(() => {
  var __webpack_modules__ = {
    4709: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.codeFrameColumns = codeFrameColumns, exports.default = function(rawLines, lineNumber, colNumber, opts = {}) {
        if (!deprecationWarningShown) {
          deprecationWarningShown = !0;
          const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
          if (process.emitWarning) process.emitWarning(message, "DeprecationWarning"); else {
            new Error(message).name = "DeprecationWarning", console.warn(new Error(message));
          }
        }
        colNumber = Math.max(colNumber, 0);
        return codeFrameColumns(rawLines, {
          start: {
            column: colNumber,
            line: lineNumber
          }
        }, opts);
      };
      var _highlight = __webpack_require__(3014);
      let deprecationWarningShown = !1;
      const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
      function codeFrameColumns(rawLines, loc, opts = {}) {
        const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts), chalk = (0, 
        _highlight.getChalk)(opts), defs = function(chalk) {
          return {
            gutter: chalk.grey,
            marker: chalk.red.bold,
            message: chalk.red.bold
          };
        }(chalk), maybeHighlight = (chalkFn, string) => highlighted ? chalkFn(string) : string, lines = rawLines.split(NEWLINE), {start, end, markerLines} = function(loc, source, opts) {
          const startLoc = Object.assign({
            column: 0,
            line: -1
          }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), {linesAbove = 2, linesBelow = 3} = opts || {}, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column;
          let start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source.length, endLine + linesBelow);
          -1 === startLine && (start = 0), -1 === endLine && (end = source.length);
          const lineDiff = endLine - startLine, markerLines = {};
          if (lineDiff) for (let i = 0; i <= lineDiff; i++) {
            const lineNumber = i + startLine;
            if (startColumn) if (0 === i) {
              const sourceLength = source[lineNumber - 1].length;
              markerLines[lineNumber] = [ startColumn, sourceLength - startColumn + 1 ];
            } else if (i === lineDiff) markerLines[lineNumber] = [ 0, endColumn ]; else {
              const sourceLength = source[lineNumber - i].length;
              markerLines[lineNumber] = [ 0, sourceLength ];
            } else markerLines[lineNumber] = !0;
          } else markerLines[startLine] = startColumn === endColumn ? !startColumn || [ startColumn, 0 ] : [ startColumn, endColumn - startColumn ];
          return {
            start,
            end,
            markerLines
          };
        }(loc, lines, opts), hasColumns = loc.start && "number" == typeof loc.start.column, numberMaxWidth = String(end).length;
        let frame = (highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines).split(NEWLINE, end).slice(start, end).map(((line, index) => {
          const number = start + 1 + index, gutter = ` ${` ${number}`.slice(-numberMaxWidth)} |`, hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
          if (hasMarker) {
            let markerLine = "";
            if (Array.isArray(hasMarker)) {
              const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
              markerLine = [ "\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers) ].join(""), 
              lastMarkerLine && opts.message && (markerLine += " " + maybeHighlight(defs.message, opts.message));
            }
            return [ maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine ].join("");
          }
          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        })).join("\n");
        return opts.message && !hasColumns && (frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`), 
        highlighted ? chalk.reset(frame) : frame;
      }
    },
    9797: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(4817);
    },
    8142: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(8392);
    },
    2624: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(5224);
    },
    772: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(4374);
    },
    4832: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(7867);
    },
    8649: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      const SPACES_RE = /^[ \t]+$/;
      exports.default = class {
        constructor(map) {
          this._map = null, this._buf = "", this._last = 0, this._queue = [], this._position = {
            line: 1,
            column: 0
          }, this._sourcePosition = {
            identifierName: void 0,
            line: void 0,
            column: void 0,
            filename: void 0,
            force: !1
          }, this._disallowedPop = null, this._map = map;
        }
        get() {
          this._flush();
          const map = this._map, result = {
            code: this._buf.trimRight(),
            decodedMap: null == map ? void 0 : map.getDecoded(),
            get map() {
              return result.map = map ? map.get() : null;
            },
            set map(value) {
              Object.defineProperty(result, "map", {
                value,
                writable: !0
              });
            },
            get rawMappings() {
              return result.rawMappings = null == map ? void 0 : map.getRawMappings();
            },
            set rawMappings(value) {
              Object.defineProperty(result, "rawMappings", {
                value,
                writable: !0
              });
            }
          };
          return result;
        }
        append(str) {
          this._flush();
          const {line, column, filename, identifierName, force} = this._sourcePosition;
          this._append(str, line, column, identifierName, filename, force);
        }
        queue(str) {
          if ("\n" === str) for (;this._queue.length > 0 && SPACES_RE.test(this._queue[0][0]); ) this._queue.shift();
          const {line, column, filename, identifierName, force} = this._sourcePosition;
          this._queue.unshift([ str, line, column, identifierName, filename, force ]);
        }
        queueIndentation(str) {
          this._queue.unshift([ str, void 0, void 0, void 0, void 0, !1 ]);
        }
        _flush() {
          let item;
          for (;item = this._queue.pop(); ) this._append(...item);
        }
        _append(str, line, column, identifierName, filename, force) {
          this._buf += str, this._last = str.charCodeAt(str.length - 1);
          let i = str.indexOf("\n"), last = 0;
          for (0 !== i && this._mark(line, column, identifierName, filename, force); -1 !== i; ) this._position.line++, 
          this._position.column = 0, last = i + 1, last < str.length && this._mark(++line, 0, identifierName, filename, force), 
          i = str.indexOf("\n", last);
          this._position.column += str.length - last;
        }
        _mark(line, column, identifierName, filename, force) {
          var _this$_map;
          null == (_this$_map = this._map) || _this$_map.mark(this._position, line, column, identifierName, filename, force);
        }
        removeTrailingNewline() {
          this._queue.length > 0 && "\n" === this._queue[0][0] && this._queue.shift();
        }
        removeLastSemicolon() {
          this._queue.length > 0 && ";" === this._queue[0][0] && this._queue.shift();
        }
        getLastChar() {
          let last;
          if (this._queue.length > 0) {
            last = this._queue[0][0].charCodeAt(0);
          } else last = this._last;
          return last;
        }
        endsWithCharAndNewline() {
          const queue = this._queue;
          if (queue.length > 0) {
            if (10 !== queue[0][0].charCodeAt(0)) return;
            if (queue.length > 1) {
              return queue[1][0].charCodeAt(0);
            }
            return this._last;
          }
        }
        hasContent() {
          return this._queue.length > 0 || !!this._last;
        }
        exactSource(loc, cb) {
          this.source("start", loc, !0), cb(), this.source("end", loc), this._disallowPop("start", loc);
        }
        source(prop, loc, force) {
          prop && !loc || this._normalizePosition(prop, loc, this._sourcePosition, force);
        }
        withSource(prop, loc, cb) {
          if (!this._map) return cb();
          const originalLine = this._sourcePosition.line, originalColumn = this._sourcePosition.column, originalFilename = this._sourcePosition.filename, originalIdentifierName = this._sourcePosition.identifierName;
          this.source(prop, loc), cb(), this._sourcePosition.force && this._sourcePosition.line === originalLine && this._sourcePosition.column === originalColumn && this._sourcePosition.filename === originalFilename || this._disallowedPop && this._disallowedPop.line === originalLine && this._disallowedPop.column === originalColumn && this._disallowedPop.filename === originalFilename || (this._sourcePosition.line = originalLine, 
          this._sourcePosition.column = originalColumn, this._sourcePosition.filename = originalFilename, 
          this._sourcePosition.identifierName = originalIdentifierName, this._sourcePosition.force = !1, 
          this._disallowedPop = null);
        }
        _disallowPop(prop, loc) {
          prop && !loc || (this._disallowedPop = this._normalizePosition(prop, loc, {
            identifierName: void 0,
            line: void 0,
            column: void 0,
            filename: void 0,
            force: !1
          }, !1));
        }
        _normalizePosition(prop, loc, targetObj, force) {
          const pos = loc ? loc[prop] : null, origLine = targetObj.line, origColumn = targetObj.column, origFilename = targetObj.filename;
          return targetObj.identifierName = "start" === prop && (null == loc ? void 0 : loc.identifierName) || null, 
          targetObj.line = null == pos ? void 0 : pos.line, targetObj.column = null == pos ? void 0 : pos.column, 
          targetObj.filename = null == loc ? void 0 : loc.filename, (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) && (targetObj.force = force), 
          targetObj;
        }
        getCurrentColumn() {
          const extra = this._queue.reduce(((acc, item) => item[0] + acc), ""), lastIndex = extra.lastIndexOf("\n");
          return -1 === lastIndex ? this._position.column + extra.length : extra.length - 1 - lastIndex;
        }
        getCurrentLine() {
          const extra = this._queue.reduce(((acc, item) => item[0] + acc), "");
          let count = 0;
          for (let i = 0; i < extra.length; i++) "\n" === extra[i] && count++;
          return this._position.line + count;
        }
      };
    },
    8516: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.BlockStatement = function(node) {
        var _node$directives;
        this.token("{"), this.printInnerComments(node);
        const hasDirectives = null == (_node$directives = node.directives) ? void 0 : _node$directives.length;
        node.body.length || hasDirectives ? (this.newline(), this.printSequence(node.directives, node, {
          indent: !0
        }), hasDirectives && this.newline(), this.printSequence(node.body, node, {
          indent: !0
        }), this.removeTrailingNewline(), this.source("end", node.loc), this.endsWith(10) || this.newline(), 
        this.rightBrace()) : (this.source("end", node.loc), this.token("}"));
      }, exports.Directive = function(node) {
        this.print(node.value, node), this.semicolon();
      }, exports.DirectiveLiteral = function(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && null != raw) return void this.token(raw);
        const {value} = node;
        if (unescapedDoubleQuoteRE.test(value)) {
          if (unescapedSingleQuoteRE.test(value)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
          this.token(`'${value}'`);
        } else this.token(`"${value}"`);
      }, exports.File = function(node) {
        node.program && this.print(node.program.interpreter, node);
        this.print(node.program, node);
      }, exports.InterpreterDirective = function(node) {
        this.token(`#!${node.value}\n`);
      }, exports.Placeholder = function(node) {
        this.token("%%"), this.print(node.name), this.token("%%"), "Statement" === node.expectedNode && this.semicolon();
      }, exports.Program = function(node) {
        this.printInnerComments(node, !1), this.printSequence(node.directives, node), node.directives && node.directives.length && this.newline();
        this.printSequence(node.body, node);
      };
      const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/, unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    },
    505: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.ClassAccessorProperty = function(node) {
        this.printJoin(node.decorators, node), this.source("end", node.key.loc), this.tsPrintClassMemberModifiers(node, !0), 
        this.word("accessor"), this.printInnerComments(node), this.space(), node.computed ? (this.token("["), 
        this.print(node.key, node), this.token("]")) : (this._variance(node), this.print(node.key, node));
        node.optional && this.token("?");
        node.definite && this.token("!");
        this.print(node.typeAnnotation, node), node.value && (this.space(), this.token("="), 
        this.space(), this.print(node.value, node));
        this.semicolon();
      }, exports.ClassBody = function(node) {
        this.token("{"), this.printInnerComments(node), 0 === node.body.length ? this.token("}") : (this.newline(), 
        this.indent(), this.printSequence(node.body, node), this.dedent(), this.endsWith(10) || this.newline(), 
        this.rightBrace());
      }, exports.ClassExpression = exports.ClassDeclaration = function(node, parent) {
        this.format.decoratorsBeforeExport && (isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent)) || this.printJoin(node.decorators, node);
        node.declare && (this.word("declare"), this.space());
        node.abstract && (this.word("abstract"), this.space());
        this.word("class"), this.printInnerComments(node), node.id && (this.space(), this.print(node.id, node));
        this.print(node.typeParameters, node), node.superClass && (this.space(), this.word("extends"), 
        this.space(), this.print(node.superClass, node), this.print(node.superTypeParameters, node));
        node.implements && (this.space(), this.word("implements"), this.space(), this.printList(node.implements, node));
        this.space(), this.print(node.body, node);
      }, exports.ClassMethod = function(node) {
        this._classMethodHead(node), this.space(), this.print(node.body, node);
      }, exports.ClassPrivateMethod = function(node) {
        this._classMethodHead(node), this.space(), this.print(node.body, node);
      }, exports.ClassPrivateProperty = function(node) {
        this.printJoin(node.decorators, node), node.static && (this.word("static"), this.space());
        this.print(node.key, node), this.print(node.typeAnnotation, node), node.value && (this.space(), 
        this.token("="), this.space(), this.print(node.value, node));
        this.semicolon();
      }, exports.ClassProperty = function(node) {
        this.printJoin(node.decorators, node), this.source("end", node.key.loc), this.tsPrintClassMemberModifiers(node, !0), 
        node.computed ? (this.token("["), this.print(node.key, node), this.token("]")) : (this._variance(node), 
        this.print(node.key, node));
        node.optional && this.token("?");
        node.definite && this.token("!");
        this.print(node.typeAnnotation, node), node.value && (this.space(), this.token("="), 
        this.space(), this.print(node.value, node));
        this.semicolon();
      }, exports.StaticBlock = function(node) {
        this.word("static"), this.space(), this.token("{"), 0 === node.body.length ? this.token("}") : (this.newline(), 
        this.printSequence(node.body, node, {
          indent: !0
        }), this.rightBrace());
      }, exports._classMethodHead = function(node) {
        this.printJoin(node.decorators, node), this.source("end", node.key.loc), this.tsPrintClassMemberModifiers(node, !1), 
        this._methodHead(node);
      };
      var _t = __webpack_require__(8218);
      const {isExportDefaultDeclaration, isExportNamedDeclaration} = _t;
    },
    6361: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = function(node, parent) {
        const parens = this.inForStatementInitCounter && "in" === node.operator && !n.needsParens(node, parent);
        parens && this.token("(");
        this.print(node.left, node), this.space(), "in" === node.operator || "instanceof" === node.operator ? this.word(node.operator) : this.token(node.operator);
        this.space(), this.print(node.right, node), parens && this.token(")");
      }, exports.AssignmentPattern = function(node) {
        this.print(node.left, node), node.left.optional && this.token("?");
        this.print(node.left.typeAnnotation, node), this.space(), this.token("="), this.space(), 
        this.print(node.right, node);
      }, exports.AwaitExpression = void 0, exports.BindExpression = function(node) {
        this.print(node.object, node), this.token("::"), this.print(node.callee, node);
      }, exports.CallExpression = function(node) {
        this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), 
        this.token("("), this.printList(node.arguments, node), this.token(")");
      }, exports.ConditionalExpression = function(node) {
        this.print(node.test, node), this.space(), this.token("?"), this.space(), this.print(node.consequent, node), 
        this.space(), this.token(":"), this.space(), this.print(node.alternate, node);
      }, exports.Decorator = function(node) {
        this.token("@");
        const {expression} = node;
        !function(node) {
          "CallExpression" === node.type && (node = node.callee);
          if ("ParenthesizedExpression" === node.type) return !1;
          return !isDecoratorMemberExpression(node);
        }(expression) ? this.print(expression, node) : (this.token("("), this.print(expression, node), 
        this.token(")"));
        this.newline();
      }, exports.DoExpression = function(node) {
        node.async && (this.word("async"), this.space());
        this.word("do"), this.space(), this.print(node.body, node);
      }, exports.EmptyStatement = function() {
        this.semicolon(!0);
      }, exports.ExpressionStatement = function(node) {
        this.print(node.expression, node), this.semicolon();
      }, exports.Import = function() {
        this.word("import");
      }, exports.MemberExpression = function(node) {
        if (this.print(node.object, node), !node.computed && isMemberExpression(node.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
        let computed = node.computed;
        isLiteral(node.property) && "number" == typeof node.property.value && (computed = !0);
        computed ? (this.token("["), this.print(node.property, node), this.token("]")) : (this.token("."), 
        this.print(node.property, node));
      }, exports.MetaProperty = function(node) {
        this.print(node.meta, node), this.token("."), this.print(node.property, node);
      }, exports.ModuleExpression = function(node) {
        this.word("module"), this.space(), this.token("{"), 0 === node.body.body.length ? this.token("}") : (this.newline(), 
        this.printSequence(node.body.body, node, {
          indent: !0
        }), this.rightBrace());
      }, exports.NewExpression = function(node, parent) {
        if (this.word("new"), this.space(), this.print(node.callee, node), this.format.minified && 0 === node.arguments.length && !node.optional && !isCallExpression(parent, {
          callee: node
        }) && !isMemberExpression(parent) && !isNewExpression(parent)) return;
        this.print(node.typeArguments, node), this.print(node.typeParameters, node), node.optional && this.token("?.");
        this.token("("), this.printList(node.arguments, node), this.token(")");
      }, exports.OptionalCallExpression = function(node) {
        this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), 
        node.optional && this.token("?.");
        this.token("("), this.printList(node.arguments, node), this.token(")");
      }, exports.OptionalMemberExpression = function(node) {
        if (this.print(node.object, node), !node.computed && isMemberExpression(node.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
        let computed = node.computed;
        isLiteral(node.property) && "number" == typeof node.property.value && (computed = !0);
        node.optional && this.token("?.");
        computed ? (this.token("["), this.print(node.property, node), this.token("]")) : (node.optional || this.token("."), 
        this.print(node.property, node));
      }, exports.ParenthesizedExpression = function(node) {
        this.token("("), this.print(node.expression, node), this.token(")");
      }, exports.PrivateName = function(node) {
        this.token("#"), this.print(node.id, node);
      }, exports.SequenceExpression = function(node) {
        this.printList(node.expressions, node);
      }, exports.Super = function() {
        this.word("super");
      }, exports.ThisExpression = function() {
        this.word("this");
      }, exports.UnaryExpression = function(node) {
        "void" === node.operator || "delete" === node.operator || "typeof" === node.operator || "throw" === node.operator ? (this.word(node.operator), 
        this.space()) : this.token(node.operator);
        this.print(node.argument, node);
      }, exports.UpdateExpression = function(node) {
        node.prefix ? (this.token(node.operator), this.print(node.argument, node)) : (this.startTerminatorless(!0), 
        this.print(node.argument, node), this.endTerminatorless(), this.token(node.operator));
      }, exports.V8IntrinsicIdentifier = function(node) {
        this.token("%"), this.word(node.name);
      }, exports.YieldExpression = void 0;
      var _t = __webpack_require__(8218), n = __webpack_require__(2866);
      const {isCallExpression, isLiteral, isMemberExpression, isNewExpression} = _t;
      function isDecoratorMemberExpression(node) {
        switch (node.type) {
         case "Identifier":
          return !0;

         case "MemberExpression":
          return !node.computed && "Identifier" === node.property.type && isDecoratorMemberExpression(node.object);

         default:
          return !1;
        }
      }
      function buildYieldAwait(keyword) {
        return function(node) {
          if (this.word(keyword), node.delegate && this.token("*"), node.argument) {
            this.space();
            const terminatorState = this.startTerminatorless();
            this.print(node.argument, node), this.endTerminatorless(terminatorState);
          }
        };
      }
      const YieldExpression = buildYieldAwait("yield");
      exports.YieldExpression = YieldExpression;
      const AwaitExpression = buildYieldAwait("await");
      exports.AwaitExpression = AwaitExpression;
    },
    8076: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.AnyTypeAnnotation = function() {
        this.word("any");
      }, exports.ArrayTypeAnnotation = function(node) {
        this.print(node.elementType, node), this.token("["), this.token("]");
      }, exports.BooleanLiteralTypeAnnotation = function(node) {
        this.word(node.value ? "true" : "false");
      }, exports.BooleanTypeAnnotation = function() {
        this.word("boolean");
      }, exports.DeclareClass = function(node, parent) {
        isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
        this.word("class"), this.space(), this._interfaceish(node);
      }, exports.DeclareExportAllDeclaration = function() {
        this.word("declare"), this.space(), _modules.ExportAllDeclaration.apply(this, arguments);
      }, exports.DeclareExportDeclaration = function(node) {
        this.word("declare"), this.space(), this.word("export"), this.space(), node.default && (this.word("default"), 
        this.space());
        FlowExportDeclaration.apply(this, arguments);
      }, exports.DeclareFunction = function(node, parent) {
        isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
        this.word("function"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation.typeAnnotation, node), 
        node.predicate && (this.space(), this.print(node.predicate, node));
        this.semicolon();
      }, exports.DeclareInterface = function(node) {
        this.word("declare"), this.space(), this.InterfaceDeclaration(node);
      }, exports.DeclareModule = function(node) {
        this.word("declare"), this.space(), this.word("module"), this.space(), this.print(node.id, node), 
        this.space(), this.print(node.body, node);
      }, exports.DeclareModuleExports = function(node) {
        this.word("declare"), this.space(), this.word("module"), this.token("."), this.word("exports"), 
        this.print(node.typeAnnotation, node);
      }, exports.DeclareOpaqueType = function(node, parent) {
        isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
        this.OpaqueType(node);
      }, exports.DeclareTypeAlias = function(node) {
        this.word("declare"), this.space(), this.TypeAlias(node);
      }, exports.DeclareVariable = function(node, parent) {
        isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
        this.word("var"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation, node), 
        this.semicolon();
      }, exports.DeclaredPredicate = function(node) {
        this.token("%"), this.word("checks"), this.token("("), this.print(node.value, node), 
        this.token(")");
      }, exports.EmptyTypeAnnotation = function() {
        this.word("empty");
      }, exports.EnumBooleanBody = function(node) {
        const {explicitType} = node;
        enumExplicitType(this, "boolean", explicitType), enumBody(this, node);
      }, exports.EnumBooleanMember = function(node) {
        enumInitializedMember(this, node);
      }, exports.EnumDeclaration = function(node) {
        const {id, body} = node;
        this.word("enum"), this.space(), this.print(id, node), this.print(body, node);
      }, exports.EnumDefaultedMember = function(node) {
        const {id} = node;
        this.print(id, node), this.token(",");
      }, exports.EnumNumberBody = function(node) {
        const {explicitType} = node;
        enumExplicitType(this, "number", explicitType), enumBody(this, node);
      }, exports.EnumNumberMember = function(node) {
        enumInitializedMember(this, node);
      }, exports.EnumStringBody = function(node) {
        const {explicitType} = node;
        enumExplicitType(this, "string", explicitType), enumBody(this, node);
      }, exports.EnumStringMember = function(node) {
        enumInitializedMember(this, node);
      }, exports.EnumSymbolBody = function(node) {
        enumExplicitType(this, "symbol", !0), enumBody(this, node);
      }, exports.ExistsTypeAnnotation = function() {
        this.token("*");
      }, exports.FunctionTypeAnnotation = function(node, parent) {
        this.print(node.typeParameters, node), this.token("("), node.this && (this.word("this"), 
        this.token(":"), this.space(), this.print(node.this.typeAnnotation, node), (node.params.length || node.rest) && (this.token(","), 
        this.space()));
        this.printList(node.params, node), node.rest && (node.params.length && (this.token(","), 
        this.space()), this.token("..."), this.print(node.rest, node));
        this.token(")"), parent && ("ObjectTypeCallProperty" === parent.type || "DeclareFunction" === parent.type || "ObjectTypeProperty" === parent.type && parent.method) ? this.token(":") : (this.space(), 
        this.token("=>"));
        this.space(), this.print(node.returnType, node);
      }, exports.FunctionTypeParam = function(node) {
        this.print(node.name, node), node.optional && this.token("?");
        node.name && (this.token(":"), this.space());
        this.print(node.typeAnnotation, node);
      }, exports.IndexedAccessType = function(node) {
        this.print(node.objectType, node), this.token("["), this.print(node.indexType, node), 
        this.token("]");
      }, exports.InferredPredicate = function() {
        this.token("%"), this.word("checks");
      }, exports.InterfaceDeclaration = function(node) {
        this.word("interface"), this.space(), this._interfaceish(node);
      }, exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = function(node) {
        this.print(node.id, node), this.print(node.typeParameters, node);
      }, exports.InterfaceTypeAnnotation = function(node) {
        this.word("interface"), node.extends && node.extends.length && (this.space(), this.word("extends"), 
        this.space(), this.printList(node.extends, node));
        this.space(), this.print(node.body, node);
      }, exports.IntersectionTypeAnnotation = function(node) {
        this.printJoin(node.types, node, {
          separator: andSeparator
        });
      }, exports.MixedTypeAnnotation = function() {
        this.word("mixed");
      }, exports.NullLiteralTypeAnnotation = function() {
        this.word("null");
      }, exports.NullableTypeAnnotation = function(node) {
        this.token("?"), this.print(node.typeAnnotation, node);
      }, Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _types2.NumericLiteral;
        }
      }), exports.NumberTypeAnnotation = function() {
        this.word("number");
      }, exports.ObjectTypeAnnotation = function(node) {
        node.exact ? this.token("{|") : this.token("{");
        const props = [ ...node.properties, ...node.callProperties || [], ...node.indexers || [], ...node.internalSlots || [] ];
        props.length && (this.space(), this.printJoin(props, node, {
          addNewlines(leading) {
            if (leading && !props[0]) return 1;
          },
          indent: !0,
          statement: !0,
          iterator: () => {
            (1 !== props.length || node.inexact) && (this.token(","), this.space());
          }
        }), this.space());
        node.inexact && (this.indent(), this.token("..."), props.length && this.newline(), 
        this.dedent());
        node.exact ? this.token("|}") : this.token("}");
      }, exports.ObjectTypeCallProperty = function(node) {
        node.static && (this.word("static"), this.space());
        this.print(node.value, node);
      }, exports.ObjectTypeIndexer = function(node) {
        node.static && (this.word("static"), this.space());
        this._variance(node), this.token("["), node.id && (this.print(node.id, node), this.token(":"), 
        this.space());
        this.print(node.key, node), this.token("]"), this.token(":"), this.space(), this.print(node.value, node);
      }, exports.ObjectTypeInternalSlot = function(node) {
        node.static && (this.word("static"), this.space());
        this.token("["), this.token("["), this.print(node.id, node), this.token("]"), this.token("]"), 
        node.optional && this.token("?");
        node.method || (this.token(":"), this.space());
        this.print(node.value, node);
      }, exports.ObjectTypeProperty = function(node) {
        node.proto && (this.word("proto"), this.space());
        node.static && (this.word("static"), this.space());
        "get" !== node.kind && "set" !== node.kind || (this.word(node.kind), this.space());
        this._variance(node), this.print(node.key, node), node.optional && this.token("?");
        node.method || (this.token(":"), this.space());
        this.print(node.value, node);
      }, exports.ObjectTypeSpreadProperty = function(node) {
        this.token("..."), this.print(node.argument, node);
      }, exports.OpaqueType = function(node) {
        this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(node.id, node), 
        this.print(node.typeParameters, node), node.supertype && (this.token(":"), this.space(), 
        this.print(node.supertype, node));
        node.impltype && (this.space(), this.token("="), this.space(), this.print(node.impltype, node));
        this.semicolon();
      }, exports.OptionalIndexedAccessType = function(node) {
        this.print(node.objectType, node), node.optional && this.token("?.");
        this.token("["), this.print(node.indexType, node), this.token("]");
      }, exports.QualifiedTypeIdentifier = function(node) {
        this.print(node.qualification, node), this.token("."), this.print(node.id, node);
      }, Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _types2.StringLiteral;
        }
      }), exports.StringTypeAnnotation = function() {
        this.word("string");
      }, exports.SymbolTypeAnnotation = function() {
        this.word("symbol");
      }, exports.ThisTypeAnnotation = function() {
        this.word("this");
      }, exports.TupleTypeAnnotation = function(node) {
        this.token("["), this.printList(node.types, node), this.token("]");
      }, exports.TypeAlias = function(node) {
        this.word("type"), this.space(), this.print(node.id, node), this.print(node.typeParameters, node), 
        this.space(), this.token("="), this.space(), this.print(node.right, node), this.semicolon();
      }, exports.TypeAnnotation = function(node) {
        this.token(":"), this.space(), node.optional && this.token("?");
        this.print(node.typeAnnotation, node);
      }, exports.TypeCastExpression = function(node) {
        this.token("("), this.print(node.expression, node), this.print(node.typeAnnotation, node), 
        this.token(")");
      }, exports.TypeParameter = function(node) {
        this._variance(node), this.word(node.name), node.bound && this.print(node.bound, node);
        node.default && (this.space(), this.token("="), this.space(), this.print(node.default, node));
      }, exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = function(node) {
        this.token("<"), this.printList(node.params, node, {}), this.token(">");
      }, exports.TypeofTypeAnnotation = function(node) {
        this.word("typeof"), this.space(), this.print(node.argument, node);
      }, exports.UnionTypeAnnotation = function(node) {
        this.printJoin(node.types, node, {
          separator: orSeparator
        });
      }, exports.Variance = function(node) {
        "plus" === node.kind ? this.token("+") : this.token("-");
      }, exports.VoidTypeAnnotation = function() {
        this.word("void");
      }, exports._interfaceish = function(node) {
        var _node$extends;
        this.print(node.id, node), this.print(node.typeParameters, node), null != (_node$extends = node.extends) && _node$extends.length && (this.space(), 
        this.word("extends"), this.space(), this.printList(node.extends, node));
        node.mixins && node.mixins.length && (this.space(), this.word("mixins"), this.space(), 
        this.printList(node.mixins, node));
        node.implements && node.implements.length && (this.space(), this.word("implements"), 
        this.space(), this.printList(node.implements, node));
        this.space(), this.print(node.body, node);
      }, exports._variance = function(node) {
        node.variance && ("plus" === node.variance.kind ? this.token("+") : "minus" === node.variance.kind && this.token("-"));
      };
      var _t = __webpack_require__(8218), _modules = __webpack_require__(7064), _types2 = __webpack_require__(5718);
      const {isDeclareExportDeclaration, isStatement} = _t;
      function enumExplicitType(context, name, hasExplicitType) {
        hasExplicitType && (context.space(), context.word("of"), context.space(), context.word(name)), 
        context.space();
      }
      function enumBody(context, node) {
        const {members} = node;
        context.token("{"), context.indent(), context.newline();
        for (const member of members) context.print(member, node), context.newline();
        node.hasUnknownMembers && (context.token("..."), context.newline()), context.dedent(), 
        context.token("}");
      }
      function enumInitializedMember(context, node) {
        const {id, init} = node;
        context.print(id, node), context.space(), context.token("="), context.space(), context.print(init, node), 
        context.token(",");
      }
      function FlowExportDeclaration(node) {
        if (node.declaration) {
          const declar = node.declaration;
          this.print(declar, node), isStatement(declar) || this.semicolon();
        } else this.token("{"), node.specifiers.length && (this.space(), this.printList(node.specifiers, node), 
        this.space()), this.token("}"), node.source && (this.space(), this.word("from"), 
        this.space(), this.print(node.source, node)), this.semicolon();
      }
      function andSeparator() {
        this.space(), this.token("&"), this.space();
      }
      function orSeparator() {
        this.space(), this.token("|"), this.space();
      }
    },
    8217: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var _templateLiterals = __webpack_require__(2347);
      Object.keys(_templateLiterals).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _templateLiterals[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _templateLiterals[key];
          }
        }));
      }));
      var _expressions = __webpack_require__(6361);
      Object.keys(_expressions).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _expressions[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _expressions[key];
          }
        }));
      }));
      var _statements = __webpack_require__(6787);
      Object.keys(_statements).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _statements[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _statements[key];
          }
        }));
      }));
      var _classes = __webpack_require__(505);
      Object.keys(_classes).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _classes[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _classes[key];
          }
        }));
      }));
      var _methods = __webpack_require__(624);
      Object.keys(_methods).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _methods[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _methods[key];
          }
        }));
      }));
      var _modules = __webpack_require__(7064);
      Object.keys(_modules).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _modules[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _modules[key];
          }
        }));
      }));
      var _types = __webpack_require__(5718);
      Object.keys(_types).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _types[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _types[key];
          }
        }));
      }));
      var _flow = __webpack_require__(8076);
      Object.keys(_flow).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _flow[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _flow[key];
          }
        }));
      }));
      var _base = __webpack_require__(8516);
      Object.keys(_base).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _base[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _base[key];
          }
        }));
      }));
      var _jsx = __webpack_require__(9598);
      Object.keys(_jsx).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _jsx[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _jsx[key];
          }
        }));
      }));
      var _typescript = __webpack_require__(2043);
      Object.keys(_typescript).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (key in exports && exports[key] === _typescript[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _typescript[key];
          }
        }));
      }));
    },
    9598: (__unused_webpack_module, exports) => {
      "use strict";
      function spaceSeparator() {
        this.space();
      }
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.JSXAttribute = function(node) {
        this.print(node.name, node), node.value && (this.token("="), this.print(node.value, node));
      }, exports.JSXClosingElement = function(node) {
        this.token("</"), this.print(node.name, node), this.token(">");
      }, exports.JSXClosingFragment = function() {
        this.token("</"), this.token(">");
      }, exports.JSXElement = function(node) {
        const open = node.openingElement;
        if (this.print(open, node), open.selfClosing) return;
        this.indent();
        for (const child of node.children) this.print(child, node);
        this.dedent(), this.print(node.closingElement, node);
      }, exports.JSXEmptyExpression = function(node) {
        this.printInnerComments(node);
      }, exports.JSXExpressionContainer = function(node) {
        this.token("{"), this.print(node.expression, node), this.token("}");
      }, exports.JSXFragment = function(node) {
        this.print(node.openingFragment, node), this.indent();
        for (const child of node.children) this.print(child, node);
        this.dedent(), this.print(node.closingFragment, node);
      }, exports.JSXIdentifier = function(node) {
        this.word(node.name);
      }, exports.JSXMemberExpression = function(node) {
        this.print(node.object, node), this.token("."), this.print(node.property, node);
      }, exports.JSXNamespacedName = function(node) {
        this.print(node.namespace, node), this.token(":"), this.print(node.name, node);
      }, exports.JSXOpeningElement = function(node) {
        this.token("<"), this.print(node.name, node), this.print(node.typeParameters, node), 
        node.attributes.length > 0 && (this.space(), this.printJoin(node.attributes, node, {
          separator: spaceSeparator
        }));
        node.selfClosing ? (this.space(), this.token("/>")) : this.token(">");
      }, exports.JSXOpeningFragment = function() {
        this.token("<"), this.token(">");
      }, exports.JSXSpreadAttribute = function(node) {
        this.token("{"), this.token("..."), this.print(node.argument, node), this.token("}");
      }, exports.JSXSpreadChild = function(node) {
        this.token("{"), this.token("..."), this.print(node.expression, node), this.token("}");
      }, exports.JSXText = function(node) {
        const raw = this.getPossibleRaw(node);
        null != raw ? this.token(raw) : this.token(node.value);
      };
    },
    624: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.ArrowFunctionExpression = function(node) {
        node.async && (this.word("async"), this.space());
        const firstParam = node.params[0];
        this.format.retainLines || this.format.auxiliaryCommentBefore || this.format.auxiliaryCommentAfter || 1 !== node.params.length || !isIdentifier(firstParam) || function(node, param) {
          var _param$leadingComment, _param$trailingCommen;
          return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || null != (_param$leadingComment = param.leadingComments) && _param$leadingComment.length || null != (_param$trailingCommen = param.trailingComments) && _param$trailingCommen.length);
        }(node, firstParam) ? this._params(node) : this.print(firstParam, node);
        this._predicate(node), this.space(), this.token("=>"), this.space(), this.print(node.body, node);
      }, exports.FunctionDeclaration = exports.FunctionExpression = function(node) {
        this._functionHead(node), this.space(), this.print(node.body, node);
      }, exports._functionHead = function(node) {
        node.async && (this.word("async"), this.space());
        this.word("function"), node.generator && this.token("*");
        this.printInnerComments(node), this.space(), node.id && this.print(node.id, node);
        this._params(node), this._predicate(node);
      }, exports._methodHead = function(node) {
        const kind = node.kind, key = node.key;
        "get" !== kind && "set" !== kind || (this.word(kind), this.space());
        node.async && (this._catchUp("start", key.loc), this.word("async"), this.space());
        "method" !== kind && "init" !== kind || node.generator && this.token("*");
        node.computed ? (this.token("["), this.print(key, node), this.token("]")) : this.print(key, node);
        node.optional && this.token("?");
        this._params(node);
      }, exports._param = function(parameter, parent) {
        this.printJoin(parameter.decorators, parameter), this.print(parameter, parent), 
        parameter.optional && this.token("?");
        this.print(parameter.typeAnnotation, parameter);
      }, exports._parameters = function(parameters, parent) {
        for (let i = 0; i < parameters.length; i++) this._param(parameters[i], parent), 
        i < parameters.length - 1 && (this.token(","), this.space());
      }, exports._params = function(node) {
        this.print(node.typeParameters, node), this.token("("), this._parameters(node.params, node), 
        this.token(")"), this.print(node.returnType, node);
      }, exports._predicate = function(node) {
        node.predicate && (node.returnType || this.token(":"), this.space(), this.print(node.predicate, node));
      };
      var _t = __webpack_require__(8218);
      const {isIdentifier} = _t;
    },
    7064: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.ExportAllDeclaration = function(node) {
        this.word("export"), this.space(), "type" === node.exportKind && (this.word("type"), 
        this.space());
        this.token("*"), this.space(), this.word("from"), this.space(), this.print(node.source, node), 
        this.printAssertions(node), this.semicolon();
      }, exports.ExportDefaultDeclaration = function(node) {
        this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration) && this.printJoin(node.declaration.decorators, node);
        this.word("export"), this.space(), this.word("default"), this.space(), ExportDeclaration.apply(this, arguments);
      }, exports.ExportDefaultSpecifier = function(node) {
        this.print(node.exported, node);
      }, exports.ExportNamedDeclaration = function(node) {
        this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration) && this.printJoin(node.declaration.decorators, node);
        this.word("export"), this.space(), ExportDeclaration.apply(this, arguments);
      }, exports.ExportNamespaceSpecifier = function(node) {
        this.token("*"), this.space(), this.word("as"), this.space(), this.print(node.exported, node);
      }, exports.ExportSpecifier = function(node) {
        "type" === node.exportKind && (this.word("type"), this.space());
        this.print(node.local, node), node.exported && node.local.name !== node.exported.name && (this.space(), 
        this.word("as"), this.space(), this.print(node.exported, node));
      }, exports.ImportAttribute = function(node) {
        this.print(node.key), this.token(":"), this.space(), this.print(node.value);
      }, exports.ImportDeclaration = function(node) {
        this.word("import"), this.space();
        const isTypeKind = "type" === node.importKind || "typeof" === node.importKind;
        isTypeKind && (this.word(node.importKind), this.space());
        const specifiers = node.specifiers.slice(0), hasSpecifiers = !!specifiers.length;
        for (;hasSpecifiers; ) {
          const first = specifiers[0];
          if (!isImportDefaultSpecifier(first) && !isImportNamespaceSpecifier(first)) break;
          this.print(specifiers.shift(), node), specifiers.length && (this.token(","), this.space());
        }
        specifiers.length ? (this.token("{"), this.space(), this.printList(specifiers, node), 
        this.space(), this.token("}")) : isTypeKind && !hasSpecifiers && (this.token("{"), 
        this.token("}"));
        (hasSpecifiers || isTypeKind) && (this.space(), this.word("from"), this.space());
        var _node$attributes;
        this.print(node.source, node), this.printAssertions(node), null != (_node$attributes = node.attributes) && _node$attributes.length && (this.space(), 
        this.word("with"), this.space(), this.printList(node.attributes, node));
        this.semicolon();
      }, exports.ImportDefaultSpecifier = function(node) {
        this.print(node.local, node);
      }, exports.ImportNamespaceSpecifier = function(node) {
        this.token("*"), this.space(), this.word("as"), this.space(), this.print(node.local, node);
      }, exports.ImportSpecifier = function(node) {
        "type" !== node.importKind && "typeof" !== node.importKind || (this.word(node.importKind), 
        this.space());
        this.print(node.imported, node), node.local && node.local.name !== node.imported.name && (this.space(), 
        this.word("as"), this.space(), this.print(node.local, node));
      };
      var _t = __webpack_require__(8218);
      const {isClassDeclaration, isExportDefaultSpecifier, isExportNamespaceSpecifier, isImportDefaultSpecifier, isImportNamespaceSpecifier, isStatement} = _t;
      function ExportDeclaration(node) {
        if (node.declaration) {
          const declar = node.declaration;
          this.print(declar, node), isStatement(declar) || this.semicolon();
        } else {
          "type" === node.exportKind && (this.word("type"), this.space());
          const specifiers = node.specifiers.slice(0);
          let hasSpecial = !1;
          for (;;) {
            const first = specifiers[0];
            if (!isExportDefaultSpecifier(first) && !isExportNamespaceSpecifier(first)) break;
            hasSpecial = !0, this.print(specifiers.shift(), node), specifiers.length && (this.token(","), 
            this.space());
          }
          (specifiers.length || !specifiers.length && !hasSpecial) && (this.token("{"), specifiers.length && (this.space(), 
          this.printList(specifiers, node), this.space()), this.token("}")), node.source && (this.space(), 
          this.word("from"), this.space(), this.print(node.source, node), this.printAssertions(node)), 
          this.semicolon();
        }
      }
    },
    6787: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.BreakStatement = void 0, exports.CatchClause = function(node) {
        this.word("catch"), this.space(), node.param && (this.token("("), this.print(node.param, node), 
        this.print(node.param.typeAnnotation, node), this.token(")"), this.space());
        this.print(node.body, node);
      }, exports.ContinueStatement = void 0, exports.DebuggerStatement = function() {
        this.word("debugger"), this.semicolon();
      }, exports.DoWhileStatement = function(node) {
        this.word("do"), this.space(), this.print(node.body, node), this.space(), this.word("while"), 
        this.space(), this.token("("), this.print(node.test, node), this.token(")"), this.semicolon();
      }, exports.ForOfStatement = exports.ForInStatement = void 0, exports.ForStatement = function(node) {
        this.word("for"), this.space(), this.token("("), this.inForStatementInitCounter++, 
        this.print(node.init, node), this.inForStatementInitCounter--, this.token(";"), 
        node.test && (this.space(), this.print(node.test, node));
        this.token(";"), node.update && (this.space(), this.print(node.update, node));
        this.token(")"), this.printBlock(node);
      }, exports.IfStatement = function(node) {
        this.word("if"), this.space(), this.token("("), this.print(node.test, node), this.token(")"), 
        this.space();
        const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
        needsBlock && (this.token("{"), this.newline(), this.indent());
        this.printAndIndentOnComments(node.consequent, node), needsBlock && (this.dedent(), 
        this.newline(), this.token("}"));
        node.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), 
        this.printAndIndentOnComments(node.alternate, node));
      }, exports.LabeledStatement = function(node) {
        this.print(node.label, node), this.token(":"), this.space(), this.print(node.body, node);
      }, exports.ReturnStatement = void 0, exports.SwitchCase = function(node) {
        node.test ? (this.word("case"), this.space(), this.print(node.test, node), this.token(":")) : (this.word("default"), 
        this.token(":"));
        node.consequent.length && (this.newline(), this.printSequence(node.consequent, node, {
          indent: !0
        }));
      }, exports.SwitchStatement = function(node) {
        this.word("switch"), this.space(), this.token("("), this.print(node.discriminant, node), 
        this.token(")"), this.space(), this.token("{"), this.printSequence(node.cases, node, {
          indent: !0,
          addNewlines(leading, cas) {
            if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
          }
        }), this.token("}");
      }, exports.ThrowStatement = void 0, exports.TryStatement = function(node) {
        this.word("try"), this.space(), this.print(node.block, node), this.space(), node.handlers ? this.print(node.handlers[0], node) : this.print(node.handler, node);
        node.finalizer && (this.space(), this.word("finally"), this.space(), this.print(node.finalizer, node));
      }, exports.VariableDeclaration = function(node, parent) {
        node.declare && (this.word("declare"), this.space());
        this.word(node.kind), this.space();
        let separator, hasInits = !1;
        if (!isFor(parent)) for (const declar of node.declarations) declar.init && (hasInits = !0);
        hasInits && (separator = "const" === node.kind ? constDeclarationIndent : variableDeclarationIndent);
        if (this.printList(node.declarations, node, {
          separator
        }), isFor(parent)) if (isForStatement(parent)) {
          if (parent.init === node) return;
        } else if (parent.left === node) return;
        this.semicolon();
      }, exports.VariableDeclarator = function(node) {
        this.print(node.id, node), node.definite && this.token("!");
        this.print(node.id.typeAnnotation, node), node.init && (this.space(), this.token("="), 
        this.space(), this.print(node.init, node));
      }, exports.WhileStatement = function(node) {
        this.word("while"), this.space(), this.token("("), this.print(node.test, node), 
        this.token(")"), this.printBlock(node);
      }, exports.WithStatement = function(node) {
        this.word("with"), this.space(), this.token("("), this.print(node.object, node), 
        this.token(")"), this.printBlock(node);
      };
      var _t = __webpack_require__(8218);
      const {isFor, isForStatement, isIfStatement, isStatement} = _t;
      function getLastStatement(statement) {
        return isStatement(statement.body) ? getLastStatement(statement.body) : statement;
      }
      const buildForXStatement = function(op) {
        return function(node) {
          this.word("for"), this.space(), "of" === op && node.await && (this.word("await"), 
          this.space()), this.token("("), this.print(node.left, node), this.space(), this.word(op), 
          this.space(), this.print(node.right, node), this.token(")"), this.printBlock(node);
        };
      }, ForInStatement = buildForXStatement("in");
      exports.ForInStatement = ForInStatement;
      const ForOfStatement = buildForXStatement("of");
      function buildLabelStatement(prefix, key = "label") {
        return function(node) {
          this.word(prefix);
          const label = node[key];
          if (label) {
            this.space();
            const isLabel = "label" == key, terminatorState = this.startTerminatorless(isLabel);
            this.print(label, node), this.endTerminatorless(terminatorState);
          }
          this.semicolon();
        };
      }
      exports.ForOfStatement = ForOfStatement;
      const ContinueStatement = buildLabelStatement("continue");
      exports.ContinueStatement = ContinueStatement;
      const ReturnStatement = buildLabelStatement("return", "argument");
      exports.ReturnStatement = ReturnStatement;
      const BreakStatement = buildLabelStatement("break");
      exports.BreakStatement = BreakStatement;
      const ThrowStatement = buildLabelStatement("throw", "argument");
      function variableDeclarationIndent() {
        if (this.token(","), this.newline(), this.endsWith(10)) for (let i = 0; i < 4; i++) this.space(!0);
      }
      function constDeclarationIndent() {
        if (this.token(","), this.newline(), this.endsWith(10)) for (let i = 0; i < 6; i++) this.space(!0);
      }
      exports.ThrowStatement = ThrowStatement;
    },
    2347: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.TaggedTemplateExpression = function(node) {
        this.print(node.tag, node), this.print(node.typeParameters, node), this.print(node.quasi, node);
      }, exports.TemplateElement = function(node, parent) {
        const isFirst = parent.quasis[0] === node, isLast = parent.quasis[parent.quasis.length - 1] === node, value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
        this.token(value);
      }, exports.TemplateLiteral = function(node) {
        const quasis = node.quasis;
        for (let i = 0; i < quasis.length; i++) this.print(quasis[i], node), i + 1 < quasis.length && this.print(node.expressions[i], node);
      };
    },
    5718: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.ArgumentPlaceholder = function() {
        this.token("?");
      }, exports.ArrayPattern = exports.ArrayExpression = function(node) {
        const elems = node.elements, len = elems.length;
        this.token("["), this.printInnerComments(node);
        for (let i = 0; i < elems.length; i++) {
          const elem = elems[i];
          elem ? (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.token(",")) : this.token(",");
        }
        this.token("]");
      }, exports.BigIntLiteral = function(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && null != raw) return void this.word(raw);
        this.word(node.value + "n");
      }, exports.BooleanLiteral = function(node) {
        this.word(node.value ? "true" : "false");
      }, exports.DecimalLiteral = function(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && null != raw) return void this.word(raw);
        this.word(node.value + "m");
      }, exports.Identifier = function(node) {
        this.exactSource(node.loc, (() => {
          this.word(node.name);
        }));
      }, exports.NullLiteral = function() {
        this.word("null");
      }, exports.NumericLiteral = function(node) {
        const raw = this.getPossibleRaw(node), opts = this.format.jsescOption, value = node.value + "";
        opts.numbers ? this.number(_jsesc(node.value, opts)) : null == raw ? this.number(value) : this.format.minified ? this.number(raw.length < value.length ? raw : value) : this.number(raw);
      }, exports.ObjectPattern = exports.ObjectExpression = function(node) {
        const props = node.properties;
        this.token("{"), this.printInnerComments(node), props.length && (this.space(), this.printList(props, node, {
          indent: !0,
          statement: !0
        }), this.space());
        this.token("}");
      }, exports.ObjectMethod = function(node) {
        this.printJoin(node.decorators, node), this._methodHead(node), this.space(), this.print(node.body, node);
      }, exports.ObjectProperty = function(node) {
        if (this.printJoin(node.decorators, node), node.computed) this.token("["), this.print(node.key, node), 
        this.token("]"); else {
          if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) return void this.print(node.value, node);
          if (this.print(node.key, node), node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) return;
        }
        this.token(":"), this.space(), this.print(node.value, node);
      }, exports.PipelineBareFunction = function(node) {
        this.print(node.callee, node);
      }, exports.PipelinePrimaryTopicReference = function() {
        this.token("#");
      }, exports.PipelineTopicExpression = function(node) {
        this.print(node.expression, node);
      }, exports.RecordExpression = function(node) {
        const props = node.properties;
        let startToken, endToken;
        if ("bar" === this.format.recordAndTupleSyntaxType) startToken = "{|", endToken = "|}"; else {
          if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
          startToken = "#{", endToken = "}";
        }
        this.token(startToken), this.printInnerComments(node), props.length && (this.space(), 
        this.printList(props, node, {
          indent: !0,
          statement: !0
        }), this.space());
        this.token(endToken);
      }, exports.RegExpLiteral = function(node) {
        this.word(`/${node.pattern}/${node.flags}`);
      }, exports.SpreadElement = exports.RestElement = function(node) {
        this.token("..."), this.print(node.argument, node);
      }, exports.StringLiteral = function(node) {
        const raw = this.getPossibleRaw(node);
        if (!this.format.minified && null != raw) return void this.token(raw);
        const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
          json: !0
        }));
        return this.token(val);
      }, exports.TopicReference = function() {
        const {topicToken} = this.format;
        if (!validTopicTokenSet.has(topicToken)) {
          const givenTopicTokenJSON = JSON.stringify(topicToken), validTopics = Array.from(validTopicTokenSet, (v => JSON.stringify(v)));
          throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
        }
        this.token(topicToken);
      }, exports.TupleExpression = function(node) {
        const elems = node.elements, len = elems.length;
        let startToken, endToken;
        if ("bar" === this.format.recordAndTupleSyntaxType) startToken = "[|", endToken = "|]"; else {
          if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
          startToken = "#[", endToken = "]";
        }
        this.token(startToken), this.printInnerComments(node);
        for (let i = 0; i < elems.length; i++) {
          const elem = elems[i];
          elem && (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.token(","));
        }
        this.token(endToken);
      };
      var _t = __webpack_require__(8218), _jsesc = __webpack_require__(3312);
      const {isAssignmentPattern, isIdentifier} = _t;
      const validTopicTokenSet = new Set([ "^^", "@@", "^", "%", "#" ]);
    },
    2043: (__unused_webpack_module, exports) => {
      "use strict";
      function tokenIfPlusMinus(self, tok) {
        !0 !== tok && self.token(tok);
      }
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.TSAnyKeyword = function() {
        this.word("any");
      }, exports.TSArrayType = function(node) {
        this.print(node.elementType, node), this.token("[]");
      }, exports.TSAsExpression = function(node) {
        const {expression, typeAnnotation} = node;
        this.print(expression, node), this.space(), this.word("as"), this.space(), this.print(typeAnnotation, node);
      }, exports.TSBigIntKeyword = function() {
        this.word("bigint");
      }, exports.TSBooleanKeyword = function() {
        this.word("boolean");
      }, exports.TSCallSignatureDeclaration = function(node) {
        this.tsPrintSignatureDeclarationBase(node), this.token(";");
      }, exports.TSConditionalType = function(node) {
        this.print(node.checkType), this.space(), this.word("extends"), this.space(), this.print(node.extendsType), 
        this.space(), this.token("?"), this.space(), this.print(node.trueType), this.space(), 
        this.token(":"), this.space(), this.print(node.falseType);
      }, exports.TSConstructSignatureDeclaration = function(node) {
        this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(node), this.token(";");
      }, exports.TSConstructorType = function(node) {
        node.abstract && (this.word("abstract"), this.space());
        this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(node);
      }, exports.TSDeclareFunction = function(node) {
        node.declare && (this.word("declare"), this.space());
        this._functionHead(node), this.token(";");
      }, exports.TSDeclareMethod = function(node) {
        this._classMethodHead(node), this.token(";");
      }, exports.TSEnumDeclaration = function(node) {
        const {declare, const: isConst, id, members} = node;
        declare && (this.word("declare"), this.space());
        isConst && (this.word("const"), this.space());
        this.word("enum"), this.space(), this.print(id, node), this.space(), this.tsPrintBraced(members, node);
      }, exports.TSEnumMember = function(node) {
        const {id, initializer} = node;
        this.print(id, node), initializer && (this.space(), this.token("="), this.space(), 
        this.print(initializer, node));
        this.token(",");
      }, exports.TSExportAssignment = function(node) {
        this.word("export"), this.space(), this.token("="), this.space(), this.print(node.expression, node), 
        this.token(";");
      }, exports.TSExpressionWithTypeArguments = function(node) {
        this.print(node.expression, node), this.print(node.typeParameters, node);
      }, exports.TSExternalModuleReference = function(node) {
        this.token("require("), this.print(node.expression, node), this.token(")");
      }, exports.TSFunctionType = function(node) {
        this.tsPrintFunctionOrConstructorType(node);
      }, exports.TSImportEqualsDeclaration = function(node) {
        const {isExport, id, moduleReference} = node;
        isExport && (this.word("export"), this.space());
        this.word("import"), this.space(), this.print(id, node), this.space(), this.token("="), 
        this.space(), this.print(moduleReference, node), this.token(";");
      }, exports.TSImportType = function(node) {
        const {argument, qualifier, typeParameters} = node;
        this.word("import"), this.token("("), this.print(argument, node), this.token(")"), 
        qualifier && (this.token("."), this.print(qualifier, node));
        typeParameters && this.print(typeParameters, node);
      }, exports.TSIndexSignature = function(node) {
        const {readonly, static: isStatic} = node;
        isStatic && (this.word("static"), this.space());
        readonly && (this.word("readonly"), this.space());
        this.token("["), this._parameters(node.parameters, node), this.token("]"), this.print(node.typeAnnotation, node), 
        this.token(";");
      }, exports.TSIndexedAccessType = function(node) {
        this.print(node.objectType, node), this.token("["), this.print(node.indexType, node), 
        this.token("]");
      }, exports.TSInferType = function(node) {
        this.token("infer"), this.space(), this.print(node.typeParameter);
      }, exports.TSInterfaceBody = function(node) {
        this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
      }, exports.TSInterfaceDeclaration = function(node) {
        const {declare, id, typeParameters, extends: extendz, body} = node;
        declare && (this.word("declare"), this.space());
        this.word("interface"), this.space(), this.print(id, node), this.print(typeParameters, node), 
        null != extendz && extendz.length && (this.space(), this.word("extends"), this.space(), 
        this.printList(extendz, node));
        this.space(), this.print(body, node);
      }, exports.TSIntersectionType = function(node) {
        this.tsPrintUnionOrIntersectionType(node, "&");
      }, exports.TSIntrinsicKeyword = function() {
        this.word("intrinsic");
      }, exports.TSLiteralType = function(node) {
        this.print(node.literal, node);
      }, exports.TSMappedType = function(node) {
        const {nameType, optional, readonly, typeParameter} = node;
        this.token("{"), this.space(), readonly && (tokenIfPlusMinus(this, readonly), this.word("readonly"), 
        this.space());
        this.token("["), this.word(typeParameter.name), this.space(), this.word("in"), this.space(), 
        this.print(typeParameter.constraint, typeParameter), nameType && (this.space(), 
        this.word("as"), this.space(), this.print(nameType, node));
        this.token("]"), optional && (tokenIfPlusMinus(this, optional), this.token("?"));
        this.token(":"), this.space(), this.print(node.typeAnnotation, node), this.space(), 
        this.token("}");
      }, exports.TSMethodSignature = function(node) {
        const {kind} = node;
        "set" !== kind && "get" !== kind || (this.word(kind), this.space());
        this.tsPrintPropertyOrMethodName(node), this.tsPrintSignatureDeclarationBase(node), 
        this.token(";");
      }, exports.TSModuleBlock = function(node) {
        this.tsPrintBraced(node.body, node);
      }, exports.TSModuleDeclaration = function(node) {
        const {declare, id} = node;
        declare && (this.word("declare"), this.space());
        node.global || (this.word("Identifier" === id.type ? "namespace" : "module"), this.space());
        if (this.print(id, node), !node.body) return void this.token(";");
        let body = node.body;
        for (;"TSModuleDeclaration" === body.type; ) this.token("."), this.print(body.id, body), 
        body = body.body;
        this.space(), this.print(body, node);
      }, exports.TSNamedTupleMember = function(node) {
        this.print(node.label, node), node.optional && this.token("?");
        this.token(":"), this.space(), this.print(node.elementType, node);
      }, exports.TSNamespaceExportDeclaration = function(node) {
        this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), 
        this.space(), this.print(node.id, node);
      }, exports.TSNeverKeyword = function() {
        this.word("never");
      }, exports.TSNonNullExpression = function(node) {
        this.print(node.expression, node), this.token("!");
      }, exports.TSNullKeyword = function() {
        this.word("null");
      }, exports.TSNumberKeyword = function() {
        this.word("number");
      }, exports.TSObjectKeyword = function() {
        this.word("object");
      }, exports.TSOptionalType = function(node) {
        this.print(node.typeAnnotation, node), this.token("?");
      }, exports.TSParameterProperty = function(node) {
        node.accessibility && (this.word(node.accessibility), this.space());
        node.readonly && (this.word("readonly"), this.space());
        this._param(node.parameter);
      }, exports.TSParenthesizedType = function(node) {
        this.token("("), this.print(node.typeAnnotation, node), this.token(")");
      }, exports.TSPropertySignature = function(node) {
        const {readonly, initializer} = node;
        readonly && (this.word("readonly"), this.space());
        this.tsPrintPropertyOrMethodName(node), this.print(node.typeAnnotation, node), initializer && (this.space(), 
        this.token("="), this.space(), this.print(initializer, node));
        this.token(";");
      }, exports.TSQualifiedName = function(node) {
        this.print(node.left, node), this.token("."), this.print(node.right, node);
      }, exports.TSRestType = function(node) {
        this.token("..."), this.print(node.typeAnnotation, node);
      }, exports.TSStringKeyword = function() {
        this.word("string");
      }, exports.TSSymbolKeyword = function() {
        this.word("symbol");
      }, exports.TSThisType = function() {
        this.word("this");
      }, exports.TSTupleType = function(node) {
        this.token("["), this.printList(node.elementTypes, node), this.token("]");
      }, exports.TSTypeAliasDeclaration = function(node) {
        const {declare, id, typeParameters, typeAnnotation} = node;
        declare && (this.word("declare"), this.space());
        this.word("type"), this.space(), this.print(id, node), this.print(typeParameters, node), 
        this.space(), this.token("="), this.space(), this.print(typeAnnotation, node), this.token(";");
      }, exports.TSTypeAnnotation = function(node) {
        this.token(":"), this.space(), node.optional && this.token("?");
        this.print(node.typeAnnotation, node);
      }, exports.TSTypeAssertion = function(node) {
        const {typeAnnotation, expression} = node;
        this.token("<"), this.print(typeAnnotation, node), this.token(">"), this.space(), 
        this.print(expression, node);
      }, exports.TSTypeLiteral = function(node) {
        this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
      }, exports.TSTypeOperator = function(node) {
        this.word(node.operator), this.space(), this.print(node.typeAnnotation, node);
      }, exports.TSTypeParameter = function(node) {
        this.word(node.name), node.constraint && (this.space(), this.word("extends"), this.space(), 
        this.print(node.constraint, node));
        node.default && (this.space(), this.token("="), this.space(), this.print(node.default, node));
      }, exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = function(node, parent) {
        this.token("<"), this.printList(node.params, node, {}), "ArrowFunctionExpression" === parent.type && 1 === node.params.length && this.token(",");
        this.token(">");
      }, exports.TSTypePredicate = function(node) {
        node.asserts && (this.word("asserts"), this.space());
        this.print(node.parameterName), node.typeAnnotation && (this.space(), this.word("is"), 
        this.space(), this.print(node.typeAnnotation.typeAnnotation));
      }, exports.TSTypeQuery = function(node) {
        this.word("typeof"), this.space(), this.print(node.exprName);
      }, exports.TSTypeReference = function(node) {
        this.print(node.typeName, node), this.print(node.typeParameters, node);
      }, exports.TSUndefinedKeyword = function() {
        this.word("undefined");
      }, exports.TSUnionType = function(node) {
        this.tsPrintUnionOrIntersectionType(node, "|");
      }, exports.TSUnknownKeyword = function() {
        this.word("unknown");
      }, exports.TSVoidKeyword = function() {
        this.word("void");
      }, exports.tsPrintBraced = function(members, node) {
        if (this.token("{"), members.length) {
          this.indent(), this.newline();
          for (const member of members) this.print(member, node), this.newline();
          this.dedent(), this.rightBrace();
        } else this.token("}");
      }, exports.tsPrintClassMemberModifiers = function(node, isField) {
        isField && node.declare && (this.word("declare"), this.space());
        node.accessibility && (this.word(node.accessibility), this.space());
        node.static && (this.word("static"), this.space());
        node.override && (this.word("override"), this.space());
        node.abstract && (this.word("abstract"), this.space());
        isField && node.readonly && (this.word("readonly"), this.space());
      }, exports.tsPrintFunctionOrConstructorType = function(node) {
        const {typeParameters} = node, parameters = node.parameters;
        this.print(typeParameters, node), this.token("("), this._parameters(parameters, node), 
        this.token(")"), this.space(), this.token("=>"), this.space();
        const returnType = node.typeAnnotation;
        this.print(returnType.typeAnnotation, node);
      }, exports.tsPrintPropertyOrMethodName = function(node) {
        node.computed && this.token("[");
        this.print(node.key, node), node.computed && this.token("]");
        node.optional && this.token("?");
      }, exports.tsPrintSignatureDeclarationBase = function(node) {
        const {typeParameters} = node, parameters = node.parameters;
        this.print(typeParameters, node), this.token("("), this._parameters(parameters, node), 
        this.token(")");
        const returnType = node.typeAnnotation;
        this.print(returnType, node);
      }, exports.tsPrintTypeLiteralOrInterfaceBody = function(members, node) {
        this.tsPrintBraced(members, node);
      }, exports.tsPrintUnionOrIntersectionType = function(node, sep) {
        this.printJoin(node.types, node, {
          separator() {
            this.space(), this.token(sep), this.space();
          }
        });
      };
    },
    9166: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.CodeGenerator = void 0, exports.default = function(ast, opts, code) {
        return new Generator(ast, opts, code).generate();
      };
      var _sourceMap = __webpack_require__(7853), _printer = __webpack_require__(3105);
      class Generator extends _printer.default {
        constructor(ast, opts = {}, code) {
          const format = function(code, opts) {
            const format = {
              auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
              auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
              shouldPrintComment: opts.shouldPrintComment,
              retainLines: opts.retainLines,
              retainFunctionParens: opts.retainFunctionParens,
              comments: null == opts.comments || opts.comments,
              compact: opts.compact,
              minified: opts.minified,
              concise: opts.concise,
              indent: {
                adjustMultilineComment: !0,
                style: "  ",
                base: 0
              },
              decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
              jsescOption: Object.assign({
                quotes: "double",
                wrap: !0,
                minimal: !1
              }, opts.jsescOption),
              recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType,
              topicToken: opts.topicToken
            };
            format.jsonCompatibleStrings = opts.jsonCompatibleStrings, format.minified ? (format.compact = !0, 
            format.shouldPrintComment = format.shouldPrintComment || (() => format.comments)) : format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
            "auto" === format.compact && (format.compact = code.length > 5e5, format.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of 500KB.`));
            format.compact && (format.indent.adjustMultilineComment = !1);
            return format;
          }(code, opts);
          super(format, opts.sourceMaps ? new _sourceMap.default(opts, code) : null), this.ast = void 0, 
          this.ast = ast;
        }
        generate() {
          return super.generate(this.ast);
        }
      }
      exports.CodeGenerator = class {
        constructor(ast, opts, code) {
          this._generator = void 0, this._generator = new Generator(ast, opts, code);
        }
        generate() {
          return this._generator.generate();
        }
      };
    },
    2866: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.needsParens = function(node, parent, printStack) {
        if (!parent) return !1;
        if (isNewExpression(parent) && parent.callee === node && isOrHasCallExpression(node)) return !0;
        return find(expandedParens, node, parent, printStack);
      }, exports.needsWhitespace = needsWhitespace, exports.needsWhitespaceAfter = function(node, parent) {
        return needsWhitespace(node, parent, "after");
      }, exports.needsWhitespaceBefore = function(node, parent) {
        return needsWhitespace(node, parent, "before");
      };
      var whitespace = __webpack_require__(4114), parens = __webpack_require__(2514), _t = __webpack_require__(8218);
      const {FLIPPED_ALIAS_KEYS, isCallExpression, isExpressionStatement, isMemberExpression, isNewExpression} = _t;
      function expandAliases(obj) {
        const newObj = {};
        function add(type, func) {
          const fn = newObj[type];
          newObj[type] = fn ? function(node, parent, stack) {
            const result = fn(node, parent, stack);
            return null == result ? func(node, parent, stack) : result;
          } : func;
        }
        for (const type of Object.keys(obj)) {
          const aliases = FLIPPED_ALIAS_KEYS[type];
          if (aliases) for (const alias of aliases) add(alias, obj[type]); else add(type, obj[type]);
        }
        return newObj;
      }
      const expandedParens = expandAliases(parens), expandedWhitespaceNodes = expandAliases(whitespace.nodes), expandedWhitespaceList = expandAliases(whitespace.list);
      function find(obj, node, parent, printStack) {
        const fn = obj[node.type];
        return fn ? fn(node, parent, printStack) : null;
      }
      function isOrHasCallExpression(node) {
        return !!isCallExpression(node) || isMemberExpression(node) && isOrHasCallExpression(node.object);
      }
      function needsWhitespace(node, parent, type) {
        if (!node) return 0;
        isExpressionStatement(node) && (node = node.expression);
        let linesInfo = find(expandedWhitespaceNodes, node, parent);
        if (!linesInfo) {
          const items = find(expandedWhitespaceList, node, parent);
          if (items) for (let i = 0; i < items.length && (linesInfo = needsWhitespace(items[i], node, type), 
          !linesInfo); i++) ;
        }
        return "object" == typeof linesInfo && null !== linesInfo && linesInfo[type] || 0;
      }
    },
    2514: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.ArrowFunctionExpression = function(node, parent) {
        return isExportDeclaration(parent) || ConditionalExpression(node, parent);
      }, exports.AssignmentExpression = function(node, parent) {
        return !!isObjectPattern(node.left) || ConditionalExpression(node, parent);
      }, exports.Binary = function(node, parent) {
        if ("**" === node.operator && isBinaryExpression(parent, {
          operator: "**"
        })) return parent.left === node;
        if (isClassExtendsClause(node, parent)) return !0;
        if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) return !0;
        if (isBinary(parent)) {
          const parentOp = parent.operator, parentPos = PRECEDENCE[parentOp], nodeOp = node.operator, nodePos = PRECEDENCE[nodeOp];
          if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) return !0;
        }
      }, exports.BinaryExpression = function(node, parent) {
        return "in" === node.operator && (isVariableDeclarator(parent) || isFor(parent));
      }, exports.ClassExpression = function(node, parent, printStack) {
        return isFirstInContext(printStack, {
          expressionStatement: !0,
          exportDefault: !0
        });
      }, exports.ConditionalExpression = ConditionalExpression, exports.DoExpression = function(node, parent, printStack) {
        return !node.async && isFirstInContext(printStack, {
          expressionStatement: !0
        });
      }, exports.FunctionExpression = function(node, parent, printStack) {
        return isFirstInContext(printStack, {
          expressionStatement: !0,
          exportDefault: !0
        });
      }, exports.FunctionTypeAnnotation = function(node, parent, printStack) {
        return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
      }, exports.Identifier = function(node, parent, printStack) {
        if ("let" === node.name) {
          const isFollowedByBracket = isMemberExpression(parent, {
            object: node,
            computed: !0
          }) || isOptionalMemberExpression(parent, {
            object: node,
            computed: !0,
            optional: !1
          });
          return isFirstInContext(printStack, {
            expressionStatement: isFollowedByBracket,
            forHead: isFollowedByBracket,
            forInHead: isFollowedByBracket,
            forOfHead: !0
          });
        }
        return "async" === node.name && isForOfStatement(parent) && node === parent.left;
      }, exports.LogicalExpression = function(node, parent) {
        switch (node.operator) {
         case "||":
          return !!isLogicalExpression(parent) && ("??" === parent.operator || "&&" === parent.operator);

         case "&&":
          return isLogicalExpression(parent, {
            operator: "??"
          });

         case "??":
          return isLogicalExpression(parent) && "??" !== parent.operator;
        }
      }, exports.NullableTypeAnnotation = function(node, parent) {
        return isArrayTypeAnnotation(parent);
      }, exports.ObjectExpression = function(node, parent, printStack) {
        return isFirstInContext(printStack, {
          expressionStatement: !0,
          arrowBody: !0
        });
      }, exports.OptionalIndexedAccessType = function(node, parent) {
        return isIndexedAccessType(parent, {
          objectType: node
        });
      }, exports.OptionalCallExpression = exports.OptionalMemberExpression = function(node, parent) {
        return isCallExpression(parent, {
          callee: node
        }) || isMemberExpression(parent, {
          object: node
        });
      }, exports.SequenceExpression = function(node, parent) {
        if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) return !1;
        return !0;
      }, exports.TSAsExpression = function() {
        return !0;
      }, exports.TSInferType = function(node, parent) {
        return isTSArrayType(parent) || isTSOptionalType(parent);
      }, exports.TSTypeAssertion = function() {
        return !0;
      }, exports.TSIntersectionType = exports.TSUnionType = function(node, parent) {
        return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
      }, exports.UnaryLike = UnaryLike, exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = function(node, parent) {
        return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
      }, exports.UpdateExpression = function(node, parent) {
        return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
      }, exports.AwaitExpression = exports.YieldExpression = function(node, parent) {
        return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
      };
      var _t = __webpack_require__(8218);
      const {isArrayTypeAnnotation, isArrowFunctionExpression, isAssignmentExpression, isAwaitExpression, isBinary, isBinaryExpression, isCallExpression, isClassDeclaration, isClassExpression, isConditional, isConditionalExpression, isExportDeclaration, isExportDefaultDeclaration, isExpressionStatement, isFor, isForInStatement, isForOfStatement, isForStatement, isIfStatement, isIndexedAccessType, isIntersectionTypeAnnotation, isLogicalExpression, isMemberExpression, isNewExpression, isNullableTypeAnnotation, isObjectPattern, isOptionalCallExpression, isOptionalMemberExpression, isReturnStatement, isSequenceExpression, isSwitchStatement, isTSArrayType, isTSAsExpression, isTSIntersectionType, isTSNonNullExpression, isTSOptionalType, isTSRestType, isTSTypeAssertion, isTSUnionType, isTaggedTemplateExpression, isThrowStatement, isTypeAnnotation, isUnaryLike, isUnionTypeAnnotation, isVariableDeclarator, isWhileStatement, isYieldExpression} = _t, PRECEDENCE = {
        "||": 0,
        "??": 0,
        "&&": 1,
        "|": 2,
        "^": 3,
        "&": 4,
        "==": 5,
        "===": 5,
        "!=": 5,
        "!==": 5,
        "<": 6,
        ">": 6,
        "<=": 6,
        ">=": 6,
        in: 6,
        instanceof: 6,
        ">>": 7,
        "<<": 7,
        ">>>": 7,
        "+": 8,
        "-": 8,
        "*": 9,
        "/": 9,
        "%": 9,
        "**": 10
      }, isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node, hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
      function UnaryLike(node, parent) {
        return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
          operator: "**",
          left: node
        }) || isClassExtendsClause(node, parent);
      }
      function ConditionalExpression(node, parent) {
        return !!(isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
          test: node
        }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) || UnaryLike(node, parent);
      }
      function isFirstInContext(printStack, {expressionStatement = !1, arrowBody = !1, exportDefault = !1, forHead = !1, forInHead = !1, forOfHead = !1}) {
        let i = printStack.length - 1, node = printStack[i];
        i--;
        let parent = printStack[i];
        for (;i >= 0; ) {
          if (expressionStatement && isExpressionStatement(parent, {
            expression: node
          }) || exportDefault && isExportDefaultDeclaration(parent, {
            declaration: node
          }) || arrowBody && isArrowFunctionExpression(parent, {
            body: node
          }) || forHead && isForStatement(parent, {
            init: node
          }) || forInHead && isForInStatement(parent, {
            left: node
          }) || forOfHead && isForOfStatement(parent, {
            left: node
          })) return !0;
          if (!(hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {
            test: node
          }) || isBinary(parent, {
            left: node
          }) || isAssignmentExpression(parent, {
            left: node
          }))) return !1;
          node = parent, i--, parent = printStack[i];
        }
        return !1;
      }
    },
    4114: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.nodes = exports.list = void 0;
      var _t = __webpack_require__(8218);
      const {FLIPPED_ALIAS_KEYS, isArrayExpression, isAssignmentExpression, isBinary, isBlockStatement, isCallExpression, isFunction, isIdentifier, isLiteral, isMemberExpression, isObjectExpression, isOptionalCallExpression, isOptionalMemberExpression, isStringLiteral} = _t;
      function crawl(node, state = {}) {
        return isMemberExpression(node) || isOptionalMemberExpression(node) ? (crawl(node.object, state), 
        node.computed && crawl(node.property, state)) : isBinary(node) || isAssignmentExpression(node) ? (crawl(node.left, state), 
        crawl(node.right, state)) : isCallExpression(node) || isOptionalCallExpression(node) ? (state.hasCall = !0, 
        crawl(node.callee, state)) : isFunction(node) ? state.hasFunction = !0 : isIdentifier(node) && (state.hasHelper = state.hasHelper || isHelper(node.callee)), 
        state;
      }
      function isHelper(node) {
        return isMemberExpression(node) ? isHelper(node.object) || isHelper(node.property) : isIdentifier(node) ? "require" === node.name || "_" === node.name[0] : isCallExpression(node) ? isHelper(node.callee) : !(!isBinary(node) && !isAssignmentExpression(node)) && (isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right));
      }
      function isType(node) {
        return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
      }
      const nodes = {
        AssignmentExpression(node) {
          const state = crawl(node.right);
          if (state.hasCall && state.hasHelper || state.hasFunction) return {
            before: state.hasFunction,
            after: !0
          };
        },
        SwitchCase: (node, parent) => ({
          before: !!node.consequent.length || parent.cases[0] === node,
          after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
        }),
        LogicalExpression(node) {
          if (isFunction(node.left) || isFunction(node.right)) return {
            after: !0
          };
        },
        Literal(node) {
          if (isStringLiteral(node) && "use strict" === node.value) return {
            after: !0
          };
        },
        CallExpression(node) {
          if (isFunction(node.callee) || isHelper(node)) return {
            before: !0,
            after: !0
          };
        },
        OptionalCallExpression(node) {
          if (isFunction(node.callee)) return {
            before: !0,
            after: !0
          };
        },
        VariableDeclaration(node) {
          for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            let enabled = isHelper(declar.id) && !isType(declar.init);
            if (!enabled) {
              const state = crawl(declar.init);
              enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
            }
            if (enabled) return {
              before: !0,
              after: !0
            };
          }
        },
        IfStatement(node) {
          if (isBlockStatement(node.consequent)) return {
            before: !0,
            after: !0
          };
        }
      };
      exports.nodes = nodes, nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
        if (parent.properties[0] === node) return {
          before: !0
        };
      }, nodes.ObjectTypeCallProperty = function(node, parent) {
        var _parent$properties;
        if (parent.callProperties[0] === node && (null == (_parent$properties = parent.properties) || !_parent$properties.length)) return {
          before: !0
        };
      }, nodes.ObjectTypeIndexer = function(node, parent) {
        var _parent$properties2, _parent$callPropertie;
        if (!(parent.indexers[0] !== node || null != (_parent$properties2 = parent.properties) && _parent$properties2.length || null != (_parent$callPropertie = parent.callProperties) && _parent$callPropertie.length)) return {
          before: !0
        };
      }, nodes.ObjectTypeInternalSlot = function(node, parent) {
        var _parent$properties3, _parent$callPropertie2, _parent$indexers;
        if (!(parent.internalSlots[0] !== node || null != (_parent$properties3 = parent.properties) && _parent$properties3.length || null != (_parent$callPropertie2 = parent.callProperties) && _parent$callPropertie2.length || null != (_parent$indexers = parent.indexers) && _parent$indexers.length)) return {
          before: !0
        };
      };
      const list = {
        VariableDeclaration: node => node.declarations.map((decl => decl.init)),
        ArrayExpression: node => node.elements,
        ObjectExpression: node => node.properties
      };
      exports.list = list, [ [ "Function", !0 ], [ "Class", !0 ], [ "Loop", !0 ], [ "LabeledStatement", !0 ], [ "SwitchStatement", !0 ], [ "TryStatement", !0 ] ].forEach((function([type, amounts]) {
        "boolean" == typeof amounts && (amounts = {
          after: amounts,
          before: amounts
        }), [ type ].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach((function(type) {
          nodes[type] = function() {
            return amounts;
          };
        }));
      }));
    },
    3105: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _buffer = __webpack_require__(8649), n = __webpack_require__(2866), _t = __webpack_require__(8218), generatorFunctions = __webpack_require__(8217);
      const {isProgram, isFile, isEmptyStatement} = _t, SCIENTIFIC_NOTATION = /e/i, ZERO_DECIMAL_INTEGER = /\.0+$/, NON_DECIMAL_LITERAL = /^0[box]/, PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/, {needsParens, needsWhitespaceAfter, needsWhitespaceBefore} = n;
      class Printer {
        constructor(format, map) {
          this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._insideAux = !1, 
          this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, 
          this._printedComments = new WeakSet, this._endsWithInteger = !1, this._endsWithWord = !1, 
          this.format = format, this._buf = new _buffer.default(map);
        }
        generate(ast) {
          return this.print(ast), this._maybeAddAuxComment(), this._buf.get();
        }
        indent() {
          this.format.compact || this.format.concise || this._indent++;
        }
        dedent() {
          this.format.compact || this.format.concise || this._indent--;
        }
        semicolon(force = !1) {
          this._maybeAddAuxComment(), this._append(";", !force);
        }
        rightBrace() {
          this.format.minified && this._buf.removeLastSemicolon(), this.token("}");
        }
        space(force = !1) {
          if (!this.format.compact) if (force) this._space(); else if (this._buf.hasContent()) {
            const lastCp = this.getLastChar();
            32 !== lastCp && 10 !== lastCp && this._space();
          }
        }
        word(str) {
          (this._endsWithWord || this.endsWith(47) && 47 === str.charCodeAt(0)) && this._space(), 
          this._maybeAddAuxComment(), this._append(str), this._endsWithWord = !0;
        }
        number(str) {
          this.word(str), this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && 46 !== str.charCodeAt(str.length - 1);
        }
        token(str) {
          const lastChar = this.getLastChar(), strFirst = str.charCodeAt(0);
          ("--" === str && 33 === lastChar || 43 === strFirst && 43 === lastChar || 45 === strFirst && 45 === lastChar || 46 === strFirst && this._endsWithInteger) && this._space(), 
          this._maybeAddAuxComment(), this._append(str);
        }
        newline(i = 1) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) return void this.space();
          const charBeforeNewline = this.endsWithCharAndNewline();
          if (10 !== charBeforeNewline && (123 !== charBeforeNewline && 58 !== charBeforeNewline || i--, 
          !(i <= 0))) for (let j = 0; j < i; j++) this._newline();
        }
        endsWith(char) {
          return this.getLastChar() === char;
        }
        getLastChar() {
          return this._buf.getLastChar();
        }
        endsWithCharAndNewline() {
          return this._buf.endsWithCharAndNewline();
        }
        removeTrailingNewline() {
          this._buf.removeTrailingNewline();
        }
        exactSource(loc, cb) {
          this._catchUp("start", loc), this._buf.exactSource(loc, cb);
        }
        source(prop, loc) {
          this._catchUp(prop, loc), this._buf.source(prop, loc);
        }
        withSource(prop, loc, cb) {
          this._catchUp(prop, loc), this._buf.withSource(prop, loc, cb);
        }
        _space() {
          this._append(" ", !0);
        }
        _newline() {
          this._append("\n", !0);
        }
        _append(str, queue = !1) {
          this._maybeAddParen(str), this._maybeIndent(str), queue ? this._buf.queue(str) : this._buf.append(str), 
          this._endsWithWord = !1, this._endsWithInteger = !1;
        }
        _maybeIndent(str) {
          this._indent && this.endsWith(10) && 10 !== str.charCodeAt(0) && this._buf.queueIndentation(this._getIndent());
        }
        _maybeAddParen(str) {
          const parenPushNewlineState = this._parenPushNewlineState;
          if (!parenPushNewlineState) return;
          let i;
          for (i = 0; i < str.length && " " === str[i]; i++) continue;
          if (i === str.length) return;
          const cha = str[i];
          if ("\n" !== cha) {
            if ("/" !== cha || i + 1 === str.length) return void (this._parenPushNewlineState = null);
            const chaPost = str[i + 1];
            if ("*" === chaPost) {
              if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) return;
            } else if ("/" !== chaPost) return void (this._parenPushNewlineState = null);
          }
          this.token("("), this.indent(), parenPushNewlineState.printed = !0;
        }
        _catchUp(prop, loc) {
          if (!this.format.retainLines) return;
          const pos = loc ? loc[prop] : null;
          if (null != (null == pos ? void 0 : pos.line)) {
            const count = pos.line - this._buf.getCurrentLine();
            for (let i = 0; i < count; i++) this._newline();
          }
        }
        _getIndent() {
          return this.format.indent.style.repeat(this._indent);
        }
        startTerminatorless(isLabel = !1) {
          return isLabel ? (this._noLineTerminator = !0, null) : this._parenPushNewlineState = {
            printed: !1
          };
        }
        endTerminatorless(state) {
          this._noLineTerminator = !1, null != state && state.printed && (this.dedent(), this.newline(), 
          this.token(")"));
        }
        print(node, parent) {
          if (!node) return;
          const oldConcise = this.format.concise;
          node._compact && (this.format.concise = !0);
          const printMethod = this[node.type];
          if (!printMethod) throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(null == node ? void 0 : node.constructor.name)}`);
          this._printStack.push(node);
          const oldInAux = this._insideAux;
          this._insideAux = !node.loc, this._maybeAddAuxComment(this._insideAux && !oldInAux);
          let shouldPrintParens = needsParens(node, parent, this._printStack);
          this.format.retainFunctionParens && "FunctionExpression" === node.type && node.extra && node.extra.parenthesized && (shouldPrintParens = !0), 
          shouldPrintParens && this.token("("), this._printLeadingComments(node);
          const loc = isProgram(node) || isFile(node) ? null : node.loc;
          this.withSource("start", loc, (() => {
            printMethod.call(this, node, parent);
          })), this._printTrailingComments(node), shouldPrintParens && this.token(")"), this._printStack.pop(), 
          this.format.concise = oldConcise, this._insideAux = oldInAux;
        }
        _maybeAddAuxComment(enteredPositionlessNode) {
          enteredPositionlessNode && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
        }
        _printAuxBeforeComment() {
          if (this._printAuxAfterOnNextUserNode) return;
          this._printAuxAfterOnNextUserNode = !0;
          const comment = this.format.auxiliaryCommentBefore;
          comment && this._printComment({
            type: "CommentBlock",
            value: comment
          });
        }
        _printAuxAfterComment() {
          if (!this._printAuxAfterOnNextUserNode) return;
          this._printAuxAfterOnNextUserNode = !1;
          const comment = this.format.auxiliaryCommentAfter;
          comment && this._printComment({
            type: "CommentBlock",
            value: comment
          });
        }
        getPossibleRaw(node) {
          const extra = node.extra;
          if (extra && null != extra.raw && null != extra.rawValue && node.value === extra.rawValue) return extra.raw;
        }
        printJoin(nodes, parent, opts = {}) {
          if (null == nodes || !nodes.length) return;
          opts.indent && this.indent();
          const newlineOpts = {
            addNewlines: opts.addNewlines
          };
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            node && (opts.statement && this._printNewline(!0, node, parent, newlineOpts), this.print(node, parent), 
            opts.iterator && opts.iterator(node, i), opts.separator && i < nodes.length - 1 && opts.separator.call(this), 
            opts.statement && this._printNewline(!1, node, parent, newlineOpts));
          }
          opts.indent && this.dedent();
        }
        printAndIndentOnComments(node, parent) {
          const indent = node.leadingComments && node.leadingComments.length > 0;
          indent && this.indent(), this.print(node, parent), indent && this.dedent();
        }
        printBlock(parent) {
          const node = parent.body;
          isEmptyStatement(node) || this.space(), this.print(node, parent);
        }
        _printTrailingComments(node) {
          this._printComments(this._getComments(!1, node));
        }
        _printLeadingComments(node) {
          this._printComments(this._getComments(!0, node), !0);
        }
        printInnerComments(node, indent = !0) {
          var _node$innerComments;
          null != (_node$innerComments = node.innerComments) && _node$innerComments.length && (indent && this.indent(), 
          this._printComments(node.innerComments), indent && this.dedent());
        }
        printSequence(nodes, parent, opts = {}) {
          return opts.statement = !0, this.printJoin(nodes, parent, opts);
        }
        printList(items, parent, opts = {}) {
          return null == opts.separator && (opts.separator = commaSeparator), this.printJoin(items, parent, opts);
        }
        _printNewline(leading, node, parent, opts) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) return void this.space();
          let lines = 0;
          if (this._buf.hasContent()) {
            leading || lines++, opts.addNewlines && (lines += opts.addNewlines(leading, node) || 0);
            (leading ? needsWhitespaceBefore : needsWhitespaceAfter)(node, parent) && lines++;
          }
          this.newline(Math.min(2, lines));
        }
        _getComments(leading, node) {
          return node && (leading ? node.leadingComments : node.trailingComments) || [];
        }
        _printComment(comment, skipNewLines) {
          if (!this.format.shouldPrintComment(comment.value)) return;
          if (comment.ignore) return;
          if (this._printedComments.has(comment)) return;
          this._printedComments.add(comment);
          const isBlockComment = "CommentBlock" === comment.type, printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
          printNewLines && this._buf.hasContent() && this.newline(1);
          const lastCharCode = this.getLastChar();
          91 !== lastCharCode && 123 !== lastCharCode && this.space();
          let val = isBlockComment || this._noLineTerminator ? `/*${comment.value}*/` : `//${comment.value}\n`;
          if (isBlockComment && this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset = null == (_comment$loc = comment.loc) ? void 0 : _comment$loc.start.column;
            if (offset) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
            val = val.replace(/\n(?!$)/g, `\n${" ".repeat(indentSize)}`);
          }
          this.endsWith(47) && this._space(), this.withSource("start", comment.loc, (() => {
            this._append(val);
          })), printNewLines && this.newline(1);
        }
        _printComments(comments, inlinePureAnnotation) {
          if (null != comments && comments.length) if (inlinePureAnnotation && 1 === comments.length && PURE_ANNOTATION_RE.test(comments[0].value)) this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10)); else for (const comment of comments) this._printComment(comment);
        }
        printAssertions(node) {
          var _node$assertions;
          null != (_node$assertions = node.assertions) && _node$assertions.length && (this.space(), 
          this.word("assert"), this.space(), this.token("{"), this.space(), this.printList(node.assertions, node), 
          this.space(), this.token("}"));
        }
      }
      Object.assign(Printer.prototype, generatorFunctions), Printer.prototype.Noop = function() {};
      var _default = Printer;
      function commaSeparator() {
        this.token(","), this.space();
      }
      exports.default = _default;
    },
    7853: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _genMapping = __webpack_require__(2509);
      exports.default = class {
        constructor(opts, code) {
          var _opts$sourceFileName;
          this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, 
          this._lastSourceLine = 0, this._lastSourceColumn = 0;
          const map = this._map = new _genMapping.GenMapping({
            sourceRoot: opts.sourceRoot
          });
          this._sourceFileName = null == (_opts$sourceFileName = opts.sourceFileName) ? void 0 : _opts$sourceFileName.replace(/\\/g, "/"), 
          this._rawMappings = void 0, "string" == typeof code ? (0, _genMapping.setSourceContent)(map, this._sourceFileName, code) : "object" == typeof code && Object.keys(code).forEach((sourceFileName => {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          }));
        }
        get() {
          return (0, _genMapping.encodedMap)(this._map);
        }
        getDecoded() {
          return (0, _genMapping.decodedMap)(this._map);
        }
        getRawMappings() {
          return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
        }
        mark(generated, line, column, identifierName, filename, force) {
          const generatedLine = generated.line;
          this._lastGenLine !== generatedLine && null == line || (force || this._lastGenLine !== generatedLine || this._lastSourceLine !== line || this._lastSourceColumn !== column) && (this._rawMappings = void 0, 
          this._lastGenLine = generatedLine, this._lastSourceLine = line, this._lastSourceColumn = column, 
          (0, _genMapping.addMapping)(this._map, {
            name: identifierName,
            generated,
            source: null == line ? void 0 : (null == filename ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
            original: null == line ? void 0 : {
              line,
              column
            }
          }));
        }
      };
    },
    4321: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(pathOrNode) {
        const node = pathOrNode.node || pathOrNode;
        if ((({leadingComments}) => !!leadingComments && leadingComments.some((comment => /[@#]__PURE__/.test(comment.value))))(node)) return;
        addComment(node, "leading", "#__PURE__");
      };
      var _t = __webpack_require__(8218);
      const {addComment} = _t;
    },
    1820: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(opts) {
        const {build, operator} = opts;
        return {
          AssignmentExpression(path) {
            const {node, scope} = path;
            if (node.operator !== operator + "=") return;
            const nodes = [], exploded = (0, _helperExplodeAssignableExpression.default)(node.left, nodes, this, scope);
            nodes.push(assignmentExpression("=", exploded.ref, build(exploded.uid, node.right))), 
            path.replaceWith(sequenceExpression(nodes));
          },
          BinaryExpression(path) {
            const {node} = path;
            node.operator === operator && path.replaceWith(build(node.left, node.right));
          }
        };
      };
      var _helperExplodeAssignableExpression = __webpack_require__(3538), _t = __webpack_require__(8218);
      const {assignmentExpression, sequenceExpression} = _t;
    },
    9678: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.getInclusionReasons = function(item, targetVersions, list) {
        const minVersions = list[item] || {};
        return Object.keys(targetVersions).reduce(((result, env) => {
          const minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env), targetVersion = targetVersions[env];
          if (minVersion) {
            const minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env);
            (0, _utils.isUnreleasedVersion)(targetVersion, env) || !minIsUnreleased && !_semver.lt(targetVersion.toString(), (0, 
            _utils.semverify)(minVersion)) || (result[env] = (0, _pretty.prettifyVersion)(targetVersion));
          } else result[env] = (0, _pretty.prettifyVersion)(targetVersion);
          return result;
        }), {});
      };
      var _semver = __webpack_require__(6625), _pretty = __webpack_require__(8087), _utils = __webpack_require__(3108);
    },
    9584: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
        const result = new Set, options = {
          compatData: list,
          includes,
          excludes
        };
        for (const item in list) if (isRequired(item, targets, options)) result.add(item); else if (pluginSyntaxMap) {
          const shippedProposalsSyntax = pluginSyntaxMap.get(item);
          shippedProposalsSyntax && result.add(shippedProposalsSyntax);
        }
        defaultIncludes && defaultIncludes.forEach((item => !excludes.has(item) && result.add(item)));
        defaultExcludes && defaultExcludes.forEach((item => !includes.has(item) && result.delete(item)));
        return result;
      }, exports.isRequired = isRequired, exports.targetsSupported = targetsSupported;
      var _semver = __webpack_require__(6625), _plugins = __webpack_require__(4832), _utils = __webpack_require__(3108);
      function targetsSupported(target, support) {
        const targetEnvironments = Object.keys(target);
        if (0 === targetEnvironments.length) return !1;
        return 0 === targetEnvironments.filter((environment => {
          const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
          if (!lowestImplementedVersion) return !0;
          const lowestTargetedVersion = target[environment];
          if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) return !1;
          if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) return !0;
          if (!_semver.valid(lowestTargetedVersion.toString())) throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". Versions must be in semver format (major.minor.patch)`);
          return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
        })).length;
      }
      function isRequired(name, targets, {compatData = _plugins, includes, excludes} = {}) {
        return (null == excludes || !excludes.has(name)) && (!(null == includes || !includes.has(name)) || !targetsSupported(targets, compatData[name]));
      }
    },
    4077: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "TargetNames", {
        enumerable: !0,
        get: function() {
          return _options.TargetNames;
        }
      }), exports.default = function(inputTargets = {}, options = {}) {
        var _browsers, _browsers2;
        let {browsers, esmodules} = inputTargets;
        const {configPath = "."} = options;
        !function(browsers) {
          v.invariant(void 0 === browsers || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`);
        }(browsers);
        let targets = function(targets) {
          const validTargets = Object.keys(_options.TargetNames);
          for (const target of Object.keys(targets)) if (!(target in _options.TargetNames)) throw new Error(v.formatMessage(`'${target}' is not a valid target\n- Did you mean '${(0, 
          _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));
          return targets;
        }(function(inputTargets) {
          const input = Object.assign({}, inputTargets);
          return delete input.esmodules, delete input.browsers, input;
        }(inputTargets));
        const hasTargets = !!browsers || Object.keys(targets).length > 0, shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
        !browsers && shouldSearchForConfig && (browsers = _browserslist.loadConfig({
          config: options.configFile,
          path: configPath,
          env: options.browserslistEnv
        }), null == browsers && (browsers = []));
        !esmodules || "intersect" === esmodules && null != (_browsers = browsers) && _browsers.length || (browsers = Object.keys(ESM_SUPPORT).map((browser => `${browser} >= ${ESM_SUPPORT[browser]}`)).join(", "), 
        esmodules = !1);
        if (null != (_browsers2 = browsers) && _browsers2.length) {
          const queryBrowsers = (queries = browsers, env = options.browserslistEnv, function(browsers) {
            return browsers.reduce(((all, browser) => {
              const [browserName, browserVersion] = browser.split(" "), normalizedBrowserName = _targets.browserNameMap[browserName];
              if (!normalizedBrowserName) return all;
              try {
                const splitVersion = browserVersion.split("-")[0].toLowerCase(), isSplitUnreleased = (0, 
                _utils.isUnreleasedVersion)(splitVersion, browserName);
                if (!all[normalizedBrowserName]) return all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : (0, 
                _utils.semverify)(splitVersion), all;
                const version = all[normalizedBrowserName], isUnreleased = (0, _utils.isUnreleasedVersion)(version, browserName);
                if (isUnreleased && isSplitUnreleased) all[normalizedBrowserName] = (0, _utils.getLowestUnreleased)(version, splitVersion, browserName); else if (isUnreleased) all[normalizedBrowserName] = (0, 
                _utils.semverify)(splitVersion); else if (!isUnreleased && !isSplitUnreleased) {
                  const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
                  all[normalizedBrowserName] = (0, _utils.semverMin)(version, parsedBrowserVersion);
                }
              } catch (e) {}
              return all;
            }), {});
          }(_browserslist(queries, {
            mobileToDesktop: !0,
            env
          })));
          if ("intersect" === esmodules) for (const browser of Object.keys(queryBrowsers)) {
            const version = queryBrowsers[browser];
            ESM_SUPPORT[browser] ? queryBrowsers[browser] = (0, _utils.getHighestUnreleased)(version, (0, 
            _utils.semverify)(ESM_SUPPORT[browser]), browser) : delete queryBrowsers[browser];
          }
          targets = Object.assign(queryBrowsers, targets);
        }
        var queries, env;
        const result = {}, decimalWarnings = [];
        for (const target of Object.keys(targets).sort()) {
          var _targetParserMap$targ;
          const value = targets[target];
          "number" == typeof value && value % 1 != 0 && decimalWarnings.push({
            target,
            value
          });
          const parser = null != (_targetParserMap$targ = targetParserMap[target]) ? _targetParserMap$targ : targetParserMap.__default, [parsedTarget, parsedValue] = parser(target, value);
          parsedValue && (result[parsedTarget] = parsedValue);
        }
        return function(decimalTargets) {
          if (!decimalTargets.length) return;
          console.warn("Warning, the following targets are using a decimal version:\n"), decimalTargets.forEach((({target, value}) => console.warn(`  ${target}: ${value}`))), 
          console.warn("\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n");
        }(decimalWarnings), result;
      }, Object.defineProperty(exports, "filterItems", {
        enumerable: !0,
        get: function() {
          return _filterItems.default;
        }
      }), Object.defineProperty(exports, "getInclusionReasons", {
        enumerable: !0,
        get: function() {
          return _debug.getInclusionReasons;
        }
      }), exports.isBrowsersQueryValid = isBrowsersQueryValid, Object.defineProperty(exports, "isRequired", {
        enumerable: !0,
        get: function() {
          return _filterItems.isRequired;
        }
      }), Object.defineProperty(exports, "prettifyTargets", {
        enumerable: !0,
        get: function() {
          return _pretty.prettifyTargets;
        }
      }), Object.defineProperty(exports, "unreleasedLabels", {
        enumerable: !0,
        get: function() {
          return _targets.unreleasedLabels;
        }
      });
      var _browserslist = __webpack_require__(1991), _helperValidatorOption = __webpack_require__(4346), _nativeModules = __webpack_require__(8142), _utils = __webpack_require__(3108), _targets = __webpack_require__(2950), _options = __webpack_require__(8910), _pretty = __webpack_require__(8087), _debug = __webpack_require__(9678), _filterItems = __webpack_require__(9584);
      const ESM_SUPPORT = _nativeModules["es6.module"], v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
      function isBrowsersQueryValid(browsers) {
        return "string" == typeof browsers || Array.isArray(browsers) && browsers.every((b => "string" == typeof b));
      }
      function semverifyTarget(target, value) {
        try {
          return (0, _utils.semverify)(value);
        } catch (error) {
          throw new Error(v.formatMessage(`'${value}' is not a valid value for 'targets.${target}'.`));
        }
      }
      const targetParserMap = {
        __default: (target, value) => [ target, (0, _utils.isUnreleasedVersion)(value, target) ? value.toLowerCase() : semverifyTarget(target, value) ],
        node: (target, value) => [ target, !0 === value || "current" === value ? process.versions.node : semverifyTarget(target, value) ]
      };
    },
    8910: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.TargetNames = void 0;
      exports.TargetNames = {
        node: "node",
        chrome: "chrome",
        opera: "opera",
        edge: "edge",
        firefox: "firefox",
        safari: "safari",
        ie: "ie",
        ios: "ios",
        android: "android",
        electron: "electron",
        samsung: "samsung",
        rhino: "rhino"
      };
    },
    8087: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.prettifyTargets = function(targets) {
        return Object.keys(targets).reduce(((results, target) => {
          let value = targets[target];
          const unreleasedLabel = _targets.unreleasedLabels[target];
          return "string" == typeof value && unreleasedLabel !== value && (value = prettifyVersion(value)), 
          results[target] = value, results;
        }), {});
      }, exports.prettifyVersion = prettifyVersion;
      var _semver = __webpack_require__(6625), _targets = __webpack_require__(2950);
      function prettifyVersion(version) {
        if ("string" != typeof version) return version;
        const parts = [ _semver.major(version) ], minor = _semver.minor(version), patch = _semver.patch(version);
        return (minor || patch) && parts.push(minor), patch && parts.push(patch), parts.join(".");
      }
    },
    2950: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.unreleasedLabels = exports.browserNameMap = void 0;
      exports.unreleasedLabels = {
        safari: "tp"
      };
      exports.browserNameMap = {
        and_chr: "chrome",
        and_ff: "firefox",
        android: "android",
        chrome: "chrome",
        edge: "edge",
        firefox: "firefox",
        ie: "ie",
        ie_mob: "ie",
        ios_saf: "ios",
        node: "node",
        op_mob: "opera",
        opera: "opera",
        safari: "safari",
        samsung: "samsung"
      };
    },
    3108: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.getHighestUnreleased = function(a, b, env) {
        return getLowestUnreleased(a, b, env) === a ? b : a;
      }, exports.getLowestImplementedVersion = function(plugin, environment) {
        const result = plugin[environment];
        if (!result && "android" === environment) return plugin.chrome;
        return result;
      }, exports.getLowestUnreleased = getLowestUnreleased, exports.isUnreleasedVersion = function(version, env) {
        const unreleasedLabel = _targets.unreleasedLabels[env];
        return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
      }, exports.semverMin = semverMin, exports.semverify = function(version) {
        if ("string" == typeof version && _semver.valid(version)) return version;
        v.invariant("number" == typeof version || "string" == typeof version && versionRegExp.test(version), `'${version}' is not a valid version`);
        const split = version.toString().split(".");
        for (;split.length < 3; ) split.push("0");
        return split.join(".");
      };
      var _semver = __webpack_require__(6625), _helperValidatorOption = __webpack_require__(4346), _targets = __webpack_require__(2950);
      const versionRegExp = /^(\d+|\d+.\d+)$/, v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
      function semverMin(first, second) {
        return first && _semver.lt(first, second) ? first : second;
      }
      function getLowestUnreleased(a, b, env) {
        const unreleasedLabel = _targets.unreleasedLabels[env], hasUnreleased = [ a, b ].some((item => item === unreleasedLabel));
        return hasUnreleased ? a === hasUnreleased ? b : a || b : semverMin(a, b);
      }
    },
    3280: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.buildDecoratedClass = function(ref, path, elements, file) {
        const {node, scope} = path, initializeId = scope.generateUidIdentifier("initialize"), isDeclaration = node.id && path.isDeclaration(), isStrict = path.isInStrictMode(), {superClass} = node;
        node.type = "ClassDeclaration", node.id || (node.id = _core.types.cloneNode(ref));
        let superId;
        superClass && (superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super"), 
        node.superClass = superId);
        const classDecorators = takeDecorators(node), definitions = _core.types.arrayExpression(elements.filter((element => !element.node.abstract)).map(extractElementDescriptor.bind(file, node.id, superId))), wrapperCall = _core.template.expression.ast`
    ${function(file) {
          try {
            return file.addHelper("decorate");
          } catch (err) {
            throw "BABEL_HELPER_UNKNOWN" === err.code && (err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version."), 
            err;
          }
        }(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `;
        isStrict || wrapperCall.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
        let replacement = wrapperCall, classPathDesc = "arguments.1.body.body.0";
        isDeclaration && (replacement = _core.template.statement.ast`let ${ref} = ${wrapperCall}`, 
        classPathDesc = "declarations.0.init." + classPathDesc);
        return {
          instanceNodes: [ _core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)` ],
          wrapClass: path => (path.replaceWith(replacement), path.get(classPathDesc))
        };
      }, exports.hasDecorators = function(node) {
        return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
      }, exports.hasOwnDecorators = hasOwnDecorators;
      var _core = __webpack_require__(4629), _helperReplaceSupers = __webpack_require__(4149), _helperFunctionName = __webpack_require__(1485);
      function hasOwnDecorators(node) {
        return !(!node.decorators || !node.decorators.length);
      }
      function prop(key, value) {
        return value ? _core.types.objectProperty(_core.types.identifier(key), value) : null;
      }
      function takeDecorators(node) {
        let result;
        return node.decorators && node.decorators.length > 0 && (result = _core.types.arrayExpression(node.decorators.map((decorator => decorator.expression)))), 
        node.decorators = void 0, result;
      }
      function getKey(node) {
        return node.computed ? node.key : _core.types.isIdentifier(node.key) ? _core.types.stringLiteral(node.key.name) : _core.types.stringLiteral(String(node.key.value));
      }
      function extractElementDescriptor(classRef, superRef, path) {
        const {node, scope} = path, isMethod = path.isClassMethod();
        if (path.isPrivate()) throw path.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
        new _helperReplaceSupers.default({
          methodPath: path,
          objectRef: classRef,
          superRef,
          file: this,
          refToPreserve: classRef
        }).replace();
        const properties = [ prop("kind", _core.types.stringLiteral(_core.types.isClassMethod(node) ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", !(null != _core.types.isStaticBlock && _core.types.isStaticBlock(node)) && node.static && _core.types.booleanLiteral(!0)), prop("key", getKey(node)) ].filter(Boolean);
        if (_core.types.isClassMethod(node)) {
          const id = node.computed ? null : node.key;
          _core.types.toExpression(node), properties.push(prop("value", (0, _helperFunctionName.default)({
            node,
            id,
            scope
          }) || node));
        } else _core.types.isClassProperty(node) && node.value ? properties.push((key = "value", 
        body = _core.template.statements.ast`return ${node.value}`, _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body)))) : properties.push(prop("value", scope.buildUndefinedNode()));
        var key, body;
        return path.remove(), _core.types.objectExpression(properties);
      }
    },
    5924: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.FEATURES = void 0, exports.enableFeature = function(file, feature, loose) {
        hasFeature(file, feature) && !canIgnoreLoose(file, feature) || (file.set(featuresKey, file.get(featuresKey) | feature), 
        "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" === loose ? (setLoose(file, feature, !0), 
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" === loose ? (setLoose(file, feature, !1), 
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : setLoose(file, feature, loose));
        let resolvedLoose, higherPriorityPluginName;
        for (const [mask, name] of featuresSameLoose) {
          if (!hasFeature(file, mask)) continue;
          const loose = isLoose(file, mask);
          if (!canIgnoreLoose(file, mask)) {
            if (resolvedLoose === !loose) throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");
            resolvedLoose = loose, higherPriorityPluginName = name;
          }
        }
        if (void 0 !== resolvedLoose) for (const [mask, name] of featuresSameLoose) hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose && (setLoose(file, mask, resolvedLoose), 
        console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.\nThe "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${name}", { "loose": ${resolvedLoose} }]\nto the "plugins" section of your Babel config.`));
      }, exports.isLoose = isLoose, exports.shouldTransform = function(path, file) {
        let decoratorPath = null, publicFieldPath = null, privateFieldPath = null, privateMethodPath = null, staticBlockPath = null;
        (0, _decorators.hasOwnDecorators)(path.node) && (decoratorPath = path.get("decorators.0"));
        for (const el of path.get("body.body")) !decoratorPath && (0, _decorators.hasOwnDecorators)(el.node) && (decoratorPath = el.get("decorators.0")), 
        !publicFieldPath && el.isClassProperty() && (publicFieldPath = el), !privateFieldPath && el.isClassPrivateProperty() && (privateFieldPath = el), 
        !privateMethodPath && null != el.isClassPrivateMethod && el.isClassPrivateMethod() && (privateMethodPath = el), 
        !staticBlockPath && null != el.isStaticBlock && el.isStaticBlock() && (staticBlockPath = el);
        if (decoratorPath && privateFieldPath) throw privateFieldPath.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
        if (decoratorPath && privateMethodPath) throw privateMethodPath.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
        if (decoratorPath && !hasFeature(file, FEATURES.decorators)) throw path.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
        if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods)) throw privateMethodPath.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-proposal-private-method` to your configuration.");
        if ((publicFieldPath || privateFieldPath) && !hasFeature(file, FEATURES.fields) && !hasFeature(file, FEATURES.privateMethods)) throw path.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-proposal-class-properties` to your configuration.");
        if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks)) throw path.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.");
        if (decoratorPath || privateMethodPath || staticBlockPath) return !0;
        if ((publicFieldPath || privateFieldPath) && hasFeature(file, FEATURES.fields)) return !0;
        return !1;
      };
      var _decorators = __webpack_require__(3280);
      const FEATURES = Object.freeze({
        fields: 2,
        privateMethods: 4,
        decorators: 8,
        privateIn: 16,
        staticBlocks: 32
      });
      exports.FEATURES = FEATURES;
      const featuresSameLoose = new Map([ [ FEATURES.fields, "@babel/plugin-proposal-class-properties" ], [ FEATURES.privateMethods, "@babel/plugin-proposal-private-methods" ], [ FEATURES.privateIn, "@babel/plugin-proposal-private-property-in-object" ] ]), featuresKey = "@babel/plugin-class-features/featuresKey", looseKey = "@babel/plugin-class-features/looseKey", looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
      function hasFeature(file, feature) {
        return !!(file.get(featuresKey) & feature);
      }
      function isLoose(file, feature) {
        return !!(file.get(looseKey) & feature);
      }
      function setLoose(file, feature, loose) {
        loose ? file.set(looseKey, file.get(looseKey) | feature) : file.set(looseKey, file.get(looseKey) & ~feature), 
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
      }
      function canIgnoreLoose(file, feature) {
        return !!(file.get(looseLowPriorityKey) & feature);
      }
    },
    6523: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.buildFieldsInitNodes = function(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
        let injectSuperRef, needsClassRef = !1;
        const staticNodes = [], instanceNodes = [], pureStaticNodes = [], getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => (null != injectSuperRef || (injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef)), 
        injectSuperRef);
        for (const prop of props) {
          prop.isClassProperty() && ts.assertFieldTransformed(prop);
          const isStatic = !(null != _core.types.isStaticBlock && _core.types.isStaticBlock(prop.node)) && prop.node.static, isInstance = !isStatic, isPrivate = prop.isPrivate(), isPublic = !isPrivate, isField = prop.isProperty(), isMethod = !isField, isStaticBlock = null == prop.isStaticBlock ? void 0 : prop.isStaticBlock();
          if (isStatic || isMethod && isPrivate || isStaticBlock) {
            const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);
            needsClassRef = needsClassRef || replaced;
          }
          switch (!0) {
           case isStaticBlock:
            {
              const blockBody = prop.node.body;
              1 === blockBody.length && _core.types.isExpressionStatement(blockBody[0]) ? staticNodes.push(blockBody[0]) : staticNodes.push(_core.template.statement.ast`(() => { ${blockBody} })()`);
              break;
            }

           case isStatic && isPrivate && isField && privateFieldsAsProperties:
            needsClassRef = !0, staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
            break;

           case isStatic && isPrivate && isField && !privateFieldsAsProperties:
            needsClassRef = !0, staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
            break;

           case isStatic && isPublic && isField && setPublicClassFields:
            if (!isNameOrLength(prop.node)) {
              needsClassRef = !0, staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
              break;
            }

           case isStatic && isPublic && isField && !setPublicClassFields:
            needsClassRef = !0, staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));
            break;

           case isInstance && isPrivate && isField && privateFieldsAsProperties:
            instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
            break;

           case isInstance && isPrivate && isField && !privateFieldsAsProperties:
            instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));
            break;

           case isInstance && isPrivate && isMethod && privateFieldsAsProperties:
            instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap)), 
            pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
            break;

           case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:
            instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state)), 
            pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
            break;

           case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:
            needsClassRef = !0, staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap)), 
            pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
            break;

           case isStatic && isPrivate && isMethod && privateFieldsAsProperties:
            needsClassRef = !0, staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap)), 
            pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
            break;

           case isInstance && isPublic && isField && setPublicClassFields:
            instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
            break;

           case isInstance && isPublic && isField && !setPublicClassFields:
            instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));
            break;

           default:
            throw new Error("Unreachable.");
          }
        }
        return {
          staticNodes: staticNodes.filter(Boolean),
          instanceNodes: instanceNodes.filter(Boolean),
          pureStaticNodes: pureStaticNodes.filter(Boolean),
          wrapClass(path) {
            for (const prop of props) prop.remove();
            return injectSuperRef && (path.scope.push({
              id: _core.types.cloneNode(injectSuperRef)
            }), path.set("superClass", _core.types.assignmentExpression("=", injectSuperRef, path.node.superClass))), 
            needsClassRef ? (path.isClassExpression() ? (path.scope.push({
              id: ref
            }), path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node))) : path.node.id || (path.node.id = ref), 
            path) : path;
          }
        };
      }, exports.buildPrivateNamesMap = function(props) {
        const privateNamesMap = new Map;
        for (const prop of props) if (prop.isPrivate()) {
          const {name} = prop.node.key.id, update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
            id: prop.scope.generateUidIdentifier(name),
            static: prop.node.static,
            method: !prop.isProperty()
          };
          prop.isClassPrivateMethod() && ("get" === prop.node.kind ? update.getId = prop.scope.generateUidIdentifier(`get_${name}`) : "set" === prop.node.kind ? update.setId = prop.scope.generateUidIdentifier(`set_${name}`) : "method" === prop.node.kind && (update.methodId = prop.scope.generateUidIdentifier(name))), 
          privateNamesMap.set(name, update);
        }
        return privateNamesMap;
      }, exports.buildPrivateNamesNodes = function(privateNamesMap, privateFieldsAsProperties, state) {
        const initNodes = [];
        for (const [name, value] of privateNamesMap) {
          const {static: isStatic, method: isMethod, getId, setId} = value, isAccessor = getId || setId, id = _core.types.cloneNode(value.id);
          let init;
          privateFieldsAsProperties ? init = _core.types.callExpression(state.addHelper("classPrivateFieldLooseKey"), [ _core.types.stringLiteral(name) ]) : isStatic || (init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), [])), 
          init && ((0, _helperAnnotateAsPure.default)(init), initNodes.push(_core.template.statement.ast`var ${id} = ${init}`));
        }
        return initNodes;
      }, exports.transformPrivateNamesUsage = function(ref, path, privateNamesMap, {privateFieldsAsProperties, noDocumentAll, innerBinding}, state) {
        if (!privateNamesMap.size) return;
        const body = path.get("body"), handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
        (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({
          privateNamesMap,
          classRef: ref,
          file: state
        }, handler, {
          noDocumentAll,
          innerBinding
        })), body.traverse(privateInVisitor, {
          privateNamesMap,
          classRef: ref,
          file: state,
          privateFieldsAsProperties,
          innerBinding
        });
      };
      var _core = __webpack_require__(4629), _helperReplaceSupers = __webpack_require__(4149), _helperEnvironmentVisitor = __webpack_require__(1692), _helperMemberExpressionToFunctions = __webpack_require__(9693), _helperOptimiseCallExpression = __webpack_require__(3934), _helperAnnotateAsPure = __webpack_require__(4321), ts = __webpack_require__(7404);
      function privateNameVisitorFactory(visitor) {
        const privateNameVisitor = Object.assign({}, visitor, {
          Class(path) {
            const {privateNamesMap} = this, body = path.get("body.body"), visiblePrivateNames = new Map(privateNamesMap), redeclared = [];
            for (const prop of body) {
              if (!prop.isPrivate()) continue;
              const {name} = prop.node.key.id;
              visiblePrivateNames.delete(name), redeclared.push(name);
            }
            redeclared.length && (path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
              redeclared
            })), path.traverse(privateNameVisitor, Object.assign({}, this, {
              privateNamesMap: visiblePrivateNames
            })), path.skipKey("body"));
          }
        }), nestedVisitor = _core.traverse.visitors.merge([ Object.assign({}, visitor), _helperEnvironmentVisitor.default ]);
        return privateNameVisitor;
      }
      const privateNameVisitor = privateNameVisitorFactory({
        PrivateName(path, {noDocumentAll}) {
          const {privateNamesMap, redeclared} = this, {node, parentPath} = path;
          if (!parentPath.isMemberExpression({
            property: node
          }) && !parentPath.isOptionalMemberExpression({
            property: node
          })) return;
          const {name} = node.id;
          privateNamesMap.has(name) && (redeclared && redeclared.includes(name) || this.handle(parentPath, noDocumentAll));
        }
      });
      function unshadow(name, scope, innerBinding) {
        for (;null != (_scope = scope) && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding); ) {
          var _scope;
          scope.rename(name), scope = scope.parent;
        }
      }
      const privateInVisitor = privateNameVisitorFactory({
        BinaryExpression(path) {
          const {operator, left, right} = path.node;
          if ("in" !== operator) return;
          if (!_core.types.isPrivateName(left)) return;
          const {privateFieldsAsProperties, privateNamesMap, redeclared} = this, {name} = left.id;
          if (!privateNamesMap.has(name)) return;
          if (redeclared && redeclared.includes(name)) return;
          if (unshadow(this.classRef.name, path.scope, this.innerBinding), privateFieldsAsProperties) {
            const {id} = privateNamesMap.get(name);
            return void path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${right}, ${_core.types.cloneNode(id)})
      `);
          }
          const {id, static: isStatic} = privateNamesMap.get(name);
          isStatic ? path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`) : path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${right})`);
        }
      }), privateNameHandlerSpec = {
        memoise(member, count) {
          const {scope} = member, {object} = member.node, memo = scope.maybeGenerateMemoised(object);
          memo && this.memoiser.set(object, memo, count);
        },
        receiver(member) {
          const {object} = member.node;
          return this.memoiser.has(object) ? _core.types.cloneNode(this.memoiser.get(object)) : _core.types.cloneNode(object);
        },
        get(member) {
          const {classRef, privateNamesMap, file, innerBinding} = this, {name} = member.node.property.id, {id, static: isStatic, method: isMethod, methodId, getId, setId} = privateNamesMap.get(name), isAccessor = getId || setId;
          if (isStatic) {
            const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
            return unshadow(classRef.name, member.scope, innerBinding), _core.types.callExpression(file.addHelper(helperName), [ this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id) ]);
          }
          if (isMethod) {
            if (isAccessor) {
              if (!getId && setId) {
                if (file.availableHelper("writeOnlyError")) return _core.types.sequenceExpression([ this.receiver(member), _core.types.callExpression(file.addHelper("writeOnlyError"), [ _core.types.stringLiteral(`#${name}`) ]) ]);
                console.warn("@babel/helpers is outdated, update it to silence this warning.");
              }
              return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [ this.receiver(member), _core.types.cloneNode(id) ]);
            }
            return _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [ this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId) ]);
          }
          return _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [ this.receiver(member), _core.types.cloneNode(id) ]);
        },
        boundGet(member) {
          return this.memoise(member, 1), _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [ this.receiver(member) ]);
        },
        set(member, value) {
          const {classRef, privateNamesMap, file} = this, {name} = member.node.property.id, {id, static: isStatic, method: isMethod, setId, getId} = privateNamesMap.get(name);
          if (isStatic) {
            const helperName = isMethod && !(getId || setId) ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
            return _core.types.callExpression(file.addHelper(helperName), [ this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value ]);
          }
          return isMethod ? setId ? _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [ this.receiver(member), _core.types.cloneNode(id), value ]) : _core.types.sequenceExpression([ this.receiver(member), value, _core.types.callExpression(file.addHelper("readOnlyError"), [ _core.types.stringLiteral(`#${name}`) ]) ]) : _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [ this.receiver(member), _core.types.cloneNode(id), value ]);
        },
        destructureSet(member) {
          const {classRef, privateNamesMap, file} = this, {name} = member.node.property.id, {id, static: isStatic} = privateNamesMap.get(name);
          if (isStatic) {
            try {
              var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
            } catch (_unused) {
              throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
            }
            return _core.types.memberExpression(_core.types.callExpression(helper, [ this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id) ]), _core.types.identifier("value"));
          }
          return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [ this.receiver(member), _core.types.cloneNode(id) ]), _core.types.identifier("value"));
        },
        call(member, args) {
          return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, !1);
        },
        optionalCall(member, args) {
          return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, !0);
        }
      }, privateNameHandlerLoose = {
        get(member) {
          const {privateNamesMap, file} = this, {object} = member.node, {name} = member.node.property.id;
          return _core.template.expression`BASE(REF, PROP)[PROP]`({
            BASE: file.addHelper("classPrivateFieldLooseBase"),
            REF: _core.types.cloneNode(object),
            PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
          });
        },
        set() {
          throw new Error("private name handler with loose = true don't need set()");
        },
        boundGet(member) {
          return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [ _core.types.cloneNode(member.node.object) ]);
        },
        simpleSet(member) {
          return this.get(member);
        },
        destructureSet(member) {
          return this.get(member);
        },
        call(member, args) {
          return _core.types.callExpression(this.get(member), args);
        },
        optionalCall(member, args) {
          return _core.types.optionalCallExpression(this.get(member), args, !0);
        }
      };
      function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
        const {id} = privateNamesMap.get(prop.node.key.id.name), value = prop.node.value || prop.scope.buildUndefinedNode();
        return _core.template.statement.ast`
    Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    });
  `;
      }
      function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {
        const {id} = privateNamesMap.get(prop.node.key.id.name), value = prop.node.value || prop.scope.buildUndefinedNode();
        if (!state.availableHelper("classPrivateFieldInitSpec")) return _core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${value},
      })`;
        const helper = state.addHelper("classPrivateFieldInitSpec");
        return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)},
    {
      writable: true,
      value: ${value}
    },
  )`;
      }
      function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
        const privateName = privateNamesMap.get(prop.node.key.id.name), {id, getId, setId, initAdded} = privateName, isAccessor = getId || setId;
        if (!prop.isProperty() && (initAdded || !isAccessor)) return;
        if (isAccessor) return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: !0
        })), _core.template.statement.ast`
      var ${_core.types.cloneNode(id)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      }
    `;
        const value = prop.node.value || prop.scope.buildUndefinedNode();
        return _core.template.statement.ast`
    var ${_core.types.cloneNode(id)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    };
  `;
      }
      function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
        const privateName = privateNamesMap.get(prop.node.key.id.name), {methodId, id, getId, setId, initAdded} = privateName;
        if (initAdded) return;
        if (methodId) return _core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `;
        return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: !0
        })), _core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      });
    `) : void 0;
      }
      function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {
        const privateName = privateNamesMap.get(prop.node.key.id.name), {getId, setId, initAdded} = privateName;
        if (initAdded) return;
        return getId || setId ? function(ref, prop, privateNamesMap, state) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), {id, getId, setId} = privateName;
          if (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
            initAdded: !0
          })), !state.availableHelper("classPrivateFieldInitSpec")) return _core.template.statement.ast`
      ${id}.set(${ref}, {
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      });
    `;
          const helper = state.addHelper("classPrivateFieldInitSpec");
          return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)},
    {
      get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
      set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
    },
  )`;
        }(ref, prop, privateNamesMap, state) : function(ref, prop, privateNamesMap, state) {
          const privateName = privateNamesMap.get(prop.node.key.id.name), {id} = privateName;
          if (!state.availableHelper("classPrivateMethodInitSpec")) return _core.template.statement.ast`${id}.add(${ref})`;
          const helper = state.addHelper("classPrivateMethodInitSpec");
          return _core.template.statement.ast`${helper}(
    ${_core.types.thisExpression()},
    ${_core.types.cloneNode(id)}
  )`;
        }(ref, prop, privateNamesMap, state);
      }
      function buildPublicFieldInitLoose(ref, prop) {
        const {key, computed} = prop.node, value = prop.node.value || prop.scope.buildUndefinedNode();
        return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));
      }
      function buildPublicFieldInitSpec(ref, prop, state) {
        const {key, computed} = prop.node, value = prop.node.value || prop.scope.buildUndefinedNode();
        return _core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value ]));
      }
      function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
        const privateName = privateNamesMap.get(prop.node.key.id.name), {id, methodId, getId, setId, initAdded} = privateName;
        if (initAdded) return;
        return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          initAdded: !0
        })), _core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      })
    `) : _core.template.statement.ast`
    Object.defineProperty(${ref}, ${id}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${methodId.name}
    });
  `;
      }
      function buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = !1) {
        const privateName = privateNamesMap.get(prop.node.key.id.name), {id, methodId, getId, setId, getterDeclared, setterDeclared, static: isStatic} = privateName, {params, body, generator, async} = prop.node, isGetter = getId && !getterDeclared && 0 === params.length, isSetter = setId && !setterDeclared && params.length > 0;
        let declId = methodId;
        return isGetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          getterDeclared: !0
        })), declId = getId) : isSetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
          setterDeclared: !0
        })), declId = setId) : isStatic && !privateFieldsAsProperties && (declId = id), 
        _core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async);
      }
      const thisContextVisitor = _core.traverse.visitors.merge([ {
        ThisExpression(path, state) {
          state.needsClassRef = !0, path.replaceWith(_core.types.cloneNode(state.classRef));
        },
        MetaProperty(path) {
          const meta = path.get("meta"), property = path.get("property"), {scope} = path;
          meta.isIdentifier({
            name: "new"
          }) && property.isIdentifier({
            name: "target"
          }) && path.replaceWith(scope.buildUndefinedNode());
        }
      }, _helperEnvironmentVisitor.default ]), innerReferencesVisitor = {
        ReferencedIdentifier(path, state) {
          path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding) && (state.needsClassRef = !0, 
          path.node.name = state.classRef.name);
        }
      };
      function replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {
        var _state$classRef;
        const state = {
          classRef: ref,
          needsClassRef: !1,
          innerBinding: innerBindingRef
        };
        return new _helperReplaceSupers.default({
          methodPath: path,
          constantSuper,
          file,
          refToPreserve: ref,
          getSuperRef,
          getObjectRef: () => (state.needsClassRef = !0, null != _core.types.isStaticBlock && _core.types.isStaticBlock(path.node) || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier("prototype")))
        }).replace(), (isStaticBlock || path.isProperty()) && path.traverse(thisContextVisitor, state), 
        null != (_state$classRef = state.classRef) && _state$classRef.name && state.classRef.name !== (null == innerBindingRef ? void 0 : innerBindingRef.name) && path.traverse(innerReferencesVisitor, state), 
        state.needsClassRef;
      }
      function isNameOrLength({key, computed}) {
        return "Identifier" === key.type ? !computed && ("name" === key.name || "length" === key.name) : "StringLiteral" === key.type && ("name" === key.value || "length" === key.value);
      }
    },
    6890: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "FEATURES", {
        enumerable: !0,
        get: function() {
          return _features.FEATURES;
        }
      }), exports.createClassFeaturePlugin = function({name, feature, loose, manipulateOptions, api = {
        assumption: () => {}
      }, inherits}) {
        const setPublicClassFields = api.assumption("setPublicClassFields"), privateFieldsAsProperties = api.assumption("privateFieldsAsProperties"), constantSuper = api.assumption("constantSuper"), noDocumentAll = api.assumption("noDocumentAll");
        if (!0 === loose) {
          const explicit = [];
          void 0 !== setPublicClassFields && explicit.push('"setPublicClassFields"'), void 0 !== privateFieldsAsProperties && explicit.push('"privateFieldsAsProperties"'), 
          0 !== explicit.length && console.warn(`[${name}]: You are using the "loose: true" option and you are explicitly setting a value for the ${explicit.join(" and ")} assumption${explicit.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsProperties": true\n\t}`);
        }
        return {
          name,
          manipulateOptions,
          inherits,
          pre() {
            (0, _features.enableFeature)(this.file, feature, loose), (!this.file.get(versionKey) || this.file.get(versionKey) < version) && this.file.set(versionKey, version);
          },
          visitor: {
            Class(path, state) {
              if (this.file.get(versionKey) !== version) return;
              if (!(0, _features.shouldTransform)(path, this.file)) return;
              path.isClassDeclaration() && (0, _typescript.assertFieldTransformed)(path);
              const loose = (0, _features.isLoose)(this.file, feature);
              let constructor;
              const isDecorated = (0, _decorators.hasDecorators)(path.node), props = [], elements = [], computedPaths = [], privateNames = new Set, body = path.get("body");
              for (const path of body.get("body")) {
                if ((path.isClassProperty() || path.isClassMethod()) && path.node.computed && computedPaths.push(path), 
                path.isPrivate()) {
                  const {name} = path.node.key.id, getName = `get ${name}`, setName = `set ${name}`;
                  if (path.isClassPrivateMethod()) {
                    if ("get" === path.node.kind) {
                      if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) throw path.buildCodeFrameError("Duplicate private field");
                      privateNames.add(getName).add(name);
                    } else if ("set" === path.node.kind) {
                      if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) throw path.buildCodeFrameError("Duplicate private field");
                      privateNames.add(setName).add(name);
                    }
                  } else {
                    if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) throw path.buildCodeFrameError("Duplicate private field");
                    privateNames.add(name);
                  }
                }
                path.isClassMethod({
                  kind: "constructor"
                }) ? constructor = path : (elements.push(path), (path.isProperty() || path.isPrivate() || null != path.isStaticBlock && path.isStaticBlock()) && props.push(path));
              }
              if (!props.length && !isDecorated) return;
              const innerBinding = path.node.id;
              let ref;
              !innerBinding || path.isClassExpression() ? ((0, _helperFunctionName.default)(path), 
              ref = path.scope.generateUidIdentifier("class")) : ref = _core.types.cloneNode(path.node.id);
              const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props), privateNamesNodes = (0, 
              _fields.buildPrivateNamesNodes)(privateNamesMap, null != privateFieldsAsProperties ? privateFieldsAsProperties : loose, state);
              let keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;
              (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, {
                privateFieldsAsProperties: null != privateFieldsAsProperties ? privateFieldsAsProperties : loose,
                noDocumentAll,
                innerBinding
              }, state), isDecorated ? (staticNodes = pureStaticNodes = keysNodes = [], ({instanceNodes, wrapClass} = (0, 
              _decorators.buildDecoratedClass)(ref, path, elements, this.file))) : (keysNodes = (0, 
              _misc.extractComputedKeys)(ref, path, computedPaths, this.file), ({staticNodes, pureStaticNodes, instanceNodes, wrapClass} = (0, 
              _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, null != setPublicClassFields ? setPublicClassFields : loose, null != privateFieldsAsProperties ? privateFieldsAsProperties : loose, null != constantSuper ? constantSuper : loose, innerBinding))), 
              instanceNodes.length > 0 && (0, _misc.injectInitialization)(path, constructor, instanceNodes, ((referenceVisitor, state) => {
                if (!isDecorated) for (const prop of props) null != _core.types.isStaticBlock && _core.types.isStaticBlock(prop.node) || prop.node.static || prop.traverse(referenceVisitor, state);
              }));
              const wrappedPath = wrapClass(path);
              wrappedPath.insertBefore([ ...privateNamesNodes, ...keysNodes ]), staticNodes.length > 0 && wrappedPath.insertAfter(staticNodes), 
              pureStaticNodes.length > 0 && wrappedPath.find((parent => parent.isStatement() || parent.isDeclaration())).insertAfter(pureStaticNodes);
            },
            ExportDefaultDeclaration(path) {
              if (this.file.get(versionKey) !== version) return;
              const decl = path.get("declaration");
              decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node) && (decl.node.id ? (0, 
              _helperSplitExportDeclaration.default)(path) : decl.node.type = "ClassExpression");
            }
          }
        };
      }, Object.defineProperty(exports, "enableFeature", {
        enumerable: !0,
        get: function() {
          return _features.enableFeature;
        }
      }), Object.defineProperty(exports, "injectInitialization", {
        enumerable: !0,
        get: function() {
          return _misc.injectInitialization;
        }
      });
      var _core = __webpack_require__(4629), _helperFunctionName = __webpack_require__(1485), _helperSplitExportDeclaration = __webpack_require__(4170), _fields = __webpack_require__(6523), _decorators = __webpack_require__(3280), _misc = __webpack_require__(5141), _features = __webpack_require__(5924), _typescript = __webpack_require__(7404);
      const version = "7.17.9".split(".").reduce(((v, x) => 1e5 * v + +x), 0), versionKey = "@babel/plugin-class-features/version";
    },
    5141: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.extractComputedKeys = function(ref, path, computedPaths, file) {
        const declarations = [], state = {
          classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
          file
        };
        for (const computedPath of computedPaths) {
          const computedKey = computedPath.get("key");
          computedKey.isReferencedIdentifier() ? handleClassTDZ(computedKey, state) : computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
          const computedNode = computedPath.node;
          if (!computedKey.isConstantExpression()) {
            const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
            path.scope.push({
              id: ident,
              kind: "let"
            }), declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(ident), computedNode.key))), 
            computedNode.key = _core.types.cloneNode(ident);
          }
        }
        return declarations;
      }, exports.injectInitialization = function(path, constructor, nodes, renamer) {
        if (!nodes.length) return;
        const isDerived = !!path.node.superClass;
        if (!constructor) {
          const newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
          isDerived && (newConstructor.params = [ _core.types.restElement(_core.types.identifier("args")) ], 
          newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)), [constructor] = path.get("body").unshiftContainer("body", newConstructor);
        }
        renamer && renamer(referenceVisitor, {
          scope: constructor.scope
        });
        if (isDerived) {
          const bareSupers = [];
          constructor.traverse(findBareSupers, bareSupers);
          let isFirst = !0;
          for (const bareSuper of bareSupers) isFirst ? (bareSuper.insertAfter(nodes), isFirst = !1) : bareSuper.insertAfter(nodes.map((n => _core.types.cloneNode(n))));
        } else constructor.get("body").unshiftContainer("body", nodes);
      };
      var _core = __webpack_require__(4629), _helperEnvironmentVisitor = __webpack_require__(1692);
      const findBareSupers = _core.traverse.visitors.merge([ {
        Super(path) {
          const {node, parentPath} = path;
          parentPath.isCallExpression({
            callee: node
          }) && this.push(parentPath);
        }
      }, _helperEnvironmentVisitor.default ]), referenceVisitor = {
        "TSTypeAnnotation|TypeAnnotation"(path) {
          path.skip();
        },
        ReferencedIdentifier(path) {
          this.scope.hasOwnBinding(path.node.name) && (this.scope.rename(path.node.name), 
          path.skip());
        }
      };
      function handleClassTDZ(path, state) {
        if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
          const classNameTDZError = state.file.addHelper("classNameTDZError"), throwNode = _core.types.callExpression(classNameTDZError, [ _core.types.stringLiteral(path.node.name) ]);
          path.replaceWith(_core.types.sequenceExpression([ throwNode, path.node ])), path.skip();
        }
      }
      const classFieldDefinitionEvaluationTDZVisitor = {
        ReferencedIdentifier: handleClassTDZ
      };
    },
    7404: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.assertFieldTransformed = function(path) {
        if (path.node.declare) throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators");
      };
    },
    1822: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.FEATURES = void 0, exports.enableFeature = function(features, feature) {
        return features | feature;
      }, exports.featuresKey = void 0, exports.hasFeature = function(features, feature) {
        return !!(features & feature);
      }, exports.runtimeKey = void 0;
      const FEATURES = Object.freeze({
        unicodeFlag: 1,
        dotAllFlag: 2,
        unicodePropertyEscape: 4,
        namedCaptureGroups: 8,
        unicodeSetsFlag_syntax: 16,
        unicodeSetsFlag: 32
      });
      exports.FEATURES = FEATURES;
      exports.featuresKey = "@babel/plugin-regexp-features/featuresKey";
      exports.runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
    },
    1357: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.createRegExpFeaturePlugin = function({name, feature, options = {}, manipulateOptions = () => {}}) {
        return {
          name,
          manipulateOptions,
          pre() {
            var _file$get;
            const {file} = this, features = null != (_file$get = file.get(_features.featuresKey)) ? _file$get : 0;
            let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);
            const {useUnicodeFlag, runtime = !0} = options;
            !1 === useUnicodeFlag && (newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag)), 
            newFeatures !== features && file.set(_features.featuresKey, newFeatures), runtime || file.set(_features.runtimeKey, !1), 
            (!file.has(versionKey) || file.get(versionKey) < version) && file.set(versionKey, version);
          },
          visitor: {
            RegExpLiteral(path) {
              var _file$get2;
              const {node} = path, {file} = this, features = file.get(_features.featuresKey), runtime = null == (_file$get2 = file.get(_features.runtimeKey)) || _file$get2, regexpuOptions = (0, 
              _util.generateRegexpuOptions)(features);
              if ((0, _util.canSkipRegexpu)(node, regexpuOptions)) return;
              const namedCaptureGroups = {};
              if ("transform" === regexpuOptions.namedGroups && (regexpuOptions.onNamedGroup = (name, index) => {
                namedCaptureGroups[name] = index;
              }), node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions), "transform" === regexpuOptions.namedGroups && Object.keys(namedCaptureGroups).length > 0 && runtime && !function(path) {
                return path.parentPath.isMemberExpression({
                  object: path.node,
                  computed: !1
                }) && path.parentPath.get("property").isIdentifier({
                  name: "test"
                });
              }(path)) {
                const call = _core.types.callExpression(this.addHelper("wrapRegExp"), [ node, _core.types.valueToNode(namedCaptureGroups) ]);
                (0, _helperAnnotateAsPure.default)(call), path.replaceWith(call);
              }
              node.flags = (0, _util.transformFlags)(regexpuOptions, node.flags);
            }
          }
        };
      };
      var _regexpuCore = __webpack_require__(3144), _features = __webpack_require__(1822), _util = __webpack_require__(2888), _core = __webpack_require__(4629), _helperAnnotateAsPure = __webpack_require__(4321);
      const version = "7.17.0".split(".").reduce(((v, x) => 1e5 * v + +x), 0), versionKey = "@babel/plugin-regexp-features/version";
    },
    2888: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.canSkipRegexpu = function(node, options) {
        const {flags, pattern} = node;
        if (flags.includes("v") && "transform" === options.unicodeSetsFlag) return !1;
        if (flags.includes("u")) {
          if ("transform" === options.unicodeFlag) return !1;
          if ("transform" === options.unicodePropertyEscapes && /\\[pP]{/.test(pattern)) return !1;
        }
        if (flags.includes("s") && "transform" === options.dotAllFlag) return !1;
        if ("transform" === options.namedGroups && /\(\?<(?![=!])/.test(pattern)) return !1;
        return !0;
      }, exports.generateRegexpuOptions = function(toTransform) {
        const feat = (name, ok = "transform") => !!(0, _features.hasFeature)(toTransform, _features.FEATURES[name]) && ok;
        return {
          unicodeFlag: feat("unicodeFlag"),
          unicodeSetsFlag: feat("unicodeSetsFlag") || feat("unicodeSetsFlag_syntax", "parse"),
          dotAllFlag: feat("dotAllFlag"),
          unicodePropertyEscapes: feat("unicodePropertyEscape"),
          namedGroups: feat("namedCaptureGroups"),
          onNamedGroup: () => {}
        };
      }, exports.transformFlags = function(regexpuOptions, flags) {
        "transform" === regexpuOptions.unicodeSetsFlag && (flags = flags.replace("v", "u"));
        "transform" === regexpuOptions.unicodeFlag && (flags = flags.replace("u", ""));
        "transform" === regexpuOptions.dotAllFlag && (flags = flags.replace("s", ""));
        return flags;
      };
      var _features = __webpack_require__(1822);
    },
    9470: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.stringifyTargetsMultiline = function(targets) {
        return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);
      }, exports.stringifyTargets = function(targets) {
        return JSON.stringify(targets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
      }, exports.presetEnvSilentDebugHeader = void 0;
      var _helperCompilationTargets = __webpack_require__(4077);
      exports.presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";
    },
    7660: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var babel = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4629));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      const {types: t} = babel.default || babel;
      exports.default = class {
        constructor(resolver) {
          this._imports = new WeakMap, this._anonymousImports = new WeakMap, this._lastImports = new WeakMap, 
          this._resolver = resolver;
        }
        storeAnonymous(programPath, url, getVal) {
          const key = this._normalizeKey(programPath, url), imports = this._ensure(this._anonymousImports, programPath, Set);
          if (imports.has(key)) return;
          const node = getVal("script" === programPath.node.sourceType, t.stringLiteral(this._resolver(url)));
          imports.add(key), this._injectImport(programPath, node);
        }
        storeNamed(programPath, url, name, getVal) {
          const key = this._normalizeKey(programPath, url, name), imports = this._ensure(this._imports, programPath, Map);
          if (!imports.has(key)) {
            const {node, name: id} = getVal("script" === programPath.node.sourceType, t.stringLiteral(this._resolver(url)), t.identifier(name));
            imports.set(key, id), this._injectImport(programPath, node);
          }
          return t.identifier(imports.get(key));
        }
        _injectImport(programPath, node) {
          let lastImport = this._lastImports.get(programPath);
          lastImport = lastImport && lastImport.node && lastImport.parent === programPath.node && lastImport.container === programPath.node.body ? lastImport.insertAfter(node) : programPath.unshiftContainer("body", node), 
          lastImport = lastImport[lastImport.length - 1], this._lastImports.set(programPath, lastImport);
        }
        _ensure(map, programPath, Collection) {
          let collection = map.get(programPath);
          return collection || (collection = new Collection, map.set(programPath, collection)), 
          collection;
        }
        _normalizeKey(programPath, url, name = "") {
          const {sourceType} = programPath.node;
          return `${name && sourceType}::${url}::${name}`;
        }
      };
    },
    9695: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(factory) {
        return (0, _helperPluginUtils.declare)(((babelApi, options, dirname) => {
          babelApi.assertVersion(7);
          const {traverse} = babelApi;
          let debugLog;
          const missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi), {debug, method, targets, provider, callProvider} = function(factory, options, missingDependencies, dirname, debugLog, babelApi) {
            const {method, methodName, targets, debug, shouldInjectPolyfill, providerOptions, absoluteImports} = function(options, babelApi) {
              const {method, targets: targetsOption, ignoreBrowserslistConfig, configPath, debug, shouldInjectPolyfill, absoluteImports} = options, providerOptions = function(source, excluded) {
                if (null == source) return {};
                var key, i, target = {}, sourceKeys = Object.keys(source);
                for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
                return target;
              }(options, [ "method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports" ]);
              let methodName, targets;
              if ("usage-global" === method) methodName = "usageGlobal"; else if ("entry-global" === method) methodName = "entryGlobal"; else {
                if ("usage-pure" !== method) throw "string" != typeof method ? new Error(".method must be a string") : new Error(`.method must be one of "entry-global", "usage-global" or "usage-pure" (received ${JSON.stringify(method)})`);
                methodName = "usagePure";
              }
              if ("function" == typeof shouldInjectPolyfill) {
                if (options.include || options.exclude) throw new Error(".include and .exclude are not supported when using the .shouldInjectPolyfill function.");
              } else if (null != shouldInjectPolyfill) throw new Error(`.shouldInjectPolyfill must be a function, or undefined (received ${JSON.stringify(shouldInjectPolyfill)})`);
              if (null != absoluteImports && "boolean" != typeof absoluteImports && "string" != typeof absoluteImports) throw new Error(`.absoluteImports must be a boolean, a string, or undefined (received ${JSON.stringify(absoluteImports)})`);
              if (targetsOption || configPath || ignoreBrowserslistConfig) {
                const targetsObj = "string" == typeof targetsOption || Array.isArray(targetsOption) ? {
                  browsers: targetsOption
                } : targetsOption;
                targets = getTargets(targetsObj, {
                  ignoreBrowserslistConfig,
                  configPath
                });
              } else targets = babelApi.targets();
              return {
                method,
                methodName,
                targets,
                absoluteImports: null != absoluteImports && absoluteImports,
                shouldInjectPolyfill,
                debug: !!debug,
                providerOptions
              };
            }(options, babelApi), getUtils = (0, _utils.createUtilsGetter)(new _importsCache.default((moduleName => deps.resolve(dirname, moduleName, absoluteImports))));
            let include, exclude, polyfillsSupport, polyfillsNames, filterPolyfills;
            const depsCache = new Map, api = {
              babel: babelApi,
              getUtils,
              method: options.method,
              targets,
              createMetaResolver: _metaResolver.default,
              shouldInjectPolyfill(name) {
                if (void 0 === polyfillsNames) throw new Error(`Internal error in the ${factory.name} provider: shouldInjectPolyfill() can't be called during initialization.`);
                if (polyfillsNames.has(name) || console.warn(`Internal error in the ${provider.name} provider: unknown polyfill "${name}".`), 
                filterPolyfills && !filterPolyfills(name)) return !1;
                let shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {
                  compatData: polyfillsSupport,
                  includes: include,
                  excludes: exclude
                });
                if (shouldInjectPolyfill && (shouldInject = shouldInjectPolyfill(name, shouldInject), 
                "boolean" != typeof shouldInject)) throw new Error(".shouldInjectPolyfill must return a boolean.");
                return shouldInject;
              },
              debug(name) {
                debugLog().found = !0, debug && name && (debugLog().polyfills.has(provider.name) || debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]));
              },
              assertDependency(name, version = "*") {
                if (!1 === missingDependencies) return;
                if (absoluteImports) return;
                const dep = "*" === version ? name : `${name}@^${version}`;
                !missingDependencies.all && function(map, key, getDefault) {
                  let val = map.get(key);
                  void 0 === val && (val = getDefault(), map.set(key, val));
                  return val;
                }(depsCache, `${name} :: ${dirname}`, (() => deps.has(dirname, name))) || debugLog().missingDeps.add(dep);
              }
            }, provider = factory(api, providerOptions, dirname);
            if ("function" != typeof provider[methodName]) throw new Error(`The "${provider.name || factory.name}" provider doesn't support the "${method}" polyfilling method.`);
            Array.isArray(provider.polyfills) ? (polyfillsNames = new Set(provider.polyfills), 
            filterPolyfills = provider.filterPolyfills) : provider.polyfills ? (polyfillsNames = new Set(Object.keys(provider.polyfills)), 
            polyfillsSupport = provider.polyfills, filterPolyfills = provider.filterPolyfills) : polyfillsNames = new Set;
            return ({include, exclude} = (0, _normalizeOptions.validateIncludeExclude)(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || [])), 
            {
              debug,
              method,
              targets,
              provider,
              callProvider(payload, path) {
                const utils = getUtils(path);
                provider[methodName](payload, utils, path);
              }
            };
          }(factory, options, missingDependencies, dirname, (() => debugLog), babelApi), createVisitor = "entry-global" === method ? v.entry : v.usage, visitor = provider.visitor ? traverse.visitors.merge([ createVisitor(callProvider), provider.visitor ]) : createVisitor(callProvider);
          return debug && debug !== _debugUtils.presetEnvSilentDebugHeader && (console.log(`${provider.name}: \`DEBUG\` option`), 
          console.log(`\nUsing targets: ${(0, _debugUtils.stringifyTargetsMultiline)(targets)}`), 
          console.log(`\nUsing polyfills with \`${method}\` method:`)), {
            name: "inject-polyfills",
            visitor,
            pre() {
              var _provider$pre;
              debugLog = {
                polyfills: new Map,
                found: !1,
                providers: new Set,
                missingDeps: new Set
              }, null == (_provider$pre = provider.pre) || _provider$pre.apply(this, arguments);
            },
            post() {
              var _provider$post;
              if (null == (_provider$post = provider.post) || _provider$post.apply(this, arguments), 
              !1 !== missingDependencies && ("per-file" === missingDependencies.log ? deps.logMissing(debugLog.missingDeps) : deps.laterLogMissing(debugLog.missingDeps)), 
              debug) if (this.filename && console.log(`\n[${this.filename}]`), 0 !== debugLog.polyfills.size) {
                "entry-global" === method ? console.log(`The ${provider.name} polyfill entry has been replaced with the following polyfills:`) : console.log(`The ${provider.name} polyfill added the following polyfills:`);
                for (const [name, support] of debugLog.polyfills) if (support) {
                  const filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, support), formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
                  console.log(`  ${name} ${formattedTargets}`);
                } else console.log(`  ${name}`);
              } else console.log("entry-global" === method ? debugLog.found ? `Based on your targets, the ${provider.name} polyfill did not add any polyfill.` : `The entry point for the ${provider.name} polyfill has not been found.` : `Based on your code and targets, the ${provider.name} polyfill did not add any polyfill.`);
            }
          };
        }));
      };
      var _helperPluginUtils = __webpack_require__(4982), _helperCompilationTargets = _interopRequireWildcard(__webpack_require__(4077)), _utils = __webpack_require__(4513), _importsCache = _interopRequireDefault(__webpack_require__(7660)), _debugUtils = __webpack_require__(9470), _normalizeOptions = __webpack_require__(1404), v = _interopRequireWildcard(__webpack_require__(7429)), deps = _interopRequireWildcard(__webpack_require__(3495)), _metaResolver = _interopRequireDefault(__webpack_require__(2821));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
      }
      const getTargets = _helperCompilationTargets.default.default || _helperCompilationTargets.default;
    },
    2821: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(polyfills) {
        const {static: staticP, instance: instanceP, global: globalP} = polyfills;
        return meta => {
          if ("global" === meta.kind && globalP && (0, _utils.has)(globalP, meta.name)) return {
            kind: "global",
            desc: globalP[meta.name],
            name: meta.name
          };
          if ("property" === meta.kind || "in" === meta.kind) {
            const {placement, object, key} = meta;
            if (object && "static" === placement) {
              if (globalP && PossibleGlobalObjects.has(object) && (0, _utils.has)(globalP, key)) return {
                kind: "global",
                desc: globalP[key],
                name: key
              };
              if (staticP && (0, _utils.has)(staticP, object) && (0, _utils.has)(staticP[object], key)) return {
                kind: "static",
                desc: staticP[object][key],
                name: `${object}$${key}`
              };
            }
            if (instanceP && (0, _utils.has)(instanceP, key)) return {
              kind: "instance",
              desc: instanceP[key],
              name: `${key}`
            };
          }
        };
      };
      var _utils = __webpack_require__(4513);
      const PossibleGlobalObjects = new Set([ "global", "globalThis", "self", "window" ]);
    },
    1404: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.validateIncludeExclude = function(provider, polyfills, includePatterns, excludePatterns) {
        let current;
        const filter = pattern => {
          const regexp = function(pattern) {
            if (pattern instanceof RegExp) return pattern;
            try {
              return new RegExp(`^${pattern}$`);
            } catch (_unused) {
              return null;
            }
          }(pattern);
          if (!regexp) return !1;
          let matched = !1;
          for (const polyfill of polyfills) regexp.test(polyfill) && (matched = !0, current.add(polyfill));
          return !matched;
        }, include = current = new Set, unusedInclude = Array.from(includePatterns).filter(filter), exclude = current = new Set, unusedExclude = Array.from(excludePatterns).filter(filter), duplicates = (0, 
        _utils.intersection)(include, exclude);
        if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) throw new Error(`Error while validating the "${provider}" provider options:\n` + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + function(duplicates) {
          return duplicates.size ? '  - The following polyfills were matched both by "include" and "exclude" patterns:\n' + Array.from(duplicates, (name => `    ${name}\n`)).join("") : "";
        }(duplicates));
        return {
          include,
          exclude
        };
      }, exports.applyMissingDependenciesDefaults = function(options, babelApi) {
        const {missingDependencies = {}} = options;
        if (!1 === missingDependencies) return !1;
        const caller = babelApi.caller((caller => null == caller ? void 0 : caller.name)), {log = "deferred", inject = "rollup-plugin-babel" === caller ? "throw" : "import", all = !1} = missingDependencies;
        return {
          log,
          inject,
          all
        };
      };
      var _utils = __webpack_require__(4513);
      function buildUnusedError(label, unused) {
        return unused.length ? `  - The following "${label}" patterns didn't match any polyfill:\n` + unused.map((original => `    ${String(original)}\n`)).join("") : "";
      }
    },
    4513: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.intersection = function(a, b) {
        const result = new Set;
        return a.forEach((v => b.has(v) && result.add(v))), result;
      }, exports.has = function(object, key) {
        return Object.prototype.hasOwnProperty.call(object, key);
      }, exports.resolveKey = function resolveKey(path, computed = !1) {
        const {node, parent, scope} = path;
        if (path.isStringLiteral()) return node.value;
        const {name} = node, isIdentifier = path.isIdentifier();
        if (isIdentifier && !computed && !parent.computed) return name;
        if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
          name: "Symbol"
        }) && !scope.hasBinding("Symbol", !0)) {
          const sym = resolveKey(path.get("property"), path.node.computed);
          if (sym) return "Symbol." + sym;
        }
        if (!isIdentifier || scope.hasBinding(name, !0)) {
          const {value} = path.evaluate();
          if ("string" == typeof value) return value;
        }
      }, exports.resolveSource = function(obj) {
        if (obj.isMemberExpression() && obj.get("property").isIdentifier({
          name: "prototype"
        })) {
          const id = resolveId(obj.get("object"));
          return id ? {
            id,
            placement: "prototype"
          } : {
            id: null,
            placement: null
          };
        }
        const id = resolveId(obj);
        if (id) return {
          id,
          placement: "static"
        };
        const {value} = obj.evaluate();
        if (void 0 !== value) return {
          id: (target = value, Object.prototype.toString.call(target).slice(8, -1)),
          placement: "prototype"
        };
        if (obj.isRegExpLiteral()) return {
          id: "RegExp",
          placement: "prototype"
        };
        if (obj.isFunction()) return {
          id: "Function",
          placement: "prototype"
        };
        var target;
        return {
          id: null,
          placement: null
        };
      }, exports.getImportSource = function({node}) {
        if (0 === node.specifiers.length) return node.source.value;
      }, exports.getRequireSource = function({node}) {
        if (!t.isExpressionStatement(node)) return;
        const {expression} = node;
        if (t.isCallExpression(expression) && t.isIdentifier(expression.callee) && "require" === expression.callee.name && 1 === expression.arguments.length && t.isStringLiteral(expression.arguments[0])) return expression.arguments[0].value;
      }, exports.createUtilsGetter = function(cache) {
        return path => {
          const prog = path.findParent((p => p.isProgram()));
          return {
            injectGlobalImport(url) {
              cache.storeAnonymous(prog, url, ((isScript, source) => isScript ? template.statement.ast`require(${source})` : t.importDeclaration([], source)));
            },
            injectNamedImport: (url, name, hint = name) => cache.storeNamed(prog, url, name, ((isScript, source, name) => {
              const id = prog.scope.generateUidIdentifier(hint);
              return {
                node: isScript ? hoist(template.statement.ast`
                  var ${id} = require(${source}).${name}
                `) : t.importDeclaration([ t.importSpecifier(id, name) ], source),
                name: id.name
              };
            })),
            injectDefaultImport: (url, hint = url) => cache.storeNamed(prog, url, "default", ((isScript, source) => {
              const id = prog.scope.generateUidIdentifier(hint);
              return {
                node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t.importDeclaration([ t.importDefaultSpecifier(id) ], source),
                name: id.name
              };
            }))
          };
        };
      };
      var babel = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4629));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      const {types: t, template} = babel.default || babel;
      function resolveId(path) {
        if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, !0)) return path.node.name;
        const {deopt} = path.evaluate();
        return deopt && deopt.isIdentifier() ? deopt.node.name : void 0;
      }
      function hoist(node) {
        return node._blockHoist = 3, node;
      }
    },
    9184: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _utils = __webpack_require__(4513);
      exports.default = callProvider => ({
        ImportDeclaration(path) {
          const source = (0, _utils.getImportSource)(path);
          source && callProvider({
            kind: "import",
            source
          }, path);
        },
        Program(path) {
          path.get("body").forEach((bodyPath => {
            const source = (0, _utils.getRequireSource)(bodyPath);
            source && callProvider({
              kind: "import",
              source
            }, bodyPath);
          }));
        }
      });
    },
    7429: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.entry = exports.usage = void 0;
      var _usage = _interopRequireDefault(__webpack_require__(2895));
      exports.usage = _usage.default;
      var _entry = _interopRequireDefault(__webpack_require__(9184));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      exports.entry = _entry.default;
    },
    2895: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _utils = __webpack_require__(4513);
      exports.default = callProvider => {
        function property(object, key, placement, path) {
          return callProvider({
            kind: "property",
            object,
            key,
            placement
          }, path);
        }
        return {
          ReferencedIdentifier(path) {
            const {node: {name}, scope} = path;
            scope.getBindingIdentifier(name) || callProvider({
              kind: "global",
              name
            }, path);
          },
          MemberExpression(path) {
            const key = (0, _utils.resolveKey)(path.get("property"), path.node.computed);
            if (!key || "prototype" === key) return;
            const object = path.get("object"), binding = object.scope.getBinding(object.node.name);
            if (binding && binding.path.isImportNamespaceSpecifier()) return;
            const source = (0, _utils.resolveSource)(object);
            return property(source.id, key, source.placement, path);
          },
          ObjectPattern(path) {
            const {parentPath, parent} = path;
            let obj;
            if (parentPath.isVariableDeclarator()) obj = parentPath.get("init"); else if (parentPath.isAssignmentExpression()) obj = parentPath.get("right"); else if (parentPath.isFunction()) {
              const grand = parentPath.parentPath;
              (grand.isCallExpression() || grand.isNewExpression()) && grand.node.callee === parent && (obj = grand.get("arguments")[path.key]);
            }
            let id = null, placement = null;
            obj && ({id, placement} = (0, _utils.resolveSource)(obj));
            for (const prop of path.get("properties")) if (prop.isObjectProperty()) {
              const key = (0, _utils.resolveKey)(prop.get("key"));
              key && property(id, key, placement, prop);
            }
          },
          BinaryExpression(path) {
            if ("in" !== path.node.operator) return;
            const source = (0, _utils.resolveSource)(path.get("right")), key = (0, _utils.resolveKey)(path.get("left"), !0);
            key && callProvider({
              kind: "in",
              object: source.id,
              key,
              placement: source.placement
            }, path);
          }
        };
      };
    },
    1692: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0, exports.skipAllButComputedKey = skipAllButComputedKey;
      var _t = __webpack_require__(8218);
      const {VISITOR_KEYS, staticBlock} = _t;
      function skipAllButComputedKey(path) {
        if (!path.node.computed) return void path.skip();
        const keys = VISITOR_KEYS[path.type];
        for (const key of keys) "key" !== key && path.skipKey(key);
      }
      var _default = {
        [(staticBlock ? "StaticBlock|" : "") + "ClassPrivateProperty|TypeAnnotation|FunctionDeclaration|FunctionExpression"]: path => path.skip(),
        "Method|ClassProperty"(path) {
          skipAllButComputedKey(path);
        }
      };
      exports.default = _default;
    },
    3538: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, nodes, file, scope, allowedSingleIdent) {
        let obj, ref, uid;
        obj = isIdentifier(node) && allowedSingleIdent ? node : function(node, nodes, scope) {
          let ref;
          if (isIdentifier(node)) {
            if (scope.hasBinding(node.name)) return node;
            ref = node;
          } else {
            if (!isMemberExpression(node)) throw new Error(`We can't explode this node type ${node.type}`);
            if (ref = node.object, isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) return ref;
          }
          const temp = scope.generateUidIdentifierBasedOnNode(ref);
          return scope.push({
            id: temp
          }), nodes.push(assignmentExpression("=", cloneNode(temp), cloneNode(ref))), temp;
        }(node, nodes, scope);
        if (isIdentifier(node)) ref = cloneNode(node), uid = obj; else {
          const prop = function(node, nodes, scope) {
            const prop = node.property;
            if (isPrivateName(prop)) throw new Error("We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`");
            const key = toComputedKey(node, prop);
            if (isLiteral(key) && isPureish(key)) return key;
            const temp = scope.generateUidIdentifierBasedOnNode(prop);
            return scope.push({
              id: temp
            }), nodes.push(assignmentExpression("=", cloneNode(temp), cloneNode(prop))), temp;
          }(node, nodes, scope), computed = node.computed || isLiteral(prop);
          uid = memberExpression(cloneNode(obj), cloneNode(prop), computed), ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);
        }
        return {
          uid,
          ref
        };
      };
      var _t = __webpack_require__(8218);
      const {assignmentExpression, cloneNode, isIdentifier, isLiteral, isMemberExpression, isPrivateName, isPureish, isSuper, memberExpression, toComputedKey} = _t;
    },
    1485: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function({node, parent, scope, id}, localBinding = !1, supportUnicodeId = !1) {
        if (node.id) return;
        if (!isObjectProperty(parent) && !isObjectMethod(parent, {
          kind: "method"
        }) || parent.computed && !isLiteral(parent.key)) {
          if (isVariableDeclarator(parent)) {
            if (id = parent.id, isIdentifier(id) && !localBinding) {
              const binding = scope.parent.getBinding(id.name);
              if (binding && binding.constant && scope.getBinding(id.name) === binding) return node.id = cloneNode(id), 
              void (node.id[NOT_LOCAL_BINDING] = !0);
            }
          } else if (isAssignmentExpression(parent, {
            operator: "="
          })) id = parent.left; else if (!id) return;
        } else id = parent.key;
        let name;
        id && isLiteral(id) ? name = function(id) {
          if (isNullLiteral(id)) return "null";
          if (isRegExpLiteral(id)) return `_${id.pattern}_${id.flags}`;
          if (isTemplateLiteral(id)) return id.quasis.map((quasi => quasi.value.raw)).join("");
          if (void 0 !== id.value) return id.value + "";
          return "";
        }(id) : id && isIdentifier(id) && (name = id.name);
        if (void 0 === name) return;
        if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name)) return;
        name = toBindingIdentifierName(name), (id = identifier(name))[NOT_LOCAL_BINDING] = !0;
        return function(state, method, id, scope) {
          if (state.selfReference) {
            if (!scope.hasBinding(id.name) || scope.hasGlobal(id.name)) {
              if (!isFunction(method)) return;
              let build = buildPropertyMethodAssignmentWrapper;
              method.generator && (build = buildGeneratorPropertyMethodAssignmentWrapper);
              const template = build({
                FUNCTION: method,
                FUNCTION_ID: id,
                FUNCTION_KEY: scope.generateUidIdentifier(id.name)
              }).expression, params = template.callee.body.body[0].params;
              for (let i = 0, len = function(node) {
                const count = node.params.findIndex((param => isAssignmentPattern(param) || isRestElement(param)));
                return -1 === count ? node.params.length : count;
              }(method); i < len; i++) params.push(scope.generateUidIdentifier("x"));
              return template;
            }
            scope.rename(id.name);
          }
          method.id = id, scope.getProgramParent().references[id.name] = !0;
        }(function(node, name, scope) {
          const state = {
            selfAssignment: !1,
            selfReference: !1,
            outerDeclar: scope.getBindingIdentifier(name),
            references: [],
            name
          }, binding = scope.getOwnBinding(name);
          binding ? "param" === binding.kind && (state.selfReference = !0) : (state.outerDeclar || scope.hasGlobal(name)) && scope.traverse(node, visitor, state);
          return state;
        }(node, name, scope), node, id, scope) || node;
      };
      var _template = __webpack_require__(4847), _t = __webpack_require__(8218);
      const {NOT_LOCAL_BINDING, cloneNode, identifier, isAssignmentExpression, isAssignmentPattern, isFunction, isIdentifier, isLiteral, isNullLiteral, isObjectMethod, isObjectProperty, isRegExpLiteral, isRestElement, isTemplateLiteral, isVariableDeclarator, toBindingIdentifierName} = _t;
      const buildPropertyMethodAssignmentWrapper = (0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), buildGeneratorPropertyMethodAssignmentWrapper = (0, 
      _template.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), visitor = {
        "ReferencedIdentifier|BindingIdentifier"(path, state) {
          if (path.node.name !== state.name) return;
          path.scope.getBindingIdentifier(state.name) === state.outerDeclar && (state.selfReference = !0, 
          path.stop());
        }
      };
    },
    9061: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, emit, kind = "var") {
        path.traverse(visitor, {
          kind,
          emit
        });
      };
      var _t = __webpack_require__(8218);
      const {assignmentExpression, expressionStatement, identifier} = _t, visitor = {
        Scope(path, state) {
          "let" === state.kind && path.skip();
        },
        FunctionParent(path) {
          path.skip();
        },
        VariableDeclaration(path, state) {
          if (state.kind && path.node.kind !== state.kind) return;
          const nodes = [], declarations = path.get("declarations");
          let firstId;
          for (const declar of declarations) {
            firstId = declar.node.id, declar.node.init && nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
            for (const name of Object.keys(declar.getBindingIdentifiers())) state.emit(identifier(name), name, null !== declar.node.init);
          }
          path.parentPath.isFor({
            left: path.node
          }) ? path.replaceWith(firstId) : path.replaceWithMultiple(nodes);
        }
      };
    },
    9693: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        return e && Object.keys(e).forEach((function(k) {
          if ("default" !== k) {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: !0,
              get: function() {
                return e[k];
              }
            });
          }
        })), n.default = e, Object.freeze(n);
      }
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var _t__namespace = _interopNamespace(__webpack_require__(8218));
      function willPathCastToBoolean(path) {
        const maybeWrapped = path, {node, parentPath} = maybeWrapped;
        if (parentPath.isLogicalExpression()) {
          const {operator, right} = parentPath.node;
          if ("&&" === operator || "||" === operator || "??" === operator && node === right) return willPathCastToBoolean(parentPath);
        }
        if (parentPath.isSequenceExpression()) {
          const {expressions} = parentPath.node;
          return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
        }
        return parentPath.isConditional({
          test: node
        }) || parentPath.isUnaryExpression({
          operator: "!"
        }) || parentPath.isLoop({
          test: node
        });
      }
      const {LOGICAL_OPERATORS, arrowFunctionExpression, assignmentExpression, binaryExpression, booleanLiteral, callExpression, cloneNode, conditionalExpression, identifier, isMemberExpression, isOptionalCallExpression, isOptionalMemberExpression, isUpdateExpression, logicalExpression, memberExpression, nullLiteral, optionalCallExpression, optionalMemberExpression, sequenceExpression, updateExpression} = _t__namespace;
      class AssignmentMemoiser {
        constructor() {
          this._map = void 0, this._map = new WeakMap;
        }
        has(key) {
          return this._map.has(key);
        }
        get(key) {
          if (!this.has(key)) return;
          const record = this._map.get(key), {value} = record;
          return record.count--, 0 === record.count ? assignmentExpression("=", value, key) : value;
        }
        set(key, value, count) {
          return this._map.set(key, {
            count,
            value
          });
        }
      }
      function toNonOptional(path, base) {
        const {node} = path;
        if (isOptionalMemberExpression(node)) return memberExpression(base, node.property, node.computed);
        if (path.isOptionalCallExpression()) {
          const callee = path.get("callee");
          if (path.node.optional && callee.isOptionalMemberExpression()) {
            const {object} = callee.node, context = path.scope.maybeGenerateMemoised(object) || object;
            return callee.get("object").replaceWith(assignmentExpression("=", context, object)), 
            callExpression(memberExpression(base, identifier("call")), [ context, ...path.node.arguments ]);
          }
          return callExpression(base, path.node.arguments);
        }
        return path.node;
      }
      const handle = {
        memoise() {},
        handle(member, noDocumentAll) {
          const {node, parent, parentPath, scope} = member;
          if (member.isOptionalMemberExpression()) {
            if (function(path) {
              for (;path && !path.isProgram(); ) {
                const {parentPath, container, listKey} = path, parentNode = parentPath.node;
                if (listKey) {
                  if (container !== parentNode[listKey]) return !0;
                } else if (container !== parentNode) return !0;
                path = parentPath;
              }
              return !1;
            }(member)) return;
            const endPath = member.find((({node, parent}) => isOptionalMemberExpression(parent) ? parent.optional || parent.object !== node : !isOptionalCallExpression(parent) || (node !== member.node && parent.optional || parent.callee !== node)));
            if (scope.path.isPattern()) return void endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
            const willEndPathCastToBoolean = willPathCastToBoolean(endPath), rootParentPath = endPath.parentPath;
            if (rootParentPath.isUpdateExpression({
              argument: node
            }) || rootParentPath.isAssignmentExpression({
              left: node
            })) throw member.buildCodeFrameError("can't handle assignment");
            const isDeleteOperation = rootParentPath.isUnaryExpression({
              operator: "delete"
            });
            if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) throw member.buildCodeFrameError("can't delete a private class element");
            let startingOptional = member;
            for (;;) if (startingOptional.isOptionalMemberExpression()) {
              if (startingOptional.node.optional) break;
              startingOptional = startingOptional.get("object");
            } else {
              if (!startingOptional.isOptionalCallExpression()) throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
              if (startingOptional.node.optional) break;
              startingOptional = startingOptional.get("callee");
            }
            const startingProp = startingOptional.isOptionalMemberExpression() ? "object" : "callee", startingNode = startingOptional.node[startingProp], baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode), baseRef = null != baseNeedsMemoised ? baseNeedsMemoised : startingNode, parentIsOptionalCall = parentPath.isOptionalCallExpression({
              callee: node
            }), isOptionalCall = parent => parentIsOptionalCall, parentIsCall = parentPath.isCallExpression({
              callee: node
            });
            startingOptional.replaceWith(toNonOptional(startingOptional, baseRef)), isOptionalCall() ? parent.optional ? parentPath.replaceWith(this.optionalCall(member, parent.arguments)) : parentPath.replaceWith(this.call(member, parent.arguments)) : parentIsCall ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member));
            let context, regular = member.node;
            for (let current = member; current !== endPath; ) {
              const parentPath = current.parentPath;
              if (parentPath === endPath && isOptionalCall() && parent.optional) {
                regular = parentPath.node;
                break;
              }
              regular = toNonOptional(parentPath, regular), current = parentPath;
            }
            const endParentPath = endPath.parentPath;
            if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
              callee: endPath.node,
              optional: !0
            })) {
              const {object} = regular;
              context = member.scope.maybeGenerateMemoised(object), context && (regular.object = assignmentExpression("=", context, object));
            }
            let replacementPath = endPath;
            isDeleteOperation && (replacementPath = endParentPath, regular = endParentPath.node);
            const baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
            if (willEndPathCastToBoolean) {
              let nonNullishCheck;
              nonNullishCheck = noDocumentAll ? binaryExpression("!=", baseMemoised, nullLiteral()) : logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode())), 
              replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
            } else {
              let nullishCheck;
              nullishCheck = noDocumentAll ? binaryExpression("==", baseMemoised, nullLiteral()) : logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode())), 
              replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(!0) : scope.buildUndefinedNode(), regular));
            }
            if (context) {
              const endParent = endParentPath.node;
              endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), !1, !0), [ cloneNode(context), ...endParent.arguments ], !1));
            }
          } else {
            if (isUpdateExpression(parent, {
              argument: node
            })) {
              if (this.simpleSet) return void member.replaceWith(this.simpleSet(member));
              const {operator, prefix} = parent;
              this.memoise(member, 2);
              const ref = scope.generateUidIdentifierBasedOnNode(node);
              scope.push({
                id: ref
              });
              const seq = [ assignmentExpression("=", cloneNode(ref), this.get(member)) ];
              if (prefix) {
                seq.push(updateExpression(operator, cloneNode(ref), prefix));
                const value = sequenceExpression(seq);
                return void parentPath.replaceWith(this.set(member, value));
              }
              {
                const ref2 = scope.generateUidIdentifierBasedOnNode(node);
                scope.push({
                  id: ref2
                }), seq.push(assignmentExpression("=", cloneNode(ref2), updateExpression(operator, cloneNode(ref), prefix)), cloneNode(ref));
                const value = sequenceExpression(seq);
                return void parentPath.replaceWith(sequenceExpression([ this.set(member, value), cloneNode(ref2) ]));
              }
            }
            if (parentPath.isAssignmentExpression({
              left: node
            })) {
              if (this.simpleSet) return void member.replaceWith(this.simpleSet(member));
              const {operator, right: value} = parentPath.node;
              if ("=" === operator) parentPath.replaceWith(this.set(member, value)); else {
                const operatorTrunc = operator.slice(0, -1);
                LOGICAL_OPERATORS.includes(operatorTrunc) ? (this.memoise(member, 1), parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, value)))) : (this.memoise(member, 2), 
                parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), value))));
              }
            } else {
              if (!parentPath.isCallExpression({
                callee: node
              })) return parentPath.isOptionalCallExpression({
                callee: node
              }) ? scope.path.isPattern() ? void parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), [])) : void parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments)) : void (parentPath.isForXStatement({
                left: node
              }) || parentPath.isObjectProperty({
                value: node
              }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
                left: node
              }) && parentPath.parentPath.isObjectProperty({
                value: parent
              }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
                left: node
              }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement() ? member.replaceWith(this.destructureSet(member)) : parentPath.isTaggedTemplateExpression() ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member)));
              parentPath.replaceWith(this.call(member, parentPath.node.arguments));
            }
          }
        }
      };
      exports.default = function(path, visitor, state) {
        path.traverse(visitor, Object.assign({}, handle, state, {
          memoiser: new AssignmentMemoiser
        }));
      };
    },
    9503: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _assert = __webpack_require__(9491), _t = __webpack_require__(8218);
      const {callExpression, cloneNode, expressionStatement, identifier, importDeclaration, importDefaultSpecifier, importNamespaceSpecifier, importSpecifier, memberExpression, stringLiteral, variableDeclaration, variableDeclarator} = _t;
      exports.default = class {
        constructor(importedSource, scope, hub) {
          this._statements = [], this._resultName = null, this._scope = null, this._hub = null, 
          this._importedSource = void 0, this._scope = scope, this._hub = hub, this._importedSource = importedSource;
        }
        done() {
          return {
            statements: this._statements,
            resultName: this._resultName
          };
        }
        import() {
          return this._statements.push(importDeclaration([], stringLiteral(this._importedSource))), 
          this;
        }
        require() {
          return this._statements.push(expressionStatement(callExpression(identifier("require"), [ stringLiteral(this._importedSource) ]))), 
          this;
        }
        namespace(name = "namespace") {
          const local = this._scope.generateUidIdentifier(name), statement = this._statements[this._statements.length - 1];
          return _assert("ImportDeclaration" === statement.type), _assert(0 === statement.specifiers.length), 
          statement.specifiers = [ importNamespaceSpecifier(local) ], this._resultName = cloneNode(local), 
          this;
        }
        default(name) {
          name = this._scope.generateUidIdentifier(name);
          const statement = this._statements[this._statements.length - 1];
          return _assert("ImportDeclaration" === statement.type), _assert(0 === statement.specifiers.length), 
          statement.specifiers = [ importDefaultSpecifier(name) ], this._resultName = cloneNode(name), 
          this;
        }
        named(name, importName) {
          if ("default" === importName) return this.default(name);
          name = this._scope.generateUidIdentifier(name);
          const statement = this._statements[this._statements.length - 1];
          return _assert("ImportDeclaration" === statement.type), _assert(0 === statement.specifiers.length), 
          statement.specifiers = [ importSpecifier(name, identifier(importName)) ], this._resultName = cloneNode(name), 
          this;
        }
        var(name) {
          name = this._scope.generateUidIdentifier(name);
          let statement = this._statements[this._statements.length - 1];
          return "ExpressionStatement" !== statement.type && (_assert(this._resultName), statement = expressionStatement(this._resultName), 
          this._statements.push(statement)), this._statements[this._statements.length - 1] = variableDeclaration("var", [ variableDeclarator(name, statement.expression) ]), 
          this._resultName = cloneNode(name), this;
        }
        defaultInterop() {
          return this._interop(this._hub.addHelper("interopRequireDefault"));
        }
        wildcardInterop() {
          return this._interop(this._hub.addHelper("interopRequireWildcard"));
        }
        _interop(callee) {
          const statement = this._statements[this._statements.length - 1];
          return "ExpressionStatement" === statement.type ? statement.expression = callExpression(callee, [ statement.expression ]) : "VariableDeclaration" === statement.type ? (_assert(1 === statement.declarations.length), 
          statement.declarations[0].init = callExpression(callee, [ statement.declarations[0].init ])) : _assert.fail("Unexpected type."), 
          this;
        }
        prop(name) {
          const statement = this._statements[this._statements.length - 1];
          return "ExpressionStatement" === statement.type ? statement.expression = memberExpression(statement.expression, identifier(name)) : "VariableDeclaration" === statement.type ? (_assert(1 === statement.declarations.length), 
          statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name))) : _assert.fail("Unexpected type:" + statement.type), 
          this;
        }
        read(name) {
          this._resultName = memberExpression(this._resultName, identifier(name));
        }
      };
    },
    8694: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _assert = __webpack_require__(9491), _t = __webpack_require__(8218), _importBuilder = __webpack_require__(9503), _isModule = __webpack_require__(821);
      const {numericLiteral, sequenceExpression} = _t;
      exports.default = class {
        constructor(path, importedSource, opts) {
          this._defaultOpts = {
            importedSource: null,
            importedType: "commonjs",
            importedInterop: "babel",
            importingInterop: "babel",
            ensureLiveReference: !1,
            ensureNoContext: !1,
            importPosition: "before"
          };
          const programPath = path.find((p => p.isProgram()));
          this._programPath = programPath, this._programScope = programPath.scope, this._hub = programPath.hub, 
          this._defaultOpts = this._applyDefaults(importedSource, opts, !0);
        }
        addDefault(importedSourceIn, opts) {
          return this.addNamed("default", importedSourceIn, opts);
        }
        addNamed(importName, importedSourceIn, opts) {
          return _assert("string" == typeof importName), this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
        }
        addNamespace(importedSourceIn, opts) {
          return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
        }
        addSideEffect(importedSourceIn, opts) {
          return this._generateImport(this._applyDefaults(importedSourceIn, opts), !1);
        }
        _applyDefaults(importedSource, opts, isInit = !1) {
          const optsList = [];
          "string" == typeof importedSource ? (optsList.push({
            importedSource
          }), optsList.push(opts)) : (_assert(!opts, "Unexpected secondary arguments."), optsList.push(importedSource));
          const newOpts = Object.assign({}, this._defaultOpts);
          for (const opts of optsList) opts && (Object.keys(newOpts).forEach((key => {
            void 0 !== opts[key] && (newOpts[key] = opts[key]);
          })), isInit || (void 0 !== opts.nameHint && (newOpts.nameHint = opts.nameHint), 
          void 0 !== opts.blockHoist && (newOpts.blockHoist = opts.blockHoist)));
          return newOpts;
        }
        _generateImport(opts, importName) {
          const isDefault = "default" === importName, isNamed = !!importName && !isDefault, isNamespace = null === importName, {importedSource, importedType, importedInterop, importingInterop, ensureLiveReference, ensureNoContext, nameHint, importPosition, blockHoist} = opts;
          let name = nameHint || importName;
          const isMod = (0, _isModule.default)(this._programPath), isModuleForNode = isMod && "node" === importingInterop, isModuleForBabel = isMod && "babel" === importingInterop;
          if ("after" === importPosition && !isMod) throw new Error('"importPosition": "after" is only supported in modules');
          const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
          if ("es6" === importedType) {
            if (!isModuleForNode && !isModuleForBabel) throw new Error("Cannot import an ES6 module from CommonJS");
            builder.import(), isNamespace ? builder.namespace(nameHint || importedSource) : (isDefault || isNamed) && builder.named(name, importName);
          } else {
            if ("commonjs" !== importedType) throw new Error(`Unexpected interopType "${importedType}"`);
            if ("babel" === importedInterop) if (isModuleForNode) {
              name = "default" !== name ? name : importedSource;
              const es6Default = `${importedSource}$es6Default`;
              builder.import(), isNamespace ? builder.default(es6Default).var(name || importedSource).wildcardInterop() : isDefault ? ensureLiveReference ? builder.default(es6Default).var(name || importedSource).defaultInterop().read("default") : builder.default(es6Default).var(name).defaultInterop().prop(importName) : isNamed && builder.default(es6Default).read(importName);
            } else isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), 
            isNamespace ? builder.var(name || importedSource).wildcardInterop() : (isDefault || isNamed) && ensureLiveReference ? isDefault ? (name = "default" !== name ? name : importedSource, 
            builder.var(name).read(importName), builder.defaultInterop()) : builder.var(importedSource).read(importName) : isDefault ? builder.var(name).defaultInterop().prop(importName) : isNamed && builder.var(name).prop(importName)); else if ("compiled" === importedInterop) isModuleForNode ? (builder.import(), 
            isNamespace ? builder.default(name || importedSource) : (isDefault || isNamed) && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), 
            isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), 
            isNamespace ? builder.var(name || importedSource) : (isDefault || isNamed) && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.prop(importName).var(name))); else {
              if ("uncompiled" !== importedInterop) throw new Error(`Unknown importedInterop "${importedInterop}".`);
              if (isDefault && ensureLiveReference) throw new Error("No live reference for commonjs default");
              isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), 
              isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.named(name, importName)) : (builder.require(), 
              isNamespace ? builder.var(name || importedSource) : isDefault ? builder.var(name) : isNamed && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.var(name).prop(importName)));
            }
          }
          const {statements, resultName} = builder.done();
          return this._insertStatements(statements, importPosition, blockHoist), (isDefault || isNamed) && ensureNoContext && "Identifier" !== resultName.type ? sequenceExpression([ numericLiteral(0), resultName ]) : resultName;
        }
        _insertStatements(statements, importPosition = "before", blockHoist = 3) {
          const body = this._programPath.get("body");
          if ("after" === importPosition) {
            for (let i = body.length - 1; i >= 0; i--) if (body[i].isImportDeclaration()) return void body[i].insertAfter(statements);
          } else {
            statements.forEach((node => {
              node._blockHoist = blockHoist;
            }));
            const targetPath = body.find((p => {
              const val = p.node._blockHoist;
              return Number.isFinite(val) && val < 4;
            }));
            if (targetPath) return void targetPath.insertBefore(statements);
          }
          this._programPath.unshiftContainer("body", statements);
        }
      };
    },
    203: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "ImportInjector", {
        enumerable: !0,
        get: function() {
          return _importInjector.default;
        }
      }), exports.addDefault = function(path, importedSource, opts) {
        return new _importInjector.default(path).addDefault(importedSource, opts);
      }, exports.addNamed = function(path, name, importedSource, opts) {
        return new _importInjector.default(path).addNamed(name, importedSource, opts);
      }, exports.addNamespace = function(path, importedSource, opts) {
        return new _importInjector.default(path).addNamespace(importedSource, opts);
      }, exports.addSideEffect = function(path, importedSource, opts) {
        return new _importInjector.default(path).addSideEffect(importedSource, opts);
      }, Object.defineProperty(exports, "isModule", {
        enumerable: !0,
        get: function() {
          return _isModule.default;
        }
      });
      var _importInjector = __webpack_require__(8694), _isModule = __webpack_require__(821);
    },
    821: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path) {
        const {sourceType} = path.node;
        if ("module" !== sourceType && "script" !== sourceType) throw path.buildCodeFrameError(`Unknown sourceType "${sourceType}", cannot transform.`);
        return "module" === path.node.sourceType;
      };
    },
    6294: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = getModuleName;
      {
        const originalGetModuleName = getModuleName;
        exports.default = getModuleName = function(rootOpts, pluginOpts) {
          var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
          return originalGetModuleName(rootOpts, {
            moduleId: null != (_pluginOpts$moduleId = pluginOpts.moduleId) ? _pluginOpts$moduleId : rootOpts.moduleId,
            moduleIds: null != (_pluginOpts$moduleIds = pluginOpts.moduleIds) ? _pluginOpts$moduleIds : rootOpts.moduleIds,
            getModuleId: null != (_pluginOpts$getModule = pluginOpts.getModuleId) ? _pluginOpts$getModule : rootOpts.getModuleId,
            moduleRoot: null != (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
          });
        };
      }
      function getModuleName(rootOpts, pluginOpts) {
        const {filename, filenameRelative = filename, sourceRoot = pluginOpts.moduleRoot} = rootOpts, {moduleId, moduleIds = !!moduleId, getModuleId, moduleRoot = sourceRoot} = pluginOpts;
        if (!moduleIds) return null;
        if (null != moduleId && !getModuleId) return moduleId;
        let moduleName = null != moduleRoot ? moduleRoot + "/" : "";
        if (filenameRelative) {
          const sourceRootReplacer = null != sourceRoot ? new RegExp("^" + sourceRoot + "/?") : "";
          moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
        }
        return moduleName = moduleName.replace(/\\/g, "/"), getModuleId && getModuleId(moduleName) || moduleName;
      }
    },
    2454: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.buildNamespaceInitStatements = function(metadata, sourceMetadata, constantReexports = !1) {
        const statements = [];
        let srcNamespace = identifier(sourceMetadata.name);
        sourceMetadata.lazy && (srcNamespace = callExpression(srcNamespace, []));
        for (const localName of sourceMetadata.importsNamespace) localName !== sourceMetadata.name && statements.push(_template.default.statement`var NAME = SOURCE;`({
          NAME: localName,
          SOURCE: cloneNode(srcNamespace)
        }));
        constantReexports && statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, !0));
        for (const exportName of sourceMetadata.reexportNamespace) statements.push((sourceMetadata.lazy ? _template.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({
          EXPORTS: metadata.exportName,
          NAME: exportName,
          NAMESPACE: cloneNode(srcNamespace)
        }));
        if (sourceMetadata.reexportAll) {
          const statement = function(metadata, namespace, constantReexports) {
            return (constantReexports ? _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
              NAMESPACE: namespace,
              EXPORTS: metadata.exportName,
              VERIFY_NAME_LIST: metadata.exportNameListName ? _template.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
                EXPORTS_LIST: metadata.exportNameListName
              }) : null
            });
          }(metadata, cloneNode(srcNamespace), constantReexports);
          statement.loc = sourceMetadata.reexportAll.loc, statements.push(statement);
        }
        return statements;
      }, exports.ensureStatementsHoisted = function(statements) {
        statements.forEach((header => {
          header._blockHoist = 3;
        }));
      }, Object.defineProperty(exports, "getModuleName", {
        enumerable: !0,
        get: function() {
          return _getModuleName.default;
        }
      }), Object.defineProperty(exports, "hasExports", {
        enumerable: !0,
        get: function() {
          return _normalizeAndLoadMetadata.hasExports;
        }
      }), Object.defineProperty(exports, "isModule", {
        enumerable: !0,
        get: function() {
          return _helperModuleImports.isModule;
        }
      }), Object.defineProperty(exports, "isSideEffectImport", {
        enumerable: !0,
        get: function() {
          return _normalizeAndLoadMetadata.isSideEffectImport;
        }
      }), exports.rewriteModuleStatementsAndPrepareHeader = function(path, {loose, exportName, strict, allowTopLevelThis, strictMode, noInterop, importInterop = noInterop ? "none" : "babel", lazy, esNamespaceOnly, constantReexports = loose, enumerableModuleMeta = loose, noIncompleteNsImportDetection}) {
        (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop), _assert((0, 
        _helperModuleImports.isModule)(path), "Cannot process module statements in a script"), 
        path.node.sourceType = "script";
        const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
          importInterop,
          initializeReexports: constantReexports,
          lazy,
          esNamespaceOnly
        });
        allowTopLevelThis || (0, _rewriteThis.default)(path);
        if ((0, _rewriteLiveReferences.default)(path, meta), !1 !== strictMode) {
          const hasStrict = path.node.directives.some((directive => "use strict" === directive.value.value));
          hasStrict || path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
        }
        const headers = [];
        (0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict && headers.push(function(metadata, enumerableModuleMeta = !1) {
          return (enumerableModuleMeta ? _template.default.statement`
        EXPORTS.__esModule = true;
      ` : _template.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
            EXPORTS: metadata.exportName
          });
        }(meta, enumerableModuleMeta));
        const nameList = function(programPath, metadata) {
          const exportedVars = Object.create(null);
          for (const data of metadata.local.values()) for (const name of data.names) exportedVars[name] = !0;
          let hasReexport = !1;
          for (const data of metadata.source.values()) {
            for (const exportName of data.reexports.keys()) exportedVars[exportName] = !0;
            for (const exportName of data.reexportNamespace) exportedVars[exportName] = !0;
            hasReexport = hasReexport || !!data.reexportAll;
          }
          if (!hasReexport || 0 === Object.keys(exportedVars).length) return null;
          const name = programPath.scope.generateUidIdentifier("exportNames");
          return delete exportedVars.default, {
            name: name.name,
            statement: variableDeclaration("var", [ variableDeclarator(name, valueToNode(exportedVars)) ])
          };
        }(path, meta);
        nameList && (meta.exportNameListName = nameList.name, headers.push(nameList.statement));
        return headers.push(...function(programPath, metadata, constantReexports = !1, noIncompleteNsImportDetection = !1) {
          const initStatements = [];
          for (const [localName, data] of metadata.local) if ("import" === data.kind) ; else if ("hoisted" === data.kind) initStatements.push([ data.names[0], buildInitStatement(metadata, data.names, identifier(localName)) ]); else if (!noIncompleteNsImportDetection) for (const exportName of data.names) initStatements.push([ exportName, null ]);
          for (const data of metadata.source.values()) {
            if (!constantReexports) {
              const reexportsStatements = buildReexportsFromMeta(metadata, data, !1), reexports = [ ...data.reexports.keys() ];
              for (let i = 0; i < reexportsStatements.length; i++) initStatements.push([ reexports[i], reexportsStatements[i] ]);
            }
            if (!noIncompleteNsImportDetection) for (const exportName of data.reexportNamespace) initStatements.push([ exportName, null ]);
          }
          initStatements.sort((([a], [b]) => a < b ? -1 : b < a ? 1 : 0));
          const results = [];
          if (noIncompleteNsImportDetection) for (const [, initStatement] of initStatements) results.push(initStatement); else {
            const chunkSize = 100;
            for (let i = 0; i < initStatements.length; i += chunkSize) {
              let uninitializedExportNames = [];
              for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
                const [exportName, initStatement] = initStatements[i + j];
                null !== initStatement ? (uninitializedExportNames.length > 0 && (results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode())), 
                uninitializedExportNames = []), results.push(initStatement)) : uninitializedExportNames.push(exportName);
              }
              uninitializedExportNames.length > 0 && results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
            }
          }
          return results;
        }(path, meta, constantReexports, noIncompleteNsImportDetection)), {
          meta,
          headers
        };
      }, Object.defineProperty(exports, "rewriteThis", {
        enumerable: !0,
        get: function() {
          return _rewriteThis.default;
        }
      }), exports.wrapInterop = function(programPath, expr, type) {
        if ("none" === type) return null;
        if ("node-namespace" === type) return callExpression(programPath.hub.addHelper("interopRequireWildcard"), [ expr, booleanLiteral(!0) ]);
        if ("node-default" === type) return null;
        let helper;
        if ("default" === type) helper = "interopRequireDefault"; else {
          if ("namespace" !== type) throw new Error(`Unknown interop: ${type}`);
          helper = "interopRequireWildcard";
        }
        return callExpression(programPath.hub.addHelper(helper), [ expr ]);
      };
      var _assert = __webpack_require__(9491), _t = __webpack_require__(8218), _template = __webpack_require__(4847), _helperModuleImports = __webpack_require__(203), _rewriteThis = __webpack_require__(333), _rewriteLiveReferences = __webpack_require__(7500), _normalizeAndLoadMetadata = __webpack_require__(6368), _getModuleName = __webpack_require__(6294);
      const {booleanLiteral, callExpression, cloneNode, directive, directiveLiteral, expressionStatement, identifier, isIdentifier, memberExpression, stringLiteral, valueToNode, variableDeclaration, variableDeclarator} = _t;
      const ReexportTemplate = {
        constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,
        constantComputed: _template.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`,
        spec: _template.default.statement`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    `
      }, buildReexportsFromMeta = (meta, metadata, constantReexports) => {
        const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name), {stringSpecifiers} = meta;
        return Array.from(metadata.reexports, (([exportName, importName]) => {
          let NAMESPACE_IMPORT = cloneNode(namespace);
          "default" === importName && "node-default" === metadata.interop || (NAMESPACE_IMPORT = stringSpecifiers.has(importName) ? memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), !0) : memberExpression(NAMESPACE_IMPORT, identifier(importName)));
          const astNodes = {
            EXPORTS: meta.exportName,
            EXPORT_NAME: exportName,
            NAMESPACE_IMPORT
          };
          return constantReexports || isIdentifier(NAMESPACE_IMPORT) ? stringSpecifiers.has(exportName) ? ReexportTemplate.constantComputed(astNodes) : ReexportTemplate.constant(astNodes) : ReexportTemplate.spec(astNodes);
        }));
      };
      const InitTemplate = {
        computed: _template.default.expression`EXPORTS["NAME"] = VALUE`,
        default: _template.default.expression`EXPORTS.NAME = VALUE`
      };
      function buildInitStatement(metadata, exportNames, initExpr) {
        const {stringSpecifiers, exportName: EXPORTS} = metadata;
        return expressionStatement(exportNames.reduce(((acc, exportName) => {
          const params = {
            EXPORTS,
            NAME: exportName,
            VALUE: acc
          };
          return stringSpecifiers.has(exportName) ? InitTemplate.computed(params) : InitTemplate.default(params);
        }), initExpr));
      }
    },
    6368: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(programPath, exportName, {importInterop, initializeReexports = !1, lazy = !1, esNamespaceOnly = !1}) {
        exportName || (exportName = programPath.scope.generateUidIdentifier("exports").name);
        const stringSpecifiers = new Set;
        !function(programPath) {
          programPath.get("body").forEach((child => {
            child.isExportDefaultDeclaration() && (0, _helperSplitExportDeclaration.default)(child);
          }));
        }(programPath);
        const {local, source, hasExports} = function(programPath, {lazy, initializeReexports}, stringSpecifiers) {
          const localData = function(programPath, initializeReexports, stringSpecifiers) {
            const bindingKindLookup = new Map;
            programPath.get("body").forEach((child => {
              let kind;
              if (child.isImportDeclaration()) kind = "import"; else {
                if (child.isExportDefaultDeclaration() && (child = child.get("declaration")), child.isExportNamedDeclaration()) if (child.node.declaration) child = child.get("declaration"); else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) return void child.get("specifiers").forEach((spec => {
                  assertExportSpecifier(spec), bindingKindLookup.set(spec.get("local").node.name, "block");
                }));
                if (child.isFunctionDeclaration()) kind = "hoisted"; else if (child.isClassDeclaration()) kind = "block"; else if (child.isVariableDeclaration({
                  kind: "var"
                })) kind = "var"; else {
                  if (!child.isVariableDeclaration()) return;
                  kind = "block";
                }
              }
              Object.keys(child.getOuterBindingIdentifiers()).forEach((name => {
                bindingKindLookup.set(name, kind);
              }));
            }));
            const localMetadata = new Map, getLocalMetadata = idPath => {
              const localName = idPath.node.name;
              let metadata = localMetadata.get(localName);
              if (!metadata) {
                const kind = bindingKindLookup.get(localName);
                if (void 0 === kind) throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
                metadata = {
                  names: [],
                  kind
                }, localMetadata.set(localName, metadata);
              }
              return metadata;
            };
            return programPath.get("body").forEach((child => {
              if (!child.isExportNamedDeclaration() || !initializeReexports && child.node.source) {
                if (child.isExportDefaultDeclaration()) {
                  const declaration = child.get("declaration");
                  if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration()) throw declaration.buildCodeFrameError("Unexpected default expression export.");
                  getLocalMetadata(declaration.get("id")).names.push("default");
                }
              } else if (child.node.declaration) {
                const declaration = child.get("declaration"), ids = declaration.getOuterBindingIdentifierPaths();
                Object.keys(ids).forEach((name => {
                  if ("__esModule" === name) throw declaration.buildCodeFrameError('Illegal export "__esModule".');
                  getLocalMetadata(ids[name]).names.push(name);
                }));
              } else child.get("specifiers").forEach((spec => {
                const local = spec.get("local"), exported = spec.get("exported"), localMetadata = getLocalMetadata(local), exportName = getExportSpecifierName(exported, stringSpecifiers);
                if ("__esModule" === exportName) throw exported.buildCodeFrameError('Illegal export "__esModule".');
                localMetadata.names.push(exportName);
              }));
            })), localMetadata;
          }(programPath, initializeReexports, stringSpecifiers), sourceData = new Map, getData = sourceNode => {
            const source = sourceNode.value;
            let data = sourceData.get(source);
            return data || (data = {
              name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
              interop: "none",
              loc: null,
              imports: new Map,
              importsNamespace: new Set,
              reexports: new Map,
              reexportNamespace: new Set,
              reexportAll: null,
              lazy: !1,
              source
            }, sourceData.set(source, data)), data;
          };
          let hasExports = !1;
          programPath.get("body").forEach((child => {
            if (child.isImportDeclaration()) {
              const data = getData(child.node.source);
              data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach((spec => {
                if (spec.isImportDefaultSpecifier()) {
                  const localName = spec.get("local").node.name;
                  data.imports.set(localName, "default");
                  const reexport = localData.get(localName);
                  reexport && (localData.delete(localName), reexport.names.forEach((name => {
                    data.reexports.set(name, "default");
                  })));
                } else if (spec.isImportNamespaceSpecifier()) {
                  const localName = spec.get("local").node.name;
                  data.importsNamespace.add(localName);
                  const reexport = localData.get(localName);
                  reexport && (localData.delete(localName), reexport.names.forEach((name => {
                    data.reexportNamespace.add(name);
                  })));
                } else if (spec.isImportSpecifier()) {
                  const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers), localName = spec.get("local").node.name;
                  data.imports.set(localName, importName);
                  const reexport = localData.get(localName);
                  reexport && (localData.delete(localName), reexport.names.forEach((name => {
                    data.reexports.set(name, importName);
                  })));
                }
              }));
            } else if (child.isExportAllDeclaration()) {
              hasExports = !0;
              const data = getData(child.node.source);
              data.loc || (data.loc = child.node.loc), data.reexportAll = {
                loc: child.node.loc
              };
            } else if (child.isExportNamedDeclaration() && child.node.source) {
              hasExports = !0;
              const data = getData(child.node.source);
              data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach((spec => {
                assertExportSpecifier(spec);
                const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers), exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
                if (data.reexports.set(exportName, importName), "__esModule" === exportName) throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
              }));
            } else (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) && (hasExports = !0);
          }));
          for (const metadata of sourceData.values()) {
            let needsDefault = !1, needsNamed = !1;
            metadata.importsNamespace.size > 0 && (needsDefault = !0, needsNamed = !0), metadata.reexportAll && (needsNamed = !0);
            for (const importName of metadata.imports.values()) "default" === importName ? needsDefault = !0 : needsNamed = !0;
            for (const importName of metadata.reexports.values()) "default" === importName ? needsDefault = !0 : needsNamed = !0;
            needsDefault && needsNamed ? metadata.interop = "namespace" : needsDefault && (metadata.interop = "default");
          }
          for (const [source, metadata] of sourceData) if (!1 !== lazy && !isSideEffectImport(metadata) && !metadata.reexportAll) if (!0 === lazy) metadata.lazy = !/\./.test(source); else if (Array.isArray(lazy)) metadata.lazy = -1 !== lazy.indexOf(source); else {
            if ("function" != typeof lazy) throw new Error(".lazy must be a boolean, string array, or function");
            metadata.lazy = lazy(source);
          }
          return {
            hasExports,
            local: localData,
            source: sourceData
          };
        }(programPath, {
          initializeReexports,
          lazy
        }, stringSpecifiers);
        !function(programPath) {
          programPath.get("body").forEach((child => {
            if (child.isImportDeclaration()) child.remove(); else if (child.isExportNamedDeclaration()) child.node.declaration ? (child.node.declaration._blockHoist = child.node._blockHoist, 
            child.replaceWith(child.node.declaration)) : child.remove(); else if (child.isExportDefaultDeclaration()) {
              const declaration = child.get("declaration");
              if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration()) throw declaration.buildCodeFrameError("Unexpected default expression export.");
              declaration._blockHoist = child.node._blockHoist, child.replaceWith(declaration);
            } else child.isExportAllDeclaration() && child.remove();
          }));
        }(programPath);
        for (const [, metadata] of source) {
          metadata.importsNamespace.size > 0 && (metadata.name = metadata.importsNamespace.values().next().value);
          const resolvedInterop = resolveImportInterop(importInterop, metadata.source);
          "none" === resolvedInterop ? metadata.interop = "none" : "node" === resolvedInterop && "namespace" === metadata.interop ? metadata.interop = "node-namespace" : "node" === resolvedInterop && "default" === metadata.interop ? metadata.interop = "node-default" : esNamespaceOnly && "namespace" === metadata.interop && (metadata.interop = "default");
        }
        return {
          exportName,
          exportNameListName: null,
          hasExports,
          local,
          source,
          stringSpecifiers
        };
      }, exports.hasExports = function(metadata) {
        return metadata.hasExports;
      }, exports.isSideEffectImport = isSideEffectImport, exports.validateImportInteropOption = validateImportInteropOption;
      var _path = __webpack_require__(1017), _helperValidatorIdentifier = __webpack_require__(720), _helperSplitExportDeclaration = __webpack_require__(4170);
      function isSideEffectImport(source) {
        return 0 === source.imports.size && 0 === source.importsNamespace.size && 0 === source.reexports.size && 0 === source.reexportNamespace.size && !source.reexportAll;
      }
      function validateImportInteropOption(importInterop) {
        if ("function" != typeof importInterop && "none" !== importInterop && "babel" !== importInterop && "node" !== importInterop) throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
        return importInterop;
      }
      function resolveImportInterop(importInterop, source) {
        return "function" == typeof importInterop ? validateImportInteropOption(importInterop(source)) : importInterop;
      }
      function getExportSpecifierName(path, stringSpecifiers) {
        if (path.isIdentifier()) return path.node.name;
        if (path.isStringLiteral()) {
          const stringValue = path.node.value;
          return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue) || stringSpecifiers.add(stringValue), 
          stringValue;
        }
        throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);
      }
      function assertExportSpecifier(path) {
        if (!path.isExportSpecifier()) throw path.isExportNamespaceSpecifier() ? path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.") : path.buildCodeFrameError("Unexpected export specifier type");
      }
    },
    7500: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(programPath, metadata) {
        const imported = new Map, exported = new Map, requeueInParent = path => {
          programPath.requeue(path);
        };
        for (const [source, data] of metadata.source) {
          for (const [localName, importName] of data.imports) imported.set(localName, [ source, importName, null ]);
          for (const localName of data.importsNamespace) imported.set(localName, [ source, null, localName ]);
        }
        for (const [local, data] of metadata.local) {
          let exportMeta = exported.get(local);
          exportMeta || (exportMeta = [], exported.set(local, exportMeta)), exportMeta.push(...data.names);
        }
        const rewriteBindingInitVisitorState = {
          metadata,
          requeueInParent,
          scope: programPath.scope,
          exported
        };
        programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState), 
        (0, _helperSimpleAccess.default)(programPath, new Set([ ...Array.from(imported.keys()), ...Array.from(exported.keys()) ]), !1);
        const rewriteReferencesVisitorState = {
          seen: new WeakSet,
          metadata,
          requeueInParent,
          scope: programPath.scope,
          imported,
          exported,
          buildImportReference: ([source, importName, localName], identNode) => {
            const meta = metadata.source.get(source);
            if (localName) return meta.lazy && (identNode = callExpression(identNode, [])), 
            identNode;
            let namespace = identifier(meta.name);
            if (meta.lazy && (namespace = callExpression(namespace, [])), "default" === importName && "node-default" === meta.interop) return namespace;
            const computed = metadata.stringSpecifiers.has(importName);
            return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);
          }
        };
        programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
      };
      var _assert = __webpack_require__(9491), _t = __webpack_require__(8218), _template = __webpack_require__(4847), _helperSimpleAccess = __webpack_require__(9196);
      const {assignmentExpression, callExpression, cloneNode, expressionStatement, getOuterBindingIdentifiers, identifier, isMemberExpression, isVariableDeclaration, jsxIdentifier, jsxMemberExpression, memberExpression, numericLiteral, sequenceExpression, stringLiteral, variableDeclaration, variableDeclarator} = _t;
      const rewriteBindingInitVisitor = {
        Scope(path) {
          path.skip();
        },
        ClassDeclaration(path) {
          const {requeueInParent, exported, metadata} = this, {id} = path.node;
          if (!id) throw new Error("Expected class to have a name");
          const localName = id.name, exportNames = exported.get(localName) || [];
          if (exportNames.length > 0) {
            const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
            statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
          }
        },
        VariableDeclaration(path) {
          const {requeueInParent, exported, metadata} = this;
          Object.keys(path.getOuterBindingIdentifiers()).forEach((localName => {
            const exportNames = exported.get(localName) || [];
            if (exportNames.length > 0) {
              const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
              statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
            }
          }));
        }
      }, buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => (exportNames || []).reduce(((expr, exportName) => {
        const {stringSpecifiers} = metadata, computed = stringSpecifiers.has(exportName);
        return assignmentExpression("=", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
      }), localExpr), buildImportThrow = localName => _template.default.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `, rewriteReferencesVisitor = {
        ReferencedIdentifier(path) {
          const {seen, buildImportReference, scope, imported, requeueInParent} = this;
          if (seen.has(path.node)) return;
          seen.add(path.node);
          const localName = path.node.name, importData = imported.get(localName);
          if (importData) {
            if (function(path) {
              do {
                switch (path.parent.type) {
                 case "TSTypeAnnotation":
                 case "TSTypeAliasDeclaration":
                 case "TSTypeReference":
                 case "TypeAnnotation":
                 case "TypeAlias":
                  return !0;

                 case "ExportSpecifier":
                  return "type" === path.parentPath.parent.exportKind;

                 default:
                  if (path.parentPath.isStatement() || path.parentPath.isExpression()) return !1;
                }
              } while (path = path.parentPath);
            }(path)) throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const localBinding = path.scope.getBinding(localName);
            if (scope.getBinding(localName) !== localBinding) return;
            const ref = buildImportReference(importData, path.node);
            if (ref.loc = path.node.loc, (path.parentPath.isCallExpression({
              callee: path.node
            }) || path.parentPath.isOptionalCallExpression({
              callee: path.node
            }) || path.parentPath.isTaggedTemplateExpression({
              tag: path.node
            })) && isMemberExpression(ref)) path.replaceWith(sequenceExpression([ numericLiteral(0), ref ])); else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
              const {object, property} = ref;
              path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
            } else path.replaceWith(ref);
            requeueInParent(path), path.skip();
          }
        },
        UpdateExpression(path) {
          const {scope, seen, imported, exported, requeueInParent, buildImportReference} = this;
          if (seen.has(path.node)) return;
          seen.add(path.node);
          const arg = path.get("argument");
          if (arg.isMemberExpression()) return;
          const update = path.node;
          if (arg.isIdentifier()) {
            const localName = arg.node.name;
            if (scope.getBinding(localName) !== path.scope.getBinding(localName)) return;
            const exportedNames = exported.get(localName), importData = imported.get(localName);
            if ((null == exportedNames ? void 0 : exportedNames.length) > 0 || importData) if (importData) path.replaceWith(assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName))); else if (update.prefix) path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update))); else {
              const ref = scope.generateDeclaredUidIdentifier(localName);
              path.replaceWith(sequenceExpression([ assignmentExpression("=", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)), cloneNode(ref) ]));
            }
          }
          requeueInParent(path), path.skip();
        },
        AssignmentExpression: {
          exit(path) {
            const {scope, seen, imported, exported, requeueInParent, buildImportReference} = this;
            if (seen.has(path.node)) return;
            seen.add(path.node);
            const left = path.get("left");
            if (!left.isMemberExpression()) if (left.isIdentifier()) {
              const localName = left.node.name;
              if (scope.getBinding(localName) !== path.scope.getBinding(localName)) return;
              const exportedNames = exported.get(localName), importData = imported.get(localName);
              if ((null == exportedNames ? void 0 : exportedNames.length) > 0 || importData) {
                _assert("=" === path.node.operator, "Path was not simplified");
                const assignment = path.node;
                importData && (assignment.left = buildImportReference(importData, assignment.left), 
                assignment.right = sequenceExpression([ assignment.right, buildImportThrow(localName) ])), 
                path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment)), 
                requeueInParent(path);
              }
            } else {
              const ids = left.getOuterBindingIdentifiers(), programScopeIds = Object.keys(ids).filter((localName => scope.getBinding(localName) === path.scope.getBinding(localName))), id = programScopeIds.find((localName => imported.has(localName)));
              id && (path.node.right = sequenceExpression([ path.node.right, buildImportThrow(id) ]));
              const items = [];
              if (programScopeIds.forEach((localName => {
                const exportedNames = exported.get(localName) || [];
                exportedNames.length > 0 && items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)));
              })), items.length > 0) {
                let node = sequenceExpression(items);
                path.parentPath.isExpressionStatement() && (node = expressionStatement(node), node._blockHoist = path.parentPath.node._blockHoist);
                requeueInParent(path.insertAfter(node)[0]);
              }
            }
          }
        },
        "ForOfStatement|ForInStatement"(path) {
          const {scope, node} = path, {left} = node, {exported, imported, scope: programScope} = this;
          if (!isVariableDeclaration(left)) {
            let importConstViolationName, didTransformExport = !1;
            const loopBodyScope = path.get("body").scope;
            for (const name of Object.keys(getOuterBindingIdentifiers(left))) programScope.getBinding(name) === scope.getBinding(name) && (exported.has(name) && (didTransformExport = !0, 
            loopBodyScope.hasOwnBinding(name) && loopBodyScope.rename(name)), imported.has(name) && !importConstViolationName && (importConstViolationName = name));
            if (!didTransformExport && !importConstViolationName) return;
            path.ensureBlock();
            const bodyPath = path.get("body"), newLoopId = scope.generateUidIdentifierBasedOnNode(left);
            path.get("left").replaceWith(variableDeclaration("let", [ variableDeclarator(cloneNode(newLoopId)) ])), 
            scope.registerDeclaration(path.get("left")), didTransformExport && bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left, newLoopId))), 
            importConstViolationName && bodyPath.unshiftContainer("body", expressionStatement(buildImportThrow(importConstViolationName)));
          }
        }
      };
    },
    333: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(programPath) {
        (0, _traverse.default)(programPath.node, Object.assign({}, rewriteThisVisitor, {
          noScope: !0
        }));
      };
      var _helperEnvironmentVisitor = __webpack_require__(1692), _traverse = __webpack_require__(9838), _t = __webpack_require__(8218);
      const {numericLiteral, unaryExpression} = _t;
      const rewriteThisVisitor = _traverse.default.visitors.merge([ _helperEnvironmentVisitor.default, {
        ThisExpression(path) {
          path.replaceWith(unaryExpression("void", numericLiteral(0), !0));
        }
      } ]);
    },
    3934: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(callee, thisNode, args, optional) {
        return 1 === args.length && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
          name: "arguments"
        }) ? optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), !1, !0), [ thisNode, args[0].argument ], !1) : callExpression(memberExpression(callee, identifier("apply")), [ thisNode, args[0].argument ]) : optional ? optionalCallExpression(optionalMemberExpression(callee, identifier("call"), !1, !0), [ thisNode, ...args ], !1) : callExpression(memberExpression(callee, identifier("call")), [ thisNode, ...args ]);
      };
      var _t = __webpack_require__(8218);
      const {callExpression, identifier, isIdentifier, isSpreadElement, memberExpression, optionalCallExpression, optionalMemberExpression} = _t;
    },
    4982: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.declare = function(builder) {
        return (api, options, dirname) => {
          var _clonedApi2;
          let clonedApi;
          for (const name of Object.keys(apiPolyfills)) {
            var _clonedApi;
            api[name] || (clonedApi = null != (_clonedApi = clonedApi) ? _clonedApi : copyApiObject(api), 
            clonedApi[name] = apiPolyfills[name](clonedApi));
          }
          return builder(null != (_clonedApi2 = clonedApi) ? _clonedApi2 : api, options || {}, dirname);
        };
      };
      const apiPolyfills = {
        assertVersion: api => range => {
          !function(range, version) {
            if ("number" == typeof range) {
              if (!Number.isInteger(range)) throw new Error("Expected string or integer value.");
              range = `^${range}.0.0-0`;
            }
            if ("string" != typeof range) throw new Error("Expected string or integer value.");
            const limit = Error.stackTraceLimit;
            "number" == typeof limit && limit < 25 && (Error.stackTraceLimit = 25);
            let err;
            err = "7." === version.slice(0, 2) ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
            "number" == typeof limit && (Error.stackTraceLimit = limit);
            throw Object.assign(err, {
              code: "BABEL_VERSION_UNSUPPORTED",
              version,
              range
            });
          }(range, api.version);
        },
        targets: () => () => ({}),
        assumption: () => () => {}
      };
      function copyApiObject(api) {
        let proto = null;
        return "string" == typeof api.version && /^7\./.test(api.version) && (proto = Object.getPrototypeOf(api), 
        !proto || has(proto, "version") && has(proto, "transform") && has(proto, "template") && has(proto, "types") || (proto = null)), 
        Object.assign({}, proto, api);
      }
      function has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
    },
    5108: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, helpers, noNewArrows, ignoreFunctionLength) {
        path.traverse(awaitVisitor, {
          wrapAwait: helpers.wrapAwait
        });
        const isIIFE = function(path) {
          if (path.parentPath.isCallExpression({
            callee: path.node
          })) return !0;
          const {parentPath} = path;
          if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {
            name: "bind"
          })) {
            const {parentPath: bindCall} = parentPath;
            return bindCall.isCallExpression() && 1 === bindCall.node.arguments.length && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
              callee: bindCall.node
            });
          }
          return !1;
        }(path);
        path.node.async = !1, path.node.generator = !0, (0, _helperWrapFunction.default)(path, cloneNode(helpers.wrapAsync), noNewArrows, ignoreFunctionLength);
        path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty() || isIIFE || !path.isExpression() || (0, 
        _helperAnnotateAsPure.default)(path);
      };
      var _helperWrapFunction = __webpack_require__(8771), _helperAnnotateAsPure = __webpack_require__(4321), _t = __webpack_require__(8218);
      const {callExpression, cloneNode, isIdentifier, isThisExpression, yieldExpression} = _t, awaitVisitor = {
        Function(path) {
          path.skip();
        },
        AwaitExpression(path, {wrapAwait}) {
          const argument = path.get("argument");
          path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [ argument.node ]) : argument.node));
        }
      };
    },
    4149: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0, Object.defineProperty(exports, "environmentVisitor", {
        enumerable: !0,
        get: function() {
          return _helperEnvironmentVisitor.default;
        }
      }), Object.defineProperty(exports, "skipAllButComputedKey", {
        enumerable: !0,
        get: function() {
          return _helperEnvironmentVisitor.skipAllButComputedKey;
        }
      });
      var _traverse = __webpack_require__(9838), _helperMemberExpressionToFunctions = __webpack_require__(9693), _helperOptimiseCallExpression = __webpack_require__(3934), _helperEnvironmentVisitor = __webpack_require__(1692), _t = __webpack_require__(8218);
      const {assignmentExpression, booleanLiteral, callExpression, cloneNode, identifier, memberExpression, sequenceExpression, stringLiteral, thisExpression} = _t;
      function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
        objectRef = cloneNode(objectRef);
        const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
        return callExpression(file.addHelper("getPrototypeOf"), [ targetRef ]);
      }
      const visitor = _traverse.default.visitors.merge([ _helperEnvironmentVisitor.default, {
        Super(path, state) {
          const {node, parentPath} = path;
          parentPath.isMemberExpression({
            object: node
          }) && state.handle(parentPath);
        }
      } ]), unshadowSuperBindingVisitor = _traverse.default.visitors.merge([ _helperEnvironmentVisitor.default, {
        Scopable(path, {refName}) {
          const binding = path.scope.getOwnBinding(refName);
          binding && binding.identifier.name === refName && path.scope.rename(refName);
        }
      } ]), specHandlers = {
        memoise(superMember, count) {
          const {scope, node} = superMember, {computed, property} = node;
          if (!computed) return;
          const memo = scope.maybeGenerateMemoised(property);
          memo && this.memoiser.set(property, memo, count);
        },
        prop(superMember) {
          const {computed, property} = superMember.node;
          return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : computed ? cloneNode(property) : stringLiteral(property.name);
        },
        get(superMember) {
          return this._get(superMember, this._getThisRefs());
        },
        _get(superMember, thisRefs) {
          const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return callExpression(this.file.addHelper("get"), [ thisRefs.memo ? sequenceExpression([ thisRefs.memo, proto ]) : proto, this.prop(superMember), thisRefs.this ]);
        },
        _getThisRefs() {
          if (!this.isDerivedConstructor) return {
            this: thisExpression()
          };
          const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
          return {
            memo: assignmentExpression("=", thisRef, thisExpression()),
            this: cloneNode(thisRef)
          };
        },
        set(superMember, value) {
          const thisRefs = this._getThisRefs(), proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
          return callExpression(this.file.addHelper("set"), [ thisRefs.memo ? sequenceExpression([ thisRefs.memo, proto ]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.isInStrictMode()) ]);
        },
        destructureSet(superMember) {
          throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        },
        call(superMember, args) {
          const thisRefs = this._getThisRefs();
          return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, !1);
        },
        optionalCall(superMember, args) {
          const thisRefs = this._getThisRefs();
          return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, !0);
        }
      }, looseHandlers = Object.assign({}, specHandlers, {
        prop(superMember) {
          const {property} = superMember.node;
          return this.memoiser.has(property) ? cloneNode(this.memoiser.get(property)) : cloneNode(property);
        },
        get(superMember) {
          const {isStatic, getSuperRef} = this, {computed} = superMember.node, prop = this.prop(superMember);
          let object;
          var _getSuperRef, _getSuperRef2;
          isStatic ? object = null != (_getSuperRef = getSuperRef()) ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype")) : object = memberExpression(null != (_getSuperRef2 = getSuperRef()) ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
          return memberExpression(object, prop, computed);
        },
        set(superMember, value) {
          const {computed} = superMember.node, prop = this.prop(superMember);
          return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
        },
        destructureSet(superMember) {
          const {computed} = superMember.node, prop = this.prop(superMember);
          return memberExpression(thisExpression(), prop, computed);
        },
        call(superMember, args) {
          return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, !1);
        },
        optionalCall(superMember, args) {
          return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, !0);
        }
      });
      exports.default = class {
        constructor(opts) {
          var _opts$constantSuper;
          const path = opts.methodPath;
          this.methodPath = path, this.isDerivedConstructor = path.isClassMethod({
            kind: "constructor"
          }) && !!opts.superRef, this.isStatic = path.isObjectMethod() || path.node.static || (null == path.isStaticBlock ? void 0 : path.isStaticBlock()), 
          this.isPrivateMethod = path.isPrivate() && path.isMethod(), this.file = opts.file, 
          this.constantSuper = null != (_opts$constantSuper = opts.constantSuper) ? _opts$constantSuper : opts.isLoose, 
          this.opts = opts;
        }
        getObjectRef() {
          return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
        }
        getSuperRef() {
          return this.opts.superRef ? cloneNode(this.opts.superRef) : this.opts.getSuperRef ? cloneNode(this.opts.getSuperRef()) : void 0;
        }
        replace() {
          this.opts.refToPreserve && this.methodPath.traverse(unshadowSuperBindingVisitor, {
            refName: this.opts.refToPreserve.name
          });
          const handler = this.constantSuper ? looseHandlers : specHandlers;
          (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({
            file: this.file,
            scope: this.methodPath.scope,
            isDerivedConstructor: this.isDerivedConstructor,
            isStatic: this.isStatic,
            isPrivateMethod: this.isPrivateMethod,
            getObjectRef: this.getObjectRef.bind(this),
            getSuperRef: this.getSuperRef.bind(this),
            boundGet: handler.get
          }, handler));
        }
      };
    },
    9196: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, bindingNames, includeUpdateExpression = !0) {
        path.traverse(simpleAssignmentVisitor, {
          scope: path.scope,
          bindingNames,
          seen: new WeakSet,
          includeUpdateExpression
        });
      };
      var _t = __webpack_require__(8218);
      const {LOGICAL_OPERATORS, assignmentExpression, binaryExpression, cloneNode, identifier, logicalExpression, numericLiteral, sequenceExpression, unaryExpression} = _t;
      const simpleAssignmentVisitor = {
        UpdateExpression: {
          exit(path) {
            const {scope, bindingNames, includeUpdateExpression} = this;
            if (!includeUpdateExpression) return;
            const arg = path.get("argument");
            if (!arg.isIdentifier()) return;
            const localName = arg.node.name;
            if (bindingNames.has(localName) && scope.getBinding(localName) === path.scope.getBinding(localName)) if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
              const operator = "++" == path.node.operator ? "+=" : "-=";
              path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
            } else if (path.node.prefix) path.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1)))); else {
              const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old"), varName = old.name;
              path.scope.push({
                id: old
              });
              const binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));
              path.replaceWith(sequenceExpression([ assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName) ]));
            }
          }
        },
        AssignmentExpression: {
          exit(path) {
            const {scope, seen, bindingNames} = this;
            if ("=" === path.node.operator) return;
            if (seen.has(path.node)) return;
            seen.add(path.node);
            const left = path.get("left");
            if (!left.isIdentifier()) return;
            const localName = left.node.name;
            if (!bindingNames.has(localName)) return;
            if (scope.getBinding(localName) !== path.scope.getBinding(localName)) return;
            const operator = path.node.operator.slice(0, -1);
            LOGICAL_OPERATORS.includes(operator) ? path.replaceWith(logicalExpression(operator, path.node.left, assignmentExpression("=", cloneNode(path.node.left), path.node.right))) : (path.node.right = binaryExpression(operator, cloneNode(path.node.left), path.node.right), 
            path.node.operator = "=");
          }
        }
      };
    },
    4539: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.isTransparentExprWrapper = isTransparentExprWrapper, exports.skipTransparentExprWrapperNodes = function(node) {
        for (;isTransparentExprWrapper(node); ) node = node.expression;
        return node;
      }, exports.skipTransparentExprWrappers = function(path) {
        for (;isTransparentExprWrapper(path.node); ) path = path.get("expression");
        return path;
      };
      var _t = __webpack_require__(8218);
      const {isParenthesizedExpression, isTSAsExpression, isTSNonNullExpression, isTSTypeAssertion, isTypeCastExpression} = _t;
      function isTransparentExprWrapper(node) {
        return isTSAsExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
      }
    },
    4170: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(exportDeclaration) {
        if (!exportDeclaration.isExportDeclaration()) throw new Error("Only export declarations can be split.");
        const isDefault = exportDeclaration.isExportDefaultDeclaration(), declaration = exportDeclaration.get("declaration"), isClassDeclaration = declaration.isClassDeclaration();
        if (isDefault) {
          const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration, scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
          let id = declaration.node.id, needBindingRegistration = !1;
          id || (needBindingRegistration = !0, id = scope.generateUidIdentifier("default"), 
          (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) && (declaration.node.id = cloneNode(id)));
          const updatedDeclaration = standaloneDeclaration ? declaration : variableDeclaration("var", [ variableDeclarator(cloneNode(id), declaration.node) ]), updatedExportDeclaration = exportNamedDeclaration(null, [ exportSpecifier(cloneNode(id), identifier("default")) ]);
          return exportDeclaration.insertAfter(updatedExportDeclaration), exportDeclaration.replaceWith(updatedDeclaration), 
          needBindingRegistration && scope.registerDeclaration(exportDeclaration), exportDeclaration;
        }
        if (exportDeclaration.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
        const bindingIdentifiers = declaration.getOuterBindingIdentifiers(), specifiers = Object.keys(bindingIdentifiers).map((name => exportSpecifier(identifier(name), identifier(name)))), aliasDeclar = exportNamedDeclaration(null, specifiers);
        return exportDeclaration.insertAfter(aliasDeclar), exportDeclaration.replaceWith(declaration.node), 
        exportDeclaration;
      };
      var _t = __webpack_require__(8218);
      const {cloneNode, exportNamedDeclaration, exportSpecifier, identifier, variableDeclaration, variableDeclarator} = _t;
    },
    3306: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.isIdentifierChar = isIdentifierChar, exports.isIdentifierName = function(name) {
        let isFirst = !0;
        for (let i = 0; i < name.length; i++) {
          let cp = name.charCodeAt(i);
          if (55296 == (64512 & cp) && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            56320 == (64512 & trail) && (cp = 65536 + ((1023 & cp) << 10) + (1023 & trail));
          }
          if (isFirst) {
            if (isFirst = !1, !isIdentifierStart(cp)) return !1;
          } else if (!isIdentifierChar(cp)) return !1;
        }
        return !isFirst;
      }, exports.isIdentifierStart = isIdentifierStart;
      let nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
      const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      const astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938 ], astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239 ];
      function isInAstralSet(code, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          if (pos += set[i], pos > code) return !1;
          if (pos += set[i + 1], pos >= code) return !0;
        }
        return !1;
      }
      function isIdentifierStart(code) {
        return code < 65 ? 36 === code : code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes)));
      }
      function isIdentifierChar(code) {
        return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes))));
      }
    },
    720: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "isIdentifierChar", {
        enumerable: !0,
        get: function() {
          return _identifier.isIdentifierChar;
        }
      }), Object.defineProperty(exports, "isIdentifierName", {
        enumerable: !0,
        get: function() {
          return _identifier.isIdentifierName;
        }
      }), Object.defineProperty(exports, "isIdentifierStart", {
        enumerable: !0,
        get: function() {
          return _identifier.isIdentifierStart;
        }
      }), Object.defineProperty(exports, "isKeyword", {
        enumerable: !0,
        get: function() {
          return _keyword.isKeyword;
        }
      }), Object.defineProperty(exports, "isReservedWord", {
        enumerable: !0,
        get: function() {
          return _keyword.isReservedWord;
        }
      }), Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
        enumerable: !0,
        get: function() {
          return _keyword.isStrictBindOnlyReservedWord;
        }
      }), Object.defineProperty(exports, "isStrictBindReservedWord", {
        enumerable: !0,
        get: function() {
          return _keyword.isStrictBindReservedWord;
        }
      }), Object.defineProperty(exports, "isStrictReservedWord", {
        enumerable: !0,
        get: function() {
          return _keyword.isStrictReservedWord;
        }
      });
      var _identifier = __webpack_require__(3306), _keyword = __webpack_require__(2887);
    },
    2887: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.isKeyword = function(word) {
        return keywords.has(word);
      }, exports.isReservedWord = isReservedWord, exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord, 
      exports.isStrictBindReservedWord = function(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }, exports.isStrictReservedWord = isStrictReservedWord;
      const reservedWords_strict = [ "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield" ], reservedWords_strictBind = [ "eval", "arguments" ], keywords = new Set([ "break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete" ]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
      function isReservedWord(word, inModule) {
        return inModule && "await" === word || "enum" === word;
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
    },
    4401: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.findSuggestion = function(str, arr) {
        const distances = arr.map((el => function(a, b) {
          let i, j, t = [], u = [];
          const m = a.length, n = b.length;
          if (!m) return n;
          if (!n) return m;
          for (j = 0; j <= n; j++) t[j] = j;
          for (i = 1; i <= m; i++) {
            for (u = [ i ], j = 1; j <= n; j++) u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
            t = u;
          }
          return u[n];
        }(el, str)));
        return arr[distances.indexOf(min(...distances))];
      };
      const {min} = Math;
    },
    4346: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "OptionValidator", {
        enumerable: !0,
        get: function() {
          return _validator.OptionValidator;
        }
      }), Object.defineProperty(exports, "findSuggestion", {
        enumerable: !0,
        get: function() {
          return _findSuggestion.findSuggestion;
        }
      });
      var _validator = __webpack_require__(6834), _findSuggestion = __webpack_require__(4401);
    },
    6834: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.OptionValidator = void 0;
      var _findSuggestion = __webpack_require__(4401);
      exports.OptionValidator = class {
        constructor(descriptor) {
          this.descriptor = descriptor;
        }
        validateTopLevelOptions(options, TopLevelOptionShape) {
          const validOptionNames = Object.keys(TopLevelOptionShape);
          for (const option of Object.keys(options)) if (!validOptionNames.includes(option)) throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.\n- Did you mean '${(0, 
          _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
        }
        validateBooleanOption(name, value, defaultValue) {
          return void 0 === value ? defaultValue : (this.invariant("boolean" == typeof value, `'${name}' option must be a boolean.`), 
          value);
        }
        validateStringOption(name, value, defaultValue) {
          return void 0 === value ? defaultValue : (this.invariant("string" == typeof value, `'${name}' option must be a string.`), 
          value);
        }
        invariant(condition, message) {
          if (!condition) throw new Error(this.formatMessage(message));
        }
        formatMessage(message) {
          return `${this.descriptor}: ${message}`;
        }
      };
    },
    8771: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, callId, noNewArrows = !0, ignoreFunctionLength = !1) {
        path.isMethod() ? function(path, callId) {
          const node = path.node, body = node.body, container = functionExpression(null, [], blockStatement(body.body), !0);
          body.body = [ returnStatement(callExpression(callExpression(callId, [ container ]), [])) ], 
          node.async = !1, node.generator = !1, path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
        }(path, callId) : function(path, callId, noNewArrows, ignoreFunctionLength) {
          const node = path.node, isDeclaration = path.isFunctionDeclaration(), functionId = node.id, wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;
          path.isArrowFunctionExpression() && path.arrowFunctionToExpression({
            noNewArrows
          });
          node.id = null, isDeclaration && (node.type = "FunctionExpression");
          const built = callExpression(callId, [ node ]), params = [];
          for (const param of node.params) {
            if (isAssignmentPattern(param) || isRestElement(param)) break;
            params.push(path.scope.generateUidIdentifier("x"));
          }
          const container = wrapper({
            NAME: functionId || null,
            REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
            FUNCTION: built,
            PARAMS: params
          });
          if (isDeclaration) path.replaceWith(container[0]), path.insertAfter(container[1]); else {
            const retFunction = container.callee.body.body[1].argument;
            functionId || (0, _helperFunctionName.default)({
              node: retFunction,
              parent: path.parent,
              scope: path.scope
            }), !retFunction || retFunction.id || !ignoreFunctionLength && params.length ? path.replaceWith(container) : path.replaceWith(built);
          }
        }(path, callId, noNewArrows, ignoreFunctionLength);
      };
      var _helperFunctionName = __webpack_require__(1485), _template = __webpack_require__(4847), _t = __webpack_require__(8218);
      const {blockStatement, callExpression, functionExpression, isAssignmentPattern, isRestElement, returnStatement} = _t, buildAnonymousExpressionWrapper = _template.default.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n"), buildNamedExpressionWrapper = _template.default.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n"), buildDeclarationWrapper = (0, 
      _template.default)("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");
    },
    3014: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(code, options = {}) {
        if ("" !== code && shouldHighlight(options)) {
          const defs = function(chalk) {
            return {
              keyword: chalk.cyan,
              capitalized: chalk.yellow,
              jsxIdentifier: chalk.yellow,
              punctuator: chalk.yellow,
              number: chalk.magenta,
              string: chalk.green,
              regex: chalk.magenta,
              comment: chalk.grey,
              invalid: chalk.white.bgRed.bold
            };
          }(getChalk(options));
          return function(defs, text) {
            let highlighted = "";
            for (const {type, value} of tokenize(text)) {
              const colorize = defs[type];
              highlighted += colorize ? value.split(NEWLINE).map((str => colorize(str))).join("\n") : value;
            }
            return highlighted;
          }(defs, code);
        }
        return code;
      }, exports.getChalk = getChalk, exports.shouldHighlight = shouldHighlight;
      var _jsTokens = __webpack_require__(6188), _helperValidatorIdentifier = __webpack_require__(720), _chalk = __webpack_require__(3920);
      const sometimesKeywords = new Set([ "as", "async", "from", "get", "of", "set" ]);
      const NEWLINE = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/;
      let tokenize;
      {
        const JSX_TAG = /^[a-z][\w-]*$/i, getTokenType = function(token, offset, text) {
          if ("name" === token.type) {
            if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, !0) || sometimesKeywords.has(token.value)) return "keyword";
            if (JSX_TAG.test(token.value) && ("<" === text[offset - 1] || "</" == text.slice(offset - 2, offset))) return "jsxIdentifier";
            if (token.value[0] !== token.value[0].toLowerCase()) return "capitalized";
          }
          return "punctuator" === token.type && BRACKET.test(token.value) ? "bracket" : "invalid" !== token.type || "@" !== token.value && "#" !== token.value ? token.type : "punctuator";
        };
        tokenize = function*(text) {
          let match;
          for (;match = _jsTokens.default.exec(text); ) {
            const token = _jsTokens.matchToToken(match);
            yield {
              type: getTokenType(token, match.index, text),
              value: token.value
            };
          }
        };
      }
      function shouldHighlight(options) {
        return !!_chalk.supportsColor || options.forceColor;
      }
      function getChalk(options) {
        return options.forceColor ? new _chalk.constructor({
          enabled: !0,
          level: 1
        }) : _chalk;
      }
    },
    3834: (__unused_webpack_module, exports) => {
      "use strict";
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (null == source) return {};
        var key, i, target = {}, sourceKeys = Object.keys(source);
        for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
        return target;
      }
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      class Position {
        constructor(line, col, index) {
          this.line = void 0, this.column = void 0, this.index = void 0, this.line = line, 
          this.column = col, this.index = index;
        }
      }
      class SourceLocation {
        constructor(start, end) {
          this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, 
          this.start = start, this.end = end;
        }
      }
      function createPositionWithColumnOffset(position, columnOffset) {
        const {line, column, index} = position;
        return new Position(line, column + columnOffset, index + columnOffset);
      }
      const ParseErrorCodes = Object.freeze({
        SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
        SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      }), reflect = (keys, last = keys.length - 1) => ({
        get() {
          return keys.reduce(((object, key) => object[key]), this);
        },
        set(value) {
          keys.reduce(((item, key, i) => i === last ? item[key] = value : item[key]), this);
        }
      });
      const NodeDescriptions = {
        ArrayPattern: "array destructuring pattern",
        AssignmentExpression: "assignment expression",
        AssignmentPattern: "assignment expression",
        ArrowFunctionExpression: "arrow function expression",
        ConditionalExpression: "conditional expression",
        ForOfStatement: "for-of statement",
        ForInStatement: "for-in statement",
        ForStatement: "for-loop",
        FormalParameters: "function parameter list",
        Identifier: "identifier",
        ObjectPattern: "object destructuring pattern",
        ParenthesizedExpression: "parenthesized expression",
        RestElement: "rest element",
        UpdateExpression: {
          true: "prefix operation",
          false: "postfix operation"
        },
        VariableDeclarator: "variable declaration",
        YieldExpression: "yield expression"
      }, toNodeDescription = ({type, prefix}) => "UpdateExpression" === type ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];
      const UnparenthesizedPipeBodyDescriptions = new Set([ "ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression" ]);
      const _excluded$1 = [ "toMessage" ];
      function toParseErrorConstructor(_ref) {
        let {toMessage} = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);
        return function constructor({loc, details}) {
          return ((constructor, properties, descriptors) => Object.keys(descriptors).map((key => [ key, descriptors[key] ])).filter((([, descriptor]) => !!descriptor)).map((([key, descriptor]) => [ key, "function" == typeof descriptor ? {
            value: descriptor,
            enumerable: !1
          } : "string" == typeof descriptor.reflect ? Object.assign({}, descriptor, reflect(descriptor.reflect.split("."))) : descriptor ])).reduce(((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({
            configurable: !0
          }, descriptor))), Object.assign(new constructor, properties)))(SyntaxError, Object.assign({}, properties, {
            loc
          }), {
            clone(overrides = {}) {
              const loc = overrides.loc || {};
              return constructor({
                loc: new Position("line" in loc ? loc.line : this.loc.line, "column" in loc ? loc.column : this.loc.column, "index" in loc ? loc.index : this.loc.index),
                details: Object.assign({}, this.details, overrides.details)
              });
            },
            details: {
              value: details,
              enumerable: !1
            },
            message: {
              get() {
                return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;
              },
              set(value) {
                Object.defineProperty(this, "message", {
                  value
                });
              }
            },
            pos: {
              reflect: "loc.index",
              enumerable: !0
            },
            missingPlugin: "missingPlugin" in details && {
              reflect: "details.missingPlugin",
              enumerable: !0
            }
          });
        };
      }
      function toParseErrorCredentials(toMessageOrMessage, credentials) {
        return Object.assign({
          toMessage: "string" == typeof toMessageOrMessage ? () => toMessageOrMessage : toMessageOrMessage
        }, credentials);
      }
      function ParseErrorEnum(argument, syntaxPlugin) {
        if (Array.isArray(argument)) return toParseErrorCredentialsMap => ParseErrorEnum(toParseErrorCredentialsMap, argument[0]);
        const partialCredentials = argument(toParseErrorCredentials), ParseErrorConstructors = {};
        for (const reasonCode of Object.keys(partialCredentials)) ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: ParseErrorCodes.SyntaxError,
          reasonCode
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, partialCredentials[reasonCode]));
        return ParseErrorConstructors;
      }
      const Errors = Object.assign({}, ParseErrorEnum((_ => ({
        ImportMetaOutsideModule: _("import.meta may appear only with 'sourceType: \"module\"'", {
          code: ParseErrorCodes.SourceTypeModuleError
        }),
        ImportOutsideModule: _("'import' and 'export' may appear only with 'sourceType: \"module\"'", {
          code: ParseErrorCodes.SourceTypeModuleError
        })
      }))), ParseErrorEnum((_ => ({
        AccessorIsGenerator: _((({kind}) => `A ${kind}ter cannot be a generator.`)),
        ArgumentsInClass: _("'arguments' is only allowed in functions and class methods."),
        AsyncFunctionInSingleStatementContext: _("Async functions can only be declared at the top level or inside a block."),
        AwaitBindingIdentifier: _("Can not use 'await' as identifier inside an async function."),
        AwaitBindingIdentifierInStaticBlock: _("Can not use 'await' as identifier inside a static block."),
        AwaitExpressionFormalParameter: _("'await' is not allowed in async function parameters."),
        AwaitNotInAsyncContext: _("'await' is only allowed within async functions and at the top levels of modules."),
        AwaitNotInAsyncFunction: _("'await' is only allowed within async functions."),
        BadGetterArity: _("A 'get' accesor must not have any formal parameters."),
        BadSetterArity: _("A 'set' accesor must have exactly one formal parameter."),
        BadSetterRestParameter: _("A 'set' accesor function argument must not be a rest parameter."),
        ConstructorClassField: _("Classes may not have a field named 'constructor'."),
        ConstructorClassPrivateField: _("Classes may not have a private field named '#constructor'."),
        ConstructorIsAccessor: _("Class constructor may not be an accessor."),
        ConstructorIsAsync: _("Constructor can't be an async function."),
        ConstructorIsGenerator: _("Constructor can't be a generator."),
        DeclarationMissingInitializer: _((({kind}) => `Missing initializer in ${kind} declaration.`)),
        DecoratorBeforeExport: _("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."),
        DecoratorConstructor: _("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"),
        DecoratorExportClass: _("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."),
        DecoratorSemicolon: _("Decorators must not be followed by a semicolon."),
        DecoratorStaticBlock: _("Decorators can't be used with a static block."),
        DeletePrivateField: _("Deleting a private field is not allowed."),
        DestructureNamedImport: _("ES2015 named imports do not destructure. Use another statement for destructuring after the import."),
        DuplicateConstructor: _("Duplicate constructor in the same class."),
        DuplicateDefaultExport: _("Only one default export allowed per module."),
        DuplicateExport: _((({exportName}) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`)),
        DuplicateProto: _("Redefinition of __proto__ property."),
        DuplicateRegExpFlags: _("Duplicate regular expression flag."),
        ElementAfterRest: _("Rest element must be last element."),
        EscapedCharNotAnIdentifier: _("Invalid Unicode escape."),
        ExportBindingIsString: _((({localName, exportName}) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`)),
        ExportDefaultFromAsIdentifier: _("'from' is not allowed as an identifier after 'export default'."),
        ForInOfLoopInitializer: _((({type}) => `'${"ForInStatement" === type ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`)),
        ForOfAsync: _("The left-hand side of a for-of loop may not be 'async'."),
        ForOfLet: _("The left-hand side of a for-of loop may not start with 'let'."),
        GeneratorInSingleStatementContext: _("Generators can only be declared at the top level or inside a block."),
        IllegalBreakContinue: _((({type}) => `Unsyntactic ${"BreakStatement" === type ? "break" : "continue"}.`)),
        IllegalLanguageModeDirective: _("Illegal 'use strict' directive in function with non-simple parameter list."),
        IllegalReturn: _("'return' outside of function."),
        ImportBindingIsString: _((({importName}) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${importName}" as foo }\`?`)),
        ImportCallArgumentTrailingComma: _("Trailing comma is disallowed inside import(...) arguments."),
        ImportCallArity: _((({maxArgumentCount}) => `\`import()\` requires exactly ${1 === maxArgumentCount ? "one argument" : "one or two arguments"}.`)),
        ImportCallNotNewExpression: _("Cannot use new with import(...)."),
        ImportCallSpreadArgument: _("`...` is not allowed in `import()`."),
        IncompatibleRegExpUVFlags: _("The 'u' and 'v' regular expression flags cannot be enabled at the same time."),
        InvalidBigIntLiteral: _("Invalid BigIntLiteral."),
        InvalidCodePoint: _("Code point out of bounds."),
        InvalidCoverInitializedName: _("Invalid shorthand property initializer."),
        InvalidDecimal: _("Invalid decimal."),
        InvalidDigit: _((({radix}) => `Expected number in radix ${radix}.`)),
        InvalidEscapeSequence: _("Bad character escape sequence."),
        InvalidEscapeSequenceTemplate: _("Invalid escape sequence in template."),
        InvalidEscapedReservedWord: _((({reservedWord}) => `Escape sequence in keyword ${reservedWord}.`)),
        InvalidIdentifier: _((({identifierName}) => `Invalid identifier ${identifierName}.`)),
        InvalidLhs: _((({ancestor}) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`)),
        InvalidLhsBinding: _((({ancestor}) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`)),
        InvalidNumber: _("Invalid number."),
        InvalidOrMissingExponent: _("Floating-point numbers require a valid exponent after the 'e'."),
        InvalidOrUnexpectedToken: _((({unexpected}) => `Unexpected character '${unexpected}'.`)),
        InvalidParenthesizedAssignment: _("Invalid parenthesized assignment pattern."),
        InvalidPrivateFieldResolution: _((({identifierName}) => `Private name #${identifierName} is not defined.`)),
        InvalidPropertyBindingPattern: _("Binding member expression."),
        InvalidRecordProperty: _("Only properties and spread elements are allowed in record definitions."),
        InvalidRestAssignmentPattern: _("Invalid rest operator's argument."),
        LabelRedeclaration: _((({labelName}) => `Label '${labelName}' is already declared.`)),
        LetInLexicalBinding: _("'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
        LineTerminatorBeforeArrow: _("No line break is allowed before '=>'."),
        MalformedRegExpFlags: _("Invalid regular expression flag."),
        MissingClassName: _("A class name is required."),
        MissingEqInAssignment: _("Only '=' operator can be used for specifying default value."),
        MissingSemicolon: _("Missing semicolon."),
        MissingPlugin: _((({missingPlugin}) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name => JSON.stringify(name))).join(", ")}.`)),
        MissingOneOfPlugins: _((({missingPlugin}) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name => JSON.stringify(name))).join(", ")}.`)),
        MissingUnicodeEscape: _("Expecting Unicode escape sequence \\uXXXX."),
        MixingCoalesceWithLogical: _("Nullish coalescing operator(??) requires parens when mixing with logical operators."),
        ModuleAttributeDifferentFromType: _("The only accepted module attribute is `type`."),
        ModuleAttributeInvalidValue: _("Only string literals are allowed as module attribute values."),
        ModuleAttributesWithDuplicateKeys: _((({key}) => `Duplicate key "${key}" is not allowed in module attributes.`)),
        ModuleExportNameHasLoneSurrogate: _((({surrogateCharCode}) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`)),
        ModuleExportUndefined: _((({localName}) => `Export '${localName}' is not defined.`)),
        MultipleDefaultsInSwitch: _("Multiple default clauses."),
        NewlineAfterThrow: _("Illegal newline after throw."),
        NoCatchOrFinally: _("Missing catch or finally clause."),
        NumberIdentifier: _("Identifier directly after number."),
        NumericSeparatorInEscapeSequence: _("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."),
        ObsoleteAwaitStar: _("'await*' has been removed from the async functions proposal. Use Promise.all() instead."),
        OptionalChainingNoNew: _("Constructors in/after an Optional Chain are not allowed."),
        OptionalChainingNoTemplate: _("Tagged Template Literals are not allowed in optionalChain."),
        OverrideOnConstructor: _("'override' modifier cannot appear on a constructor declaration."),
        ParamDupe: _("Argument name clash."),
        PatternHasAccessor: _("Object pattern can't contain getter or setter."),
        PatternHasMethod: _("Object pattern can't contain methods."),
        PrivateInExpectedIn: _((({identifierName}) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`)),
        PrivateNameRedeclaration: _((({identifierName}) => `Duplicate private name #${identifierName}.`)),
        RecordExpressionBarIncorrectEndSyntaxType: _("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        RecordExpressionBarIncorrectStartSyntaxType: _("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        RecordExpressionHashIncorrectStartSyntaxType: _("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
        RecordNoProto: _("'__proto__' is not allowed in Record expressions."),
        RestTrailingComma: _("Unexpected trailing comma after rest element."),
        SloppyFunction: _("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."),
        StaticPrototype: _("Classes may not have static property named prototype."),
        SuperNotAllowed: _("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"),
        SuperPrivateField: _("Private fields can't be accessed on super."),
        TrailingDecorator: _("Decorators must be attached to a class element."),
        TupleExpressionBarIncorrectEndSyntaxType: _("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        TupleExpressionBarIncorrectStartSyntaxType: _("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."),
        TupleExpressionHashIncorrectStartSyntaxType: _("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."),
        UnexpectedArgumentPlaceholder: _("Unexpected argument placeholder."),
        UnexpectedAwaitAfterPipelineBody: _('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'),
        UnexpectedDigitAfterHash: _("Unexpected digit after hash token."),
        UnexpectedImportExport: _("'import' and 'export' may only appear at the top level."),
        UnexpectedKeyword: _((({keyword}) => `Unexpected keyword '${keyword}'.`)),
        UnexpectedLeadingDecorator: _("Leading decorators must be attached to a class declaration."),
        UnexpectedLexicalDeclaration: _("Lexical declaration cannot appear in a single-statement context."),
        UnexpectedNewTarget: _("`new.target` can only be used in functions or class properties."),
        UnexpectedNumericSeparator: _("A numeric separator is only allowed between two digits."),
        UnexpectedPrivateField: _("Unexpected private name."),
        UnexpectedReservedWord: _((({reservedWord}) => `Unexpected reserved word '${reservedWord}'.`)),
        UnexpectedSuper: _("'super' is only allowed in object methods and classes."),
        UnexpectedToken: _((({expected, unexpected}) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`)),
        UnexpectedTokenUnaryExponentiation: _("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."),
        UnsupportedBind: _("Binding should be performed on object property."),
        UnsupportedDecoratorExport: _("A decorated export must export a class declaration."),
        UnsupportedDefaultExport: _("Only expressions, functions or classes are allowed as the `default` export."),
        UnsupportedImport: _("`import` can only be used in `import()` or `import.meta`."),
        UnsupportedMetaProperty: _((({target, onlyValidPropertyName}) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`)),
        UnsupportedParameterDecorator: _("Decorators cannot be used to decorate parameters."),
        UnsupportedPropertyDecorator: _("Decorators cannot be used to decorate object literal properties."),
        UnsupportedSuper: _("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."),
        UnterminatedComment: _("Unterminated comment."),
        UnterminatedRegExp: _("Unterminated regular expression."),
        UnterminatedString: _("Unterminated string constant."),
        UnterminatedTemplate: _("Unterminated template."),
        VarRedeclaration: _((({identifierName}) => `Identifier '${identifierName}' has already been declared.`)),
        YieldBindingIdentifier: _("Can not use 'yield' as identifier inside a generator."),
        YieldInParameter: _("Yield expression is not allowed in formal parameters."),
        ZeroDigitNumericSeparator: _("Numeric separator can not be used after leading 0.")
      }))), ParseErrorEnum((_ => ({
        StrictDelete: _("Deleting local variable in strict mode."),
        StrictEvalArguments: _((({referenceName}) => `Assigning to '${referenceName}' in strict mode.`)),
        StrictEvalArgumentsBinding: _((({bindingName}) => `Binding '${bindingName}' in strict mode.`)),
        StrictFunction: _("In strict mode code, functions can only be declared at top level or inside a block."),
        StrictNumericEscape: _("The only valid numeric escape in strict mode is '\\0'."),
        StrictOctalLiteral: _("Legacy octal literals are not allowed in strict mode."),
        StrictWith: _("'with' in strict mode.")
      }))), ParseErrorEnum`pipelineOperator`((_ => ({
        PipeBodyIsTighter: _("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."),
        PipeTopicRequiresHackPipes: _('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'),
        PipeTopicUnbound: _("Topic reference is unbound; it must be inside a pipe body."),
        PipeTopicUnconfiguredToken: _((({token}) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`)),
        PipeTopicUnused: _("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."),
        PipeUnparenthesizedBody: _((({type}) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
          type
        })}; please wrap it in parentheses.`)),
        PipelineBodyNoArrow: _('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'),
        PipelineBodySequenceExpression: _("Pipeline body may not be a comma-separated sequence expression."),
        PipelineHeadSequenceExpression: _("Pipeline head should not be a comma-separated sequence expression."),
        PipelineTopicUnused: _("Pipeline is in topic style but does not use topic reference."),
        PrimaryTopicNotAllowed: _("Topic reference was used in a lexical context without topic binding."),
        PrimaryTopicRequiresSmartPipeline: _('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.')
      })))), {defineProperty} = Object, toUnenumerable = (object, key) => defineProperty(object, key, {
        enumerable: !1,
        value: object[key]
      });
      function toESTreeLocation(node) {
        return toUnenumerable(node.loc.start, "index"), toUnenumerable(node.loc.end, "index"), 
        node;
      }
      class TokContext {
        constructor(token, preserveSpace) {
          this.token = void 0, this.preserveSpace = void 0, this.token = token, this.preserveSpace = !!preserveSpace;
        }
      }
      const types = {
        brace: new TokContext("{"),
        j_oTag: new TokContext("<tag"),
        j_cTag: new TokContext("</tag"),
        j_expr: new TokContext("<tag>...</tag>", !0)
      };
      types.template = new TokContext("`", !0);
      class ExportedTokenType {
        constructor(label, conf = {}) {
          this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, 
          this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, 
          this.postfix = void 0, this.binop = void 0, this.label = label, this.keyword = conf.keyword, 
          this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.rightAssociative = !!conf.rightAssociative, 
          this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, 
          this.postfix = !!conf.postfix, this.binop = null != conf.binop ? conf.binop : null, 
          this.updateContext = null;
        }
      }
      const keywords$1 = new Map;
      function createKeyword(name, options = {}) {
        options.keyword = name;
        const token = createToken(name, options);
        return keywords$1.set(name, token), token;
      }
      function createBinop(name, binop) {
        return createToken(name, {
          beforeExpr: true,
          binop
        });
      }
      let tokenTypeCounter = -1;
      const tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
      function createToken(name, options = {}) {
        var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
        return ++tokenTypeCounter, tokenLabels.push(name), tokenBinops.push(null != (_options$binop = options.binop) ? _options$binop : -1), 
        tokenBeforeExprs.push(null != (_options$beforeExpr = options.beforeExpr) && _options$beforeExpr), 
        tokenStartsExprs.push(null != (_options$startsExpr = options.startsExpr) && _options$startsExpr), 
        tokenPrefixes.push(null != (_options$prefix = options.prefix) && _options$prefix), 
        tokenTypes.push(new ExportedTokenType(name, options)), tokenTypeCounter;
      }
      function createKeywordLike(name, options = {}) {
        var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
        return ++tokenTypeCounter, keywords$1.set(name, tokenTypeCounter), tokenLabels.push(name), 
        tokenBinops.push(null != (_options$binop2 = options.binop) ? _options$binop2 : -1), 
        tokenBeforeExprs.push(null != (_options$beforeExpr2 = options.beforeExpr) && _options$beforeExpr2), 
        tokenStartsExprs.push(null != (_options$startsExpr2 = options.startsExpr) && _options$startsExpr2), 
        tokenPrefixes.push(null != (_options$prefix2 = options.prefix) && _options$prefix2), 
        tokenTypes.push(new ExportedTokenType("name", options)), tokenTypeCounter;
      }
      const tt = {
        bracketL: createToken("[", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketHashL: createToken("#[", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketBarL: createToken("[|", {
          beforeExpr: true,
          startsExpr: true
        }),
        bracketR: createToken("]"),
        bracketBarR: createToken("|]"),
        braceL: createToken("{", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceBarL: createToken("{|", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceHashL: createToken("#{", {
          beforeExpr: true,
          startsExpr: true
        }),
        braceR: createToken("}", {
          beforeExpr: true
        }),
        braceBarR: createToken("|}"),
        parenL: createToken("(", {
          beforeExpr: true,
          startsExpr: true
        }),
        parenR: createToken(")"),
        comma: createToken(",", {
          beforeExpr: true
        }),
        semi: createToken(";", {
          beforeExpr: true
        }),
        colon: createToken(":", {
          beforeExpr: true
        }),
        doubleColon: createToken("::", {
          beforeExpr: true
        }),
        dot: createToken("."),
        question: createToken("?", {
          beforeExpr: true
        }),
        questionDot: createToken("?."),
        arrow: createToken("=>", {
          beforeExpr: true
        }),
        template: createToken("template"),
        ellipsis: createToken("...", {
          beforeExpr: true
        }),
        backQuote: createToken("`", {
          startsExpr: true
        }),
        dollarBraceL: createToken("${", {
          beforeExpr: true,
          startsExpr: true
        }),
        templateTail: createToken("...`", {
          startsExpr: true
        }),
        templateNonTail: createToken("...${", {
          beforeExpr: true,
          startsExpr: true
        }),
        at: createToken("@"),
        hash: createToken("#", {
          startsExpr: true
        }),
        interpreterDirective: createToken("#!..."),
        eq: createToken("=", {
          beforeExpr: true,
          isAssign: true
        }),
        assign: createToken("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        slashAssign: createToken("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        xorAssign: createToken("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        moduloAssign: createToken("_=", {
          beforeExpr: true,
          isAssign: true
        }),
        incDec: createToken("++/--", {
          prefix: true,
          postfix: !0,
          startsExpr: true
        }),
        bang: createToken("!", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        tilde: createToken("~", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        doubleCaret: createToken("^^", {
          startsExpr: true
        }),
        doubleAt: createToken("@@", {
          startsExpr: true
        }),
        pipeline: createBinop("|>", 0),
        nullishCoalescing: createBinop("??", 1),
        logicalOR: createBinop("||", 1),
        logicalAND: createBinop("&&", 2),
        bitwiseOR: createBinop("|", 3),
        bitwiseXOR: createBinop("^", 4),
        bitwiseAND: createBinop("&", 5),
        equality: createBinop("==/!=/===/!==", 6),
        lt: createBinop("</>/<=/>=", 7),
        gt: createBinop("</>/<=/>=", 7),
        relational: createBinop("</>/<=/>=", 7),
        bitShift: createBinop("<</>>/>>>", 8),
        bitShiftL: createBinop("<</>>/>>>", 8),
        bitShiftR: createBinop("<</>>/>>>", 8),
        plusMin: createToken("+/-", {
          beforeExpr: true,
          binop: 9,
          prefix: true,
          startsExpr: true
        }),
        modulo: createToken("%", {
          binop: 10,
          startsExpr: true
        }),
        star: createToken("*", {
          binop: 10
        }),
        slash: createBinop("/", 10),
        exponent: createToken("**", {
          beforeExpr: true,
          binop: 11,
          rightAssociative: !0
        }),
        _in: createKeyword("in", {
          beforeExpr: true,
          binop: 7
        }),
        _instanceof: createKeyword("instanceof", {
          beforeExpr: true,
          binop: 7
        }),
        _break: createKeyword("break"),
        _case: createKeyword("case", {
          beforeExpr: true
        }),
        _catch: createKeyword("catch"),
        _continue: createKeyword("continue"),
        _debugger: createKeyword("debugger"),
        _default: createKeyword("default", {
          beforeExpr: true
        }),
        _else: createKeyword("else", {
          beforeExpr: true
        }),
        _finally: createKeyword("finally"),
        _function: createKeyword("function", {
          startsExpr: true
        }),
        _if: createKeyword("if"),
        _return: createKeyword("return", {
          beforeExpr: true
        }),
        _switch: createKeyword("switch"),
        _throw: createKeyword("throw", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _try: createKeyword("try"),
        _var: createKeyword("var"),
        _const: createKeyword("const"),
        _with: createKeyword("with"),
        _new: createKeyword("new", {
          beforeExpr: true,
          startsExpr: true
        }),
        _this: createKeyword("this", {
          startsExpr: true
        }),
        _super: createKeyword("super", {
          startsExpr: true
        }),
        _class: createKeyword("class", {
          startsExpr: true
        }),
        _extends: createKeyword("extends", {
          beforeExpr: true
        }),
        _export: createKeyword("export"),
        _import: createKeyword("import", {
          startsExpr: true
        }),
        _null: createKeyword("null", {
          startsExpr: true
        }),
        _true: createKeyword("true", {
          startsExpr: true
        }),
        _false: createKeyword("false", {
          startsExpr: true
        }),
        _typeof: createKeyword("typeof", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _void: createKeyword("void", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _delete: createKeyword("delete", {
          beforeExpr: true,
          prefix: true,
          startsExpr: true
        }),
        _do: createKeyword("do", {
          isLoop: true,
          beforeExpr: true
        }),
        _for: createKeyword("for", {
          isLoop: true
        }),
        _while: createKeyword("while", {
          isLoop: true
        }),
        _as: createKeywordLike("as", {
          startsExpr: true
        }),
        _assert: createKeywordLike("assert", {
          startsExpr: true
        }),
        _async: createKeywordLike("async", {
          startsExpr: true
        }),
        _await: createKeywordLike("await", {
          startsExpr: true
        }),
        _from: createKeywordLike("from", {
          startsExpr: true
        }),
        _get: createKeywordLike("get", {
          startsExpr: true
        }),
        _let: createKeywordLike("let", {
          startsExpr: true
        }),
        _meta: createKeywordLike("meta", {
          startsExpr: true
        }),
        _of: createKeywordLike("of", {
          startsExpr: true
        }),
        _sent: createKeywordLike("sent", {
          startsExpr: true
        }),
        _set: createKeywordLike("set", {
          startsExpr: true
        }),
        _static: createKeywordLike("static", {
          startsExpr: true
        }),
        _yield: createKeywordLike("yield", {
          startsExpr: true
        }),
        _asserts: createKeywordLike("asserts", {
          startsExpr: true
        }),
        _checks: createKeywordLike("checks", {
          startsExpr: true
        }),
        _exports: createKeywordLike("exports", {
          startsExpr: true
        }),
        _global: createKeywordLike("global", {
          startsExpr: true
        }),
        _implements: createKeywordLike("implements", {
          startsExpr: true
        }),
        _intrinsic: createKeywordLike("intrinsic", {
          startsExpr: true
        }),
        _infer: createKeywordLike("infer", {
          startsExpr: true
        }),
        _is: createKeywordLike("is", {
          startsExpr: true
        }),
        _mixins: createKeywordLike("mixins", {
          startsExpr: true
        }),
        _proto: createKeywordLike("proto", {
          startsExpr: true
        }),
        _require: createKeywordLike("require", {
          startsExpr: true
        }),
        _keyof: createKeywordLike("keyof", {
          startsExpr: true
        }),
        _readonly: createKeywordLike("readonly", {
          startsExpr: true
        }),
        _unique: createKeywordLike("unique", {
          startsExpr: true
        }),
        _abstract: createKeywordLike("abstract", {
          startsExpr: true
        }),
        _declare: createKeywordLike("declare", {
          startsExpr: true
        }),
        _enum: createKeywordLike("enum", {
          startsExpr: true
        }),
        _module: createKeywordLike("module", {
          startsExpr: true
        }),
        _namespace: createKeywordLike("namespace", {
          startsExpr: true
        }),
        _interface: createKeywordLike("interface", {
          startsExpr: true
        }),
        _type: createKeywordLike("type", {
          startsExpr: true
        }),
        _opaque: createKeywordLike("opaque", {
          startsExpr: true
        }),
        name: createToken("name", {
          startsExpr: true
        }),
        string: createToken("string", {
          startsExpr: true
        }),
        num: createToken("num", {
          startsExpr: true
        }),
        bigint: createToken("bigint", {
          startsExpr: true
        }),
        decimal: createToken("decimal", {
          startsExpr: true
        }),
        regexp: createToken("regexp", {
          startsExpr: true
        }),
        privateName: createToken("#name", {
          startsExpr: true
        }),
        eof: createToken("eof"),
        jsxName: createToken("jsxName"),
        jsxText: createToken("jsxText", {
          beforeExpr: !0
        }),
        jsxTagStart: createToken("jsxTagStart", {
          startsExpr: !0
        }),
        jsxTagEnd: createToken("jsxTagEnd"),
        placeholder: createToken("%%", {
          startsExpr: !0
        })
      };
      function tokenIsIdentifier(token) {
        return token >= 93 && token <= 128;
      }
      function tokenIsKeywordOrIdentifier(token) {
        return token >= 58 && token <= 128;
      }
      function tokenIsLiteralPropertyName(token) {
        return token >= 58 && token <= 132;
      }
      function tokenCanStartExpression(token) {
        return tokenStartsExprs[token];
      }
      function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
        return token >= 125 && token <= 127;
      }
      function tokenIsKeyword(token) {
        return token >= 58 && token <= 92;
      }
      function tokenLabelName(token) {
        return tokenLabels[token];
      }
      function tokenOperatorPrecedence(token) {
        return tokenBinops[token];
      }
      function tokenIsTemplate(token) {
        return token >= 24 && token <= 25;
      }
      function getExportedToken(token) {
        return tokenTypes[token];
      }
      tokenTypes[8].updateContext = context => {
        context.pop();
      }, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {
        context.push(types.brace);
      }, tokenTypes[22].updateContext = context => {
        context[context.length - 1] === types.template ? context.pop() : context.push(types.template);
      }, tokenTypes[138].updateContext = context => {
        context.push(types.j_expr, types.j_oTag);
      };
      let nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
      const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
      const astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938 ], astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239 ];
      function isInAstralSet(code, set) {
        let pos = 65536;
        for (let i = 0, length = set.length; i < length; i += 2) {
          if (pos += set[i], pos > code) return !1;
          if (pos += set[i + 1], pos >= code) return !0;
        }
        return !1;
      }
      function isIdentifierStart(code) {
        return code < 65 ? 36 === code : code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes)));
      }
      function isIdentifierChar(code) {
        return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes))));
      }
      const reservedWords_strict = [ "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield" ], reservedWords_strictBind = [ "eval", "arguments" ], keywords = new Set([ "break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete" ]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
      function isReservedWord(word, inModule) {
        return inModule && "await" === word || "enum" === word;
      }
      function isStrictReservedWord(word, inModule) {
        return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
      }
      function isStrictBindOnlyReservedWord(word) {
        return reservedWordsStrictBindSet.has(word);
      }
      function isStrictBindReservedWord(word, inModule) {
        return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
      }
      const reservedWordLikeSet = new Set([ "break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await" ]);
      function setTrailingComments(node, comments) {
        void 0 === node.trailingComments ? node.trailingComments = comments : node.trailingComments.unshift(...comments);
      }
      function setInnerComments(node, comments) {
        void 0 === node.innerComments ? node.innerComments = comments : node.innerComments.unshift(...comments);
      }
      function adjustInnerComments(node, elements, commentWS) {
        let lastElement = null, i = elements.length;
        for (;null === lastElement && i > 0; ) lastElement = elements[--i];
        null === lastElement || lastElement.start > commentWS.start ? setInnerComments(node, commentWS.comments) : setTrailingComments(lastElement, commentWS.comments);
      }
      const lineBreak = /\r\n?|[\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        switch (code) {
         case 10:
         case 13:
         case 8232:
         case 8233:
          return !0;

         default:
          return !1;
        }
      }
      const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceToLineBreak = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
      function isWhitespace(code) {
        switch (code) {
         case 9:
         case 11:
         case 12:
         case 32:
         case 160:
         case 5760:
         case 8192:
         case 8193:
         case 8194:
         case 8195:
         case 8196:
         case 8197:
         case 8198:
         case 8199:
         case 8200:
         case 8201:
         case 8202:
         case 8239:
         case 8287:
         case 12288:
         case 65279:
          return !0;

         default:
          return !1;
        }
      }
      class State {
        constructor() {
          this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, 
          this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], 
          this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inType = !1, 
          this.noAnonFunctionType = !1, this.hasFlowComment = !1, this.isAmbientContext = !1, 
          this.inAbstractClass = !1, this.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], 
          this.decoratorStack = [ [] ], this.comments = [], this.commentStack = [], this.pos = 0, 
          this.type = 135, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, 
          this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [ types.brace ], 
          this.canStartJSXElement = !0, this.containsEsc = !1, this.strictErrors = new Map, 
          this.tokensLength = 0;
        }
        init({strictMode, sourceType, startLine, startColumn}) {
          this.strict = !1 !== strictMode && (!0 === strictMode || "module" === sourceType), 
          this.curLine = startLine, this.lineStart = -startColumn, this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
        }
        curPosition() {
          return new Position(this.curLine, this.pos - this.lineStart, this.pos);
        }
        clone(skipArrays) {
          const state = new State, keys = Object.keys(this);
          for (let i = 0, length = keys.length; i < length; i++) {
            const key = keys[i];
            let val = this[key];
            !skipArrays && Array.isArray(val) && (val = val.slice()), state[key] = val;
          }
          return state;
        }
      }
      const _excluded = [ "at" ], _excluded2 = [ "at" ];
      var _isDigit = function(code) {
        return code >= 48 && code <= 57;
      };
      const VALID_REGEX_FLAGS = new Set([ 103, 109, 115, 105, 121, 117, 100, 118 ]), forbiddenNumericSeparatorSiblings = {
        decBinOct: new Set([ 46, 66, 69, 79, 95, 98, 101, 111 ]),
        hex: new Set([ 46, 88, 95, 120 ])
      }, isAllowedNumericSeparatorSibling = {
        bin: ch => 48 === ch || 49 === ch,
        oct: ch => ch >= 48 && ch <= 55,
        dec: ch => ch >= 48 && ch <= 57,
        hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
      };
      class Token {
        constructor(state) {
          this.type = state.type, this.value = state.value, this.start = state.start, this.end = state.end, 
          this.loc = new SourceLocation(state.startLoc, state.endLoc);
        }
      }
      class Scope {
        constructor(flags) {
          this.var = new Set, this.lexical = new Set, this.functions = new Set, this.flags = flags;
        }
      }
      class ScopeHandler {
        constructor(parser, inModule) {
          this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = new Map, 
          this.parser = parser, this.inModule = inModule;
        }
        get inFunction() {
          return (2 & this.currentVarScopeFlags()) > 0;
        }
        get allowSuper() {
          return (16 & this.currentThisScopeFlags()) > 0;
        }
        get allowDirectSuper() {
          return (32 & this.currentThisScopeFlags()) > 0;
        }
        get inClass() {
          return (64 & this.currentThisScopeFlags()) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
          const flags = this.currentThisScopeFlags();
          return (64 & flags) > 0 && 0 == (2 & flags);
        }
        get inStaticBlock() {
          for (let i = this.scopeStack.length - 1; ;i--) {
            const {flags} = this.scopeStack[i];
            if (128 & flags) return !0;
            if (323 & flags) return !1;
          }
        }
        get inNonArrowFunction() {
          return (2 & this.currentThisScopeFlags()) > 0;
        }
        get treatFunctionsAsVar() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(flags) {
          return new Scope(flags);
        }
        enter(flags) {
          this.scopeStack.push(this.createScope(flags));
        }
        exit() {
          this.scopeStack.pop();
        }
        treatFunctionsAsVarInScope(scope) {
          return !!(130 & scope.flags || !this.parser.inModule && 1 & scope.flags);
        }
        declareName(name, bindingType, loc) {
          let scope = this.currentScope();
          if (8 & bindingType || 16 & bindingType) this.checkRedeclarationInScope(scope, name, bindingType, loc), 
          16 & bindingType ? scope.functions.add(name) : scope.lexical.add(name), 8 & bindingType && this.maybeExportDefined(scope, name); else if (4 & bindingType) for (let i = this.scopeStack.length - 1; i >= 0 && (scope = this.scopeStack[i], 
          this.checkRedeclarationInScope(scope, name, bindingType, loc), scope.var.add(name), 
          this.maybeExportDefined(scope, name), !(259 & scope.flags)); --i) ;
          this.parser.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
        }
        maybeExportDefined(scope, name) {
          this.parser.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
        }
        checkRedeclarationInScope(scope, name, bindingType, loc) {
          this.isRedeclaredInScope(scope, name, bindingType) && this.parser.raise(Errors.VarRedeclaration, {
            at: loc,
            identifierName: name
          });
        }
        isRedeclaredInScope(scope, name, bindingType) {
          return !!(1 & bindingType) && (8 & bindingType ? scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name) : 16 & bindingType ? scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name) : scope.lexical.has(name) && !(8 & scope.flags && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name));
        }
        checkLocalExport(id) {
          const {name} = id, topLevelScope = this.scopeStack[0];
          topLevelScope.lexical.has(name) || topLevelScope.var.has(name) || topLevelScope.functions.has(name) || this.undefinedExports.set(name, id.loc.start);
        }
        currentScope() {
          return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
          for (let i = this.scopeStack.length - 1; ;i--) {
            const {flags} = this.scopeStack[i];
            if (259 & flags) return flags;
          }
        }
        currentThisScopeFlags() {
          for (let i = this.scopeStack.length - 1; ;i--) {
            const {flags} = this.scopeStack[i];
            if (323 & flags && !(4 & flags)) return flags;
          }
        }
      }
      class FlowScope extends Scope {
        constructor(...args) {
          super(...args), this.declareFunctions = new Set;
        }
      }
      class FlowScopeHandler extends ScopeHandler {
        createScope(flags) {
          return new FlowScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (2048 & bindingType) return this.checkRedeclarationInScope(scope, name, bindingType, loc), 
          this.maybeExportDefined(scope, name), void scope.declareFunctions.add(name);
          super.declareName(...arguments);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          return !!super.isRedeclaredInScope(...arguments) || !!(2048 & bindingType) && (!scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name)));
        }
        checkLocalExport(id) {
          this.scopeStack[0].declareFunctions.has(id.name) || super.checkLocalExport(id);
        }
      }
      class ClassScope {
        constructor() {
          this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
        }
      }
      class ClassScopeHandler {
        constructor(parser) {
          this.parser = void 0, this.stack = [], this.undefinedPrivateNames = new Map, this.parser = parser;
        }
        current() {
          return this.stack[this.stack.length - 1];
        }
        enter() {
          this.stack.push(new ClassScope);
        }
        exit() {
          const oldClassScope = this.stack.pop(), current = this.current();
          for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) current ? current.undefinedPrivateNames.has(name) || current.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name
          });
        }
        declarePrivateName(name, elementType, loc) {
          const {privateNames, loneAccessors, undefinedPrivateNames} = this.current();
          let redefined = privateNames.has(name);
          if (3 & elementType) {
            const accessor = redefined && loneAccessors.get(name);
            if (accessor) {
              const oldStatic = 4 & accessor, newStatic = 4 & elementType;
              redefined = (3 & accessor) === (3 & elementType) || oldStatic !== newStatic, redefined || loneAccessors.delete(name);
            } else redefined || loneAccessors.set(name, elementType);
          }
          redefined && this.parser.raise(Errors.PrivateNameRedeclaration, {
            at: loc,
            identifierName: name
          }), privateNames.add(name), undefinedPrivateNames.delete(name);
        }
        usePrivateName(name, loc) {
          let classScope;
          for (classScope of this.stack) if (classScope.privateNames.has(name)) return;
          classScope ? classScope.undefinedPrivateNames.set(name, loc) : this.parser.raise(Errors.InvalidPrivateFieldResolution, {
            at: loc,
            identifierName: name
          });
        }
      }
      class ExpressionScope {
        constructor(type = 0) {
          this.type = void 0, this.type = type;
        }
        canBeArrowParameterDeclaration() {
          return 2 === this.type || 1 === this.type;
        }
        isCertainlyParameterDeclaration() {
          return 3 === this.type;
        }
      }
      class ArrowHeadParsingScope extends ExpressionScope {
        constructor(type) {
          super(type), this.declarationErrors = new Map;
        }
        recordDeclarationError(ParsingErrorClass, {at}) {
          const index = at.index;
          this.declarationErrors.set(index, [ ParsingErrorClass, at ]);
        }
        clearDeclarationError(index) {
          this.declarationErrors.delete(index);
        }
        iterateErrors(iterator) {
          this.declarationErrors.forEach(iterator);
        }
      }
      class ExpressionScopeHandler {
        constructor(parser) {
          this.parser = void 0, this.stack = [ new ExpressionScope ], this.parser = parser;
        }
        enter(scope) {
          this.stack.push(scope);
        }
        exit() {
          this.stack.pop();
        }
        recordParameterInitializerError(toParseError, {at: node}) {
          const origin = {
            at: node.loc.start
          }, {stack} = this;
          let i = stack.length - 1, scope = stack[i];
          for (;!scope.isCertainlyParameterDeclaration(); ) {
            if (!scope.canBeArrowParameterDeclaration()) return;
            scope.recordDeclarationError(toParseError, origin), scope = stack[--i];
          }
          this.parser.raise(toParseError, origin);
        }
        recordParenthesizedIdentifierError({at: node}) {
          const {stack} = this, scope = stack[stack.length - 1], origin = {
            at: node.loc.start
          };
          if (scope.isCertainlyParameterDeclaration()) this.parser.raise(Errors.InvalidParenthesizedAssignment, origin); else {
            if (!scope.canBeArrowParameterDeclaration()) return;
            scope.recordDeclarationError(Errors.InvalidParenthesizedAssignment, origin);
          }
        }
        recordAsyncArrowParametersError({at}) {
          const {stack} = this;
          let i = stack.length - 1, scope = stack[i];
          for (;scope.canBeArrowParameterDeclaration(); ) 2 === scope.type && scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {
            at
          }), scope = stack[--i];
        }
        validateAsPattern() {
          const {stack} = this, currentScope = stack[stack.length - 1];
          currentScope.canBeArrowParameterDeclaration() && currentScope.iterateErrors((([toParseError, loc]) => {
            this.parser.raise(toParseError, {
              at: loc
            });
            let i = stack.length - 2, scope = stack[i];
            for (;scope.canBeArrowParameterDeclaration(); ) scope.clearDeclarationError(loc.index), 
            scope = stack[--i];
          }));
        }
      }
      function newExpressionScope() {
        return new ExpressionScope;
      }
      class ProductionParameterHandler {
        constructor() {
          this.stacks = [];
        }
        enter(flags) {
          this.stacks.push(flags);
        }
        exit() {
          this.stacks.pop();
        }
        currentFlags() {
          return this.stacks[this.stacks.length - 1];
        }
        get hasAwait() {
          return (2 & this.currentFlags()) > 0;
        }
        get hasYield() {
          return (1 & this.currentFlags()) > 0;
        }
        get hasReturn() {
          return (4 & this.currentFlags()) > 0;
        }
        get hasIn() {
          return (8 & this.currentFlags()) > 0;
        }
      }
      function functionFlags(isAsync, isGenerator) {
        return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
      }
      class ExpressionErrors {
        constructor() {
          this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, 
          this.optionalParametersLoc = null;
        }
      }
      class Node {
        constructor(parser, pos, loc) {
          this.type = "", this.start = pos, this.end = 0, this.loc = new SourceLocation(loc), 
          null != parser && parser.options.ranges && (this.range = [ pos, 0 ]), null != parser && parser.filename && (this.loc.filename = parser.filename);
        }
      }
      const NodePrototype = Node.prototype;
      function cloneIdentifier(node) {
        const {type, start, end, loc, range, extra, name} = node, cloned = Object.create(NodePrototype);
        return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, 
        cloned.range = range, cloned.extra = extra, cloned.name = name, "Placeholder" === type && (cloned.expectedNode = node.expectedNode), 
        cloned;
      }
      function cloneStringLiteral(node) {
        const {type, start, end, loc, range, extra} = node;
        if ("Placeholder" === type) return function(node) {
          return cloneIdentifier(node);
        }(node);
        const cloned = Object.create(NodePrototype);
        return cloned.type = type, cloned.start = start, cloned.end = end, cloned.loc = loc, 
        cloned.range = range, void 0 !== node.raw ? cloned.raw = node.raw : cloned.extra = extra, 
        cloned.value = node.value, cloned;
      }
      NodePrototype.__clone = function() {
        const newNode = new Node, keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          "leadingComments" !== key && "trailingComments" !== key && "innerComments" !== key && (newNode[key] = this[key]);
        }
        return newNode;
      };
      const reservedTypes = new Set([ "_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void" ]), FlowErrors = ParseErrorEnum`flow`((_ => ({
        AmbiguousConditionalArrow: _("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."),
        AmbiguousDeclareModuleKind: _("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."),
        AssignReservedType: _((({reservedType}) => `Cannot overwrite reserved type ${reservedType}.`)),
        DeclareClassElement: _("The `declare` modifier can only appear on class fields."),
        DeclareClassFieldInitializer: _("Initializers are not allowed in fields with the `declare` modifier."),
        DuplicateDeclareModuleExports: _("Duplicate `declare module.exports` statement."),
        EnumBooleanMemberNotInitialized: _((({memberName, enumName}) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`)),
        EnumDuplicateMemberName: _((({memberName, enumName}) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`)),
        EnumInconsistentMemberValues: _((({enumName}) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`)),
        EnumInvalidExplicitType: _((({invalidEnumType, enumName}) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`)),
        EnumInvalidExplicitTypeUnknownSupplied: _((({enumName}) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`)),
        EnumInvalidMemberInitializerPrimaryType: _((({enumName, memberName, explicitType}) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`)),
        EnumInvalidMemberInitializerSymbolType: _((({enumName, memberName}) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`)),
        EnumInvalidMemberInitializerUnknownType: _((({enumName, memberName}) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`)),
        EnumInvalidMemberName: _((({enumName, memberName, suggestion}) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`)),
        EnumNumberMemberNotInitialized: _((({enumName, memberName}) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`)),
        EnumStringMemberInconsistentlyInitailized: _((({enumName}) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`)),
        GetterMayNotHaveThisParam: _("A getter cannot have a `this` parameter."),
        ImportTypeShorthandOnlyInPureImport: _("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."),
        InexactInsideExact: _("Explicit inexact syntax cannot appear inside an explicit exact object type."),
        InexactInsideNonObject: _("Explicit inexact syntax cannot appear in class or interface definitions."),
        InexactVariance: _("Explicit inexact syntax cannot have variance."),
        InvalidNonTypeImportInDeclareModule: _("Imports within a `declare module` body must always be `import type` or `import typeof`."),
        MissingTypeParamDefault: _("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),
        NestedDeclareModule: _("`declare module` cannot be used inside another `declare module`."),
        NestedFlowComment: _("Cannot have a flow comment inside another flow comment."),
        PatternIsOptional: _("A binding pattern parameter cannot be optional in an implementation signature.", {
          reasonCode: "OptionalBindingPattern"
        }),
        SetterMayNotHaveThisParam: _("A setter cannot have a `this` parameter."),
        SpreadVariance: _("Spread properties cannot have variance."),
        ThisParamAnnotationRequired: _("A type annotation is required for the `this` parameter."),
        ThisParamBannedInConstructor: _("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."),
        ThisParamMayNotBeOptional: _("The `this` parameter cannot be optional."),
        ThisParamMustBeFirst: _("The `this` parameter must be the first function parameter."),
        ThisParamNoDefault: _("The `this` parameter may not have a default value."),
        TypeBeforeInitializer: _("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
        TypeCastInPattern: _("The type cast expression is expected to be wrapped with parenthesis."),
        UnexpectedExplicitInexactInObject: _("Explicit inexact syntax must appear at the end of an inexact object."),
        UnexpectedReservedType: _((({reservedType}) => `Unexpected reserved type ${reservedType}.`)),
        UnexpectedReservedUnderscore: _("`_` is only allowed as a type argument to call or new."),
        UnexpectedSpaceBetweenModuloChecks: _("Spaces between `%` and `checks` are not allowed here."),
        UnexpectedSpreadType: _("Spread operator cannot appear in class or interface definitions."),
        UnexpectedSubtractionOperand: _('Unexpected token, expected "number" or "bigint".'),
        UnexpectedTokenAfterTypeParameter: _("Expected an arrow function after this type parameter declaration."),
        UnexpectedTypeParameterBeforeAsyncArrowFunction: _("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."),
        UnsupportedDeclareExportKind: _((({unsupportedExportKind, suggestion}) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`)),
        UnsupportedStatementInDeclareModule: _("Only declares and type imports are allowed inside declare module."),
        UnterminatedFlowComment: _("Unterminated flow-comment.")
      })));
      function hasTypeImportKind(node) {
        return "type" === node.importKind || "typeof" === node.importKind;
      }
      function isMaybeDefaultImport(type) {
        return tokenIsKeywordOrIdentifier(type) && 97 !== type;
      }
      const exportSuggestions = {
        const: "declare export var",
        let: "declare export var",
        type: "export type",
        interface: "export interface"
      };
      const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
      const entities = {
        __proto__: null,
        quot: '"',
        amp: "&",
        apos: "'",
        lt: "<",
        gt: ">",
        nbsp: "",
        iexcl: "",
        cent: "",
        pound: "",
        curren: "",
        yen: "",
        brvbar: "",
        sect: "",
        uml: "",
        copy: "",
        ordf: "",
        laquo: "",
        not: "",
        shy: "",
        reg: "",
        macr: "",
        deg: "",
        plusmn: "",
        sup2: "",
        sup3: "",
        acute: "",
        micro: "",
        para: "",
        middot: "",
        cedil: "",
        sup1: "",
        ordm: "",
        raquo: "",
        frac14: "",
        frac12: "",
        frac34: "",
        iquest: "",
        Agrave: "",
        Aacute: "",
        Acirc: "",
        Atilde: "",
        Auml: "",
        Aring: "",
        AElig: "",
        Ccedil: "",
        Egrave: "",
        Eacute: "",
        Ecirc: "",
        Euml: "",
        Igrave: "",
        Iacute: "",
        Icirc: "",
        Iuml: "",
        ETH: "",
        Ntilde: "",
        Ograve: "",
        Oacute: "",
        Ocirc: "",
        Otilde: "",
        Ouml: "",
        times: "",
        Oslash: "",
        Ugrave: "",
        Uacute: "",
        Ucirc: "",
        Uuml: "",
        Yacute: "",
        THORN: "",
        szlig: "",
        agrave: "",
        aacute: "",
        acirc: "",
        atilde: "",
        auml: "",
        aring: "",
        aelig: "",
        ccedil: "",
        egrave: "",
        eacute: "",
        ecirc: "",
        euml: "",
        igrave: "",
        iacute: "",
        icirc: "",
        iuml: "",
        eth: "",
        ntilde: "",
        ograve: "",
        oacute: "",
        ocirc: "",
        otilde: "",
        ouml: "",
        divide: "",
        oslash: "",
        ugrave: "",
        uacute: "",
        ucirc: "",
        uuml: "",
        yacute: "",
        thorn: "",
        yuml: "",
        OElig: "",
        oelig: "",
        Scaron: "",
        scaron: "",
        Yuml: "",
        fnof: "",
        circ: "",
        tilde: "",
        Alpha: "",
        Beta: "",
        Gamma: "",
        Delta: "",
        Epsilon: "",
        Zeta: "",
        Eta: "",
        Theta: "",
        Iota: "",
        Kappa: "",
        Lambda: "",
        Mu: "",
        Nu: "",
        Xi: "",
        Omicron: "",
        Pi: "",
        Rho: "",
        Sigma: "",
        Tau: "",
        Upsilon: "",
        Phi: "",
        Chi: "",
        Psi: "",
        Omega: "",
        alpha: "",
        beta: "",
        gamma: "",
        delta: "",
        epsilon: "",
        zeta: "",
        eta: "",
        theta: "",
        iota: "",
        kappa: "",
        lambda: "",
        mu: "",
        nu: "",
        xi: "",
        omicron: "",
        pi: "",
        rho: "",
        sigmaf: "",
        sigma: "",
        tau: "",
        upsilon: "",
        phi: "",
        chi: "",
        psi: "",
        omega: "",
        thetasym: "",
        upsih: "",
        piv: "",
        ensp: "",
        emsp: "",
        thinsp: "",
        zwnj: "",
        zwj: "",
        lrm: "",
        rlm: "",
        ndash: "",
        mdash: "",
        lsquo: "",
        rsquo: "",
        sbquo: "",
        ldquo: "",
        rdquo: "",
        bdquo: "",
        dagger: "",
        Dagger: "",
        bull: "",
        hellip: "",
        permil: "",
        prime: "",
        Prime: "",
        lsaquo: "",
        rsaquo: "",
        oline: "",
        frasl: "",
        euro: "",
        image: "",
        weierp: "",
        real: "",
        trade: "",
        alefsym: "",
        larr: "",
        uarr: "",
        rarr: "",
        darr: "",
        harr: "",
        crarr: "",
        lArr: "",
        uArr: "",
        rArr: "",
        dArr: "",
        hArr: "",
        forall: "",
        part: "",
        exist: "",
        empty: "",
        nabla: "",
        isin: "",
        notin: "",
        ni: "",
        prod: "",
        sum: "",
        minus: "",
        lowast: "",
        radic: "",
        prop: "",
        infin: "",
        ang: "",
        and: "",
        or: "",
        cap: "",
        cup: "",
        int: "",
        there4: "",
        sim: "",
        cong: "",
        asymp: "",
        ne: "",
        equiv: "",
        le: "",
        ge: "",
        sub: "",
        sup: "",
        nsub: "",
        sube: "",
        supe: "",
        oplus: "",
        otimes: "",
        perp: "",
        sdot: "",
        lceil: "",
        rceil: "",
        lfloor: "",
        rfloor: "",
        lang: "",
        rang: "",
        loz: "",
        spades: "",
        clubs: "",
        hearts: "",
        diams: ""
      }, JsxErrors = ParseErrorEnum`jsx`((_ => ({
        AttributeIsEmpty: _("JSX attributes must only be assigned a non-empty expression."),
        MissingClosingTagElement: _((({openingTagName}) => `Expected corresponding JSX closing tag for <${openingTagName}>.`)),
        MissingClosingTagFragment: _("Expected corresponding JSX closing tag for <>."),
        UnexpectedSequenceExpression: _("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"),
        UnexpectedToken: _((({unexpected, HTMLEntity}) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`)),
        UnsupportedJsxValue: _("JSX value should be either an expression or a quoted JSX text."),
        UnterminatedJsxContent: _("Unterminated JSX contents."),
        UnwrappedAdjacentJSXElements: _("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?")
      })));
      function isFragment(object) {
        return !!object && ("JSXOpeningFragment" === object.type || "JSXClosingFragment" === object.type);
      }
      function getQualifiedJSXName(object) {
        if ("JSXIdentifier" === object.type) return object.name;
        if ("JSXNamespacedName" === object.type) return object.namespace.name + ":" + object.name.name;
        if ("JSXMemberExpression" === object.type) return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
        throw new Error("Node had unexpected type: " + object.type);
      }
      class TypeScriptScope extends Scope {
        constructor(...args) {
          super(...args), this.types = new Set, this.enums = new Set, this.constEnums = new Set, 
          this.classes = new Set, this.exportOnlyBindings = new Set;
        }
      }
      class TypeScriptScopeHandler extends ScopeHandler {
        createScope(flags) {
          return new TypeScriptScope(flags);
        }
        declareName(name, bindingType, loc) {
          const scope = this.currentScope();
          if (1024 & bindingType) return this.maybeExportDefined(scope, name), void scope.exportOnlyBindings.add(name);
          super.declareName(...arguments), 2 & bindingType && (1 & bindingType || (this.checkRedeclarationInScope(scope, name, bindingType, loc), 
          this.maybeExportDefined(scope, name)), scope.types.add(name)), 256 & bindingType && scope.enums.add(name), 
          512 & bindingType && scope.constEnums.add(name), 128 & bindingType && scope.classes.add(name);
        }
        isRedeclaredInScope(scope, name, bindingType) {
          if (scope.enums.has(name)) {
            if (256 & bindingType) {
              return !!(512 & bindingType) !== scope.constEnums.has(name);
            }
            return !0;
          }
          return 128 & bindingType && scope.classes.has(name) ? !!scope.lexical.has(name) && !!(1 & bindingType) : !!(2 & bindingType && scope.types.has(name)) || super.isRedeclaredInScope(...arguments);
        }
        checkLocalExport(id) {
          const topLevelScope = this.scopeStack[0], {name} = id;
          topLevelScope.types.has(name) || topLevelScope.exportOnlyBindings.has(name) || super.checkLocalExport(id);
        }
      }
      function assert(x) {
        if (!x) throw new Error("Assert fail");
      }
      const TSErrors = ParseErrorEnum`typescript`((_ => ({
        AbstractMethodHasImplementation: _((({methodName}) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`)),
        AbstractPropertyHasInitializer: _((({propertyName}) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`)),
        AccesorCannotDeclareThisParameter: _("'get' and 'set' accessors cannot declare 'this' parameters."),
        AccesorCannotHaveTypeParameters: _("An accessor cannot have type parameters."),
        CannotFindName: _((({name}) => `Cannot find name '${name}'.`)),
        ClassMethodHasDeclare: _("Class methods cannot have the 'declare' modifier."),
        ClassMethodHasReadonly: _("Class methods cannot have the 'readonly' modifier."),
        ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: _("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
        ConstructorHasTypeParameters: _("Type parameters cannot appear on a constructor declaration."),
        DeclareAccessor: _((({kind}) => `'declare' is not allowed in ${kind}ters.`)),
        DeclareClassFieldHasInitializer: _("Initializers are not allowed in ambient contexts."),
        DeclareFunctionHasImplementation: _("An implementation cannot be declared in ambient contexts."),
        DuplicateAccessibilityModifier: _((({modifier}) => "Accessibility modifier already seen.")),
        DuplicateModifier: _((({modifier}) => `Duplicate modifier: '${modifier}'.`)),
        EmptyHeritageClauseType: _((({token}) => `'${token}' list cannot be empty.`)),
        EmptyTypeArguments: _("Type argument list cannot be empty."),
        EmptyTypeParameters: _("Type parameter list cannot be empty."),
        ExpectedAmbientAfterExportDeclare: _("'export declare' must be followed by an ambient declaration."),
        ImportAliasHasImportType: _("An import alias can not use 'import type'."),
        IncompatibleModifiers: _((({modifiers}) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`)),
        IndexSignatureHasAbstract: _("Index signatures cannot have the 'abstract' modifier."),
        IndexSignatureHasAccessibility: _((({modifier}) => `Index signatures cannot have an accessibility modifier ('${modifier}').`)),
        IndexSignatureHasDeclare: _("Index signatures cannot have the 'declare' modifier."),
        IndexSignatureHasOverride: _("'override' modifier cannot appear on an index signature."),
        IndexSignatureHasStatic: _("Index signatures cannot have the 'static' modifier."),
        InitializerNotAllowedInAmbientContext: _("Initializers are not allowed in ambient contexts."),
        InvalidModifierOnTypeMember: _((({modifier}) => `'${modifier}' modifier cannot appear on a type member.`)),
        InvalidModifiersOrder: _((({orderedModifiers}) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`)),
        InvalidTupleMemberLabel: _("Tuple members must be labeled with a simple identifier."),
        MissingInterfaceName: _("'interface' declarations must be followed by an identifier."),
        MixedLabeledAndUnlabeledElements: _("Tuple members must all have names or all not have names."),
        NonAbstractClassHasAbstractMethod: _("Abstract methods can only appear within an abstract class."),
        NonClassMethodPropertyHasAbstractModifer: _("'abstract' modifier can only appear on a class, method, or property declaration."),
        OptionalTypeBeforeRequired: _("A required element cannot follow an optional element."),
        OverrideNotInSubClass: _("This member cannot have an 'override' modifier because its containing class does not extend another class."),
        PatternIsOptional: _("A binding pattern parameter cannot be optional in an implementation signature."),
        PrivateElementHasAbstract: _("Private elements cannot have the 'abstract' modifier."),
        PrivateElementHasAccessibility: _((({modifier}) => `Private elements cannot have an accessibility modifier ('${modifier}').`)),
        ReadonlyForMethodSignature: _("'readonly' modifier can only appear on a property declaration or index signature."),
        ReservedArrowTypeParam: _("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."),
        ReservedTypeAssertion: _("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
        SetAccesorCannotHaveOptionalParameter: _("A 'set' accessor cannot have an optional parameter."),
        SetAccesorCannotHaveRestParameter: _("A 'set' accessor cannot have rest parameter."),
        SetAccesorCannotHaveReturnType: _("A 'set' accessor cannot have a return type annotation."),
        SingleTypeParameterWithoutTrailingComma: _((({typeParameterName}) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`)),
        StaticBlockCannotHaveModifier: _("Static class blocks cannot have any modifier."),
        TypeAnnotationAfterAssign: _("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."),
        TypeImportCannotSpecifyDefaultAndNamed: _("A type-only import can specify a default import or named bindings, but not both."),
        TypeModifierIsUsedInTypeExports: _("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
        TypeModifierIsUsedInTypeImports: _("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
        UnexpectedParameterModifier: _("A parameter property is only allowed in a constructor implementation."),
        UnexpectedReadonly: _("'readonly' type modifier is only permitted on array and tuple literal types."),
        UnexpectedTypeAnnotation: _("Did not expect a type annotation here."),
        UnexpectedTypeCastInParameter: _("Unexpected type cast in parameter position."),
        UnsupportedImportTypeArgument: _("Argument in a type import must be a string literal."),
        UnsupportedParameterPropertyKind: _("A parameter property may not be declared using a binding pattern."),
        UnsupportedSignatureParameterKind: _((({type}) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`))
      })));
      function tsIsAccessModifier(modifier) {
        return "private" === modifier || "public" === modifier || "protected" === modifier;
      }
      function isPossiblyLiteralEnum(expression) {
        if ("MemberExpression" !== expression.type) return !1;
        const {computed, property} = expression;
        return (!computed || "StringLiteral" === property.type || !("TemplateLiteral" !== property.type || property.expressions.length > 0)) && isUncomputedMemberExpressionChain(expression.object);
      }
      function isUncomputedMemberExpressionChain(expression) {
        return "Identifier" === expression.type || "MemberExpression" === expression.type && (!expression.computed && isUncomputedMemberExpressionChain(expression.object));
      }
      const PlaceholderErrors = ParseErrorEnum`placeholders`((_ => ({
        ClassNameIsRequired: _("A class name is required."),
        UnexpectedSpace: _("Unexpected space in placeholder.")
      })));
      function hasPlugin(plugins, expectedConfig) {
        const [expectedName, expectedOptions] = "string" == typeof expectedConfig ? [ expectedConfig, {} ] : expectedConfig, expectedKeys = Object.keys(expectedOptions), expectedOptionsIsEmpty = 0 === expectedKeys.length;
        return plugins.some((p => {
          if ("string" == typeof p) return expectedOptionsIsEmpty && p === expectedName;
          {
            const [pluginName, pluginOptions] = p;
            if (pluginName !== expectedName) return !1;
            for (const key of expectedKeys) if (pluginOptions[key] !== expectedOptions[key]) return !1;
            return !0;
          }
        }));
      }
      function getPluginOption(plugins, name, option) {
        const plugin = plugins.find((plugin => Array.isArray(plugin) ? plugin[0] === name : plugin === name));
        return plugin && Array.isArray(plugin) ? plugin[1][option] : null;
      }
      const PIPELINE_PROPOSALS = [ "minimal", "fsharp", "hack", "smart" ], TOPIC_TOKENS = [ "^^", "@@", "^", "%", "#" ], RECORD_AND_TUPLE_SYNTAX_TYPES = [ "hash", "bar" ];
      const mixinPlugins = {
        estree: superClass => class extends superClass {
          parse() {
            const file = toESTreeLocation(super.parse());
            return this.options.tokens && (file.tokens = file.tokens.map(toESTreeLocation)), 
            file;
          }
          parseRegExpLiteral({pattern, flags}) {
            let regex = null;
            try {
              regex = new RegExp(pattern, flags);
            } catch (e) {}
            const node = this.estreeParseLiteral(regex);
            return node.regex = {
              pattern,
              flags
            }, node;
          }
          parseBigIntLiteral(value) {
            let bigInt;
            try {
              bigInt = BigInt(value);
            } catch (_unused) {
              bigInt = null;
            }
            const node = this.estreeParseLiteral(bigInt);
            return node.bigint = String(node.value || value), node;
          }
          parseDecimalLiteral(value) {
            const node = this.estreeParseLiteral(null);
            return node.decimal = String(node.value || value), node;
          }
          estreeParseLiteral(value) {
            return this.parseLiteral(value, "Literal");
          }
          parseStringLiteral(value) {
            return this.estreeParseLiteral(value);
          }
          parseNumericLiteral(value) {
            return this.estreeParseLiteral(value);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(value) {
            return this.estreeParseLiteral(value);
          }
          directiveToStmt(directive) {
            const directiveLiteral = directive.value, stmt = this.startNodeAt(directive.start, directive.loc.start), expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
            return expression.value = directiveLiteral.extra.expressionValue, expression.raw = directiveLiteral.extra.raw, 
            stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.loc.end), 
            stmt.directive = directiveLiteral.extra.raw.slice(1, -1), this.finishNodeAt(stmt, "ExpressionStatement", directive.loc.end);
          }
          initFunction(node, isAsync) {
            super.initFunction(node, isAsync), node.expression = !1;
          }
          checkDeclaration(node) {
            null != node && this.isObjectProperty(node) ? this.checkDeclaration(node.value) : super.checkDeclaration(node);
          }
          getObjectOrClassMethodParams(method) {
            return method.value.params;
          }
          isValidDirective(stmt) {
            var _stmt$expression$extr;
            return "ExpressionStatement" === stmt.type && "Literal" === stmt.expression.type && "string" == typeof stmt.expression.value && !(null != (_stmt$expression$extr = stmt.expression.extra) && _stmt$expression$extr.parenthesized);
          }
          parseBlockBody(node, ...args) {
            super.parseBlockBody(node, ...args);
            const directiveStatements = node.directives.map((d => this.directiveToStmt(d)));
            node.body = directiveStatements.concat(node.body), delete node.directives;
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0), 
            method.typeParameters && (method.value.typeParameters = method.typeParameters, delete method.typeParameters), 
            classBody.body.push(method);
          }
          parsePrivateName() {
            const node = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(node) : node;
          }
          convertPrivateNameToPrivateIdentifier(node) {
            const name = super.getPrivateNameSV(node);
            return delete (node = node).id, node.name = name, node.type = "PrivateIdentifier", 
            node;
          }
          isPrivateName(node) {
            return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === node.type : super.isPrivateName(node);
          }
          getPrivateNameSV(node) {
            return this.getPluginOption("estree", "classFeatures") ? node.name : super.getPrivateNameSV(node);
          }
          parseLiteral(value, type) {
            const node = super.parseLiteral(value, type);
            return node.raw = node.extra.raw, delete node.extra, node;
          }
          parseFunctionBody(node, allowExpression, isMethod = !1) {
            super.parseFunctionBody(node, allowExpression, isMethod), node.expression = "BlockStatement" !== node.body.type;
          }
          parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = !1) {
            let funcNode = this.startNode();
            return funcNode.kind = node.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope), 
            funcNode.type = "FunctionExpression", delete funcNode.kind, node.value = funcNode, 
            "ClassPrivateMethod" === type && (node.computed = !1), type = "MethodDefinition", 
            this.finishNode(node, type);
          }
          parseClassProperty(...args) {
            const propertyNode = super.parseClassProperty(...args);
            return this.getPluginOption("estree", "classFeatures") ? (propertyNode.type = "PropertyDefinition", 
            propertyNode) : propertyNode;
          }
          parseClassPrivateProperty(...args) {
            const propertyNode = super.parseClassPrivateProperty(...args);
            return this.getPluginOption("estree", "classFeatures") ? (propertyNode.type = "PropertyDefinition", 
            propertyNode.computed = !1, propertyNode) : propertyNode;
          }
          parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
            const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
            return node && (node.type = "Property", "method" === node.kind && (node.kind = "init"), 
            node.shorthand = !1), node;
          }
          parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
            const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
            return node && (node.kind = "init", node.type = "Property"), node;
          }
          isValidLVal(type, ...rest) {
            return "Property" === type ? "value" : super.isValidLVal(type, ...rest);
          }
          isAssignable(node, isBinding) {
            return null != node && this.isObjectProperty(node) ? this.isAssignable(node.value, isBinding) : super.isAssignable(node, isBinding);
          }
          toAssignable(node, isLHS = !1) {
            if (null != node && this.isObjectProperty(node)) {
              const {key, value} = node;
              return this.isPrivateName(key) && this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start), 
              this.toAssignable(value, isLHS), node;
            }
            return super.toAssignable(node, isLHS);
          }
          toAssignableObjectExpressionProp(prop, ...args) {
            "get" === prop.kind || "set" === prop.kind ? this.raise(Errors.PatternHasAccessor, {
              at: prop.key
            }) : prop.method ? this.raise(Errors.PatternHasMethod, {
              at: prop.key
            }) : super.toAssignableObjectExpressionProp(prop, ...args);
          }
          finishCallExpression(node, optional) {
            if (super.finishCallExpression(node, optional), "Import" === node.callee.type) {
              var _node$arguments$;
              if (node.type = "ImportExpression", node.source = node.arguments[0], this.hasPlugin("importAssertions")) node.attributes = null != (_node$arguments$ = node.arguments[1]) ? _node$arguments$ : null;
              delete node.arguments, delete node.callee;
            }
            return node;
          }
          toReferencedArguments(node) {
            "ImportExpression" !== node.type && super.toReferencedArguments(node);
          }
          parseExport(node) {
            switch (super.parseExport(node), node.type) {
             case "ExportAllDeclaration":
              node.exported = null;
              break;

             case "ExportNamedDeclaration":
              1 === node.specifiers.length && "ExportNamespaceSpecifier" === node.specifiers[0].type && (node.type = "ExportAllDeclaration", 
              node.exported = node.specifiers[0].exported, delete node.specifiers);
            }
            return node;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);
            if (state.optionalChainMember) {
              if ("OptionalMemberExpression" !== node.type && "OptionalCallExpression" !== node.type || (node.type = node.type.substring(8)), 
              state.stop) {
                const chain = this.startNodeAtNode(node);
                return chain.expression = node, this.finishNode(chain, "ChainExpression");
              }
            } else "MemberExpression" !== node.type && "CallExpression" !== node.type || (node.optional = !1);
            return node;
          }
          hasPropertyAsPrivateName(node) {
            return "ChainExpression" === node.type && (node = node.expression), super.hasPropertyAsPrivateName(node);
          }
          isOptionalChain(node) {
            return "ChainExpression" === node.type;
          }
          isObjectProperty(node) {
            return "Property" === node.type && "init" === node.kind && !node.method;
          }
          isObjectMethod(node) {
            return node.method || "get" === node.kind || "set" === node.kind;
          }
          finishNodeAt(node, type, endLoc) {
            return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
          }
          resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
            super.resetEndLocation(node, endLoc), toESTreeLocation(node);
          }
        },
        jsx: superClass => class extends superClass {
          jsxReadToken() {
            let out = "", chunkStart = this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length) throw this.raise(JsxErrors.UnterminatedJsxContent, {
                at: this.state.startLoc
              });
              const ch = this.input.charCodeAt(this.state.pos);
              switch (ch) {
               case 60:
               case 123:
                return this.state.pos === this.state.start ? 60 === ch && this.state.canStartJSXElement ? (++this.state.pos, 
                this.finishToken(138)) : super.getTokenFromCode(ch) : (out += this.input.slice(chunkStart, this.state.pos), 
                this.finishToken(137, out));

               case 38:
                out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), 
                chunkStart = this.state.pos;
                break;

               default:
                isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!0), 
                chunkStart = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(normalizeCRLF) {
            const ch = this.input.charCodeAt(this.state.pos);
            let out;
            return ++this.state.pos, 13 === ch && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, 
            out = normalizeCRLF ? "\n" : "\r\n") : out = String.fromCharCode(ch), ++this.state.curLine, 
            this.state.lineStart = this.state.pos, out;
          }
          jsxReadString(quote) {
            let out = "", chunkStart = ++this.state.pos;
            for (;;) {
              if (this.state.pos >= this.length) throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
              const ch = this.input.charCodeAt(this.state.pos);
              if (ch === quote) break;
              38 === ch ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), 
              chunkStart = this.state.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), 
              out += this.jsxReadNewLine(!1), chunkStart = this.state.pos) : ++this.state.pos;
            }
            return out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(129, out);
          }
          jsxReadEntity() {
            const startPos = ++this.state.pos;
            if (35 === this.codePointAtPos(this.state.pos)) {
              ++this.state.pos;
              let radix = 10;
              120 === this.codePointAtPos(this.state.pos) && (radix = 16, ++this.state.pos);
              const codePoint = this.readInt(radix, void 0, !1, "bail");
              if (null !== codePoint && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, 
              String.fromCodePoint(codePoint);
            } else {
              let count = 0, semi = !1;
              for (;count++ < 10 && this.state.pos < this.length && !(semi = 59 == this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
              if (semi) {
                const desc = this.input.slice(startPos, this.state.pos), entity = entities[desc];
                if (++this.state.pos, entity) return entity;
              }
            }
            return this.state.pos = startPos, "&";
          }
          jsxReadWord() {
            let ch;
            const start = this.state.pos;
            do {
              ch = this.input.charCodeAt(++this.state.pos);
            } while (isIdentifierChar(ch) || 45 === ch);
            return this.finishToken(136, this.input.slice(start, this.state.pos));
          }
          jsxParseIdentifier() {
            const node = this.startNode();
            return this.match(136) ? node.name = this.state.value : tokenIsKeyword(this.state.type) ? node.name = tokenLabelName(this.state.type) : this.unexpected(), 
            this.next(), this.finishNode(node, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const startPos = this.state.start, startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
            if (!this.eat(14)) return name;
            const node = this.startNodeAt(startPos, startLoc);
            return node.namespace = name, node.name = this.jsxParseIdentifier(), this.finishNode(node, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let node = this.jsxParseNamespacedName();
            if ("JSXNamespacedName" === node.type) return node;
            for (;this.eat(16); ) {
              const newNode = this.startNodeAt(startPos, startLoc);
              newNode.object = node, newNode.property = this.jsxParseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
            }
            return node;
          }
          jsxParseAttributeValue() {
            let node;
            switch (this.state.type) {
             case 5:
              return node = this.startNode(), this.setContext(types.brace), this.next(), node = this.jsxParseExpressionContainer(node, types.j_oTag), 
              "JSXEmptyExpression" === node.expression.type && this.raise(JsxErrors.AttributeIsEmpty, {
                at: node
              }), node;

             case 138:
             case 129:
              return this.parseExprAtom();

             default:
              throw this.raise(JsxErrors.UnsupportedJsxValue, {
                at: this.state.startLoc
              });
            }
          }
          jsxParseEmptyExpression() {
            const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
            return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(node) {
            return this.next(), node.expression = this.parseExpression(), this.setContext(types.j_oTag), 
            this.expect(8), this.finishNode(node, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(node, previousContext) {
            if (this.match(8)) node.expression = this.jsxParseEmptyExpression(); else {
              const expression = this.parseExpression();
              node.expression = expression;
            }
            return this.setContext(previousContext), this.expect(8), this.finishNode(node, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const node = this.startNode();
            return this.match(5) ? (this.setContext(types.brace), this.next(), this.expect(21), 
            node.argument = this.parseMaybeAssignAllowIn(), this.setContext(types.j_oTag), this.expect(8), 
            this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsxParseNamespacedName(), 
            node.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            return this.match(139) ? (this.expect(139), this.finishNode(node, "JSXOpeningFragment")) : (node.name = this.jsxParseElementName(), 
            this.jsxParseOpeningElementAfterName(node));
          }
          jsxParseOpeningElementAfterName(node) {
            const attributes = [];
            for (;!this.match(56) && !this.match(139); ) attributes.push(this.jsxParseAttribute());
            return node.attributes = attributes, node.selfClosing = this.eat(56), this.expect(139), 
            this.finishNode(node, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            return this.match(139) ? (this.expect(139), this.finishNode(node, "JSXClosingFragment")) : (node.name = this.jsxParseElementName(), 
            this.expect(139), this.finishNode(node, "JSXClosingElement"));
          }
          jsxParseElementAt(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
            let closingElement = null;
            if (!openingElement.selfClosing) {
              contents: for (;;) switch (this.state.type) {
               case 138:
                if (startPos = this.state.start, startLoc = this.state.startLoc, this.next(), this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;

               case 137:
                children.push(this.parseExprAtom());
                break;

               case 5:
                {
                  const node = this.startNode();
                  this.setContext(types.brace), this.next(), this.match(21) ? children.push(this.jsxParseSpreadChild(node)) : children.push(this.jsxParseExpressionContainer(node, types.j_expr));
                  break;
                }

               default:
                throw this.unexpected();
              }
              isFragment(openingElement) && !isFragment(closingElement) && null !== closingElement ? this.raise(JsxErrors.MissingClosingTagFragment, {
                at: closingElement
              }) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              }) : isFragment(openingElement) || isFragment(closingElement) || getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(JsxErrors.MissingClosingTagElement, {
                at: closingElement,
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
            if (isFragment(openingElement) ? (node.openingFragment = openingElement, node.closingFragment = closingElement) : (node.openingElement = openingElement, 
            node.closingElement = closingElement), node.children = children, this.match(47)) throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
              at: this.state.startLoc
            });
            return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
          }
          jsxParseElement() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(startPos, startLoc);
          }
          setContext(newContext) {
            const {context} = this.state;
            context[context.length - 1] = newContext;
          }
          parseExprAtom(refExpressionErrors) {
            return this.match(137) ? this.parseLiteral(this.state.value, "JSXText") : this.match(138) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(138), 
            this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(code) {
            const context = this.curContext();
            if (context === types.j_expr) return this.jsxReadToken();
            if (context === types.j_oTag || context === types.j_cTag) {
              if (isIdentifierStart(code)) return this.jsxReadWord();
              if (62 === code) return ++this.state.pos, this.finishToken(139);
              if ((34 === code || 39 === code) && context === types.j_oTag) return this.jsxReadString(code);
            }
            return 60 === code && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, 
            this.finishToken(138)) : super.getTokenFromCode(code);
          }
          updateContext(prevType) {
            const {context, type} = this.state;
            if (56 === type && 138 === prevType) context.splice(-2, 2, types.j_cTag), this.state.canStartJSXElement = !1; else if (138 === type) context.push(types.j_oTag); else if (139 === type) {
              const out = context[context.length - 1];
              out === types.j_oTag && 56 === prevType || out === types.j_cTag ? (context.pop(), 
              this.state.canStartJSXElement = context[context.length - 1] === types.j_expr) : (this.setContext(types.j_expr), 
              this.state.canStartJSXElement = !0);
            } else this.state.canStartJSXElement = tokenBeforeExprs[type];
          }
        },
        flow: superClass => class extends superClass {
          constructor(...args) {
            super(...args), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return FlowScopeHandler;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(type, val) {
            return 129 !== type && 13 !== type && 28 !== type && void 0 === this.flowPragma && (this.flowPragma = null), 
            super.finishToken(type, val);
          }
          addComment(comment) {
            if (void 0 === this.flowPragma) {
              const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
              if (matches) if ("flow" === matches[1]) this.flowPragma = "flow"; else {
                if ("noflow" !== matches[1]) throw new Error("Unexpected flow pragma");
                this.flowPragma = "noflow";
              } else ;
            }
            return super.addComment(comment);
          }
          flowParseTypeInitialiser(tok) {
            const oldInType = this.state.inType;
            this.state.inType = !0, this.expect(tok || 14);
            const type = this.flowParseType();
            return this.state.inType = oldInType, type;
          }
          flowParsePredicate() {
            const node = this.startNode(), moduloLoc = this.state.startLoc;
            return this.next(), this.expectContextual(107), this.state.lastTokStart > moduloLoc.index + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
              at: moduloLoc
            }), this.eat(10) ? (node.value = this.parseExpression(), this.expect(11), this.finishNode(node, "DeclaredPredicate")) : this.finishNode(node, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const oldInType = this.state.inType;
            this.state.inType = !0, this.expect(14);
            let type = null, predicate = null;
            return this.match(54) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type = this.flowParseType(), 
            this.state.inType = oldInType, this.match(54) && (predicate = this.flowParsePredicate())), 
            [ type, predicate ];
          }
          flowParseDeclareClass(node) {
            return this.next(), this.flowParseInterfaceish(node, !0), this.finishNode(node, "DeclareClass");
          }
          flowParseDeclareFunction(node) {
            this.next();
            const id = node.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
            this.match(47) ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, 
            this.expect(10);
            const tmp = this.flowParseFunctionTypeParams();
            return typeNode.params = tmp.params, typeNode.rest = tmp.rest, typeNode.this = tmp._this, 
            this.expect(11), [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), 
            typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), 
            id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), 
            this.semicolon(), this.scope.declareName(node.id.name, 2048, node.id.loc.start), 
            this.finishNode(node, "DeclareFunction");
          }
          flowParseDeclare(node, insideModule) {
            if (this.match(80)) return this.flowParseDeclareClass(node);
            if (this.match(68)) return this.flowParseDeclareFunction(node);
            if (this.match(74)) return this.flowParseDeclareVariable(node);
            if (this.eatContextual(123)) return this.match(16) ? this.flowParseDeclareModuleExports(node) : (insideModule && this.raise(FlowErrors.NestedDeclareModule, {
              at: this.state.lastTokStartLoc
            }), this.flowParseDeclareModule(node));
            if (this.isContextual(126)) return this.flowParseDeclareTypeAlias(node);
            if (this.isContextual(127)) return this.flowParseDeclareOpaqueType(node);
            if (this.isContextual(125)) return this.flowParseDeclareInterface(node);
            if (this.match(82)) return this.flowParseDeclareExportDeclaration(node, insideModule);
            throw this.unexpected();
          }
          flowParseDeclareVariable(node) {
            return this.next(), node.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(node.id.name, 5, node.id.loc.start), 
            this.semicolon(), this.finishNode(node, "DeclareVariable");
          }
          flowParseDeclareModule(node) {
            this.scope.enter(0), this.match(129) ? node.id = this.parseExprAtom() : node.id = this.parseIdentifier();
            const bodyNode = node.body = this.startNode(), body = bodyNode.body = [];
            for (this.expect(5); !this.match(8); ) {
              let bodyNode = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(126) || this.match(87) || this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
                at: this.state.lastTokStartLoc
              }), this.parseImport(bodyNode)) : (this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule), 
              bodyNode = this.flowParseDeclare(bodyNode, !0)), body.push(bodyNode);
            }
            this.scope.exit(), this.expect(8), this.finishNode(bodyNode, "BlockStatement");
            let kind = null, hasModuleExport = !1;
            return body.forEach((bodyElement => {
              !function(bodyElement) {
                return "DeclareExportAllDeclaration" === bodyElement.type || "DeclareExportDeclaration" === bodyElement.type && (!bodyElement.declaration || "TypeAlias" !== bodyElement.declaration.type && "InterfaceDeclaration" !== bodyElement.declaration.type);
              }(bodyElement) ? "DeclareModuleExports" === bodyElement.type && (hasModuleExport && this.raise(FlowErrors.DuplicateDeclareModuleExports, {
                at: bodyElement
              }), "ES" === kind && this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                at: bodyElement
              }), kind = "CommonJS", hasModuleExport = !0) : ("CommonJS" === kind && this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
                at: bodyElement
              }), kind = "ES");
            })), node.kind = kind || "CommonJS", this.finishNode(node, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(node, insideModule) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? node.declaration = this.flowParseDeclare(this.startNode()) : (node.declaration = this.flowParseType(), 
            this.semicolon()), node.default = !0, this.finishNode(node, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {
              const label = this.state.value;
              throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
                at: this.state.startLoc,
                unsupportedExportKind: label,
                suggestion: exportSuggestions[label]
              });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) return node.declaration = this.flowParseDeclare(this.startNode()), 
            node.default = !1, this.finishNode(node, "DeclareExportDeclaration");
            if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) return "ExportNamedDeclaration" === (node = this.parseExport(node)).type && (node.type = "ExportDeclaration", 
            node.default = !1, delete node.exportKind), node.type = "Declare" + node.type, node;
            throw this.unexpected();
          }
          flowParseDeclareModuleExports(node) {
            return this.next(), this.expectContextual(108), node.typeAnnotation = this.flowParseTypeAnnotation(), 
            this.semicolon(), this.finishNode(node, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(node) {
            return this.next(), this.flowParseTypeAlias(node), node.type = "DeclareTypeAlias", 
            node;
          }
          flowParseDeclareOpaqueType(node) {
            return this.next(), this.flowParseOpaqueType(node, !0), node.type = "DeclareOpaqueType", 
            node;
          }
          flowParseDeclareInterface(node) {
            return this.next(), this.flowParseInterfaceish(node), this.finishNode(node, "DeclareInterface");
          }
          flowParseInterfaceish(node, isClass = !1) {
            if (node.id = this.flowParseRestrictedIdentifier(!isClass, !0), this.scope.declareName(node.id.name, isClass ? 17 : 9, node.id.loc.start), 
            this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, 
            node.extends = [], node.implements = [], node.mixins = [], this.eat(81)) do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (!isClass && this.eat(12));
            if (this.isContextual(114)) {
              this.next();
              do {
                node.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            if (this.isContextual(110)) {
              this.next();
              do {
                node.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            node.body = this.flowParseObjectType({
              allowStatic: isClass,
              allowExact: !1,
              allowSpread: !1,
              allowProto: isClass,
              allowInexact: !1
            });
          }
          flowParseInterfaceExtends() {
            const node = this.startNode();
            return node.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, 
            this.finishNode(node, "InterfaceExtends");
          }
          flowParseInterface(node) {
            return this.flowParseInterfaceish(node), this.finishNode(node, "InterfaceDeclaration");
          }
          checkNotUnderscore(word) {
            "_" === word && this.raise(FlowErrors.UnexpectedReservedUnderscore, {
              at: this.state.startLoc
            });
          }
          checkReservedType(word, startLoc, declaration) {
            reservedTypes.has(word) && this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
              at: startLoc,
              reservedType: word
            });
          }
          flowParseRestrictedIdentifier(liberal, declaration) {
            return this.checkReservedType(this.state.value, this.state.startLoc, declaration), 
            this.parseIdentifier(liberal);
          }
          flowParseTypeAlias(node) {
            return node.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(node.id.name, 9, node.id.loc.start), 
            this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, 
            node.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(node, "TypeAlias");
          }
          flowParseOpaqueType(node, declare) {
            return this.expectContextual(126), node.id = this.flowParseRestrictedIdentifier(!0, !0), 
            this.scope.declareName(node.id.name, 9, node.id.loc.start), this.match(47) ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, 
            node.supertype = null, this.match(14) && (node.supertype = this.flowParseTypeInitialiser(14)), 
            node.impltype = null, declare || (node.impltype = this.flowParseTypeInitialiser(29)), 
            this.semicolon(), this.finishNode(node, "OpaqueType");
          }
          flowParseTypeParameter(requireDefault = !1) {
            const nodeStartLoc = this.state.startLoc, node = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
            return node.name = ident.name, node.variance = variance, node.bound = ident.typeAnnotation, 
            this.match(29) ? (this.eat(29), node.default = this.flowParseType()) : requireDefault && this.raise(FlowErrors.MissingTypeParamDefault, {
              at: nodeStartLoc
            }), this.finishNode(node, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const oldInType = this.state.inType, node = this.startNode();
            node.params = [], this.state.inType = !0, this.match(47) || this.match(138) ? this.next() : this.unexpected();
            let defaultRequired = !1;
            do {
              const typeParameter = this.flowParseTypeParameter(defaultRequired);
              node.params.push(typeParameter), typeParameter.default && (defaultRequired = !0), 
              this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const node = this.startNode(), oldInType = this.state.inType;
            node.params = [], this.state.inType = !0, this.expect(47);
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = !1; !this.match(48); ) node.params.push(this.flowParseType()), 
            this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = oldNoAnonFunctionType, this.expect(48), this.state.inType = oldInType, 
            this.finishNode(node, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const node = this.startNode(), oldInType = this.state.inType;
            for (node.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) node.params.push(this.flowParseTypeOrImplicitInstantiation()), 
            this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const node = this.startNode();
            if (this.expectContextual(125), node.extends = [], this.eat(81)) do {
              node.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
            return node.body = this.flowParseObjectType({
              allowStatic: !1,
              allowExact: !1,
              allowSpread: !1,
              allowProto: !1,
              allowInexact: !1
            }), this.finishNode(node, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(node, isStatic, variance) {
            return node.static = isStatic, 14 === this.lookahead().type ? (node.id = this.flowParseObjectPropertyKey(), 
            node.key = this.flowParseTypeInitialiser()) : (node.id = null, node.key = this.flowParseType()), 
            this.expect(3), node.value = this.flowParseTypeInitialiser(), node.variance = variance, 
            this.finishNode(node, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(node, isStatic) {
            return node.static = isStatic, node.id = this.flowParseObjectPropertyKey(), this.expect(3), 
            this.expect(3), this.match(47) || this.match(10) ? (node.method = !0, node.optional = !1, 
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start))) : (node.method = !1, 
            this.eat(17) && (node.optional = !0), node.value = this.flowParseTypeInitialiser()), 
            this.finishNode(node, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(node) {
            for (node.params = [], node.rest = null, node.typeParameters = null, node.this = null, 
            this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), 
            this.expect(10), this.match(78) && (node.this = this.flowParseFunctionTypeParam(!0), 
            node.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) node.params.push(this.flowParseFunctionTypeParam(!1)), 
            this.match(11) || this.expect(12);
            return this.eat(21) && (node.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), 
            node.returnType = this.flowParseTypeInitialiser(), this.finishNode(node, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(node, isStatic) {
            const valueNode = this.startNode();
            return node.static = isStatic, node.value = this.flowParseObjectTypeMethodish(valueNode), 
            this.finishNode(node, "ObjectTypeCallProperty");
          }
          flowParseObjectType({allowStatic, allowExact, allowSpread, allowProto, allowInexact}) {
            const oldInType = this.state.inType;
            this.state.inType = !0;
            const nodeStart = this.startNode();
            let endDelim, exact;
            nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], 
            nodeStart.internalSlots = [];
            let inexact = !1;
            for (allowExact && this.match(6) ? (this.expect(6), endDelim = 9, exact = !0) : (this.expect(5), 
            endDelim = 8, exact = !1), nodeStart.exact = exact; !this.match(endDelim); ) {
              let isStatic = !1, protoStartLoc = null, inexactStartLoc = null;
              const node = this.startNode();
              if (allowProto && this.isContextual(115)) {
                const lookahead = this.lookahead();
                14 !== lookahead.type && 17 !== lookahead.type && (this.next(), protoStartLoc = this.state.startLoc, 
                allowStatic = !1);
              }
              if (allowStatic && this.isContextual(104)) {
                const lookahead = this.lookahead();
                14 !== lookahead.type && 17 !== lookahead.type && (this.next(), isStatic = !0);
              }
              const variance = this.flowParseVariance();
              if (this.eat(0)) null != protoStartLoc && this.unexpected(protoStartLoc), this.eat(0) ? (variance && this.unexpected(variance.loc.start), 
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance)); else if (this.match(10) || this.match(47)) null != protoStartLoc && this.unexpected(protoStartLoc), 
              variance && this.unexpected(variance.loc.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic)); else {
                let kind = "init";
                if (this.isContextual(98) || this.isContextual(103)) {
                  tokenIsLiteralPropertyName(this.lookahead().type) && (kind = this.state.value, this.next());
                }
                const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, null != allowInexact ? allowInexact : !exact);
                null === propOrInexact ? (inexact = !0, inexactStartLoc = this.state.lastTokStartLoc) : nodeStart.properties.push(propOrInexact);
              }
              this.flowObjectTypeSemicolon(), !inexactStartLoc || this.match(8) || this.match(9) || this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
                at: inexactStartLoc
              });
            }
            this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
            const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
            return this.state.inType = oldInType, out;
          }
          flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
            if (this.eat(21)) {
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (allowSpread ? allowInexact || this.raise(FlowErrors.InexactInsideExact, {
                at: this.state.lastTokStartLoc
              }) : this.raise(FlowErrors.InexactInsideNonObject, {
                at: this.state.lastTokStartLoc
              }), variance && this.raise(FlowErrors.InexactVariance, {
                at: variance
              }), null) : (allowSpread || this.raise(FlowErrors.UnexpectedSpreadType, {
                at: this.state.lastTokStartLoc
              }), null != protoStartLoc && this.unexpected(protoStartLoc), variance && this.raise(FlowErrors.SpreadVariance, {
                at: variance
              }), node.argument = this.flowParseType(), this.finishNode(node, "ObjectTypeSpreadProperty"));
            }
            {
              node.key = this.flowParseObjectPropertyKey(), node.static = isStatic, node.proto = null != protoStartLoc, 
              node.kind = kind;
              let optional = !1;
              return this.match(47) || this.match(10) ? (node.method = !0, null != protoStartLoc && this.unexpected(protoStartLoc), 
              variance && this.unexpected(variance.loc.start), node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start)), 
              "get" !== kind && "set" !== kind || this.flowCheckGetterSetterParams(node), !allowSpread && "constructor" === node.key.name && node.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: node.value.this
              })) : ("init" !== kind && this.unexpected(), node.method = !1, this.eat(17) && (optional = !0), 
              node.value = this.flowParseTypeInitialiser(), node.variance = variance), node.optional = optional, 
              this.finishNode(node, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(property) {
            const paramCount = "get" === property.kind ? 0 : 1, length = property.value.params.length + (property.value.rest ? 1 : 0);
            property.value.this && this.raise("get" === property.kind ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
              at: property.value.this
            }), length !== paramCount && this.raise("get" === property.kind ? Errors.BadGetterArity : Errors.BadSetterArity, {
              at: property
            }), "set" === property.kind && property.value.rest && this.raise(Errors.BadSetterRestParameter, {
              at: property
            });
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
            startPos = startPos || this.state.start, startLoc = startLoc || this.state.startLoc;
            let node = id || this.flowParseRestrictedIdentifier(!0);
            for (;this.eat(16); ) {
              const node2 = this.startNodeAt(startPos, startLoc);
              node2.qualification = node, node2.id = this.flowParseRestrictedIdentifier(!0), node = this.finishNode(node2, "QualifiedTypeIdentifier");
            }
            return node;
          }
          flowParseGenericType(startPos, startLoc, id) {
            const node = this.startNodeAt(startPos, startLoc);
            return node.typeParameters = null, node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id), 
            this.match(47) && (node.typeParameters = this.flowParseTypeParameterInstantiation()), 
            this.finishNode(node, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const node = this.startNode();
            return this.expect(87), node.argument = this.flowParsePrimaryType(), this.finishNode(node, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const node = this.startNode();
            for (node.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (node.types.push(this.flowParseType()), 
            !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(node, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(first) {
            let name = null, optional = !1, typeAnnotation = null;
            const node = this.startNode(), lh = this.lookahead(), isThis = 78 === this.state.type;
            return 14 === lh.type || 17 === lh.type ? (isThis && !first && this.raise(FlowErrors.ThisParamMustBeFirst, {
              at: node
            }), name = this.parseIdentifier(isThis), this.eat(17) && (optional = !0, isThis && this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              at: node
            })), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), 
            node.name = name, node.optional = optional, node.typeAnnotation = typeAnnotation, 
            this.finishNode(node, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(type) {
            const node = this.startNodeAt(type.start, type.loc.start);
            return node.name = null, node.optional = !1, node.typeAnnotation = type, this.finishNode(node, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(params = []) {
            let rest = null, _this = null;
            for (this.match(78) && (_this = this.flowParseFunctionTypeParam(!0), _this.name = null, 
            this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) params.push(this.flowParseFunctionTypeParam(!1)), 
            this.match(11) || this.expect(12);
            return this.eat(21) && (rest = this.flowParseFunctionTypeParam(!1)), {
              params,
              rest,
              _this
            };
          }
          flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
            switch (id.name) {
             case "any":
              return this.finishNode(node, "AnyTypeAnnotation");

             case "bool":
             case "boolean":
              return this.finishNode(node, "BooleanTypeAnnotation");

             case "mixed":
              return this.finishNode(node, "MixedTypeAnnotation");

             case "empty":
              return this.finishNode(node, "EmptyTypeAnnotation");

             case "number":
              return this.finishNode(node, "NumberTypeAnnotation");

             case "string":
              return this.finishNode(node, "StringTypeAnnotation");

             case "symbol":
              return this.finishNode(node, "SymbolTypeAnnotation");

             default:
              return this.checkNotUnderscore(id.name), this.flowParseGenericType(startPos, startLoc, id);
            }
          }
          flowParsePrimaryType() {
            const startPos = this.state.start, startLoc = this.state.startLoc, node = this.startNode();
            let tmp, type, isGroupedType = !1;
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            switch (this.state.type) {
             case 5:
              return this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !1,
                allowSpread: !0,
                allowProto: !1,
                allowInexact: !0
              });

             case 6:
              return this.flowParseObjectType({
                allowStatic: !1,
                allowExact: !0,
                allowSpread: !0,
                allowProto: !1,
                allowInexact: !1
              });

             case 0:
              return this.state.noAnonFunctionType = !1, type = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, 
              type;

             case 47:
              return node.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), 
              tmp = this.flowParseFunctionTypeParams(), node.params = tmp.params, node.rest = tmp.rest, 
              node.this = tmp._this, this.expect(11), this.expect(19), node.returnType = this.flowParseType(), 
              this.finishNode(node, "FunctionTypeAnnotation");

             case 10:
              if (this.next(), !this.match(11) && !this.match(21)) if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = 17 !== token && 14 !== token;
              } else isGroupedType = !0;
              if (isGroupedType) {
                if (this.state.noAnonFunctionType = !1, type = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, 
                this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type)) return this.expect(11), 
                type;
                this.eat(12);
              }
              return tmp = type ? this.flowParseFunctionTypeParams([ this.reinterpretTypeAsFunctionTypeParam(type) ]) : this.flowParseFunctionTypeParams(), 
              node.params = tmp.params, node.rest = tmp.rest, node.this = tmp._this, this.expect(11), 
              this.expect(19), node.returnType = this.flowParseType(), node.typeParameters = null, 
              this.finishNode(node, "FunctionTypeAnnotation");

             case 129:
              return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

             case 85:
             case 86:
              return node.value = this.match(85), this.next(), this.finishNode(node, "BooleanLiteralTypeAnnotation");

             case 53:
              if ("-" === this.state.value) {
                if (this.next(), this.match(130)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
                if (this.match(131)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
                throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
                  at: this.state.startLoc
                });
              }
              throw this.unexpected();

             case 130:
              return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

             case 131:
              return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

             case 88:
              return this.next(), this.finishNode(node, "VoidTypeAnnotation");

             case 84:
              return this.next(), this.finishNode(node, "NullLiteralTypeAnnotation");

             case 78:
              return this.next(), this.finishNode(node, "ThisTypeAnnotation");

             case 55:
              return this.next(), this.finishNode(node, "ExistsTypeAnnotation");

             case 87:
              return this.flowParseTypeofType();

             default:
              if (tokenIsKeyword(this.state.type)) {
                const label = tokenLabelName(this.state.type);
                return this.next(), super.createIdentifier(node, label);
              }
              if (tokenIsIdentifier(this.state.type)) return this.isContextual(125) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());
            }
            throw this.unexpected();
          }
          flowParsePostfixType() {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let type = this.flowParsePrimaryType(), seenOptionalIndexedAccess = !1;
            for (;(this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const node = this.startNodeAt(startPos, startLoc), optional = this.eat(18);
              seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional, this.expect(0), 
              !optional && this.match(3) ? (node.elementType = type, this.next(), type = this.finishNode(node, "ArrayTypeAnnotation")) : (node.objectType = type, 
              node.indexType = this.flowParseType(), this.expect(3), seenOptionalIndexedAccess ? (node.optional = optional, 
              type = this.finishNode(node, "OptionalIndexedAccessType")) : type = this.finishNode(node, "IndexedAccessType"));
            }
            return type;
          }
          flowParsePrefixType() {
            const node = this.startNode();
            return this.eat(17) ? (node.typeAnnotation = this.flowParsePrefixType(), this.finishNode(node, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const param = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const node = this.startNodeAt(param.start, param.loc.start);
              return node.params = [ this.reinterpretTypeAsFunctionTypeParam(param) ], node.rest = null, 
              node.this = null, node.returnType = this.flowParseType(), node.typeParameters = null, 
              this.finishNode(node, "FunctionTypeAnnotation");
            }
            return param;
          }
          flowParseIntersectionType() {
            const node = this.startNode();
            this.eat(45);
            const type = this.flowParseAnonFunctionWithoutParens();
            for (node.types = [ type ]; this.eat(45); ) node.types.push(this.flowParseAnonFunctionWithoutParens());
            return 1 === node.types.length ? type : this.finishNode(node, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const node = this.startNode();
            this.eat(43);
            const type = this.flowParseIntersectionType();
            for (node.types = [ type ]; this.eat(43); ) node.types.push(this.flowParseIntersectionType());
            return 1 === node.types.length ? type : this.finishNode(node, "UnionTypeAnnotation");
          }
          flowParseType() {
            const oldInType = this.state.inType;
            this.state.inType = !0;
            const type = this.flowParseUnionType();
            return this.state.inType = oldInType, type;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (128 === this.state.type && "_" === this.state.value) {
              const startPos = this.state.start, startLoc = this.state.startLoc, node = this.parseIdentifier();
              return this.flowParseGenericType(startPos, startLoc, node);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const node = this.startNode();
            return node.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
            const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), 
            this.resetEndLocation(ident)), ident;
          }
          typeCastToParameter(node) {
            return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), 
            node.expression;
          }
          flowParseVariance() {
            let variance = null;
            return this.match(53) && (variance = this.startNode(), "+" === this.state.value ? variance.kind = "plus" : variance.kind = "minus", 
            this.next(), this.finishNode(variance, "Variance")), variance;
          }
          parseFunctionBody(node, allowExpressionBody, isMethod = !1) {
            return allowExpressionBody ? this.forwardNoArrowParamsConversionAt(node, (() => super.parseFunctionBody(node, !0, isMethod))) : super.parseFunctionBody(node, !1, isMethod);
          }
          parseFunctionBodyAndFinish(node, type, isMethod = !1) {
            if (this.match(14)) {
              const typeNode = this.startNode();
              [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), 
              node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
            }
            super.parseFunctionBodyAndFinish(node, type, isMethod);
          }
          parseStatement(context, topLevel) {
            if (this.state.strict && this.isContextual(125)) {
              if (tokenIsKeywordOrIdentifier(this.lookahead().type)) {
                const node = this.startNode();
                return this.next(), this.flowParseInterface(node);
              }
            } else if (this.shouldParseEnums() && this.isContextual(122)) {
              const node = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(node);
            }
            const stmt = super.parseStatement(context, topLevel);
            return void 0 !== this.flowPragma || this.isValidDirective(stmt) || (this.flowPragma = null), 
            stmt;
          }
          parseExpressionStatement(node, expr) {
            if ("Identifier" === expr.type) if ("declare" === expr.name) {
              if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(node);
            } else if (tokenIsIdentifier(this.state.type)) {
              if ("interface" === expr.name) return this.flowParseInterface(node);
              if ("type" === expr.name) return this.flowParseTypeAlias(node);
              if ("opaque" === expr.name) return this.flowParseOpaqueType(node, !1);
            }
            return super.parseExpressionStatement(node, expr);
          }
          shouldParseExportDeclaration() {
            const {type} = this.state;
            return tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && 122 === type ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const {type} = this.state;
            return tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && 122 === type ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(122)) {
              const node = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(node);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(expr, startPos, startLoc, refExpressionErrors) {
            if (!this.match(17)) return expr;
            if (this.state.maybeInArrowParameters) {
              const nextCh = this.lookaheadCharCode();
              if (44 === nextCh || 61 === nextCh || 58 === nextCh || 41 === nextCh) return this.setOptionalParametersError(refExpressionErrors), 
              expr;
            }
            this.expect(17);
            const state = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node = this.startNodeAt(startPos, startLoc);
            let {consequent, failed} = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
            if (failed || invalid.length > 0) {
              const noArrowAt = [ ...originalNoArrowAt ];
              if (invalid.length > 0) {
                this.state = state, this.state.noArrowAt = noArrowAt;
                for (let i = 0; i < invalid.length; i++) noArrowAt.push(invalid[i].start);
                ({consequent, failed} = this.tryParseConditionalConsequent()), [valid, invalid] = this.getArrowLikeExpressions(consequent);
              }
              failed && valid.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, {
                at: state.startLoc
              }), failed && 1 === valid.length && (this.state = state, noArrowAt.push(valid[0].start), 
              this.state.noArrowAt = noArrowAt, ({consequent, failed} = this.tryParseConditionalConsequent()));
            }
            return this.getArrowLikeExpressions(consequent, !0), this.state.noArrowAt = originalNoArrowAt, 
            this.expect(14), node.test = expr, node.consequent = consequent, node.alternate = this.forwardNoArrowParamsConversionAt(node, (() => this.parseMaybeAssign(void 0, void 0))), 
            this.finishNode(node, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const consequent = this.parseMaybeAssignAllowIn(), failed = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), {
              consequent,
              failed
            };
          }
          getArrowLikeExpressions(node, disallowInvalid) {
            const stack = [ node ], arrows = [];
            for (;0 !== stack.length; ) {
              const node = stack.pop();
              "ArrowFunctionExpression" === node.type ? (node.typeParameters || !node.returnType ? this.finishArrowValidation(node) : arrows.push(node), 
              stack.push(node.body)) : "ConditionalExpression" === node.type && (stack.push(node.consequent), 
              stack.push(node.alternate));
            }
            return disallowInvalid ? (arrows.forEach((node => this.finishArrowValidation(node))), 
            [ arrows, [] ]) : function(list, test) {
              const list1 = [], list2 = [];
              for (let i = 0; i < list.length; i++) (test(list[i], i, list) ? list1 : list2).push(list[i]);
              return [ list1, list2 ];
            }(arrows, (node => node.params.every((param => this.isAssignable(param, !0)))));
          }
          finishArrowValidation(node) {
            var _node$extra;
            this.toAssignableList(node.params, null == (_node$extra = node.extra) ? void 0 : _node$extra.trailingCommaLoc, !1), 
            this.scope.enter(6), super.checkParams(node, !1, !0), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(node, parse) {
            let result;
            return -1 !== this.state.noArrowParamsConversionAt.indexOf(node.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), 
            result = parse(), this.state.noArrowParamsConversionAt.pop()) : result = parse(), 
            result;
          }
          parseParenItem(node, startPos, startLoc) {
            if (node = super.parseParenItem(node, startPos, startLoc), this.eat(17) && (node.optional = !0, 
            this.resetEndLocation(node)), this.match(14)) {
              const typeCastNode = this.startNodeAt(startPos, startLoc);
              return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), 
              this.finishNode(typeCastNode, "TypeCastExpression");
            }
            return node;
          }
          assertModuleNodeAllowed(node) {
            "ImportDeclaration" === node.type && ("type" === node.importKind || "typeof" === node.importKind) || "ExportNamedDeclaration" === node.type && "type" === node.exportKind || "ExportAllDeclaration" === node.type && "type" === node.exportKind || super.assertModuleNodeAllowed(node);
          }
          parseExport(node) {
            const decl = super.parseExport(node);
            return "ExportNamedDeclaration" !== decl.type && "ExportAllDeclaration" !== decl.type || (decl.exportKind = decl.exportKind || "value"), 
            decl;
          }
          parseExportDeclaration(node) {
            if (this.isContextual(126)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.match(5) ? (node.specifiers = this.parseExportSpecifiers(!0), 
              this.parseExportFrom(node), null) : this.flowParseTypeAlias(declarationNode);
            }
            if (this.isContextual(127)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseOpaqueType(declarationNode, !1);
            }
            if (this.isContextual(125)) {
              node.exportKind = "type";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseInterface(declarationNode);
            }
            if (this.shouldParseEnums() && this.isContextual(122)) {
              node.exportKind = "value";
              const declarationNode = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(declarationNode);
            }
            return super.parseExportDeclaration(node);
          }
          eatExportStar(node) {
            return !!super.eatExportStar(...arguments) || !(!this.isContextual(126) || 55 !== this.lookahead().type) && (node.exportKind = "type", 
            this.next(), this.next(), !0);
          }
          maybeParseExportNamespaceSpecifier(node) {
            const {startLoc} = this.state, hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
            return hasNamespace && "type" === node.exportKind && this.unexpected(startLoc), 
            hasNamespace;
          }
          parseClassId(node, isStatement, optionalId) {
            super.parseClassId(node, isStatement, optionalId), this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(classBody, member, state) {
            const {startLoc} = this.state;
            if (this.isContextual(121)) {
              if (this.parseClassMemberFromModifier(classBody, member)) return;
              member.declare = !0;
            }
            super.parseClassMember(classBody, member, state), member.declare && ("ClassProperty" !== member.type && "ClassPrivateProperty" !== member.type && "PropertyDefinition" !== member.type ? this.raise(FlowErrors.DeclareClassElement, {
              at: startLoc
            }) : member.value && this.raise(FlowErrors.DeclareClassFieldInitializer, {
              at: member.value
            }));
          }
          isIterator(word) {
            return "iterator" === word || "asyncIterator" === word;
          }
          readIterator() {
            const word = super.readWord1(), fullWord = "@@" + word;
            this.isIterator(word) && this.state.inType || this.raise(Errors.InvalidIdentifier, {
              at: this.state.curPosition(),
              identifierName: fullWord
            }), this.finishToken(128, fullWord);
          }
          getTokenFromCode(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            return 123 === code && 124 === next ? this.finishOp(6, 2) : !this.state.inType || 62 !== code && 60 !== code ? this.state.inType && 63 === code ? 46 === next ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(current, next, next2) {
              return 64 === current && 64 === next && isIdentifierStart(next2);
            }(code, next, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, 
            this.readIterator()) : super.getTokenFromCode(code) : this.finishOp(62 === code ? 48 : 47, 1);
          }
          isAssignable(node, isBinding) {
            return "TypeCastExpression" === node.type ? this.isAssignable(node.expression, isBinding) : super.isAssignable(node, isBinding);
          }
          toAssignable(node, isLHS = !1) {
            return "TypeCastExpression" === node.type ? super.toAssignable(this.typeCastToParameter(node), isLHS) : super.toAssignable(node, isLHS);
          }
          toAssignableList(exprList, trailingCommaLoc, isLHS) {
            for (let i = 0; i < exprList.length; i++) {
              const expr = exprList[i];
              "TypeCastExpression" === (null == expr ? void 0 : expr.type) && (exprList[i] = this.typeCastToParameter(expr));
            }
            return super.toAssignableList(exprList, trailingCommaLoc, isLHS);
          }
          toReferencedList(exprList, isParenthesizedExpr) {
            for (let i = 0; i < exprList.length; i++) {
              var _expr$extra;
              const expr = exprList[i];
              !expr || "TypeCastExpression" !== expr.type || null != (_expr$extra = expr.extra) && _expr$extra.parenthesized || !(exprList.length > 1) && isParenthesizedExpr || this.raise(FlowErrors.TypeCastInPattern, {
                at: expr.typeAnnotation
              });
            }
            return exprList;
          }
          parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
            const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
            return canBePattern && !this.state.maybeInArrowParameters && this.toReferencedList(node.elements), 
            node;
          }
          isValidLVal(type, ...rest) {
            return "TypeCastExpression" === type || super.isValidLVal(type, ...rest);
          }
          parseClassProperty(node) {
            return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), 
            super.parseClassProperty(node);
          }
          parseClassPrivateProperty(node) {
            return this.match(14) && (node.typeAnnotation = this.flowParseTypeAnnotation()), 
            super.parseClassPrivateProperty(node);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(method) {
            return !this.match(14) && super.isNonstaticConstructor(method);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            if (method.variance && this.unexpected(method.variance.loc.start), delete method.variance, 
            this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), 
            super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper), 
            method.params && isConstructor) {
              const params = method.params;
              params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            } else if ("MethodDefinition" === method.type && isConstructor && method.value.params) {
              const params = method.value.params;
              params.length > 0 && this.isThisParam(params[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, {
                at: method
              });
            }
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            method.variance && this.unexpected(method.variance.loc.start), delete method.variance, 
            this.match(47) && (method.typeParameters = this.flowParseTypeParameterDeclaration()), 
            super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          parseClassSuper(node) {
            if (super.parseClassSuper(node), node.superClass && this.match(47) && (node.superTypeParameters = this.flowParseTypeParameterInstantiation()), 
            this.isContextual(110)) {
              this.next();
              const implemented = node.implements = [];
              do {
                const node = this.startNode();
                node.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, 
                implemented.push(this.finishNode(node, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(method) {
            super.checkGetterSetterParams(method);
            const params = this.getObjectOrClassMethodParams(method);
            if (params.length > 0) {
              const param = params[0];
              this.isThisParam(param) && "get" === method.kind ? this.raise(FlowErrors.GetterMayNotHaveThisParam, {
                at: param
              }) : this.isThisParam(param) && this.raise(FlowErrors.SetterMayNotHaveThisParam, {
                at: param
              });
            }
          }
          parsePropertyNamePrefixOperator(node) {
            node.variance = this.flowParseVariance();
          }
          parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
            let typeParameters;
            prop.variance && this.unexpected(prop.variance.loc.start), delete prop.variance, 
            this.match(47) && !isAccessor && (typeParameters = this.flowParseTypeParameterDeclaration(), 
            this.match(10) || this.unexpected()), super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors), 
            typeParameters && ((prop.value || prop).typeParameters = typeParameters);
          }
          parseAssignableListItemTypes(param) {
            return this.eat(17) && ("Identifier" !== param.type && this.raise(FlowErrors.PatternIsOptional, {
              at: param
            }), this.isThisParam(param) && this.raise(FlowErrors.ThisParamMayNotBeOptional, {
              at: param
            }), param.optional = !0), this.match(14) ? param.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(param) && this.raise(FlowErrors.ThisParamAnnotationRequired, {
              at: param
            }), this.match(29) && this.isThisParam(param) && this.raise(FlowErrors.ThisParamNoDefault, {
              at: param
            }), this.resetEndLocation(param), param;
          }
          parseMaybeDefault(startPos, startLoc, left) {
            const node = super.parseMaybeDefault(startPos, startLoc, left);
            return "AssignmentPattern" === node.type && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, {
              at: node.typeAnnotation
            }), node;
          }
          shouldParseDefaultImport(node) {
            return hasTypeImportKind(node) ? isMaybeDefaultImport(this.state.type) : super.shouldParseDefaultImport(node);
          }
          parseImportSpecifierLocal(node, specifier, type) {
            specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), 
            node.specifiers.push(this.finishImportSpecifier(specifier, type));
          }
          maybeParseDefaultImportSpecifier(node) {
            node.importKind = "value";
            let kind = null;
            if (this.match(87) ? kind = "typeof" : this.isContextual(126) && (kind = "type"), 
            kind) {
              const lh = this.lookahead(), {type} = lh;
              "type" === kind && 55 === type && this.unexpected(null, lh.type), (isMaybeDefaultImport(type) || 5 === type || 55 === type) && (this.next(), 
              node.importKind = kind);
            }
            return super.maybeParseDefaultImportSpecifier(node);
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
            const firstIdent = specifier.imported;
            let specifierTypeKind = null;
            "Identifier" === firstIdent.type && ("type" === firstIdent.name ? specifierTypeKind = "type" : "typeof" === firstIdent.name && (specifierTypeKind = "typeof"));
            let isBinding = !1;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const as_ident = this.parseIdentifier(!0);
              null === specifierTypeKind || tokenIsKeywordOrIdentifier(this.state.type) ? (specifier.imported = firstIdent, 
              specifier.importKind = null, specifier.local = this.parseIdentifier()) : (specifier.imported = as_ident, 
              specifier.importKind = specifierTypeKind, specifier.local = cloneIdentifier(as_ident));
            } else {
              if (null !== specifierTypeKind && tokenIsKeywordOrIdentifier(this.state.type)) specifier.imported = this.parseIdentifier(!0), 
              specifier.importKind = specifierTypeKind; else {
                if (importedIsString) throw this.raise(Errors.ImportBindingIsString, {
                  at: specifier,
                  importName: firstIdent.value
                });
                specifier.imported = firstIdent, specifier.importKind = null;
              }
              this.eatContextual(93) ? specifier.local = this.parseIdentifier() : (isBinding = !0, 
              specifier.local = cloneIdentifier(specifier.imported));
            }
            const specifierIsTypeImport = hasTypeImportKind(specifier);
            return isInTypeOnlyImport && specifierIsTypeImport && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
              at: specifier
            }), (isInTypeOnlyImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.loc.start, !0), 
            !isBinding || isInTypeOnlyImport || specifierIsTypeImport || this.checkReservedWord(specifier.local.name, specifier.loc.start, !0, !0), 
            this.finishImportSpecifier(specifier, "ImportSpecifier");
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseFunctionParams(node, allowModifiers) {
            const kind = node.kind;
            "get" !== kind && "set" !== kind && this.match(47) && (node.typeParameters = this.flowParseTypeParameterDeclaration()), 
            super.parseFunctionParams(node, allowModifiers);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind), this.match(14) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), 
            this.resetEndLocation(decl.id));
          }
          parseAsyncArrowFromCallExpression(node, call) {
            if (this.match(14)) {
              const oldNoAnonFunctionType = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = !0, node.returnType = this.flowParseTypeAnnotation(), 
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
            }
            return super.parseAsyncArrowFromCallExpression(node, call);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(refExpressionErrors, afterLeftParse) {
            var _jsx;
            let jsx, state = null;
            if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
              if (state = this.state.clone(), jsx = this.tryParse((() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse)), state), 
              !jsx.error) return jsx.node;
              const {context} = this.state, currentContext = context[context.length - 1];
              currentContext !== types.j_oTag && currentContext !== types.j_expr || context.pop();
            }
            if (null != (_jsx = jsx) && _jsx.error || this.match(47)) {
              var _jsx2, _jsx3;
              let typeParameters;
              state = state || this.state.clone();
              const arrow = this.tryParse((abort => {
                var _arrowExpression$extr;
                typeParameters = this.flowParseTypeParameterDeclaration();
                const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, (() => {
                  const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
                  return this.resetStartLocationFromNode(result, typeParameters), result;
                }));
                null != (_arrowExpression$extr = arrowExpression.extra) && _arrowExpression$extr.parenthesized && abort();
                const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
                return "ArrowFunctionExpression" !== expr.type && abort(), expr.typeParameters = typeParameters, 
                this.resetStartLocationFromNode(expr, typeParameters), arrowExpression;
              }), state);
              let arrowExpression = null;
              if (arrow.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(arrow.node).type) {
                if (!arrow.error && !arrow.aborted) return arrow.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
                  at: typeParameters
                }), arrow.node;
                arrowExpression = arrow.node;
              }
              if (null != (_jsx2 = jsx) && _jsx2.node) return this.state = jsx.failState, jsx.node;
              if (arrowExpression) return this.state = arrow.failState, arrowExpression;
              if (null != (_jsx3 = jsx) && _jsx3.thrown) throw jsx.error;
              if (arrow.thrown) throw arrow.error;
              throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
                at: typeParameters
              });
            }
            return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          }
          parseArrow(node) {
            if (this.match(14)) {
              const result = this.tryParse((() => {
                const oldNoAnonFunctionType = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = !0;
                const typeNode = this.startNode();
                return [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), 
                this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), 
                this.match(19) || this.unexpected(), typeNode;
              }));
              if (result.thrown) return null;
              result.error && (this.state = result.failState), node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(node);
          }
          shouldParseArrow(params) {
            return this.match(14) || super.shouldParseArrow(params);
          }
          setArrowFunctionParameters(node, params) {
            -1 !== this.state.noArrowParamsConversionAt.indexOf(node.start) ? node.params = params : super.setArrowFunctionParameters(node, params);
          }
          checkParams(node, allowDuplicates, isArrowFunction) {
            if (!isArrowFunction || -1 === this.state.noArrowParamsConversionAt.indexOf(node.start)) {
              for (let i = 0; i < node.params.length; i++) this.isThisParam(node.params[i]) && i > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, {
                at: node.params[i]
              });
              return super.checkParams(...arguments);
            }
          }
          parseParenAndDistinguishExpression(canBeArrow) {
            return super.parseParenAndDistinguishExpression(canBeArrow && -1 === this.state.noArrowAt.indexOf(this.state.start));
          }
          parseSubscripts(base, startPos, startLoc, noCalls) {
            if ("Identifier" === base.type && "async" === base.name && -1 !== this.state.noArrowAt.indexOf(startPos)) {
              this.next();
              const node = this.startNodeAt(startPos, startLoc);
              node.callee = base, node.arguments = this.parseCallExpressionArguments(11, !1), 
              base = this.finishNode(node, "CallExpression");
            } else if ("Identifier" === base.type && "async" === base.name && this.match(47)) {
              const state = this.state.clone(), arrow = this.tryParse((abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort()), state);
              if (!arrow.error && !arrow.aborted) return arrow.node;
              const result = this.tryParse((() => super.parseSubscripts(base, startPos, startLoc, noCalls)), state);
              if (result.node && !result.error) return result.node;
              if (arrow.node) return this.state = arrow.failState, arrow.node;
              if (result.node) return this.state = result.failState, result.node;
              throw arrow.error || result.error;
            }
            return super.parseSubscripts(base, startPos, startLoc, noCalls);
          }
          parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (subscriptState.optionalChainMember = !0, noCalls) return subscriptState.stop = !0, 
              base;
              this.next();
              const node = this.startNodeAt(startPos, startLoc);
              return node.callee = base, node.typeArguments = this.flowParseTypeParameterInstantiation(), 
              this.expect(10), node.arguments = this.parseCallExpressionArguments(11, !1), node.optional = !0, 
              this.finishCallExpression(node, !0);
            }
            if (!noCalls && this.shouldParseTypes() && this.match(47)) {
              const node = this.startNodeAt(startPos, startLoc);
              node.callee = base;
              const result = this.tryParse((() => (node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), 
              this.expect(10), node.arguments = this.parseCallExpressionArguments(11, !1), subscriptState.optionalChainMember && (node.optional = !1), 
              this.finishCallExpression(node, subscriptState.optionalChainMember))));
              if (result.node) return result.error && (this.state = result.failState), result.node;
            }
            return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
          }
          parseNewArguments(node) {
            let targs = null;
            this.shouldParseTypes() && this.match(47) && (targs = this.tryParse((() => this.flowParseTypeParameterInstantiationCallOrNew())).node), 
            node.typeArguments = targs, super.parseNewArguments(node);
          }
          parseAsyncArrowWithTypeParameters(startPos, startLoc) {
            const node = this.startNodeAt(startPos, startLoc);
            if (this.parseFunctionParams(node), this.parseArrow(node)) return this.parseArrowExpression(node, void 0, !0);
          }
          readToken_mult_modulo(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (42 === code && 47 === next && this.state.hasFlowComment) return this.state.hasFlowComment = !1, 
            this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(code);
          }
          readToken_pipe_amp(code) {
            const next = this.input.charCodeAt(this.state.pos + 1);
            124 !== code || 125 !== next ? super.readToken_pipe_amp(code) : this.finishOp(9, 2);
          }
          parseTopLevel(file, program) {
            const fileNode = super.parseTopLevel(file, program);
            return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, {
              at: this.state.curPosition()
            }), fileNode;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment) throw this.raise(FlowErrors.NestedFlowComment, {
                at: this.state.startLoc
              });
              return this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), 
              void (this.state.hasFlowComment = !0);
            }
            if (!this.state.hasFlowComment) return super.skipBlockComment();
            {
              const end = this.input.indexOf("*-/", this.state.pos + 2);
              if (-1 === end) throw this.raise(Errors.UnterminatedComment, {
                at: this.state.curPosition()
              });
              this.state.pos = end + 2 + 3;
            }
          }
          skipFlowComment() {
            const {pos} = this.state;
            let shiftToFirstNonWhiteSpace = 2;
            for (;[ 32, 9 ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)); ) shiftToFirstNonWhiteSpace++;
            const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
            return 58 === ch2 && 58 === ch3 ? shiftToFirstNonWhiteSpace + 2 : "flow-include" === this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) ? shiftToFirstNonWhiteSpace + 12 : 58 === ch2 && 58 !== ch3 && shiftToFirstNonWhiteSpace;
          }
          hasFlowCommentCompletion() {
            if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(Errors.UnterminatedComment, {
              at: this.state.curPosition()
            });
          }
          flowEnumErrorBooleanMemberNotInitialized(loc, {enumName, memberName}) {
            this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
              at: loc,
              memberName,
              enumName
            });
          }
          flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
            return this.raise(enumContext.explicitType ? "symbol" === enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType : FlowErrors.EnumInvalidMemberInitializerUnknownType, Object.assign({
              at: loc
            }, enumContext));
          }
          flowEnumErrorNumberMemberNotInitialized(loc, {enumName, memberName}) {
            this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
              at: loc,
              enumName,
              memberName
            });
          }
          flowEnumErrorStringMemberInconsistentlyInitailized(node, {enumName}) {
            this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {
              at: node,
              enumName
            });
          }
          flowEnumMemberInit() {
            const startLoc = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
            switch (this.state.type) {
             case 130:
              {
                const literal = this.parseNumericLiteral(this.state.value);
                return endOfInit() ? {
                  type: "number",
                  loc: literal.loc.start,
                  value: literal
                } : {
                  type: "invalid",
                  loc: startLoc
                };
              }

             case 129:
              {
                const literal = this.parseStringLiteral(this.state.value);
                return endOfInit() ? {
                  type: "string",
                  loc: literal.loc.start,
                  value: literal
                } : {
                  type: "invalid",
                  loc: startLoc
                };
              }

             case 85:
             case 86:
              {
                const literal = this.parseBooleanLiteral(this.match(85));
                return endOfInit() ? {
                  type: "boolean",
                  loc: literal.loc.start,
                  value: literal
                } : {
                  type: "invalid",
                  loc: startLoc
                };
              }

             default:
              return {
                type: "invalid",
                loc: startLoc
              };
            }
          }
          flowEnumMemberRaw() {
            const loc = this.state.startLoc;
            return {
              id: this.parseIdentifier(!0),
              init: this.eat(29) ? this.flowEnumMemberInit() : {
                type: "none",
                loc
              }
            };
          }
          flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
            const {explicitType} = context;
            null !== explicitType && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(loc, context);
          }
          flowEnumMembers({enumName, explicitType}) {
            const seenNames = new Set, members = {
              booleanMembers: [],
              numberMembers: [],
              stringMembers: [],
              defaultedMembers: []
            };
            let hasUnknownMembers = !1;
            for (;!this.match(8); ) {
              if (this.eat(21)) {
                hasUnknownMembers = !0;
                break;
              }
              const memberNode = this.startNode(), {id, init} = this.flowEnumMemberRaw(), memberName = id.name;
              if ("" === memberName) continue;
              /^[a-z]/.test(memberName) && this.raise(FlowErrors.EnumInvalidMemberName, {
                at: id,
                memberName,
                suggestion: memberName[0].toUpperCase() + memberName.slice(1),
                enumName
              }), seenNames.has(memberName) && this.raise(FlowErrors.EnumDuplicateMemberName, {
                at: id,
                memberName,
                enumName
              }), seenNames.add(memberName);
              const context = {
                enumName,
                explicitType,
                memberName
              };
              switch (memberNode.id = id, init.type) {
               case "boolean":
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean"), memberNode.init = init.value, 
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;

               case "number":
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number"), memberNode.init = init.value, 
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;

               case "string":
                this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string"), memberNode.init = init.value, 
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;

               case "invalid":
                throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);

               case "none":
                switch (explicitType) {
                 case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;

                 case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;

                 default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
              this.match(8) || this.expect(12);
            }
            return {
              members,
              hasUnknownMembers
            };
          }
          flowEnumStringMembers(initializedMembers, defaultedMembers, {enumName}) {
            if (0 === initializedMembers.length) return defaultedMembers;
            if (0 === defaultedMembers.length) return initializedMembers;
            if (defaultedMembers.length > initializedMembers.length) {
              for (const member of initializedMembers) this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
                enumName
              });
              return defaultedMembers;
            }
            for (const member of defaultedMembers) this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {
              enumName
            });
            return initializedMembers;
          }
          flowEnumParseExplicitType({enumName}) {
            if (!this.eatContextual(101)) return null;
            if (!tokenIsIdentifier(this.state.type)) throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
              at: this.state.startLoc,
              enumName
            });
            const {value} = this.state;
            return this.next(), "boolean" !== value && "number" !== value && "string" !== value && "symbol" !== value && this.raise(FlowErrors.EnumInvalidExplicitType, {
              at: this.state.startLoc,
              enumName,
              invalidEnumType: value
            }), value;
          }
          flowEnumBody(node, id) {
            const enumName = id.name, nameLoc = id.loc.start, explicitType = this.flowEnumParseExplicitType({
              enumName
            });
            this.expect(5);
            const {members, hasUnknownMembers} = this.flowEnumMembers({
              enumName,
              explicitType
            });
            switch (node.hasUnknownMembers = hasUnknownMembers, explicitType) {
             case "boolean":
              return node.explicitType = !0, node.members = members.booleanMembers, this.expect(8), 
              this.finishNode(node, "EnumBooleanBody");

             case "number":
              return node.explicitType = !0, node.members = members.numberMembers, this.expect(8), 
              this.finishNode(node, "EnumNumberBody");

             case "string":
              return node.explicitType = !0, node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              }), this.expect(8), this.finishNode(node, "EnumStringBody");

             case "symbol":
              return node.members = members.defaultedMembers, this.expect(8), this.finishNode(node, "EnumSymbolBody");

             default:
              {
                const empty = () => (node.members = [], this.expect(8), this.finishNode(node, "EnumStringBody"));
                node.explicitType = !1;
                const boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
                if (boolsLen || numsLen || strsLen || defaultedLen) {
                  if (boolsLen || numsLen) {
                    if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                      for (const member of members.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                        enumName,
                        memberName: member.id.name
                      });
                      return node.members = members.booleanMembers, this.expect(8), this.finishNode(node, "EnumBooleanBody");
                    }
                    if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                      for (const member of members.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                        enumName,
                        memberName: member.id.name
                      });
                      return node.members = members.numberMembers, this.expect(8), this.finishNode(node, "EnumNumberBody");
                    }
                    return this.raise(FlowErrors.EnumInconsistentMemberValues, {
                      at: nameLoc,
                      enumName
                    }), empty();
                  }
                  return node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                    enumName
                  }), this.expect(8), this.finishNode(node, "EnumStringBody");
                }
                return empty();
              }
            }
          }
          flowParseEnumDeclaration(node) {
            const id = this.parseIdentifier();
            return node.id = id, node.body = this.flowEnumBody(this.startNode(), id), this.finishNode(node, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const next = this.nextTokenStart();
            if (60 === this.input.charCodeAt(next)) {
              const afterNext = this.input.charCodeAt(next + 1);
              return 60 !== afterNext && 61 !== afterNext;
            }
            return !1;
          }
          maybeUnwrapTypeCastExpression(node) {
            return "TypeCastExpression" === node.type ? node.expression : node;
          }
        },
        typescript: superClass => class extends superClass {
          getScopeHandler() {
            return TypeScriptScopeHandler;
          }
          tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
            if (!tokenIsIdentifier(this.state.type)) return;
            const modifier = this.state.value;
            if (-1 !== allowedModifiers.indexOf(modifier)) {
              if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return modifier;
            }
          }
          tsParseModifiers({modified, allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock}) {
            const enforceOrder = (loc, modifier, before, after) => {
              modifier === before && modified[after] && this.raise(TSErrors.InvalidModifiersOrder, {
                at: loc,
                orderedModifiers: [ before, after ]
              });
            }, incompatible = (loc, modifier, mod1, mod2) => {
              (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) && this.raise(TSErrors.IncompatibleModifiers, {
                at: loc,
                modifiers: [ mod1, mod2 ]
              });
            };
            for (;;) {
              const {startLoc} = this.state, modifier = this.tsParseModifier(allowedModifiers.concat(null != disallowedModifiers ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
              if (!modifier) break;
              tsIsAccessModifier(modifier) ? modified.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, {
                at: startLoc,
                modifier
              }) : (enforceOrder(startLoc, modifier, modifier, "override"), enforceOrder(startLoc, modifier, modifier, "static"), 
              enforceOrder(startLoc, modifier, modifier, "readonly"), modified.accessibility = modifier) : (Object.hasOwnProperty.call(modified, modifier) ? this.raise(TSErrors.DuplicateModifier, {
                at: startLoc,
                modifier
              }) : (enforceOrder(startLoc, modifier, "static", "readonly"), enforceOrder(startLoc, modifier, "static", "override"), 
              enforceOrder(startLoc, modifier, "override", "readonly"), enforceOrder(startLoc, modifier, "abstract", "override"), 
              incompatible(startLoc, modifier, "declare", "override"), incompatible(startLoc, modifier, "static", "abstract")), 
              modified[modifier] = !0), null != disallowedModifiers && disallowedModifiers.includes(modifier) && this.raise(TSErrors.InvalidModifierOnTypeMember, {
                at: startLoc,
                modifier
              });
            }
          }
          tsIsListTerminator(kind) {
            switch (kind) {
             case "EnumMembers":
             case "TypeMembers":
              return this.match(8);

             case "HeritageClauseElement":
              return this.match(5);

             case "TupleElementTypes":
              return this.match(3);

             case "TypeParametersOrArguments":
              return this.match(48);
            }
            throw new Error("Unreachable");
          }
          tsParseList(kind, parseElement) {
            const result = [];
            for (;!this.tsIsListTerminator(kind); ) result.push(parseElement());
            return result;
          }
          tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
            return function(x) {
              if (null == x) throw new Error(`Unexpected ${x} value.`);
              return x;
            }(this.tsParseDelimitedListWorker(kind, parseElement, !0, refTrailingCommaPos));
          }
          tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
            const result = [];
            let trailingCommaPos = -1;
            for (;!this.tsIsListTerminator(kind); ) {
              trailingCommaPos = -1;
              const element = parseElement();
              if (null == element) return;
              if (result.push(element), !this.eat(12)) {
                if (this.tsIsListTerminator(kind)) break;
                return void (expectSuccess && this.expect(12));
              }
              trailingCommaPos = this.state.lastTokStart;
            }
            return refTrailingCommaPos && (refTrailingCommaPos.value = trailingCommaPos), result;
          }
          tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
            skipFirstToken || (bracket ? this.expect(0) : this.expect(47));
            const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
            return bracket ? this.expect(3) : this.expect(48), result;
          }
          tsParseImportType() {
            const node = this.startNode();
            return this.expect(83), this.expect(10), this.match(129) || this.raise(TSErrors.UnsupportedImportTypeArgument, {
              at: this.state.startLoc
            }), node.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (node.qualifier = this.tsParseEntityName()), 
            this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSImportType");
          }
          tsParseEntityName(allowReservedWords = !0) {
            let entity = this.parseIdentifier(allowReservedWords);
            for (;this.eat(16); ) {
              const node = this.startNodeAtNode(entity);
              node.left = entity, node.right = this.parseIdentifier(allowReservedWords), entity = this.finishNode(node, "TSQualifiedName");
            }
            return entity;
          }
          tsParseTypeReference() {
            const node = this.startNode();
            return node.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), 
            this.finishNode(node, "TSTypeReference");
          }
          tsParseThisTypePredicate(lhs) {
            this.next();
            const node = this.startNodeAtNode(lhs);
            return node.parameterName = lhs, node.typeAnnotation = this.tsParseTypeAnnotation(!1), 
            node.asserts = !1, this.finishNode(node, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const node = this.startNode();
            return this.next(), this.finishNode(node, "TSThisType");
          }
          tsParseTypeQuery() {
            const node = this.startNode();
            return this.expect(87), this.match(83) ? node.exprName = this.tsParseImportType() : node.exprName = this.tsParseEntityName(), 
            this.finishNode(node, "TSTypeQuery");
          }
          tsParseTypeParameter() {
            const node = this.startNode();
            return node.name = this.tsParseTypeParameterName(), node.constraint = this.tsEatThenParseType(81), 
            node.default = this.tsEatThenParseType(29), this.finishNode(node, "TSTypeParameter");
          }
          tsTryParseTypeParameters() {
            if (this.match(47)) return this.tsParseTypeParameters();
          }
          tsParseTypeParameters() {
            const node = this.startNode();
            this.match(47) || this.match(138) ? this.next() : this.unexpected();
            const refTrailingCommaPos = {
              value: -1
            };
            return node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), !1, !0, refTrailingCommaPos), 
            0 === node.params.length && this.raise(TSErrors.EmptyTypeParameters, {
              at: node
            }), -1 !== refTrailingCommaPos.value && this.addExtra(node, "trailingComma", refTrailingCommaPos.value), 
            this.finishNode(node, "TSTypeParameterDeclaration");
          }
          tsTryNextParseConstantContext() {
            if (75 !== this.lookahead().type) return null;
            this.next();
            const typeReference = this.tsParseTypeReference();
            return typeReference.typeParameters && this.raise(TSErrors.CannotFindName, {
              at: typeReference.typeName,
              name: "const"
            }), typeReference;
          }
          tsFillSignature(returnToken, signature) {
            const returnTokenRequired = 19 === returnToken;
            signature.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), signature.parameters = this.tsParseBindingListForSignature(), 
            (returnTokenRequired || this.match(returnToken)) && (signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
          }
          tsParseBindingListForSignature() {
            return this.parseBindingList(11, 41).map((pattern => ("Identifier" !== pattern.type && "RestElement" !== pattern.type && "ObjectPattern" !== pattern.type && "ArrayPattern" !== pattern.type && this.raise(TSErrors.UnsupportedSignatureParameterKind, {
              at: pattern,
              type: pattern.type
            }), pattern)));
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(kind, node) {
            return this.tsFillSignature(14, node), this.tsParseTypeMemberSemicolon(), this.finishNode(node, kind);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!tokenIsIdentifier(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(node) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
            this.expect(0);
            const id = this.parseIdentifier();
            id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(3), 
            node.parameters = [ id ];
            const type = this.tsTryParseTypeAnnotation();
            return type && (node.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), 
            this.finishNode(node, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(node, readonly) {
            this.eat(17) && (node.optional = !0);
            const nodeAny = node;
            if (this.match(10) || this.match(47)) {
              readonly && this.raise(TSErrors.ReadonlyForMethodSignature, {
                at: node
              });
              const method = nodeAny;
              method.kind && this.match(47) && this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
                at: this.state.curPosition()
              }), this.tsFillSignature(14, method), this.tsParseTypeMemberSemicolon();
              const paramsKey = "parameters", returnTypeKey = "typeAnnotation";
              if ("get" === method.kind) method[paramsKey].length > 0 && (this.raise(Errors.BadGetterArity, {
                at: this.state.curPosition()
              }), this.isThisParam(method[paramsKey][0]) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                at: this.state.curPosition()
              })); else if ("set" === method.kind) {
                if (1 !== method[paramsKey].length) this.raise(Errors.BadSetterArity, {
                  at: this.state.curPosition()
                }); else {
                  const firstParameter = method[paramsKey][0];
                  this.isThisParam(firstParameter) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
                    at: this.state.curPosition()
                  }), "Identifier" === firstParameter.type && firstParameter.optional && this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
                    at: this.state.curPosition()
                  }), "RestElement" === firstParameter.type && this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
                    at: this.state.curPosition()
                  });
                }
                method[returnTypeKey] && this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
                  at: method[returnTypeKey]
                });
              } else method.kind = "method";
              return this.finishNode(method, "TSMethodSignature");
            }
            {
              const property = nodeAny;
              readonly && (property.readonly = !0);
              const type = this.tsTryParseTypeAnnotation();
              return type && (property.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), 
              this.finishNode(property, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const node = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
            if (this.match(77)) {
              const id = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node) : (node.key = this.createIdentifier(id, "new"), 
              this.tsParsePropertyOrMethodSignature(node, !1));
            }
            this.tsParseModifiers({
              modified: node,
              allowedModifiers: [ "readonly" ],
              disallowedModifiers: [ "declare", "abstract", "private", "protected", "public", "static", "override" ]
            });
            const idx = this.tsTryParseIndexSignature(node);
            return idx || (this.parsePropertyName(node), node.computed || "Identifier" !== node.key.type || "get" !== node.key.name && "set" !== node.key.name || !this.tsTokenCanFollowModifier() || (node.kind = node.key.name, 
            this.parsePropertyName(node)), this.tsParsePropertyOrMethodSignature(node, !!node.readonly));
          }
          tsParseTypeLiteral() {
            const node = this.startNode();
            return node.members = this.tsParseObjectTypeMembers(), this.finishNode(node, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), members;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(118) : (this.isContextual(118) && this.next(), 
            !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedTypeParameter() {
            const node = this.startNode();
            return node.name = this.tsParseTypeParameterName(), node.constraint = this.tsExpectThenParseType(58), 
            this.finishNode(node, "TSTypeParameter");
          }
          tsParseMappedType() {
            const node = this.startNode();
            return this.expect(5), this.match(53) ? (node.readonly = this.state.value, this.next(), 
            this.expectContextual(118)) : this.eatContextual(118) && (node.readonly = !0), this.expect(0), 
            node.typeParameter = this.tsParseMappedTypeParameter(), node.nameType = this.eatContextual(93) ? this.tsParseType() : null, 
            this.expect(3), this.match(53) ? (node.optional = this.state.value, this.next(), 
            this.expect(17)) : this.eat(17) && (node.optional = !0), node.typeAnnotation = this.tsTryParseType(), 
            this.semicolon(), this.expect(8), this.finishNode(node, "TSMappedType");
          }
          tsParseTupleType() {
            const node = this.startNode();
            node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
            let seenOptionalElement = !1, labeledElements = null;
            return node.elementTypes.forEach((elementNode => {
              var _labeledElements;
              let {type} = elementNode;
              !seenOptionalElement || "TSRestType" === type || "TSOptionalType" === type || "TSNamedTupleMember" === type && elementNode.optional || this.raise(TSErrors.OptionalTypeBeforeRequired, {
                at: elementNode
              }), seenOptionalElement = seenOptionalElement || "TSNamedTupleMember" === type && elementNode.optional || "TSOptionalType" === type, 
              "TSRestType" === type && (type = (elementNode = elementNode.typeAnnotation).type);
              const isLabeled = "TSNamedTupleMember" === type;
              labeledElements = null != (_labeledElements = labeledElements) ? _labeledElements : isLabeled, 
              labeledElements !== isLabeled && this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {
                at: elementNode
              });
            })), this.finishNode(node, "TSTupleType");
          }
          tsParseTupleElementType() {
            const {start: startPos, startLoc} = this.state, rest = this.eat(21);
            let type = this.tsParseType();
            const optional = this.eat(17);
            if (this.eat(14)) {
              const labeledNode = this.startNodeAtNode(type);
              labeledNode.optional = optional, "TSTypeReference" !== type.type || type.typeParameters || "Identifier" !== type.typeName.type ? (this.raise(TSErrors.InvalidTupleMemberLabel, {
                at: type
              }), labeledNode.label = type) : labeledNode.label = type.typeName, labeledNode.elementType = this.tsParseType(), 
              type = this.finishNode(labeledNode, "TSNamedTupleMember");
            } else if (optional) {
              const optionalTypeNode = this.startNodeAtNode(type);
              optionalTypeNode.typeAnnotation = type, type = this.finishNode(optionalTypeNode, "TSOptionalType");
            }
            if (rest) {
              const restNode = this.startNodeAt(startPos, startLoc);
              restNode.typeAnnotation = type, type = this.finishNode(restNode, "TSRestType");
            }
            return type;
          }
          tsParseParenthesizedType() {
            const node = this.startNode();
            return this.expect(10), node.typeAnnotation = this.tsParseType(), this.expect(11), 
            this.finishNode(node, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(type, abstract) {
            const node = this.startNode();
            return "TSConstructorType" === type && (node.abstract = !!abstract, abstract && this.next(), 
            this.next()), this.tsFillSignature(19, node), this.finishNode(node, type);
          }
          tsParseLiteralTypeNode() {
            const node = this.startNode();
            return node.literal = (() => {
              switch (this.state.type) {
               case 130:
               case 131:
               case 129:
               case 85:
               case 86:
                return this.parseExprAtom();

               default:
                throw this.unexpected();
              }
            })(), this.finishNode(node, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const node = this.startNode();
            return node.literal = this.parseTemplate(!1), this.finishNode(node, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const thisKeyword = this.tsParseThisTypeNode();
            return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
             case 129:
             case 130:
             case 131:
             case 85:
             case 86:
              return this.tsParseLiteralTypeNode();

             case 53:
              if ("-" === this.state.value) {
                const node = this.startNode(), nextToken = this.lookahead();
                if (130 !== nextToken.type && 131 !== nextToken.type) throw this.unexpected();
                return node.literal = this.parseMaybeUnary(), this.finishNode(node, "TSLiteralType");
              }
              break;

             case 78:
              return this.tsParseThisTypeOrThisTypePredicate();

             case 87:
              return this.tsParseTypeQuery();

             case 83:
              return this.tsParseImportType();

             case 5:
              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

             case 0:
              return this.tsParseTupleType();

             case 10:
              return this.tsParseParenthesizedType();

             case 25:
             case 24:
              return this.tsParseTemplateLiteralType();

             default:
              {
                const {type} = this.state;
                if (tokenIsIdentifier(type) || 88 === type || 84 === type) {
                  const nodeType = 88 === type ? "TSVoidKeyword" : 84 === type ? "TSNullKeyword" : function(value) {
                    switch (value) {
                     case "any":
                      return "TSAnyKeyword";

                     case "boolean":
                      return "TSBooleanKeyword";

                     case "bigint":
                      return "TSBigIntKeyword";

                     case "never":
                      return "TSNeverKeyword";

                     case "number":
                      return "TSNumberKeyword";

                     case "object":
                      return "TSObjectKeyword";

                     case "string":
                      return "TSStringKeyword";

                     case "symbol":
                      return "TSSymbolKeyword";

                     case "undefined":
                      return "TSUndefinedKeyword";

                     case "unknown":
                      return "TSUnknownKeyword";

                     default:
                      return;
                    }
                  }(this.state.value);
                  if (void 0 !== nodeType && 46 !== this.lookaheadCharCode()) {
                    const node = this.startNode();
                    return this.next(), this.finishNode(node, nodeType);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            throw this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let type = this.tsParseNonArrayType();
            for (;!this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              const node = this.startNodeAtNode(type);
              node.elementType = type, this.expect(3), type = this.finishNode(node, "TSArrayType");
            } else {
              const node = this.startNodeAtNode(type);
              node.objectType = type, node.indexType = this.tsParseType(), this.expect(3), type = this.finishNode(node, "TSIndexedAccessType");
            }
            return type;
          }
          tsParseTypeOperator() {
            const node = this.startNode(), operator = this.state.value;
            return this.next(), node.operator = operator, node.typeAnnotation = this.tsParseTypeOperatorOrHigher(), 
            "readonly" === operator && this.tsCheckTypeAnnotationForReadOnly(node), this.finishNode(node, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(node) {
            switch (node.typeAnnotation.type) {
             case "TSTupleType":
             case "TSArrayType":
              return;

             default:
              this.raise(TSErrors.UnexpectedReadonly, {
                at: node
              });
            }
          }
          tsParseInferType() {
            const node = this.startNode();
            this.expectContextual(112);
            const typeParameter = this.startNode();
            return typeParameter.name = this.tsParseTypeParameterName(), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), 
            this.finishNode(node, "TSInferType");
          }
          tsParseTypeOperatorOrHigher() {
            var token;
            return (token = this.state.type) >= 117 && token <= 119 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
          }
          tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
            const node = this.startNode(), hasLeadingOperator = this.eat(operator), types = [];
            do {
              types.push(parseConstituentType());
            } while (this.eat(operator));
            return 1 !== types.length || hasLeadingOperator ? (node.types = types, this.finishNode(node, kind)) : types[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) return this.next(), !0;
            if (this.match(5)) {
              const {errors} = this.state, previousErrorCount = errors.length;
              try {
                return this.parseObjectLike(8, !0), errors.length === previousErrorCount;
              } catch (_unused) {
                return !1;
              }
            }
            if (this.match(0)) {
              this.next();
              const {errors} = this.state, previousErrorCount = errors.length;
              try {
                return this.parseBindingList(3, 93, !0), errors.length === previousErrorCount;
              } catch (_unused2) {
                return !1;
              }
            }
            return !1;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(11) || this.match(21)) return !0;
            if (this.tsSkipParameterStart()) {
              if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return !0;
              if (this.match(11) && (this.next(), this.match(19))) return !0;
            }
            return !1;
          }
          tsParseTypeOrTypePredicateAnnotation(returnToken) {
            return this.tsInType((() => {
              const t = this.startNode();
              this.expect(returnToken);
              const node = this.startNode(), asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (asserts && this.match(78)) {
                let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
                return "TSThisType" === thisTypePredicate.type ? (node.parameterName = thisTypePredicate, 
                node.asserts = !0, node.typeAnnotation = null, thisTypePredicate = this.finishNode(node, "TSTypePredicate")) : (this.resetStartLocationFromNode(thisTypePredicate, node), 
                thisTypePredicate.asserts = !0), t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
              }
              const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!typePredicateVariable) return asserts ? (node.parameterName = this.parseIdentifier(), 
              node.asserts = asserts, node.typeAnnotation = null, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), 
              this.finishNode(t, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, t);
              const type = this.tsParseTypeAnnotation(!1);
              return node.parameterName = typePredicateVariable, node.typeAnnotation = type, node.asserts = asserts, 
              t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
            }));
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
          }
          tsTryParseTypeAnnotation() {
            return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const id = this.parseIdentifier();
            if (this.isContextual(113) && !this.hasPrecedingLineBreak()) return this.next(), 
            id;
          }
          tsParseTypePredicateAsserts() {
            if (106 !== this.state.type) return !1;
            const containsEsc = this.state.containsEsc;
            return this.next(), !(!tokenIsIdentifier(this.state.type) && !this.match(78)) && (containsEsc && this.raise(Errors.InvalidEscapedReservedWord, {
              at: this.state.lastTokStartLoc,
              reservedWord: "asserts"
            }), !0);
          }
          tsParseTypeAnnotation(eatColon = !0, t = this.startNode()) {
            return this.tsInType((() => {
              eatColon && this.expect(14), t.typeAnnotation = this.tsParseType();
            })), this.finishNode(t, "TSTypeAnnotation");
          }
          tsParseType() {
            assert(this.state.inType);
            const type = this.tsParseNonConditionalType();
            if (this.hasPrecedingLineBreak() || !this.eat(81)) return type;
            const node = this.startNodeAtNode(type);
            return node.checkType = type, node.extendsType = this.tsParseNonConditionalType(), 
            this.expect(17), node.trueType = this.tsParseType(), this.expect(14), node.falseType = this.tsParseType(), 
            this.finishNode(node, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(120) && 77 === this.lookahead().type;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, {
              at: this.state.startLoc
            });
            const node = this.startNode(), _const = this.tsTryNextParseConstantContext();
            return node.typeAnnotation = _const || this.tsNextThenParseType(), this.expect(48), 
            node.expression = this.parseMaybeUnary(), this.finishNode(node, "TSTypeAssertion");
          }
          tsParseHeritageClause(token) {
            const originalStartLoc = this.state.startLoc, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
            return delimitedList.length || this.raise(TSErrors.EmptyHeritageClauseType, {
              at: originalStartLoc,
              token
            }), delimitedList;
          }
          tsParseExpressionWithTypeArguments() {
            const node = this.startNode();
            return node.expression = this.tsParseEntityName(), this.match(47) && (node.typeParameters = this.tsParseTypeArguments()), 
            this.finishNode(node, "TSExpressionWithTypeArguments");
          }
          tsParseInterfaceDeclaration(node, properties = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(125), properties.declare && (node.declare = !0), tokenIsIdentifier(this.state.type) ? (node.id = this.parseIdentifier(), 
            this.checkIdentifier(node.id, 130)) : (node.id = null, this.raise(TSErrors.MissingInterfaceName, {
              at: this.state.startLoc
            })), node.typeParameters = this.tsTryParseTypeParameters(), this.eat(81) && (node.extends = this.tsParseHeritageClause("extends"));
            const body = this.startNode();
            return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node.body = this.finishNode(body, "TSInterfaceBody"), 
            this.finishNode(node, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(node) {
            return node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 2), node.typeAnnotation = this.tsInType((() => {
              if (node.typeParameters = this.tsTryParseTypeParameters(), this.expect(29), this.isContextual(111) && 16 !== this.lookahead().type) {
                const node = this.startNode();
                return this.next(), this.finishNode(node, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            })), this.semicolon(), this.finishNode(node, "TSTypeAliasDeclaration");
          }
          tsInNoContext(cb) {
            const oldContext = this.state.context;
            this.state.context = [ oldContext[0] ];
            try {
              return cb();
            } finally {
              this.state.context = oldContext;
            }
          }
          tsInType(cb) {
            const oldInType = this.state.inType;
            this.state.inType = !0;
            try {
              return cb();
            } finally {
              this.state.inType = oldInType;
            }
          }
          tsEatThenParseType(token) {
            return this.match(token) ? this.tsNextThenParseType() : void 0;
          }
          tsExpectThenParseType(token) {
            return this.tsDoThenParseType((() => this.expect(token)));
          }
          tsNextThenParseType() {
            return this.tsDoThenParseType((() => this.next()));
          }
          tsDoThenParseType(cb) {
            return this.tsInType((() => (cb(), this.tsParseType())));
          }
          tsParseEnumMember() {
            const node = this.startNode();
            return node.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(!0), 
            this.eat(29) && (node.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(node, "TSEnumMember");
          }
          tsParseEnumDeclaration(node, properties = {}) {
            return properties.const && (node.const = !0), properties.declare && (node.declare = !0), 
            this.expectContextual(122), node.id = this.parseIdentifier(), this.checkIdentifier(node.id, node.const ? 779 : 267), 
            this.expect(5), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), 
            this.expect(8), this.finishNode(node, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const node = this.startNode();
            return this.scope.enter(0), this.expect(5), this.parseBlockOrModuleBlockBody(node.body = [], void 0, !0, 8), 
            this.scope.exit(), this.finishNode(node, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(node, nested = !1) {
            if (node.id = this.parseIdentifier(), nested || this.checkIdentifier(node.id, 1024), 
            this.eat(16)) {
              const inner = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(inner, !0), node.body = inner;
            } else this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), 
            this.prodParam.exit(), this.scope.exit();
            return this.finishNode(node, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(node) {
            return this.isContextual(109) ? (node.global = !0, node.id = this.parseIdentifier()) : this.match(129) ? node.id = this.parseExprAtom() : this.unexpected(), 
            this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), 
            this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(node, isExport) {
            node.isExport = isExport || !1, node.id = this.parseIdentifier(), this.checkIdentifier(node.id, 9), 
            this.expect(29);
            const moduleReference = this.tsParseModuleReference();
            return "type" === node.importKind && "TSExternalModuleReference" !== moduleReference.type && this.raise(TSErrors.ImportAliasHasImportType, {
              at: moduleReference
            }), node.moduleReference = moduleReference, this.semicolon(), this.finishNode(node, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(116) && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
          }
          tsParseExternalModuleReference() {
            const node = this.startNode();
            if (this.expectContextual(116), this.expect(10), !this.match(129)) throw this.unexpected();
            return node.expression = this.parseExprAtom(), this.expect(11), this.finishNode(node, "TSExternalModuleReference");
          }
          tsLookAhead(f) {
            const state = this.state.clone(), res = f();
            return this.state = state, res;
          }
          tsTryParseAndCatch(f) {
            const result = this.tryParse((abort => f() || abort()));
            if (!result.aborted && result.node) return result.error && (this.state = result.failState), 
            result.node;
          }
          tsTryParse(f) {
            const state = this.state.clone(), result = f();
            return void 0 !== result && !1 !== result ? result : void (this.state = state);
          }
          tsTryParseDeclare(nany) {
            if (this.isLineTerminator()) return;
            let kind, starttype = this.state.type;
            return this.isContextual(99) && (starttype = 74, kind = "let"), this.tsInAmbientContext((() => {
              if (68 === starttype) return nany.declare = !0, this.parseFunctionStatement(nany, !1, !0);
              if (80 === starttype) return nany.declare = !0, this.parseClass(nany, !0, !1);
              if (122 === starttype) return this.tsParseEnumDeclaration(nany, {
                declare: !0
              });
              if (109 === starttype) return this.tsParseAmbientExternalModuleDeclaration(nany);
              if (75 === starttype || 74 === starttype) return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), 
              this.tsParseEnumDeclaration(nany, {
                const: !0,
                declare: !0
              })) : (nany.declare = !0, this.parseVarStatement(nany, kind || this.state.value, !0));
              if (125 === starttype) {
                const result = this.tsParseInterfaceDeclaration(nany, {
                  declare: !0
                });
                if (result) return result;
              }
              return tokenIsIdentifier(starttype) ? this.tsParseDeclaration(nany, this.state.value, !0) : void 0;
            }));
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, !0);
          }
          tsParseExpressionStatement(node, expr) {
            switch (expr.name) {
             case "declare":
              {
                const declaration = this.tsTryParseDeclare(node);
                if (declaration) return declaration.declare = !0, declaration;
                break;
              }

             case "global":
              if (this.match(5)) {
                this.scope.enter(256), this.prodParam.enter(0);
                const mod = node;
                return mod.global = !0, mod.id = expr, mod.body = this.tsParseModuleBlock(), this.scope.exit(), 
                this.prodParam.exit(), this.finishNode(mod, "TSModuleDeclaration");
              }
              break;

             default:
              return this.tsParseDeclaration(node, expr.name, !1);
            }
          }
          tsParseDeclaration(node, value, next) {
            switch (value) {
             case "abstract":
              if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) return this.tsParseAbstractDeclaration(node);
              break;

             case "module":
              if (this.tsCheckLineTerminator(next)) {
                if (this.match(129)) return this.tsParseAmbientExternalModuleDeclaration(node);
                if (tokenIsIdentifier(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
              }
              break;

             case "namespace":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(node);
              break;

             case "type":
              if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) return this.tsParseTypeAliasDeclaration(node);
            }
          }
          tsCheckLineTerminator(next) {
            return next ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
            if (!this.match(47)) return;
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = !0;
            const res = this.tsTryParseAndCatch((() => {
              const node = this.startNodeAt(startPos, startLoc);
              return node.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(node), 
              node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), 
              node;
            }));
            return this.state.maybeInArrowParameters = oldMaybeInArrowParameters, res ? this.parseArrowExpression(res, null, !0) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const node = this.startNode();
            return node.params = this.tsInType((() => this.tsInNoContext((() => (this.expect(47), 
            this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))))), 
            0 === node.params.length && this.raise(TSErrors.EmptyTypeArguments, {
              at: node
            }), this.expect(48), this.finishNode(node, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (token = this.state.type) >= 120 && token <= 126;
            var token;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(allowModifiers, decorators) {
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let accessibility, readonly = !1, override = !1;
            if (void 0 !== allowModifiers) {
              const modified = {};
              this.tsParseModifiers({
                modified,
                allowedModifiers: [ "public", "private", "protected", "override", "readonly" ]
              }), accessibility = modified.accessibility, override = modified.override, readonly = modified.readonly, 
              !1 === allowModifiers && (accessibility || readonly || override) && this.raise(TSErrors.UnexpectedParameterModifier, {
                at: startLoc
              });
            }
            const left = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(left);
            const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
            if (accessibility || readonly || override) {
              const pp = this.startNodeAt(startPos, startLoc);
              return decorators.length && (pp.decorators = decorators), accessibility && (pp.accessibility = accessibility), 
              readonly && (pp.readonly = readonly), override && (pp.override = override), "Identifier" !== elt.type && "AssignmentPattern" !== elt.type && this.raise(TSErrors.UnsupportedParameterPropertyKind, {
                at: pp
              }), pp.parameter = elt, this.finishNode(pp, "TSParameterProperty");
            }
            return decorators.length && (left.decorators = decorators), elt;
          }
          isSimpleParameter(node) {
            return "TSParameterProperty" === node.type && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
          }
          parseFunctionBodyAndFinish(node, type, isMethod = !1) {
            this.match(14) && (node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const bodilessType = "FunctionDeclaration" === type ? "TSDeclareFunction" : "ClassMethod" === type || "ClassPrivateMethod" === type ? "TSDeclareMethod" : void 0;
            bodilessType && !this.match(5) && this.isLineTerminator() ? this.finishNode(node, bodilessType) : "TSDeclareFunction" === bodilessType && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, {
              at: node
            }), node.declare) ? super.parseFunctionBodyAndFinish(node, bodilessType, isMethod) : super.parseFunctionBodyAndFinish(node, type, isMethod);
          }
          registerFunctionStatementId(node) {
            !node.body && node.id ? this.checkIdentifier(node.id, 1024) : super.registerFunctionStatementId(...arguments);
          }
          tsCheckForInvalidTypeCasts(items) {
            items.forEach((node => {
              "TSTypeCastExpression" === (null == node ? void 0 : node.type) && this.raise(TSErrors.UnexpectedTypeAnnotation, {
                at: node.typeAnnotation
              });
            }));
          }
          toReferencedList(exprList, isInParens) {
            return this.tsCheckForInvalidTypeCasts(exprList), exprList;
          }
          parseArrayLike(...args) {
            const node = super.parseArrayLike(...args);
            return "ArrayExpression" === node.type && this.tsCheckForInvalidTypeCasts(node.elements), 
            node;
          }
          parseSubscript(base, startPos, startLoc, noCalls, state) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = !1, this.next();
              const nonNullExpression = this.startNodeAt(startPos, startLoc);
              return nonNullExpression.expression = base, this.finishNode(nonNullExpression, "TSNonNullExpression");
            }
            let isOptionalCall = !1;
            if (this.match(18) && 60 === this.lookaheadCharCode()) {
              if (noCalls) return state.stop = !0, base;
              state.optionalChainMember = isOptionalCall = !0, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let missingParenErrorLoc;
              const result = this.tsTryParseAndCatch((() => {
                if (!noCalls && this.atPossibleAsyncArrow(base)) {
                  const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
                  if (asyncArrowFn) return asyncArrowFn;
                }
                const node = this.startNodeAt(startPos, startLoc);
                node.callee = base;
                const typeArguments = this.tsParseTypeArgumentsInExpression();
                if (typeArguments) {
                  if (isOptionalCall && !this.match(10) && (missingParenErrorLoc = this.state.curPosition(), 
                  this.unexpected()), !noCalls && this.eat(10)) return node.arguments = this.parseCallExpressionArguments(11, !1), 
                  this.tsCheckForInvalidTypeCasts(node.arguments), node.typeParameters = typeArguments, 
                  state.optionalChainMember && (node.optional = isOptionalCall), this.finishCallExpression(node, state.optionalChainMember);
                  if (tokenIsTemplate(this.state.type)) {
                    const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
                    return result.typeParameters = typeArguments, result;
                  }
                }
                this.unexpected();
              }));
              if (missingParenErrorLoc && this.unexpected(missingParenErrorLoc, 10), result) return result;
            }
            return super.parseSubscript(base, startPos, startLoc, noCalls, state);
          }
          parseNewArguments(node) {
            if (this.match(47) || this.match(51)) {
              const typeParameters = this.tsTryParseAndCatch((() => {
                const args = this.tsParseTypeArgumentsInExpression();
                return this.match(10) || this.unexpected(), args;
              }));
              typeParameters && (node.typeParameters = typeParameters);
            }
            super.parseNewArguments(node);
          }
          parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
            if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
              const node = this.startNodeAt(leftStartPos, leftStartLoc);
              node.expression = left;
              const _const = this.tsTryNextParseConstantContext();
              return node.typeAnnotation = _const || this.tsNextThenParseType(), this.finishNode(node, "TSAsExpression"), 
              this.reScan_lt_gt(), this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
            }
            return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
          }
          checkReservedWord(word, startLoc, checkKeywords, isBinding) {
            this.state.isAmbientContext || super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
          }
          checkDuplicateExports() {}
          parseImport(node) {
            if (node.importKind = "value", tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {
              let ahead = this.lookahead();
              if (this.isContextual(126) && 12 !== ahead.type && 97 !== ahead.type && 29 !== ahead.type && (node.importKind = "type", 
              this.next(), ahead = this.lookahead()), tokenIsIdentifier(this.state.type) && 29 === ahead.type) return this.tsParseImportEqualsDeclaration(node);
            }
            const importNode = super.parseImport(node);
            return "type" === importNode.importKind && importNode.specifiers.length > 1 && "ImportDefaultSpecifier" === importNode.specifiers[0].type && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
              at: importNode
            }), importNode;
          }
          parseExport(node) {
            if (this.match(83)) return this.next(), this.isContextual(126) && 61 !== this.lookaheadCharCode() ? (node.importKind = "type", 
            this.next()) : node.importKind = "value", this.tsParseImportEqualsDeclaration(node, !0);
            if (this.eat(29)) {
              const assign = node;
              return assign.expression = this.parseExpression(), this.semicolon(), this.finishNode(assign, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const decl = node;
              return this.expectContextual(124), decl.id = this.parseIdentifier(), this.semicolon(), 
              this.finishNode(decl, "TSNamespaceExportDeclaration");
            }
            return this.isContextual(126) && 5 === this.lookahead().type ? (this.next(), node.exportKind = "type") : node.exportKind = "value", 
            super.parseExport(node);
          }
          isAbstractClass() {
            return this.isContextual(120) && 80 === this.lookahead().type;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const cls = this.startNode();
              return this.next(), cls.abstract = !0, this.parseClass(cls, !0, !0), cls;
            }
            if (this.match(125)) {
              const result = this.tsParseInterfaceDeclaration(this.startNode());
              if (result) return result;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(node, kind, allowMissingInitializer = !1) {
            const {isAmbientContext} = this.state, declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
            if (!isAmbientContext) return declaration;
            for (const {id, init} of declaration.declarations) init && ("const" !== kind || id.typeAnnotation ? this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
              at: init
            }) : "StringLiteral" !== init.type && "BooleanLiteral" !== init.type && "NumericLiteral" !== init.type && "BigIntLiteral" !== init.type && ("TemplateLiteral" !== init.type || init.expressions.length > 0) && !isPossiblyLiteralEnum(init) && this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
              at: init
            }));
            return declaration;
          }
          parseStatementContent(context, topLevel) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const node = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(node, {
                const: !0
              });
            }
            if (this.isContextual(122)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(125)) {
              const result = this.tsParseInterfaceDeclaration(this.startNode());
              if (result) return result;
            }
            return super.parseStatementContent(context, topLevel);
          }
          parseAccessModifier() {
            return this.tsParseModifier([ "public", "protected", "private" ]);
          }
          tsHasSomeModifiers(member, modifiers) {
            return modifiers.some((modifier => tsIsAccessModifier(modifier) ? member.accessibility === modifier : !!member[modifier]));
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(104) && 123 === this.lookaheadCharCode();
          }
          parseClassMember(classBody, member, state) {
            const modifiers = [ "declare", "private", "public", "protected", "override", "abstract", "readonly", "static" ];
            this.tsParseModifiers({
              modified: member,
              allowedModifiers: modifiers,
              stopOnStartOfClassStaticBlock: !0
            });
            const callParseClassMemberWithIsStatic = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(member, modifiers) && this.raise(TSErrors.StaticBlockCannotHaveModifier, {
                at: this.state.curPosition()
              }), this.parseClassStaticBlock(classBody, member)) : this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
            };
            member.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
          }
          parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
            const idx = this.tsTryParseIndexSignature(member);
            if (idx) return classBody.body.push(idx), member.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, {
              at: member
            }), member.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, {
              at: member,
              modifier: member.accessibility
            }), member.declare && this.raise(TSErrors.IndexSignatureHasDeclare, {
              at: member
            }), void (member.override && this.raise(TSErrors.IndexSignatureHasOverride, {
              at: member
            }));
            !this.state.inAbstractClass && member.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
              at: member
            }), member.override && (state.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, {
              at: member
            })), super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
          parsePostMemberNameModifiers(methodOrProp) {
            this.eat(17) && (methodOrProp.optional = !0), methodOrProp.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, {
              at: methodOrProp
            }), methodOrProp.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, {
              at: methodOrProp
            });
          }
          parseExpressionStatement(node, expr) {
            return ("Identifier" === expr.type ? this.tsParseExpressionStatement(node, expr) : void 0) || super.parseExpressionStatement(node, expr);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(expr, startPos, startLoc, refExpressionErrors) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
            const result = this.tryParse((() => super.parseConditional(expr, startPos, startLoc)));
            return result.node ? (result.error && (this.state = result.failState), result.node) : (result.error && super.setOptionalParametersError(refExpressionErrors, result.error), 
            expr);
          }
          parseParenItem(node, startPos, startLoc) {
            if (node = super.parseParenItem(node, startPos, startLoc), this.eat(17) && (node.optional = !0, 
            this.resetEndLocation(node)), this.match(14)) {
              const typeCastNode = this.startNodeAt(startPos, startLoc);
              return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), 
              this.finishNode(typeCastNode, "TSTypeCastExpression");
            }
            return node;
          }
          parseExportDeclaration(node) {
            if (!this.state.isAmbientContext && this.isContextual(121)) return this.tsInAmbientContext((() => this.parseExportDeclaration(node)));
            const startPos = this.state.start, startLoc = this.state.startLoc, isDeclare = this.eatContextual(121);
            if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
              at: this.state.startLoc
            });
            const declaration = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
            return declaration ? (("TSInterfaceDeclaration" === declaration.type || "TSTypeAliasDeclaration" === declaration.type || isDeclare) && (node.exportKind = "type"), 
            isDeclare && (this.resetStartLocation(declaration, startPos, startLoc), declaration.declare = !0), 
            declaration) : null;
          }
          parseClassId(node, isStatement, optionalId) {
            if ((!isStatement || optionalId) && this.isContextual(110)) return;
            super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 139);
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (node.typeParameters = typeParameters);
          }
          parseClassPropertyAnnotation(node) {
            !node.optional && this.eat(35) && (node.definite = !0);
            const type = this.tsTryParseTypeAnnotation();
            type && (node.typeAnnotation = type);
          }
          parseClassProperty(node) {
            if (this.parseClassPropertyAnnotation(node), this.state.isAmbientContext && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, {
              at: this.state.startLoc
            }), node.abstract && this.match(29)) {
              const {key} = node;
              this.raise(TSErrors.AbstractPropertyHasInitializer, {
                at: this.state.startLoc,
                propertyName: "Identifier" !== key.type || node.computed ? `[${this.input.slice(key.start, key.end)}]` : key.name
              });
            }
            return super.parseClassProperty(node);
          }
          parseClassPrivateProperty(node) {
            return node.abstract && this.raise(TSErrors.PrivateElementHasAbstract, {
              at: node
            }), node.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, {
              at: node,
              modifier: node.accessibility
            }), this.parseClassPropertyAnnotation(node), super.parseClassPrivateProperty(node);
          }
          pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && isConstructor && this.raise(TSErrors.ConstructorHasTypeParameters, {
              at: typeParameters
            });
            const {declare = !1, kind} = method;
            !declare || "get" !== kind && "set" !== kind || this.raise(TSErrors.DeclareAccessor, {
              at: method,
              kind
            }), typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
          }
          pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
          }
          declareClassPrivateMethodInScope(node, kind) {
            "TSDeclareMethod" !== node.type && ("MethodDefinition" !== node.type || node.value.body) && super.declareClassPrivateMethodInScope(node, kind);
          }
          parseClassSuper(node) {
            super.parseClassSuper(node), node.superClass && (this.match(47) || this.match(51)) && (node.superTypeParameters = this.tsParseTypeArgumentsInExpression()), 
            this.eatContextual(110) && (node.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(prop, ...args) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, ...args);
          }
          parseFunctionParams(node, allowModifiers) {
            const typeParameters = this.tsTryParseTypeParameters();
            typeParameters && (node.typeParameters = typeParameters), super.parseFunctionParams(node, allowModifiers);
          }
          parseVarId(decl, kind) {
            super.parseVarId(decl, kind), "Identifier" === decl.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (decl.definite = !0);
            const type = this.tsTryParseTypeAnnotation();
            type && (decl.id.typeAnnotation = type, this.resetEndLocation(decl.id));
          }
          parseAsyncArrowFromCallExpression(node, call) {
            return this.match(14) && (node.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(node, call);
          }
          parseMaybeAssign(...args) {
            var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
            let state, jsx, typeCast, typeParameters;
            if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
              if (state = this.state.clone(), jsx = this.tryParse((() => super.parseMaybeAssign(...args)), state), 
              !jsx.error) return jsx.node;
              const {context} = this.state, currentContext = context[context.length - 1];
              currentContext !== types.j_oTag && currentContext !== types.j_expr || context.pop();
            }
            if (!(null != (_jsx = jsx) && _jsx.error || this.match(47))) return super.parseMaybeAssign(...args);
            state = state || this.state.clone();
            const arrow = this.tryParse((abort => {
              var _expr$extra, _typeParameters, _expr$typeParameters$;
              typeParameters = this.tsParseTypeParameters();
              const expr = super.parseMaybeAssign(...args);
              if (("ArrowFunctionExpression" !== expr.type || null != (_expr$extra = expr.extra) && _expr$extra.parenthesized) && abort(), 
              0 !== (null == (_typeParameters = typeParameters) ? void 0 : _typeParameters.params.length) && this.resetStartLocationFromNode(expr, typeParameters), 
              expr.typeParameters = typeParameters, this.hasPlugin("jsx") && 1 === expr.typeParameters.params.length && (null == (_expr$typeParameters$ = expr.typeParameters.extra) || !_expr$typeParameters$.trailingComma)) {
                expr.typeParameters.params[0].constraint;
              }
              return expr;
            }), state);
            if (!arrow.error && !arrow.aborted) return typeParameters && this.reportReservedArrowTypeParam(typeParameters), 
            arrow.node;
            if (!jsx && (assert(!this.hasPlugin("jsx")), typeCast = this.tryParse((() => super.parseMaybeAssign(...args)), state), 
            !typeCast.error)) return typeCast.node;
            if (null != (_jsx2 = jsx) && _jsx2.node) return this.state = jsx.failState, jsx.node;
            if (arrow.node) return this.state = arrow.failState, typeParameters && this.reportReservedArrowTypeParam(typeParameters), 
            arrow.node;
            if (null != (_typeCast = typeCast) && _typeCast.node) return this.state = typeCast.failState, 
            typeCast.node;
            if (null != (_jsx3 = jsx) && _jsx3.thrown) throw jsx.error;
            if (arrow.thrown) throw arrow.error;
            if (null != (_typeCast2 = typeCast) && _typeCast2.thrown) throw typeCast.error;
            throw (null == (_jsx4 = jsx) ? void 0 : _jsx4.error) || arrow.error || (null == (_typeCast3 = typeCast) ? void 0 : _typeCast3.error);
          }
          reportReservedArrowTypeParam(node) {
            var _node$extra;
            1 !== node.params.length || null != (_node$extra = node.extra) && _node$extra.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(TSErrors.ReservedArrowTypeParam, {
              at: node
            });
          }
          parseMaybeUnary(refExpressionErrors) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors);
          }
          parseArrow(node) {
            if (this.match(14)) {
              const result = this.tryParse((abort => {
                const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || abort(), returnType;
              }));
              if (result.aborted) return;
              result.thrown || (result.error && (this.state = result.failState), node.returnType = result.node);
            }
            return super.parseArrow(node);
          }
          parseAssignableListItemTypes(param) {
            this.eat(17) && ("Identifier" === param.type || this.state.isAmbientContext || this.state.inType || this.raise(TSErrors.PatternIsOptional, {
              at: param
            }), param.optional = !0);
            const type = this.tsTryParseTypeAnnotation();
            return type && (param.typeAnnotation = type), this.resetEndLocation(param), param;
          }
          isAssignable(node, isBinding) {
            switch (node.type) {
             case "TSTypeCastExpression":
              return this.isAssignable(node.expression, isBinding);

             case "TSParameterProperty":
              return !0;

             default:
              return super.isAssignable(node, isBinding);
            }
          }
          toAssignable(node, isLHS = !1) {
            switch (node.type) {
             case "TSTypeCastExpression":
              return super.toAssignable(this.typeCastToParameter(node), isLHS);

             case "TSParameterProperty":
             default:
              return super.toAssignable(node, isLHS);

             case "ParenthesizedExpression":
              return this.toAssignableParenthesizedExpression(node, isLHS);

             case "TSAsExpression":
             case "TSNonNullExpression":
             case "TSTypeAssertion":
              return node.expression = this.toAssignable(node.expression, isLHS), node;
            }
          }
          toAssignableParenthesizedExpression(node, isLHS) {
            switch (node.expression.type) {
             case "TSAsExpression":
             case "TSNonNullExpression":
             case "TSTypeAssertion":
             case "ParenthesizedExpression":
              return node.expression = this.toAssignable(node.expression, isLHS), node;

             default:
              return super.toAssignable(node, isLHS);
            }
          }
          isValidLVal(type, isParenthesized, binding) {
            return object = {
              TSTypeCastExpression: !0,
              TSParameterProperty: "parameter",
              TSNonNullExpression: "expression",
              TSAsExpression: (64 !== binding || isParenthesized) && [ "expression", !0 ],
              TSTypeAssertion: (64 !== binding || isParenthesized) && [ "expression", !0 ]
            }, key = type, Object.hasOwnProperty.call(object, key) && object[key] || super.isValidLVal(type, isParenthesized, binding);
            var object, key;
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(expr) {
            if (this.match(47) || this.match(51)) {
              const typeArguments = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const call = super.parseMaybeDecoratorArguments(expr);
                return call.typeParameters = typeArguments, call;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(expr);
          }
          checkCommaAfterRest(close) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close ? (this.next(), 
            !1) : super.checkCommaAfterRest(close);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(...args) {
            const node = super.parseMaybeDefault(...args);
            return "AssignmentPattern" === node.type && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, {
              at: node.typeAnnotation
            }), node;
          }
          getTokenFromCode(code) {
            if (this.state.inType) {
              if (62 === code) return this.finishOp(48, 1);
              if (60 === code) return this.finishOp(47, 1);
            }
            return super.getTokenFromCode(code);
          }
          reScan_lt_gt() {
            const {type} = this.state;
            47 === type ? (this.state.pos -= 1, this.readToken_lt()) : 48 === type && (this.state.pos -= 1, 
            this.readToken_gt());
          }
          reScan_lt() {
            const {type} = this.state;
            return 51 === type ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : type;
          }
          toAssignableList(exprList) {
            for (let i = 0; i < exprList.length; i++) {
              const expr = exprList[i];
              if (expr) switch (expr.type) {
               case "TSTypeCastExpression":
                exprList[i] = this.typeCastToParameter(expr);
                break;

               case "TSAsExpression":
               case "TSTypeAssertion":
                this.state.maybeInArrowParameters ? this.raise(TSErrors.UnexpectedTypeCastInParameter, {
                  at: expr
                }) : exprList[i] = this.typeCastToParameter(expr);
              }
            }
            return super.toAssignableList(...arguments);
          }
          typeCastToParameter(node) {
            return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.loc.end), 
            node.expression;
          }
          shouldParseArrow(params) {
            return this.match(14) ? params.every((expr => this.isAssignable(expr, !0))) : super.shouldParseArrow(params);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(node) {
            if (this.match(47) || this.match(51)) {
              const typeArguments = this.tsTryParseAndCatch((() => this.tsParseTypeArgumentsInExpression()));
              typeArguments && (node.typeParameters = typeArguments);
            }
            return super.jsxParseOpeningElementAfterName(node);
          }
          getGetterSetterExpectedParamCount(method) {
            const baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = this.getObjectOrClassMethodParams(method)[0];
            return firstParam && this.isThisParam(firstParam) ? baseCount + 1 : baseCount;
          }
          parseCatchClauseParam() {
            const param = super.parseCatchClauseParam(), type = this.tsTryParseTypeAnnotation();
            return type && (param.typeAnnotation = type, this.resetEndLocation(param)), param;
          }
          tsInAmbientContext(cb) {
            const oldIsAmbientContext = this.state.isAmbientContext;
            this.state.isAmbientContext = !0;
            try {
              return cb();
            } finally {
              this.state.isAmbientContext = oldIsAmbientContext;
            }
          }
          parseClass(node, ...args) {
            const oldInAbstractClass = this.state.inAbstractClass;
            this.state.inAbstractClass = !!node.abstract;
            try {
              return super.parseClass(node, ...args);
            } finally {
              this.state.inAbstractClass = oldInAbstractClass;
            }
          }
          tsParseAbstractDeclaration(node) {
            if (this.match(80)) return node.abstract = !0, this.parseClass(node, !0, !1);
            if (this.isContextual(125)) {
              if (!this.hasFollowingLineBreak()) return node.abstract = !0, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
                at: node
              }), this.tsParseInterfaceDeclaration(node);
            } else this.unexpected(null, 80);
          }
          parseMethod(...args) {
            const method = super.parseMethod(...args);
            if (method.abstract) {
              if (this.hasPlugin("estree") ? !!method.value.body : !!method.body) {
                const {key} = method;
                this.raise(TSErrors.AbstractMethodHasImplementation, {
                  at: method,
                  methodName: "Identifier" !== key.type || method.computed ? `[${this.input.slice(key.start, key.end)}]` : key.name
                });
              }
            }
            return method;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), 
            super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), 
            super.getExpression();
          }
          parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
            return !isString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(node, !1, isInTypeExport), 
            this.finishNode(node, "ExportSpecifier")) : (node.exportKind = "value", super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
            return !importedIsString && isMaybeTypeOnly ? (this.parseTypeOnlyImportExportSpecifier(specifier, !0, isInTypeOnlyImport), 
            this.finishNode(specifier, "ImportSpecifier")) : (specifier.importKind = "value", 
            super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly));
          }
          parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
            const leftOfAsKey = isImport ? "imported" : "local", rightOfAsKey = isImport ? "local" : "exported";
            let rightOfAs, leftOfAs = node[leftOfAsKey], hasTypeSpecifier = !1, canParseAsKeyword = !0;
            const loc = leftOfAs.loc.start;
            if (this.isContextual(93)) {
              const firstAs = this.parseIdentifier();
              if (this.isContextual(93)) {
                const secondAs = this.parseIdentifier();
                tokenIsKeywordOrIdentifier(this.state.type) ? (hasTypeSpecifier = !0, leftOfAs = firstAs, 
                rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName(), canParseAsKeyword = !1) : (rightOfAs = secondAs, 
                canParseAsKeyword = !1);
              } else tokenIsKeywordOrIdentifier(this.state.type) ? (canParseAsKeyword = !1, rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName()) : (hasTypeSpecifier = !0, 
              leftOfAs = firstAs);
            } else tokenIsKeywordOrIdentifier(this.state.type) && (hasTypeSpecifier = !0, leftOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName());
            hasTypeSpecifier && isInTypeOnlyImportExport && this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
              at: loc
            }), node[leftOfAsKey] = leftOfAs, node[rightOfAsKey] = rightOfAs;
            node[isImport ? "importKind" : "exportKind"] = hasTypeSpecifier ? "type" : "value", 
            canParseAsKeyword && this.eatContextual(93) && (node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName()), 
            node[rightOfAsKey] || (node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey])), 
            isImport && this.checkIdentifier(node[rightOfAsKey], 9);
          }
        },
        v8intrinsic: superClass => class extends superClass {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const v8IntrinsicStartLoc = this.state.startLoc, node = this.startNode();
              if (this.next(), tokenIsIdentifier(this.state.type)) {
                const name = this.parseIdentifierName(this.state.start), identifier = this.createIdentifier(node, name);
                if (identifier.type = "V8IntrinsicIdentifier", this.match(10)) return identifier;
              }
              this.unexpected(v8IntrinsicStartLoc);
            }
          }
          parseExprAtom() {
            return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
          }
        },
        placeholders: superClass => class extends superClass {
          parsePlaceholder(expectedNode) {
            if (this.match(140)) {
              const node = this.startNode();
              return this.next(), this.assertNoSpace(), node.name = super.parseIdentifier(!0), 
              this.assertNoSpace(), this.expect(140), this.finishPlaceholder(node, expectedNode);
            }
          }
          finishPlaceholder(node, expectedNode) {
            const isFinished = !(!node.expectedNode || "Placeholder" !== node.type);
            return node.expectedNode = expectedNode, isFinished ? node : this.finishNode(node, "Placeholder");
          }
          getTokenFromCode(code) {
            return 37 === code && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(140, 2) : super.getTokenFromCode(...arguments);
          }
          parseExprAtom() {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
          }
          parseIdentifier() {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
          }
          checkReservedWord(word) {
            void 0 !== word && super.checkReservedWord(...arguments);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
          }
          isValidLVal(type, ...rest) {
            return "Placeholder" === type || super.isValidLVal(type, ...rest);
          }
          toAssignable(node) {
            return node && "Placeholder" === node.type && "Expression" === node.expectedNode ? (node.expectedNode = "Pattern", 
            node) : super.toAssignable(...arguments);
          }
          isLet(context) {
            if (super.isLet(context)) return !0;
            if (!this.isContextual(99)) return !1;
            if (context) return !1;
            return 140 === this.lookahead().type;
          }
          verifyBreakContinue(node) {
            node.label && "Placeholder" === node.label.type || super.verifyBreakContinue(...arguments);
          }
          parseExpressionStatement(node, expr) {
            if ("Placeholder" !== expr.type || expr.extra && expr.extra.parenthesized) return super.parseExpressionStatement(...arguments);
            if (this.match(14)) {
              const stmt = node;
              return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = this.parseStatement("label"), 
              this.finishNode(stmt, "LabeledStatement");
            }
            return this.semicolon(), node.name = expr.name, this.finishPlaceholder(node, "Statement");
          }
          parseBlock() {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
          }
          parseFunctionId() {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
          }
          parseClass(node, isStatement, optionalId) {
            const type = isStatement ? "ClassDeclaration" : "ClassExpression";
            this.next(), this.takeDecorators(node);
            const oldStrict = this.state.strict, placeholder = this.parsePlaceholder("Identifier");
            if (placeholder) {
              if (!(this.match(81) || this.match(140) || this.match(5))) {
                if (optionalId || !isStatement) return node.id = null, node.body = this.finishPlaceholder(placeholder, "ClassBody"), 
                this.finishNode(node, type);
                throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
                  at: this.state.startLoc
                });
              }
              node.id = placeholder;
            } else this.parseClassId(node, isStatement, optionalId);
            return this.parseClassSuper(node), node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict), 
            this.finishNode(node, type);
          }
          parseExport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder) return super.parseExport(...arguments);
            if (!this.isContextual(97) && !this.match(12)) return node.specifiers = [], node.source = null, 
            node.declaration = this.finishPlaceholder(placeholder, "Declaration"), this.finishNode(node, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            return specifier.exported = placeholder, node.specifiers = [ this.finishNode(specifier, "ExportDefaultSpecifier") ], 
            super.parseExport(node);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const next = this.nextTokenStart();
              if (this.isUnparsedContextual(next, "from") && this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) return !0;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(node) {
            return !!(node.specifiers && node.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
          }
          checkExport(node) {
            const {specifiers} = node;
            null != specifiers && specifiers.length && (node.specifiers = specifiers.filter((node => "Placeholder" === node.exported.type))), 
            super.checkExport(node), node.specifiers = specifiers;
          }
          parseImport(node) {
            const placeholder = this.parsePlaceholder("Identifier");
            if (!placeholder) return super.parseImport(...arguments);
            if (node.specifiers = [], !this.isContextual(97) && !this.match(12)) return node.source = this.finishPlaceholder(placeholder, "StringLiteral"), 
            this.semicolon(), this.finishNode(node, "ImportDeclaration");
            const specifier = this.startNodeAtNode(placeholder);
            if (specifier.local = placeholder, this.finishNode(specifier, "ImportDefaultSpecifier"), 
            node.specifiers.push(specifier), this.eat(12)) {
              this.maybeParseStarImportSpecifier(node) || this.parseNamedImportSpecifiers(node);
            }
            return this.expectContextual(97), node.source = this.parseImportSource(), this.semicolon(), 
            this.finishNode(node, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(PlaceholderErrors.UnexpectedSpace, {
              at: this.state.lastTokEndLoc
            });
          }
        }
      }, mixinPluginNames = Object.keys(mixinPlugins), defaultOptions = {
        sourceType: "script",
        sourceFilename: void 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: !1,
        allowReturnOutsideFunction: !1,
        allowImportExportEverywhere: !1,
        allowSuperOutsideMethod: !1,
        allowUndeclaredExports: !1,
        plugins: [],
        strictMode: null,
        ranges: !1,
        tokens: !1,
        createParenthesizedExpressions: !1,
        errorRecovery: !1,
        attachComment: !0
      };
      const unwrapParenthesizedExpression = node => "ParenthesizedExpression" === node.type ? unwrapParenthesizedExpression(node.expression) : node;
      const loopLabel = {
        kind: "loop"
      }, switchLabel = {
        kind: "switch"
      }, loneSurrogate = /[\uD800-\uDFFF]/u, keywordRelationalOperator = /in(?:stanceof)?/y;
      class Parser extends class extends class extends class extends class extends class extends class extends class extends class {
        constructor() {
          this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
        }
        hasPlugin(pluginConfig) {
          if ("string" == typeof pluginConfig) return this.plugins.has(pluginConfig);
          {
            const [pluginName, pluginOptions] = pluginConfig;
            if (!this.hasPlugin(pluginName)) return !1;
            const actualOptions = this.plugins.get(pluginName);
            for (const key of Object.keys(pluginOptions)) if ((null == actualOptions ? void 0 : actualOptions[key]) !== pluginOptions[key]) return !1;
            return !0;
          }
        }
        getPluginOption(plugin, name) {
          var _this$plugins$get;
          return null == (_this$plugins$get = this.plugins.get(plugin)) ? void 0 : _this$plugins$get[name];
        }
      } {
        addComment(comment) {
          this.filename && (comment.loc.filename = this.filename), this.state.comments.push(comment);
        }
        processComment(node) {
          const {commentStack} = this.state, commentStackLength = commentStack.length;
          if (0 === commentStackLength) return;
          let i = commentStackLength - 1;
          const lastCommentWS = commentStack[i];
          lastCommentWS.start === node.end && (lastCommentWS.leadingNode = node, i--);
          const {start: nodeStart} = node;
          for (;i >= 0; i--) {
            const commentWS = commentStack[i], commentEnd = commentWS.end;
            if (!(commentEnd > nodeStart)) {
              commentEnd === nodeStart && (commentWS.trailingNode = node);
              break;
            }
            commentWS.containingNode = node, this.finalizeComment(commentWS), commentStack.splice(i, 1);
          }
        }
        finalizeComment(commentWS) {
          const {comments} = commentWS;
          if (null !== commentWS.leadingNode || null !== commentWS.trailingNode) null !== commentWS.leadingNode && setTrailingComments(commentWS.leadingNode, comments), 
          null !== commentWS.trailingNode && function(node, comments) {
            void 0 === node.leadingComments ? node.leadingComments = comments : node.leadingComments.unshift(...comments);
          }(commentWS.trailingNode, comments); else {
            const {containingNode: node, start: commentStart} = commentWS;
            if (44 === this.input.charCodeAt(commentStart - 1)) switch (node.type) {
             case "ObjectExpression":
             case "ObjectPattern":
             case "RecordExpression":
              adjustInnerComments(node, node.properties, commentWS);
              break;

             case "CallExpression":
             case "OptionalCallExpression":
              adjustInnerComments(node, node.arguments, commentWS);
              break;

             case "FunctionDeclaration":
             case "FunctionExpression":
             case "ArrowFunctionExpression":
             case "ObjectMethod":
             case "ClassMethod":
             case "ClassPrivateMethod":
              adjustInnerComments(node, node.params, commentWS);
              break;

             case "ArrayExpression":
             case "ArrayPattern":
             case "TupleExpression":
              adjustInnerComments(node, node.elements, commentWS);
              break;

             case "ExportNamedDeclaration":
             case "ImportDeclaration":
              adjustInnerComments(node, node.specifiers, commentWS);
              break;

             default:
              setInnerComments(node, comments);
            } else setInnerComments(node, comments);
          }
        }
        finalizeRemainingComments() {
          const {commentStack} = this.state;
          for (let i = commentStack.length - 1; i >= 0; i--) this.finalizeComment(commentStack[i]);
          this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(node) {
          const {commentStack} = this.state, {length} = commentStack;
          if (0 === length) return;
          const commentWS = commentStack[length - 1];
          commentWS.leadingNode === node && (commentWS.leadingNode = null);
        }
        takeSurroundingComments(node, start, end) {
          const {commentStack} = this.state, commentStackLength = commentStack.length;
          if (0 === commentStackLength) return;
          let i = commentStackLength - 1;
          for (;i >= 0; i--) {
            const commentWS = commentStack[i], commentEnd = commentWS.end;
            if (commentWS.start === end) commentWS.leadingNode = node; else if (commentEnd === start) commentWS.trailingNode = node; else if (commentEnd < start) break;
          }
        }
      } {
        constructor(options, input) {
          super(), this.isLookahead = void 0, this.tokens = [], this.state = new State, this.state.init(options), 
          this.input = input, this.length = input.length, this.isLookahead = !1;
        }
        pushToken(token) {
          this.tokens.length = this.state.tokensLength, this.tokens.push(token), ++this.state.tokensLength;
        }
        next() {
          this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state)), 
          this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, 
          this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
        }
        eat(type) {
          return !!this.match(type) && (this.next(), !0);
        }
        match(type) {
          return this.state.type === type;
        }
        createLookaheadState(state) {
          return {
            pos: state.pos,
            value: null,
            type: state.type,
            start: state.start,
            end: state.end,
            context: [ this.curContext() ],
            inType: state.inType,
            startLoc: state.startLoc,
            lastTokEndLoc: state.lastTokEndLoc,
            curLine: state.curLine,
            lineStart: state.lineStart,
            curPosition: state.curPosition
          };
        }
        lookahead() {
          const old = this.state;
          this.state = this.createLookaheadState(old), this.isLookahead = !0, this.nextToken(), 
          this.isLookahead = !1;
          const curr = this.state;
          return this.state = old, curr;
        }
        nextTokenStart() {
          return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(pos) {
          return skipWhiteSpace.lastIndex = pos, skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
        }
        lookaheadCharCode() {
          return this.input.charCodeAt(this.nextTokenStart());
        }
        codePointAtPos(pos) {
          let cp = this.input.charCodeAt(pos);
          if (55296 == (64512 & cp) && ++pos < this.input.length) {
            const trail = this.input.charCodeAt(pos);
            56320 == (64512 & trail) && (cp = 65536 + ((1023 & cp) << 10) + (1023 & trail));
          }
          return cp;
        }
        setStrict(strict) {
          this.state.strict = strict, strict && (this.state.strictErrors.forEach((([toParseError, at]) => this.raise(toParseError, {
            at
          }))), this.state.strictErrors.clear());
        }
        curContext() {
          return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
          this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), 
          this.state.pos >= this.length ? this.finishToken(135) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment() {
          let startLoc;
          this.isLookahead || (startLoc = this.state.curPosition());
          const start = this.state.pos, end = this.input.indexOf("*/", start + 2);
          if (-1 === end) throw this.raise(Errors.UnterminatedComment, {
            at: this.state.curPosition()
          });
          for (this.state.pos = end + 2, lineBreakG.lastIndex = start + 2; lineBreakG.test(this.input) && lineBreakG.lastIndex <= end; ) ++this.state.curLine, 
          this.state.lineStart = lineBreakG.lastIndex;
          if (this.isLookahead) return;
          const comment = {
            type: "CommentBlock",
            value: this.input.slice(start + 2, end),
            start,
            end: end + 2,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          return this.options.tokens && this.pushToken(comment), comment;
        }
        skipLineComment(startSkip) {
          const start = this.state.pos;
          let startLoc;
          this.isLookahead || (startLoc = this.state.curPosition());
          let ch = this.input.charCodeAt(this.state.pos += startSkip);
          if (this.state.pos < this.length) for (;!isNewLine(ch) && ++this.state.pos < this.length; ) ch = this.input.charCodeAt(this.state.pos);
          if (this.isLookahead) return;
          const end = this.state.pos, comment = {
            type: "CommentLine",
            value: this.input.slice(start + startSkip, end),
            start,
            end,
            loc: new SourceLocation(startLoc, this.state.curPosition())
          };
          return this.options.tokens && this.pushToken(comment), comment;
        }
        skipSpace() {
          const spaceStart = this.state.pos, comments = [];
          loop: for (;this.state.pos < this.length; ) {
            const ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
             case 32:
             case 160:
             case 9:
              ++this.state.pos;
              break;

             case 13:
              10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;

             case 10:
             case 8232:
             case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;

             case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
               case 42:
                {
                  const comment = this.skipBlockComment();
                  void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                  break;
                }

               case 47:
                {
                  const comment = this.skipLineComment(2);
                  void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                  break;
                }

               default:
                break loop;
              }
              break;

             default:
              if (isWhitespace(ch)) ++this.state.pos; else if (45 !== ch || this.inModule) {
                if (60 !== ch || this.inModule) break loop;
                {
                  const pos = this.state.pos;
                  if (33 !== this.input.charCodeAt(pos + 1) || 45 !== this.input.charCodeAt(pos + 2) || 45 !== this.input.charCodeAt(pos + 3)) break loop;
                  {
                    const comment = this.skipLineComment(4);
                    void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                  }
                }
              } else {
                const pos = this.state.pos;
                if (45 !== this.input.charCodeAt(pos + 1) || 62 !== this.input.charCodeAt(pos + 2) || !(0 === spaceStart || this.state.lineStart > spaceStart)) break loop;
                {
                  const comment = this.skipLineComment(3);
                  void 0 !== comment && (this.addComment(comment), this.options.attachComment && comments.push(comment));
                }
              }
            }
          }
          if (comments.length > 0) {
            const CommentWhitespace = {
              start: spaceStart,
              end: this.state.pos,
              comments,
              leadingNode: null,
              trailingNode: null,
              containingNode: null
            };
            this.state.commentStack.push(CommentWhitespace);
          }
        }
        finishToken(type, val) {
          this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
          const prevType = this.state.type;
          this.state.type = type, this.state.value = val, this.isLookahead || this.updateContext(prevType);
        }
        replaceToken(type) {
          this.state.type = type, this.updateContext();
        }
        readToken_numberSign() {
          if (0 === this.state.pos && this.readToken_interpreter()) return;
          const nextPos = this.state.pos + 1, next = this.codePointAtPos(nextPos);
          if (next >= 48 && next <= 57) throw this.raise(Errors.UnexpectedDigitAfterHash, {
            at: this.state.curPosition()
          });
          if (123 === next || 91 === next && this.hasPlugin("recordAndTuple")) {
            if (this.expectPlugin("recordAndTuple"), "hash" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(123 === next ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
            this.state.pos += 2, 123 === next ? this.finishToken(7) : this.finishToken(1);
          } else isIdentifierStart(next) ? (++this.state.pos, this.finishToken(134, this.readWord1(next))) : 92 === next ? (++this.state.pos, 
          this.finishToken(134, this.readWord1())) : this.finishOp(27, 1);
        }
        readToken_dot() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          next >= 48 && next <= 57 ? this.readNumber(!0) : 46 === next && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, 
          this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
        }
        readToken_slash() {
          61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
        }
        readToken_interpreter() {
          if (0 !== this.state.pos || this.length < 2) return !1;
          let ch = this.input.charCodeAt(this.state.pos + 1);
          if (33 !== ch) return !1;
          const start = this.state.pos;
          for (this.state.pos += 1; !isNewLine(ch) && ++this.state.pos < this.length; ) ch = this.input.charCodeAt(this.state.pos);
          const value = this.input.slice(start + 2, this.state.pos);
          return this.finishToken(28, value), !0;
        }
        readToken_mult_modulo(code) {
          let type = 42 === code ? 55 : 54, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
          42 === code && 42 === next && (width++, next = this.input.charCodeAt(this.state.pos + 2), 
          type = 57), 61 !== next || this.state.inType || (width++, type = 37 === code ? 33 : 30), 
          this.finishOp(type, width);
        }
        readToken_pipe_amp(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (next !== code) {
            if (124 === code) {
              if (62 === next) return void this.finishOp(39, 2);
              if (this.hasPlugin("recordAndTuple") && 125 === next) {
                if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
                return this.state.pos += 2, void this.finishToken(9);
              }
              if (this.hasPlugin("recordAndTuple") && 93 === next) {
                if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
                  at: this.state.curPosition()
                });
                return this.state.pos += 2, void this.finishToken(4);
              }
            }
            61 !== next ? this.finishOp(124 === code ? 43 : 45, 1) : this.finishOp(30, 2);
          } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === code ? 41 : 42, 2);
        }
        readToken_caret() {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (61 !== next || this.state.inType) if (94 === next && this.hasPlugin([ "pipelineOperator", {
            proposal: "hack",
            topicToken: "^^"
          } ])) {
            this.finishOp(37, 2);
            if (94 === this.input.codePointAt(this.state.pos)) throw this.unexpected();
          } else this.finishOp(44, 1); else this.finishOp(32, 2);
        }
        readToken_atSign() {
          64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin([ "pipelineOperator", {
            proposal: "hack",
            topicToken: "@@"
          } ]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
        }
        readToken_plus_min(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          next !== code ? 61 === next ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
        }
        readToken_lt() {
          const {pos} = this.state, next = this.input.charCodeAt(pos + 1);
          if (60 === next) return 61 === this.input.charCodeAt(pos + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
          61 !== next ? this.finishOp(47, 1) : this.finishOp(49, 2);
        }
        readToken_gt() {
          const {pos} = this.state, next = this.input.charCodeAt(pos + 1);
          if (62 === next) {
            const size = 62 === this.input.charCodeAt(pos + 2) ? 3 : 2;
            return 61 === this.input.charCodeAt(pos + size) ? void this.finishOp(30, size + 1) : void this.finishOp(52, size);
          }
          61 !== next ? this.finishOp(48, 1) : this.finishOp(49, 2);
        }
        readToken_eq_excl(code) {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (61 !== next) return 61 === code && 62 === next ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === code ? 29 : 35, 1);
          this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
        }
        readToken_question() {
          const next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
          63 === next ? 61 === next2 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== next || next2 >= 48 && next2 <= 57 ? (++this.state.pos, 
          this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
        }
        getTokenFromCode(code) {
          switch (code) {
           case 46:
            return void this.readToken_dot();

           case 40:
            return ++this.state.pos, void this.finishToken(10);

           case 41:
            return ++this.state.pos, void this.finishToken(11);

           case 59:
            return ++this.state.pos, void this.finishToken(13);

           case 44:
            return ++this.state.pos, void this.finishToken(12);

           case 91:
            if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
              if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
              this.state.pos += 2, this.finishToken(2);
            } else ++this.state.pos, this.finishToken(0);
            return;

           case 93:
            return ++this.state.pos, void this.finishToken(3);

           case 123:
            if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
              if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
                at: this.state.curPosition()
              });
              this.state.pos += 2, this.finishToken(6);
            } else ++this.state.pos, this.finishToken(5);
            return;

           case 125:
            return ++this.state.pos, void this.finishToken(8);

           case 58:
            return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, 
            this.finishToken(14)));

           case 63:
            return void this.readToken_question();

           case 96:
            return void this.readTemplateToken();

           case 48:
            {
              const next = this.input.charCodeAt(this.state.pos + 1);
              if (120 === next || 88 === next) return void this.readRadixNumber(16);
              if (111 === next || 79 === next) return void this.readRadixNumber(8);
              if (98 === next || 66 === next) return void this.readRadixNumber(2);
            }

           case 49:
           case 50:
           case 51:
           case 52:
           case 53:
           case 54:
           case 55:
           case 56:
           case 57:
            return void this.readNumber(!1);

           case 34:
           case 39:
            return void this.readString(code);

           case 47:
            return void this.readToken_slash();

           case 37:
           case 42:
            return void this.readToken_mult_modulo(code);

           case 124:
           case 38:
            return void this.readToken_pipe_amp(code);

           case 94:
            return void this.readToken_caret();

           case 43:
           case 45:
            return void this.readToken_plus_min(code);

           case 60:
            return void this.readToken_lt();

           case 62:
            return void this.readToken_gt();

           case 61:
           case 33:
            return void this.readToken_eq_excl(code);

           case 126:
            return void this.finishOp(36, 1);

           case 64:
            return void this.readToken_atSign();

           case 35:
            return void this.readToken_numberSign();

           case 92:
            return void this.readWord();

           default:
            if (isIdentifierStart(code)) return void this.readWord(code);
          }
          throw this.raise(Errors.InvalidOrUnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: String.fromCodePoint(code)
          });
        }
        finishOp(type, size) {
          const str = this.input.slice(this.state.pos, this.state.pos + size);
          this.state.pos += size, this.finishToken(type, str);
        }
        readRegexp() {
          const startLoc = this.state.startLoc, start = this.state.start + 1;
          let escaped, inClass, {pos} = this.state;
          for (;;++pos) {
            if (pos >= this.length) throw this.raise(Errors.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
            const ch = this.input.charCodeAt(pos);
            if (isNewLine(ch)) throw this.raise(Errors.UnterminatedRegExp, {
              at: createPositionWithColumnOffset(startLoc, 1)
            });
            if (escaped) escaped = !1; else {
              if (91 === ch) inClass = !0; else if (93 === ch && inClass) inClass = !1; else if (47 === ch && !inClass) break;
              escaped = 92 === ch;
            }
          }
          const content = this.input.slice(start, pos);
          ++pos;
          let mods = "";
          const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
          for (;pos < this.length; ) {
            const cp = this.codePointAtPos(pos), char = String.fromCharCode(cp);
            if (VALID_REGEX_FLAGS.has(cp)) 118 === cp ? (this.expectPlugin("regexpUnicodeSets", nextPos()), 
            mods.includes("u") && this.raise(Errors.IncompatibleRegExpUVFlags, {
              at: nextPos()
            })) : 117 === cp && mods.includes("v") && this.raise(Errors.IncompatibleRegExpUVFlags, {
              at: nextPos()
            }), mods.includes(char) && this.raise(Errors.DuplicateRegExpFlags, {
              at: nextPos()
            }); else {
              if (!isIdentifierChar(cp) && 92 !== cp) break;
              this.raise(Errors.MalformedRegExpFlags, {
                at: nextPos()
              });
            }
            ++pos, mods += char;
          }
          this.state.pos = pos, this.finishToken(133, {
            pattern: content,
            flags: mods
          });
        }
        readInt(radix, len, forceLen, allowNumSeparator = !0) {
          const start = this.state.pos, forbiddenSiblings = 16 === radix ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, isAllowedSibling = 16 === radix ? isAllowedNumericSeparatorSibling.hex : 10 === radix ? isAllowedNumericSeparatorSibling.dec : 8 === radix ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
          let invalid = !1, total = 0;
          for (let i = 0, e = null == len ? 1 / 0 : len; i < e; ++i) {
            const code = this.input.charCodeAt(this.state.pos);
            let val;
            if (95 !== code || "bail" === allowNumSeparator) {
              if (val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : _isDigit(code) ? code - 48 : 1 / 0, 
              val >= radix) if (this.options.errorRecovery && val <= 9) val = 0, this.raise(Errors.InvalidDigit, {
                at: this.state.curPosition(),
                radix
              }); else {
                if (!forceLen) break;
                val = 0, invalid = !0;
              }
              ++this.state.pos, total = total * radix + val;
            } else {
              const prev = this.input.charCodeAt(this.state.pos - 1), next = this.input.charCodeAt(this.state.pos + 1);
              allowNumSeparator ? (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) && this.raise(Errors.UnexpectedNumericSeparator, {
                at: this.state.curPosition()
              }) : this.raise(Errors.NumericSeparatorInEscapeSequence, {
                at: this.state.curPosition()
              }), ++this.state.pos;
            }
          }
          return this.state.pos === start || null != len && this.state.pos - start !== len || invalid ? null : total;
        }
        readRadixNumber(radix) {
          const startLoc = this.state.curPosition();
          let isBigInt = !1;
          this.state.pos += 2;
          const val = this.readInt(radix);
          null == val && this.raise(Errors.InvalidDigit, {
            at: createPositionWithColumnOffset(startLoc, 2),
            radix
          });
          const next = this.input.charCodeAt(this.state.pos);
          if (110 === next) ++this.state.pos, isBigInt = !0; else if (109 === next) throw this.raise(Errors.InvalidDecimal, {
            at: startLoc
          });
          if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
          });
          if (isBigInt) {
            const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
            this.finishToken(131, str);
          } else this.finishToken(130, val);
        }
        readNumber(startsWithDot) {
          const start = this.state.pos, startLoc = this.state.curPosition();
          let isFloat = !1, isBigInt = !1, isDecimal = !1, hasExponent = !1, isOctal = !1;
          startsWithDot || null !== this.readInt(10) || this.raise(Errors.InvalidNumber, {
            at: this.state.curPosition()
          });
          const hasLeadingZero = this.state.pos - start >= 2 && 48 === this.input.charCodeAt(start);
          if (hasLeadingZero) {
            const integer = this.input.slice(start, this.state.pos);
            if (this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
              at: startLoc
            }), !this.state.strict) {
              const underscorePos = integer.indexOf("_");
              underscorePos > 0 && this.raise(Errors.ZeroDigitNumericSeparator, {
                at: createPositionWithColumnOffset(startLoc, underscorePos)
              });
            }
            isOctal = hasLeadingZero && !/[89]/.test(integer);
          }
          let next = this.input.charCodeAt(this.state.pos);
          if (46 !== next || isOctal || (++this.state.pos, this.readInt(10), isFloat = !0, 
          next = this.input.charCodeAt(this.state.pos)), 69 !== next && 101 !== next || isOctal || (next = this.input.charCodeAt(++this.state.pos), 
          43 !== next && 45 !== next || ++this.state.pos, null === this.readInt(10) && this.raise(Errors.InvalidOrMissingExponent, {
            at: startLoc
          }), isFloat = !0, hasExponent = !0, next = this.input.charCodeAt(this.state.pos)), 
          110 === next && ((isFloat || hasLeadingZero) && this.raise(Errors.InvalidBigIntLiteral, {
            at: startLoc
          }), ++this.state.pos, isBigInt = !0), 109 === next && (this.expectPlugin("decimal", this.state.curPosition()), 
          (hasExponent || hasLeadingZero) && this.raise(Errors.InvalidDecimal, {
            at: startLoc
          }), ++this.state.pos, isDecimal = !0), isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(Errors.NumberIdentifier, {
            at: this.state.curPosition()
          });
          const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
          if (isBigInt) return void this.finishToken(131, str);
          if (isDecimal) return void this.finishToken(132, str);
          const val = isOctal ? parseInt(str, 8) : parseFloat(str);
          this.finishToken(130, val);
        }
        readCodePoint(throwOnInvalid) {
          let code;
          if (123 === this.input.charCodeAt(this.state.pos)) {
            if (++this.state.pos, code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, !0, throwOnInvalid), 
            ++this.state.pos, null !== code && code > 1114111) {
              if (!throwOnInvalid) return null;
              this.raise(Errors.InvalidCodePoint, {
                at: this.state.curPosition()
              });
            }
          } else code = this.readHexChar(4, !1, throwOnInvalid);
          return code;
        }
        readString(quote) {
          let out = "", chunkStart = ++this.state.pos;
          for (;;) {
            if (this.state.pos >= this.length) throw this.raise(Errors.UnterminatedString, {
              at: this.state.startLoc
            });
            const ch = this.input.charCodeAt(this.state.pos);
            if (ch === quote) break;
            if (92 === ch) out += this.input.slice(chunkStart, this.state.pos), out += this.readEscapedChar(!1), 
            chunkStart = this.state.pos; else if (8232 === ch || 8233 === ch) ++this.state.pos, 
            ++this.state.curLine, this.state.lineStart = this.state.pos; else {
              if (isNewLine(ch)) throw this.raise(Errors.UnterminatedString, {
                at: this.state.startLoc
              });
              ++this.state.pos;
            }
          }
          out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(129, out);
        }
        readTemplateContinuation() {
          this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
        }
        readTemplateToken() {
          let out = "", chunkStart = this.state.pos, containsInvalid = !1;
          for (++this.state.pos; ;) {
            if (this.state.pos >= this.length) throw this.raise(Errors.UnterminatedTemplate, {
              at: createPositionWithColumnOffset(this.state.startLoc, 1)
            });
            const ch = this.input.charCodeAt(this.state.pos);
            if (96 === ch) return ++this.state.pos, out += this.input.slice(chunkStart, this.state.pos), 
            void this.finishToken(24, containsInvalid ? null : out);
            if (36 === ch && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos += 2, 
            out += this.input.slice(chunkStart, this.state.pos), void this.finishToken(25, containsInvalid ? null : out);
            if (92 === ch) {
              out += this.input.slice(chunkStart, this.state.pos);
              const escaped = this.readEscapedChar(!0);
              null === escaped ? containsInvalid = !0 : out += escaped, chunkStart = this.state.pos;
            } else if (isNewLine(ch)) {
              switch (out += this.input.slice(chunkStart, this.state.pos), ++this.state.pos, ch) {
               case 13:
                10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;

               case 10:
                out += "\n";
                break;

               default:
                out += String.fromCharCode(ch);
              }
              ++this.state.curLine, this.state.lineStart = this.state.pos, chunkStart = this.state.pos;
            } else ++this.state.pos;
          }
        }
        recordStrictModeErrors(toParseError, {at}) {
          const index = at.index;
          this.state.strict && !this.state.strictErrors.has(index) ? this.raise(toParseError, {
            at
          }) : this.state.strictErrors.set(index, [ toParseError, at ]);
        }
        readEscapedChar(inTemplate) {
          const throwOnInvalid = !inTemplate, ch = this.input.charCodeAt(++this.state.pos);
          switch (++this.state.pos, ch) {
           case 110:
            return "\n";

           case 114:
            return "\r";

           case 120:
            {
              const code = this.readHexChar(2, !1, throwOnInvalid);
              return null === code ? null : String.fromCharCode(code);
            }

           case 117:
            {
              const code = this.readCodePoint(throwOnInvalid);
              return null === code ? null : String.fromCodePoint(code);
            }

           case 116:
            return "\t";

           case 98:
            return "\b";

           case 118:
            return "\v";

           case 102:
            return "\f";

           case 13:
            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;

           case 10:
            this.state.lineStart = this.state.pos, ++this.state.curLine;

           case 8232:
           case 8233:
            return "";

           case 56:
           case 57:
            if (inTemplate) return null;
            this.recordStrictModeErrors(Errors.StrictNumericEscape, {
              at: createPositionWithColumnOffset(this.state.curPosition(), -1)
            });

           default:
            if (ch >= 48 && ch <= 55) {
              const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1);
              let octalStr = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
              octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), 
              this.state.pos += octalStr.length - 1;
              const next = this.input.charCodeAt(this.state.pos);
              if ("0" !== octalStr || 56 === next || 57 === next) {
                if (inTemplate) return null;
                this.recordStrictModeErrors(Errors.StrictNumericEscape, {
                  at: codePos
                });
              }
              return String.fromCharCode(octal);
            }
            return String.fromCharCode(ch);
          }
        }
        readHexChar(len, forceLen, throwOnInvalid) {
          const codeLoc = this.state.curPosition(), n = this.readInt(16, len, forceLen, !1);
          return null === n && (throwOnInvalid ? this.raise(Errors.InvalidEscapeSequence, {
            at: codeLoc
          }) : this.state.pos = codeLoc.index - 1), n;
        }
        readWord1(firstCode) {
          this.state.containsEsc = !1;
          let word = "";
          const start = this.state.pos;
          let chunkStart = this.state.pos;
          for (void 0 !== firstCode && (this.state.pos += firstCode <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
            const ch = this.codePointAtPos(this.state.pos);
            if (isIdentifierChar(ch)) this.state.pos += ch <= 65535 ? 1 : 2; else {
              if (92 !== ch) break;
              {
                this.state.containsEsc = !0, word += this.input.slice(chunkStart, this.state.pos);
                const escStart = this.state.curPosition(), identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
                if (117 !== this.input.charCodeAt(++this.state.pos)) {
                  this.raise(Errors.MissingUnicodeEscape, {
                    at: this.state.curPosition()
                  }), chunkStart = this.state.pos - 1;
                  continue;
                }
                ++this.state.pos;
                const esc = this.readCodePoint(!0);
                null !== esc && (identifierCheck(esc) || this.raise(Errors.EscapedCharNotAnIdentifier, {
                  at: escStart
                }), word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
              }
            }
          }
          return word + this.input.slice(chunkStart, this.state.pos);
        }
        readWord(firstCode) {
          const word = this.readWord1(firstCode), type = keywords$1.get(word);
          void 0 !== type ? this.finishToken(type, tokenLabelName(type)) : this.finishToken(128, word);
        }
        checkKeywordEscapes() {
          const {type} = this.state;
          tokenIsKeyword(type) && this.state.containsEsc && this.raise(Errors.InvalidEscapedReservedWord, {
            at: this.state.startLoc,
            reservedWord: tokenLabelName(type)
          });
        }
        raise(toParseError, raiseProperties) {
          const {at} = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded), error = toParseError({
            loc: at instanceof Position ? at : at.loc.start,
            details
          });
          if (!this.options.errorRecovery) throw error;
          return this.isLookahead || this.state.errors.push(error), error;
        }
        raiseOverwrite(toParseError, raiseProperties) {
          const {at} = raiseProperties, details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2), loc = at instanceof Position ? at : at.loc.start, pos = loc.index, errors = this.state.errors;
          for (let i = errors.length - 1; i >= 0; i--) {
            const error = errors[i];
            if (error.loc.index === pos) return errors[i] = toParseError({
              loc,
              details
            });
            if (error.loc.index < pos) break;
          }
          return this.raise(toParseError, raiseProperties);
        }
        updateContext(prevType) {}
        unexpected(loc, type) {
          throw this.raise(Errors.UnexpectedToken, {
            expected: type ? tokenLabelName(type) : null,
            at: null != loc ? loc : this.state.startLoc
          });
        }
        expectPlugin(pluginName, loc) {
          if (this.hasPlugin(pluginName)) return !0;
          throw this.raise(Errors.MissingPlugin, {
            at: null != loc ? loc : this.state.startLoc,
            missingPlugin: [ pluginName ]
          });
        }
        expectOnePlugin(pluginNames) {
          if (!pluginNames.some((name => this.hasPlugin(name)))) throw this.raise(Errors.MissingOneOfPlugins, {
            at: this.state.startLoc,
            missingPlugin: pluginNames
          });
        }
      } {
        addExtra(node, key, value, enumerable = !0) {
          if (!node) return;
          const extra = node.extra = node.extra || {};
          enumerable ? extra[key] = value : Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
        isContextual(token) {
          return this.state.type === token && !this.state.containsEsc;
        }
        isUnparsedContextual(nameStart, name) {
          const nameEnd = nameStart + name.length;
          if (this.input.slice(nameStart, nameEnd) === name) {
            const nextCh = this.input.charCodeAt(nameEnd);
            return !(isIdentifierChar(nextCh) || 55296 == (64512 & nextCh));
          }
          return !1;
        }
        isLookaheadContextual(name) {
          const next = this.nextTokenStart();
          return this.isUnparsedContextual(next, name);
        }
        eatContextual(token) {
          return !!this.isContextual(token) && (this.next(), !0);
        }
        expectContextual(token, toParseError) {
          if (!this.eatContextual(token)) {
            if (null != toParseError) throw this.raise(toParseError, {
              at: this.state.startLoc
            });
            throw this.unexpected(null, token);
          }
        }
        canInsertSemicolon() {
          return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
          return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
        }
        hasFollowingLineBreak() {
          return skipWhiteSpaceToLineBreak.lastIndex = this.state.end, skipWhiteSpaceToLineBreak.test(this.input);
        }
        isLineTerminator() {
          return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(allowAsi = !0) {
          (allowAsi ? this.isLineTerminator() : this.eat(13)) || this.raise(Errors.MissingSemicolon, {
            at: this.state.lastTokEndLoc
          });
        }
        expect(type, loc) {
          this.eat(type) || this.unexpected(loc, type);
        }
        tryParse(fn, oldState = this.state.clone()) {
          const abortSignal = {
            node: null
          };
          try {
            const node = fn(((node = null) => {
              throw abortSignal.node = node, abortSignal;
            }));
            if (this.state.errors.length > oldState.errors.length) {
              const failState = this.state;
              return this.state = oldState, this.state.tokensLength = failState.tokensLength, 
              {
                node,
                error: failState.errors[oldState.errors.length],
                thrown: !1,
                aborted: !1,
                failState
              };
            }
            return {
              node,
              error: null,
              thrown: !1,
              aborted: !1,
              failState: null
            };
          } catch (error) {
            const failState = this.state;
            if (this.state = oldState, error instanceof SyntaxError) return {
              node: null,
              error,
              thrown: !0,
              aborted: !1,
              failState
            };
            if (error === abortSignal) return {
              node: abortSignal.node,
              error: null,
              thrown: !1,
              aborted: !0,
              failState
            };
            throw error;
          }
        }
        checkExpressionErrors(refExpressionErrors, andThrow) {
          if (!refExpressionErrors) return !1;
          const {shorthandAssignLoc, doubleProtoLoc, privateKeyLoc, optionalParametersLoc} = refExpressionErrors;
          if (!andThrow) return !!(shorthandAssignLoc || doubleProtoLoc || optionalParametersLoc || privateKeyLoc);
          null != shorthandAssignLoc && this.raise(Errors.InvalidCoverInitializedName, {
            at: shorthandAssignLoc
          }), null != doubleProtoLoc && this.raise(Errors.DuplicateProto, {
            at: doubleProtoLoc
          }), null != privateKeyLoc && this.raise(Errors.UnexpectedPrivateField, {
            at: privateKeyLoc
          }), null != optionalParametersLoc && this.unexpected(optionalParametersLoc);
        }
        isLiteralPropertyName() {
          return tokenIsLiteralPropertyName(this.state.type);
        }
        isPrivateName(node) {
          return "PrivateName" === node.type;
        }
        getPrivateNameSV(node) {
          return node.id.name;
        }
        hasPropertyAsPrivateName(node) {
          return ("MemberExpression" === node.type || "OptionalMemberExpression" === node.type) && this.isPrivateName(node.property);
        }
        isOptionalChain(node) {
          return "OptionalMemberExpression" === node.type || "OptionalCallExpression" === node.type;
        }
        isObjectProperty(node) {
          return "ObjectProperty" === node.type;
        }
        isObjectMethod(node) {
          return "ObjectMethod" === node.type;
        }
        initializeScopes(inModule = "module" === this.options.sourceType) {
          const oldLabels = this.state.labels;
          this.state.labels = [];
          const oldExportedIdentifiers = this.exportedIdentifiers;
          this.exportedIdentifiers = new Set;
          const oldInModule = this.inModule;
          this.inModule = inModule;
          const oldScope = this.scope, ScopeHandler = this.getScopeHandler();
          this.scope = new ScopeHandler(this, inModule);
          const oldProdParam = this.prodParam;
          this.prodParam = new ProductionParameterHandler;
          const oldClassScope = this.classScope;
          this.classScope = new ClassScopeHandler(this);
          const oldExpressionScope = this.expressionScope;
          return this.expressionScope = new ExpressionScopeHandler(this), () => {
            this.state.labels = oldLabels, this.exportedIdentifiers = oldExportedIdentifiers, 
            this.inModule = oldInModule, this.scope = oldScope, this.prodParam = oldProdParam, 
            this.classScope = oldClassScope, this.expressionScope = oldExpressionScope;
          };
        }
        enterInitialScopes() {
          let paramFlags = 0;
          this.inModule && (paramFlags |= 2), this.scope.enter(1), this.prodParam.enter(paramFlags);
        }
        checkDestructuringPrivate(refExpressionErrors) {
          const {privateKeyLoc} = refExpressionErrors;
          null !== privateKeyLoc && this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      } {
        startNode() {
          return new Node(this, this.state.start, this.state.startLoc);
        }
        startNodeAt(pos, loc) {
          return new Node(this, pos, loc);
        }
        startNodeAtNode(type) {
          return this.startNodeAt(type.start, type.loc.start);
        }
        finishNode(node, type) {
          return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
        }
        finishNodeAt(node, type, endLoc) {
          return node.type = type, node.end = endLoc.index, node.loc.end = endLoc, this.options.ranges && (node.range[1] = endLoc.index), 
          this.options.attachComment && this.processComment(node), node;
        }
        resetStartLocation(node, start, startLoc) {
          node.start = start, node.loc.start = startLoc, this.options.ranges && (node.range[0] = start);
        }
        resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
          node.end = endLoc.index, node.loc.end = endLoc, this.options.ranges && (node.range[1] = endLoc.index);
        }
        resetStartLocationFromNode(node, locationNode) {
          this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
        }
      } {
        toAssignable(node, isLHS = !1) {
          var _node$extra, _node$extra3;
          let parenthesized;
          switch (("ParenthesizedExpression" === node.type || null != (_node$extra = node.extra) && _node$extra.parenthesized) && (parenthesized = unwrapParenthesizedExpression(node), 
          isLHS ? "Identifier" === parenthesized.type ? this.expressionScope.recordParenthesizedIdentifierError({
            at: node
          }) : "MemberExpression" !== parenthesized.type && this.raise(Errors.InvalidParenthesizedAssignment, {
            at: node
          }) : this.raise(Errors.InvalidParenthesizedAssignment, {
            at: node
          })), node.type) {
           case "Identifier":
           case "ObjectPattern":
           case "ArrayPattern":
           case "AssignmentPattern":
           case "RestElement":
            break;

           case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i], isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS), isLast && "RestElement" === prop.type && null != (_node$extra2 = node.extra) && _node$extra2.trailingCommaLoc && this.raise(Errors.RestTrailingComma, {
                at: node.extra.trailingCommaLoc
              });
            }
            break;

           case "ObjectProperty":
            {
              const {key, value} = node;
              this.isPrivateName(key) && this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start), 
              this.toAssignable(value, isLHS);
              break;
            }

           case "SpreadElement":
            {
              this.checkToRestConversion(node), node.type = "RestElement";
              const arg = node.argument;
              this.toAssignable(arg, isLHS);
              break;
            }

           case "ArrayExpression":
            node.type = "ArrayPattern", this.toAssignableList(node.elements, null == (_node$extra3 = node.extra) ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;

           case "AssignmentExpression":
            "=" !== node.operator && this.raise(Errors.MissingEqInAssignment, {
              at: node.left.loc.end
            }), node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isLHS);
            break;

           case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
          }
          return node;
        }
        toAssignableObjectExpressionProp(prop, isLast, isLHS) {
          "ObjectMethod" === prop.type ? this.raise("get" === prop.kind || "set" === prop.kind ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
            at: prop.key
          }) : "SpreadElement" !== prop.type || isLast ? this.toAssignable(prop, isLHS) : this.raise(Errors.RestTrailingComma, {
            at: prop
          });
        }
        toAssignableList(exprList, trailingCommaLoc, isLHS) {
          let end = exprList.length;
          if (end) {
            const last = exprList[end - 1];
            if ("RestElement" === (null == last ? void 0 : last.type)) --end; else if ("SpreadElement" === (null == last ? void 0 : last.type)) {
              last.type = "RestElement";
              let arg = last.argument;
              this.toAssignable(arg, isLHS), arg = unwrapParenthesizedExpression(arg), "Identifier" !== arg.type && "MemberExpression" !== arg.type && "ArrayPattern" !== arg.type && "ObjectPattern" !== arg.type && this.unexpected(arg.start), 
              trailingCommaLoc && this.raise(Errors.RestTrailingComma, {
                at: trailingCommaLoc
              }), --end;
            }
          }
          for (let i = 0; i < end; i++) {
            const elt = exprList[i];
            elt && (this.toAssignable(elt, isLHS), "RestElement" === elt.type && this.raise(Errors.RestTrailingComma, {
              at: elt
            }));
          }
          return exprList;
        }
        isAssignable(node, isBinding) {
          switch (node.type) {
           case "Identifier":
           case "ObjectPattern":
           case "ArrayPattern":
           case "AssignmentPattern":
           case "RestElement":
            return !0;

           case "ObjectExpression":
            {
              const last = node.properties.length - 1;
              return node.properties.every(((prop, i) => "ObjectMethod" !== prop.type && (i === last || "SpreadElement" !== prop.type) && this.isAssignable(prop)));
            }

           case "ObjectProperty":
            return this.isAssignable(node.value);

           case "SpreadElement":
            return this.isAssignable(node.argument);

           case "ArrayExpression":
            return node.elements.every((element => null === element || this.isAssignable(element)));

           case "AssignmentExpression":
            return "=" === node.operator;

           case "ParenthesizedExpression":
            return this.isAssignable(node.expression);

           case "MemberExpression":
           case "OptionalMemberExpression":
            return !isBinding;

           default:
            return !1;
          }
        }
        toReferencedList(exprList, isParenthesizedExpr) {
          return exprList;
        }
        toReferencedListDeep(exprList, isParenthesizedExpr) {
          this.toReferencedList(exprList, isParenthesizedExpr);
          for (const expr of exprList) "ArrayExpression" === (null == expr ? void 0 : expr.type) && this.toReferencedListDeep(expr.elements);
        }
        parseSpread(refExpressionErrors, refNeedsArrowPos) {
          const node = this.startNode();
          return this.next(), node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0, refNeedsArrowPos), 
          this.finishNode(node, "SpreadElement");
        }
        parseRestBinding() {
          const node = this.startNode();
          return this.next(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
        }
        parseBindingAtom() {
          switch (this.state.type) {
           case 0:
            {
              const node = this.startNode();
              return this.next(), node.elements = this.parseBindingList(3, 93, !0), this.finishNode(node, "ArrayPattern");
            }

           case 5:
            return this.parseObjectLike(8, !0);
          }
          return this.parseIdentifier();
        }
        parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
          const elts = [];
          let first = !0;
          for (;!this.eat(close); ) if (first ? first = !1 : this.expect(12), allowEmpty && this.match(12)) elts.push(null); else {
            if (this.eat(close)) break;
            if (this.match(21)) {
              if (elts.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(closeCharCode)) {
                this.expect(close);
                break;
              }
            } else {
              const decorators = [];
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(Errors.UnsupportedParameterDecorator, {
                at: this.state.startLoc
              }); this.match(26); ) decorators.push(this.parseDecorator());
              elts.push(this.parseAssignableListItem(allowModifiers, decorators));
            }
          }
          return elts;
        }
        parseBindingRestProperty(prop) {
          return this.next(), prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), 
          this.finishNode(prop, "RestElement");
        }
        parseBindingProperty() {
          const prop = this.startNode(), {type, start: startPos, startLoc} = this.state;
          return 21 === type ? this.parseBindingRestProperty(prop) : (134 === type ? (this.expectPlugin("destructuringPrivate", startLoc), 
          this.classScope.usePrivateName(this.state.value, startLoc), prop.key = this.parsePrivateName()) : this.parsePropertyName(prop), 
          prop.method = !1, this.parseObjPropValue(prop, startPos, startLoc, !1, !1, !0, !1), 
          prop);
        }
        parseAssignableListItem(allowModifiers, decorators) {
          const left = this.parseMaybeDefault();
          this.parseAssignableListItemTypes(left);
          const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
          return decorators.length && (left.decorators = decorators), elt;
        }
        parseAssignableListItemTypes(param) {
          return param;
        }
        parseMaybeDefault(startPos, startLoc, left) {
          var _startLoc, _startPos, _left;
          if (startLoc = null != (_startLoc = startLoc) ? _startLoc : this.state.startLoc, 
          startPos = null != (_startPos = startPos) ? _startPos : this.state.start, left = null != (_left = left) ? _left : this.parseBindingAtom(), 
          !this.eat(29)) return left;
          const node = this.startNodeAt(startPos, startLoc);
          return node.left = left, node.right = this.parseMaybeAssignAllowIn(), this.finishNode(node, "AssignmentPattern");
        }
        isValidLVal(type, isParenthesized, binding) {
          return object = {
            AssignmentPattern: "left",
            RestElement: "argument",
            ObjectProperty: "value",
            ParenthesizedExpression: "expression",
            ArrayPattern: "elements",
            ObjectPattern: "properties"
          }, key = type, Object.hasOwnProperty.call(object, key) && object[key];
          var object, key;
        }
        checkLVal(expression, {in: ancestor, binding = 64, checkClashes = !1, strictModeChanged = !1, allowingSloppyLetBinding = !(8 & binding), hasParenthesizedAncestor = !1}) {
          var _expression$extra;
          const type = expression.type;
          if (this.isObjectMethod(expression)) return;
          if ("MemberExpression" === type) return void (64 !== binding && this.raise(Errors.InvalidPropertyBindingPattern, {
            at: expression
          }));
          if ("Identifier" === expression.type) {
            this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);
            const {name} = expression;
            return void (checkClashes && (checkClashes.has(name) ? this.raise(Errors.ParamDupe, {
              at: expression
            }) : checkClashes.add(name)));
          }
          const validity = this.isValidLVal(expression.type, hasParenthesizedAncestor || (null == (_expression$extra = expression.extra) ? void 0 : _expression$extra.parenthesized), binding);
          if (!0 === validity) return;
          if (!1 === validity) {
            const ParseErrorClass = 64 === binding ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
            return void this.raise(ParseErrorClass, {
              at: expression,
              ancestor: "UpdateExpression" === ancestor.type ? {
                type: "UpdateExpression",
                prefix: ancestor.prefix
              } : {
                type: ancestor.type
              }
            });
          }
          const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [ validity, "ParenthesizedExpression" === type ], nextAncestor = "ArrayPattern" === expression.type || "ObjectPattern" === expression.type || "ParenthesizedExpression" === expression.type ? expression : ancestor;
          for (const child of [].concat(expression[key])) child && this.checkLVal(child, {
            in: nextAncestor,
            binding,
            checkClashes,
            allowingSloppyLetBinding,
            strictModeChanged,
            hasParenthesizedAncestor: isParenthesizedExpression
          });
        }
        checkIdentifier(at, bindingType, strictModeChanged = !1, allowLetBinding = !(8 & bindingType)) {
          this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name)) && (64 === bindingType ? this.raise(Errors.StrictEvalArguments, {
            at,
            referenceName: at.name
          }) : this.raise(Errors.StrictEvalArgumentsBinding, {
            at,
            bindingName: at.name
          })), allowLetBinding || "let" !== at.name || this.raise(Errors.LetInLexicalBinding, {
            at
          }), 64 & bindingType || this.declareNameFromIdentifier(at, bindingType);
        }
        declareNameFromIdentifier(identifier, binding) {
          this.scope.declareName(identifier.name, binding, identifier.loc.start);
        }
        checkToRestConversion(node) {
          "Identifier" !== node.argument.type && "MemberExpression" !== node.argument.type && this.raise(Errors.InvalidRestAssignmentPattern, {
            at: node.argument
          });
        }
        checkCommaAfterRest(close) {
          return !!this.match(12) && (this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
            at: this.state.startLoc
          }), !0);
        }
      } {
        checkProto(prop, isRecord, protoRef, refExpressionErrors) {
          if ("SpreadElement" === prop.type || this.isObjectMethod(prop) || prop.computed || prop.shorthand) return;
          const key = prop.key;
          if ("__proto__" === ("Identifier" === key.type ? key.name : key.value)) {
            if (isRecord) return void this.raise(Errors.RecordNoProto, {
              at: key
            });
            protoRef.used && (refExpressionErrors ? null === refExpressionErrors.doubleProtoLoc && (refExpressionErrors.doubleProtoLoc = key.loc.start) : this.raise(Errors.DuplicateProto, {
              at: key
            })), protoRef.used = !0;
          }
        }
        shouldExitDescending(expr, potentialArrowAt) {
          return "ArrowFunctionExpression" === expr.type && expr.start === potentialArrowAt;
        }
        getExpression() {
          this.enterInitialScopes(), this.nextToken();
          const expr = this.parseExpression();
          return this.match(135) || this.unexpected(), this.finalizeRemainingComments(), expr.comments = this.state.comments, 
          expr.errors = this.state.errors, this.options.tokens && (expr.tokens = this.tokens), 
          expr;
        }
        parseExpression(disallowIn, refExpressionErrors) {
          return disallowIn ? this.disallowInAnd((() => this.parseExpressionBase(refExpressionErrors))) : this.allowInAnd((() => this.parseExpressionBase(refExpressionErrors)));
        }
        parseExpressionBase(refExpressionErrors) {
          const startPos = this.state.start, startLoc = this.state.startLoc, expr = this.parseMaybeAssign(refExpressionErrors);
          if (this.match(12)) {
            const node = this.startNodeAt(startPos, startLoc);
            for (node.expressions = [ expr ]; this.eat(12); ) node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
            return this.toReferencedList(node.expressions), this.finishNode(node, "SequenceExpression");
          }
          return expr;
        }
        parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
          return this.disallowInAnd((() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse)));
        }
        parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
          return this.allowInAnd((() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse)));
        }
        setOptionalParametersError(refExpressionErrors, resultError) {
          var _resultError$loc;
          refExpressionErrors.optionalParametersLoc = null != (_resultError$loc = null == resultError ? void 0 : resultError.loc) ? _resultError$loc : this.state.startLoc;
        }
        parseMaybeAssign(refExpressionErrors, afterLeftParse) {
          const startPos = this.state.start, startLoc = this.state.startLoc;
          if (this.isContextual(105) && this.prodParam.hasYield) {
            let left = this.parseYield();
            return afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), 
            left;
          }
          let ownExpressionErrors;
          refExpressionErrors ? ownExpressionErrors = !1 : (refExpressionErrors = new ExpressionErrors, 
          ownExpressionErrors = !0);
          const {type} = this.state;
          (10 === type || tokenIsIdentifier(type)) && (this.state.potentialArrowAt = this.state.start);
          let left = this.parseMaybeConditional(refExpressionErrors);
          if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), 
          (token = this.state.type) >= 29 && token <= 33) {
            const node = this.startNodeAt(startPos, startLoc), operator = this.state.value;
            return node.operator = operator, this.match(29) ? (node.left = this.toAssignable(left, !0), 
            null != refExpressionErrors.doubleProtoLoc && refExpressionErrors.doubleProtoLoc.index >= startPos && (refExpressionErrors.doubleProtoLoc = null), 
            null != refExpressionErrors.shorthandAssignLoc && refExpressionErrors.shorthandAssignLoc.index >= startPos && (refExpressionErrors.shorthandAssignLoc = null), 
            null != refExpressionErrors.privateKeyLoc && refExpressionErrors.privateKeyLoc.index >= startPos && (this.checkDestructuringPrivate(refExpressionErrors), 
            refExpressionErrors.privateKeyLoc = null)) : node.left = left, this.next(), node.right = this.parseMaybeAssign(), 
            this.checkLVal(left, {
              in: this.finishNode(node, "AssignmentExpression")
            }), node;
          }
          var token;
          return ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, !0), 
          left;
        }
        parseMaybeConditional(refExpressionErrors) {
          const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(refExpressionErrors);
          return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
        }
        parseConditional(expr, startPos, startLoc, refExpressionErrors) {
          if (this.eat(17)) {
            const node = this.startNodeAt(startPos, startLoc);
            return node.test = expr, node.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), 
            node.alternate = this.parseMaybeAssign(), this.finishNode(node, "ConditionalExpression");
          }
          return expr;
        }
        parseMaybeUnaryOrPrivate(refExpressionErrors) {
          return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
        }
        parseExprOps(refExpressionErrors) {
          const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
          return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseExprOp(expr, startPos, startLoc, -1);
        }
        parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
          if (this.isPrivateName(left)) {
            const value = this.getPrivateNameSV(left);
            (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Errors.PrivateInExpectedIn, {
              at: left,
              identifierName: value
            }), this.classScope.usePrivateName(value, left.loc.start);
          }
          const op = this.state.type;
          if ((token = op) >= 39 && token <= 59 && (this.prodParam.hasIn || !this.match(58))) {
            let prec = tokenOperatorPrecedence(op);
            if (prec > minPrec) {
              if (39 === op) {
                if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return left;
                this.checkPipelineAtInfixOperator(left, leftStartLoc);
              }
              const node = this.startNodeAt(leftStartPos, leftStartLoc);
              node.left = left, node.operator = this.state.value;
              const logical = 41 === op || 42 === op, coalesce = 40 === op;
              if (coalesce && (prec = tokenOperatorPrecedence(42)), this.next(), 39 === op && this.hasPlugin([ "pipelineOperator", {
                proposal: "minimal"
              } ]) && 96 === this.state.type && this.prodParam.hasAwait) throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
                at: this.state.startLoc
              });
              node.right = this.parseExprOpRightExpr(op, prec), this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
              const nextOp = this.state.type;
              if (coalesce && (41 === nextOp || 42 === nextOp) || logical && 40 === nextOp) throw this.raise(Errors.MixingCoalesceWithLogical, {
                at: this.state.startLoc
              });
              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
            }
          }
          var token;
          return left;
        }
        parseExprOpRightExpr(op, prec) {
          const startPos = this.state.start, startLoc = this.state.startLoc;
          if (39 === op) switch (this.getPluginOption("pipelineOperator", "proposal")) {
           case "hack":
            return this.withTopicBindingContext((() => this.parseHackPipeBody()));

           case "smart":
            return this.withTopicBindingContext((() => {
              if (this.prodParam.hasYield && this.isContextual(105)) throw this.raise(Errors.PipeBodyIsTighter, {
                at: this.state.startLoc
              });
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
            }));

           case "fsharp":
            return this.withSoloAwaitPermittingContext((() => this.parseFSharpPipelineBody(prec)));
          }
          return this.parseExprOpBaseRightExpr(op, prec);
        }
        parseExprOpBaseRightExpr(op, prec) {
          const startPos = this.state.start, startLoc = this.state.startLoc;
          return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, 57 === op ? prec - 1 : prec);
        }
        parseHackPipeBody() {
          var _body$extra;
          const {startLoc} = this.state, body = this.parseMaybeAssign();
          return !UnparenthesizedPipeBodyDescriptions.has(body.type) || null != (_body$extra = body.extra) && _body$extra.parenthesized || this.raise(Errors.PipeUnparenthesizedBody, {
            at: startLoc,
            type: body.type
          }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipeTopicUnused, {
            at: startLoc
          }), body;
        }
        checkExponentialAfterUnary(node) {
          this.match(57) && this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
            at: node.argument
          });
        }
        parseMaybeUnary(refExpressionErrors, sawUnary) {
          const startPos = this.state.start, startLoc = this.state.startLoc, isAwait = this.isContextual(96);
          if (isAwait && this.isAwaitAllowed()) {
            this.next();
            const expr = this.parseAwait(startPos, startLoc);
            return sawUnary || this.checkExponentialAfterUnary(expr), expr;
          }
          const update = this.match(34), node = this.startNode();
          if (token = this.state.type, tokenPrefixes[token]) {
            node.operator = this.state.value, node.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
            const isDelete = this.match(89);
            if (this.next(), node.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(refExpressionErrors, !0), 
            this.state.strict && isDelete) {
              const arg = node.argument;
              "Identifier" === arg.type ? this.raise(Errors.StrictDelete, {
                at: node
              }) : this.hasPropertyAsPrivateName(arg) && this.raise(Errors.DeletePrivateField, {
                at: node
              });
            }
            if (!update) return sawUnary || this.checkExponentialAfterUnary(node), this.finishNode(node, "UnaryExpression");
          }
          var token;
          const expr = this.parseUpdate(node, update, refExpressionErrors);
          if (isAwait) {
            const {type} = this.state;
            if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
              at: startLoc
            }), this.parseAwait(startPos, startLoc);
          }
          return expr;
        }
        parseUpdate(node, update, refExpressionErrors) {
          if (update) return this.checkLVal(node.argument, {
            in: this.finishNode(node, "UpdateExpression")
          }), node;
          const startPos = this.state.start, startLoc = this.state.startLoc;
          let expr = this.parseExprSubscripts(refExpressionErrors);
          if (this.checkExpressionErrors(refExpressionErrors, !1)) return expr;
          for (;34 === this.state.type && !this.canInsertSemicolon(); ) {
            const node = this.startNodeAt(startPos, startLoc);
            node.operator = this.state.value, node.prefix = !1, node.argument = expr, this.next(), 
            this.checkLVal(expr, {
              in: expr = this.finishNode(node, "UpdateExpression")
            });
          }
          return expr;
        }
        parseExprSubscripts(refExpressionErrors) {
          const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
          return this.shouldExitDescending(expr, potentialArrowAt) ? expr : this.parseSubscripts(expr, startPos, startLoc);
        }
        parseSubscripts(base, startPos, startLoc, noCalls) {
          const state = {
            optionalChainMember: !1,
            maybeAsyncArrow: this.atPossibleAsyncArrow(base),
            stop: !1
          };
          do {
            base = this.parseSubscript(base, startPos, startLoc, noCalls, state), state.maybeAsyncArrow = !1;
          } while (!state.stop);
          return base;
        }
        parseSubscript(base, startPos, startLoc, noCalls, state) {
          const {type} = this.state;
          if (!noCalls && 15 === type) return this.parseBind(base, startPos, startLoc, noCalls, state);
          if (tokenIsTemplate(type)) return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
          let optional = !1;
          if (18 === type) {
            if (noCalls && 40 === this.lookaheadCharCode()) return state.stop = !0, base;
            state.optionalChainMember = optional = !0, this.next();
          }
          if (!noCalls && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
          {
            const computed = this.eat(0);
            return computed || optional || this.eat(16) ? this.parseMember(base, startPos, startLoc, state, computed, optional) : (state.stop = !0, 
            base);
          }
        }
        parseMember(base, startPos, startLoc, state, computed, optional) {
          const node = this.startNodeAt(startPos, startLoc);
          return node.object = base, node.computed = computed, computed ? (node.property = this.parseExpression(), 
          this.expect(3)) : this.match(134) ? ("Super" === base.type && this.raise(Errors.SuperPrivateField, {
            at: startLoc
          }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), node.property = this.parsePrivateName()) : node.property = this.parseIdentifier(!0), 
          state.optionalChainMember ? (node.optional = optional, this.finishNode(node, "OptionalMemberExpression")) : this.finishNode(node, "MemberExpression");
        }
        parseBind(base, startPos, startLoc, noCalls, state) {
          const node = this.startNodeAt(startPos, startLoc);
          return node.object = base, this.next(), node.callee = this.parseNoCallExpr(), state.stop = !0, 
          this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
        }
        parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          let refExpressionErrors = null;
          this.state.maybeInArrowParameters = !0, this.next();
          let node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const {maybeAsyncArrow, optionalChainMember} = state;
          return maybeAsyncArrow && (this.expressionScope.enter(new ArrowHeadParsingScope(2)), 
          refExpressionErrors = new ExpressionErrors), optionalChainMember && (node.optional = optional), 
          node.arguments = optional ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, "Import" === base.type, "Super" !== base.type, node, refExpressionErrors), 
          this.finishCallExpression(node, optionalChainMember), maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state.stop = !0, 
          this.checkDestructuringPrivate(refExpressionErrors), this.expressionScope.validateAsPattern(), 
          this.expressionScope.exit(), node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node)) : (maybeAsyncArrow && (this.checkExpressionErrors(refExpressionErrors, !0), 
          this.expressionScope.exit()), this.toReferencedArguments(node)), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, 
          node;
        }
        toReferencedArguments(node, isParenthesizedExpr) {
          this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
        }
        parseTaggedTemplateExpression(base, startPos, startLoc, state) {
          const node = this.startNodeAt(startPos, startLoc);
          return node.tag = base, node.quasi = this.parseTemplate(!0), state.optionalChainMember && this.raise(Errors.OptionalChainingNoTemplate, {
            at: startLoc
          }), this.finishNode(node, "TaggedTemplateExpression");
        }
        atPossibleAsyncArrow(base) {
          return "Identifier" === base.type && "async" === base.name && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start == 5 && base.start === this.state.potentialArrowAt;
        }
        finishCallExpression(node, optional) {
          if ("Import" === node.callee.type) if (2 === node.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), 
          0 === node.arguments.length || node.arguments.length > 2) this.raise(Errors.ImportCallArity, {
            at: node,
            maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
          }); else for (const arg of node.arguments) "SpreadElement" === arg.type && this.raise(Errors.ImportCallSpreadArgument, {
            at: arg
          });
          return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
        }
        parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
          const elts = [];
          let first = !0;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(close); ) {
            if (first) first = !1; else if (this.expect(12), this.match(close)) {
              !dynamicImport || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(Errors.ImportCallArgumentTrailingComma, {
                at: this.state.lastTokStartLoc
              }), nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
              break;
            }
            elts.push(this.parseExprListItem(!1, refExpressionErrors, allowPlaceholder));
          }
          return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
        }
        shouldParseAsyncArrow() {
          return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(node, call) {
          var _call$extra;
          return this.resetPreviousNodeTrailingComments(call), this.expect(19), this.parseArrowExpression(node, call.arguments, !0, null == (_call$extra = call.extra) ? void 0 : _call$extra.trailingCommaLoc), 
          call.innerComments && setInnerComments(node, call.innerComments), call.callee.trailingComments && setInnerComments(node, call.callee.trailingComments), 
          node;
        }
        parseNoCallExpr() {
          const startPos = this.state.start, startLoc = this.state.startLoc;
          return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, !0);
        }
        parseExprAtom(refExpressionErrors) {
          let node;
          const {type} = this.state;
          switch (type) {
           case 79:
            return this.parseSuper();

           case 83:
            return node = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(node) : (this.match(10) || this.raise(Errors.UnsupportedImport, {
              at: this.state.lastTokStartLoc
            }), this.finishNode(node, "Import"));

           case 78:
            return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");

           case 90:
            return this.parseDo(this.startNode(), !1);

           case 56:
           case 31:
            return this.readRegexp(), this.parseRegExpLiteral(this.state.value);

           case 130:
            return this.parseNumericLiteral(this.state.value);

           case 131:
            return this.parseBigIntLiteral(this.state.value);

           case 132:
            return this.parseDecimalLiteral(this.state.value);

           case 129:
            return this.parseStringLiteral(this.state.value);

           case 84:
            return this.parseNullLiteral();

           case 85:
            return this.parseBooleanLiteral(!0);

           case 86:
            return this.parseBooleanLiteral(!1);

           case 10:
            {
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              return this.parseParenAndDistinguishExpression(canBeArrow);
            }

           case 2:
           case 1:
            return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);

           case 0:
            return this.parseArrayLike(3, !0, !1, refExpressionErrors);

           case 6:
           case 7:
            return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);

           case 5:
            return this.parseObjectLike(8, !1, !1, refExpressionErrors);

           case 68:
            return this.parseFunctionOrFunctionSent();

           case 26:
            this.parseDecorators();

           case 80:
            return node = this.startNode(), this.takeDecorators(node), this.parseClass(node, !1);

           case 77:
            return this.parseNewOrNewTarget();

           case 25:
           case 24:
            return this.parseTemplate(!1);

           case 15:
            {
              node = this.startNode(), this.next(), node.object = null;
              const callee = node.callee = this.parseNoCallExpr();
              if ("MemberExpression" === callee.type) return this.finishNode(node, "BindExpression");
              throw this.raise(Errors.UnsupportedBind, {
                at: callee
              });
            }

           case 134:
            return this.raise(Errors.PrivateInExpectedIn, {
              at: this.state.startLoc,
              identifierName: this.state.value
            }), this.parsePrivateName();

           case 33:
            return this.parseTopicReferenceThenEqualsSign(54, "%");

           case 32:
            return this.parseTopicReferenceThenEqualsSign(44, "^");

           case 37:
           case 38:
            return this.parseTopicReference("hack");

           case 44:
           case 54:
           case 27:
            {
              const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
              if (pipeProposal) return this.parseTopicReference(pipeProposal);
              throw this.unexpected();
            }

           case 47:
            {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
              if (isIdentifierStart(lookaheadCh) || 62 === lookaheadCh) {
                this.expectOnePlugin([ "jsx", "flow", "typescript" ]);
                break;
              }
              throw this.unexpected();
            }

           default:
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(123) && 123 === this.lookaheadCharCode() && !this.hasFollowingLineBreak()) return this.parseModuleExpression();
              const canBeArrow = this.state.potentialArrowAt === this.state.start, containsEsc = this.state.containsEsc, id = this.parseIdentifier();
              if (!containsEsc && "async" === id.name && !this.canInsertSemicolon()) {
                const {type} = this.state;
                if (68 === type) return this.resetPreviousNodeTrailingComments(id), this.next(), 
                this.parseFunction(this.startNodeAtNode(id), void 0, !0);
                if (tokenIsIdentifier(type)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id)) : id;
                if (90 === type) return this.resetPreviousNodeTrailingComments(id), this.parseDo(this.startNodeAtNode(id), !0);
              }
              return canBeArrow && this.match(19) && !this.canInsertSemicolon() ? (this.next(), 
              this.parseArrowExpression(this.startNodeAtNode(id), [ id ], !1)) : id;
            }
            throw this.unexpected();
          }
        }
        parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
          if (pipeProposal) return this.state.type = topicTokenType, this.state.value = topicTokenValue, 
          this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), 
          this.parseTopicReference(pipeProposal);
          throw this.unexpected();
        }
        parseTopicReference(pipeProposal) {
          const node = this.startNode(), startLoc = this.state.startLoc, tokenType = this.state.type;
          return this.next(), this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
        }
        finishTopicReference(node, startLoc, pipeProposal, tokenType) {
          if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
            const nodeType = "smart" === pipeProposal ? "PipelinePrimaryTopicReference" : "TopicReference";
            return this.topicReferenceIsAllowedInCurrentContext() || this.raise("smart" === pipeProposal ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
              at: startLoc
            }), this.registerTopicReference(), this.finishNode(node, nodeType);
          }
          throw this.raise(Errors.PipeTopicUnconfiguredToken, {
            at: startLoc,
            token: tokenLabelName(tokenType)
          });
        }
        testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
          switch (pipeProposal) {
           case "hack":
            return this.hasPlugin([ "pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            } ]);

           case "smart":
            return 27 === tokenType;

           default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, {
              at: startLoc
            });
          }
        }
        parseAsyncArrowUnaryFunction(node) {
          this.prodParam.enter(functionFlags(!0, this.prodParam.hasYield));
          const params = [ this.parseIdentifier() ];
          return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Errors.LineTerminatorBeforeArrow, {
            at: this.state.curPosition()
          }), this.expect(19), this.parseArrowExpression(node, params, !0), node;
        }
        parseDo(node, isAsync) {
          this.expectPlugin("doExpressions"), isAsync && this.expectPlugin("asyncDoExpressions"), 
          node.async = isAsync, this.next();
          const oldLabels = this.state.labels;
          return this.state.labels = [], isAsync ? (this.prodParam.enter(2), node.body = this.parseBlock(), 
          this.prodParam.exit()) : node.body = this.parseBlock(), this.state.labels = oldLabels, 
          this.finishNode(node, "DoExpression");
        }
        parseSuper() {
          const node = this.startNode();
          return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(Errors.UnexpectedSuper, {
            at: node
          }) : this.raise(Errors.SuperNotAllowed, {
            at: node
          }), this.match(10) || this.match(0) || this.match(16) || this.raise(Errors.UnsupportedSuper, {
            at: node
          }), this.finishNode(node, "Super");
        }
        parsePrivateName() {
          const node = this.startNode(), id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), name = this.state.value;
          return this.next(), node.id = this.createIdentifier(id, name), this.finishNode(node, "PrivateName");
        }
        parseFunctionOrFunctionSent() {
          const node = this.startNode();
          if (this.next(), this.prodParam.hasYield && this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
            return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), 
            this.parseMetaProperty(node, meta, "sent");
          }
          return this.parseFunction(node);
        }
        parseMetaProperty(node, meta, propertyName) {
          node.meta = meta;
          const containsEsc = this.state.containsEsc;
          return node.property = this.parseIdentifier(!0), (node.property.name !== propertyName || containsEsc) && this.raise(Errors.UnsupportedMetaProperty, {
            at: node.property,
            target: meta.name,
            onlyValidPropertyName: propertyName
          }), this.finishNode(node, "MetaProperty");
        }
        parseImportMetaProperty(node) {
          const id = this.createIdentifier(this.startNodeAtNode(node), "import");
          return this.next(), this.isContextual(100) && (this.inModule || this.raise(Errors.ImportMetaOutsideModule, {
            at: id
          }), this.sawUnambiguousESM = !0), this.parseMetaProperty(node, id, "meta");
        }
        parseLiteralAtNode(value, type, node) {
          return this.addExtra(node, "rawValue", value), this.addExtra(node, "raw", this.input.slice(node.start, this.state.end)), 
          node.value = value, this.next(), this.finishNode(node, type);
        }
        parseLiteral(value, type) {
          const node = this.startNode();
          return this.parseLiteralAtNode(value, type, node);
        }
        parseStringLiteral(value) {
          return this.parseLiteral(value, "StringLiteral");
        }
        parseNumericLiteral(value) {
          return this.parseLiteral(value, "NumericLiteral");
        }
        parseBigIntLiteral(value) {
          return this.parseLiteral(value, "BigIntLiteral");
        }
        parseDecimalLiteral(value) {
          return this.parseLiteral(value, "DecimalLiteral");
        }
        parseRegExpLiteral(value) {
          const node = this.parseLiteral(value.value, "RegExpLiteral");
          return node.pattern = value.pattern, node.flags = value.flags, node;
        }
        parseBooleanLiteral(value) {
          const node = this.startNode();
          return node.value = value, this.next(), this.finishNode(node, "BooleanLiteral");
        }
        parseNullLiteral() {
          const node = this.startNode();
          return this.next(), this.finishNode(node, "NullLiteral");
        }
        parseParenAndDistinguishExpression(canBeArrow) {
          const startPos = this.state.start, startLoc = this.state.startLoc;
          let val;
          this.next(), this.expressionScope.enter(new ArrowHeadParsingScope(1));
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
          const innerStartPos = this.state.start, innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors;
          let spreadStartLoc, optionalCommaStartLoc, first = !0;
          for (;!this.match(11); ) {
            if (first) first = !1; else if (this.expect(12, null === refExpressionErrors.optionalParametersLoc ? null : refExpressionErrors.optionalParametersLoc), 
            this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
            if (this.match(21)) {
              const spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
              if (spreadStartLoc = this.state.startLoc, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc)), 
              !this.checkCommaAfterRest(41)) break;
            } else exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
          const innerEndLoc = this.state.lastTokEndLoc;
          this.expect(11), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, 
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let arrowNode = this.startNodeAt(startPos, startLoc);
          return canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode)) ? (this.checkDestructuringPrivate(refExpressionErrors), 
          this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(arrowNode, exprList, !1), 
          arrowNode) : (this.expressionScope.exit(), exprList.length || this.unexpected(this.state.lastTokStartLoc), 
          optionalCommaStartLoc && this.unexpected(optionalCommaStartLoc), spreadStartLoc && this.unexpected(spreadStartLoc), 
          this.checkExpressionErrors(refExpressionErrors, !0), this.toReferencedListDeep(exprList, !0), 
          exprList.length > 1 ? (val = this.startNodeAt(innerStartPos, innerStartLoc), val.expressions = exprList, 
          this.finishNode(val, "SequenceExpression"), this.resetEndLocation(val, innerEndLoc)) : val = exprList[0], 
          this.wrapParenthesis(startPos, startLoc, val));
        }
        wrapParenthesis(startPos, startLoc, expression) {
          if (!this.options.createParenthesizedExpressions) return this.addExtra(expression, "parenthesized", !0), 
          this.addExtra(expression, "parenStart", startPos), this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index), 
          expression;
          const parenExpression = this.startNodeAt(startPos, startLoc);
          return parenExpression.expression = expression, this.finishNode(parenExpression, "ParenthesizedExpression"), 
          parenExpression;
        }
        shouldParseArrow(params) {
          return !this.canInsertSemicolon();
        }
        parseArrow(node) {
          if (this.eat(19)) return node;
        }
        parseParenItem(node, startPos, startLoc) {
          return node;
        }
        parseNewOrNewTarget() {
          const node = this.startNode();
          if (this.next(), this.match(16)) {
            const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
            this.next();
            const metaProp = this.parseMetaProperty(node, meta, "target");
            return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(Errors.UnexpectedNewTarget, {
              at: metaProp
            }), metaProp;
          }
          return this.parseNew(node);
        }
        parseNew(node) {
          return node.callee = this.parseNoCallExpr(), "Import" === node.callee.type ? this.raise(Errors.ImportCallNotNewExpression, {
            at: node.callee
          }) : this.isOptionalChain(node.callee) ? this.raise(Errors.OptionalChainingNoNew, {
            at: this.state.lastTokEndLoc
          }) : this.eat(18) && this.raise(Errors.OptionalChainingNoNew, {
            at: this.state.startLoc
          }), this.parseNewArguments(node), this.finishNode(node, "NewExpression");
        }
        parseNewArguments(node) {
          if (this.eat(10)) {
            const args = this.parseExprList(11);
            this.toReferencedList(args), node.arguments = args;
          } else node.arguments = [];
        }
        parseTemplateElement(isTagged) {
          const {start, startLoc, end, value} = this.state, elemStart = start + 1, elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));
          null === value && (isTagged || this.raise(Errors.InvalidEscapeSequenceTemplate, {
            at: createPositionWithColumnOffset(startLoc, 2)
          }));
          const isTail = this.match(24), endOffset = isTail ? -1 : -2, elemEnd = end + endOffset;
          return elem.value = {
            raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
            cooked: null === value ? null : value.slice(1, endOffset)
          }, elem.tail = isTail, this.next(), this.finishNode(elem, "TemplateElement"), this.resetEndLocation(elem, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset)), 
          elem;
        }
        parseTemplate(isTagged) {
          const node = this.startNode();
          node.expressions = [];
          let curElt = this.parseTemplateElement(isTagged);
          for (node.quasis = [ curElt ]; !curElt.tail; ) node.expressions.push(this.parseTemplateSubstitution()), 
          this.readTemplateContinuation(), node.quasis.push(curElt = this.parseTemplateElement(isTagged));
          return this.finishNode(node, "TemplateLiteral");
        }
        parseTemplateSubstitution() {
          return this.parseExpression();
        }
        parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
          isRecord && this.expectPlugin("recordAndTuple");
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          const propHash = Object.create(null);
          let first = !0;
          const node = this.startNode();
          for (node.properties = [], this.next(); !this.match(close); ) {
            if (first) first = !1; else if (this.expect(12), this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
            let prop;
            isPattern ? prop = this.parseBindingProperty() : (prop = this.parsePropertyDefinition(refExpressionErrors), 
            this.checkProto(prop, isRecord, propHash, refExpressionErrors)), isRecord && !this.isObjectProperty(prop) && "SpreadElement" !== prop.type && this.raise(Errors.InvalidRecordProperty, {
              at: prop
            }), prop.shorthand && this.addExtra(prop, "shorthand", !0), node.properties.push(prop);
          }
          this.next(), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
          let type = "ObjectExpression";
          return isPattern ? type = "ObjectPattern" : isRecord && (type = "RecordExpression"), 
          this.finishNode(node, type);
        }
        addTrailingCommaExtraToNode(node) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart), this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
        }
        maybeAsyncOrAccessorProp(prop) {
          return !prop.computed && "Identifier" === prop.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(refExpressionErrors) {
          let decorators = [];
          if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(Errors.UnsupportedPropertyDecorator, {
            at: this.state.startLoc
          }); this.match(26); ) decorators.push(this.parseDecorator());
          const prop = this.startNode();
          let startPos, startLoc, isAsync = !1, isAccessor = !1;
          if (this.match(21)) return decorators.length && this.unexpected(), this.parseSpread();
          decorators.length && (prop.decorators = decorators, decorators = []), prop.method = !1, 
          refExpressionErrors && (startPos = this.state.start, startLoc = this.state.startLoc);
          let isGenerator = this.eat(55);
          this.parsePropertyNamePrefixOperator(prop);
          const containsEsc = this.state.containsEsc, key = this.parsePropertyName(prop, refExpressionErrors);
          if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
            const keyName = key.name;
            "async" !== keyName || this.hasPrecedingLineBreak() || (isAsync = !0, this.resetPreviousNodeTrailingComments(key), 
            isGenerator = this.eat(55), this.parsePropertyName(prop)), "get" !== keyName && "set" !== keyName || (isAccessor = !0, 
            this.resetPreviousNodeTrailingComments(key), prop.kind = keyName, this.match(55) && (isGenerator = !0, 
            this.raise(Errors.AccessorIsGenerator, {
              at: this.state.curPosition(),
              kind: keyName
            }), this.next()), this.parsePropertyName(prop));
          }
          return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, !1, isAccessor, refExpressionErrors), 
          prop;
        }
        getGetterSetterExpectedParamCount(method) {
          return "get" === method.kind ? 0 : 1;
        }
        getObjectOrClassMethodParams(method) {
          return method.params;
        }
        checkGetterSetterParams(method) {
          var _params;
          const paramCount = this.getGetterSetterExpectedParamCount(method), params = this.getObjectOrClassMethodParams(method);
          params.length !== paramCount && this.raise("get" === method.kind ? Errors.BadGetterArity : Errors.BadSetterArity, {
            at: method
          }), "set" === method.kind && "RestElement" === (null == (_params = params[params.length - 1]) ? void 0 : _params.type) && this.raise(Errors.BadSetterRestParameter, {
            at: method
          });
        }
        parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
          return isAccessor ? (this.parseMethod(prop, isGenerator, !1, !1, !1, "ObjectMethod"), 
          this.checkGetterSetterParams(prop), prop) : isAsync || isGenerator || this.match(10) ? (isPattern && this.unexpected(), 
          prop.kind = "method", prop.method = !0, this.parseMethod(prop, isGenerator, isAsync, !1, !1, "ObjectMethod")) : void 0;
        }
        parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
          if (prop.shorthand = !1, this.eat(14)) return prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors), 
          this.finishNode(prop, "ObjectProperty");
          if (!prop.computed && "Identifier" === prop.key.type) {
            if (this.checkReservedWord(prop.key.name, prop.key.loc.start, !0, !1), isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key)); else if (this.match(29)) {
              const shorthandAssignLoc = this.state.startLoc;
              null != refExpressionErrors ? null === refExpressionErrors.shorthandAssignLoc && (refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc) : this.raise(Errors.InvalidCoverInitializedName, {
                at: shorthandAssignLoc
              }), prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));
            } else prop.value = cloneIdentifier(prop.key);
            return prop.shorthand = !0, this.finishNode(prop, "ObjectProperty");
          }
        }
        parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
          const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
          return node || this.unexpected(), node;
        }
        parsePropertyName(prop, refExpressionErrors) {
          if (this.eat(0)) prop.computed = !0, prop.key = this.parseMaybeAssignAllowIn(), 
          this.expect(3); else {
            const {type, value} = this.state;
            let key;
            if (tokenIsKeywordOrIdentifier(type)) key = this.parseIdentifier(!0); else switch (type) {
             case 130:
              key = this.parseNumericLiteral(value);
              break;

             case 129:
              key = this.parseStringLiteral(value);
              break;

             case 131:
              key = this.parseBigIntLiteral(value);
              break;

             case 132:
              key = this.parseDecimalLiteral(value);
              break;

             case 134:
              {
                const privateKeyLoc = this.state.startLoc;
                null != refExpressionErrors ? null === refExpressionErrors.privateKeyLoc && (refExpressionErrors.privateKeyLoc = privateKeyLoc) : this.raise(Errors.UnexpectedPrivateField, {
                  at: privateKeyLoc
                }), key = this.parsePrivateName();
                break;
              }

             default:
              throw this.unexpected();
            }
            prop.key = key, 134 !== type && (prop.computed = !1);
          }
          return prop.key;
        }
        initFunction(node, isAsync) {
          node.id = null, node.generator = !1, node.async = !!isAsync;
        }
        parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = !1) {
          this.initFunction(node, isAsync), node.generator = !!isGenerator;
          const allowModifiers = isConstructor;
          return this.scope.enter(18 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0)), 
          this.prodParam.enter(functionFlags(isAsync, node.generator)), this.parseFunctionParams(node, allowModifiers), 
          this.parseFunctionBodyAndFinish(node, type, !0), this.prodParam.exit(), this.scope.exit(), 
          node;
        }
        parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
          isTuple && this.expectPlugin("recordAndTuple");
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          const node = this.startNode();
          return this.next(), node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node), 
          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
        }
        parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
          this.scope.enter(6);
          let flags = functionFlags(isAsync, !1);
          !this.match(5) && this.prodParam.hasIn && (flags |= 8), this.prodParam.enter(flags), 
          this.initFunction(node, isAsync);
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          return params && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(node, params, trailingCommaLoc)), 
          this.state.maybeInArrowParameters = !1, this.parseFunctionBody(node, !0), this.prodParam.exit(), 
          this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, 
          this.finishNode(node, "ArrowFunctionExpression");
        }
        setArrowFunctionParameters(node, params, trailingCommaLoc) {
          node.params = this.toAssignableList(params, trailingCommaLoc, !1);
        }
        parseFunctionBodyAndFinish(node, type, isMethod = !1) {
          this.parseFunctionBody(node, !1, isMethod), this.finishNode(node, type);
        }
        parseFunctionBody(node, allowExpression, isMethod = !1) {
          const isExpression = allowExpression && !this.match(5);
          if (this.expressionScope.enter(newExpressionScope()), isExpression) node.body = this.parseMaybeAssign(), 
          this.checkParams(node, !1, allowExpression, !1); else {
            const oldStrict = this.state.strict, oldLabels = this.state.labels;
            this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), 
            node.body = this.parseBlock(!0, !1, (hasStrictModeDirective => {
              const nonSimple = !this.isSimpleParamList(node.params);
              hasStrictModeDirective && nonSimple && this.raise(Errors.IllegalLanguageModeDirective, {
                at: "method" !== node.kind && "constructor" !== node.kind || !node.key ? node : node.key.loc.end
              });
              const strictModeChanged = !oldStrict && this.state.strict;
              this.checkParams(node, !(this.state.strict || allowExpression || isMethod || nonSimple), allowExpression, strictModeChanged), 
              this.state.strict && node.id && this.checkIdentifier(node.id, 65, strictModeChanged);
            })), this.prodParam.exit(), this.state.labels = oldLabels;
          }
          this.expressionScope.exit();
        }
        isSimpleParameter(node) {
          return "Identifier" === node.type;
        }
        isSimpleParamList(params) {
          for (let i = 0, len = params.length; i < len; i++) if (!this.isSimpleParameter(params[i])) return !1;
          return !0;
        }
        checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
          const checkClashes = !allowDuplicates && new Set, formalParameters = {
            type: "FormalParameters"
          };
          for (const param of node.params) this.checkLVal(param, {
            in: formalParameters,
            binding: 5,
            checkClashes,
            strictModeChanged
          });
        }
        parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
          const elts = [];
          let first = !0;
          for (;!this.eat(close); ) {
            if (first) first = !1; else if (this.expect(12), this.match(close)) {
              nodeForExtra && this.addTrailingCommaExtraToNode(nodeForExtra), this.next();
              break;
            }
            elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
          }
          return elts;
        }
        parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
          let elt;
          if (this.match(12)) allowEmpty || this.raise(Errors.UnexpectedToken, {
            at: this.state.curPosition(),
            unexpected: ","
          }), elt = null; else if (this.match(21)) {
            const spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
            elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
          } else if (this.match(17)) {
            this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(Errors.UnexpectedArgumentPlaceholder, {
              at: this.state.startLoc
            });
            const node = this.startNode();
            this.next(), elt = this.finishNode(node, "ArgumentPlaceholder");
          } else elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
          return elt;
        }
        parseIdentifier(liberal) {
          const node = this.startNode(), name = this.parseIdentifierName(node.start, liberal);
          return this.createIdentifier(node, name);
        }
        createIdentifier(node, name) {
          return node.name = name, node.loc.identifierName = name, this.finishNode(node, "Identifier");
        }
        parseIdentifierName(pos, liberal) {
          let name;
          const {startLoc, type} = this.state;
          if (!tokenIsKeywordOrIdentifier(type)) throw this.unexpected();
          name = this.state.value;
          const tokenIsKeyword = type <= 92;
          return liberal ? tokenIsKeyword && this.replaceToken(128) : this.checkReservedWord(name, startLoc, tokenIsKeyword, !1), 
          this.next(), name;
        }
        checkReservedWord(word, startLoc, checkKeywords, isBinding) {
          if (word.length > 10) return;
          if (!function(word) {
            return reservedWordLikeSet.has(word);
          }(word)) return;
          if ("yield" === word) {
            if (this.prodParam.hasYield) return void this.raise(Errors.YieldBindingIdentifier, {
              at: startLoc
            });
          } else if ("await" === word) {
            if (this.prodParam.hasAwait) return void this.raise(Errors.AwaitBindingIdentifier, {
              at: startLoc
            });
            if (this.scope.inStaticBlock) return void this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
              at: startLoc
            });
            this.expressionScope.recordAsyncArrowParametersError({
              at: startLoc
            });
          } else if ("arguments" === word && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(Errors.ArgumentsInClass, {
            at: startLoc
          });
          if (checkKeywords && function(word) {
            return keywords.has(word);
          }(word)) return void this.raise(Errors.UnexpectedKeyword, {
            at: startLoc,
            keyword: word
          });
          (this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule) && this.raise(Errors.UnexpectedReservedWord, {
            at: startLoc,
            reservedWord: word
          });
        }
        isAwaitAllowed() {
          return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
        }
        parseAwait(startPos, startLoc) {
          const node = this.startNodeAt(startPos, startLoc);
          return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
            at: node
          }), this.eat(55) && this.raise(Errors.ObsoleteAwaitStar, {
            at: node
          }), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), 
          this.state.soloAwait || (node.argument = this.parseMaybeUnary(null, !0)), this.finishNode(node, "AwaitExpression");
        }
        isAmbiguousAwait() {
          if (this.hasPrecedingLineBreak()) return !0;
          const {type} = this.state;
          return 53 === type || 10 === type || 0 === type || tokenIsTemplate(type) || 133 === type || 56 === type || this.hasPlugin("v8intrinsic") && 54 === type;
        }
        parseYield() {
          const node = this.startNode();
          this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
            at: node
          }), this.next();
          let delegating = !1, argument = null;
          if (!this.hasPrecedingLineBreak()) switch (delegating = this.eat(55), this.state.type) {
           case 13:
           case 135:
           case 8:
           case 11:
           case 3:
           case 9:
           case 14:
           case 12:
            if (!delegating) break;

           default:
            argument = this.parseMaybeAssign();
          }
          return node.delegate = delegating, node.argument = argument, this.finishNode(node, "YieldExpression");
        }
        checkPipelineAtInfixOperator(left, leftStartLoc) {
          this.hasPlugin([ "pipelineOperator", {
            proposal: "smart"
          } ]) && "SequenceExpression" === left.type && this.raise(Errors.PipelineHeadSequenceExpression, {
            at: leftStartLoc
          });
        }
        parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {
          const bodyNode = this.startNodeAt(startPos, startLoc);
          return this.isSimpleReference(childExpr) ? (bodyNode.callee = childExpr, this.finishNode(bodyNode, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(startLoc), 
          bodyNode.expression = childExpr, this.finishNode(bodyNode, "PipelineTopicExpression"));
        }
        isSimpleReference(expression) {
          switch (expression.type) {
           case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);

           case "Identifier":
            return !0;

           default:
            return !1;
          }
        }
        checkSmartPipeTopicBodyEarlyErrors(startLoc) {
          if (this.match(19)) throw this.raise(Errors.PipelineBodyNoArrow, {
            at: this.state.startLoc
          });
          this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipelineTopicUnused, {
            at: startLoc
          });
        }
        withTopicBindingContext(callback) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 1,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        }
        withSmartMixTopicForbiddingContext(callback) {
          if (!this.hasPlugin([ "pipelineOperator", {
            proposal: "smart"
          } ])) return callback();
          {
            const outerContextTopicState = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null
            };
            try {
              return callback();
            } finally {
              this.state.topicContext = outerContextTopicState;
            }
          }
        }
        withSoloAwaitPermittingContext(callback) {
          const outerContextSoloAwaitState = this.state.soloAwait;
          this.state.soloAwait = !0;
          try {
            return callback();
          } finally {
            this.state.soloAwait = outerContextSoloAwaitState;
          }
        }
        allowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          if (8 & ~flags) {
            this.prodParam.enter(8 | flags);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        disallowInAnd(callback) {
          const flags = this.prodParam.currentFlags();
          if (8 & flags) {
            this.prodParam.enter(-9 & flags);
            try {
              return callback();
            } finally {
              this.prodParam.exit();
            }
          }
          return callback();
        }
        registerTopicReference() {
          this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
          return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
          return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(prec) {
          const startPos = this.state.start, startLoc = this.state.startLoc;
          this.state.potentialArrowAt = this.state.start;
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !0;
          const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);
          return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
        }
        parseModuleExpression() {
          this.expectPlugin("moduleBlocks");
          const node = this.startNode();
          this.next(), this.eat(5);
          const revertScopes = this.initializeScopes(!0);
          this.enterInitialScopes();
          const program = this.startNode();
          try {
            node.body = this.parseProgram(program, 8, "module");
          } finally {
            revertScopes();
          }
          return this.eat(8), this.finishNode(node, "ModuleExpression");
        }
        parsePropertyNamePrefixOperator(prop) {}
      } {
        parseTopLevel(file, program) {
          return file.program = this.parseProgram(program), file.comments = this.state.comments, 
          this.options.tokens && (file.tokens = function(tokens, input) {
            for (let i = 0; i < tokens.length; i++) {
              const token = tokens[i], {type} = token;
              if ("number" == typeof type) {
                if (134 === type) {
                  const {loc, start, value, end} = token, hashEndPos = start + 1, hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
                  tokens.splice(i, 1, new Token({
                    type: getExportedToken(27),
                    value: "#",
                    start,
                    end: hashEndPos,
                    startLoc: loc.start,
                    endLoc: hashEndLoc
                  }), new Token({
                    type: getExportedToken(128),
                    value,
                    start: hashEndPos,
                    end,
                    startLoc: hashEndLoc,
                    endLoc: loc.end
                  })), i++;
                  continue;
                }
                if (tokenIsTemplate(type)) {
                  const {loc, start, value, end} = token, backquoteEnd = start + 1, backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
                  let startToken, templateValue, templateElementEnd, templateElementEndLoc, endToken;
                  startToken = 96 === input.charCodeAt(start) ? new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  }) : new Token({
                    type: getExportedToken(8),
                    value: "}",
                    start,
                    end: backquoteEnd,
                    startLoc: loc.start,
                    endLoc: backquoteEndLoc
                  }), 24 === type ? (templateElementEnd = end - 1, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1), 
                  templateValue = null === value ? null : value.slice(1, -1), endToken = new Token({
                    type: getExportedToken(22),
                    value: "`",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  })) : (templateElementEnd = end - 2, templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2), 
                  templateValue = null === value ? null : value.slice(1, -2), endToken = new Token({
                    type: getExportedToken(23),
                    value: "${",
                    start: templateElementEnd,
                    end,
                    startLoc: templateElementEndLoc,
                    endLoc: loc.end
                  })), tokens.splice(i, 1, startToken, new Token({
                    type: getExportedToken(20),
                    value: templateValue,
                    start: backquoteEnd,
                    end: templateElementEnd,
                    startLoc: backquoteEndLoc,
                    endLoc: templateElementEndLoc
                  }), endToken), i += 2;
                  continue;
                }
                token.type = getExportedToken(type);
              }
            }
            return tokens;
          }(this.tokens, this.input)), this.finishNode(file, "File");
        }
        parseProgram(program, end = 135, sourceType = this.options.sourceType) {
          if (program.sourceType = sourceType, program.interpreter = this.parseInterpreterDirective(), 
          this.parseBlockBody(program, !0, !0, end), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [localName, at] of Array.from(this.scope.undefinedExports)) this.raise(Errors.ModuleExportUndefined, {
            at,
            localName
          });
          return this.finishNode(program, "Program");
        }
        stmtToDirective(stmt) {
          const directive = stmt;
          directive.type = "Directive", directive.value = directive.expression, delete directive.expression;
          const directiveLiteral = directive.value, expressionValue = directiveLiteral.value, raw = this.input.slice(directiveLiteral.start, directiveLiteral.end), val = directiveLiteral.value = raw.slice(1, -1);
          return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), 
          this.addExtra(directiveLiteral, "expressionValue", expressionValue), directiveLiteral.type = "DirectiveLiteral", 
          directive;
        }
        parseInterpreterDirective() {
          if (!this.match(28)) return null;
          const node = this.startNode();
          return node.value = this.state.value, this.next(), this.finishNode(node, "InterpreterDirective");
        }
        isLet(context) {
          return !!this.isContextual(99) && this.isLetKeyword(context);
        }
        isLetKeyword(context) {
          const next = this.nextTokenStart(), nextCh = this.codePointAtPos(next);
          if (92 === nextCh || 91 === nextCh) return !0;
          if (context) return !1;
          if (123 === nextCh) return !0;
          if (isIdentifierStart(nextCh)) {
            if (keywordRelationalOperator.lastIndex = next, keywordRelationalOperator.test(this.input)) {
              const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
              if (!isIdentifierChar(endCh) && 92 !== endCh) return !1;
            }
            return !0;
          }
          return !1;
        }
        parseStatement(context, topLevel) {
          return this.match(26) && this.parseDecorators(!0), this.parseStatementContent(context, topLevel);
        }
        parseStatementContent(context, topLevel) {
          let starttype = this.state.type;
          const node = this.startNode();
          let kind;
          switch (this.isLet(context) && (starttype = 74, kind = "let"), starttype) {
           case 60:
            return this.parseBreakContinueStatement(node, !0);

           case 63:
            return this.parseBreakContinueStatement(node, !1);

           case 64:
            return this.parseDebuggerStatement(node);

           case 90:
            return this.parseDoStatement(node);

           case 91:
            return this.parseForStatement(node);

           case 68:
            if (46 === this.lookaheadCharCode()) break;
            return context && (this.state.strict ? this.raise(Errors.StrictFunction, {
              at: this.state.startLoc
            }) : "if" !== context && "label" !== context && this.raise(Errors.SloppyFunction, {
              at: this.state.startLoc
            })), this.parseFunctionStatement(node, !1, !context);

           case 80:
            return context && this.unexpected(), this.parseClass(node, !0);

           case 69:
            return this.parseIfStatement(node);

           case 70:
            return this.parseReturnStatement(node);

           case 71:
            return this.parseSwitchStatement(node);

           case 72:
            return this.parseThrowStatement(node);

           case 73:
            return this.parseTryStatement(node);

           case 75:
           case 74:
            return kind = kind || this.state.value, context && "var" !== kind && this.raise(Errors.UnexpectedLexicalDeclaration, {
              at: this.state.startLoc
            }), this.parseVarStatement(node, kind);

           case 92:
            return this.parseWhileStatement(node);

           case 76:
            return this.parseWithStatement(node);

           case 5:
            return this.parseBlock();

           case 13:
            return this.parseEmptyStatement(node);

           case 83:
            {
              const nextTokenCharCode = this.lookaheadCharCode();
              if (40 === nextTokenCharCode || 46 === nextTokenCharCode) break;
            }

           case 82:
            {
              let result;
              return this.options.allowImportExportEverywhere || topLevel || this.raise(Errors.UnexpectedImportExport, {
                at: this.state.startLoc
              }), this.next(), 83 === starttype ? (result = this.parseImport(node), "ImportDeclaration" !== result.type || result.importKind && "value" !== result.importKind || (this.sawUnambiguousESM = !0)) : (result = this.parseExport(node), 
              ("ExportNamedDeclaration" !== result.type || result.exportKind && "value" !== result.exportKind) && ("ExportAllDeclaration" !== result.type || result.exportKind && "value" !== result.exportKind) && "ExportDefaultDeclaration" !== result.type || (this.sawUnambiguousESM = !0)), 
              this.assertModuleNodeAllowed(node), result;
            }

           default:
            if (this.isAsyncFunction()) return context && this.raise(Errors.AsyncFunctionInSingleStatementContext, {
              at: this.state.startLoc
            }), this.next(), this.parseFunctionStatement(node, !0, !context);
          }
          const maybeName = this.state.value, expr = this.parseExpression();
          return tokenIsIdentifier(starttype) && "Identifier" === expr.type && this.eat(14) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
        }
        assertModuleNodeAllowed(node) {
          this.options.allowImportExportEverywhere || this.inModule || this.raise(Errors.ImportOutsideModule, {
            at: node
          });
        }
        takeDecorators(node) {
          const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          decorators.length && (node.decorators = decorators, this.resetStartLocationFromNode(node, decorators[0]), 
          this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
        }
        canHaveLeadingDecorator() {
          return this.match(80);
        }
        parseDecorators(allowExport) {
          const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
          for (;this.match(26); ) {
            const decorator = this.parseDecorator();
            currentContextDecorators.push(decorator);
          }
          if (this.match(82)) allowExport || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(Errors.DecoratorExportClass, {
            at: this.state.startLoc
          }); else if (!this.canHaveLeadingDecorator()) throw this.raise(Errors.UnexpectedLeadingDecorator, {
            at: this.state.startLoc
          });
        }
        parseDecorator() {
          this.expectOnePlugin([ "decorators-legacy", "decorators" ]);
          const node = this.startNode();
          if (this.next(), this.hasPlugin("decorators")) {
            this.state.decoratorStack.push([]);
            const startPos = this.state.start, startLoc = this.state.startLoc;
            let expr;
            if (this.match(10)) {
              const startPos = this.state.start, startLoc = this.state.startLoc;
              this.next(), expr = this.parseExpression(), this.expect(11), expr = this.wrapParenthesis(startPos, startLoc, expr);
            } else for (expr = this.parseIdentifier(!1); this.eat(16); ) {
              const node = this.startNodeAt(startPos, startLoc);
              node.object = expr, node.property = this.parseIdentifier(!0), node.computed = !1, 
              expr = this.finishNode(node, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr), this.state.decoratorStack.pop();
          } else node.expression = this.parseExprSubscripts();
          return this.finishNode(node, "Decorator");
        }
        parseMaybeDecoratorArguments(expr) {
          if (this.eat(10)) {
            const node = this.startNodeAtNode(expr);
            return node.callee = expr, node.arguments = this.parseCallExpressionArguments(11, !1), 
            this.toReferencedList(node.arguments), this.finishNode(node, "CallExpression");
          }
          return expr;
        }
        parseBreakContinueStatement(node, isBreak) {
          return this.next(), this.isLineTerminator() ? node.label = null : (node.label = this.parseIdentifier(), 
          this.semicolon()), this.verifyBreakContinue(node, isBreak), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
        }
        verifyBreakContinue(node, isBreak) {
          let i;
          for (i = 0; i < this.state.labels.length; ++i) {
            const lab = this.state.labels[i];
            if (null == node.label || lab.name === node.label.name) {
              if (null != lab.kind && (isBreak || "loop" === lab.kind)) break;
              if (node.label && isBreak) break;
            }
          }
          if (i === this.state.labels.length) {
            const type = isBreak ? "BreakStatement" : "ContinueStatement";
            this.raise(Errors.IllegalBreakContinue, {
              at: node,
              type
            });
          }
        }
        parseDebuggerStatement(node) {
          return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
        }
        parseHeaderExpression() {
          this.expect(10);
          const val = this.parseExpression();
          return this.expect(11), val;
        }
        parseDoStatement(node) {
          return this.next(), this.state.labels.push(loopLabel), node.body = this.withSmartMixTopicForbiddingContext((() => this.parseStatement("do"))), 
          this.state.labels.pop(), this.expect(92), node.test = this.parseHeaderExpression(), 
          this.eat(13), this.finishNode(node, "DoWhileStatement");
        }
        parseForStatement(node) {
          this.next(), this.state.labels.push(loopLabel);
          let awaitAt = null;
          if (this.isAwaitAllowed() && this.eatContextual(96) && (awaitAt = this.state.lastTokStartLoc), 
          this.scope.enter(0), this.expect(10), this.match(13)) return null !== awaitAt && this.unexpected(awaitAt), 
          this.parseFor(node, null);
          const startsWithLet = this.isContextual(99), isLet = startsWithLet && this.isLetKeyword();
          if (this.match(74) || this.match(75) || isLet) {
            const init = this.startNode(), kind = isLet ? "let" : this.state.value;
            return this.next(), this.parseVar(init, !0, kind), this.finishNode(init, "VariableDeclaration"), 
            (this.match(58) || this.isContextual(101)) && 1 === init.declarations.length ? this.parseForIn(node, init, awaitAt) : (null !== awaitAt && this.unexpected(awaitAt), 
            this.parseFor(node, init));
          }
          const startsWithAsync = this.isContextual(95), refExpressionErrors = new ExpressionErrors, init = this.parseExpression(!0, refExpressionErrors), isForOf = this.isContextual(101);
          if (isForOf && (startsWithLet && this.raise(Errors.ForOfLet, {
            at: init
          }), null === awaitAt && startsWithAsync && "Identifier" === init.type && this.raise(Errors.ForOfAsync, {
            at: init
          })), isForOf || this.match(58)) {
            this.checkDestructuringPrivate(refExpressionErrors), this.toAssignable(init, !0);
            const type = isForOf ? "ForOfStatement" : "ForInStatement";
            return this.checkLVal(init, {
              in: {
                type
              }
            }), this.parseForIn(node, init, awaitAt);
          }
          return this.checkExpressionErrors(refExpressionErrors, !0), null !== awaitAt && this.unexpected(awaitAt), 
          this.parseFor(node, init);
        }
        parseFunctionStatement(node, isAsync, declarationPosition) {
          return this.next(), this.parseFunction(node, 1 | (declarationPosition ? 0 : 2), isAsync);
        }
        parseIfStatement(node) {
          return this.next(), node.test = this.parseHeaderExpression(), node.consequent = this.parseStatement("if"), 
          node.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
        }
        parseReturnStatement(node) {
          return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(Errors.IllegalReturn, {
            at: this.state.startLoc
          }), this.next(), this.isLineTerminator() ? node.argument = null : (node.argument = this.parseExpression(), 
          this.semicolon()), this.finishNode(node, "ReturnStatement");
        }
        parseSwitchStatement(node) {
          this.next(), node.discriminant = this.parseHeaderExpression();
          const cases = node.cases = [];
          let cur, sawDefault;
          for (this.expect(5), this.state.labels.push(switchLabel), this.scope.enter(0); !this.match(8); ) if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], 
            this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(Errors.MultipleDefaultsInSwitch, {
              at: this.state.lastTokStartLoc
            }), sawDefault = !0, cur.test = null), this.expect(14);
          } else cur ? cur.consequent.push(this.parseStatement(null)) : this.unexpected();
          return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), 
          this.state.labels.pop(), this.finishNode(node, "SwitchStatement");
        }
        parseThrowStatement(node) {
          return this.next(), this.hasPrecedingLineBreak() && this.raise(Errors.NewlineAfterThrow, {
            at: this.state.lastTokEndLoc
          }), node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
        }
        parseCatchClauseParam() {
          const param = this.parseBindingAtom(), simple = "Identifier" === param.type;
          return this.scope.enter(simple ? 8 : 0), this.checkLVal(param, {
            in: {
              type: "CatchClause"
            },
            binding: 9,
            allowingSloppyLetBinding: !0
          }), param;
        }
        parseTryStatement(node) {
          if (this.next(), node.block = this.parseBlock(), node.handler = null, this.match(62)) {
            const clause = this.startNode();
            this.next(), this.match(10) ? (this.expect(10), clause.param = this.parseCatchClauseParam(), 
            this.expect(11)) : (clause.param = null, this.scope.enter(0)), clause.body = this.withSmartMixTopicForbiddingContext((() => this.parseBlock(!1, !1))), 
            this.scope.exit(), node.handler = this.finishNode(clause, "CatchClause");
          }
          return node.finalizer = this.eat(67) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(Errors.NoCatchOrFinally, {
            at: node
          }), this.finishNode(node, "TryStatement");
        }
        parseVarStatement(node, kind, allowMissingInitializer = !1) {
          return this.next(), this.parseVar(node, !1, kind, allowMissingInitializer), this.semicolon(), 
          this.finishNode(node, "VariableDeclaration");
        }
        parseWhileStatement(node) {
          return this.next(), node.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), 
          node.body = this.withSmartMixTopicForbiddingContext((() => this.parseStatement("while"))), 
          this.state.labels.pop(), this.finishNode(node, "WhileStatement");
        }
        parseWithStatement(node) {
          return this.state.strict && this.raise(Errors.StrictWith, {
            at: this.state.startLoc
          }), this.next(), node.object = this.parseHeaderExpression(), node.body = this.withSmartMixTopicForbiddingContext((() => this.parseStatement("with"))), 
          this.finishNode(node, "WithStatement");
        }
        parseEmptyStatement(node) {
          return this.next(), this.finishNode(node, "EmptyStatement");
        }
        parseLabeledStatement(node, maybeName, expr, context) {
          for (const label of this.state.labels) label.name === maybeName && this.raise(Errors.LabelRedeclaration, {
            at: expr,
            labelName: maybeName
          });
          const kind = (token = this.state.type) >= 90 && token <= 92 ? "loop" : this.match(71) ? "switch" : null;
          var token;
          for (let i = this.state.labels.length - 1; i >= 0; i--) {
            const label = this.state.labels[i];
            if (label.statementStart !== node.start) break;
            label.statementStart = this.state.start, label.kind = kind;
          }
          return this.state.labels.push({
            name: maybeName,
            kind,
            statementStart: this.state.start
          }), node.body = this.parseStatement(context ? -1 === context.indexOf("label") ? context + "label" : context : "label"), 
          this.state.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
        }
        parseExpressionStatement(node, expr) {
          return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
        }
        parseBlock(allowDirectives = !1, createNewLexicalScope = !0, afterBlockParse) {
          const node = this.startNode();
          return allowDirectives && this.state.strictErrors.clear(), this.expect(5), createNewLexicalScope && this.scope.enter(0), 
          this.parseBlockBody(node, allowDirectives, !1, 8, afterBlockParse), createNewLexicalScope && this.scope.exit(), 
          this.finishNode(node, "BlockStatement");
        }
        isValidDirective(stmt) {
          return "ExpressionStatement" === stmt.type && "StringLiteral" === stmt.expression.type && !stmt.expression.extra.parenthesized;
        }
        parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
          const body = node.body = [], directives = node.directives = [];
          this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
        }
        parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
          const oldStrict = this.state.strict;
          let hasStrictModeDirective = !1, parsedNonDirective = !1;
          for (;!this.match(end); ) {
            const stmt = this.parseStatement(null, topLevel);
            if (directives && !parsedNonDirective) {
              if (this.isValidDirective(stmt)) {
                const directive = this.stmtToDirective(stmt);
                directives.push(directive), hasStrictModeDirective || "use strict" !== directive.value.value || (hasStrictModeDirective = !0, 
                this.setStrict(!0));
                continue;
              }
              parsedNonDirective = !0, this.state.strictErrors.clear();
            }
            body.push(stmt);
          }
          afterBlockParse && afterBlockParse.call(this, hasStrictModeDirective), oldStrict || this.setStrict(!1), 
          this.next();
        }
        parseFor(node, init) {
          return node.init = init, this.semicolon(!1), node.test = this.match(13) ? null : this.parseExpression(), 
          this.semicolon(!1), node.update = this.match(11) ? null : this.parseExpression(), 
          this.expect(11), node.body = this.withSmartMixTopicForbiddingContext((() => this.parseStatement("for"))), 
          this.scope.exit(), this.state.labels.pop(), this.finishNode(node, "ForStatement");
        }
        parseForIn(node, init, awaitAt) {
          const isForIn = this.match(58);
          return this.next(), isForIn ? null !== awaitAt && this.unexpected(awaitAt) : node.await = null !== awaitAt, 
          "VariableDeclaration" !== init.type || null == init.declarations[0].init || isForIn && !this.state.strict && "var" === init.kind && "Identifier" === init.declarations[0].id.type || this.raise(Errors.ForInOfLoopInitializer, {
            at: init,
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          }), "AssignmentPattern" === init.type && this.raise(Errors.InvalidLhs, {
            at: init,
            ancestor: {
              type: "ForStatement"
            }
          }), node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn(), 
          this.expect(11), node.body = this.withSmartMixTopicForbiddingContext((() => this.parseStatement("for"))), 
          this.scope.exit(), this.state.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
        }
        parseVar(node, isFor, kind, allowMissingInitializer = !1) {
          const declarations = node.declarations = [];
          for (node.kind = kind; ;) {
            const decl = this.startNode();
            if (this.parseVarId(decl, kind), decl.init = this.eat(29) ? isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, 
            null !== decl.init || allowMissingInitializer || ("Identifier" === decl.id.type || isFor && (this.match(58) || this.isContextual(101)) ? "const" !== kind || this.match(58) || this.isContextual(101) || this.raise(Errors.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc,
              kind: "const"
            }) : this.raise(Errors.DeclarationMissingInitializer, {
              at: this.state.lastTokEndLoc,
              kind: "destructuring"
            })), declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(12)) break;
          }
          return node;
        }
        parseVarId(decl, kind) {
          decl.id = this.parseBindingAtom(), this.checkLVal(decl.id, {
            in: {
              type: "VariableDeclarator"
            },
            binding: "var" === kind ? 5 : 9
          });
        }
        parseFunction(node, statement = 0, isAsync = !1) {
          const isStatement = 1 & statement, isHangingStatement = 2 & statement, requireId = !(!isStatement || 4 & statement);
          this.initFunction(node, isAsync), this.match(55) && isHangingStatement && this.raise(Errors.GeneratorInSingleStatementContext, {
            at: this.state.startLoc
          }), node.generator = this.eat(55), isStatement && (node.id = this.parseFunctionId(requireId));
          const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
          return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(functionFlags(isAsync, node.generator)), 
          isStatement || (node.id = this.parseFunctionId()), this.parseFunctionParams(node, !1), 
          this.withSmartMixTopicForbiddingContext((() => {
            this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
          })), this.prodParam.exit(), this.scope.exit(), isStatement && !isHangingStatement && this.registerFunctionStatementId(node), 
          this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
        }
        parseFunctionId(requireId) {
          return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(node, allowModifiers) {
          this.expect(10), this.expressionScope.enter(new ExpressionScope(3)), node.params = this.parseBindingList(11, 41, !1, allowModifiers), 
          this.expressionScope.exit();
        }
        registerFunctionStatementId(node) {
          node.id && this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, node.id.loc.start);
        }
        parseClass(node, isStatement, optionalId) {
          this.next(), this.takeDecorators(node);
          const oldStrict = this.state.strict;
          return this.state.strict = !0, this.parseClassId(node, isStatement, optionalId), 
          this.parseClassSuper(node), node.body = this.parseClassBody(!!node.superClass, oldStrict), 
          this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
        }
        isClassProperty() {
          return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
          return this.match(10);
        }
        isNonstaticConstructor(method) {
          return !(method.computed || method.static || "constructor" !== method.key.name && "constructor" !== method.key.value);
        }
        parseClassBody(hadSuperClass, oldStrict) {
          this.classScope.enter();
          const state = {
            hadConstructor: !1,
            hadSuperClass
          };
          let decorators = [];
          const classBody = this.startNode();
          if (classBody.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext((() => {
            for (;!this.match(8); ) {
              if (this.eat(13)) {
                if (decorators.length > 0) throw this.raise(Errors.DecoratorSemicolon, {
                  at: this.state.lastTokEndLoc
                });
                continue;
              }
              if (this.match(26)) {
                decorators.push(this.parseDecorator());
                continue;
              }
              const member = this.startNode();
              decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), 
              decorators = []), this.parseClassMember(classBody, member, state), "constructor" === member.kind && member.decorators && member.decorators.length > 0 && this.raise(Errors.DecoratorConstructor, {
                at: member
              });
            }
          })), this.state.strict = oldStrict, this.next(), decorators.length) throw this.raise(Errors.TrailingDecorator, {
            at: this.state.startLoc
          });
          return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
        }
        parseClassMemberFromModifier(classBody, member) {
          const key = this.parseIdentifier(!0);
          if (this.isClassMethod()) {
            const method = member;
            return method.kind = "method", method.computed = !1, method.key = key, method.static = !1, 
            this.pushClassMethod(classBody, method, !1, !1, !1, !1), !0;
          }
          if (this.isClassProperty()) {
            const prop = member;
            return prop.computed = !1, prop.key = key, prop.static = !1, classBody.body.push(this.parseClassProperty(prop)), 
            !0;
          }
          return this.resetPreviousNodeTrailingComments(key), !1;
        }
        parseClassMember(classBody, member, state) {
          const isStatic = this.isContextual(104);
          if (isStatic) {
            if (this.parseClassMemberFromModifier(classBody, member)) return;
            if (this.eat(5)) return void this.parseClassStaticBlock(classBody, member);
          }
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
        parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
          const publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, accessorProp = member, method = publicMethod, publicMember = publicMethod;
          if (member.static = isStatic, this.parsePropertyNamePrefixOperator(member), this.eat(55)) {
            method.kind = "method";
            const isPrivateName = this.match(134);
            return this.parseClassElementName(method), isPrivateName ? void this.pushClassPrivateMethod(classBody, privateMethod, !0, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsGenerator, {
              at: publicMethod.key
            }), void this.pushClassMethod(classBody, publicMethod, !0, !1, !1, !1));
          }
          const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc, isPrivate = this.match(134), key = this.parseClassElementName(member), maybeQuestionTokenStartLoc = this.state.startLoc;
          if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
            if (method.kind = "method", isPrivate) return void this.pushClassPrivateMethod(classBody, privateMethod, !1, !1);
            const isConstructor = this.isNonstaticConstructor(publicMethod);
            let allowsDirectSuper = !1;
            isConstructor && (publicMethod.kind = "constructor", state.hadConstructor && !this.hasPlugin("typescript") && this.raise(Errors.DuplicateConstructor, {
              at: key
            }), isConstructor && this.hasPlugin("typescript") && member.override && this.raise(Errors.OverrideOnConstructor, {
              at: key
            }), state.hadConstructor = !0, allowsDirectSuper = state.hadSuperClass), this.pushClassMethod(classBody, publicMethod, !1, !1, isConstructor, allowsDirectSuper);
          } else if (this.isClassProperty()) isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp); else if (isContextual && "async" === key.name && !this.isLineTerminator()) {
            this.resetPreviousNodeTrailingComments(key);
            const isGenerator = this.eat(55);
            publicMember.optional && this.unexpected(maybeQuestionTokenStartLoc), method.kind = "method";
            const isPrivate = this.match(134);
            this.parseClassElementName(method), this.parsePostMemberNameModifiers(publicMember), 
            isPrivate ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, !0) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAsync, {
              at: publicMethod.key
            }), this.pushClassMethod(classBody, publicMethod, isGenerator, !0, !1, !1));
          } else if (!isContextual || "get" !== key.name && "set" !== key.name || this.match(55) && this.isLineTerminator()) if (isContextual && "accessor" === key.name && !this.isLineTerminator()) {
            this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(key);
            const isPrivate = this.match(134);
            this.parseClassElementName(publicProp), this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);
          } else this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected(); else {
            this.resetPreviousNodeTrailingComments(key), method.kind = key.name;
            const isPrivate = this.match(134);
            this.parseClassElementName(publicMethod), isPrivate ? this.pushClassPrivateMethod(classBody, privateMethod, !1, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(Errors.ConstructorIsAccessor, {
              at: publicMethod.key
            }), this.pushClassMethod(classBody, publicMethod, !1, !1, !1, !1)), this.checkGetterSetterParams(publicMethod);
          }
        }
        parseClassElementName(member) {
          const {type, value} = this.state;
          if (128 !== type && 129 !== type || !member.static || "prototype" !== value || this.raise(Errors.StaticPrototype, {
            at: this.state.startLoc
          }), 134 === type) {
            "constructor" === value && this.raise(Errors.ConstructorClassPrivateField, {
              at: this.state.startLoc
            });
            const key = this.parsePrivateName();
            return member.key = key, key;
          }
          return this.parsePropertyName(member);
        }
        parseClassStaticBlock(classBody, member) {
          var _member$decorators;
          this.scope.enter(208);
          const oldLabels = this.state.labels;
          this.state.labels = [], this.prodParam.enter(0);
          const body = member.body = [];
          this.parseBlockOrModuleBlockBody(body, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), 
          this.state.labels = oldLabels, classBody.body.push(this.finishNode(member, "StaticBlock")), 
          null != (_member$decorators = member.decorators) && _member$decorators.length && this.raise(Errors.DecoratorStaticBlock, {
            at: member
          });
        }
        pushClassProperty(classBody, prop) {
          prop.computed || "constructor" !== prop.key.name && "constructor" !== prop.key.value || this.raise(Errors.ConstructorClassField, {
            at: prop.key
          }), classBody.body.push(this.parseClassProperty(prop));
        }
        pushClassPrivateProperty(classBody, prop) {
          const node = this.parseClassPrivateProperty(prop);
          classBody.body.push(node), this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
        pushClassAccessorProperty(classBody, prop, isPrivate) {
          if (!isPrivate && !prop.computed) {
            const key = prop.key;
            "constructor" !== key.name && "constructor" !== key.value || this.raise(Errors.ConstructorClassField, {
              at: key
            });
          }
          const node = this.parseClassAccessorProperty(prop);
          classBody.body.push(node), isPrivate && this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
        pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
          classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0));
        }
        pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
          const node = this.parseMethod(method, isGenerator, isAsync, !1, !1, "ClassPrivateMethod", !0);
          classBody.body.push(node);
          const kind = "get" === node.kind ? node.static ? 6 : 2 : "set" === node.kind ? node.static ? 5 : 1 : 0;
          this.declareClassPrivateMethodInScope(node, kind);
        }
        declareClassPrivateMethodInScope(node, kind) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
        }
        parsePostMemberNameModifiers(methodOrProp) {}
        parseClassPrivateProperty(node) {
          return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassPrivateProperty");
        }
        parseClassProperty(node) {
          return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassProperty");
        }
        parseClassAccessorProperty(node) {
          return this.parseInitializer(node), this.semicolon(), this.finishNode(node, "ClassAccessorProperty");
        }
        parseInitializer(node) {
          this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), 
          node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), 
          this.prodParam.exit(), this.scope.exit();
        }
        parseClassId(node, isStatement, optionalId, bindingType = 139) {
          if (tokenIsIdentifier(this.state.type)) node.id = this.parseIdentifier(), isStatement && this.declareNameFromIdentifier(node.id, bindingType); else {
            if (!optionalId && isStatement) throw this.raise(Errors.MissingClassName, {
              at: this.state.startLoc
            });
            node.id = null;
          }
        }
        parseClassSuper(node) {
          node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(node) {
          const hasDefault = this.maybeParseExportDefaultSpecifier(node), parseAfterDefault = !hasDefault || this.eat(12), hasStar = parseAfterDefault && this.eatExportStar(node), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12)), isFromRequired = hasDefault || hasStar;
          if (hasStar && !hasNamespace) return hasDefault && this.unexpected(), this.parseExportFrom(node, !0), 
          this.finishNode(node, "ExportAllDeclaration");
          const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
          if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) throw this.unexpected(null, 5);
          let hasDeclaration;
          if (isFromRequired || hasSpecifiers ? (hasDeclaration = !1, this.parseExportFrom(node, isFromRequired)) : hasDeclaration = this.maybeParseExportDeclaration(node), 
          isFromRequired || hasSpecifiers || hasDeclaration) return this.checkExport(node, !0, !1, !!node.source), 
          this.finishNode(node, "ExportNamedDeclaration");
          if (this.eat(65)) return node.declaration = this.parseExportDefaultExpression(), 
          this.checkExport(node, !0, !0), this.finishNode(node, "ExportDefaultDeclaration");
          throw this.unexpected(null, 5);
        }
        eatExportStar(node) {
          return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(node) {
          if (this.isExportDefaultSpecifier()) {
            this.expectPlugin("exportDefaultFrom");
            const specifier = this.startNode();
            return specifier.exported = this.parseIdentifier(!0), node.specifiers = [ this.finishNode(specifier, "ExportDefaultSpecifier") ], 
            !0;
          }
          return !1;
        }
        maybeParseExportNamespaceSpecifier(node) {
          if (this.isContextual(93)) {
            node.specifiers || (node.specifiers = []);
            const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
            return this.next(), specifier.exported = this.parseModuleExportName(), node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), 
            !0;
          }
          return !1;
        }
        maybeParseExportNamedSpecifiers(node) {
          if (this.match(5)) {
            node.specifiers || (node.specifiers = []);
            const isTypeExport = "type" === node.exportKind;
            return node.specifiers.push(...this.parseExportSpecifiers(isTypeExport)), node.source = null, 
            node.declaration = null, this.hasPlugin("importAssertions") && (node.assertions = []), 
            !0;
          }
          return !1;
        }
        maybeParseExportDeclaration(node) {
          return !!this.shouldParseExportDeclaration() && (node.specifiers = [], node.source = null, 
          this.hasPlugin("importAssertions") && (node.assertions = []), node.declaration = this.parseExportDeclaration(node), 
          !0);
        }
        isAsyncFunction() {
          if (!this.isContextual(95)) return !1;
          const next = this.nextTokenStart();
          return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
        }
        parseExportDefaultExpression() {
          const expr = this.startNode(), isAsync = this.isAsyncFunction();
          if (this.match(68) || isAsync) return this.next(), isAsync && this.next(), this.parseFunction(expr, 5, isAsync);
          if (this.match(80)) return this.parseClass(expr, !0, !0);
          if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(Errors.DecoratorBeforeExport, {
            at: this.state.startLoc
          }), this.parseDecorators(!1), this.parseClass(expr, !0, !0);
          if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(Errors.UnsupportedDefaultExport, {
            at: this.state.startLoc
          });
          const res = this.parseMaybeAssignAllowIn();
          return this.semicolon(), res;
        }
        parseExportDeclaration(node) {
          return this.parseStatement(null);
        }
        isExportDefaultSpecifier() {
          const {type} = this.state;
          if (tokenIsIdentifier(type)) {
            if (95 === type && !this.state.containsEsc || 99 === type) return !1;
            if ((126 === type || 125 === type) && !this.state.containsEsc) {
              const {type: nextType} = this.lookahead();
              if (tokenIsIdentifier(nextType) && 97 !== nextType || 5 === nextType) return this.expectOnePlugin([ "flow", "typescript" ]), 
              !1;
            }
          } else if (!this.match(65)) return !1;
          const next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
          if (44 === this.input.charCodeAt(next) || tokenIsIdentifier(this.state.type) && hasFrom) return !0;
          if (this.match(65) && hasFrom) {
            const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
            return 34 === nextAfterFrom || 39 === nextAfterFrom;
          }
          return !1;
        }
        parseExportFrom(node, expect) {
          if (this.eatContextual(97)) {
            node.source = this.parseImportSource(), this.checkExport(node);
            const assertions = this.maybeParseImportAssertions();
            assertions && (node.assertions = assertions);
          } else expect && this.unexpected();
          this.semicolon();
        }
        shouldParseExportDeclaration() {
          const {type} = this.state;
          if (26 === type && (this.expectOnePlugin([ "decorators", "decorators-legacy" ]), 
          this.hasPlugin("decorators"))) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport")) throw this.raise(Errors.DecoratorBeforeExport, {
              at: this.state.startLoc
            });
            return !0;
          }
          return 74 === type || 75 === type || 68 === type || 80 === type || this.isLet() || this.isAsyncFunction();
        }
        checkExport(node, checkNames, isDefault, isFrom) {
          if (checkNames) if (isDefault) {
            if (this.checkDuplicateExports(node, "default"), this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              "Identifier" !== declaration.type || "from" !== declaration.name || declaration.end - declaration.start != 4 || null != (_declaration$extra = declaration.extra) && _declaration$extra.parenthesized || this.raise(Errors.ExportDefaultFromAsIdentifier, {
                at: declaration
              });
            }
          } else if (node.specifiers && node.specifiers.length) for (const specifier of node.specifiers) {
            const {exported} = specifier, exportName = "Identifier" === exported.type ? exported.name : exported.value;
            if (this.checkDuplicateExports(specifier, exportName), !isFrom && specifier.local) {
              const {local} = specifier;
              "Identifier" !== local.type ? this.raise(Errors.ExportBindingIsString, {
                at: specifier,
                localName: local.value,
                exportName
              }) : (this.checkReservedWord(local.name, local.loc.start, !0, !1), this.scope.checkLocalExport(local));
            }
          } else if (node.declaration) if ("FunctionDeclaration" === node.declaration.type || "ClassDeclaration" === node.declaration.type) {
            const id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if ("VariableDeclaration" === node.declaration.type) for (const declaration of node.declaration.declarations) this.checkDeclaration(declaration.id);
          if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) throw this.raise(Errors.UnsupportedDecoratorExport, {
            at: node
          });
        }
        checkDeclaration(node) {
          if ("Identifier" === node.type) this.checkDuplicateExports(node, node.name); else if ("ObjectPattern" === node.type) for (const prop of node.properties) this.checkDeclaration(prop); else if ("ArrayPattern" === node.type) for (const elem of node.elements) elem && this.checkDeclaration(elem); else "ObjectProperty" === node.type ? this.checkDeclaration(node.value) : "RestElement" === node.type ? this.checkDeclaration(node.argument) : "AssignmentPattern" === node.type && this.checkDeclaration(node.left);
        }
        checkDuplicateExports(node, exportName) {
          this.exportedIdentifiers.has(exportName) && ("default" === exportName ? this.raise(Errors.DuplicateDefaultExport, {
            at: node
          }) : this.raise(Errors.DuplicateExport, {
            at: node,
            exportName
          })), this.exportedIdentifiers.add(exportName);
        }
        parseExportSpecifiers(isInTypeExport) {
          const nodes = [];
          let first = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (first) first = !1; else if (this.expect(12), this.eat(8)) break;
            const isMaybeTypeOnly = this.isContextual(126), isString = this.match(129), node = this.startNode();
            node.local = this.parseModuleExportName(), nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
          }
          return nodes;
        }
        parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
          return this.eatContextual(93) ? node.exported = this.parseModuleExportName() : isString ? node.exported = cloneStringLiteral(node.local) : node.exported || (node.exported = cloneIdentifier(node.local)), 
          this.finishNode(node, "ExportSpecifier");
        }
        parseModuleExportName() {
          if (this.match(129)) {
            const result = this.parseStringLiteral(this.state.value), surrogate = result.value.match(loneSurrogate);
            return surrogate && this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
              at: result,
              surrogateCharCode: surrogate[0].charCodeAt(0)
            }), result;
          }
          return this.parseIdentifier(!0);
        }
        parseImport(node) {
          if (node.specifiers = [], !this.match(129)) {
            const parseNext = !this.maybeParseDefaultImportSpecifier(node) || this.eat(12), hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
            parseNext && !hasStar && this.parseNamedImportSpecifiers(node), this.expectContextual(97);
          }
          node.source = this.parseImportSource();
          const assertions = this.maybeParseImportAssertions();
          if (assertions) node.assertions = assertions; else {
            const attributes = this.maybeParseModuleAttributes();
            attributes && (node.attributes = attributes);
          }
          return this.semicolon(), this.finishNode(node, "ImportDeclaration");
        }
        parseImportSource() {
          return this.match(129) || this.unexpected(), this.parseExprAtom();
        }
        shouldParseDefaultImport(node) {
          return tokenIsIdentifier(this.state.type);
        }
        parseImportSpecifierLocal(node, specifier, type) {
          specifier.local = this.parseIdentifier(), node.specifiers.push(this.finishImportSpecifier(specifier, type));
        }
        finishImportSpecifier(specifier, type) {
          return this.checkLVal(specifier.local, {
            in: specifier,
            binding: 9
          }), this.finishNode(specifier, type);
        }
        parseAssertEntries() {
          const attrs = [], attrNames = new Set;
          do {
            if (this.match(8)) break;
            const node = this.startNode(), keyName = this.state.value;
            if (attrNames.has(keyName) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
              at: this.state.startLoc,
              key: keyName
            }), attrNames.add(keyName), this.match(129) ? node.key = this.parseStringLiteral(keyName) : node.key = this.parseIdentifier(!0), 
            this.expect(14), !this.match(129)) throw this.raise(Errors.ModuleAttributeInvalidValue, {
              at: this.state.startLoc
            });
            node.value = this.parseStringLiteral(this.state.value), this.finishNode(node, "ImportAttribute"), 
            attrs.push(node);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseModuleAttributes() {
          if (!this.match(76) || this.hasPrecedingLineBreak()) return this.hasPlugin("moduleAttributes") ? [] : null;
          this.expectPlugin("moduleAttributes"), this.next();
          const attrs = [], attributes = new Set;
          do {
            const node = this.startNode();
            if (node.key = this.parseIdentifier(!0), "type" !== node.key.name && this.raise(Errors.ModuleAttributeDifferentFromType, {
              at: node.key
            }), attributes.has(node.key.name) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
              at: node.key,
              key: node.key.name
            }), attributes.add(node.key.name), this.expect(14), !this.match(129)) throw this.raise(Errors.ModuleAttributeInvalidValue, {
              at: this.state.startLoc
            });
            node.value = this.parseStringLiteral(this.state.value), this.finishNode(node, "ImportAttribute"), 
            attrs.push(node);
          } while (this.eat(12));
          return attrs;
        }
        maybeParseImportAssertions() {
          if (!this.isContextual(94) || this.hasPrecedingLineBreak()) return this.hasPlugin("importAssertions") ? [] : null;
          this.expectPlugin("importAssertions"), this.next(), this.eat(5);
          const attrs = this.parseAssertEntries();
          return this.eat(8), attrs;
        }
        maybeParseDefaultImportSpecifier(node) {
          return !!this.shouldParseDefaultImport(node) && (this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier"), 
          !0);
        }
        maybeParseStarImportSpecifier(node) {
          if (this.match(55)) {
            const specifier = this.startNode();
            return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier"), 
            !0;
          }
          return !1;
        }
        parseNamedImportSpecifiers(node) {
          let first = !0;
          for (this.expect(5); !this.eat(8); ) {
            if (first) first = !1; else {
              if (this.eat(14)) throw this.raise(Errors.DestructureNamedImport, {
                at: this.state.startLoc
              });
              if (this.expect(12), this.eat(8)) break;
            }
            const specifier = this.startNode(), importedIsString = this.match(129), isMaybeTypeOnly = this.isContextual(126);
            specifier.imported = this.parseModuleExportName();
            const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, "type" === node.importKind || "typeof" === node.importKind, isMaybeTypeOnly);
            node.specifiers.push(importSpecifier);
          }
        }
        parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {
          if (this.eatContextual(93)) specifier.local = this.parseIdentifier(); else {
            const {imported} = specifier;
            if (importedIsString) throw this.raise(Errors.ImportBindingIsString, {
              at: specifier,
              importName: imported.value
            });
            this.checkReservedWord(imported.name, specifier.loc.start, !0, !0), specifier.local || (specifier.local = cloneIdentifier(imported));
          }
          return this.finishImportSpecifier(specifier, "ImportSpecifier");
        }
        isThisParam(param) {
          return "Identifier" === param.type && "this" === param.name;
        }
      } {
        constructor(options, input) {
          super(options = function(opts) {
            const options = {};
            for (const key of Object.keys(defaultOptions)) options[key] = opts && null != opts[key] ? opts[key] : defaultOptions[key];
            return options;
          }(options), input), this.options = options, this.initializeScopes(), this.plugins = function(plugins) {
            const pluginMap = new Map;
            for (const plugin of plugins) {
              const [name, options] = Array.isArray(plugin) ? plugin : [ plugin, {} ];
              pluginMap.has(name) || pluginMap.set(name, options || {});
            }
            return pluginMap;
          }(this.options.plugins), this.filename = options.sourceFilename;
        }
        getScopeHandler() {
          return ScopeHandler;
        }
        parse() {
          this.enterInitialScopes();
          const file = this.startNode(), program = this.startNode();
          return this.nextToken(), file.errors = null, this.parseTopLevel(file, program), 
          file.errors = this.state.errors, file;
        }
      }
      const tokTypes = function(internalTokenTypes) {
        const tokenTypes = {};
        for (const typeName of Object.keys(internalTokenTypes)) tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);
        return tokenTypes;
      }(tt);
      function getParser(options, input) {
        let cls = Parser;
        return null != options && options.plugins && (!function(plugins) {
          if (hasPlugin(plugins, "decorators")) {
            if (hasPlugin(plugins, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
            if (null == decoratorsBeforeExport) throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
            if ("boolean" != typeof decoratorsBeforeExport) throw new Error("'decoratorsBeforeExport' must be a boolean.");
          }
          if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
          if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          if (hasPlugin(plugins, "pipelineOperator")) {
            const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
            if (!PIPELINE_PROPOSALS.includes(proposal)) {
              const proposalList = PIPELINE_PROPOSALS.map((p => `"${p}"`)).join(", ");
              throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
            }
            const tupleSyntaxIsHash = hasPlugin(plugins, [ "recordAndTuple", {
              syntaxType: "hash"
            } ]);
            if ("hack" === proposal) {
              if (hasPlugin(plugins, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
              if (hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
              const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
              if (!TOPIC_TOKENS.includes(topicToken)) {
                const tokenList = TOPIC_TOKENS.map((t => `"${t}"`)).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
              }
              if ("#" === topicToken && tupleSyntaxIsHash) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            } else if ("smart" === proposal && tupleSyntaxIsHash) throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
          }
          if (hasPlugin(plugins, "moduleAttributes")) {
            if (hasPlugin(plugins, "importAssertions")) throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
            if ("may-2020" !== getPluginOption(plugins, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
          if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p => `'${p}'`)).join(", "));
          if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
            const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw error.missingPlugins = "doExpressions", error;
          }
        }(options.plugins), cls = function(pluginsFromOptions) {
          const pluginList = mixinPluginNames.filter((name => hasPlugin(pluginsFromOptions, name))), key = pluginList.join("/");
          let cls = parserClassCache[key];
          if (!cls) {
            cls = Parser;
            for (const plugin of pluginList) cls = mixinPlugins[plugin](cls);
            parserClassCache[key] = cls;
          }
          return cls;
        }(options.plugins)), new cls(options, input);
      }
      const parserClassCache = {};
      exports.parse = function(input, options) {
        var _options;
        if ("unambiguous" !== (null == (_options = options) ? void 0 : _options.sourceType)) return getParser(options, input).parse();
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input), ast = parser.parse();
          if (parser.sawUnambiguousESM) return ast;
          if (parser.ambiguousScriptDifferentAst) try {
            return options.sourceType = "script", getParser(options, input).parse();
          } catch (_unused) {} else ast.program.sourceType = "script";
          return ast;
        } catch (moduleError) {
          try {
            return options.sourceType = "script", getParser(options, input).parse();
          } catch (_unused2) {}
          throw moduleError;
        }
      }, exports.parseExpression = function(input, options) {
        const parser = getParser(options, input);
        return parser.options.strictMode && (parser.state.strict = !0), parser.getExpression();
      }, exports.tokTypes = tokTypes;
    },
    4979: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var index = __webpack_require__(4982).declare((api => (api.assertVersion("^7.16.0"), 
      {
        name: "plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
        visitor: {
          FunctionExpression(path) {
            const name = function(path) {
              const {node} = path, functionId = node.id;
              if (!functionId) return !1;
              const name = functionId.name, paramNameBinding = path.scope.getOwnBinding(name);
              return void 0 !== paramNameBinding && "param" === paramNameBinding.kind && paramNameBinding.identifier !== paramNameBinding.path.node && name;
            }(path);
            if (name) {
              const {scope} = path, newParamName = scope.generateUid(name);
              scope.rename(name, newParamName);
            }
          }
        }
      })));
      exports.default = index;
    },
    2020: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var helperPluginUtils = __webpack_require__(4982), pluginProposalOptionalChaining = __webpack_require__(6288), helperSkipTransparentExpressionWrappers = __webpack_require__(4539), core = __webpack_require__(4629);
      function matchAffectedArguments(argumentNodes) {
        const spreadIndex = argumentNodes.findIndex((node => core.types.isSpreadElement(node)));
        return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
      }
      var index = helperPluginUtils.declare((api => {
        api.assertVersion(7);
        const noDocumentAll = api.assumption("noDocumentAll"), pureGetters = api.assumption("pureGetters");
        return {
          name: "bugfix-v8-spread-parameters-in-optional-chaining",
          visitor: {
            "OptionalCallExpression|OptionalMemberExpression"(path) {
              (function(path) {
                let optionalPath = path;
                const chains = [];
                for (;optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression(); ) {
                  const {node} = optionalPath;
                  chains.push(node), optionalPath.isOptionalMemberExpression() ? optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object")) : optionalPath.isOptionalCallExpression() && (optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee")));
                }
                for (let i = 0; i < chains.length; i++) {
                  const node = chains[i];
                  if (core.types.isOptionalCallExpression(node) && matchAffectedArguments(node.arguments)) {
                    if (node.optional) return !0;
                    const callee = chains[i + 1];
                    if (core.types.isOptionalMemberExpression(callee, {
                      optional: !0
                    })) return !0;
                  }
                }
                return !1;
              })(path) && pluginProposalOptionalChaining.transform(path, {
                noDocumentAll,
                pureGetters
              });
            }
          }
        };
      }));
      exports.default = index;
    },
    2288: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, {getAsyncIterator}) {
        const {node, scope, parent} = path, stepKey = scope.generateUidIdentifier("step"), stepValue = _core.types.memberExpression(stepKey, _core.types.identifier("value")), left = node.left;
        let declar;
        _core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left) ? declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue)) : _core.types.isVariableDeclaration(left) && (declar = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, stepValue) ]));
        let template = buildForAwait({
          ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
          ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier("iteratorAbruptCompletion"),
          ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
          ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
          GET_ITERATOR: getAsyncIterator,
          OBJECT: node.right,
          STEP_KEY: _core.types.cloneNode(stepKey)
        });
        template = template.body.body;
        const isLabeledParent = _core.types.isLabeledStatement(parent), tryBody = template[3].block.body, loop = tryBody[0];
        isLabeledParent && (tryBody[0] = _core.types.labeledStatement(parent.label, loop));
        return {
          replaceParent: isLabeledParent,
          node: template,
          declar,
          loop
        };
      };
      var _core = __webpack_require__(4629);
      const buildForAwait = (0, _core.template)("\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
    },
    1918: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperRemapAsyncToGenerator = __webpack_require__(5108), _pluginSyntaxAsyncGenerators = __webpack_require__(894), _core = __webpack_require__(4629), _forAwait = __webpack_require__(2288), _default = (0, 
      _helperPluginUtils.declare)((api => {
        api.assertVersion(7);
        const yieldStarVisitor = {
          Function(path) {
            path.skip();
          },
          YieldExpression({node}, state) {
            if (!node.delegate) return;
            const callee = state.addHelper("asyncGeneratorDelegate");
            node.argument = _core.types.callExpression(callee, [ _core.types.callExpression(state.addHelper("asyncIterator"), [ node.argument ]), state.addHelper("awaitAsyncGenerator") ]);
          }
        }, forAwaitVisitor = {
          Function(path) {
            path.skip();
          },
          ForOfStatement(path, {file}) {
            const {node} = path;
            if (!node.await) return;
            const build = (0, _forAwait.default)(path, {
              getAsyncIterator: file.addHelper("asyncIterator")
            }), {declar, loop} = build, block = loop.body;
            path.ensureBlock(), declar && block.body.push(declar), block.body.push(...node.body.body), 
            _core.types.inherits(loop, node), _core.types.inherits(loop.body, node.body), build.replaceParent ? path.parentPath.replaceWithMultiple(build.node) : path.replaceWithMultiple(build.node);
          }
        }, visitor = {
          Function(path, state) {
            path.node.async && (path.traverse(forAwaitVisitor, state), path.node.generator && (path.traverse(yieldStarVisitor, state), 
            (0, _helperRemapAsyncToGenerator.default)(path, {
              wrapAsync: state.addHelper("wrapAsyncGenerator"),
              wrapAwait: state.addHelper("awaitAsyncGenerator")
            })));
          }
        };
        return {
          name: "proposal-async-generator-functions",
          inherits: _pluginSyntaxAsyncGenerators.default,
          visitor: {
            Program(path, state) {
              path.traverse(visitor, state);
            }
          }
        };
      }));
      exports.default = _default;
    },
    5675: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperCreateClassFeaturesPlugin = __webpack_require__(6890), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => (api.assertVersion(7), (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
        name: "proposal-class-properties",
        api,
        feature: _helperCreateClassFeaturesPlugin.FEATURES.fields,
        loose: options.loose,
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties");
        }
      }))));
      exports.default = _default;
    },
    3884: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxClassStaticBlock = __webpack_require__(7249), _helperCreateClassFeaturesPlugin = __webpack_require__(6890);
      function generateUid(scope, denyList) {
        let uid, i = 1;
        do {
          uid = scope._generateUid("", i), i++;
        } while (denyList.has(uid));
        return uid;
      }
      var _default = (0, _helperPluginUtils.declare)((({types: t, template, assertVersion}) => (assertVersion("^7.12.0"), 
      {
        name: "proposal-class-static-block",
        inherits: _pluginSyntaxClassStaticBlock.default,
        pre() {
          (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, !1);
        },
        visitor: {
          ClassBody(classBody) {
            const {scope} = classBody, privateNames = new Set, body = classBody.get("body");
            for (const path of body) path.isPrivate() && privateNames.add(path.get("key.id").node.name);
            for (const path of body) {
              if (!path.isStaticBlock()) continue;
              const staticBlockPrivateId = generateUid(scope, privateNames);
              privateNames.add(staticBlockPrivateId);
              const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));
              let replacement;
              const blockBody = path.node.body;
              replacement = 1 === blockBody.length && t.isExpressionStatement(blockBody[0]) ? blockBody[0].expression : template.expression.ast`(() => { ${blockBody} })()`, 
              path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], !0));
            }
          }
        }
      })));
      exports.default = _default;
    },
    4673: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxDynamicImport = __webpack_require__(642);
      const SUPPORTED_MODULES = [ "commonjs", "amd", "systemjs" ];
      var _default = (0, _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "proposal-dynamic-import",
        inherits: _pluginSyntaxDynamicImport.default,
        pre() {
          this.file.set("@babel/plugin-proposal-dynamic-import", "7.16.7");
        },
        visitor: {
          Program() {
            const modules = this.file.get("@babel/plugin-transform-modules-*");
            if (!SUPPORTED_MODULES.includes(modules)) throw new Error("@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n");
          }
        }
      })));
      exports.default = _default;
    },
    9295: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxExportNamespaceFrom = __webpack_require__(494), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "proposal-export-namespace-from",
        inherits: _pluginSyntaxExportNamespaceFrom.default,
        visitor: {
          ExportNamedDeclaration(path) {
            var _exported$name;
            const {node, scope} = path, {specifiers} = node, index = _core.types.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
            if (!_core.types.isExportNamespaceSpecifier(specifiers[index])) return;
            const nodes = [];
            1 === index && nodes.push(_core.types.exportNamedDeclaration(null, [ specifiers.shift() ], node.source));
            const specifier = specifiers.shift(), {exported} = specifier, uid = scope.generateUidIdentifier(null != (_exported$name = exported.name) ? _exported$name : exported.value);
            nodes.push(_core.types.importDeclaration([ _core.types.importNamespaceSpecifier(uid) ], _core.types.cloneNode(node.source)), _core.types.exportNamedDeclaration(null, [ _core.types.exportSpecifier(_core.types.cloneNode(uid), exported) ])), 
            node.specifiers.length >= 1 && nodes.push(node);
            const [importDeclaration] = path.replaceWithMultiple(nodes);
            path.scope.registerDeclaration(importDeclaration);
          }
        }
      })));
      exports.default = _default;
    },
    797: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxJsonStrings = __webpack_require__(8775), _default = (0, 
      _helperPluginUtils.declare)((api => {
        api.assertVersion(7);
        const regex = /(\\*)([\u2028\u2029])/g;
        function replace(match, escapes, separator) {
          return escapes.length % 2 == 1 ? match : `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
        }
        return {
          name: "proposal-json-strings",
          inherits: _pluginSyntaxJsonStrings.default,
          visitor: {
            "DirectiveLiteral|StringLiteral"({node}) {
              const {extra} = node;
              null != extra && extra.raw && (extra.raw = extra.raw.replace(regex, replace));
            }
          }
        };
      }));
      exports.default = _default;
    },
    566: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxLogicalAssignmentOperators = __webpack_require__(399), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "proposal-logical-assignment-operators",
        inherits: _pluginSyntaxLogicalAssignmentOperators.default,
        visitor: {
          AssignmentExpression(path) {
            const {node, scope} = path, {operator, left, right} = node, operatorTrunc = operator.slice(0, -1);
            if (!_core.types.LOGICAL_OPERATORS.includes(operatorTrunc)) return;
            const lhs = _core.types.cloneNode(left);
            if (_core.types.isMemberExpression(left)) {
              const {object, property, computed} = left, memo = scope.maybeGenerateMemoised(object);
              if (memo && (left.object = memo, lhs.object = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), object)), 
              computed) {
                const memo = scope.maybeGenerateMemoised(property);
                memo && (left.property = memo, lhs.property = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), property));
              }
            }
            path.replaceWith(_core.types.logicalExpression(operatorTrunc, lhs, _core.types.assignmentExpression("=", left, right)));
          }
        }
      })));
      exports.default = _default;
    },
    7595: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxNullishCoalescingOperator = __webpack_require__(9338), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)(((api, {loose = !1}) => {
        var _api$assumption;
        api.assertVersion(7);
        const noDocumentAll = null != (_api$assumption = api.assumption("noDocumentAll")) ? _api$assumption : loose;
        return {
          name: "proposal-nullish-coalescing-operator",
          inherits: _pluginSyntaxNullishCoalescingOperator.default,
          visitor: {
            LogicalExpression(path) {
              const {node, scope} = path;
              if ("??" !== node.operator) return;
              let ref, assignment;
              if (scope.isStatic(node.left)) ref = node.left, assignment = _core.types.cloneNode(node.left); else {
                if (scope.path.isPattern()) return void path.replaceWith(_core.template.ast`(() => ${path.node})()`);
                ref = scope.generateUidIdentifierBasedOnNode(node.left), scope.push({
                  id: _core.types.cloneNode(ref)
                }), assignment = _core.types.assignmentExpression("=", ref, node.left);
              }
              path.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));
            }
          }
        };
      }));
      exports.default = _default;
    },
    7635: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxNumericSeparator = __webpack_require__(3594);
      function remover({node}) {
        var _extra$raw;
        const {extra} = node;
        null != extra && null != (_extra$raw = extra.raw) && _extra$raw.includes("_") && (extra.raw = extra.raw.replace(/_/g, ""));
      }
      var _default = (0, _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "proposal-numeric-separator",
        inherits: _pluginSyntaxNumericSeparator.default,
        visitor: {
          NumericLiteral: remover,
          BigIntLiteral: remover
        }
      })));
      exports.default = _default;
    },
    3578: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var helperPluginUtils = __webpack_require__(4982), syntaxObjectRestSpread = __webpack_require__(7196), core = __webpack_require__(4629), pluginTransformParameters = __webpack_require__(9425), helperCompilationTargets = __webpack_require__(4077);
      function _interopDefaultLegacy(e) {
        return e && "object" == typeof e && "default" in e ? e : {
          default: e
        };
      }
      var syntaxObjectRestSpread__default = _interopDefaultLegacy(syntaxObjectRestSpread), corejs2BuiltIns = {
        "es6.array.copy-within": {
          chrome: "45",
          opera: "32",
          edge: "12",
          firefox: "32",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "5",
          rhino: "1.7.13",
          electron: "0.31"
        },
        "es6.array.every": {
          chrome: "5",
          opera: "10.10",
          edge: "12",
          firefox: "2",
          safari: "3.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.fill": {
          chrome: "45",
          opera: "32",
          edge: "12",
          firefox: "31",
          safari: "7.1",
          node: "4",
          ios: "8",
          samsung: "5",
          rhino: "1.7.13",
          electron: "0.31"
        },
        "es6.array.filter": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.array.find": {
          chrome: "45",
          opera: "32",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "4",
          ios: "8",
          samsung: "5",
          rhino: "1.7.13",
          electron: "0.31"
        },
        "es6.array.find-index": {
          chrome: "45",
          opera: "32",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "4",
          ios: "8",
          samsung: "5",
          rhino: "1.7.13",
          electron: "0.31"
        },
        "es7.array.flat-map": {
          chrome: "69",
          opera: "56",
          edge: "79",
          firefox: "62",
          safari: "12",
          node: "11",
          ios: "12",
          samsung: "10",
          electron: "4.0"
        },
        "es6.array.for-each": {
          chrome: "5",
          opera: "10.10",
          edge: "12",
          firefox: "2",
          safari: "3.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.from": {
          chrome: "51",
          opera: "38",
          edge: "15",
          firefox: "36",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es7.array.includes": {
          chrome: "47",
          opera: "34",
          edge: "14",
          firefox: "43",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.36"
        },
        "es6.array.index-of": {
          chrome: "5",
          opera: "10.10",
          edge: "12",
          firefox: "2",
          safari: "3.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.is-array": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "4",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.iterator": {
          chrome: "66",
          opera: "53",
          edge: "12",
          firefox: "60",
          safari: "9",
          node: "10",
          ios: "9",
          samsung: "9",
          rhino: "1.7.13",
          electron: "3.0"
        },
        "es6.array.last-index-of": {
          chrome: "5",
          opera: "10.10",
          edge: "12",
          firefox: "2",
          safari: "3.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.map": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.array.of": {
          chrome: "45",
          opera: "32",
          edge: "12",
          firefox: "25",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "5",
          rhino: "1.7.13",
          electron: "0.31"
        },
        "es6.array.reduce": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "3",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.reduce-right": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "3",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.slice": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.array.some": {
          chrome: "5",
          opera: "10.10",
          edge: "12",
          firefox: "2",
          safari: "3.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.array.sort": {
          chrome: "63",
          opera: "50",
          edge: "12",
          firefox: "5",
          safari: "12",
          node: "10",
          ie: "9",
          ios: "12",
          samsung: "8",
          rhino: "1.7.13",
          electron: "3.0"
        },
        "es6.array.species": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.date.now": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "2",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.date.to-iso-string": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "3.5",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.date.to-json": {
          chrome: "5",
          opera: "12.10",
          edge: "12",
          firefox: "4",
          safari: "10",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "10",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.date.to-primitive": {
          chrome: "47",
          opera: "34",
          edge: "15",
          firefox: "44",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.36"
        },
        "es6.date.to-string": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "2",
          safari: "3.1",
          node: "0.10",
          ie: "10",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.function.bind": {
          chrome: "7",
          opera: "12",
          edge: "12",
          firefox: "4",
          safari: "5.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.function.has-instance": {
          chrome: "51",
          opera: "38",
          edge: "15",
          firefox: "50",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.function.name": {
          chrome: "5",
          opera: "10.50",
          edge: "14",
          firefox: "2",
          safari: "4",
          node: "0.10",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.map": {
          chrome: "51",
          opera: "38",
          edge: "15",
          firefox: "53",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.math.acosh": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.asinh": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.atanh": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.cbrt": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.clz32": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "31",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.cosh": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.expm1": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.fround": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "26",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.hypot": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "27",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.imul": {
          chrome: "30",
          opera: "17",
          edge: "12",
          firefox: "23",
          safari: "7",
          node: "0.12",
          android: "4.4",
          ios: "7",
          samsung: "2",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.log1p": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.log10": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.log2": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.sign": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.sinh": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.tanh": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.math.trunc": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "25",
          safari: "7.1",
          node: "0.12",
          ios: "8",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.constructor": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "36",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.number.epsilon": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "25",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.number.is-finite": {
          chrome: "19",
          opera: "15",
          edge: "12",
          firefox: "16",
          safari: "9",
          node: "0.12",
          android: "4.1",
          ios: "9",
          samsung: "1.5",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.is-integer": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "16",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.is-nan": {
          chrome: "19",
          opera: "15",
          edge: "12",
          firefox: "15",
          safari: "9",
          node: "0.12",
          android: "4.1",
          ios: "9",
          samsung: "1.5",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.is-safe-integer": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "32",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.max-safe-integer": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "31",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.min-safe-integer": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "31",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.number.parse-float": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "25",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.number.parse-int": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "25",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "2",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.object.assign": {
          chrome: "49",
          opera: "36",
          edge: "13",
          firefox: "36",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.object.create": {
          chrome: "5",
          opera: "12",
          edge: "12",
          firefox: "4",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es7.object.define-getter": {
          chrome: "62",
          opera: "49",
          edge: "16",
          firefox: "48",
          safari: "9",
          node: "8.10",
          ios: "9",
          samsung: "8",
          electron: "3.0"
        },
        "es7.object.define-setter": {
          chrome: "62",
          opera: "49",
          edge: "16",
          firefox: "48",
          safari: "9",
          node: "8.10",
          ios: "9",
          samsung: "8",
          electron: "3.0"
        },
        "es6.object.define-property": {
          chrome: "5",
          opera: "12",
          edge: "12",
          firefox: "4",
          safari: "5.1",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.object.define-properties": {
          chrome: "5",
          opera: "12",
          edge: "12",
          firefox: "4",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es7.object.entries": {
          chrome: "54",
          opera: "41",
          edge: "14",
          firefox: "47",
          safari: "10.1",
          node: "7",
          ios: "10.3",
          samsung: "6",
          rhino: "1.7.14",
          electron: "1.4"
        },
        "es6.object.freeze": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es6.object.get-own-property-descriptor": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es7.object.get-own-property-descriptors": {
          chrome: "54",
          opera: "41",
          edge: "15",
          firefox: "50",
          safari: "10.1",
          node: "7",
          ios: "10.3",
          samsung: "6",
          electron: "1.4"
        },
        "es6.object.get-own-property-names": {
          chrome: "40",
          opera: "27",
          edge: "12",
          firefox: "33",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.object.get-prototype-of": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es7.object.lookup-getter": {
          chrome: "62",
          opera: "49",
          edge: "79",
          firefox: "36",
          safari: "9",
          node: "8.10",
          ios: "9",
          samsung: "8",
          electron: "3.0"
        },
        "es7.object.lookup-setter": {
          chrome: "62",
          opera: "49",
          edge: "79",
          firefox: "36",
          safari: "9",
          node: "8.10",
          ios: "9",
          samsung: "8",
          electron: "3.0"
        },
        "es6.object.prevent-extensions": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es6.object.to-string": {
          chrome: "57",
          opera: "44",
          edge: "15",
          firefox: "51",
          safari: "10",
          node: "8",
          ios: "10",
          samsung: "7",
          electron: "1.7"
        },
        "es6.object.is": {
          chrome: "19",
          opera: "15",
          edge: "12",
          firefox: "22",
          safari: "9",
          node: "0.12",
          android: "4.1",
          ios: "9",
          samsung: "1.5",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.object.is-frozen": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es6.object.is-sealed": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es6.object.is-extensible": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es6.object.keys": {
          chrome: "40",
          opera: "27",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.object.seal": {
          chrome: "44",
          opera: "31",
          edge: "12",
          firefox: "35",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "4",
          rhino: "1.7.13",
          electron: "0.30"
        },
        "es6.object.set-prototype-of": {
          chrome: "34",
          opera: "21",
          edge: "12",
          firefox: "31",
          safari: "9",
          node: "0.12",
          ie: "11",
          ios: "9",
          samsung: "2",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es7.object.values": {
          chrome: "54",
          opera: "41",
          edge: "14",
          firefox: "47",
          safari: "10.1",
          node: "7",
          ios: "10.3",
          samsung: "6",
          rhino: "1.7.14",
          electron: "1.4"
        },
        "es6.promise": {
          chrome: "51",
          opera: "38",
          edge: "14",
          firefox: "45",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es7.promise.finally": {
          chrome: "63",
          opera: "50",
          edge: "18",
          firefox: "58",
          safari: "11.1",
          node: "10",
          ios: "11.3",
          samsung: "8",
          electron: "3.0"
        },
        "es6.reflect.apply": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.construct": {
          chrome: "49",
          opera: "36",
          edge: "13",
          firefox: "49",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.define-property": {
          chrome: "49",
          opera: "36",
          edge: "13",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.delete-property": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.get": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.get-own-property-descriptor": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.get-prototype-of": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.has": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.is-extensible": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.own-keys": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.prevent-extensions": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.set": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.reflect.set-prototype-of": {
          chrome: "49",
          opera: "36",
          edge: "12",
          firefox: "42",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "0.37"
        },
        "es6.regexp.constructor": {
          chrome: "50",
          opera: "37",
          edge: "79",
          firefox: "40",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "1.1"
        },
        "es6.regexp.flags": {
          chrome: "49",
          opera: "36",
          edge: "79",
          firefox: "37",
          safari: "9",
          node: "6",
          ios: "9",
          samsung: "5",
          electron: "0.37"
        },
        "es6.regexp.match": {
          chrome: "50",
          opera: "37",
          edge: "79",
          firefox: "49",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          rhino: "1.7.13",
          electron: "1.1"
        },
        "es6.regexp.replace": {
          chrome: "50",
          opera: "37",
          edge: "79",
          firefox: "49",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "1.1"
        },
        "es6.regexp.split": {
          chrome: "50",
          opera: "37",
          edge: "79",
          firefox: "49",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "1.1"
        },
        "es6.regexp.search": {
          chrome: "50",
          opera: "37",
          edge: "79",
          firefox: "49",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          rhino: "1.7.13",
          electron: "1.1"
        },
        "es6.regexp.to-string": {
          chrome: "50",
          opera: "37",
          edge: "79",
          firefox: "39",
          safari: "10",
          node: "6",
          ios: "10",
          samsung: "5",
          electron: "1.1"
        },
        "es6.set": {
          chrome: "51",
          opera: "38",
          edge: "15",
          firefox: "53",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.symbol": {
          chrome: "51",
          opera: "38",
          edge: "79",
          firefox: "51",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es7.symbol.async-iterator": {
          chrome: "63",
          opera: "50",
          edge: "79",
          firefox: "57",
          safari: "12",
          node: "10",
          ios: "12",
          samsung: "8",
          electron: "3.0"
        },
        "es6.string.anchor": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.big": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.blink": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.bold": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.code-point-at": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "29",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.string.ends-with": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "29",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.string.fixed": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.fontcolor": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.fontsize": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.from-code-point": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "29",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.string.includes": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "40",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.string.italics": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.iterator": {
          chrome: "38",
          opera: "25",
          edge: "12",
          firefox: "36",
          safari: "9",
          node: "0.12",
          ios: "9",
          samsung: "3",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.string.link": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es7.string.pad-start": {
          chrome: "57",
          opera: "44",
          edge: "15",
          firefox: "48",
          safari: "10",
          node: "8",
          ios: "10",
          samsung: "7",
          rhino: "1.7.13",
          electron: "1.7"
        },
        "es7.string.pad-end": {
          chrome: "57",
          opera: "44",
          edge: "15",
          firefox: "48",
          safari: "10",
          node: "8",
          ios: "10",
          samsung: "7",
          rhino: "1.7.13",
          electron: "1.7"
        },
        "es6.string.raw": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "34",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.14",
          electron: "0.21"
        },
        "es6.string.repeat": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "24",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.string.small": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.starts-with": {
          chrome: "41",
          opera: "28",
          edge: "12",
          firefox: "29",
          safari: "9",
          node: "4",
          ios: "9",
          samsung: "3.4",
          rhino: "1.7.13",
          electron: "0.21"
        },
        "es6.string.strike": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.sub": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.sup": {
          chrome: "5",
          opera: "15",
          edge: "12",
          firefox: "17",
          safari: "6",
          node: "0.10",
          android: "4",
          ios: "7",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.14",
          electron: "0.20"
        },
        "es6.string.trim": {
          chrome: "5",
          opera: "10.50",
          edge: "12",
          firefox: "3.5",
          safari: "4",
          node: "0.10",
          ie: "9",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es7.string.trim-left": {
          chrome: "66",
          opera: "53",
          edge: "79",
          firefox: "61",
          safari: "12",
          node: "10",
          ios: "12",
          samsung: "9",
          rhino: "1.7.13",
          electron: "3.0"
        },
        "es7.string.trim-right": {
          chrome: "66",
          opera: "53",
          edge: "79",
          firefox: "61",
          safari: "12",
          node: "10",
          ios: "12",
          samsung: "9",
          rhino: "1.7.13",
          electron: "3.0"
        },
        "es6.typed.array-buffer": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.data-view": {
          chrome: "5",
          opera: "12",
          edge: "12",
          firefox: "15",
          safari: "5.1",
          node: "0.10",
          ie: "10",
          android: "4",
          ios: "6",
          phantom: "2",
          samsung: "1",
          rhino: "1.7.13",
          electron: "0.20"
        },
        "es6.typed.int8-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.uint8-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.uint8-clamped-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.int16-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.uint16-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.int32-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.uint32-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.float32-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.typed.float64-array": {
          chrome: "51",
          opera: "38",
          edge: "13",
          firefox: "48",
          safari: "10",
          node: "6.5",
          ios: "10",
          samsung: "5",
          electron: "1.2"
        },
        "es6.weak-map": {
          chrome: "51",
          opera: "38",
          edge: "15",
          firefox: "53",
          safari: "9",
          node: "6.5",
          ios: "9",
          samsung: "5",
          electron: "1.2"
        },
        "es6.weak-set": {
          chrome: "51",
          opera: "38",
          edge: "15",
          firefox: "53",
          safari: "9",
          node: "6.5",
          ios: "9",
          samsung: "5",
          electron: "1.2"
        }
      };
      const {isObjectProperty: isObjectProperty$1, isArrayPattern, isObjectPattern, isAssignmentPattern: isAssignmentPattern$1, isRestElement, isIdentifier} = core.types;
      function shouldStoreRHSInTemporaryVariable(node) {
        if (isArrayPattern(node)) {
          const nonNullElements = node.elements.filter((element => null !== element));
          return nonNullElements.length > 1 || shouldStoreRHSInTemporaryVariable(nonNullElements[0]);
        }
        if (isObjectPattern(node)) {
          const {properties} = node;
          if (properties.length > 1) return !0;
          if (0 === properties.length) return !1;
          {
            const firstProperty = properties[0];
            return isObjectProperty$1(firstProperty) ? shouldStoreRHSInTemporaryVariable(firstProperty.value) : shouldStoreRHSInTemporaryVariable(firstProperty);
          }
        }
        return isAssignmentPattern$1(node) ? shouldStoreRHSInTemporaryVariable(node.left) : !!isRestElement(node) && (!!isIdentifier(node.argument) || shouldStoreRHSInTemporaryVariable(node.argument));
      }
      const {isAssignmentPattern, isObjectProperty} = core.types;
      {
        const node = core.types.identifier("a"), property = core.types.objectProperty(core.types.identifier("key"), node), pattern = core.types.objectPattern([ property ]);
        var ZERO_REFS = core.types.isReferenced(node, property, pattern) ? 1 : 0;
      }
      var index = helperPluginUtils.declare(((api, opts) => {
        var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
        api.assertVersion(7);
        const targets = api.targets(), supportsObjectAssign = !helperCompilationTargets.isRequired("es6.object.assign", targets, {
          compatData: corejs2BuiltIns
        }), {useBuiltIns = supportsObjectAssign, loose = !1} = opts;
        if ("boolean" != typeof loose) throw new Error(".loose must be a boolean, or undefined");
        const ignoreFunctionLength = null != (_api$assumption = api.assumption("ignoreFunctionLength")) ? _api$assumption : loose, objectRestNoSymbols = null != (_api$assumption2 = api.assumption("objectRestNoSymbols")) ? _api$assumption2 : loose, pureGetters = null != (_api$assumption3 = api.assumption("pureGetters")) ? _api$assumption3 : loose, setSpreadProperties = null != (_api$assumption4 = api.assumption("setSpreadProperties")) ? _api$assumption4 : loose;
        function getExtendsHelper(file) {
          return useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : file.addHelper("extends");
        }
        function hasRestElement(path) {
          let foundRestElement = !1;
          return visitRestElements(path, (restElement => {
            foundRestElement = !0, restElement.stop();
          })), foundRestElement;
        }
        function hasObjectPatternRestElement(path) {
          let foundRestElement = !1;
          return visitRestElements(path, (restElement => {
            restElement.parentPath.isObjectPattern() && (foundRestElement = !0, restElement.stop());
          })), foundRestElement;
        }
        function visitRestElements(path, visitor) {
          path.traverse({
            Expression(path) {
              const {parent, key} = path;
              (isAssignmentPattern(parent) && "right" === key || isObjectProperty(parent) && parent.computed && "key" === key) && path.skip();
            },
            RestElement: visitor
          });
        }
        function replaceImpureComputedKeys(properties, scope) {
          const impureComputedPropertyDeclarators = [];
          for (const propPath of properties) {
            const key = propPath.get("key");
            if (propPath.node.computed && !key.isPure()) {
              const name = scope.generateUidBasedOnNode(key.node), declarator = core.types.variableDeclarator(core.types.identifier(name), key.node);
              impureComputedPropertyDeclarators.push(declarator), key.replaceWith(core.types.identifier(name));
            }
          }
          return impureComputedPropertyDeclarators;
        }
        function createObjectRest(path, file, objRef) {
          const props = path.get("properties"), last = props[props.length - 1];
          core.types.assertRestElement(last.node);
          const restElement = core.types.cloneNode(last.node);
          last.remove();
          const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope), {keys, allLiteral, hasTemplateLiteral} = function(node) {
            const props = node.properties, keys = [];
            let allLiteral = !0, hasTemplateLiteral = !1;
            for (const prop of props) core.types.isIdentifier(prop.key) && !prop.computed ? keys.push(core.types.stringLiteral(prop.key.name)) : core.types.isTemplateLiteral(prop.key) ? (keys.push(core.types.cloneNode(prop.key)), 
            hasTemplateLiteral = !0) : core.types.isLiteral(prop.key) ? keys.push(core.types.stringLiteral(String(prop.key.value))) : (keys.push(core.types.cloneNode(prop.key)), 
            allLiteral = !1);
            return {
              keys,
              allLiteral,
              hasTemplateLiteral
            };
          }(path.node);
          if (0 === keys.length) return [ impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(getExtendsHelper(file), [ core.types.objectExpression([]), core.types.cloneNode(objRef) ]) ];
          let keyExpression;
          if (allLiteral) {
            if (keyExpression = core.types.arrayExpression(keys), !hasTemplateLiteral && !core.types.isProgram(path.scope.block)) {
              const program = path.findParent((path => path.isProgram())), id = path.scope.generateUidIdentifier("excluded");
              program.scope.push({
                id,
                init: keyExpression,
                kind: "const"
              }), keyExpression = core.types.cloneNode(id);
            }
          } else keyExpression = core.types.callExpression(core.types.memberExpression(core.types.arrayExpression(keys), core.types.identifier("map")), [ file.addHelper("toPropertyKey") ]);
          return [ impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(file.addHelper("objectWithoutProperties" + (objectRestNoSymbols ? "Loose" : "")), [ core.types.cloneNode(objRef), keyExpression ]) ];
        }
        function replaceRestElement(parentPath, paramPath, container) {
          if (paramPath.isAssignmentPattern()) replaceRestElement(parentPath, paramPath.get("left"), container); else {
            if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
              const elements = paramPath.get("elements");
              for (let i = 0; i < elements.length; i++) replaceRestElement(parentPath, elements[i], container);
            }
            if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
              const uid = parentPath.scope.generateUidIdentifier("ref"), declar = core.types.variableDeclaration("let", [ core.types.variableDeclarator(paramPath.node, uid) ]);
              container ? container.push(declar) : (parentPath.ensureBlock(), parentPath.get("body").unshiftContainer("body", declar)), 
              paramPath.replaceWith(core.types.cloneNode(uid));
            }
          }
        }
        return {
          name: "proposal-object-rest-spread",
          inherits: syntaxObjectRestSpread__default.default.default,
          visitor: {
            Function(path) {
              const params = path.get("params"), paramsWithRestElement = new Set, idsInRestParams = new Set;
              for (let i = 0; i < params.length; ++i) {
                const param = params[i];
                if (hasRestElement(param)) {
                  paramsWithRestElement.add(i);
                  for (const name of Object.keys(param.getBindingIdentifiers())) idsInRestParams.add(name);
                }
              }
              let idInRest = !1;
              const IdentifierHandler = function(path, functionScope) {
                const name = path.node.name;
                path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name) && (idInRest = !0, 
                path.stop());
              };
              let i;
              for (i = 0; i < params.length && !idInRest; ++i) {
                const param = params[i];
                paramsWithRestElement.has(i) || (param.isReferencedIdentifier() || param.isBindingIdentifier() ? IdentifierHandler(path, path.scope) : param.traverse({
                  "Scope|TypeAnnotation|TSTypeAnnotation": path => path.skip(),
                  "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
                }, path.scope));
              }
              if (idInRest) {
                const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);
                pluginTransformParameters.convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);
              } else for (let i = 0; i < params.length; ++i) {
                const param = params[i];
                paramsWithRestElement.has(i) && replaceRestElement(path, param);
              }
            },
            VariableDeclarator(path, file) {
              if (!path.get("id").isObjectPattern()) return;
              let insertionPath = path;
              const originalPath = path;
              visitRestElements(path.get("id"), (path => {
                if (!path.parentPath.isObjectPattern()) return;
                if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !core.types.isIdentifier(originalPath.node.init)) {
                  const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
                  return originalPath.insertBefore(core.types.variableDeclarator(initRef, originalPath.node.init)), 
                  void originalPath.replaceWith(core.types.variableDeclarator(originalPath.node.id, core.types.cloneNode(initRef)));
                }
                let ref = originalPath.node.init;
                const refPropertyPath = [];
                let kind;
                path.findParent((path => {
                  if (path.isObjectProperty()) refPropertyPath.unshift(path); else if (path.isVariableDeclarator()) return kind = path.parentPath.node.kind, 
                  !0;
                }));
                const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
                refPropertyPath.forEach((prop => {
                  const {node} = prop;
                  ref = core.types.memberExpression(ref, core.types.cloneNode(node.key), node.computed || core.types.isLiteral(node.key));
                }));
                const objectPatternPath = path.findParent((path => path.isObjectPattern())), [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(objectPatternPath, file, ref);
                pureGetters && function(path) {
                  const bindings = path.getOuterBindingIdentifierPaths();
                  Object.keys(bindings).forEach((bindingName => {
                    const bindingParentPath = bindings[bindingName].parentPath;
                    path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty() || bindingParentPath.remove();
                  }));
                }(objectPatternPath), core.types.assertIdentifier(argument), insertionPath.insertBefore(impureComputedPropertyDeclarators), 
                insertionPath.insertBefore(impureObjRefComputedDeclarators), insertionPath = insertionPath.insertAfter(core.types.variableDeclarator(argument, callExpression))[0], 
                path.scope.registerBinding(kind, insertionPath), 0 === objectPatternPath.node.properties.length && objectPatternPath.findParent((path => path.isObjectProperty() || path.isVariableDeclarator())).remove();
              }));
            },
            ExportNamedDeclaration(path) {
              const declaration = path.get("declaration");
              if (!declaration.isVariableDeclaration()) return;
              const hasRest = declaration.get("declarations").some((path => hasObjectPatternRestElement(path.get("id"))));
              if (!hasRest) return;
              const specifiers = [];
              for (const name of Object.keys(path.getOuterBindingIdentifiers(!0))) specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));
              path.replaceWith(declaration.node), path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));
            },
            CatchClause(path) {
              const paramPath = path.get("param");
              replaceRestElement(path, paramPath);
            },
            AssignmentExpression(path, file) {
              const leftPath = path.get("left");
              if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
                const nodes = [], refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
                nodes.push(core.types.variableDeclaration("var", [ core.types.variableDeclarator(core.types.identifier(refName), path.node.right) ]));
                const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(leftPath, file, core.types.identifier(refName));
                impureComputedPropertyDeclarators.length > 0 && nodes.push(core.types.variableDeclaration("var", impureComputedPropertyDeclarators));
                const nodeWithoutSpread = core.types.cloneNode(path.node);
                nodeWithoutSpread.right = core.types.identifier(refName), nodes.push(core.types.expressionStatement(nodeWithoutSpread)), 
                nodes.push(core.types.toStatement(core.types.assignmentExpression("=", argument, callExpression))), 
                nodes.push(core.types.expressionStatement(core.types.identifier(refName))), path.replaceWithMultiple(nodes);
              }
            },
            ForXStatement(path) {
              const {node, scope} = path, leftPath = path.get("left"), left = node.left;
              if (hasObjectPatternRestElement(leftPath)) if (core.types.isVariableDeclaration(left)) {
                const pattern = left.declarations[0].id, key = scope.generateUidIdentifier("ref");
                node.left = core.types.variableDeclaration(left.kind, [ core.types.variableDeclarator(key, null) ]), 
                path.ensureBlock();
                node.body.body.unshift(core.types.variableDeclaration(node.left.kind, [ core.types.variableDeclarator(pattern, core.types.cloneNode(key)) ]));
              } else {
                const temp = scope.generateUidIdentifier("ref");
                node.left = core.types.variableDeclaration("var", [ core.types.variableDeclarator(temp) ]), 
                path.ensureBlock();
                const body = node.body;
                0 === body.body.length && path.isCompletionRecord() && body.body.unshift(core.types.expressionStatement(scope.buildUndefinedNode())), 
                body.body.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", left, core.types.cloneNode(temp))));
              }
            },
            ArrayPattern(path) {
              const objectPatterns = [];
              if (visitRestElements(path, (path => {
                if (!path.parentPath.isObjectPattern()) return;
                const objectPattern = path.parentPath, uid = path.scope.generateUidIdentifier("ref");
                objectPatterns.push(core.types.variableDeclarator(objectPattern.node, uid)), objectPattern.replaceWith(core.types.cloneNode(uid)), 
                path.skip();
              })), objectPatterns.length > 0) {
                const statementPath = path.getStatementParent(), statementNode = statementPath.node, kind = "VariableDeclaration" === statementNode.type ? statementNode.kind : "var";
                statementPath.insertAfter(core.types.variableDeclaration(kind, objectPatterns));
              }
            },
            ObjectExpression(path, file) {
              if (!function(node) {
                for (const prop of node.properties) if (core.types.isSpreadElement(prop)) return !0;
                return !1;
              }(path.node)) return;
              let helper;
              if (setSpreadProperties) helper = getExtendsHelper(file); else try {
                helper = file.addHelper("objectSpread2");
              } catch (_unused) {
                this.file.declarations.objectSpread2 = null, helper = file.addHelper("objectSpread");
              }
              let exp = null, props = [];
              function make() {
                const hadProps = props.length > 0, obj = core.types.objectExpression(props);
                props = [], exp ? pureGetters ? hadProps && exp.arguments.push(obj) : exp = core.types.callExpression(core.types.cloneNode(helper), [ exp, ...hadProps ? [ core.types.objectExpression([]), obj ] : [] ]) : exp = core.types.callExpression(helper, [ obj ]);
              }
              for (const prop of path.node.properties) core.types.isSpreadElement(prop) ? (make(), 
              exp.arguments.push(prop.argument)) : props.push(prop);
              props.length && make(), path.replaceWith(exp);
            }
          }
        };
      }));
      exports.default = index;
    },
    9318: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxOptionalCatchBinding = __webpack_require__(9312), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "proposal-optional-catch-binding",
        inherits: _pluginSyntaxOptionalCatchBinding.default,
        visitor: {
          CatchClause(path) {
            if (!path.node.param) {
              const uid = path.scope.generateUidIdentifier("unused");
              path.get("param").replaceWith(uid);
            }
          }
        }
      })));
      exports.default = _default;
    },
    6288: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var helperPluginUtils = __webpack_require__(4982), syntaxOptionalChaining = __webpack_require__(4852), core = __webpack_require__(4629), helperSkipTransparentExpressionWrappers = __webpack_require__(4539);
      function _interopDefaultLegacy(e) {
        return e && "object" == typeof e && "default" in e ? e : {
          default: e
        };
      }
      var syntaxOptionalChaining__default = _interopDefaultLegacy(syntaxOptionalChaining);
      function willPathCastToBoolean(path) {
        const maybeWrapped = findOutermostTransparentParent(path), {node, parentPath} = maybeWrapped;
        if (parentPath.isLogicalExpression()) {
          const {operator, right} = parentPath.node;
          if ("&&" === operator || "||" === operator || "??" === operator && node === right) return willPathCastToBoolean(parentPath);
        }
        if (parentPath.isSequenceExpression()) {
          const {expressions} = parentPath.node;
          return expressions[expressions.length - 1] !== node || willPathCastToBoolean(parentPath);
        }
        return parentPath.isConditional({
          test: node
        }) || parentPath.isUnaryExpression({
          operator: "!"
        }) || parentPath.isLoop({
          test: node
        });
      }
      function findOutermostTransparentParent(path) {
        let maybeWrapped = path;
        return path.findParent((p => {
          if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return !0;
          maybeWrapped = p;
        })), maybeWrapped;
      }
      const {ast} = core.template.expression;
      function isSimpleMemberExpression(expression) {
        return expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression), 
        core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
      }
      function transform(path, {pureGetters, noDocumentAll}) {
        const {scope} = path, maybeWrapped = findOutermostTransparentParent(path), {parentPath} = maybeWrapped, willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);
        let isDeleteOperation = !1;
        const parentIsCall = parentPath.isCallExpression({
          callee: maybeWrapped.node
        }) && path.isOptionalMemberExpression(), optionals = [];
        let optionalPath = path;
        if (scope.path.isPattern() && function(path) {
          let optionalPath = path;
          const {scope} = path;
          for (;optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression(); ) {
            const {node} = optionalPath, childKey = optionalPath.isOptionalMemberExpression() ? "object" : "callee", childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(childKey));
            if (node.optional) return !scope.isStatic(childPath.node);
            optionalPath = childPath;
          }
        }(optionalPath)) return void path.replaceWith(core.template.ast`(() => ${path.node})()`);
        for (;optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression(); ) {
          const {node} = optionalPath;
          node.optional && optionals.push(node), optionalPath.isOptionalMemberExpression() ? (optionalPath.node.type = "MemberExpression", 
          optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"))) : optionalPath.isOptionalCallExpression() && (optionalPath.node.type = "CallExpression", 
          optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee")));
        }
        let replacementPath = path;
        parentPath.isUnaryExpression({
          operator: "delete"
        }) && (replacementPath = parentPath, isDeleteOperation = !0);
        for (let i = optionals.length - 1; i >= 0; i--) {
          const node = optionals[i], isCall = core.types.isCallExpression(node), replaceKey = isCall ? "callee" : "object", chainWithTypes = node[replaceKey], chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
          let ref, check;
          if (isCall && core.types.isIdentifier(chain, {
            name: "eval"
          }) ? (check = ref = chain, node[replaceKey] = core.types.sequenceExpression([ core.types.numericLiteral(0), ref ])) : pureGetters && isCall && isSimpleMemberExpression(chain) ? check = ref = chainWithTypes : (ref = scope.maybeGenerateMemoised(chain), 
          ref ? (check = core.types.assignmentExpression("=", core.types.cloneNode(ref), chainWithTypes), 
          node[replaceKey] = ref) : check = ref = chainWithTypes), isCall && core.types.isMemberExpression(chain)) if (pureGetters && isSimpleMemberExpression(chain)) node.callee = chainWithTypes; else {
            const {object} = chain;
            let context = scope.maybeGenerateMemoised(object);
            context ? chain.object = core.types.assignmentExpression("=", context, object) : context = core.types.isSuper(object) ? core.types.thisExpression() : object, 
            node.arguments.unshift(core.types.cloneNode(context)), node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
          }
          let replacement = replacementPath.node;
          if (0 === i && parentIsCall) {
            var _baseRef;
            const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
            let baseRef;
            pureGetters && isSimpleMemberExpression(object) || (baseRef = scope.maybeGenerateMemoised(object), 
            baseRef && (replacement.object = core.types.assignmentExpression("=", baseRef, object))), 
            replacement = core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [ core.types.cloneNode(null != (_baseRef = baseRef) ? _baseRef : object) ]);
          }
          if (willReplacementCastToBoolean) {
            const nonNullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} != null` : ast`
            ${core.types.cloneNode(check)} !== null && ${core.types.cloneNode(ref)} !== void 0`;
            replacementPath.replaceWith(core.types.logicalExpression("&&", nonNullishCheck, replacement)), 
            replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("right"));
          } else {
            const nullishCheck = noDocumentAll ? ast`${core.types.cloneNode(check)} == null` : ast`
            ${core.types.cloneNode(check)} === null || ${core.types.cloneNode(ref)} === void 0`, returnValue = isDeleteOperation ? ast`true` : ast`void 0`;
            replacementPath.replaceWith(core.types.conditionalExpression(nullishCheck, returnValue, replacement)), 
            replacementPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(replacementPath.get("alternate"));
          }
        }
      }
      var index = helperPluginUtils.declare(((api, options) => {
        var _api$assumption, _api$assumption2;
        api.assertVersion(7);
        const {loose = !1} = options, noDocumentAll = null != (_api$assumption = api.assumption("noDocumentAll")) ? _api$assumption : loose, pureGetters = null != (_api$assumption2 = api.assumption("pureGetters")) ? _api$assumption2 : loose;
        return {
          name: "proposal-optional-chaining",
          inherits: syntaxOptionalChaining__default.default.default,
          visitor: {
            "OptionalCallExpression|OptionalMemberExpression"(path) {
              transform(path, {
                noDocumentAll,
                pureGetters
              });
            }
          }
        };
      }));
      exports.default = index, exports.transform = transform;
    },
    2191: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperCreateClassFeaturesPlugin = __webpack_require__(6890), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => (api.assertVersion(7), (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
        name: "proposal-private-methods",
        api,
        feature: _helperCreateClassFeaturesPlugin.FEATURES.privateMethods,
        loose: options.loose,
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classPrivateMethods");
        }
      }))));
      exports.default = _default;
    },
    4008: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _pluginSyntaxPrivatePropertyInObject = __webpack_require__(2611), _helperCreateClassFeaturesPlugin = __webpack_require__(6890), _helperAnnotateAsPure = __webpack_require__(4321), _default = (0, 
      _helperPluginUtils.declare)((({assertVersion, types: t, template}, {loose}) => {
        assertVersion(7);
        const classWeakSets = new WeakMap;
        new WeakMap;
        function injectToFieldInit(fieldPath, expr, before = !1) {
          fieldPath.node.value ? before ? fieldPath.get("value").insertBefore(expr) : fieldPath.get("value").insertAfter(expr) : fieldPath.set("value", t.unaryExpression("void", expr));
        }
        function injectInitialization(classPath, init) {
          let firstFieldPath, consturctorPath;
          for (const el of classPath.get("body.body")) {
            if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {
              firstFieldPath = el;
              break;
            }
            !consturctorPath && el.isClassMethod({
              kind: "constructor"
            }) && (consturctorPath = el);
          }
          firstFieldPath ? injectToFieldInit(firstFieldPath, init, !0) : (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, consturctorPath, [ t.expressionStatement(init) ]);
        }
        function getWeakSetId(weakSets, outerClass, reference, name = "", inject) {
          let id = classWeakSets.get(reference.node);
          if (!id) {
            id = outerClass.scope.generateUidIdentifier(`${name || ""} brandCheck`), classWeakSets.set(reference.node, id), 
            inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);
            const newExpr = t.newExpression(t.identifier("WeakSet"), []);
            (0, _helperAnnotateAsPure.default)(newExpr), outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);
          }
          return t.cloneNode(id);
        }
        return {
          name: "proposal-private-property-in-object",
          inherits: _pluginSyntaxPrivatePropertyInObject.default,
          pre() {
            (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);
          },
          visitor: {
            BinaryExpression(path) {
              const {node} = path;
              if ("in" !== node.operator) return;
              if (!t.isPrivateName(node.left)) return;
              const {name} = node.left.id;
              let privateElement;
              const outerClass = path.findParent((path => !!path.isClass() && (privateElement = path.get("body.body").find((({node}) => t.isPrivate(node) && node.key.id.name === name)), 
              !!privateElement)));
              if (outerClass.parentPath.scope.path.isPattern()) outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`); else if (privateElement.isMethod()) if (privateElement.node.static) outerClass.node.id ? function(name, targetScope, scope) {
                for (;scope !== targetScope; ) scope.hasOwnBinding(name) && scope.rename(name), 
                scope = scope.parent;
              }(outerClass.node.id.name, outerClass.scope, path.scope) : outerClass.set("id", path.scope.generateUidIdentifier("class")), 
              path.replaceWith(template.expression.ast`
                ${t.cloneNode(outerClass.node.id)} === ${path.node.right}
              `); else {
                var _outerClass$node$id;
                const id = getWeakSetId(0, outerClass, outerClass, null == (_outerClass$node$id = outerClass.node.id) ? void 0 : _outerClass$node$id.name, injectInitialization);
                path.replaceWith(template.expression.ast`${id}.has(${path.node.right})`);
              } else {
                const id = getWeakSetId(0, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);
                path.replaceWith(template.expression.ast`${id}.has(${path.node.right})`);
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    4759: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperCreateRegexpFeaturesPlugin = __webpack_require__(1357), _default = (0, 
      __webpack_require__(4982).declare)(((api, options) => {
        api.assertVersion(7);
        const {useUnicodeFlag = !0} = options;
        if ("boolean" != typeof useUnicodeFlag) throw new Error(".useUnicodeFlag must be a boolean, or undefined");
        return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
          name: "proposal-unicode-property-regex",
          feature: "unicodePropertyEscape",
          options: {
            useUnicodeFlag
          }
        });
      }));
      exports.default = _default;
    },
    894: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-async-generators",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      })));
      exports.default = _default;
    },
    3876: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-class-properties",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        }
      })));
      exports.default = _default;
    },
    7249: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-class-static-block",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classStaticBlock");
        }
      })));
      exports.default = _default;
    },
    642: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-dynamic-import",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("dynamicImport");
        }
      })));
      exports.default = _default;
    },
    494: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-export-namespace-from",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("exportNamespaceFrom");
        }
      })));
      exports.default = _default;
    },
    8775: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-json-strings",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("jsonStrings");
        }
      })));
      exports.default = _default;
    },
    399: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-logical-assignment-operators",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("logicalAssignment");
        }
      })));
      exports.default = _default;
    },
    9338: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-nullish-coalescing-operator",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        }
      })));
      exports.default = _default;
    },
    3594: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-numeric-separator",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("numericSeparator");
        }
      })));
      exports.default = _default;
    },
    7196: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-object-rest-spread",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      })));
      exports.default = _default;
    },
    9312: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-optional-catch-binding",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      })));
      exports.default = _default;
    },
    4852: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-optional-chaining",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        }
      })));
      exports.default = _default;
    },
    2611: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-private-property-in-object",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("privateIn");
        }
      })));
      exports.default = _default;
    },
    7934: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "syntax-top-level-await",
        manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("topLevelAwait");
        }
      })));
      exports.default = _default;
    },
    8339: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)(((api, options) => {
        var _api$assumption;
        api.assertVersion(7);
        const noNewArrows = null != (_api$assumption = api.assumption("noNewArrows")) ? _api$assumption : !options.spec;
        return {
          name: "transform-arrow-functions",
          visitor: {
            ArrowFunctionExpression(path) {
              path.isArrowFunctionExpression() && path.arrowFunctionToExpression({
                allowInsertArrow: !1,
                noNewArrows,
                specCompliant: !noNewArrows
              });
            }
          }
        };
      }));
      exports.default = _default;
    },
    5897: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperRemapAsyncToGenerator = __webpack_require__(5108), _helperModuleImports = __webpack_require__(203), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        api.assertVersion(7);
        const {method, module} = options, noNewArrows = api.assumption("noNewArrows"), ignoreFunctionLength = api.assumption("ignoreFunctionLength");
        return method && module ? {
          name: "transform-async-to-generator",
          visitor: {
            Function(path, state) {
              if (!path.node.async || path.node.generator) return;
              let wrapAsync = state.methodWrapper;
              wrapAsync = wrapAsync ? _core.types.cloneNode(wrapAsync) : state.methodWrapper = (0, 
              _helperModuleImports.addNamed)(path, method, module), (0, _helperRemapAsyncToGenerator.default)(path, {
                wrapAsync
              }, noNewArrows, ignoreFunctionLength);
            }
          }
        } : {
          name: "transform-async-to-generator",
          visitor: {
            Function(path, state) {
              path.node.async && !path.node.generator && (0, _helperRemapAsyncToGenerator.default)(path, {
                wrapAsync: state.addHelper("asyncToGenerator")
              }, noNewArrows, ignoreFunctionLength);
            }
          }
        };
      }));
      exports.default = _default;
    },
    3590: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => {
        function statementList(key, path) {
          const paths = path.get(key);
          for (const path of paths) {
            const func = path.node;
            if (!path.isFunctionDeclaration()) continue;
            const declar = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(func.id, _core.types.toExpression(func)) ]);
            declar._blockHoist = 2, func.id = null, path.replaceWith(declar);
          }
        }
        return api.assertVersion(7), {
          name: "transform-block-scoped-functions",
          visitor: {
            BlockStatement(path) {
              const {node, parent} = path;
              _core.types.isFunction(parent, {
                body: node
              }) || _core.types.isExportDeclaration(parent) || statementList("body", path);
            },
            SwitchCase(path) {
              statementList("consequent", path);
            }
          }
        };
      }));
      exports.default = _default;
    },
    3115: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _tdz = __webpack_require__(4601), _core = __webpack_require__(4629);
      const DONE = new WeakSet;
      var _default = (0, _helperPluginUtils.declare)(((api, opts) => {
        api.assertVersion(7);
        const {throwIfClosureRequired = !1, tdz: tdzEnabled = !1} = opts;
        if ("boolean" != typeof throwIfClosureRequired) throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
        if ("boolean" != typeof tdzEnabled) throw new Error(".tdz must be a boolean, or undefined");
        return {
          name: "transform-block-scoping",
          visitor: {
            VariableDeclaration(path) {
              const {node, parent, scope} = path;
              if (isBlockScoped(node) && (convertBlockScopedToVar(path, null, parent, scope, !0), 
              node._tdzThis)) {
                const nodes = [ node ];
                for (let i = 0; i < node.declarations.length; i++) {
                  const decl = node.declarations[i], assign = _core.types.assignmentExpression("=", _core.types.cloneNode(decl.id), decl.init || scope.buildUndefinedNode());
                  assign._ignoreBlockScopingTDZ = !0, nodes.push(_core.types.expressionStatement(assign)), 
                  decl.init = this.addHelper("temporalUndefined");
                }
                node._blockHoist = 2, path.isCompletionRecord() && nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode())), 
                path.replaceWithMultiple(nodes);
              }
            },
            Loop(path, state) {
              const {parent, scope} = path;
              path.ensureBlock();
              const replace = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state).run();
              replace && path.replaceWith(replace);
            },
            CatchClause(path, state) {
              const {parent, scope} = path;
              new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state).run();
            },
            "BlockStatement|SwitchStatement|Program"(path, state) {
              if (!function(path) {
                return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);
              }(path)) {
                new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state).run();
              }
            }
          }
        };
      }));
      exports.default = _default;
      const buildRetCheck = (0, _core.template)('\n  if (typeof RETURN === "object") return RETURN.v;\n');
      function isBlockScoped(node) {
        return !!_core.types.isVariableDeclaration(node) && (!!node[_core.types.BLOCK_SCOPED_SYMBOL] || ("let" === node.kind || "const" === node.kind));
      }
      function isInLoop(path) {
        const loopOrFunctionParent = path.find((path => path.isLoop() || path.isFunction()));
        return null == loopOrFunctionParent ? void 0 : loopOrFunctionParent.isLoop();
      }
      function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent = !1) {
        if (node || (node = path.node), isInLoop(path) && !_core.types.isFor(parent)) for (let i = 0; i < node.declarations.length; i++) {
          const declar = node.declarations[i];
          declar.init = declar.init || scope.buildUndefinedNode();
        }
        if (node[_core.types.BLOCK_SCOPED_SYMBOL] = !0, node.kind = "var", moveBindingsToParent) {
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          for (const name of Object.keys(path.getBindingIdentifiers())) {
            const binding = scope.getOwnBinding(name);
            binding && (binding.kind = "var"), scope.moveBindingTo(name, parentScope);
          }
        }
      }
      function isVar(node) {
        return _core.types.isVariableDeclaration(node, {
          kind: "var"
        }) && !isBlockScoped(node);
      }
      const letReferenceBlockVisitor = _core.traverse.visitors.merge([ {
        Loop: {
          enter(path, state) {
            state.loopDepth++;
          },
          exit(path, state) {
            state.loopDepth--;
          }
        },
        FunctionParent: (path, state) => (state.loopDepth > 0 ? path.traverse(letReferenceFunctionVisitor, state) : path.traverse(_tdz.visitor, state), 
        path.skip())
      }, _tdz.visitor ]), letReferenceFunctionVisitor = _core.traverse.visitors.merge([ {
        ReferencedIdentifier(path, state) {
          const ref = state.letReferences.get(path.node.name);
          if (!ref) return;
          const localBinding = path.scope.getBindingIdentifier(path.node.name);
          localBinding && localBinding !== ref || (state.closurify = !0);
        }
      }, _tdz.visitor ]), hoistVarDeclarationsVisitor = {
        enter(path, self) {
          if (path.isForStatement()) {
            const {node} = path;
            if (isVar(node.init)) {
              const nodes = self.pushDeclar(node.init);
              1 === nodes.length ? node.init = nodes[0] : node.init = _core.types.sequenceExpression(nodes);
            }
          } else if (path.isForInStatement() || path.isForOfStatement()) {
            const {node} = path;
            isVar(node.left) && (self.pushDeclar(node.left), node.left = node.left.declarations[0].id);
          } else if (isVar(path.node)) path.replaceWithMultiple(self.pushDeclar(path.node).map((expr => _core.types.expressionStatement(expr)))); else if (path.isFunction()) return path.skip();
        }
      }, loopLabelVisitor = {
        LabeledStatement({node}, state) {
          state.innerLabels.push(node.label.name);
        }
      }, continuationVisitor = {
        enter(path, state) {
          if (path.isAssignmentExpression() || path.isUpdateExpression()) for (const name of Object.keys(path.getBindingIdentifiers())) state.outsideReferences.get(name) === path.scope.getBindingIdentifier(name) && (state.reassignments[name] = !0); else path.isReturnStatement() && state.returnStatements.push(path);
        }
      };
      const loopVisitor = {
        Loop(path, state) {
          const oldIgnoreLabeless = state.ignoreLabeless;
          state.ignoreLabeless = !0, path.traverse(loopVisitor, state), state.ignoreLabeless = oldIgnoreLabeless, 
          path.skip();
        },
        Function(path) {
          path.skip();
        },
        SwitchCase(path, state) {
          const oldInSwitchCase = state.inSwitchCase;
          state.inSwitchCase = !0, path.traverse(loopVisitor, state), state.inSwitchCase = oldInSwitchCase, 
          path.skip();
        },
        "BreakStatement|ContinueStatement|ReturnStatement"(path, state) {
          const {node, scope} = path;
          if (node[this.LOOP_IGNORE]) return;
          let replace, loopText = function(node) {
            return _core.types.isBreakStatement(node) ? "break" : _core.types.isContinueStatement(node) ? "continue" : void 0;
          }(node);
          if (loopText) {
            if (_core.types.isReturnStatement(node)) throw new Error("Internal error: unexpected return statement with `loopText`");
            if (node.label) {
              if (state.innerLabels.indexOf(node.label.name) >= 0) return;
              loopText = `${loopText}|${node.label.name}`;
            } else {
              if (state.ignoreLabeless) return;
              if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;
            }
            state.hasBreakContinue = !0, state.map[loopText] = node, replace = _core.types.stringLiteral(loopText);
          }
          _core.types.isReturnStatement(node) && (state.hasReturn = !0, replace = _core.types.objectExpression([ _core.types.objectProperty(_core.types.identifier("v"), node.argument || scope.buildUndefinedNode()) ])), 
          replace && (replace = _core.types.returnStatement(replace), replace[this.LOOP_IGNORE] = !0, 
          path.skip(), path.replaceWith(_core.types.inherits(replace, node)));
        }
      };
      class BlockScoping {
        constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
          this.parent = void 0, this.state = void 0, this.scope = void 0, this.throwIfClosureRequired = void 0, 
          this.tdzEnabled = void 0, this.blockPath = void 0, this.block = void 0, this.outsideLetReferences = void 0, 
          this.hasLetReferences = void 0, this.letReferences = void 0, this.body = void 0, 
          this.loopParent = void 0, this.loopLabel = void 0, this.loopPath = void 0, this.loop = void 0, 
          this.has = void 0, this.parent = parent, this.scope = scope, this.state = state, 
          this.throwIfClosureRequired = throwIfClosureRequired, this.tdzEnabled = tdzEnabled, 
          this.blockPath = blockPath, this.block = blockPath.node, this.outsideLetReferences = new Map, 
          this.hasLetReferences = !1, this.letReferences = new Map, this.body = [], loopPath && (this.loopParent = loopPath.parent, 
          this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label, 
          this.loopPath = loopPath, this.loop = loopPath.node);
        }
        run() {
          const block = this.block;
          if (DONE.has(block)) return;
          DONE.add(block);
          const needsClosure = this.getLetReferences();
          if (this.checkConstants(), _core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) this.updateScopeInfo(); else if (this.hasLetReferences) return needsClosure ? this.wrapClosure() : this.remap(), 
          this.updateScopeInfo(needsClosure), this.loopLabel && !_core.types.isLabeledStatement(this.loopParent) ? _core.types.labeledStatement(this.loopLabel, this.loop) : void 0;
        }
        checkConstants() {
          const scope = this.scope, state = this.state;
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            if ("const" === binding.kind) for (const violation of binding.constantViolations) {
              const readOnlyError = state.addHelper("readOnlyError"), throwNode = _core.types.callExpression(readOnlyError, [ _core.types.stringLiteral(name) ]);
              if (violation.isAssignmentExpression()) {
                const {operator} = violation.node;
                "=" === operator ? violation.replaceWith(_core.types.sequenceExpression([ violation.get("right").node, throwNode ])) : [ "&&=", "||=", "??=" ].includes(operator) ? violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), violation.get("left").node, _core.types.sequenceExpression([ violation.get("right").node, throwNode ]))) : violation.replaceWith(_core.types.sequenceExpression([ _core.types.binaryExpression(operator.slice(0, -1), violation.get("left").node, violation.get("right").node), throwNode ]));
              } else violation.isUpdateExpression() ? violation.replaceWith(_core.types.sequenceExpression([ _core.types.unaryExpression("+", violation.get("argument").node), throwNode ])) : violation.isForXStatement() && (violation.ensureBlock(), 
              violation.get("left").replaceWith(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(violation.scope.generateUidIdentifier(name)) ])), 
              violation.node.body.body.unshift(_core.types.expressionStatement(throwNode)));
            }
          }
        }
        updateScopeInfo(wrappedInClosure) {
          const blockScope = this.blockPath.scope, parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent(), letRefs = this.letReferences;
          for (const key of letRefs.keys()) {
            const ref = letRefs.get(key), binding = blockScope.getBinding(ref.name);
            binding && ("let" !== binding.kind && "const" !== binding.kind || (binding.kind = "var", 
            wrappedInClosure ? blockScope.hasOwnBinding(ref.name) && blockScope.removeBinding(ref.name) : blockScope.moveBindingTo(ref.name, parentScope)));
          }
        }
        remap() {
          const letRefs = this.letReferences, outsideLetRefs = this.outsideLetReferences, scope = this.scope, blockPathScope = this.blockPath.scope;
          for (const key of letRefs.keys()) {
            const ref = letRefs.get(key);
            if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
              const binding = scope.getOwnBinding(key);
              if (binding) {
                const parentBinding = scope.parent.getOwnBinding(key);
                if ("hoisted" === binding.kind && !binding.path.node.async && !binding.path.node.generator && (!parentBinding || isVar(parentBinding.path.parent)) && !binding.path.parentPath.find((({node}) => {
                  if (_core.types.isProgram(node)) {
                    if ("module" === node.sourceType) return !0;
                  } else if (!_core.types.isBlockStatement(node)) return !1;
                  return node.directives.some((directive => "use strict" === directive.value.value));
                }))) continue;
                scope.rename(ref.name);
              }
              blockPathScope.hasOwnBinding(key) && blockPathScope.rename(ref.name);
            }
          }
          for (const key of outsideLetRefs.keys()) {
            const ref = letRefs.get(key);
            isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key) && blockPathScope.rename(ref.name);
          }
        }
        wrapClosure() {
          if (this.throwIfClosureRequired) throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure (throwIfClosureRequired).");
          const block = this.block, outsideRefs = this.outsideLetReferences;
          if (this.loop) for (const name of Array.from(outsideRefs.keys())) {
            const id = outsideRefs.get(name);
            (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) && (outsideRefs.delete(id.name), 
            this.letReferences.delete(id.name), this.scope.rename(id.name), this.letReferences.set(id.name, id), 
            outsideRefs.set(id.name, id));
          }
          this.has = this.checkLoop(), this.hoistVarDeclarations();
          const args = Array.from(outsideRefs.values(), (node => _core.types.cloneNode(node))), params = args.map((id => _core.types.cloneNode(id))), isSwitch = this.blockPath.isSwitchStatement(), fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [ block ] : block.body));
          this.addContinuations(fn);
          let call = _core.types.callExpression(_core.types.nullLiteral(), args), basePath = ".callee";
          _core.traverse.hasType(fn.body, "YieldExpression", _core.types.FUNCTION_TYPES) && (fn.generator = !0, 
          call = _core.types.yieldExpression(call, !0), basePath = ".argument" + basePath);
          let placeholderPath, index, callPath;
          if (_core.traverse.hasType(fn.body, "AwaitExpression", _core.types.FUNCTION_TYPES) && (fn.async = !0, 
          call = _core.types.awaitExpression(call), basePath = ".argument" + basePath), this.has.hasReturn || this.has.hasBreakContinue) {
            const ret = this.scope.generateUid("ret");
            this.body.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(ret), call) ])), 
            placeholderPath = "declarations.0.init" + basePath, index = this.body.length - 1, 
            this.buildHas(ret);
          } else this.body.push(_core.types.expressionStatement(call)), placeholderPath = "expression" + basePath, 
          index = this.body.length - 1;
          if (isSwitch) {
            const {parentPath, listKey, key} = this.blockPath;
            this.blockPath.replaceWithMultiple(this.body), callPath = parentPath.get(listKey)[key + index];
          } else block.body = this.body, callPath = this.blockPath.get("body")[index];
          const placeholder = callPath.get(placeholderPath);
          let fnPath;
          if (this.loop) {
            const loopId = this.scope.generateUid("loop"), p = this.loopPath.insertBefore(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(loopId), fn) ]));
            placeholder.replaceWith(_core.types.identifier(loopId)), fnPath = p[0].get("declarations.0.init");
          } else placeholder.replaceWith(fn), fnPath = placeholder;
          fnPath.unwrapFunctionEnvironment();
        }
        addContinuations(fn) {
          const state = {
            reassignments: {},
            returnStatements: [],
            outsideReferences: this.outsideLetReferences
          };
          this.scope.traverse(fn, continuationVisitor, state);
          for (let i = 0; i < fn.params.length; i++) {
            const param = fn.params[i];
            if (!state.reassignments[param.name]) continue;
            const paramName = param.name, newParamName = this.scope.generateUid(param.name);
            fn.params[i] = _core.types.identifier(newParamName), this.scope.rename(paramName, newParamName, fn), 
            state.returnStatements.forEach((returnStatement => {
              returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(paramName), _core.types.identifier(newParamName))));
            })), fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(paramName), _core.types.identifier(newParamName))));
          }
        }
        getLetReferences() {
          const block = this.block, declarators = [];
          if (this.loop) {
            const init = this.loop.left || this.loop.init;
            if (isBlockScoped(init)) {
              declarators.push(init);
              const names = _core.types.getBindingIdentifiers(init);
              for (const name of Object.keys(names)) this.outsideLetReferences.set(name, names[name]);
            }
          }
          const addDeclarationsFromChild = (path, node) => {
            if (node = node || path.node, _core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) if (isBlockScoped(node) && convertBlockScopedToVar(path, node, block, this.scope), 
            node.declarations) for (let i = 0; i < node.declarations.length; i++) declarators.push(node.declarations[i]); else declarators.push(node);
            _core.types.isLabeledStatement(node) && addDeclarationsFromChild(path.get("body"), node.body);
          };
          if (block.body) {
            const declarPaths = this.blockPath.get("body");
            for (let i = 0; i < block.body.length; i++) addDeclarationsFromChild(declarPaths[i]);
          }
          if (block.cases) {
            const declarPaths = this.blockPath.get("cases");
            for (let i = 0; i < block.cases.length; i++) {
              const consequents = block.cases[i].consequent;
              for (let j = 0; j < consequents.length; j++) {
                const declar = consequents[j];
                addDeclarationsFromChild(declarPaths[i], declar);
              }
            }
          }
          for (let i = 0; i < declarators.length; i++) {
            const declar = declarators[i], keys = _core.types.getBindingIdentifiers(declar, !1, !0);
            for (const key of Object.keys(keys)) this.letReferences.set(key, keys[key]);
            this.hasLetReferences = !0;
          }
          if (!this.hasLetReferences) return;
          const state = {
            letReferences: this.letReferences,
            closurify: !1,
            loopDepth: 0,
            tdzEnabled: this.tdzEnabled,
            addHelper: name => this.state.addHelper(name)
          };
          return isInLoop(this.blockPath) && state.loopDepth++, this.blockPath.traverse(letReferenceBlockVisitor, state), 
          state.closurify;
        }
        checkLoop() {
          const state = {
            hasBreakContinue: !1,
            ignoreLabeless: !1,
            inSwitchCase: !1,
            innerLabels: [],
            hasReturn: !1,
            isLoop: !!this.loop,
            map: {},
            LOOP_IGNORE: Symbol()
          };
          return this.blockPath.traverse(loopLabelVisitor, state), this.blockPath.traverse(loopVisitor, state), 
          state;
        }
        hoistVarDeclarations() {
          this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
        }
        pushDeclar(node) {
          const declars = [], names = _core.types.getBindingIdentifiers(node);
          for (const name of Object.keys(names)) declars.push(_core.types.variableDeclarator(names[name]));
          this.body.push(_core.types.variableDeclaration(node.kind, declars));
          const replace = [];
          for (let i = 0; i < node.declarations.length; i++) {
            const declar = node.declarations[i];
            if (!declar.init) continue;
            const expr = _core.types.assignmentExpression("=", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));
            replace.push(_core.types.inherits(expr, declar));
          }
          return replace;
        }
        buildHas(ret) {
          const body = this.body, has = this.has;
          if (has.hasBreakContinue) for (const key of Object.keys(has.map)) body.push(_core.types.ifStatement(_core.types.binaryExpression("===", _core.types.identifier(ret), _core.types.stringLiteral(key)), has.map[key]));
          has.hasReturn && body.push(buildRetCheck({
            RETURN: _core.types.identifier(ret)
          }));
        }
      }
    },
    4601: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.visitor = void 0;
      var _core = __webpack_require__(4629);
      function isReference(node, scope, state) {
        const declared = state.letReferences.get(node.name);
        return !!declared && scope.getBindingIdentifier(node.name) === declared;
      }
      const visitedMaybeTDZNodes = new WeakSet, visitor = {
        ReferencedIdentifier(path, state) {
          if (!state.tdzEnabled) return;
          const {node, parent, scope} = path;
          if (path.parentPath.isFor({
            left: node
          })) return;
          if (!isReference(node, scope, state)) return;
          const bindingPath = scope.getBinding(node.name).path;
          if (bindingPath.isFunctionDeclaration()) return;
          const status = function(refPath, bindingPath) {
            const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
            return "before" === executionStatus ? "outside" : "after" === executionStatus ? "inside" : "maybe";
          }(path, bindingPath);
          if ("outside" !== status) if ("maybe" === status) {
            if (visitedMaybeTDZNodes.has(node)) return;
            visitedMaybeTDZNodes.add(node);
            const assert = function(node, state) {
              return _core.types.callExpression(state.addHelper("temporalRef"), [ node, _core.types.stringLiteral(node.name) ]);
            }(node, state);
            if (bindingPath.parent._tdzThis = !0, path.parentPath.isUpdateExpression()) {
              if (parent._ignoreBlockScopingTDZ) return;
              path.parentPath.replaceWith(_core.types.sequenceExpression([ assert, parent ]));
            } else path.replaceWith(assert);
          } else "inside" === status && path.replaceWith(_core.template.ast`${state.addHelper("tdz")}("${node.name}")`);
        },
        AssignmentExpression: {
          exit(path, state) {
            if (!state.tdzEnabled) return;
            const {node} = path;
            if (node._ignoreBlockScopingTDZ) return;
            const nodes = [], ids = path.getBindingIdentifiers();
            for (const name of Object.keys(ids)) {
              const id = ids[name];
              isReference(id, path.scope, state) && nodes.push(id);
            }
            nodes.length && (node._ignoreBlockScopingTDZ = !0, nodes.push(node), path.replaceWithMultiple(nodes.map((n => _core.types.expressionStatement(n)))));
          }
        }
      };
      exports.visitor = visitor;
    },
    2535: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperAnnotateAsPure = __webpack_require__(4321), _helperFunctionName = __webpack_require__(1485), _helperSplitExportDeclaration = __webpack_require__(4170), _core = __webpack_require__(4629), _globals = __webpack_require__(1272), _transformClass = __webpack_require__(8342);
      const getBuiltinClasses = category => Object.keys(_globals[category]).filter((name => /^[A-Z]/.test(name))), builtinClasses = new Set([ ...getBuiltinClasses("builtin"), ...getBuiltinClasses("browser") ]);
      var _default = (0, _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
        api.assertVersion(7);
        const {loose} = options, setClassMethods = null != (_api$assumption = api.assumption("setClassMethods")) ? _api$assumption : options.loose, constantSuper = null != (_api$assumption2 = api.assumption("constantSuper")) ? _api$assumption2 : options.loose, superIsCallableConstructor = null != (_api$assumption3 = api.assumption("superIsCallableConstructor")) ? _api$assumption3 : options.loose, noClassCalls = null != (_api$assumption4 = api.assumption("noClassCalls")) ? _api$assumption4 : options.loose, VISITED = Symbol();
        return {
          name: "transform-classes",
          visitor: {
            ExportDefaultDeclaration(path) {
              path.get("declaration").isClassDeclaration() && (0, _helperSplitExportDeclaration.default)(path);
            },
            ClassDeclaration(path) {
              const {node} = path, ref = node.id || path.scope.generateUidIdentifier("class");
              path.replaceWith(_core.types.variableDeclaration("let", [ _core.types.variableDeclarator(ref, _core.types.toExpression(node)) ]));
            },
            ClassExpression(path, state) {
              const {node} = path;
              if (node[VISITED]) return;
              const inferred = (0, _helperFunctionName.default)(path);
              if (inferred && inferred !== node) path.replaceWith(inferred); else if (node[VISITED] = !0, 
              path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose, {
                setClassMethods,
                constantSuper,
                superIsCallableConstructor,
                noClassCalls
              })), path.isCallExpression()) {
                (0, _helperAnnotateAsPure.default)(path);
                const callee = path.get("callee");
                callee.isArrowFunctionExpression() && callee.arrowFunctionToExpression();
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    8610: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(file) {
        if (helperIDs.has(file)) return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));
        try {
          return file.addHelper("createSuper");
        } catch (_unused) {}
        const id = file.scope.generateUidIdentifier("createSuper");
        helperIDs.set(file, id);
        const fn = helper({
          CREATE_SUPER: id,
          GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
          POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
        });
        return file.path.unshiftContainer("body", [ fn ]), file.scope.registerDeclaration(file.path.get("body.0")), 
        _core.types.cloneNode(id);
      };
      var _core = __webpack_require__(4629);
      const helperIDs = new WeakMap;
      const helper = _core.template.statement`
  function CREATE_SUPER(Derived) {
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;

      // core-js@3
      if (Reflect.construct.sham) return false;

      // Proxy can't be polyfilled. Every browser implemented
      // proxies before or at the same time as Reflect.construct,
      // so if they support Proxy they also support Reflect.construct.
      if (typeof Proxy === "function") return true;

      // Since Reflect.construct can't be properly polyfilled, some
      // implementations (e.g. core-js@2) don't set the correct internal slots.
      // Those polyfills don't allow us to subclass built-ins, so we need to
      // use our fallback implementation.
      try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Date object.
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    return function () {
      var Super = GET_PROTOTYPE_OF(Derived), result;
      if (isNativeReflectConstruct()) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = GET_PROTOTYPE_OF(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);
    }
  }
`;
    },
    8342: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, file, builtinClasses, isLoose, assumptions) {
        const classState = {
          parent: void 0,
          scope: void 0,
          node: void 0,
          path: void 0,
          file: void 0,
          classId: void 0,
          classRef: void 0,
          superFnId: void 0,
          superName: void 0,
          superReturns: [],
          isDerived: !1,
          extendsNative: !1,
          construct: void 0,
          constructorBody: void 0,
          userConstructor: void 0,
          userConstructorPath: void 0,
          hasConstructor: !1,
          staticPropBody: [],
          body: [],
          superThises: [],
          pushedConstructor: !1,
          pushedInherits: !1,
          pushedCreateClass: !1,
          protoAlias: null,
          isLoose: !1,
          dynamicKeys: new Map,
          methods: {
            instance: {
              hasComputed: !1,
              list: [],
              map: new Map
            },
            static: {
              hasComputed: !1,
              list: [],
              map: new Map
            }
          }
        }, setState = newState => {
          Object.assign(classState, newState);
        }, findThisesVisitor = _core.traverse.visitors.merge([ _helperEnvironmentVisitor.default, {
          ThisExpression(path) {
            classState.superThises.push(path);
          }
        } ]);
        function createClassHelper(args) {
          return _core.types.callExpression(classState.file.addHelper("createClass"), args);
        }
        function buildBody() {
          if (function() {
            let hasConstructor = !1;
            const paths = classState.path.get("body.body");
            for (const path of paths) if (hasConstructor = path.equals("kind", "constructor"), 
            hasConstructor) break;
            if (hasConstructor) return;
            let params, body;
            if (classState.isDerived) {
              const constructor = _core.template.expression.ast`
        (function () {
          super(...arguments);
        })
      `;
              params = constructor.params, body = constructor.body;
            } else params = [], body = _core.types.blockStatement([]);
            classState.path.get("body").unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
          }(), function() {
            const classBodyPaths = classState.path.get("body.body");
            for (const path of classBodyPaths) {
              const node = path.node;
              if (path.isClassProperty()) throw path.buildCodeFrameError("Missing class properties transform.");
              if (node.decorators) throw path.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
              if (_core.types.isClassMethod(node)) {
                const isConstructor = "constructor" === node.kind;
                new _helperReplaceSupers.default({
                  methodPath: path,
                  objectRef: classState.classRef,
                  superRef: classState.superName,
                  constantSuper: assumptions.constantSuper,
                  file: classState.file,
                  refToPreserve: classState.classRef
                }).replace();
                const superReturns = [];
                path.traverse(_core.traverse.visitors.merge([ _helperEnvironmentVisitor.default, {
                  ReturnStatement(path) {
                    path.getFunctionParent().isArrowFunctionExpression() || superReturns.push(path);
                  }
                } ])), isConstructor ? pushConstructor(superReturns, node, path) : pushMethod(node, path);
              }
            }
          }(), function() {
            if (!classState.isDerived) return;
            const path = classState.userConstructorPath, body = path.get("body");
            path.traverse(findThisesVisitor);
            let thisRef = function() {
              const ref = path.scope.generateDeclaredUidIdentifier("this");
              return thisRef = () => _core.types.cloneNode(ref), ref;
            };
            for (const thisPath of classState.superThises) {
              const {node, parentPath} = thisPath;
              parentPath.isMemberExpression({
                object: node
              }) ? thisPath.replaceWith(thisRef()) : thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [ thisRef() ]));
            }
            const bareSupers = new Set;
            path.traverse(_core.traverse.visitors.merge([ _helperEnvironmentVisitor.default, {
              Super(path) {
                const {node, parentPath} = path;
                parentPath.isCallExpression({
                  callee: node
                }) && bareSupers.add(parentPath);
              }
            } ]));
            let wrapReturn, guaranteedSuperBeforeFinish = !!bareSupers.size;
            for (const bareSuper of bareSupers) wrapSuperCall(bareSuper, classState.superName, thisRef, body), 
            guaranteedSuperBeforeFinish && bareSuper.find((function(parentPath) {
              return parentPath === path || (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression() ? (guaranteedSuperBeforeFinish = !1, 
              !0) : void 0);
            }));
            wrapReturn = classState.isLoose ? returnArg => {
              const thisExpr = _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [ thisRef() ]);
              return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
            } : returnArg => _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [ thisRef() ].concat(returnArg || []));
            const bodyPaths = body.get("body");
            bodyPaths.length && bodyPaths.pop().isReturnStatement() || body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));
            for (const returnPath of classState.superReturns) returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
          }(), classState.userConstructor) {
            const {constructorBody, userConstructor, construct} = classState;
            constructorBody.body.push(...userConstructor.body.body), _core.types.inherits(construct, userConstructor), 
            _core.types.inherits(constructorBody, userConstructor.body);
          }
          pushDescriptors();
        }
        function pushDescriptors() {
          pushInheritsToBody();
          const {body} = classState, props = {
            instance: null,
            static: null
          };
          for (const placement of [ "static", "instance" ]) classState.methods[placement].list.length && (props[placement] = classState.methods[placement].list.map((desc => {
            const obj = _core.types.objectExpression([ _core.types.objectProperty(_core.types.identifier("key"), desc.key) ]);
            for (const kind of [ "get", "set", "value" ]) null != desc[kind] && obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));
            return obj;
          })));
          if (props.instance || props.static) {
            let args = [ _core.types.cloneNode(classState.classRef), props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(), props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral() ], lastNonNullIndex = 0;
            for (let i = 0; i < args.length; i++) _core.types.isNullLiteral(args[i]) || (lastNonNullIndex = i);
            args = args.slice(0, lastNonNullIndex + 1), body.push(_core.types.expressionStatement(createClassHelper(args))), 
            classState.pushedCreateClass = !0;
          }
        }
        function wrapSuperCall(bareSuper, superRef, thisRef, body) {
          const bareSuperNode = bareSuper.node;
          let call;
          assumptions.superIsCallableConstructor ? (bareSuperNode.arguments.unshift(_core.types.thisExpression()), 
          2 === bareSuperNode.arguments.length && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
            name: "arguments"
          }) ? (bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument, bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"))) : bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call")), 
          call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression())) : call = (0, 
          _helperOptimiseCallExpression.default)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments, !1), 
          bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key ? (classState.superThises.length && (call = _core.types.assignmentExpression("=", thisRef(), call)), 
          bareSuper.parentPath.replaceWith(_core.types.returnStatement(call))) : bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
        }
        function pushMethod(node, path) {
          const scope = path ? path.scope : classState.scope;
          if ("method" === node.kind && function(node, scope) {
            if (assumptions.setClassMethods && !node.decorators) {
              let {classRef} = classState;
              node.static || (!function() {
                if (null === classState.protoAlias) {
                  setState({
                    protoAlias: classState.scope.generateUidIdentifier("proto")
                  });
                  const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype")), protoDeclaration = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(classState.protoAlias, classProto) ]);
                  classState.body.push(protoDeclaration);
                }
              }(), classRef = classState.protoAlias);
              const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));
              let func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
              _core.types.inherits(func, node);
              const key = _core.types.toComputedKey(node, node.key);
              _core.types.isStringLiteral(key) && (func = (0, _helperFunctionName.default)({
                node: func,
                id: key,
                scope
              }));
              const expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));
              return _core.types.inheritsComments(expr, node), classState.body.push(expr), !0;
            }
            return !1;
          }(node, scope)) return;
          const placement = node.static ? "static" : "instance", methods = classState.methods[placement], descKey = "method" === node.kind ? "value" : node.kind, key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);
          let descriptor, fn = _core.types.toExpression(node);
          _core.types.isStringLiteral(key) ? "method" === node.kind && (fn = (0, _helperFunctionName.default)({
            id: key,
            node,
            scope
          })) : methods.hasComputed = !0, !methods.hasComputed && methods.map.has(key.value) ? (descriptor = methods.map.get(key.value), 
          descriptor[descKey] = fn, "value" === descKey ? (descriptor.get = null, descriptor.set = null) : descriptor.value = null) : (descriptor = {
            key,
            [descKey]: fn
          }, methods.list.push(descriptor), methods.hasComputed || methods.map.set(key.value, descriptor));
        }
        function pushConstructor(superReturns, method, path) {
          setState({
            userConstructorPath: path,
            userConstructor: method,
            hasConstructor: !0,
            superReturns
          });
          const {construct} = classState;
          _core.types.inheritsComments(construct, method), construct.params = method.params, 
          _core.types.inherits(construct.body, method.body), construct.body.directives = method.body.directives, 
          function() {
            if (classState.pushedConstructor) return;
            classState.pushedConstructor = !0, (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) && pushDescriptors();
            classState.body.push(classState.construct), pushInheritsToBody();
          }();
        }
        function pushInheritsToBody() {
          if (!classState.isDerived || classState.pushedInherits) return;
          const superFnId = path.scope.generateUidIdentifier("super");
          setState({
            pushedInherits: !0,
            superFnId
          }), assumptions.superIsCallableConstructor || classState.body.unshift(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(superFnId, _core.types.callExpression((0, 
          _inlineCreateSuperHelpers.default)(classState.file), [ _core.types.cloneNode(classState.classRef) ])) ])), 
          classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [ _core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName) ])));
        }
        return function(path, file, builtinClasses, isLoose) {
          setState({
            parent: path.parent,
            scope: path.scope,
            node: path.node,
            path,
            file,
            isLoose
          }), setState({
            classId: classState.node.id,
            classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
            superName: classState.node.superClass,
            isDerived: !!classState.node.superClass,
            constructorBody: _core.types.blockStatement([])
          }), setState({
            extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, !0)
          });
          const {classRef, node, constructorBody} = classState;
          setState({
            construct: buildConstructor(classRef, constructorBody, node)
          }), function() {
            const {dynamicKeys, node, scope} = classState;
            for (const elem of node.body.body) {
              if (!_core.types.isClassMethod(elem) || !elem.computed) continue;
              if (scope.isPure(elem.key, !0)) continue;
              const id = scope.generateUidIdentifierBasedOnNode(elem.key);
              dynamicKeys.set(id.name, elem.key), elem.key = id;
            }
          }();
          const {body} = classState, {closureParams, closureArgs} = function() {
            const {superName, dynamicKeys} = classState, closureParams = [], closureArgs = [];
            if (classState.isDerived) {
              let arg = _core.types.cloneNode(superName);
              classState.extendsNative && (arg = _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [ arg ]), 
              (0, _helperAnnotateAsPure.default)(arg));
              const param = classState.scope.generateUidIdentifierBasedOnNode(superName);
              closureParams.push(param), closureArgs.push(arg), setState({
                superName: _core.types.cloneNode(param)
              });
            }
            for (const [name, value] of dynamicKeys) closureParams.push(_core.types.identifier(name)), 
            closureArgs.push(value);
            return {
              closureParams,
              closureArgs
            };
          }();
          buildBody(), assumptions.noClassCalls || constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [ _core.types.thisExpression(), _core.types.cloneNode(classState.classRef) ]))), 
          body.push(...classState.staticPropBody.map((fn => fn(_core.types.cloneNode(classState.classRef)))));
          const isStrict = path.isInStrictMode();
          let constructorOnly = classState.classId && 1 === body.length;
          if (constructorOnly && !isStrict) for (const param of classState.construct.params) if (!_core.types.isIdentifier(param)) {
            constructorOnly = !1;
            break;
          }
          const directives = constructorOnly ? body[0].body.directives : [];
          if (isStrict || directives.push(_core.types.directive(_core.types.directiveLiteral("use strict"))), 
          constructorOnly) {
            const expr = _core.types.toExpression(body[0]);
            return classState.isLoose ? expr : createClassHelper([ expr ]);
          }
          let returnArg = _core.types.cloneNode(classState.classRef);
          classState.pushedCreateClass || classState.isLoose || (returnArg = createClassHelper([ returnArg ])), 
          body.push(_core.types.returnStatement(returnArg));
          const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));
          return _core.types.callExpression(container, closureArgs);
        }(path, file, builtinClasses, isLoose);
      };
      var _helperFunctionName = __webpack_require__(1485), _helperReplaceSupers = __webpack_require__(4149), _helperEnvironmentVisitor = __webpack_require__(1692), _helperOptimiseCallExpression = __webpack_require__(3934), _core = __webpack_require__(4629), _helperAnnotateAsPure = __webpack_require__(4321), _inlineCreateSuperHelpers = __webpack_require__(8610);
      function buildConstructor(classRef, constructorBody, node) {
        const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);
        return _core.types.inherits(func, node), func;
      }
    },
    7175: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption;
        api.assertVersion(7);
        const pushComputedProps = (null != (_api$assumption = api.assumption("setComputedProperties")) ? _api$assumption : options.loose) ? function(info) {
          for (const prop of info.computedProps) "get" === prop.kind || "set" === prop.kind ? pushMutatorDefine(info, prop) : pushAssign(_core.types.cloneNode(info.objId), prop, info.body);
        } : function(info) {
          const {objId, body, computedProps, state} = info;
          for (const prop of computedProps) {
            const key = _core.types.toComputedKey(prop);
            if ("get" === prop.kind || "set" === prop.kind) pushMutatorDefine(info, prop); else {
              if (1 === computedProps.length) return _core.types.callExpression(state.addHelper("defineProperty"), [ info.initPropExpression, key, getValue(prop) ]);
              body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ _core.types.cloneNode(objId), key, getValue(prop) ])));
            }
          }
        }, buildMutatorMapAssign = (0, _core.template)("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");
        function getValue(prop) {
          return _core.types.isObjectProperty(prop) ? prop.value : _core.types.isObjectMethod(prop) ? _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async) : void 0;
        }
        function pushAssign(objId, prop, body) {
          "get" === prop.kind && "set" === prop.kind ? pushMutatorDefine(objId, prop) : body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));
        }
        function pushMutatorDefine({body, getMutatorId, scope}, prop) {
          let key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;
          const maybeMemoise = scope.maybeGenerateMemoised(key);
          maybeMemoise && (body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", maybeMemoise, key))), 
          key = maybeMemoise), body.push(...buildMutatorMapAssign({
            MUTATOR_MAP_REF: getMutatorId(),
            KEY: _core.types.cloneNode(key),
            VALUE: getValue(prop),
            KIND: _core.types.identifier(prop.kind)
          }));
        }
        return {
          name: "transform-computed-properties",
          visitor: {
            ObjectExpression: {
              exit(path, state) {
                const {node, parent, scope} = path;
                let hasComputed = !1;
                for (const prop of node.properties) if (hasComputed = !0 === prop.computed, hasComputed) break;
                if (!hasComputed) return;
                const initProps = [], computedProps = [];
                let foundComputed = !1;
                for (const prop of node.properties) prop.computed && (foundComputed = !0), foundComputed ? computedProps.push(prop) : initProps.push(prop);
                const objId = scope.generateUidIdentifierBasedOnNode(parent), initPropExpression = _core.types.objectExpression(initProps), body = [];
                let mutatorRef;
                body.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(objId, initPropExpression) ]));
                const single = pushComputedProps({
                  scope,
                  objId,
                  body,
                  computedProps,
                  initPropExpression,
                  getMutatorId: function() {
                    return mutatorRef || (mutatorRef = scope.generateUidIdentifier("mutatorMap"), body.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(mutatorRef, _core.types.objectExpression([])) ]))), 
                    _core.types.cloneNode(mutatorRef);
                  },
                  state
                });
                mutatorRef && body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineEnumerableProperties"), [ _core.types.cloneNode(objId), _core.types.cloneNode(mutatorRef) ]))), 
                single ? path.replaceWith(single) : (body.push(_core.types.expressionStatement(_core.types.cloneNode(objId))), 
                path.replaceWithMultiple(body));
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    8177: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var helperPluginUtils = __webpack_require__(4982), core = __webpack_require__(4629);
      function hasArrayRest(pattern) {
        return pattern.elements.some((elem => core.types.isRestElement(elem)));
      }
      const STOP_TRAVERSAL = {}, arrayUnpackVisitor = (node, ancestors, state) => {
        if (ancestors.length && core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) throw state.deopt = !0, 
        STOP_TRAVERSAL;
      };
      class DestructuringTransformer {
        constructor(opts) {
          this.blockHoist = void 0, this.operator = void 0, this.arrayRefSet = void 0, this.nodes = void 0, 
          this.scope = void 0, this.kind = void 0, this.iterableIsArray = void 0, this.arrayLikeIsIterable = void 0, 
          this.objectRestNoSymbols = void 0, this.useBuiltIns = void 0, this.addHelper = void 0, 
          this.blockHoist = opts.blockHoist, this.operator = opts.operator, this.arrayRefSet = new Set, 
          this.nodes = opts.nodes || [], this.scope = opts.scope, this.kind = opts.kind, this.iterableIsArray = opts.iterableIsArray, 
          this.arrayLikeIsIterable = opts.arrayLikeIsIterable, this.objectRestNoSymbols = opts.objectRestNoSymbols, 
          this.useBuiltIns = opts.useBuiltIns, this.addHelper = opts.addHelper;
        }
        getExtendsHelper() {
          return this.useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : this.addHelper("extends");
        }
        buildVariableAssignment(id, init) {
          let node, op = this.operator;
          if (core.types.isMemberExpression(id) && (op = "="), op) node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode())); else {
            let nodeInit;
            nodeInit = "const" === this.kind && null === init ? this.scope.buildUndefinedNode() : core.types.cloneNode(init), 
            node = core.types.variableDeclaration(this.kind, [ core.types.variableDeclarator(id, nodeInit) ]);
          }
          return node._blockHoist = this.blockHoist, node;
        }
        buildVariableDeclaration(id, init) {
          const declar = core.types.variableDeclaration("var", [ core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init)) ]);
          return declar._blockHoist = this.blockHoist, declar;
        }
        push(id, _init) {
          const init = core.types.cloneNode(_init);
          core.types.isObjectPattern(id) ? this.pushObjectPattern(id, init) : core.types.isArrayPattern(id) ? this.pushArrayPattern(id, init) : core.types.isAssignmentPattern(id) ? this.pushAssignmentPattern(id, init) : this.nodes.push(this.buildVariableAssignment(id, init));
        }
        toArray(node, count) {
          return this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name) ? node : this.scope.toArray(node, count, this.arrayLikeIsIterable);
        }
        pushAssignmentPattern({left, right}, valueRef) {
          if (null === valueRef) return void this.push(left, right);
          const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
          this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
          const tempConditional = core.types.conditionalExpression(core.types.binaryExpression("===", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));
          if (core.types.isPattern(left)) {
            let patternId, node;
            "const" === this.kind || "let" === this.kind ? (patternId = this.scope.generateUidIdentifier(tempId.name), 
            node = this.buildVariableDeclaration(patternId, tempConditional)) : (patternId = tempId, 
            node = core.types.expressionStatement(core.types.assignmentExpression("=", core.types.cloneNode(tempId), tempConditional))), 
            this.nodes.push(node), this.push(left, patternId);
          } else this.nodes.push(this.buildVariableAssignment(left, tempConditional));
        }
        pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
          const value = function(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {
            const keys = [];
            let value, allLiteral = !0, hasTemplateLiteral = !1;
            for (let i = 0; i < excludedKeys.length; i++) {
              const prop = excludedKeys[i], key = prop.key;
              core.types.isIdentifier(key) && !prop.computed ? keys.push(core.types.stringLiteral(key.name)) : core.types.isTemplateLiteral(key) ? (keys.push(core.types.cloneNode(key)), 
              hasTemplateLiteral = !0) : core.types.isLiteral(key) ? keys.push(core.types.stringLiteral(String(key.value))) : core.types.isPrivateName(key) || (keys.push(core.types.cloneNode(key)), 
              allLiteral = !1);
            }
            if (0 === keys.length) {
              const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : addHelper("extends");
              value = core.types.callExpression(extendsHelper, [ core.types.objectExpression([]), core.types.cloneNode(objRef) ]);
            } else {
              let keyExpression = core.types.arrayExpression(keys);
              if (allLiteral) {
                if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {
                  const programScope = scope.getProgramParent(), id = programScope.generateUidIdentifier("excluded");
                  programScope.push({
                    id,
                    init: keyExpression,
                    kind: "const"
                  }), keyExpression = core.types.cloneNode(id);
                }
              } else keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier("map")), [ addHelper("toPropertyKey") ]);
              value = core.types.callExpression(addHelper("objectWithoutProperties" + (objectRestNoSymbols ? "Loose" : "")), [ core.types.cloneNode(objRef), keyExpression ]);
            }
            return value;
          }(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, (name => this.addHelper(name)), this.objectRestNoSymbols, this.useBuiltIns);
          this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
        }
        pushObjectProperty(prop, propRef) {
          core.types.isLiteral(prop.key) && (prop.computed = !0);
          const pattern = prop.value, objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);
          core.types.isPattern(pattern) ? this.push(pattern, objRef) : this.nodes.push(this.buildVariableAssignment(pattern, objRef));
        }
        pushObjectPattern(pattern, objRef) {
          if (pattern.properties.length && null !== objRef) {
            if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
              const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
              this.nodes.push(this.buildVariableDeclaration(temp, objRef)), objRef = temp;
            }
            if (function(pattern) {
              return pattern.properties.some((prop => core.types.isRestElement(prop)));
            }(pattern)) {
              let copiedPattern;
              for (let i = 0; i < pattern.properties.length; i++) {
                const prop = pattern.properties[i];
                if (core.types.isRestElement(prop)) break;
                const key = prop.key;
                if (prop.computed && !this.scope.isPure(key)) {
                  const name = this.scope.generateUidIdentifierBasedOnNode(key);
                  this.nodes.push(this.buildVariableDeclaration(name, key)), copiedPattern || (copiedPattern = pattern = Object.assign({}, pattern, {
                    properties: pattern.properties.slice()
                  })), copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                    key: name
                  });
                }
              }
            }
            for (let i = 0; i < pattern.properties.length; i++) {
              const prop = pattern.properties[i];
              core.types.isRestElement(prop) ? this.pushObjectRest(pattern, objRef, prop, i) : this.pushObjectProperty(prop, objRef);
            }
          } else this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), null !== objRef ? [ objRef ] : [])));
        }
        canUnpackArrayPattern(pattern, arr) {
          if (!core.types.isArrayExpression(arr)) return !1;
          if (pattern.elements.length > arr.elements.length) return;
          if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) return !1;
          for (const elem of pattern.elements) {
            if (!elem) return !1;
            if (core.types.isMemberExpression(elem)) return !1;
          }
          for (const elem of arr.elements) {
            if (core.types.isSpreadElement(elem)) return !1;
            if (core.types.isCallExpression(elem)) return !1;
            if (core.types.isMemberExpression(elem)) return !1;
          }
          const state = {
            deopt: !1,
            bindings: core.types.getBindingIdentifiers(pattern)
          };
          try {
            core.types.traverse(arr, arrayUnpackVisitor, state);
          } catch (e) {
            if (e !== STOP_TRAVERSAL) throw e;
          }
          return !state.deopt;
        }
        pushUnpackedArrayPattern(pattern, arr) {
          for (let i = 0; i < pattern.elements.length; i++) {
            const elem = pattern.elements[i];
            core.types.isRestElement(elem) ? this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i))) : this.push(elem, arr.elements[i]);
          }
        }
        pushArrayPattern(pattern, arrayRef) {
          if (null === arrayRef) return void this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [])));
          if (!pattern.elements) return;
          if (this.canUnpackArrayPattern(pattern, arrayRef)) return this.pushUnpackedArrayPattern(pattern, arrayRef);
          const count = !hasArrayRest(pattern) && pattern.elements.length, toArray = this.toArray(arrayRef, count);
          core.types.isIdentifier(toArray) ? arrayRef = toArray : (arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef), 
          this.arrayRefSet.add(arrayRef.name), this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray)));
          for (let i = 0; i < pattern.elements.length; i++) {
            const elem = pattern.elements[i];
            if (!elem) continue;
            let elemRef;
            core.types.isRestElement(elem) ? (elemRef = this.toArray(arrayRef), elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier("slice")), [ core.types.numericLiteral(i) ]), 
            this.push(elem.argument, elemRef)) : (elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), !0), 
            this.push(elem, elemRef));
          }
        }
        init(pattern, ref) {
          if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {
            const memo = this.scope.maybeGenerateMemoised(ref, !0);
            memo && (this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref))), 
            ref = memo);
          }
          return this.push(pattern, ref), this.nodes;
        }
      }
      function variableDeclarationHasPattern(node) {
        for (const declar of node.declarations) if (core.types.isPattern(declar.id)) return !0;
        return !1;
      }
      var index = helperPluginUtils.declare(((api, options) => {
        var _api$assumption, _options$allowArrayLi, _api$assumption2;
        api.assertVersion(7);
        const {useBuiltIns = !1} = options, iterableIsArray = null != (_api$assumption = api.assumption("iterableIsArray")) ? _api$assumption : options.loose, arrayLikeIsIterable = null != (_options$allowArrayLi = options.allowArrayLike) ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable"), objectRestNoSymbols = null != (_api$assumption2 = api.assumption("objectRestNoSymbols")) ? _api$assumption2 : options.loose;
        return {
          name: "transform-destructuring",
          visitor: {
            ExportNamedDeclaration(path) {
              const declaration = path.get("declaration");
              if (!declaration.isVariableDeclaration()) return;
              if (!variableDeclarationHasPattern(declaration.node)) return;
              const specifiers = [];
              for (const name of Object.keys(path.getOuterBindingIdentifiers())) specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));
              path.replaceWith(declaration.node), path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));
            },
            ForXStatement(path) {
              const {node, scope} = path, left = node.left;
              if (core.types.isPattern(left)) {
                const temp = scope.generateUidIdentifier("ref");
                node.left = core.types.variableDeclaration("var", [ core.types.variableDeclarator(temp) ]), 
                path.ensureBlock();
                const statementBody = node.body.body;
                return 0 === statementBody.length && path.isCompletionRecord() && statementBody.unshift(core.types.expressionStatement(scope.buildUndefinedNode())), 
                void statementBody.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", left, temp)));
              }
              if (!core.types.isVariableDeclaration(left)) return;
              const pattern = left.declarations[0].id;
              if (!core.types.isPattern(pattern)) return;
              const key = scope.generateUidIdentifier("ref");
              node.left = core.types.variableDeclaration(left.kind, [ core.types.variableDeclarator(key, null) ]);
              const nodes = [];
              new DestructuringTransformer({
                kind: left.kind,
                scope,
                nodes,
                arrayLikeIsIterable,
                iterableIsArray,
                objectRestNoSymbols,
                useBuiltIns,
                addHelper: name => this.addHelper(name)
              }).init(pattern, key), path.ensureBlock();
              const block = node.body;
              block.body = nodes.concat(block.body);
            },
            CatchClause({node, scope}) {
              const pattern = node.param;
              if (!core.types.isPattern(pattern)) return;
              const ref = scope.generateUidIdentifier("ref");
              node.param = ref;
              const nodes = [];
              new DestructuringTransformer({
                kind: "let",
                scope,
                nodes,
                arrayLikeIsIterable,
                iterableIsArray,
                objectRestNoSymbols,
                useBuiltIns,
                addHelper: name => this.addHelper(name)
              }).init(pattern, ref), node.body.body = nodes.concat(node.body.body);
            },
            AssignmentExpression(path, state) {
              core.types.isPattern(path.node.left) && function(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
                const {node, scope} = path, nodes = [], destructuring = new DestructuringTransformer({
                  operator: node.operator,
                  scope,
                  nodes,
                  arrayLikeIsIterable,
                  iterableIsArray,
                  objectRestNoSymbols,
                  useBuiltIns,
                  addHelper
                });
                let ref;
                !path.isCompletionRecord() && path.parentPath.isExpressionStatement() || (ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref"), 
                nodes.push(core.types.variableDeclaration("var", [ core.types.variableDeclarator(ref, node.right) ])), 
                core.types.isArrayExpression(node.right) && destructuring.arrayRefSet.add(ref.name)), 
                destructuring.init(node.left, ref || node.right), ref && (path.parentPath.isArrowFunctionExpression() ? (path.replaceWith(core.types.blockStatement([])), 
                nodes.push(core.types.returnStatement(core.types.cloneNode(ref)))) : nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)))), 
                path.replaceWithMultiple(nodes), path.scope.crawl();
              }(path, (name => state.addHelper(name)), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
            },
            VariableDeclaration(path, state) {
              const {node, parent} = path;
              core.types.isForXStatement(parent) || parent && path.container && variableDeclarationHasPattern(node) && function(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
                const {node, scope} = path, nodeKind = node.kind, nodeLoc = node.loc, nodes = [];
                for (let i = 0; i < node.declarations.length; i++) {
                  const declar = node.declarations[i], patternId = declar.init, pattern = declar.id, destructuring = new DestructuringTransformer({
                    blockHoist: node._blockHoist,
                    nodes,
                    scope,
                    kind: node.kind,
                    iterableIsArray,
                    arrayLikeIsIterable,
                    useBuiltIns,
                    objectRestNoSymbols,
                    addHelper
                  });
                  core.types.isPattern(pattern) ? (destructuring.init(pattern, patternId), +i != node.declarations.length - 1 && core.types.inherits(nodes[nodes.length - 1], declar)) : nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));
                }
                let tail = null;
                const nodesOut = [];
                for (const node of nodes) null !== tail && core.types.isVariableDeclaration(node) ? tail.declarations.push(...node.declarations) : (node.kind = nodeKind, 
                node.loc || (node.loc = nodeLoc), nodesOut.push(node), tail = core.types.isVariableDeclaration(node) ? node : null);
                for (const nodeOut of nodesOut) if (nodeOut.declarations) for (const declaration of nodeOut.declarations) {
                  const {name} = declaration.id;
                  scope.bindings[name] && (scope.bindings[name].kind = nodeOut.kind);
                }
                1 === nodesOut.length ? path.replaceWith(nodesOut[0]) : path.replaceWithMultiple(nodesOut);
              }(path, (name => state.addHelper(name)), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
            }
          }
        };
      }));
      exports.default = index;
    },
    4410: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperCreateRegexpFeaturesPlugin = __webpack_require__(1357), _default = (0, 
      __webpack_require__(4982).declare)((api => (api.assertVersion(7), (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-dotall-regex",
        feature: "dotAllFlag"
      }))));
      exports.default = _default;
    },
    8144: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629);
      var _default = (0, _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-duplicate-keys",
        visitor: {
          ObjectExpression(path) {
            const {node} = path, plainProps = node.properties.filter((prop => !_core.types.isSpreadElement(prop) && !prop.computed)), alreadySeenData = Object.create(null), alreadySeenGetters = Object.create(null), alreadySeenSetters = Object.create(null);
            for (const prop of plainProps) {
              const name = (key = prop.key, _core.types.isIdentifier(key) ? key.name : key.value.toString());
              let isDuplicate = !1;
              switch (prop.kind) {
               case "get":
                (alreadySeenData[name] || alreadySeenGetters[name]) && (isDuplicate = !0), alreadySeenGetters[name] = !0;
                break;

               case "set":
                (alreadySeenData[name] || alreadySeenSetters[name]) && (isDuplicate = !0), alreadySeenSetters[name] = !0;
                break;

               default:
                (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) && (isDuplicate = !0), 
                alreadySeenData[name] = !0;
              }
              isDuplicate && (prop.computed = !0, prop.key = _core.types.stringLiteral(name));
            }
            var key;
          }
        }
      })));
      exports.default = _default;
    },
    2488: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperBuilderBinaryAssignmentOperatorVisitor = __webpack_require__(1820), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-exponentiation-operator",
        visitor: (0, _helperBuilderBinaryAssignmentOperatorVisitor.default)({
          operator: "**",
          build: (left, right) => _core.types.callExpression(_core.types.memberExpression(_core.types.identifier("Math"), _core.types.identifier("pow")), [ left, right ])
        })
      })));
      exports.default = _default;
    },
    7149: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _noHelperImplementation = __webpack_require__(9876), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        var _options$assumeArray, _options$allowArrayLi, _api$assumption;
        api.assertVersion(7);
        {
          const {assumeArray, allowArrayLike, loose} = options;
          if (!0 === loose && !0 === assumeArray) throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
          if (!0 === assumeArray && !0 === allowArrayLike) throw new Error("The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of");
          if (allowArrayLike && /^7\.\d\./.test(api.version)) throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
        }
        const iterableIsArray = null != (_options$assumeArray = options.assumeArray) ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray"), arrayLikeIsIterable = null != (_options$allowArrayLi = options.allowArrayLike) ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable"), skipteratorClosing = null != (_api$assumption = api.assumption("skipForOfIteratorClosing")) ? _api$assumption : options.loose;
        if (iterableIsArray && arrayLikeIsIterable) throw new Error('The "iterableIsArray" and "arrayLikeIsIterable" assumptions are not compatible.');
        if (iterableIsArray) return {
          name: "transform-for-of",
          visitor: {
            ForOfStatement(path) {
              const {scope} = path, {left, right, await: isAwait} = path.node;
              if (isAwait) return;
              const i = scope.generateUidIdentifier("i");
              let array = scope.maybeGenerateMemoised(right, !0);
              const inits = [ _core.types.variableDeclarator(i, _core.types.numericLiteral(0)) ];
              array ? inits.push(_core.types.variableDeclarator(array, right)) : array = right;
              const item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), !0);
              let assignment, blockBody;
              _core.types.isVariableDeclaration(left) ? (assignment = left, assignment.declarations[0].init = item) : assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, item));
              const body = path.get("body");
              body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some((id => body.scope.hasOwnBinding(id))) ? blockBody = _core.types.blockStatement([ assignment, body.node ]) : (blockBody = _core.types.toBlock(body.node), 
              blockBody.body.unshift(assignment)), path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration("let", inits), _core.types.binaryExpression("<", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier("length"))), _core.types.updateExpression("++", _core.types.cloneNode(i)), blockBody));
            }
          }
        };
        const buildForOfArray = _core.template`
    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;
  `, buildForOfNoIteratorClosing = _core.template.statements`
    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;
  `, buildForOf = _core.template.statements`
    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
    try {
      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;
    } catch (err) {
      ITERATOR_HELPER.e(err);
    } finally {
      ITERATOR_HELPER.f();
    }
  `, builder = skipteratorClosing ? {
          build: buildForOfNoIteratorClosing,
          helper: "createForOfIteratorHelperLoose",
          getContainer: nodes => nodes
        } : {
          build: buildForOf,
          helper: "createForOfIteratorHelper",
          getContainer: nodes => nodes[1].block.body
        };
        return {
          name: "transform-for-of",
          visitor: {
            ForOfStatement(path, state) {
              const right = path.get("right");
              if (right.isArrayExpression() || right.isGenericType("Array") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) return void path.replaceWith(function(path) {
                const {node, scope} = path, right = scope.generateUidIdentifierBasedOnNode(node.right, "arr"), iterationKey = scope.generateUidIdentifier("i"), loop = buildForOfArray({
                  BODY: node.body,
                  KEY: iterationKey,
                  NAME: right,
                  ARR: node.right
                });
                _core.types.inherits(loop, node), _core.types.ensureBlock(loop);
                const iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), !0), left = node.left;
                return _core.types.isVariableDeclaration(left) ? (left.declarations[0].init = iterationValue, 
                loop.body.body.unshift(left)) : loop.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, iterationValue))), 
                loop;
              }(path));
              if (!state.availableHelper(builder.helper)) return void (0, _noHelperImplementation.default)(skipteratorClosing, path, state);
              const {node, parent, scope} = path, left = node.left;
              let declar;
              const stepKey = scope.generateUid("step"), stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
              declar = _core.types.isVariableDeclaration(left) ? _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, stepValue) ]) : _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue)), 
              path.ensureBlock(), node.body.body.unshift(declar);
              const nodes = builder.build({
                CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
                ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
                ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? _core.types.booleanLiteral(!0) : null,
                STEP_KEY: _core.types.identifier(stepKey),
                OBJECT: node.right,
                BODY: node.body
              }), container = builder.getContainer(nodes);
              _core.types.inherits(container[0], node), _core.types.inherits(container[0].body, node.body), 
              _core.types.isLabeledStatement(parent) ? (container[0] = _core.types.labeledStatement(parent.label, container[0]), 
              path.parentPath.replaceWithMultiple(nodes), path.skip()) : path.replaceWithMultiple(nodes);
            }
          }
        };
      }));
      exports.default = _default;
    },
    9876: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(loose, path, state) {
        const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec, {node} = path, build = pushComputedProps(path, state), declar = build.declar, loop = build.loop, block = loop.body;
        path.ensureBlock(), declar && block.body.push(declar);
        block.body.push(...node.body.body), _core.types.inherits(loop, node), _core.types.inherits(loop.body, node.body), 
        build.replaceParent ? (path.parentPath.replaceWithMultiple(build.node), path.remove()) : path.replaceWithMultiple(build.node);
      };
      var _core = __webpack_require__(4629);
      const buildForOfLoose = (0, _core.template)("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n"), buildForOf = (0, 
      _core.template)("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");
      function pushComputedPropsLoose(path, file) {
        const {node, scope, parent} = path, {left} = node;
        let declar, id, intermediate;
        if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) id = left, 
        intermediate = null; else {
          if (!_core.types.isVariableDeclaration(left)) throw file.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
          id = scope.generateUidIdentifier("ref"), declar = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, _core.types.identifier(id.name)) ]), 
          intermediate = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(id.name)) ]);
        }
        const iteratorKey = scope.generateUidIdentifier("iterator"), isArrayKey = scope.generateUidIdentifier("isArray"), loop = buildForOfLoose({
          LOOP_OBJECT: iteratorKey,
          IS_ARRAY: isArrayKey,
          OBJECT: node.right,
          INDEX: scope.generateUidIdentifier("i"),
          ID: id,
          INTERMEDIATE: intermediate
        }), isLabeledParent = _core.types.isLabeledStatement(parent);
        let labeled;
        return isLabeledParent && (labeled = _core.types.labeledStatement(parent.label, loop)), 
        {
          replaceParent: isLabeledParent,
          declar,
          node: labeled || loop,
          loop
        };
      }
      function pushComputedPropsSpec(path, file) {
        const {node, scope, parent} = path, left = node.left;
        let declar;
        const stepKey = scope.generateUid("step"), stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
        if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue)); else {
          if (!_core.types.isVariableDeclaration(left)) throw file.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
          declar = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, stepValue) ]);
        }
        const template = buildForOf({
          ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
          ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
          ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
          ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
          STEP_KEY: _core.types.identifier(stepKey),
          OBJECT: node.right
        }), isLabeledParent = _core.types.isLabeledStatement(parent), tryBody = template[3].block.body, loop = tryBody[0];
        return isLabeledParent && (tryBody[0] = _core.types.labeledStatement(parent.label, loop)), 
        {
          replaceParent: isLabeledParent,
          declar,
          loop,
          node: template
        };
      }
    },
    6042: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperCompilationTargets = __webpack_require__(4077), _helperPluginUtils = __webpack_require__(4982), _helperFunctionName = __webpack_require__(1485), _default = (0, 
      _helperPluginUtils.declare)((api => {
        api.assertVersion(7);
        const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
        return {
          name: "transform-function-name",
          visitor: {
            FunctionExpression: {
              exit(path) {
                if ("value" !== path.key && !path.parentPath.isObjectProperty()) {
                  const replacement = (0, _helperFunctionName.default)(path);
                  replacement && path.replaceWith(replacement);
                }
              }
            },
            ObjectProperty(path) {
              const value = path.get("value");
              if (value.isFunction()) {
                const newNode = (0, _helperFunctionName.default)(value, !1, supportUnicodeId);
                newNode && value.replaceWith(newNode);
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    8012: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(4982).declare)((api => (api.assertVersion(7), 
      {
        name: "transform-literals",
        visitor: {
          NumericLiteral({node}) {
            node.extra && /^0[ob]/i.test(node.extra.raw) && (node.extra = void 0);
          },
          StringLiteral({node}) {
            node.extra && /\\[u]/gi.test(node.extra.raw) && (node.extra = void 0);
          }
        }
      })));
      exports.default = _default;
    },
    3740: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-member-expression-literals",
        visitor: {
          MemberExpression: {
            exit({node}) {
              const prop = node.property;
              node.computed || !_core.types.isIdentifier(prop) || _core.types.isValidES3Identifier(prop.name) || (node.property = _core.types.stringLiteral(prop.name), 
              node.computed = !0);
            }
          }
        }
      })));
      exports.default = _default;
    },
    3152: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperModuleTransforms = __webpack_require__(2454), _core = __webpack_require__(4629), _utils = __webpack_require__(6113);
      const buildWrapper = (0, _core.template)("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n"), buildAnonymousWrapper = (0, 
      _core.template)('\n  define(["require"], function(REQUIRE) {\n  })\n');
      function injectWrapper(path, wrapper) {
        const {body, directives} = path.node;
        path.node.directives = [], path.node.body = [];
        const amdFactory = path.pushContainer("body", wrapper)[0].get("expression.arguments").filter((arg => arg.isFunctionExpression()))[0].get("body");
        amdFactory.pushContainer("directives", directives), amdFactory.pushContainer("body", body);
      }
      var _default = (0, _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption, _api$assumption2;
        api.assertVersion(7);
        const {allowTopLevelThis, strict, strictMode, importInterop, noInterop} = options, constantReexports = null != (_api$assumption = api.assumption("constantReexports")) ? _api$assumption : options.loose, enumerableModuleMeta = null != (_api$assumption2 = api.assumption("enumerableModuleMeta")) ? _api$assumption2 : options.loose;
        return {
          name: "transform-modules-amd",
          pre() {
            this.file.set("@babel/plugin-transform-modules-*", "amd");
          },
          visitor: {
            CallExpression(path, state) {
              if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
              if (!path.get("callee").isImport()) return;
              let {requireId, resolveId, rejectId} = state;
              requireId || (requireId = path.scope.generateUidIdentifier("require"), state.requireId = requireId), 
              resolveId && rejectId || (resolveId = path.scope.generateUidIdentifier("resolve"), 
              rejectId = path.scope.generateUidIdentifier("reject"), state.resolveId = resolveId, 
              state.rejectId = rejectId);
              let result = _core.types.identifier("imported");
              noInterop || (result = (0, _helperModuleTransforms.wrapInterop)(path, result, "namespace")), 
              path.replaceWith(_core.template.expression.ast`
            new Promise((${resolveId}, ${rejectId}) =>
              ${requireId}(
                [${(0, _utils.getImportSource)(_core.types, path.node)}],
                imported => ${_core.types.cloneNode(resolveId)}(${result}),
                ${_core.types.cloneNode(rejectId)}
              )
            )`);
            },
            Program: {
              exit(path, {requireId}) {
                if (!(0, _helperModuleTransforms.isModule)(path)) return void (requireId && injectWrapper(path, buildAnonymousWrapper({
                  REQUIRE: _core.types.cloneNode(requireId)
                })));
                const amdArgs = [], importNames = [];
                requireId && (amdArgs.push(_core.types.stringLiteral("require")), importNames.push(_core.types.cloneNode(requireId)));
                let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                moduleName && (moduleName = _core.types.stringLiteral(moduleName));
                const {meta, headers} = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                  enumerableModuleMeta,
                  constantReexports,
                  strict,
                  strictMode,
                  allowTopLevelThis,
                  importInterop,
                  noInterop
                });
                (0, _helperModuleTransforms.hasExports)(meta) && (amdArgs.push(_core.types.stringLiteral("exports")), 
                importNames.push(_core.types.identifier(meta.exportName)));
                for (const [source, metadata] of meta.source) {
                  if (amdArgs.push(_core.types.stringLiteral(source)), importNames.push(_core.types.identifier(metadata.name)), 
                  !(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                    const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
                    if (interop) {
                      const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                      header.loc = metadata.loc, headers.push(header);
                    }
                  }
                  headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
                }
                (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers), 
                injectWrapper(path, buildWrapper({
                  MODULE_NAME: moduleName,
                  AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
                  IMPORT_NAMES: importNames
                }));
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    2558: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperModuleTransforms = __webpack_require__(2454), _helperSimpleAccess = __webpack_require__(9196), _core = __webpack_require__(4629), _utils = __webpack_require__(6113), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption, _api$assumption2, _api$assumption3;
        api.assertVersion(7);
        const transformImportCall = (0, _utils.createDynamicImportTransform)(api), {strictNamespace = !1, mjsStrictNamespace = strictNamespace, allowTopLevelThis, strict, strictMode, noInterop, importInterop, lazy = !1, allowCommonJSExports = !0} = options, constantReexports = null != (_api$assumption = api.assumption("constantReexports")) ? _api$assumption : options.loose, enumerableModuleMeta = null != (_api$assumption2 = api.assumption("enumerableModuleMeta")) ? _api$assumption2 : options.loose, noIncompleteNsImportDetection = null != (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) && _api$assumption3;
        if (!("boolean" == typeof lazy || "function" == typeof lazy || Array.isArray(lazy) && lazy.every((item => "string" == typeof item)))) throw new Error(".lazy must be a boolean, array of strings, or a function");
        if ("boolean" != typeof strictNamespace) throw new Error(".strictNamespace must be a boolean, or undefined");
        if ("boolean" != typeof mjsStrictNamespace) throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
        const getAssertion = localName => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, moduleExportsVisitor = {
          ReferencedIdentifier(path) {
            const localName = path.node.name;
            if ("module" !== localName && "exports" !== localName) return;
            const localBinding = path.scope.getBinding(localName);
            this.scope.getBinding(localName) !== localBinding || path.parentPath.isObjectProperty({
              value: path.node
            }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
              left: path.node
            }) || path.isAssignmentExpression({
              left: path.node
            }) || path.replaceWith(getAssertion(localName));
          },
          UpdateExpression(path) {
            const arg = path.get("argument"), localName = arg.node.name;
            if ("module" !== localName && "exports" !== localName) return;
            const localBinding = path.scope.getBinding(localName);
            this.scope.getBinding(localName) === localBinding && path.replaceWith(_core.types.assignmentExpression(path.node.operator[0] + "=", arg.node, getAssertion(localName)));
          },
          AssignmentExpression(path) {
            const left = path.get("left");
            if (left.isIdentifier()) {
              const localName = path.node.name;
              if ("module" !== localName && "exports" !== localName) return;
              const localBinding = path.scope.getBinding(localName);
              if (this.scope.getBinding(localName) !== localBinding) return;
              const right = path.get("right");
              right.replaceWith(_core.types.sequenceExpression([ right.node, getAssertion(localName) ]));
            } else if (left.isPattern()) {
              const ids = left.getOuterBindingIdentifiers(), localName = Object.keys(ids).filter((localName => ("module" === localName || "exports" === localName) && this.scope.getBinding(localName) === path.scope.getBinding(localName)))[0];
              if (localName) {
                const right = path.get("right");
                right.replaceWith(_core.types.sequenceExpression([ right.node, getAssertion(localName) ]));
              }
            }
          }
        };
        return {
          name: "transform-modules-commonjs",
          pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs");
          },
          visitor: {
            CallExpression(path) {
              if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
              if (!path.get("callee").isImport()) return;
              let {scope} = path;
              do {
                scope.rename("require");
              } while (scope = scope.parent);
              transformImportCall(this, path.get("callee"));
            },
            Program: {
              exit(path, state) {
                if (!(0, _helperModuleTransforms.isModule)(path)) return;
                path.scope.rename("exports"), path.scope.rename("module"), path.scope.rename("require"), 
                path.scope.rename("__filename"), path.scope.rename("__dirname"), allowCommonJSExports || ((0, 
                _helperSimpleAccess.default)(path, new Set([ "module", "exports" ]), !1), path.traverse(moduleExportsVisitor, {
                  scope: path.scope
                }));
                let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                moduleName && (moduleName = _core.types.stringLiteral(moduleName));
                const {meta, headers} = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                  exportName: "exports",
                  constantReexports,
                  enumerableModuleMeta,
                  strict,
                  strictMode,
                  allowTopLevelThis,
                  noInterop,
                  importInterop,
                  lazy,
                  esNamespaceOnly: "string" == typeof state.filename && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
                  noIncompleteNsImportDetection
                });
                for (const [source, metadata] of meta.source) {
                  const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [ _core.types.stringLiteral(source) ]);
                  let header;
                  if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                    if (metadata.lazy) throw new Error("Assertion failure");
                    header = _core.types.expressionStatement(loadExpr);
                  } else {
                    const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
                    header = metadata.lazy ? _core.template.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function(){ return data; };
                    return data;
                  }
                ` : _core.template.ast`
                  var ${metadata.name} = ${init};
                `;
                  }
                  header.loc = metadata.loc, headers.push(header), headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
                }
                (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers), 
                path.get("body").forEach((path => {
                  -1 !== headers.indexOf(path.node) && path.isVariableDeclaration() && path.scope.registerDeclaration(path);
                }));
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    1089: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0, exports.getExportSpecifierName = getExportSpecifierName;
      var _helperPluginUtils = __webpack_require__(4982), _helperHoistVariables = __webpack_require__(9061), _core = __webpack_require__(4629), _utils = __webpack_require__(6113), _helperModuleTransforms = __webpack_require__(2454), _helperValidatorIdentifier = __webpack_require__(720);
      const buildTemplate = _core.template.statement('\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    "use strict";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n'), buildExportAll = _core.template.statement('\n  for (var KEY in TARGET) {\n    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n');
      function getExportSpecifierName(node, stringSpecifiers) {
        if ("Identifier" === node.type) return node.name;
        if ("StringLiteral" === node.type) {
          const stringValue = node.value;
          return (0, _helperValidatorIdentifier.isIdentifierName)(stringValue) || stringSpecifiers.add(stringValue), 
          stringValue;
        }
        throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);
      }
      function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
        const statements = [];
        if (exportStarTarget) {
          const exportObj = path.scope.generateUid("exportObj");
          statements.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([])) ])), 
          statements.push(buildExportAll({
            KEY: path.scope.generateUidIdentifier("key"),
            EXPORT_OBJ: _core.types.identifier(exportObj),
            TARGET: exportStarTarget
          }));
          for (let i = 0; i < exportNames.length; i++) {
            const exportName = exportNames[i], exportValue = exportValues[i];
            statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
          }
          statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [ _core.types.identifier(exportObj) ])));
        } else if (1 === exportNames.length) statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [ _core.types.stringLiteral(exportNames[0]), exportValues[0] ]))); else {
          const objectProperties = [];
          for (let i = 0; i < exportNames.length; i++) {
            const exportName = exportNames[i], exportValue = exportValues[i];
            objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));
          }
          statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [ _core.types.objectExpression(objectProperties) ])));
        }
        return statements;
      }
      var _default = (0, _helperPluginUtils.declare)(((api, options) => {
        api.assertVersion(7);
        const {systemGlobal = "System", allowTopLevelThis = !1} = options, IGNORE_REASSIGNMENT_SYMBOL = Symbol(), reassignmentVisitor = {
          "AssignmentExpression|UpdateExpression"(path) {
            if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
            path.node[IGNORE_REASSIGNMENT_SYMBOL] = !0;
            const arg = path.get(path.isAssignmentExpression() ? "left" : "argument");
            if (arg.isObjectPattern() || arg.isArrayPattern()) {
              const exprs = [ path.node ];
              for (const name of Object.keys(arg.getBindingIdentifiers())) {
                if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
                const exportedNames = this.exports[name];
                if (!exportedNames) return;
                for (const exportedName of exportedNames) exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);
              }
              return void path.replaceWith(_core.types.sequenceExpression(exprs));
            }
            if (!arg.isIdentifier()) return;
            const name = arg.node.name;
            if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
            const exportedNames = this.exports[name];
            if (!exportedNames) return;
            let node = path.node;
            const isPostUpdateExpression = path.isUpdateExpression({
              prefix: !1
            });
            isPostUpdateExpression && (node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1)));
            for (const exportedName of exportedNames) node = this.buildCall(exportedName, node).expression;
            isPostUpdateExpression && (node = _core.types.sequenceExpression([ node, path.node ])), 
            path.replaceWith(node);
          }
        };
        return {
          name: "transform-modules-systemjs",
          pre() {
            this.file.set("@babel/plugin-transform-modules-*", "systemjs");
          },
          visitor: {
            CallExpression(path, state) {
              _core.types.isImport(path.node.callee) && (this.file.has("@babel/plugin-proposal-dynamic-import") || console.warn("WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n"), 
              path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [ (0, 
              _utils.getImportSource)(_core.types, path.node) ])));
            },
            MetaProperty(path, state) {
              "import" === path.node.meta.name && "meta" === path.node.property.name && path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
            },
            ReferencedIdentifier(path, state) {
              "__moduleName" !== path.node.name || path.scope.hasBinding("__moduleName") || path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
            },
            Program: {
              enter(path, state) {
                state.contextIdent = path.scope.generateUid("context"), state.stringSpecifiers = new Set, 
                allowTopLevelThis || (0, _helperModuleTransforms.rewriteThis)(path);
              },
              exit(path, state) {
                const scope = path.scope, exportIdent = scope.generateUid("export"), {contextIdent, stringSpecifiers} = state, exportMap = Object.create(null), modules = [], beforeBody = [], setters = [], sources = [], variableIds = [], removedPaths = [];
                function addExportName(key, val) {
                  exportMap[key] = exportMap[key] || [], exportMap[key].push(val);
                }
                function pushModule(source, key, specifiers) {
                  let module;
                  modules.forEach((function(m) {
                    m.key === source && (module = m);
                  })), module || modules.push(module = {
                    key: source,
                    imports: [],
                    exports: []
                  }), module[key] = module[key].concat(specifiers);
                }
                function buildExportCall(name, val) {
                  return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [ _core.types.stringLiteral(name), val ]));
                }
                const exportNames = [], exportValues = [], body = path.get("body");
                for (const path of body) if (path.isFunctionDeclaration()) beforeBody.push(path.node), 
                removedPaths.push(path); else if (path.isClassDeclaration()) variableIds.push(_core.types.cloneNode(path.node.id)), 
                path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node)))); else if (path.isVariableDeclaration()) path.node.kind = "var"; else if (path.isImportDeclaration()) {
                  pushModule(path.node.source.value, "imports", path.node.specifiers);
                  for (const name of Object.keys(path.getBindingIdentifiers())) scope.removeBinding(name), 
                  variableIds.push(_core.types.identifier(name));
                  path.remove();
                } else if (path.isExportAllDeclaration()) pushModule(path.node.source.value, "exports", path.node), 
                path.remove(); else if (path.isExportDefaultDeclaration()) {
                  const declar = path.get("declaration");
                  if (declar.isClassDeclaration()) {
                    const id = declar.node.id;
                    id ? (exportNames.push("default"), exportValues.push(scope.buildUndefinedNode()), 
                    variableIds.push(_core.types.cloneNode(id)), addExportName(id.name, "default"), 
                    path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar.node))))) : (exportNames.push("default"), 
                    exportValues.push(_core.types.toExpression(declar.node)), removedPaths.push(path));
                  } else if (declar.isFunctionDeclaration()) {
                    const id = declar.node.id;
                    id ? (beforeBody.push(declar.node), exportNames.push("default"), exportValues.push(_core.types.cloneNode(id)), 
                    addExportName(id.name, "default")) : (exportNames.push("default"), exportValues.push(_core.types.toExpression(declar.node))), 
                    removedPaths.push(path);
                  } else path.replaceWith(buildExportCall("default", declar.node));
                } else if (path.isExportNamedDeclaration()) {
                  const declar = path.get("declaration");
                  if (declar.node) if (path.replaceWith(declar), declar.isFunction()) {
                    const node = declar.node, name = node.id.name;
                    addExportName(name, name), beforeBody.push(node), exportNames.push(name), exportValues.push(_core.types.cloneNode(node.id)), 
                    removedPaths.push(path);
                  } else if (declar.isClass()) {
                    const name = declar.node.id.name;
                    exportNames.push(name), exportValues.push(scope.buildUndefinedNode()), variableIds.push(_core.types.cloneNode(declar.node.id)), 
                    path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node)))), 
                    addExportName(name, name);
                  } else {
                    declar.isVariableDeclaration() && (declar.node.kind = "var");
                    for (const name of Object.keys(declar.getBindingIdentifiers())) addExportName(name, name);
                  } else {
                    const specifiers = path.node.specifiers;
                    if (null != specifiers && specifiers.length) if (path.node.source) pushModule(path.node.source.value, "exports", specifiers), 
                    path.remove(); else {
                      const nodes = [];
                      for (const specifier of specifiers) {
                        const {local, exported} = specifier, binding = scope.getBinding(local.name), exportedName = getExportSpecifierName(exported, stringSpecifiers);
                        binding && _core.types.isFunctionDeclaration(binding.path.node) ? (exportNames.push(exportedName), 
                        exportValues.push(_core.types.cloneNode(local))) : binding || nodes.push(buildExportCall(exportedName, local)), 
                        addExportName(local.name, exportedName);
                      }
                      path.replaceWithMultiple(nodes);
                    } else path.remove();
                  }
                }
                modules.forEach((function(specifiers) {
                  const setterBody = [], target = scope.generateUid(specifiers.key);
                  for (let specifier of specifiers.imports) if (_core.types.isImportNamespaceSpecifier(specifier) ? setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target)))) : _core.types.isImportDefaultSpecifier(specifier) && (specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"))), 
                  _core.types.isImportSpecifier(specifier)) {
                    const {imported} = specifier;
                    setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, "StringLiteral" === imported.type))));
                  }
                  if (specifiers.exports.length) {
                    const exportNames = [], exportValues = [];
                    let hasExportStar = !1;
                    for (const node of specifiers.exports) if (_core.types.isExportAllDeclaration(node)) hasExportStar = !0; else if (_core.types.isExportSpecifier(node)) {
                      const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);
                      exportNames.push(exportedName), exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));
                    }
                    setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));
                  }
                  sources.push(_core.types.stringLiteral(specifiers.key)), setters.push(_core.types.functionExpression(null, [ _core.types.identifier(target) ], _core.types.blockStatement(setterBody)));
                }));
                let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                moduleName && (moduleName = _core.types.stringLiteral(moduleName)), (0, _helperHoistVariables.default)(path, ((id, name, hasInit) => {
                  if (variableIds.push(id), !hasInit && name in exportMap) for (const exported of exportMap[name]) exportNames.push(exported), 
                  exportValues.push(scope.buildUndefinedNode());
                })), variableIds.length && beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map((id => _core.types.variableDeclarator(id))))), 
                exportNames.length && beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers)), 
                path.traverse(reassignmentVisitor, {
                  exports: exportMap,
                  buildCall: buildExportCall,
                  scope
                });
                for (const path of removedPaths) path.remove();
                let hasTLA = !1;
                path.traverse({
                  AwaitExpression(path) {
                    hasTLA = !0, path.stop();
                  },
                  Function(path) {
                    path.skip();
                  },
                  noScope: !0
                }), path.node.body = [ buildTemplate({
                  SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
                  BEFORE_BODY: beforeBody,
                  MODULE_NAME: moduleName,
                  SETTERS: _core.types.arrayExpression(setters),
                  EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), !1, hasTLA),
                  SOURCES: _core.types.arrayExpression(sources),
                  EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
                  CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
                }) ];
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    7704: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _path = __webpack_require__(1017), _helperModuleTransforms = __webpack_require__(2454), _core = __webpack_require__(4629);
      const buildPrerequisiteAssignment = (0, _core.template)("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n"), buildWrapper = (0, 
      _core.template)('\n  (function (global, factory) {\n    if (typeof define === "function" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== "undefined") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== "undefined" ? globalThis\n      : typeof self !== "undefined" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n');
      var _default = (0, _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption, _api$assumption2;
        api.assertVersion(7);
        const {globals, exactGlobals, allowTopLevelThis, strict, strictMode, noInterop, importInterop} = options, constantReexports = null != (_api$assumption = api.assumption("constantReexports")) ? _api$assumption : options.loose, enumerableModuleMeta = null != (_api$assumption2 = api.assumption("enumerableModuleMeta")) ? _api$assumption2 : options.loose;
        function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
          const moduleNameOrBasename = moduleName ? moduleName.value : (0, _path.basename)(filename, (0, 
          _path.extname)(filename));
          let globalToAssign = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(moduleNameOrBasename))), initAssignments = [];
          if (exactGlobals) {
            const globalName = browserGlobals[moduleNameOrBasename];
            if (globalName) {
              initAssignments = [];
              const members = globalName.split(".");
              globalToAssign = members.slice(1).reduce(((accum, curr) => (initAssignments.push(buildPrerequisiteAssignment({
                GLOBAL_REFERENCE: _core.types.cloneNode(accum)
              })), _core.types.memberExpression(accum, _core.types.identifier(curr)))), _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(members[0])));
            }
          }
          return initAssignments.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", globalToAssign, _core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports"))))), 
          initAssignments;
        }
        function buildBrowserArg(browserGlobals, exactGlobals, source) {
          let memberExpression;
          if (exactGlobals) {
            const globalRef = browserGlobals[source];
            memberExpression = globalRef ? globalRef.split(".").reduce(((accum, curr) => _core.types.memberExpression(accum, _core.types.identifier(curr))), _core.types.identifier("global")) : _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(source)));
          } else {
            const requireName = (0, _path.basename)(source, (0, _path.extname)(source)), globalName = browserGlobals[requireName] || requireName;
            memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(globalName)));
          }
          return memberExpression;
        }
        return {
          name: "transform-modules-umd",
          visitor: {
            Program: {
              exit(path) {
                if (!(0, _helperModuleTransforms.isModule)(path)) return;
                const browserGlobals = globals || {};
                let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                moduleName && (moduleName = _core.types.stringLiteral(moduleName));
                const {meta, headers} = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                  constantReexports,
                  enumerableModuleMeta,
                  strict,
                  strictMode,
                  allowTopLevelThis,
                  noInterop,
                  importInterop
                }), amdArgs = [], commonjsArgs = [], browserArgs = [], importNames = [];
                (0, _helperModuleTransforms.hasExports)(meta) && (amdArgs.push(_core.types.stringLiteral("exports")), 
                commonjsArgs.push(_core.types.identifier("exports")), browserArgs.push(_core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports"))), 
                importNames.push(_core.types.identifier(meta.exportName)));
                for (const [source, metadata] of meta.source) {
                  if (amdArgs.push(_core.types.stringLiteral(source)), commonjsArgs.push(_core.types.callExpression(_core.types.identifier("require"), [ _core.types.stringLiteral(source) ])), 
                  browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source)), importNames.push(_core.types.identifier(metadata.name)), 
                  !(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                    const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
                    if (interop) {
                      const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                      header.loc = meta.loc, headers.push(header);
                    }
                  }
                  headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
                }
                (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers);
                const {body, directives} = path.node;
                path.node.directives = [], path.node.body = [];
                const umdFactory = path.pushContainer("body", [ buildWrapper({
                  MODULE_NAME: moduleName,
                  AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
                  COMMONJS_ARGUMENTS: commonjsArgs,
                  BROWSER_ARGUMENTS: browserArgs,
                  IMPORT_NAMES: importNames,
                  GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
                }) ])[0].get("expression.arguments")[1].get("body");
                umdFactory.pushContainer("directives", directives), umdFactory.pushContainer("body", body);
              }
            }
          }
        };
      }));
      exports.default = _default;
    },
    4790: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(core, options) {
        const {runtime = !0} = options;
        if ("boolean" != typeof runtime) throw new Error("The 'runtime' option must be boolean");
        return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
          name: "transform-named-capturing-groups-regex",
          feature: "namedCaptureGroups",
          options: {
            runtime
          }
        });
      };
      var _helperCreateRegexpFeaturesPlugin = __webpack_require__(1357);
    },
    4023: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-new-target",
        visitor: {
          MetaProperty(path) {
            const meta = path.get("meta"), property = path.get("property"), {scope} = path;
            if (meta.isIdentifier({
              name: "new"
            }) && property.isIdentifier({
              name: "target"
            })) {
              const func = path.findParent((path => !!path.isClass() || !(!path.isFunction() || path.isArrowFunctionExpression()) && !path.isClassMethod({
                kind: "constructor"
              })));
              if (!func) throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
              const {node} = func;
              if (!node.id) {
                if (func.isMethod()) return void path.replaceWith(scope.buildUndefinedNode());
                node.id = scope.generateUidIdentifier("target");
              }
              const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));
              if (func.isClass()) return void path.replaceWith(constructor);
              path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
            }
          }
        }
      })));
      exports.default = _default;
    },
    8654: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperReplaceSupers = __webpack_require__(4149), _core = __webpack_require__(4629);
      var _default = (0, _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-object-super",
        visitor: {
          ObjectExpression(path, state) {
            let objectRef;
            const getObjectRef = () => objectRef = objectRef || path.scope.generateUidIdentifier("obj");
            path.get("properties").forEach((propPath => {
              propPath.isMethod() && function(path, getObjectRef, file) {
                new _helperReplaceSupers.default({
                  getObjectRef,
                  methodPath: path,
                  file
                }).replace();
              }(propPath, getObjectRef, state);
            })), objectRef && (path.scope.push({
              id: _core.types.cloneNode(objectRef)
            }), path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(objectRef), path.node)));
          }
        }
      })));
      exports.default = _default;
    },
    9425: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "convertFunctionParams", {
        enumerable: !0,
        get: function() {
          return _params.default;
        }
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _params = __webpack_require__(5489), _rest = __webpack_require__(6133), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption;
        api.assertVersion(7);
        const ignoreFunctionLength = null != (_api$assumption = api.assumption("ignoreFunctionLength")) ? _api$assumption : options.loose, noNewArrows = api.assumption("noNewArrows");
        return {
          name: "transform-parameters",
          visitor: {
            Function(path) {
              if (path.isArrowFunctionExpression() && path.get("params").some((param => param.isRestElement() || param.isAssignmentPattern())) && (path.arrowFunctionToExpression({
                noNewArrows
              }), !path.isFunctionExpression())) return;
              const convertedRest = (0, _rest.default)(path), convertedParams = (0, _params.default)(path, ignoreFunctionLength);
              (convertedRest || convertedParams) && path.scope.crawl();
            }
          }
        };
      }));
      exports.default = _default;
    },
    5489: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
        const params = path.get("params");
        if (params.every((param => param.isIdentifier()))) return !1;
        const {node, scope} = path, state = {
          stop: !1,
          needsOuterBinding: !1,
          scope
        }, body = [], shadowedParams = new Set;
        for (const param of params) for (const name of Object.keys(param.getBindingIdentifiers())) {
          var _scope$bindings$name;
          const constantViolations = null == (_scope$bindings$name = scope.bindings[name]) ? void 0 : _scope$bindings$name.constantViolations;
          if (constantViolations) for (const redeclarator of constantViolations) {
            const node = redeclarator.node;
            switch (node.type) {
             case "VariableDeclarator":
              if (null === node.init) {
                const declaration = redeclarator.parentPath;
                if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                  redeclarator.remove();
                  break;
                }
              }
              shadowedParams.add(name);
              break;

             case "FunctionDeclaration":
              shadowedParams.add(name);
            }
          }
        }
        if (0 === shadowedParams.size) for (const param of params) if (param.isIdentifier() || param.traverse(iifeVisitor, state), 
        state.needsOuterBinding) break;
        let firstOptionalIndex = null;
        for (let i = 0; i < params.length; i++) {
          const param = params[i];
          if (shouldTransformParam && !shouldTransformParam(i)) continue;
          const transformedRestNodes = [];
          replaceRestElement && replaceRestElement(param.parentPath, param, transformedRestNodes);
          const paramIsAssignmentPattern = param.isAssignmentPattern();
          if (paramIsAssignmentPattern && (ignoreFunctionLength || "set" === node.kind)) {
            const left = param.get("left"), right = param.get("right"), undefinedNode = scope.buildUndefinedNode();
            if (left.isIdentifier()) body.push(buildLooseDefaultParam({
              ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),
              DEFAULT_VALUE: right.node,
              UNDEFINED: undefinedNode
            })), param.replaceWith(left.node); else if (left.isObjectPattern() || left.isArrayPattern()) {
              const paramName = scope.generateUidIdentifier();
              body.push(buildLooseDestructuredDefaultParam({
                ASSIGNMENT_IDENTIFIER: left.node,
                DEFAULT_VALUE: right.node,
                PARAMETER_NAME: _core.types.cloneNode(paramName),
                UNDEFINED: undefinedNode
              })), param.replaceWith(paramName);
            }
          } else if (paramIsAssignmentPattern) {
            null === firstOptionalIndex && (firstOptionalIndex = i);
            const left = param.get("left"), right = param.get("right"), defNode = buildDefaultParam({
              VARIABLE_NAME: left.node,
              DEFAULT_VALUE: right.node,
              ARGUMENT_KEY: _core.types.numericLiteral(i)
            });
            body.push(defNode);
          } else if (null !== firstOptionalIndex) {
            const defNode = buildSafeArgumentsAccess([ param.node, _core.types.numericLiteral(i) ]);
            body.push(defNode);
          } else if (param.isObjectPattern() || param.isArrayPattern()) {
            const uid = path.scope.generateUidIdentifier("ref"), defNode = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(param.node, uid) ]);
            body.push(defNode), param.replaceWith(_core.types.cloneNode(uid));
          }
          if (transformedRestNodes) for (const transformedNode of transformedRestNodes) body.push(transformedNode);
        }
        null !== firstOptionalIndex && (node.params = node.params.slice(0, firstOptionalIndex));
        if (path.ensureBlock(), state.needsOuterBinding || shadowedParams.size > 0) {
          body.push(function(shadowedParams, body) {
            const args = [], params = [];
            for (const name of shadowedParams) args.push(_core.types.identifier(name)), params.push(_core.types.identifier(name));
            return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));
          }(shadowedParams, path.get("body").node)), path.set("body", _core.types.blockStatement(body));
          const bodyPath = path.get("body.body"), arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
          arrowPath.arrowFunctionToExpression(), arrowPath.node.generator = path.node.generator, 
          arrowPath.node.async = path.node.async, path.node.generator = !1;
        } else path.get("body").unshiftContainer("body", body);
        return !0;
      };
      var _core = __webpack_require__(4629);
      const buildDefaultParam = (0, _core.template)("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n"), buildLooseDefaultParam = (0, 
      _core.template)("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n"), buildLooseDestructuredDefaultParam = (0, 
      _core.template)("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n"), buildSafeArgumentsAccess = (0, 
      _core.template)("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n"), iifeVisitor = {
        "ReferencedIdentifier|BindingIdentifier"(path, state) {
          const {scope, node} = path, {name} = node;
          ("eval" === name || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) && (state.needsOuterBinding = !0, 
          path.stop());
        },
        "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": path => path.skip()
      };
    },
    6133: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(path) {
        const {node, scope} = path;
        if (!function(node) {
          const length = node.params.length;
          return length > 0 && _core.types.isRestElement(node.params[length - 1]);
        }(node)) return !1;
        let rest = node.params.pop().argument;
        "arguments" === rest.name && scope.rename(rest.name);
        const argsId = _core.types.identifier("arguments");
        if (_core.types.isPattern(rest)) {
          const pattern = rest;
          rest = scope.generateUidIdentifier("ref");
          const declar = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(pattern, rest) ]);
          node.body.body.unshift(declar);
        }
        const paramsCount = function(node) {
          let count = node.params.length;
          count > 0 && _core.types.isIdentifier(node.params[0], {
            name: "this"
          }) && (count -= 1);
          return count;
        }(node), state = {
          references: [],
          offset: paramsCount,
          argumentsNode: argsId,
          outerBinding: scope.getBindingIdentifier(rest.name),
          candidates: [],
          name: rest.name,
          deopted: !1
        };
        if (path.traverse(memberExpressionOptimisationVisitor, state), !state.deopted && !state.references.length) {
          for (const {path, cause} of state.candidates) {
            const clonedArgsId = _core.types.cloneNode(argsId);
            switch (cause) {
             case "indexGetter":
              optimiseIndexGetter(path, clonedArgsId, state.offset);
              break;

             case "lengthGetter":
              optimiseLengthGetter(path, clonedArgsId, state.offset);
              break;

             default:
              path.replaceWith(clonedArgsId);
            }
          }
          return !0;
        }
        state.references.push(...state.candidates.map((({path}) => path)));
        const start = _core.types.numericLiteral(paramsCount), key = scope.generateUidIdentifier("key"), len = scope.generateUidIdentifier("len");
        let arrKey, arrLen;
        paramsCount ? (arrKey = _core.types.binaryExpression("-", _core.types.cloneNode(key), _core.types.cloneNode(start)), 
        arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(">", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression("-", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0))) : (arrKey = _core.types.identifier(key.name), 
        arrLen = _core.types.identifier(len.name));
        const loop = buildRest({
          ARGUMENTS: argsId,
          ARRAY_KEY: arrKey,
          ARRAY_LEN: arrLen,
          START: start,
          ARRAY: rest,
          KEY: key,
          LEN: len
        });
        if (state.deopted) node.body.body.unshift(loop); else {
          let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
          target.findParent((path => {
            if (!path.isLoop()) return path.isFunction();
            target = path;
          })), target.insertBefore(loop);
        }
        return !0;
      };
      var _core = __webpack_require__(4629);
      const buildRest = (0, _core.template)("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n"), restIndex = (0, 
      _core.template)("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n"), restIndexImpure = (0, 
      _core.template)("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n"), restLength = (0, 
      _core.template)("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");
      function referencesRest(path, state) {
        return path.node.name === state.name && path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
      }
      const memberExpressionOptimisationVisitor = {
        Scope(path, state) {
          path.scope.bindingIdentifierEquals(state.name, state.outerBinding) || path.skip();
        },
        Flow(path) {
          path.isTypeCastExpression() || path.skip();
        },
        Function(path, state) {
          const oldNoOptimise = state.noOptimise;
          state.noOptimise = !0, path.traverse(memberExpressionOptimisationVisitor, state), 
          state.noOptimise = oldNoOptimise, path.skip();
        },
        ReferencedIdentifier(path, state) {
          const {node} = path;
          if ("arguments" === node.name && (state.deopted = !0), referencesRest(path, state)) if (state.noOptimise) state.deopted = !0; else {
            const {parentPath} = path;
            if ("params" === parentPath.listKey && parentPath.key < state.offset) return;
            if (parentPath.isMemberExpression({
              object: node
            })) {
              const grandparentPath = parentPath.parentPath;
              if (!state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
                operator: "delete"
              }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee)) if (parentPath.node.computed) {
                if (parentPath.get("property").isBaseType("number")) return void state.candidates.push({
                  cause: "indexGetter",
                  path
                });
              } else if ("length" === parentPath.node.property.name) return void state.candidates.push({
                cause: "lengthGetter",
                path
              });
            }
            if (0 === state.offset && parentPath.isSpreadElement()) {
              const call = parentPath.parentPath;
              if (call.isCallExpression() && 1 === call.node.arguments.length) return void state.candidates.push({
                cause: "argSpread",
                path
              });
            }
            state.references.push(path);
          }
        },
        BindingIdentifier(path, state) {
          referencesRest(path, state) && (state.deopted = !0);
        }
      };
      function optimiseIndexGetter(path, argsId, offset) {
        const offsetLiteral = _core.types.numericLiteral(offset);
        let index;
        index = _core.types.isNumericLiteral(path.parent.property) ? _core.types.numericLiteral(path.parent.property.value + offset) : 0 === offset ? path.parent.property : _core.types.binaryExpression("+", path.parent.property, _core.types.cloneNode(offsetLiteral));
        const {scope} = path;
        if (scope.isPure(index)) {
          const parentPath = path.parentPath;
          parentPath.replaceWith(restIndex({
            ARGUMENTS: argsId,
            OFFSET: offsetLiteral,
            INDEX: index
          }));
          const valRes = parentPath.get("test").get("left").evaluate();
          valRes.confident && (!0 === valRes.value ? parentPath.replaceWith(parentPath.scope.buildUndefinedNode()) : parentPath.get("test").replaceWith(parentPath.get("test").get("right")));
        } else {
          const temp = scope.generateUidIdentifierBasedOnNode(index);
          scope.push({
            id: temp,
            kind: "var"
          }), path.parentPath.replaceWith(restIndexImpure({
            ARGUMENTS: argsId,
            OFFSET: offsetLiteral,
            INDEX: index,
            REF: _core.types.cloneNode(temp)
          }));
        }
      }
      function optimiseLengthGetter(path, argsId, offset) {
        offset ? path.parentPath.replaceWith(restLength({
          ARGUMENTS: argsId,
          OFFSET: _core.types.numericLiteral(offset)
        })) : path.replaceWith(argsId);
      }
    },
    3176: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-property-literals",
        visitor: {
          ObjectProperty: {
            exit({node}) {
              const key = node.key;
              node.computed || !_core.types.isIdentifier(key) || _core.types.isValidES3Identifier(key.name) || (node.key = _core.types.stringLiteral(key.name));
            }
          }
        }
      })));
      exports.default = _default;
    },
    2210: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = __webpack_require__(5833).default;
      exports.default = _default;
    },
    9400: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-reserved-words",
        visitor: {
          "BindingIdentifier|ReferencedIdentifier"(path) {
            _core.types.isValidES3Identifier(path.node.name) || path.scope.rename(path.node.name);
          }
        }
      })));
      exports.default = _default;
    },
    8347: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-shorthand-properties",
        visitor: {
          ObjectMethod(path) {
            const {node} = path;
            if ("method" === node.kind) {
              const func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
              func.returnType = node.returnType;
              const computedKey = _core.types.toComputedKey(node);
              _core.types.isStringLiteral(computedKey, {
                value: "__proto__"
              }) ? path.replaceWith(_core.types.objectProperty(computedKey, func, !0)) : path.replaceWith(_core.types.objectProperty(node.key, func, node.computed));
            }
          },
          ObjectProperty(path) {
            const {node} = path;
            if (node.shorthand) {
              const computedKey = _core.types.toComputedKey(node);
              _core.types.isStringLiteral(computedKey, {
                value: "__proto__"
              }) ? path.replaceWith(_core.types.objectProperty(computedKey, node.value, !0)) : node.shorthand = !1;
            }
          }
        }
      })));
      exports.default = _default;
    },
    267: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _helperSkipTransparentExpressionWrappers = __webpack_require__(4539), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption, _options$allowArrayLi;
        api.assertVersion(7);
        const iterableIsArray = null != (_api$assumption = api.assumption("iterableIsArray")) ? _api$assumption : options.loose, arrayLikeIsIterable = null != (_options$allowArrayLi = options.allowArrayLike) ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
        function getSpreadLiteral(spread, scope) {
          return iterableIsArray && !_core.types.isIdentifier(spread.argument, {
            name: "arguments"
          }) ? spread.argument : scope.toArray(spread.argument, !0, arrayLikeIsIterable);
        }
        function hasSpread(nodes) {
          for (let i = 0; i < nodes.length; i++) if (_core.types.isSpreadElement(nodes[i])) return !0;
          return !1;
        }
        function push(_props, nodes) {
          return _props.length ? (nodes.push(_core.types.arrayExpression(_props)), []) : _props;
        }
        function build(props, scope, file) {
          const nodes = [];
          let _props = [];
          for (const prop of props) if (_core.types.isSpreadElement(prop)) {
            _props = push(_props, nodes);
            let spreadLiteral = getSpreadLiteral(prop, scope);
            _core.types.isArrayExpression(spreadLiteral) && spreadLiteral.elements.some((el => null === el)) && (spreadLiteral = _core.types.callExpression(file.addHelper("arrayWithoutHoles"), [ spreadLiteral ])), 
            nodes.push(spreadLiteral);
          } else _props.push(prop);
          return push(_props, nodes), nodes;
        }
        return {
          name: "transform-spread",
          visitor: {
            ArrayExpression(path) {
              const {node, scope} = path, elements = node.elements;
              if (!hasSpread(elements)) return;
              const nodes = build(elements, scope, this);
              let first = nodes[0];
              1 !== nodes.length || first === elements[0].argument ? (_core.types.isArrayExpression(first) ? nodes.shift() : first = _core.types.arrayExpression([]), 
              path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes))) : path.replaceWith(first);
            },
            CallExpression(path) {
              const {node, scope} = path, args = node.arguments;
              if (!hasSpread(args)) return;
              const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("callee"));
              if (calleePath.isSuper()) throw path.buildCodeFrameError("It's not possible to compile spread arguments in `super()` without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
              let nodes, contextLiteral = scope.buildUndefinedNode();
              node.arguments = [], nodes = 1 === args.length && _core.types.isIdentifier(args[0].argument, {
                name: "arguments"
              }) ? [ args[0].argument ] : build(args, scope, this);
              const first = nodes.shift();
              nodes.length ? node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes)) : node.arguments.push(first);
              const callee = calleePath.node;
              if (_core.types.isMemberExpression(callee)) {
                const temp = scope.maybeGenerateMemoised(callee.object);
                temp ? (callee.object = _core.types.assignmentExpression("=", temp, callee.object), 
                contextLiteral = temp) : contextLiteral = _core.types.cloneNode(callee.object);
              }
              node.callee = _core.types.memberExpression(node.callee, _core.types.identifier("apply")), 
              _core.types.isSuper(contextLiteral) && (contextLiteral = _core.types.thisExpression()), 
              node.arguments.unshift(_core.types.cloneNode(contextLiteral));
            },
            NewExpression(path) {
              const {node, scope} = path;
              if (!hasSpread(node.arguments)) return;
              const nodes = build(node.arguments, scope, this), first = nodes.shift();
              let args;
              args = nodes.length ? _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes) : first, 
              path.replaceWith(_core.types.callExpression(path.hub.addHelper("construct"), [ node.callee, args ]));
            }
          }
        };
      }));
      exports.default = _default;
    },
    1827: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-sticky-regex",
        visitor: {
          RegExpLiteral(path) {
            const {node} = path;
            node.flags.includes("y") && path.replaceWith(_core.types.newExpression(_core.types.identifier("RegExp"), [ _core.types.stringLiteral(node.pattern), _core.types.stringLiteral(node.flags) ]));
          }
        }
      })));
      exports.default = _default;
    },
    4396: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)(((api, options) => {
        var _api$assumption, _api$assumption2;
        api.assertVersion(7);
        const ignoreToPrimitiveHint = null != (_api$assumption = api.assumption("ignoreToPrimitiveHint")) ? _api$assumption : options.loose, mutableTemplateObject = null != (_api$assumption2 = api.assumption("mutableTemplateObject")) ? _api$assumption2 : options.loose;
        let helperName = "taggedTemplateLiteral";
        return mutableTemplateObject && (helperName += "Loose"), {
          name: "transform-template-literals",
          visitor: {
            TaggedTemplateExpression(path) {
              const {node} = path, {quasi} = node, strings = [], raws = [];
              let isStringsRawEqual = !0;
              for (const elem of quasi.quasis) {
                const {raw, cooked} = elem.value, value = null == cooked ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
                strings.push(value), raws.push(_core.types.stringLiteral(raw)), raw !== cooked && (isStringsRawEqual = !1);
              }
              const helperArgs = [ _core.types.arrayExpression(strings) ];
              isStringsRawEqual || helperArgs.push(_core.types.arrayExpression(raws));
              const tmp = path.scope.generateUidIdentifier("templateObject");
              path.scope.getProgramParent().push({
                id: _core.types.cloneNode(tmp)
              }), path.replaceWith(_core.types.callExpression(node.tag, [ _core.template.expression.ast`
              ${_core.types.cloneNode(tmp)} || (
                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})
              )
            `, ...quasi.expressions ]));
            },
            TemplateLiteral(path) {
              const nodes = [], expressions = path.get("expressions");
              let index = 0;
              for (const elem of path.node.quasis) if (elem.value.cooked && nodes.push(_core.types.stringLiteral(elem.value.cooked)), 
              index < expressions.length) {
                const node = expressions[index++].node;
                _core.types.isStringLiteral(node, {
                  value: ""
                }) || nodes.push(node);
              }
              _core.types.isStringLiteral(nodes[0]) || ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]) || nodes.unshift(_core.types.stringLiteral(""));
              let root = nodes[0];
              if (ignoreToPrimitiveHint) for (let i = 1; i < nodes.length; i++) root = _core.types.binaryExpression("+", root, nodes[i]); else nodes.length > 1 && (root = function(items) {
                let avail = !0;
                return items.reduce((function(left, right) {
                  let canBeInserted = _core.types.isLiteral(right);
                  return !canBeInserted && avail && (canBeInserted = !0, avail = !1), canBeInserted && _core.types.isCallExpression(left) ? (left.arguments.push(right), 
                  left) : _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [ right ]);
                }));
              }(nodes));
              path.replaceWith(root);
            }
          }
        };
      }));
      exports.default = _default;
    },
    113: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => (api.assertVersion(7), {
        name: "transform-typeof-symbol",
        visitor: {
          Scope({scope}) {
            scope.getBinding("Symbol") && scope.rename("Symbol");
          },
          UnaryExpression(path) {
            const {node, parent} = path;
            if ("typeof" !== node.operator) return;
            if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
              const opposite = path.getOpposite();
              if (opposite.isLiteral() && "symbol" !== opposite.node.value && "object" !== opposite.node.value) return;
            }
            let isUnderHelper = path.findParent((path => {
              var _path$get;
              if (path.isFunction()) return "@babel/helpers - typeof" === (null == (_path$get = path.get("body.directives.0")) ? void 0 : _path$get.node.value.value);
            }));
            if (isUnderHelper) return;
            const helper = this.addHelper("typeof");
            if (isUnderHelper = path.findParent((path => path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name)), 
            isUnderHelper) return;
            const call = _core.types.callExpression(helper, [ node.argument ]), arg = path.get("argument");
            if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, !0)) {
              const unary = _core.types.unaryExpression("typeof", _core.types.cloneNode(node.argument));
              path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("===", unary, _core.types.stringLiteral("undefined")), _core.types.stringLiteral("undefined"), call));
            } else path.replaceWith(call);
          }
        }
      })));
      exports.default = _default;
    },
    8026: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperPluginUtils = __webpack_require__(4982), _core = __webpack_require__(4629), _default = (0, 
      _helperPluginUtils.declare)((api => {
        api.assertVersion(7);
        const surrogate = /[\ud800-\udfff]/g, unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;
        function escape(code) {
          let str = code.toString(16);
          for (;str.length < 4; ) str = "0" + str;
          return "\\u" + str;
        }
        function replacer(match, backslashes, code) {
          if (backslashes.length % 2 == 0) return match;
          const char = String.fromCodePoint(parseInt(code, 16)), escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));
          return 1 === char.length ? escaped : escaped + escape(char.charCodeAt(1));
        }
        function replaceUnicodeEscapes(str) {
          return str.replace(unicodeEscape, replacer);
        }
        return {
          name: "transform-unicode-escapes",
          manipulateOptions({generatorOpts}) {
            var _generatorOpts$jsescO;
            generatorOpts.jsescOption || (generatorOpts.jsescOption = {}), null != (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal || (_generatorOpts$jsescO.minimal = !1);
          },
          visitor: {
            Identifier(path) {
              const {node, key} = path, {name} = node, replaced = name.replace(surrogate, (c => `_u${c.charCodeAt(0).toString(16)}`));
              if (name === replaced) return;
              const str = _core.types.inherits(_core.types.stringLiteral(name), node);
              if ("key" === key) return void path.replaceWith(str);
              const {parentPath, scope} = path;
              if (parentPath.isMemberExpression({
                property: node
              }) || parentPath.isOptionalMemberExpression({
                property: node
              })) return parentPath.node.computed = !0, void path.replaceWith(str);
              if (!scope.getBinding(name)) throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);
              scope.rename(name, scope.generateUid(replaced));
            },
            "StringLiteral|DirectiveLiteral"(path) {
              const {node} = path, {extra} = node;
              null != extra && extra.raw && (extra.raw = replaceUnicodeEscapes(extra.raw));
            },
            TemplateElement(path) {
              const {node, parentPath} = path, {value} = node, firstEscape = function(str) {
                let match;
                for (;match = unicodeEscape.exec(str); ) if (match[1].length % 2 != 0) return unicodeEscape.lastIndex = 0, 
                match[0];
                return null;
              }(value.raw);
              if (!firstEscape) return;
              if (parentPath.parentPath.isTaggedTemplateExpression()) throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);
              value.raw = replaceUnicodeEscapes(value.raw);
            }
          }
        };
      }));
      exports.default = _default;
    },
    3890: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _helperCreateRegexpFeaturesPlugin = __webpack_require__(1357), _default = (0, 
      __webpack_require__(4982).declare)((api => (api.assertVersion(7), (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-unicode-regex",
        feature: "unicodeFlag"
      }))));
      exports.default = _default;
    },
    9279: module => {
      const proposalPlugins = new Set, pluginSyntaxObject = {
        "proposal-async-generator-functions": "syntax-async-generators",
        "proposal-class-properties": "syntax-class-properties",
        "proposal-class-static-block": "syntax-class-static-block",
        "proposal-json-strings": "syntax-json-strings",
        "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
        "proposal-numeric-separator": "syntax-numeric-separator",
        "proposal-object-rest-spread": "syntax-object-rest-spread",
        "proposal-optional-catch-binding": "syntax-optional-catch-binding",
        "proposal-optional-chaining": "syntax-optional-chaining",
        "proposal-private-methods": "syntax-class-properties",
        "proposal-private-property-in-object": "syntax-private-property-in-object",
        "proposal-unicode-property-regex": null
      }, pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map((function(key) {
        return [ key, pluginSyntaxObject[key] ];
      })), pluginSyntaxMap = new Map(pluginSyntaxEntries);
      module.exports = {
        pluginSyntaxMap,
        proposalPlugins
      };
    },
    2751: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.minVersions = exports.default = void 0;
      var _pluginSyntaxAsyncGenerators = __webpack_require__(894), _pluginSyntaxClassProperties = __webpack_require__(3876), _pluginSyntaxClassStaticBlock = __webpack_require__(7249), _pluginSyntaxDynamicImport = __webpack_require__(642), _pluginSyntaxExportNamespaceFrom = __webpack_require__(494), _pluginSyntaxJsonStrings = __webpack_require__(8775), _pluginSyntaxLogicalAssignmentOperators = __webpack_require__(399), _pluginSyntaxNullishCoalescingOperator = __webpack_require__(9338), _pluginSyntaxNumericSeparator = __webpack_require__(3594), _pluginSyntaxObjectRestSpread = __webpack_require__(7196), _pluginSyntaxOptionalCatchBinding = __webpack_require__(9312), _pluginSyntaxOptionalChaining = __webpack_require__(4852), _pluginSyntaxPrivatePropertyInObject = __webpack_require__(2611), _pluginSyntaxTopLevelAwait = __webpack_require__(7934), _pluginProposalAsyncGeneratorFunctions = __webpack_require__(1918), _pluginProposalClassProperties = __webpack_require__(5675), _pluginProposalClassStaticBlock = __webpack_require__(3884), _pluginProposalDynamicImport = __webpack_require__(4673), _pluginProposalExportNamespaceFrom = __webpack_require__(9295), _pluginProposalJsonStrings = __webpack_require__(797), _pluginProposalLogicalAssignmentOperators = __webpack_require__(566), _pluginProposalNullishCoalescingOperator = __webpack_require__(7595), _pluginProposalNumericSeparator = __webpack_require__(7635), _pluginProposalObjectRestSpread = __webpack_require__(3578), _pluginProposalOptionalCatchBinding = __webpack_require__(9318), _pluginProposalOptionalChaining = __webpack_require__(6288), _pluginProposalPrivateMethods = __webpack_require__(2191), _pluginProposalPrivatePropertyInObject = __webpack_require__(4008), _pluginProposalUnicodePropertyRegex = __webpack_require__(4759), _pluginTransformAsyncToGenerator = __webpack_require__(5897), _pluginTransformArrowFunctions = __webpack_require__(8339), _pluginTransformBlockScopedFunctions = __webpack_require__(3590), _pluginTransformBlockScoping = __webpack_require__(3115), _pluginTransformClasses = __webpack_require__(2535), _pluginTransformComputedProperties = __webpack_require__(7175), _pluginTransformDestructuring = __webpack_require__(8177), _pluginTransformDotallRegex = __webpack_require__(4410), _pluginTransformDuplicateKeys = __webpack_require__(8144), _pluginTransformExponentiationOperator = __webpack_require__(2488), _pluginTransformForOf = __webpack_require__(7149), _pluginTransformFunctionName = __webpack_require__(6042), _pluginTransformLiterals = __webpack_require__(8012), _pluginTransformMemberExpressionLiterals = __webpack_require__(3740), _pluginTransformModulesAmd = __webpack_require__(3152), _pluginTransformModulesCommonjs = __webpack_require__(2558), _pluginTransformModulesSystemjs = __webpack_require__(1089), _pluginTransformModulesUmd = __webpack_require__(7704), _pluginTransformNamedCapturingGroupsRegex = __webpack_require__(4790), _pluginTransformNewTarget = __webpack_require__(4023), _pluginTransformObjectSuper = __webpack_require__(8654), _pluginTransformParameters = __webpack_require__(9425), _pluginTransformPropertyLiterals = __webpack_require__(3176), _pluginTransformRegenerator = __webpack_require__(2210), _pluginTransformReservedWords = __webpack_require__(9400), _pluginTransformShorthandProperties = __webpack_require__(8347), _pluginTransformSpread = __webpack_require__(267), _pluginTransformStickyRegex = __webpack_require__(1827), _pluginTransformTemplateLiterals = __webpack_require__(4396), _pluginTransformTypeofSymbol = __webpack_require__(113), _pluginTransformUnicodeEscapes = __webpack_require__(8026), _pluginTransformUnicodeRegex = __webpack_require__(3890), _transformAsyncArrowsInClass = __webpack_require__(5196), _transformEdgeDefaultParameters = __webpack_require__(7592), _transformEdgeFunctionName = __webpack_require__(2777), _transformTaggedTemplateCaching = __webpack_require__(8895), _transformSafariBlockShadowing = __webpack_require__(7327), _transformSafariForShadowing = __webpack_require__(9271), _pluginBugfixSafariIdDestructuringCollisionInFunctionExpression = __webpack_require__(4979), _pluginBugfixV8SpreadParametersInOptionalChaining = __webpack_require__(2020), _default = {
        "bugfix/transform-async-arrows-in-class": () => _transformAsyncArrowsInClass,
        "bugfix/transform-edge-default-parameters": () => _transformEdgeDefaultParameters,
        "bugfix/transform-edge-function-name": () => _transformEdgeFunctionName,
        "bugfix/transform-safari-block-shadowing": () => _transformSafariBlockShadowing,
        "bugfix/transform-safari-for-shadowing": () => _transformSafariForShadowing,
        "bugfix/transform-safari-id-destructuring-collision-in-function-expression": () => _pluginBugfixSafariIdDestructuringCollisionInFunctionExpression.default,
        "bugfix/transform-tagged-template-caching": () => _transformTaggedTemplateCaching,
        "bugfix/transform-v8-spread-parameters-in-optional-chaining": () => _pluginBugfixV8SpreadParametersInOptionalChaining.default,
        "proposal-async-generator-functions": () => _pluginProposalAsyncGeneratorFunctions.default,
        "proposal-class-properties": () => _pluginProposalClassProperties.default,
        "proposal-class-static-block": () => _pluginProposalClassStaticBlock.default,
        "proposal-dynamic-import": () => _pluginProposalDynamicImport.default,
        "proposal-export-namespace-from": () => _pluginProposalExportNamespaceFrom.default,
        "proposal-json-strings": () => _pluginProposalJsonStrings.default,
        "proposal-logical-assignment-operators": () => _pluginProposalLogicalAssignmentOperators.default,
        "proposal-nullish-coalescing-operator": () => _pluginProposalNullishCoalescingOperator.default,
        "proposal-numeric-separator": () => _pluginProposalNumericSeparator.default,
        "proposal-object-rest-spread": () => _pluginProposalObjectRestSpread.default,
        "proposal-optional-catch-binding": () => _pluginProposalOptionalCatchBinding.default,
        "proposal-optional-chaining": () => _pluginProposalOptionalChaining.default,
        "proposal-private-methods": () => _pluginProposalPrivateMethods.default,
        "proposal-private-property-in-object": () => _pluginProposalPrivatePropertyInObject.default,
        "proposal-unicode-property-regex": () => _pluginProposalUnicodePropertyRegex.default,
        "syntax-async-generators": () => _pluginSyntaxAsyncGenerators,
        "syntax-class-properties": () => _pluginSyntaxClassProperties,
        "syntax-class-static-block": () => _pluginSyntaxClassStaticBlock,
        "syntax-dynamic-import": () => _pluginSyntaxDynamicImport,
        "syntax-export-namespace-from": () => _pluginSyntaxExportNamespaceFrom,
        "syntax-json-strings": () => _pluginSyntaxJsonStrings,
        "syntax-logical-assignment-operators": () => _pluginSyntaxLogicalAssignmentOperators,
        "syntax-nullish-coalescing-operator": () => _pluginSyntaxNullishCoalescingOperator,
        "syntax-numeric-separator": () => _pluginSyntaxNumericSeparator,
        "syntax-object-rest-spread": () => _pluginSyntaxObjectRestSpread,
        "syntax-optional-catch-binding": () => _pluginSyntaxOptionalCatchBinding,
        "syntax-optional-chaining": () => _pluginSyntaxOptionalChaining,
        "syntax-private-property-in-object": () => _pluginSyntaxPrivatePropertyInObject,
        "syntax-top-level-await": () => _pluginSyntaxTopLevelAwait,
        "transform-arrow-functions": () => _pluginTransformArrowFunctions.default,
        "transform-async-to-generator": () => _pluginTransformAsyncToGenerator.default,
        "transform-block-scoped-functions": () => _pluginTransformBlockScopedFunctions.default,
        "transform-block-scoping": () => _pluginTransformBlockScoping.default,
        "transform-classes": () => _pluginTransformClasses.default,
        "transform-computed-properties": () => _pluginTransformComputedProperties.default,
        "transform-destructuring": () => _pluginTransformDestructuring.default,
        "transform-dotall-regex": () => _pluginTransformDotallRegex.default,
        "transform-duplicate-keys": () => _pluginTransformDuplicateKeys.default,
        "transform-exponentiation-operator": () => _pluginTransformExponentiationOperator.default,
        "transform-for-of": () => _pluginTransformForOf.default,
        "transform-function-name": () => _pluginTransformFunctionName.default,
        "transform-literals": () => _pluginTransformLiterals.default,
        "transform-member-expression-literals": () => _pluginTransformMemberExpressionLiterals.default,
        "transform-modules-amd": () => _pluginTransformModulesAmd.default,
        "transform-modules-commonjs": () => _pluginTransformModulesCommonjs.default,
        "transform-modules-systemjs": () => _pluginTransformModulesSystemjs.default,
        "transform-modules-umd": () => _pluginTransformModulesUmd.default,
        "transform-named-capturing-groups-regex": () => _pluginTransformNamedCapturingGroupsRegex.default,
        "transform-new-target": () => _pluginTransformNewTarget.default,
        "transform-object-super": () => _pluginTransformObjectSuper.default,
        "transform-parameters": () => _pluginTransformParameters.default,
        "transform-property-literals": () => _pluginTransformPropertyLiterals.default,
        "transform-regenerator": () => _pluginTransformRegenerator.default,
        "transform-reserved-words": () => _pluginTransformReservedWords.default,
        "transform-shorthand-properties": () => _pluginTransformShorthandProperties.default,
        "transform-spread": () => _pluginTransformSpread.default,
        "transform-sticky-regex": () => _pluginTransformStickyRegex.default,
        "transform-template-literals": () => _pluginTransformTemplateLiterals.default,
        "transform-typeof-symbol": () => _pluginTransformTypeofSymbol.default,
        "transform-unicode-escapes": () => _pluginTransformUnicodeEscapes.default,
        "transform-unicode-regex": () => _pluginTransformUnicodeRegex.default
      };
      exports.default = _default;
      exports.minVersions = {
        "bugfix/transform-safari-id-destructuring-collision-in-function-expression": "7.16.0",
        "proposal-class-static-block": "7.12.0",
        "proposal-private-property-in-object": "7.10.0"
      };
    },
    2157: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.logPlugin = void 0;
      var _helperCompilationTargets = __webpack_require__(4077);
      exports.logPlugin = (item, targetVersions, list) => {
        const filteredList = (0, _helperCompilationTargets.getInclusionReasons)(item, targetVersions, list), support = list[item];
        if (!support) return void console.log(`  ${item}`);
        let formattedTargets = "{", first = !0;
        for (const target of Object.keys(filteredList)) first || (formattedTargets += ","), 
        first = !1, formattedTargets += ` ${target}`, support[target] && (formattedTargets += ` < ${support[target]}`);
        formattedTargets += " }", console.log(`  ${item} ${formattedTargets}`);
      };
    },
    8502: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.removeUnnecessaryItems = function(items, overlapping) {
        items.forEach((item => {
          var _overlapping$item;
          null == (_overlapping$item = overlapping[item]) || _overlapping$item.forEach((name => items.delete(name)));
        }));
      }, exports.removeUnsupportedItems = function(items, babelVersion) {
        items.forEach((item => {
          has(_availablePlugins.minVersions, item) && (0, _semver.lt)(babelVersion, _availablePlugins.minVersions[item]) && items.delete(item);
        }));
      };
      var _semver = __webpack_require__(6625), _availablePlugins = __webpack_require__(2751);
      const has = Function.call.bind(Object.hasOwnProperty);
    },
    6015: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function({loose}) {
        return loose ? defaultExcludesForLooseMode : null;
      };
      const defaultExcludesForLooseMode = [ "transform-typeof-symbol" ];
    },
    1049: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      exports.default = {
        auto: "transform-modules-commonjs",
        amd: "transform-modules-amd",
        commonjs: "transform-modules-commonjs",
        cjs: "transform-modules-commonjs",
        systemjs: "transform-modules-systemjs",
        umd: "transform-modules-umd"
      };
    },
    3668: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.checkDuplicateIncludeExcludes = void 0, exports.default = function(opts) {
        v.validateTopLevelOptions(opts, _options.TopLevelOptions);
        const useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns), corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns), include = expandIncludesAndExcludes(opts.include, _options.TopLevelOptions.include, !!corejs.version && corejs.version.major), exclude = expandIncludesAndExcludes(opts.exclude, _options.TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
        return checkDuplicateIncludeExcludes(include, exclude), {
          bugfixes: v.validateBooleanOption(_options.TopLevelOptions.bugfixes, opts.bugfixes, !1),
          configPath: v.validateStringOption(_options.TopLevelOptions.configPath, opts.configPath, process.cwd()),
          corejs,
          debug: v.validateBooleanOption(_options.TopLevelOptions.debug, opts.debug, !1),
          include,
          exclude,
          forceAllTransforms: v.validateBooleanOption(_options.TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, !1),
          ignoreBrowserslistConfig: v.validateBooleanOption(_options.TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, !1),
          loose: v.validateBooleanOption(_options.TopLevelOptions.loose, opts.loose),
          modules: validateModulesOption(opts.modules),
          shippedProposals: v.validateBooleanOption(_options.TopLevelOptions.shippedProposals, opts.shippedProposals, !1),
          spec: v.validateBooleanOption(_options.TopLevelOptions.spec, opts.spec, !1),
          targets: normalizeTargets(opts.targets),
          useBuiltIns,
          browserslistEnv: v.validateStringOption(_options.TopLevelOptions.browserslistEnv, opts.browserslistEnv)
        };
      }, exports.normalizeCoreJSOption = normalizeCoreJSOption, exports.validateUseBuiltInsOption = exports.validateModulesOption = exports.normalizePluginName = void 0;
      var _data = __webpack_require__(6578), _semver = __webpack_require__(6625), _corejs2BuiltIns = __webpack_require__(9797), _pluginsCompatData = __webpack_require__(4600), _moduleTransformations = __webpack_require__(1049), _options = __webpack_require__(2524), _helperValidatorOption = __webpack_require__(4346);
      const corejs2DefaultWebIncludes = [ "web.timers", "web.immediate", "web.dom.iterable" ], v = new _helperValidatorOption.OptionValidator("@babel/preset-env"), allPluginsList = Object.keys(_pluginsCompatData.plugins), modulePlugins = [ "proposal-dynamic-import", ...Object.keys(_moduleTransformations.default).map((m => _moduleTransformations.default[m])) ], selectPlugins = (regexp, type, corejs) => Array.from(((type, corejs) => new Set([ ...allPluginsList, ..."exclude" === type ? modulePlugins : [], ...corejs ? 2 == corejs ? [ ...Object.keys(_corejs2BuiltIns), ...corejs2DefaultWebIncludes ] : Object.keys(_data) : [] ]))(type, corejs)).filter((item => regexp instanceof RegExp && regexp.test(item))), expandIncludesAndExcludes = (plugins = [], type, corejs) => {
        if (0 === plugins.length) return [];
        const selectedPlugins = plugins.map((plugin => selectPlugins((plugin => {
          if (plugin instanceof RegExp) return plugin;
          try {
            return new RegExp(`^${normalizePluginName(plugin)}$`);
          } catch (e) {
            return null;
          }
        })(plugin), type, corejs))), invalidRegExpList = plugins.filter(((p, i) => 0 === selectedPlugins[i].length));
        return v.invariant(0 === invalidRegExpList.length, `The plugins/built-ins '${invalidRegExpList.join(", ")}' passed to the '${type}' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`), 
        array = selectedPlugins, [].concat(...array);
        var array;
      }, normalizePluginName = plugin => plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
      exports.normalizePluginName = normalizePluginName;
      const checkDuplicateIncludeExcludes = (include = [], exclude = []) => {
        const duplicates = include.filter((opt => exclude.indexOf(opt) >= 0));
        v.invariant(0 === duplicates.length, `The plugins/built-ins '${duplicates.join(", ")}' were found in both the "include" and\n    "exclude" options.`);
      };
      exports.checkDuplicateIncludeExcludes = checkDuplicateIncludeExcludes;
      const normalizeTargets = targets => "string" == typeof targets || Array.isArray(targets) ? {
        browsers: targets
      } : Object.assign({}, targets), validateModulesOption = (modulesOpt = _options.ModulesOption.auto) => (v.invariant(_options.ModulesOption[modulesOpt.toString()] || modulesOpt === _options.ModulesOption.false, "The 'modules' option must be one of \n - 'false' to indicate no module processing\n - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs' - 'auto' (default) which will automatically select 'false' if the current\n   process is known to support ES module syntax, or \"commonjs\" otherwise\n"), 
      modulesOpt);
      exports.validateModulesOption = validateModulesOption;
      const validateUseBuiltInsOption = (builtInsOpt = !1) => (v.invariant(_options.UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === _options.UseBuiltInsOption.false, "The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file"), 
      builtInsOpt);
      function normalizeCoreJSOption(corejs, useBuiltIns) {
        let rawVersion, proposals = !1;
        useBuiltIns && void 0 === corejs ? (rawVersion = 2, console.warn("\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.\n\nYou should also be sure that the version you pass to the `corejs` option matches the version specified in your `package.json`'s `dependencies` section. If it doesn't, you need to run one of the following commands:\n\n  npm install --save core-js@2    npm install --save core-js@3\n  yarn add core-js@2              yarn add core-js@3\n\nMore info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\nMore info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs")) : "object" == typeof corejs && null !== corejs ? (rawVersion = corejs.version, 
        proposals = Boolean(corejs.proposals)) : rawVersion = corejs;
        const version = !!rawVersion && (0, _semver.coerce)(String(rawVersion));
        if (!useBuiltIns && version && console.warn("\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n"), 
        useBuiltIns && (!version || version.major < 2 || version.major > 3)) throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, only core-js@2 and core-js@3 are supported.");
        return {
          version,
          proposals
        };
      }
      exports.validateUseBuiltInsOption = validateUseBuiltInsOption;
    },
    2524: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.UseBuiltInsOption = exports.TopLevelOptions = exports.ModulesOption = void 0;
      exports.TopLevelOptions = {
        bugfixes: "bugfixes",
        configPath: "configPath",
        corejs: "corejs",
        debug: "debug",
        exclude: "exclude",
        forceAllTransforms: "forceAllTransforms",
        ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
        include: "include",
        loose: "loose",
        modules: "modules",
        shippedProposals: "shippedProposals",
        spec: "spec",
        targets: "targets",
        useBuiltIns: "useBuiltIns",
        browserslistEnv: "browserslistEnv"
      };
      exports.ModulesOption = {
        false: !1,
        auto: "auto",
        amd: "amd",
        commonjs: "commonjs",
        cjs: "cjs",
        systemjs: "systemjs",
        umd: "umd"
      };
      exports.UseBuiltInsOption = {
        false: !1,
        entry: "entry",
        usage: "usage"
      };
    },
    4600: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.pluginsBugfixes = exports.plugins = void 0;
      var _plugins = __webpack_require__(4832), _pluginBugfixes = __webpack_require__(772), _availablePlugins = __webpack_require__(2751);
      const pluginsFiltered = {};
      exports.plugins = pluginsFiltered;
      const bugfixPluginsFiltered = {};
      exports.pluginsBugfixes = bugfixPluginsFiltered;
      for (const plugin of Object.keys(_plugins)) Object.hasOwnProperty.call(_availablePlugins.default, plugin) && (pluginsFiltered[plugin] = _plugins[plugin]);
      for (const plugin of Object.keys(_pluginBugfixes)) Object.hasOwnProperty.call(_availablePlugins.default, plugin) && (bugfixPluginsFiltered[plugin] = _pluginBugfixes[plugin]);
    },
    9462: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function({template}, {regenerator, deprecated, usage}) {
        return {
          name: "preset-env/replace-babel-polyfill",
          visitor: {
            ImportDeclaration(path) {
              const src = (0, _utils.getImportSource)(path);
              usage && (0, _utils.isPolyfillSource)(src) ? (console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src)), 
              deprecated || path.remove()) : "@babel/polyfill" === src && (deprecated ? console.warn(BABEL_POLYFILL_DEPRECATION) : regenerator ? path.replaceWithMultiple(template.ast`
              import "core-js";
              import "regenerator-runtime/runtime.js";
            `) : path.replaceWith(template.ast`
              import "core-js";
            `));
            },
            Program(path) {
              path.get("body").forEach((bodyPath => {
                const src = (0, _utils.getRequireSource)(bodyPath);
                usage && (0, _utils.isPolyfillSource)(src) ? (console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src)), 
                deprecated || bodyPath.remove()) : "@babel/polyfill" === src && (deprecated ? console.warn(BABEL_POLYFILL_DEPRECATION) : regenerator ? bodyPath.replaceWithMultiple(template.ast`
                require("core-js");
                require("regenerator-runtime/runtime.js");
              `) : bodyPath.replaceWith(template.ast`
                require("core-js");
              `));
              }));
            }
          }
        };
      };
      var _utils = __webpack_require__(8474);
      const BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately", NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `SPECIFIER` or use `useBuiltIns: 'entry'` instead.";
    },
    3893: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function() {
        return {
          name: "preset-env/remove-regenerator",
          visitor: {
            ImportDeclaration(path) {
              isRegeneratorSource((0, _utils.getImportSource)(path)) && (this.regeneratorImportExcluded = !0, 
              path.remove());
            },
            Program(path) {
              path.get("body").forEach((bodyPath => {
                isRegeneratorSource((0, _utils.getRequireSource)(bodyPath)) && (this.regeneratorImportExcluded = !0, 
                bodyPath.remove());
              }));
            }
          },
          pre() {
            this.regeneratorImportExcluded = !1;
          },
          post() {
            if (this.opts.debug && this.regeneratorImportExcluded) {
              let filename = this.file.opts.filename;
              "test" === process.env.BABEL_ENV && (filename = filename.replace(/\\/g, "/")), console.log(`\n[${filename}] Based on your targets, regenerator-runtime import excluded.`);
            }
          }
        };
      };
      var _utils = __webpack_require__(8474);
      function isRegeneratorSource(source) {
        return "regenerator-runtime/runtime" === source || "regenerator-runtime/runtime.js" === source;
      }
    },
    8474: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.getImportSource = function({node}) {
        if (0 === node.specifiers.length) return node.source.value;
      }, exports.getRequireSource = function({node}) {
        if (!isExpressionStatement(node)) return;
        const {expression} = node;
        if (isCallExpression(expression) && isIdentifier(expression.callee) && "require" === expression.callee.name && 1 === expression.arguments.length && isStringLiteral(expression.arguments[0])) return expression.arguments[0].value;
      }, exports.isPolyfillSource = function(source) {
        return "@babel/polyfill" === source || "core-js" === source;
      };
      var _t = __webpack_require__(8218);
      const {isCallExpression, isExpressionStatement, isIdentifier, isStringLiteral} = _t;
    },
    5196: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      const OPTS = {
        allowInsertArrow: !1,
        specCompliant: !1
      };
      exports.default = ({types: t}) => ({
        name: "transform-async-arrows-in-class",
        visitor: {
          ArrowFunctionExpression(path) {
            path.node.async && path.findParent(t.isClassMethod) && path.arrowFunctionToExpression(OPTS);
          }
        }
      }), module.exports = exports.default;
    },
    7592: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      exports.default = ({types: t}) => {
        const isArrowParent = p => "params" === p.parentKey && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
        return {
          name: "transform-edge-default-parameters",
          visitor: {
            AssignmentPattern(path) {
              path.find(isArrowParent) && path.parent.shorthand && (path.parent.shorthand = !1, 
              (path.parent.extra || {}).shorthand = !1, path.scope.rename(path.parent.key.name));
            }
          }
        };
      }, module.exports = exports.default;
    },
    2777: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      exports.default = ({types: t}) => ({
        name: "transform-edge-function-name",
        visitor: {
          FunctionExpression: {
            exit(path) {
              if (!path.node.id && t.isIdentifier(path.parent.id)) {
                const id = t.cloneNode(path.parent.id), binding = path.scope.getBinding(id.name);
                (null == binding ? void 0 : binding.constantViolations.length) && path.scope.rename(id.name), 
                path.node.id = id;
              }
            }
          }
        }
      }), module.exports = exports.default;
    },
    7327: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = function({types: t}) {
        return {
          name: "transform-safari-block-shadowing",
          visitor: {
            VariableDeclarator(path) {
              const kind = path.parent.kind;
              if ("let" !== kind && "const" !== kind) return;
              const block = path.scope.block;
              if (t.isFunction(block) || t.isProgram(block)) return;
              const bindings = t.getOuterBindingIdentifiers(path.node.id);
              for (const name of Object.keys(bindings)) {
                let scope = path.scope;
                if (scope.hasOwnBinding(name)) for (;scope = scope.parent; ) {
                  if (scope.hasOwnBinding(name)) {
                    path.scope.rename(name);
                    break;
                  }
                  if (t.isFunction(scope.block) || t.isProgram(scope.block)) break;
                }
              }
            }
          }
        };
      }, module.exports = exports.default;
    },
    9271: (module, exports) => {
      "use strict";
      function handle(declaration) {
        if (!declaration.isVariableDeclaration()) return;
        const fn = declaration.getFunctionParent(), {name} = declaration.node.declarations[0].id;
        fn && fn.scope.hasOwnBinding(name) && "param" === fn.scope.getOwnBinding(name).kind && declaration.scope.rename(name);
      }
      exports.__esModule = !0, exports.default = void 0;
      exports.default = () => ({
        name: "transform-safari-for-shadowing",
        visitor: {
          ForXStatement(path) {
            handle(path.get("left"));
          },
          ForStatement(path) {
            handle(path.get("init"));
          }
        }
      }), module.exports = exports.default;
    },
    8895: (module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      exports.default = ({types: t}) => ({
        name: "transform-tagged-template-caching",
        visitor: {
          TaggedTemplateExpression(path, state) {
            let processed = state.get("processed");
            if (processed || (processed = new WeakSet, state.set("processed", processed)), processed.has(path.node)) return path.skip();
            const expressions = path.node.quasi.expressions;
            let identity = state.get("identity");
            if (!identity) {
              identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_"), state.set("identity", identity);
              path.scope.getBinding(identity.name).path.get("init").replaceWith(t.arrowFunctionExpression([ t.identifier("t") ], t.identifier("t")));
            }
            const template = t.taggedTemplateExpression(t.cloneNode(identity), t.templateLiteral(path.node.quasi.quasis, expressions.map((() => t.numericLiteral(0)))));
            processed.add(template);
            const ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
            path.scope.getBinding(ident.name).path.parent.kind = "let";
            const inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", t.cloneNode(ident), template)), node = t.callExpression(path.node.tag, [ inlineCache, ...expressions ]);
            path.replaceWith(node);
          }
        }
      }), module.exports = exports.default;
    },
    5318: module => {
      module.exports = function(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }, module.exports.__esModule = !0, module.exports.default = module.exports;
    },
    9007: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function createTemplateBuilder(formatter, defaultOpts) {
        const templateFnCache = new WeakMap, templateAstCache = new WeakMap, cachedOpts = defaultOpts || (0, 
        _options.validate)(null);
        return Object.assign(((tpl, ...args) => {
          if ("string" == typeof tpl) {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, 
            _options.validate)(args[0]))));
          }
          if (Array.isArray(tpl)) {
            let builder = templateFnCache.get(tpl);
            return builder || (builder = (0, _literal.default)(formatter, tpl, cachedOpts), 
            templateFnCache.set(tpl, builder)), extendedTrace(builder(args));
          }
          if ("object" == typeof tpl && tpl) {
            if (args.length > 0) throw new Error("Unexpected extra params.");
            return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
          }
          throw new Error("Unexpected template param " + typeof tpl);
        }), {
          ast: (tpl, ...args) => {
            if ("string" == typeof tpl) {
              if (args.length > 1) throw new Error("Unexpected extra params.");
              return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, 
              _options.validate)(args[0])), NO_PLACEHOLDER))();
            }
            if (Array.isArray(tpl)) {
              let builder = templateAstCache.get(tpl);
              return builder || (builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER)), 
              templateAstCache.set(tpl, builder)), builder(args)();
            }
            throw new Error("Unexpected template param " + typeof tpl);
          }
        });
      };
      var _options = __webpack_require__(698), _string = __webpack_require__(4515), _literal = __webpack_require__(9948);
      const NO_PLACEHOLDER = (0, _options.validate)({
        placeholderPattern: !1
      });
      function extendedTrace(fn) {
        let rootStack = "";
        try {
          throw new Error;
        } catch (error) {
          error.stack && (rootStack = error.stack.split("\n").slice(3).join("\n"));
        }
        return arg => {
          try {
            return fn(arg);
          } catch (err) {
            throw err.stack += `\n    =============\n${rootStack}`, err;
          }
        };
      }
    },
    1522: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
      var _t = __webpack_require__(8218);
      const {assertExpressionStatement} = _t;
      function makeStatementFormatter(fn) {
        return {
          code: str => `/* @babel/template */;\n${str}`,
          validate: () => {},
          unwrap: ast => fn(ast.program.body.slice(1))
        };
      }
      const smart = makeStatementFormatter((body => body.length > 1 ? body : body[0]));
      exports.smart = smart;
      const statements = makeStatementFormatter((body => body));
      exports.statements = statements;
      const statement = makeStatementFormatter((body => {
        if (0 === body.length) throw new Error("Found nothing to return.");
        if (body.length > 1) throw new Error("Found multiple statements but wanted one");
        return body[0];
      }));
      exports.statement = statement;
      const expression = {
        code: str => `(\n${str}\n)`,
        validate: ast => {
          if (ast.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
          if (0 === expression.unwrap(ast).start) throw new Error("Parse result included parens.");
        },
        unwrap: ({program}) => {
          const [stmt] = program.body;
          return assertExpressionStatement(stmt), stmt.expression;
        }
      };
      exports.expression = expression;
      exports.program = {
        code: str => str,
        validate: () => {},
        unwrap: ast => ast.program
      };
    },
    4847: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = void 0;
      var formatters = __webpack_require__(1522), _builder = __webpack_require__(9007);
      const smart = (0, _builder.default)(formatters.smart);
      exports.smart = smart;
      const statement = (0, _builder.default)(formatters.statement);
      exports.statement = statement;
      const statements = (0, _builder.default)(formatters.statements);
      exports.statements = statements;
      const expression = (0, _builder.default)(formatters.expression);
      exports.expression = expression;
      const program = (0, _builder.default)(formatters.program);
      exports.program = program;
      var _default = Object.assign(smart.bind(void 0), {
        smart,
        statement,
        statements,
        expression,
        program,
        ast: smart.ast
      });
      exports.default = _default;
    },
    9948: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(formatter, tpl, opts) {
        const {metadata, names} = function(formatter, tpl, opts) {
          let names, nameSet, metadata, prefix = "";
          do {
            prefix += "$";
            const result = buildTemplateCode(tpl, prefix);
            names = result.names, nameSet = new Set(names), metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
              parser: opts.parser,
              placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
              placeholderPattern: opts.placeholderPattern,
              preserveComments: opts.preserveComments,
              syntacticPlaceholders: opts.syntacticPlaceholders
            });
          } while (metadata.placeholders.some((placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name))));
          return {
            metadata,
            names
          };
        }(formatter, tpl, opts);
        return arg => {
          const defaultReplacements = {};
          return arg.forEach(((replacement, i) => {
            defaultReplacements[names[i]] = replacement;
          })), arg => {
            const replacements = (0, _options.normalizeReplacements)(arg);
            return replacements && Object.keys(replacements).forEach((key => {
              if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) throw new Error("Unexpected replacement overlap.");
            })), formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
          };
        };
      };
      var _options = __webpack_require__(698), _parse = __webpack_require__(5672), _populate = __webpack_require__(1969);
      function buildTemplateCode(tpl, prefix) {
        const names = [];
        let code = tpl[0];
        for (let i = 1; i < tpl.length; i++) {
          const value = `${prefix}${i - 1}`;
          names.push(value), code += value + tpl[i];
        }
        return {
          names,
          code
        };
      }
    },
    698: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.merge = function(a, b) {
        const {placeholderWhitelist = a.placeholderWhitelist, placeholderPattern = a.placeholderPattern, preserveComments = a.preserveComments, syntacticPlaceholders = a.syntacticPlaceholders} = b;
        return {
          parser: Object.assign({}, a.parser, b.parser),
          placeholderWhitelist,
          placeholderPattern,
          preserveComments,
          syntacticPlaceholders
        };
      }, exports.normalizeReplacements = function(replacements) {
        if (Array.isArray(replacements)) return replacements.reduce(((acc, replacement, i) => (acc["$" + i] = replacement, 
        acc)), {});
        if ("object" == typeof replacements || null == replacements) return replacements || void 0;
        throw new Error("Template replacements must be an array, object, null, or undefined");
      }, exports.validate = function(opts) {
        if (null != opts && "object" != typeof opts) throw new Error("Unknown template options.");
        const _ref = opts || {}, {placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders} = _ref, parser = function(source, excluded) {
          if (null == source) return {};
          var key, i, target = {}, sourceKeys = Object.keys(source);
          for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
          return target;
        }(_ref, _excluded);
        if (null != placeholderWhitelist && !(placeholderWhitelist instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
        if (null != placeholderPattern && !(placeholderPattern instanceof RegExp) && !1 !== placeholderPattern) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
        if (null != preserveComments && "boolean" != typeof preserveComments) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
        if (null != syntacticPlaceholders && "boolean" != typeof syntacticPlaceholders) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
        if (!0 === syntacticPlaceholders && (null != placeholderWhitelist || null != placeholderPattern)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        return {
          parser,
          placeholderWhitelist: placeholderWhitelist || void 0,
          placeholderPattern: null == placeholderPattern ? void 0 : placeholderPattern,
          preserveComments: null == preserveComments ? void 0 : preserveComments,
          syntacticPlaceholders: null == syntacticPlaceholders ? void 0 : syntacticPlaceholders
        };
      };
      const _excluded = [ "placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders" ];
    },
    5672: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(formatter, code, opts) {
        const {placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders} = opts, ast = function(code, parserOpts, syntacticPlaceholders) {
          const plugins = (parserOpts.plugins || []).slice();
          !1 !== syntacticPlaceholders && plugins.push("placeholders");
          parserOpts = Object.assign({
            allowReturnOutsideFunction: !0,
            allowSuperOutsideMethod: !0,
            sourceType: "module"
          }, parserOpts, {
            plugins
          });
          try {
            return (0, _parser.parse)(code, parserOpts);
          } catch (err) {
            const loc = err.loc;
            throw loc && (err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
              start: loc
            }), err.code = "BABEL_TEMPLATE_PARSE_ERROR"), err;
          }
        }(code, opts.parser, syntacticPlaceholders);
        removePropertiesDeep(ast, {
          preserveComments
        }), formatter.validate(ast);
        const syntactic = {
          placeholders: [],
          placeholderNames: new Set
        }, legacy = {
          placeholders: [],
          placeholderNames: new Set
        }, isLegacyRef = {
          value: void 0
        };
        return traverse(ast, placeholderVisitorHandler, {
          syntactic,
          legacy,
          isLegacyRef,
          placeholderWhitelist,
          placeholderPattern,
          syntacticPlaceholders
        }), Object.assign({
          ast
        }, isLegacyRef.value ? legacy : syntactic);
      };
      var _t = __webpack_require__(8218), _parser = __webpack_require__(3834), _codeFrame = __webpack_require__(4709);
      const {isCallExpression, isExpressionStatement, isFunction, isIdentifier, isJSXIdentifier, isNewExpression, isPlaceholder, isStatement, isStringLiteral, removePropertiesDeep, traverse} = _t, PATTERN = /^[_$A-Z0-9]+$/;
      function placeholderVisitorHandler(node, ancestors, state) {
        var _state$placeholderWhi;
        let name;
        if (isPlaceholder(node)) {
          if (!1 === state.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
          name = node.name.name, state.isLegacyRef.value = !1;
        } else {
          if (!1 === state.isLegacyRef.value || state.syntacticPlaceholders) return;
          if (isIdentifier(node) || isJSXIdentifier(node)) name = node.name, state.isLegacyRef.value = !0; else {
            if (!isStringLiteral(node)) return;
            name = node.value, state.isLegacyRef.value = !0;
          }
        }
        if (!state.isLegacyRef.value && (null != state.placeholderPattern || null != state.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
        if (state.isLegacyRef.value && (!1 === state.placeholderPattern || !(state.placeholderPattern || PATTERN).test(name)) && (null == (_state$placeholderWhi = state.placeholderWhitelist) || !_state$placeholderWhi.has(name))) return;
        ancestors = ancestors.slice();
        const {node: parent, key} = ancestors[ancestors.length - 1];
        let type;
        isStringLiteral(node) || isPlaceholder(node, {
          expectedNode: "StringLiteral"
        }) ? type = "string" : isNewExpression(parent) && "arguments" === key || isCallExpression(parent) && "arguments" === key || isFunction(parent) && "params" === key ? type = "param" : isExpressionStatement(parent) && !isPlaceholder(node) ? (type = "statement", 
        ancestors = ancestors.slice(0, -1)) : type = isStatement(node) && isPlaceholder(node) ? "statement" : "other";
        const {placeholders, placeholderNames} = state.isLegacyRef.value ? state.legacy : state.syntactic;
        placeholders.push({
          name,
          type,
          resolve: ast => function(ast, ancestors) {
            let parent = ast;
            for (let i = 0; i < ancestors.length - 1; i++) {
              const {key, index} = ancestors[i];
              parent = void 0 === index ? parent[key] : parent[key][index];
            }
            const {key, index} = ancestors[ancestors.length - 1];
            return {
              parent,
              key,
              index
            };
          }(ast, ancestors),
          isDuplicate: placeholderNames.has(name)
        }), placeholderNames.add(name);
      }
    },
    1969: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(metadata, replacements) {
        const ast = cloneNode(metadata.ast);
        replacements && (metadata.placeholders.forEach((placeholder => {
          if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
            const placeholderName = placeholder.name;
            throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`);
          }
        })), Object.keys(replacements).forEach((key => {
          if (!metadata.placeholderNames.has(key)) throw new Error(`Unknown substitution "${key}" given`);
        })));
        return metadata.placeholders.slice().reverse().forEach((placeholder => {
          try {
            !function(placeholder, ast, replacement) {
              placeholder.isDuplicate && (Array.isArray(replacement) ? replacement = replacement.map((node => cloneNode(node))) : "object" == typeof replacement && (replacement = cloneNode(replacement)));
              const {parent, key, index} = placeholder.resolve(ast);
              if ("string" === placeholder.type) {
                if ("string" == typeof replacement && (replacement = stringLiteral(replacement)), 
                !replacement || !isStringLiteral(replacement)) throw new Error("Expected string substitution");
              } else if ("statement" === placeholder.type) void 0 === index ? replacement ? Array.isArray(replacement) ? replacement = blockStatement(replacement) : "string" == typeof replacement ? replacement = expressionStatement(identifier(replacement)) : isStatement(replacement) || (replacement = expressionStatement(replacement)) : replacement = emptyStatement() : replacement && !Array.isArray(replacement) && ("string" == typeof replacement && (replacement = identifier(replacement)), 
              isStatement(replacement) || (replacement = expressionStatement(replacement))); else if ("param" === placeholder.type) {
                if ("string" == typeof replacement && (replacement = identifier(replacement)), void 0 === index) throw new Error("Assertion failure.");
              } else if ("string" == typeof replacement && (replacement = identifier(replacement)), 
              Array.isArray(replacement)) throw new Error("Cannot replace single expression with an array.");
              if (void 0 === index) validate(parent, key, replacement), parent[key] = replacement; else {
                const items = parent[key].slice();
                "statement" === placeholder.type || "param" === placeholder.type ? null == replacement ? items.splice(index, 1) : Array.isArray(replacement) ? items.splice(index, 1, ...replacement) : items[index] = replacement : items[index] = replacement, 
                validate(parent, key, items), parent[key] = items;
              }
            }(placeholder, ast, replacements && replacements[placeholder.name] || null);
          } catch (e) {
            throw e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`, 
            e;
          }
        })), ast;
      };
      var _t = __webpack_require__(8218);
      const {blockStatement, cloneNode, emptyStatement, expressionStatement, identifier, isStatement, isStringLiteral, stringLiteral, validate} = _t;
    },
    4515: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(formatter, code, opts) {
        let metadata;
        return code = formatter.code(code), arg => {
          const replacements = (0, _options.normalizeReplacements)(arg);
          return metadata || (metadata = (0, _parse.default)(formatter, code, opts)), formatter.unwrap((0, 
          _populate.default)(metadata, replacements));
        };
      };
      var _options = __webpack_require__(698), _parse = __webpack_require__(5672), _populate = __webpack_require__(1969);
    },
    732: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.clear = function() {
        clearPath(), clearScope();
      }, exports.clearPath = clearPath, exports.clearScope = clearScope, exports.scope = exports.path = void 0;
      let path = new WeakMap;
      exports.path = path;
      let scope = new WeakMap;
      function clearPath() {
        exports.path = path = new WeakMap;
      }
      function clearScope() {
        exports.scope = scope = new WeakMap;
      }
      exports.scope = scope;
    },
    6617: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _path = __webpack_require__(2969), _t = __webpack_require__(8218);
      const {VISITOR_KEYS} = _t;
      exports.default = class {
        constructor(scope, opts, state, parentPath) {
          this.queue = null, this.priorityQueue = null, this.parentPath = parentPath, this.scope = scope, 
          this.state = state, this.opts = opts;
        }
        shouldVisit(node) {
          const opts = this.opts;
          if (opts.enter || opts.exit) return !0;
          if (opts[node.type]) return !0;
          const keys = VISITOR_KEYS[node.type];
          if (null == keys || !keys.length) return !1;
          for (const key of keys) if (node[key]) return !0;
          return !1;
        }
        create(node, obj, key, listKey) {
          return _path.default.get({
            parentPath: this.parentPath,
            parent: node,
            container: obj,
            key,
            listKey
          });
        }
        maybeQueue(path, notPriority) {
          this.queue && (notPriority ? this.queue.push(path) : this.priorityQueue.push(path));
        }
        visitMultiple(container, parent, listKey) {
          if (0 === container.length) return !1;
          const queue = [];
          for (let key = 0; key < container.length; key++) {
            const node = container[key];
            node && this.shouldVisit(node) && queue.push(this.create(parent, container, key, listKey));
          }
          return this.visitQueue(queue);
        }
        visitSingle(node, key) {
          return !!this.shouldVisit(node[key]) && this.visitQueue([ this.create(node, node, key) ]);
        }
        visitQueue(queue) {
          this.queue = queue, this.priorityQueue = [];
          const visited = new WeakSet;
          let stop = !1;
          for (const path of queue) {
            if (path.resync(), 0 !== path.contexts.length && path.contexts[path.contexts.length - 1] === this || path.pushContext(this), 
            null === path.key) continue;
            const {node} = path;
            if (!visited.has(node)) {
              if (node && visited.add(node), path.visit()) {
                stop = !0;
                break;
              }
              if (this.priorityQueue.length && (stop = this.visitQueue(this.priorityQueue), this.priorityQueue = [], 
              this.queue = queue, stop)) break;
            }
          }
          for (const path of queue) path.popContext();
          return this.queue = null, stop;
        }
        visit(node, key) {
          const nodes = node[key];
          return !!nodes && (Array.isArray(nodes) ? this.visitMultiple(nodes, node, key) : this.visitSingle(node, key));
        }
      };
    },
    2180: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      exports.default = class {
        getCode() {}
        getScope() {}
        addHelper() {
          throw new Error("Helpers are not supported by the default hub.");
        }
        buildError(node, msg, Error = TypeError) {
          return new Error(msg);
        }
      };
    },
    9838: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "Hub", {
        enumerable: !0,
        get: function() {
          return _hub.default;
        }
      }), Object.defineProperty(exports, "NodePath", {
        enumerable: !0,
        get: function() {
          return _path.default;
        }
      }), Object.defineProperty(exports, "Scope", {
        enumerable: !0,
        get: function() {
          return _scope.default;
        }
      }), exports.visitors = exports.default = void 0;
      var visitors = __webpack_require__(1169);
      exports.visitors = visitors;
      var _t = __webpack_require__(8218), cache = __webpack_require__(732), _traverseNode = __webpack_require__(6033), _path = __webpack_require__(2969), _scope = __webpack_require__(2570), _hub = __webpack_require__(2180);
      const {VISITOR_KEYS, removeProperties, traverseFast} = _t;
      function traverse(parent, opts = {}, scope, state, parentPath) {
        if (parent) {
          if (!opts.noScope && !scope && "Program" !== parent.type && "File" !== parent.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
          VISITOR_KEYS[parent.type] && (visitors.explode(opts), (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath));
        }
      }
      var _default = traverse;
      function hasDenylistedType(path, state) {
        path.node.type === state.type && (state.has = !0, path.stop());
      }
      exports.default = _default, traverse.visitors = visitors, traverse.verify = visitors.verify, 
      traverse.explode = visitors.explode, traverse.cheap = function(node, enter) {
        return traverseFast(node, enter);
      }, traverse.node = function(node, opts, scope, state, path, skipKeys) {
        (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
      }, traverse.clearNode = function(node, opts) {
        removeProperties(node, opts), cache.path.delete(node);
      }, traverse.removeProperties = function(tree, opts) {
        return traverseFast(tree, traverse.clearNode, opts), tree;
      }, traverse.hasType = function(tree, type, denylistTypes) {
        if (null != denylistTypes && denylistTypes.includes(tree.type)) return !1;
        if (tree.type === type) return !0;
        const state = {
          has: !1,
          type
        };
        return traverse(tree, {
          noScope: !0,
          denylist: denylistTypes,
          enter: hasDenylistedType
        }, null, state), state.has;
      }, traverse.cache = cache;
    },
    6576: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.find = function(callback) {
        let path = this;
        do {
          if (callback(path)) return path;
        } while (path = path.parentPath);
        return null;
      }, exports.findParent = function(callback) {
        let path = this;
        for (;path = path.parentPath; ) if (callback(path)) return path;
        return null;
      }, exports.getAncestry = function() {
        let path = this;
        const paths = [];
        do {
          paths.push(path);
        } while (path = path.parentPath);
        return paths;
      }, exports.getDeepestCommonAncestorFrom = function(paths, filter) {
        if (!paths.length) return this;
        if (1 === paths.length) return paths[0];
        let lastCommonIndex, lastCommon, minDepth = 1 / 0;
        const ancestries = paths.map((path => {
          const ancestry = [];
          do {
            ancestry.unshift(path);
          } while ((path = path.parentPath) && path !== this);
          return ancestry.length < minDepth && (minDepth = ancestry.length), ancestry;
        })), first = ancestries[0];
        depthLoop: for (let i = 0; i < minDepth; i++) {
          const shouldMatch = first[i];
          for (const ancestry of ancestries) if (ancestry[i] !== shouldMatch) break depthLoop;
          lastCommonIndex = i, lastCommon = shouldMatch;
        }
        if (lastCommon) return filter ? filter(lastCommon, lastCommonIndex, ancestries) : lastCommon;
        throw new Error("Couldn't find intersection");
      }, exports.getEarliestCommonAncestorFrom = function(paths) {
        return this.getDeepestCommonAncestorFrom(paths, (function(deepest, i, ancestries) {
          let earliest;
          const keys = VISITOR_KEYS[deepest.type];
          for (const ancestry of ancestries) {
            const path = ancestry[i + 1];
            if (!earliest) {
              earliest = path;
              continue;
            }
            if (path.listKey && earliest.listKey === path.listKey && path.key < earliest.key) {
              earliest = path;
              continue;
            }
            keys.indexOf(earliest.parentKey) > keys.indexOf(path.parentKey) && (earliest = path);
          }
          return earliest;
        }));
      }, exports.getFunctionParent = function() {
        return this.findParent((p => p.isFunction()));
      }, exports.getStatementParent = function() {
        let path = this;
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) break;
          path = path.parentPath;
        } while (path);
        if (path && (path.isProgram() || path.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
        return path;
      }, exports.inType = function(...candidateTypes) {
        let path = this;
        for (;path; ) {
          for (const type of candidateTypes) if (path.node.type === type) return !0;
          path = path.parentPath;
        }
        return !1;
      }, exports.isAncestor = function(maybeDescendant) {
        return maybeDescendant.isDescendant(this);
      }, exports.isDescendant = function(maybeAncestor) {
        return !!this.findParent((parent => parent === maybeAncestor));
      };
      var _t = __webpack_require__(8218);
      __webpack_require__(2969);
      const {VISITOR_KEYS} = _t;
    },
    1483: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.addComment = function(type, content, line) {
        _addComment(this.node, type, content, line);
      }, exports.addComments = function(type, comments) {
        _addComments(this.node, type, comments);
      }, exports.shareCommentsWithSiblings = function() {
        if ("string" == typeof this.key) return;
        const node = this.node;
        if (!node) return;
        const trailing = node.trailingComments, leading = node.leadingComments;
        if (!trailing && !leading) return;
        const prev = this.getSibling(this.key - 1), next = this.getSibling(this.key + 1), hasPrev = Boolean(prev.node), hasNext = Boolean(next.node);
        hasPrev && !hasNext ? prev.addComments("trailing", trailing) : hasNext && !hasPrev && next.addComments("leading", leading);
      };
      var _t = __webpack_require__(8218);
      const {addComment: _addComment, addComments: _addComments} = _t;
    },
    2523: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._call = function(fns) {
        if (!fns) return !1;
        for (const fn of fns) {
          if (!fn) continue;
          const node = this.node;
          if (!node) return !0;
          const ret = fn.call(this.state, this, this.state);
          if (ret && "object" == typeof ret && "function" == typeof ret.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          if (ret) throw new Error(`Unexpected return value from visitor method ${fn}`);
          if (this.node !== node) return !0;
          if (this._traverseFlags > 0) return !0;
        }
        return !1;
      }, exports._getQueueContexts = function() {
        let path = this, contexts = this.contexts;
        for (;!contexts.length && (path = path.parentPath, path); ) contexts = path.contexts;
        return contexts;
      }, exports._resyncKey = function() {
        if (!this.container) return;
        if (this.node === this.container[this.key]) return;
        if (Array.isArray(this.container)) {
          for (let i = 0; i < this.container.length; i++) if (this.container[i] === this.node) return this.setKey(i);
        } else for (const key of Object.keys(this.container)) if (this.container[key] === this.node) return this.setKey(key);
        this.key = null;
      }, exports._resyncList = function() {
        if (!this.parent || !this.inList) return;
        const newContainer = this.parent[this.listKey];
        if (this.container === newContainer) return;
        this.container = newContainer || null;
      }, exports._resyncParent = function() {
        this.parentPath && (this.parent = this.parentPath.node);
      }, exports._resyncRemoved = function() {
        null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
      }, exports.call = function(key) {
        const opts = this.opts;
        if (this.debug(key), this.node && this._call(opts[key])) return !0;
        if (this.node) return this._call(opts[this.node.type] && opts[this.node.type][key]);
        return !1;
      }, exports.isBlacklisted = exports.isDenylisted = function() {
        var _this$opts$denylist;
        const denylist = null != (_this$opts$denylist = this.opts.denylist) ? _this$opts$denylist : this.opts.blacklist;
        return denylist && denylist.indexOf(this.node.type) > -1;
      }, exports.popContext = function() {
        this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
      }, exports.pushContext = function(context) {
        this.contexts.push(context), this.setContext(context);
      }, exports.requeue = function(pathToQueue = this) {
        if (pathToQueue.removed) return;
        const contexts = this.contexts;
        for (const context of contexts) context.maybeQueue(pathToQueue);
      }, exports.resync = function() {
        if (this.removed) return;
        this._resyncParent(), this._resyncList(), this._resyncKey();
      }, exports.setContext = function(context) {
        null != this.skipKeys && (this.skipKeys = {});
        this._traverseFlags = 0, context && (this.context = context, this.state = context.state, 
        this.opts = context.opts);
        return this.setScope(), this;
      }, exports.setKey = function(key) {
        var _this$node;
        this.key = key, this.node = this.container[this.key], this.type = null == (_this$node = this.node) ? void 0 : _this$node.type;
      }, exports.setScope = function() {
        if (this.opts && this.opts.noScope) return;
        let target, path = this.parentPath;
        "key" === this.key && path.isMethod() && (path = path.parentPath);
        for (;path && !target; ) {
          if (path.opts && path.opts.noScope) return;
          target = path.scope, path = path.parentPath;
        }
        this.scope = this.getScope(target), this.scope && this.scope.init();
      }, exports.setup = function(parentPath, container, listKey, key) {
        this.listKey = listKey, this.container = container, this.parentPath = parentPath || this.parentPath, 
        this.setKey(key);
      }, exports.skip = function() {
        this.shouldSkip = !0;
      }, exports.skipKey = function(key) {
        null == this.skipKeys && (this.skipKeys = {});
        this.skipKeys[key] = !0;
      }, exports.stop = function() {
        this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
      }, exports.visit = function() {
        if (!this.node) return !1;
        if (this.isDenylisted()) return !1;
        if (this.opts.shouldSkip && this.opts.shouldSkip(this)) return !1;
        const currentContext = this.context;
        if (this.shouldSkip || this.call("enter")) return this.debug("Skip..."), this.shouldStop;
        return restoreContext(this, currentContext), this.debug("Recursing into..."), this.shouldStop = (0, 
        _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), 
        restoreContext(this, currentContext), this.call("exit"), this.shouldStop;
      };
      var _traverseNode = __webpack_require__(6033), _index = __webpack_require__(2969);
      function restoreContext(path, context) {
        path.context !== context && (path.context = context, path.state = context.state, 
        path.opts = context.opts);
      }
    },
    4249: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.arrowFunctionToExpression = function({allowInsertArrow = !0, specCompliant = !1, noNewArrows = !specCompliant} = {}) {
        if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
        const {thisBinding, fnPath: fn} = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);
        if (fn.ensureBlock(), fn.node.type = "FunctionExpression", !noNewArrows) {
          const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
          checkBinding && fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression([])
          }), fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [ thisExpression(), identifier(checkBinding ? checkBinding.name : thisBinding) ]))), 
          fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, !0) || fn.node, identifier("bind")), [ checkBinding ? identifier(checkBinding.name) : thisExpression() ]));
        }
      }, exports.arrowFunctionToShadowed = function() {
        if (!this.isArrowFunctionExpression()) return;
        this.arrowFunctionToExpression();
      }, exports.ensureBlock = function() {
        const body = this.get("body"), bodyNode = body.node;
        if (Array.isArray(body)) throw new Error("Can't convert array path to a block statement");
        if (!bodyNode) throw new Error("Can't convert node without a body");
        if (body.isBlockStatement()) return bodyNode;
        const statements = [];
        let key, listKey, stringPath = "body";
        body.isStatement() ? (listKey = "body", key = 0, statements.push(body.node)) : (stringPath += ".body.0", 
        this.isFunction() ? (key = "argument", statements.push(returnStatement(body.node))) : (key = "expression", 
        statements.push(expressionStatement(body.node))));
        this.node.body = blockStatement(statements);
        const parentPath = this.get(stringPath);
        return body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key), 
        this.node;
      }, exports.toComputedKey = function() {
        let key;
        if (this.isMemberExpression()) key = this.node.property; else {
          if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
          key = this.node.key;
        }
        this.node.computed || isIdentifier(key) && (key = stringLiteral(key.name));
        return key;
      }, exports.unwrapFunctionEnvironment = function() {
        if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
        hoistFunctionEnvironment(this);
      };
      var _t = __webpack_require__(8218), _helperEnvironmentVisitor = __webpack_require__(1692), _helperFunctionName = __webpack_require__(1485), _visitors = __webpack_require__(1169);
      const {arrowFunctionExpression, assignmentExpression, binaryExpression, blockStatement, callExpression, conditionalExpression, expressionStatement, identifier, isIdentifier, jsxIdentifier, logicalExpression, LOGICAL_OPERATORS, memberExpression, metaProperty, numericLiteral, objectExpression, restElement, returnStatement, sequenceExpression, spreadElement, stringLiteral, super: _super, thisExpression, toExpression, unaryExpression} = _t;
      const getSuperCallsVisitor = (0, _visitors.merge)([ {
        CallExpression(child, {allSuperCalls}) {
          child.get("callee").isSuper() && allSuperCalls.push(child);
        }
      }, _helperEnvironmentVisitor.default ]);
      function hoistFunctionEnvironment(fnPath, noNewArrows = !0, allowInsertArrow = !0) {
        let arrowParent, thisEnvFn = fnPath.findParent((p => p.isArrowFunctionExpression() ? (null != arrowParent || (arrowParent = p), 
        !1) : p.isFunction() || p.isProgram() || p.isClassProperty({
          static: !1
        }) || p.isClassPrivateProperty({
          static: !1
        })));
        const inConstructor = thisEnvFn.isClassMethod({
          kind: "constructor"
        });
        if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) if (arrowParent) thisEnvFn = arrowParent; else {
          if (!allowInsertArrow) throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
          fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), [])), 
          thisEnvFn = fnPath.get("callee"), fnPath = thisEnvFn.get("body");
        }
        const {thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls} = function(fnPath) {
          const thisPaths = [], argumentsPaths = [], newTargetPaths = [], superProps = [], superCalls = [];
          return fnPath.traverse(getScopeInformationVisitor, {
            thisPaths,
            argumentsPaths,
            newTargetPaths,
            superProps,
            superCalls
          }), {
            thisPaths,
            argumentsPaths,
            newTargetPaths,
            superProps,
            superCalls
          };
        }(fnPath);
        if (inConstructor && superCalls.length > 0) {
          if (!allowInsertArrow) throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
          const allSuperCalls = [];
          thisEnvFn.traverse(getSuperCallsVisitor, {
            allSuperCalls
          });
          const superBinding = function(thisEnvFn) {
            return getBinding(thisEnvFn, "supercall", (() => {
              const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
              return arrowFunctionExpression([ restElement(argsBinding) ], callExpression(_super(), [ spreadElement(identifier(argsBinding.name)) ]));
            }));
          }(thisEnvFn);
          allSuperCalls.forEach((superCall => {
            const callee = identifier(superBinding);
            callee.loc = superCall.node.callee.loc, superCall.get("callee").replaceWith(callee);
          }));
        }
        if (argumentsPaths.length > 0) {
          const argumentsBinding = getBinding(thisEnvFn, "arguments", (() => {
            const args = () => identifier("arguments");
            return thisEnvFn.scope.path.isProgram() ? conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args()) : args();
          }));
          argumentsPaths.forEach((argumentsChild => {
            const argsRef = identifier(argumentsBinding);
            argsRef.loc = argumentsChild.node.loc, argumentsChild.replaceWith(argsRef);
          }));
        }
        if (newTargetPaths.length > 0) {
          const newTargetBinding = getBinding(thisEnvFn, "newtarget", (() => metaProperty(identifier("new"), identifier("target"))));
          newTargetPaths.forEach((targetChild => {
            const targetRef = identifier(newTargetBinding);
            targetRef.loc = targetChild.node.loc, targetChild.replaceWith(targetRef);
          }));
        }
        if (superProps.length > 0) {
          if (!allowInsertArrow) throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
          superProps.reduce(((acc, superProp) => acc.concat(function(superProp) {
            if (superProp.parentPath.isAssignmentExpression() && "=" !== superProp.parentPath.node.operator) {
              const assignmentPath = superProp.parentPath, op = assignmentPath.node.operator.slice(0, -1), value = assignmentPath.node.right, isLogicalAssignment = function(op) {
                return LOGICAL_OPERATORS.includes(op);
              }(op);
              if (superProp.node.computed) {
                const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp"), object = superProp.node.object, property = superProp.node.property;
                assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), !0)), 
                assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), !0), value));
              } else {
                const object = superProp.node.object, property = superProp.node.property;
                assignmentPath.get("left").replaceWith(memberExpression(object, property)), assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
              }
              return isLogicalAssignment ? assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right)) : assignmentPath.node.operator = "=", 
              [ assignmentPath.get("left"), assignmentPath.get("right").get("left") ];
            }
            if (superProp.parentPath.isUpdateExpression()) {
              const updateExpr = superProp.parentPath, tmp = superProp.scope.generateDeclaredUidIdentifier("tmp"), computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null, parts = [ assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1))) ];
              superProp.parentPath.node.prefix || parts.push(identifier(tmp.name)), updateExpr.replaceWith(sequenceExpression(parts));
              return [ updateExpr.get("expressions.0.right"), updateExpr.get("expressions.1.left") ];
            }
            return [ superProp ];
            function rightExpression(op, left, right) {
              return "=" === op ? assignmentExpression("=", left, right) : binaryExpression(op, left, right);
            }
          }(superProp))), []).forEach((superProp => {
            const key = superProp.node.computed ? "" : superProp.get("property").node.name, isAssignment = superProp.parentPath.isAssignmentExpression({
              left: superProp.node
            }), isCall = superProp.parentPath.isCallExpression({
              callee: superProp.node
            }), superBinding = function(thisEnvFn, isAssignment, propName) {
              return getBinding(thisEnvFn, `superprop_${isAssignment ? "set" : "get"}:${propName || ""}`, (() => {
                const argsList = [];
                let fnBody;
                if (propName) fnBody = memberExpression(_super(), identifier(propName)); else {
                  const method = thisEnvFn.scope.generateUidIdentifier("prop");
                  argsList.unshift(method), fnBody = memberExpression(_super(), identifier(method.name), !0);
                }
                if (isAssignment) {
                  const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
                  argsList.push(valueIdent), fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
                }
                return arrowFunctionExpression(argsList, fnBody);
              }));
            }(thisEnvFn, isAssignment, key), args = [];
            if (superProp.node.computed && args.push(superProp.get("property").node), isAssignment) {
              const value = superProp.parentPath.node.right;
              args.push(value);
            }
            const call = callExpression(identifier(superBinding), args);
            isCall ? (superProp.parentPath.unshiftContainer("arguments", thisExpression()), 
            superProp.replaceWith(memberExpression(call, identifier("call"))), thisPaths.push(superProp.parentPath.get("arguments.0"))) : isAssignment ? superProp.parentPath.replaceWith(call) : superProp.replaceWith(call);
          }));
        }
        let thisBinding;
        return (thisPaths.length > 0 || !noNewArrows) && (thisBinding = function(thisEnvFn, inConstructor) {
          return getBinding(thisEnvFn, "this", (thisBinding => {
            if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
            thisEnvFn.traverse(assignSuperThisVisitor, {
              supers: new WeakSet,
              thisBinding
            });
          }));
        }(thisEnvFn, inConstructor), (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) && (thisPaths.forEach((thisChild => {
          const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
          thisRef.loc = thisChild.node.loc, thisChild.replaceWith(thisRef);
        })), noNewArrows || (thisBinding = null))), {
          thisBinding,
          fnPath
        };
      }
      function hasSuperClass(thisEnvFn) {
        return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
      }
      const assignSuperThisVisitor = (0, _visitors.merge)([ {
        CallExpression(child, {supers, thisBinding}) {
          child.get("callee").isSuper() && (supers.has(child.node) || (supers.add(child.node), 
          child.replaceWithMultiple([ child.node, assignmentExpression("=", identifier(thisBinding), identifier("this")) ])));
        }
      }, _helperEnvironmentVisitor.default ]);
      function getBinding(thisEnvFn, key, init) {
        const cacheKey = "binding:" + key;
        let data = thisEnvFn.getData(cacheKey);
        if (!data) {
          const id = thisEnvFn.scope.generateUidIdentifier(key);
          data = id.name, thisEnvFn.setData(cacheKey, data), thisEnvFn.scope.push({
            id,
            init: init(data)
          });
        }
        return data;
      }
      const getScopeInformationVisitor = (0, _visitors.merge)([ {
        ThisExpression(child, {thisPaths}) {
          thisPaths.push(child);
        },
        JSXIdentifier(child, {thisPaths}) {
          "this" === child.node.name && (child.parentPath.isJSXMemberExpression({
            object: child.node
          }) || child.parentPath.isJSXOpeningElement({
            name: child.node
          })) && thisPaths.push(child);
        },
        CallExpression(child, {superCalls}) {
          child.get("callee").isSuper() && superCalls.push(child);
        },
        MemberExpression(child, {superProps}) {
          child.get("object").isSuper() && superProps.push(child);
        },
        Identifier(child, {argumentsPaths}) {
          if (!child.isReferencedIdentifier({
            name: "arguments"
          })) return;
          let curr = child.scope;
          do {
            if (curr.hasOwnBinding("arguments")) return void curr.rename("arguments");
            if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) break;
          } while (curr = curr.parent);
          argumentsPaths.push(child);
        },
        MetaProperty(child, {newTargetPaths}) {
          child.get("meta").isIdentifier({
            name: "new"
          }) && child.get("property").isIdentifier({
            name: "target"
          }) && newTargetPaths.push(child);
        }
      }, _helperEnvironmentVisitor.default ]);
    },
    3456: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.evaluate = function() {
        const state = {
          confident: !0,
          deoptPath: null,
          seen: new Map
        };
        let value = evaluateCached(this, state);
        state.confident || (value = void 0);
        return {
          confident: state.confident,
          deopt: state.deoptPath,
          value
        };
      }, exports.evaluateTruthy = function() {
        const res = this.evaluate();
        if (res.confident) return !!res.value;
      };
      const VALID_CALLEES = [ "String", "Number", "Math" ], INVALID_METHODS = [ "random" ];
      function deopt(path, state) {
        state.confident && (state.deoptPath = path, state.confident = !1);
      }
      function evaluateCached(path, state) {
        const {node} = path, {seen} = state;
        if (seen.has(node)) {
          const existing = seen.get(node);
          return existing.resolved ? existing.value : void deopt(path, state);
        }
        {
          const item = {
            resolved: !1
          };
          seen.set(node, item);
          const val = function(path, state) {
            if (!state.confident) return;
            if (path.isSequenceExpression()) {
              const exprs = path.get("expressions");
              return evaluateCached(exprs[exprs.length - 1], state);
            }
            if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) return path.node.value;
            if (path.isNullLiteral()) return null;
            if (path.isTemplateLiteral()) return evaluateQuasis(path, path.node.quasis, state);
            if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
              const object = path.get("tag.object"), {node: {name}} = object, property = path.get("tag.property");
              if (object.isIdentifier() && "String" === name && !path.scope.getBinding(name) && property.isIdentifier() && "raw" === property.node.name) return evaluateQuasis(path, path.node.quasi.quasis, state, !0);
            }
            if (path.isConditionalExpression()) {
              const testResult = evaluateCached(path.get("test"), state);
              if (!state.confident) return;
              return evaluateCached(testResult ? path.get("consequent") : path.get("alternate"), state);
            }
            if (path.isExpressionWrapper()) return evaluateCached(path.get("expression"), state);
            if (path.isMemberExpression() && !path.parentPath.isCallExpression({
              callee: path.node
            })) {
              const property = path.get("property"), object = path.get("object");
              if (object.isLiteral() && property.isIdentifier()) {
                const value = object.node.value, type = typeof value;
                if ("number" === type || "string" === type) return value[property.node.name];
              }
            }
            if (path.isReferencedIdentifier()) {
              const binding = path.scope.getBinding(path.node.name);
              if (binding && binding.constantViolations.length > 0) return deopt(binding.path, state);
              if (binding && path.node.start < binding.path.node.end) return deopt(binding.path, state);
              if (null != binding && binding.hasValue) return binding.value;
              {
                if ("undefined" === path.node.name) return binding ? deopt(binding.path, state) : void 0;
                if ("Infinity" === path.node.name) return binding ? deopt(binding.path, state) : 1 / 0;
                if ("NaN" === path.node.name) return binding ? deopt(binding.path, state) : NaN;
                const resolved = path.resolve();
                return resolved === path ? deopt(path, state) : evaluateCached(resolved, state);
              }
            }
            if (path.isUnaryExpression({
              prefix: !0
            })) {
              if ("void" === path.node.operator) return;
              const argument = path.get("argument");
              if ("typeof" === path.node.operator && (argument.isFunction() || argument.isClass())) return "function";
              const arg = evaluateCached(argument, state);
              if (!state.confident) return;
              switch (path.node.operator) {
               case "!":
                return !arg;

               case "+":
                return +arg;

               case "-":
                return -arg;

               case "~":
                return ~arg;

               case "typeof":
                return typeof arg;
              }
            }
            if (path.isArrayExpression()) {
              const arr = [], elems = path.get("elements");
              for (const elem of elems) {
                const elemValue = elem.evaluate();
                if (!elemValue.confident) return deopt(elemValue.deopt, state);
                arr.push(elemValue.value);
              }
              return arr;
            }
            if (path.isObjectExpression()) {
              const obj = {}, props = path.get("properties");
              for (const prop of props) {
                if (prop.isObjectMethod() || prop.isSpreadElement()) return deopt(prop, state);
                let key = prop.get("key");
                if (prop.node.computed) {
                  if (key = key.evaluate(), !key.confident) return deopt(key.deopt, state);
                  key = key.value;
                } else key = key.isIdentifier() ? key.node.name : key.node.value;
                let value = prop.get("value").evaluate();
                if (!value.confident) return deopt(value.deopt, state);
                value = value.value, obj[key] = value;
              }
              return obj;
            }
            if (path.isLogicalExpression()) {
              const wasConfident = state.confident, left = evaluateCached(path.get("left"), state), leftConfident = state.confident;
              state.confident = wasConfident;
              const right = evaluateCached(path.get("right"), state), rightConfident = state.confident;
              switch (path.node.operator) {
               case "||":
                if (state.confident = leftConfident && (!!left || rightConfident), !state.confident) return;
                return left || right;

               case "&&":
                if (state.confident = leftConfident && (!left || rightConfident), !state.confident) return;
                return left && right;
              }
            }
            if (path.isBinaryExpression()) {
              const left = evaluateCached(path.get("left"), state);
              if (!state.confident) return;
              const right = evaluateCached(path.get("right"), state);
              if (!state.confident) return;
              switch (path.node.operator) {
               case "-":
                return left - right;

               case "+":
                return left + right;

               case "/":
                return left / right;

               case "*":
                return left * right;

               case "%":
                return left % right;

               case "**":
                return Math.pow(left, right);

               case "<":
                return left < right;

               case ">":
                return left > right;

               case "<=":
                return left <= right;

               case ">=":
                return left >= right;

               case "==":
                return left == right;

               case "!=":
                return left != right;

               case "===":
                return left === right;

               case "!==":
                return left !== right;

               case "|":
                return left | right;

               case "&":
                return left & right;

               case "^":
                return left ^ right;

               case "<<":
                return left << right;

               case ">>":
                return left >> right;

               case ">>>":
                return left >>> right;
              }
            }
            if (path.isCallExpression()) {
              const callee = path.get("callee");
              let context, func;
              if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0 && (func = global[callee.node.name]), 
              callee.isMemberExpression()) {
                const object = callee.get("object"), property = callee.get("property");
                if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0 && (context = global[object.node.name], 
                func = context[property.node.name]), object.isLiteral() && property.isIdentifier()) {
                  const type = typeof object.node.value;
                  "string" !== type && "number" !== type || (context = object.node.value, func = context[property.node.name]);
                }
              }
              if (func) {
                const args = path.get("arguments").map((arg => evaluateCached(arg, state)));
                if (!state.confident) return;
                return func.apply(context, args);
              }
            }
            deopt(path, state);
          }(path, state);
          return state.confident && (item.resolved = !0, item.value = val), val;
        }
      }
      function evaluateQuasis(path, quasis, state, raw = !1) {
        let str = "", i = 0;
        const exprs = path.get("expressions");
        for (const elem of quasis) {
          if (!state.confident) break;
          str += raw ? elem.value.raw : elem.value.cooked;
          const expr = exprs[i++];
          expr && (str += String(evaluateCached(expr, state)));
        }
        if (state.confident) return str;
      }
    },
    9463: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._getKey = function(key, context) {
        const node = this.node, container = node[key];
        return Array.isArray(container) ? container.map(((_, i) => _index.default.get({
          listKey: key,
          parentPath: this,
          parent: node,
          container,
          key: i
        }).setContext(context))) : _index.default.get({
          parentPath: this,
          parent: node,
          container: node,
          key
        }).setContext(context);
      }, exports._getPattern = function(parts, context) {
        let path = this;
        for (const part of parts) path = "." === part ? path.parentPath : Array.isArray(path) ? path[part] : path.get(part, context);
        return path;
      }, exports.get = function(key, context = !0) {
        !0 === context && (context = this.context);
        const parts = key.split(".");
        return 1 === parts.length ? this._getKey(key, context) : this._getPattern(parts, context);
      }, exports.getAllNextSiblings = function() {
        let _key = this.key, sibling = this.getSibling(++_key);
        const siblings = [];
        for (;sibling.node; ) siblings.push(sibling), sibling = this.getSibling(++_key);
        return siblings;
      }, exports.getAllPrevSiblings = function() {
        let _key = this.key, sibling = this.getSibling(--_key);
        const siblings = [];
        for (;sibling.node; ) siblings.push(sibling), sibling = this.getSibling(--_key);
        return siblings;
      }, exports.getBindingIdentifierPaths = function(duplicates = !1, outerOnly = !1) {
        const search = [ this ], ids = Object.create(null);
        for (;search.length; ) {
          const id = search.shift();
          if (!id) continue;
          if (!id.node) continue;
          const keys = _getBindingIdentifiers.keys[id.node.type];
          if (id.isIdentifier()) if (duplicates) {
            (ids[id.node.name] = ids[id.node.name] || []).push(id);
          } else ids[id.node.name] = id; else if (id.isExportDeclaration()) {
            const declaration = id.get("declaration");
            isDeclaration(declaration) && search.push(declaration);
          } else {
            if (outerOnly) {
              if (id.isFunctionDeclaration()) {
                search.push(id.get("id"));
                continue;
              }
              if (id.isFunctionExpression()) continue;
            }
            if (keys) for (let i = 0; i < keys.length; i++) {
              const key = keys[i], child = id.get(key);
              Array.isArray(child) ? search.push(...child) : child.node && search.push(child);
            }
          }
        }
        return ids;
      }, exports.getBindingIdentifiers = function(duplicates) {
        return _getBindingIdentifiers(this.node, duplicates);
      }, exports.getCompletionRecords = function() {
        return _getCompletionRecords(this, {
          canHaveBreak: !1,
          shouldPopulateBreak: !1,
          inCaseClause: !1
        }).map((r => r.path));
      }, exports.getNextSibling = function() {
        return this.getSibling(this.key + 1);
      }, exports.getOpposite = function() {
        if ("left" === this.key) return this.getSibling("right");
        if ("right" === this.key) return this.getSibling("left");
        return null;
      }, exports.getOuterBindingIdentifierPaths = function(duplicates) {
        return this.getBindingIdentifierPaths(duplicates, !0);
      }, exports.getOuterBindingIdentifiers = function(duplicates) {
        return _getOuterBindingIdentifiers(this.node, duplicates);
      }, exports.getPrevSibling = function() {
        return this.getSibling(this.key - 1);
      }, exports.getSibling = function(key) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: this.parent,
          container: this.container,
          listKey: this.listKey,
          key
        }).setContext(this.context);
      };
      var _index = __webpack_require__(2969), _t = __webpack_require__(8218);
      const {getBindingIdentifiers: _getBindingIdentifiers, getOuterBindingIdentifiers: _getOuterBindingIdentifiers, isDeclaration, numericLiteral, unaryExpression} = _t;
      function addCompletionRecords(path, records, context) {
        return path && records.push(..._getCompletionRecords(path, context)), records;
      }
      function normalCompletionToBreak(completions) {
        completions.forEach((c => {
          c.type = 1;
        }));
      }
      function replaceBreakStatementInBreakCompletion(completions, reachable) {
        completions.forEach((c => {
          c.path.isBreakStatement({
            label: null
          }) && (reachable ? c.path.replaceWith(unaryExpression("void", numericLiteral(0))) : c.path.remove());
        }));
      }
      function getStatementListCompletion(paths, context) {
        const completions = [];
        if (context.canHaveBreak) {
          let lastNormalCompletions = [];
          for (let i = 0; i < paths.length; i++) {
            const path = paths[i], newContext = Object.assign({}, context, {
              inCaseClause: !1
            });
            path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak) ? newContext.shouldPopulateBreak = !0 : newContext.shouldPopulateBreak = !1;
            const statementCompletions = _getCompletionRecords(path, newContext);
            if (statementCompletions.length > 0 && statementCompletions.every((c => 1 === c.type))) {
              lastNormalCompletions.length > 0 && statementCompletions.every((c => c.path.isBreakStatement({
                label: null
              }))) ? (normalCompletionToBreak(lastNormalCompletions), completions.push(...lastNormalCompletions), 
              lastNormalCompletions.some((c => c.path.isDeclaration())) && (completions.push(...statementCompletions), 
              replaceBreakStatementInBreakCompletion(statementCompletions, !0)), replaceBreakStatementInBreakCompletion(statementCompletions, !1)) : (completions.push(...statementCompletions), 
              context.shouldPopulateBreak || replaceBreakStatementInBreakCompletion(statementCompletions, !0));
              break;
            }
            if (i === paths.length - 1) completions.push(...statementCompletions); else {
              lastNormalCompletions = [];
              for (let i = 0; i < statementCompletions.length; i++) {
                const c = statementCompletions[i];
                1 === c.type && completions.push(c), 0 === c.type && lastNormalCompletions.push(c);
              }
            }
          }
        } else if (paths.length) for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || 1 === pathCompletions.length && !pathCompletions[0].path.isVariableDeclaration()) {
            completions.push(...pathCompletions);
            break;
          }
        }
        return completions;
      }
      function _getCompletionRecords(path, context) {
        let records = [];
        if (path.isIfStatement()) records = addCompletionRecords(path.get("consequent"), records, context), 
        records = addCompletionRecords(path.get("alternate"), records, context); else {
          if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) return addCompletionRecords(path.get("body"), records, context);
          if (path.isProgram() || path.isBlockStatement()) return getStatementListCompletion(path.get("body"), context);
          if (path.isFunction()) return _getCompletionRecords(path.get("body"), context);
          if (path.isTryStatement()) records = addCompletionRecords(path.get("block"), records, context), 
          records = addCompletionRecords(path.get("handler"), records, context); else {
            if (path.isCatchClause()) return addCompletionRecords(path.get("body"), records, context);
            if (path.isSwitchStatement()) return function(cases, records, context) {
              let lastNormalCompletions = [];
              for (let i = 0; i < cases.length; i++) {
                const caseCompletions = _getCompletionRecords(cases[i], context), normalCompletions = [], breakCompletions = [];
                for (const c of caseCompletions) 0 === c.type && normalCompletions.push(c), 1 === c.type && breakCompletions.push(c);
                normalCompletions.length && (lastNormalCompletions = normalCompletions), records.push(...breakCompletions);
              }
              return records.push(...lastNormalCompletions), records;
            }(path.get("cases"), records, context);
            if (path.isSwitchCase()) return getStatementListCompletion(path.get("consequent"), {
              canHaveBreak: !0,
              shouldPopulateBreak: !1,
              inCaseClause: !0
            });
            path.isBreakStatement() ? records.push(function(path) {
              return {
                type: 1,
                path
              };
            }(path)) : records.push(function(path) {
              return {
                type: 0,
                path
              };
            }(path));
          }
        }
        return records;
      }
    },
    2969: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;
      var virtualTypes = __webpack_require__(4387), _debug = __webpack_require__(5158), _index = __webpack_require__(9838), _scope = __webpack_require__(2570), _t = __webpack_require__(8218), t = _t, _cache = __webpack_require__(732), _generator = __webpack_require__(9166), NodePath_ancestry = __webpack_require__(6576), NodePath_inference = __webpack_require__(1534), NodePath_replacement = __webpack_require__(23), NodePath_evaluation = __webpack_require__(3456), NodePath_conversion = __webpack_require__(4249), NodePath_introspection = __webpack_require__(7743), NodePath_context = __webpack_require__(2523), NodePath_removal = __webpack_require__(2052), NodePath_modification = __webpack_require__(8129), NodePath_family = __webpack_require__(9463), NodePath_comments = __webpack_require__(1483);
      const {validate} = _t, debug = _debug("babel");
      exports.REMOVED = 1;
      exports.SHOULD_STOP = 2;
      exports.SHOULD_SKIP = 4;
      class NodePath {
        constructor(hub, parent) {
          this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, 
          this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, 
          this.key = null, this.node = null, this.type = null, this.parent = parent, this.hub = hub, 
          this.data = null, this.context = null, this.scope = null;
        }
        static get({hub, parentPath, parent, container, listKey, key}) {
          if (!hub && parentPath && (hub = parentPath.hub), !parent) throw new Error("To get a node path the parent needs to exist");
          const targetNode = container[key];
          let paths = _cache.path.get(parent);
          paths || (paths = new Map, _cache.path.set(parent, paths));
          let path = paths.get(targetNode);
          return path || (path = new NodePath(hub, parent), targetNode && paths.set(targetNode, path)), 
          path.setup(parentPath, container, listKey, key), path;
        }
        getScope(scope) {
          return this.isScope() ? new _scope.default(this) : scope;
        }
        setData(key, val) {
          return null == this.data && (this.data = Object.create(null)), this.data[key] = val;
        }
        getData(key, def) {
          null == this.data && (this.data = Object.create(null));
          let val = this.data[key];
          return void 0 === val && void 0 !== def && (val = this.data[key] = def), val;
        }
        hasNode() {
          return null != this.node;
        }
        buildCodeFrameError(msg, Error = SyntaxError) {
          return this.hub.buildError(this.node, msg, Error);
        }
        traverse(visitor, state) {
          (0, _index.default)(this.node, visitor, this.scope, state, this);
        }
        set(key, node) {
          validate(this.node, key, node), this.node[key] = node;
        }
        getPathLocation() {
          const parts = [];
          let path = this;
          do {
            let key = path.key;
            path.inList && (key = `${path.listKey}[${key}]`), parts.unshift(key);
          } while (path = path.parentPath);
          return parts.join(".");
        }
        debug(message) {
          debug.enabled && debug(`${this.getPathLocation()} ${this.type}: ${message}`);
        }
        toString() {
          return (0, _generator.default)(this.node).code;
        }
        get inList() {
          return !!this.listKey;
        }
        set inList(inList) {
          inList || (this.listKey = null);
        }
        get parentKey() {
          return this.listKey || this.key;
        }
        get shouldSkip() {
          return !!(4 & this._traverseFlags);
        }
        set shouldSkip(v) {
          v ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
        }
        get shouldStop() {
          return !!(2 & this._traverseFlags);
        }
        set shouldStop(v) {
          v ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
        }
        get removed() {
          return !!(1 & this._traverseFlags);
        }
        set removed(v) {
          v ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
        }
      }
      Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
      for (const type of t.TYPES) {
        const typeKey = `is${type}`, fn = t[typeKey];
        NodePath.prototype[typeKey] = function(opts) {
          return fn(this.node, opts);
        }, NodePath.prototype[`assert${type}`] = function(opts) {
          if (!fn(this.node, opts)) throw new TypeError(`Expected node path of type ${type}`);
        };
      }
      for (const type of Object.keys(virtualTypes)) {
        if ("_" === type[0]) continue;
        t.TYPES.indexOf(type) < 0 && t.TYPES.push(type);
        const virtualType = virtualTypes[type];
        NodePath.prototype[`is${type}`] = function(opts) {
          return virtualType.checkPath(this, opts);
        };
      }
      var _default = NodePath;
      exports.default = _default;
    },
    1534: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._getTypeAnnotation = function() {
        const node = this.node;
        if (!node) {
          if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
            const declar = this.parentPath.parentPath, declarParent = declar.parentPath;
            return "left" === declar.key && declarParent.isForInStatement() ? stringTypeAnnotation() : "left" === declar.key && declarParent.isForOfStatement() ? anyTypeAnnotation() : voidTypeAnnotation();
          }
          return;
        }
        if (node.typeAnnotation) return node.typeAnnotation;
        if (typeAnnotationInferringNodes.has(node)) return;
        typeAnnotationInferringNodes.add(node);
        try {
          var _inferer;
          let inferer = inferers[node.type];
          if (inferer) return inferer.call(this, node);
          if (inferer = inferers[this.parentPath.type], null != (_inferer = inferer) && _inferer.validParent) return this.parentPath.getTypeAnnotation();
        } finally {
          typeAnnotationInferringNodes.delete(node);
        }
      }, exports.baseTypeStrictlyMatches = function(rightArg) {
        const left = this.getTypeAnnotation(), right = rightArg.getTypeAnnotation();
        if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) return right.type === left.type;
        return !1;
      }, exports.couldBeBaseType = function(name) {
        const type = this.getTypeAnnotation();
        if (isAnyTypeAnnotation(type)) return !0;
        if (isUnionTypeAnnotation(type)) {
          for (const type2 of type.types) if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, !0)) return !0;
          return !1;
        }
        return _isBaseType(name, type, !0);
      }, exports.getTypeAnnotation = function() {
        if (this.typeAnnotation) return this.typeAnnotation;
        let type = this._getTypeAnnotation() || anyTypeAnnotation();
        isTypeAnnotation(type) && (type = type.typeAnnotation);
        return this.typeAnnotation = type;
      }, exports.isBaseType = function(baseName, soft) {
        return _isBaseType(baseName, this.getTypeAnnotation(), soft);
      }, exports.isGenericType = function(genericName) {
        const type = this.getTypeAnnotation();
        return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
          name: genericName
        });
      };
      var inferers = __webpack_require__(5081), _t = __webpack_require__(8218);
      const {anyTypeAnnotation, isAnyTypeAnnotation, isBooleanTypeAnnotation, isEmptyTypeAnnotation, isFlowBaseAnnotation, isGenericTypeAnnotation, isIdentifier, isMixedTypeAnnotation, isNumberTypeAnnotation, isStringTypeAnnotation, isTypeAnnotation, isUnionTypeAnnotation, isVoidTypeAnnotation, stringTypeAnnotation, voidTypeAnnotation} = _t;
      const typeAnnotationInferringNodes = new WeakSet;
      function _isBaseType(baseName, type, soft) {
        if ("string" === baseName) return isStringTypeAnnotation(type);
        if ("number" === baseName) return isNumberTypeAnnotation(type);
        if ("boolean" === baseName) return isBooleanTypeAnnotation(type);
        if ("any" === baseName) return isAnyTypeAnnotation(type);
        if ("mixed" === baseName) return isMixedTypeAnnotation(type);
        if ("empty" === baseName) return isEmptyTypeAnnotation(type);
        if ("void" === baseName) return isVoidTypeAnnotation(type);
        if (soft) return !1;
        throw new Error(`Unknown base type ${baseName}`);
      }
    },
    1674: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        if (!this.isReferenced()) return;
        const binding = this.scope.getBinding(node.name);
        if (binding) return binding.identifier.typeAnnotation ? binding.identifier.typeAnnotation : function(binding, path, name) {
          const types = [], functionConstantViolations = [];
          let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
          const testType = getConditionalAnnotation(binding, path, name);
          if (testType) {
            const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
            constantViolations = constantViolations.filter((path => testConstantViolations.indexOf(path) < 0)), 
            types.push(testType.typeAnnotation);
          }
          if (constantViolations.length) {
            constantViolations.push(...functionConstantViolations);
            for (const violation of constantViolations) types.push(violation.getTypeAnnotation());
          }
          if (!types.length) return;
          if (isTSTypeAnnotation(types[0]) && createTSUnionType) return createTSUnionType(types);
          if (createFlowUnionType) return createFlowUnionType(types);
          return createUnionTypeAnnotation(types);
        }(binding, this, node.name);
        if ("undefined" === node.name) return voidTypeAnnotation();
        if ("NaN" === node.name || "Infinity" === node.name) return numberTypeAnnotation();
        node.name;
      };
      var _t = __webpack_require__(8218);
      const {BOOLEAN_NUMBER_BINARY_OPERATORS, createFlowUnionType, createTSUnionType, createTypeAnnotationBasedOnTypeof, createUnionTypeAnnotation, isTSTypeAnnotation, numberTypeAnnotation, voidTypeAnnotation} = _t;
      function getConstantViolationsBefore(binding, path, functions) {
        const violations = binding.constantViolations.slice();
        return violations.unshift(binding.path), violations.filter((violation => {
          const status = (violation = violation.resolve())._guessExecutionStatusRelativeTo(path);
          return functions && "unknown" === status && functions.push(violation), "before" === status;
        }));
      }
      function inferAnnotationFromBinaryExpression(name, path) {
        const operator = path.node.operator, right = path.get("right").resolve(), left = path.get("left").resolve();
        let target, typeofPath, typePath;
        if (left.isIdentifier({
          name
        }) ? target = right : right.isIdentifier({
          name
        }) && (target = left), target) return "===" === operator ? target.getTypeAnnotation() : BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0 ? numberTypeAnnotation() : void 0;
        if ("===" !== operator && "==" !== operator) return;
        if (left.isUnaryExpression({
          operator: "typeof"
        }) ? (typeofPath = left, typePath = right) : right.isUnaryExpression({
          operator: "typeof"
        }) && (typeofPath = right, typePath = left), !typeofPath) return;
        if (!typeofPath.get("argument").isIdentifier({
          name
        })) return;
        if (typePath = typePath.resolve(), !typePath.isLiteral()) return;
        const typeValue = typePath.node.value;
        return "string" == typeof typeValue ? createTypeAnnotationBasedOnTypeof(typeValue) : void 0;
      }
      function getConditionalAnnotation(binding, path, name) {
        const ifStatement = function(binding, path, name) {
          let parentPath;
          for (;parentPath = path.parentPath; ) {
            if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
              if ("test" === path.key) return;
              return parentPath;
            }
            if (parentPath.isFunction() && parentPath.parentPath.scope.getBinding(name) !== binding) return;
            path = parentPath;
          }
        }(binding, path, name);
        if (!ifStatement) return;
        const paths = [ ifStatement.get("test") ], types = [];
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          if (path.isLogicalExpression()) "&&" === path.node.operator && (paths.push(path.get("left")), 
          paths.push(path.get("right"))); else if (path.isBinaryExpression()) {
            const type = inferAnnotationFromBinaryExpression(name, path);
            type && types.push(type);
          }
        }
        return types.length ? isTSTypeAnnotation(types[0]) && createTSUnionType ? {
          typeAnnotation: createTSUnionType(types),
          ifStatement
        } : createFlowUnionType ? {
          typeAnnotation: createFlowUnionType(types),
          ifStatement
        } : {
          typeAnnotation: createUnionTypeAnnotation(types),
          ifStatement
        } : getConditionalAnnotation(ifStatement, name);
      }
    },
    5081: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.ArrayExpression = ArrayExpression, exports.AssignmentExpression = function() {
        return this.get("right").getTypeAnnotation();
      }, exports.BinaryExpression = function(node) {
        const operator = node.operator;
        if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) return numberTypeAnnotation();
        if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) return booleanTypeAnnotation();
        if ("+" === operator) {
          const right = this.get("right"), left = this.get("left");
          return left.isBaseType("number") && right.isBaseType("number") ? numberTypeAnnotation() : left.isBaseType("string") || right.isBaseType("string") ? stringTypeAnnotation() : unionTypeAnnotation([ stringTypeAnnotation(), numberTypeAnnotation() ]);
        }
      }, exports.BooleanLiteral = function() {
        return booleanTypeAnnotation();
      }, exports.CallExpression = function() {
        const {callee} = this.node;
        if (isObjectKeys(callee)) return arrayTypeAnnotation(stringTypeAnnotation());
        if (isArrayFrom(callee) || isObjectValues(callee)) return arrayTypeAnnotation(anyTypeAnnotation());
        if (isObjectEntries(callee)) return arrayTypeAnnotation(tupleTypeAnnotation([ stringTypeAnnotation(), anyTypeAnnotation() ]));
        return resolveCall(this.get("callee"));
      }, exports.ConditionalExpression = function() {
        const argumentTypes = [ this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation() ];
        if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) return createTSUnionType(argumentTypes);
        if (createFlowUnionType) return createFlowUnionType(argumentTypes);
        return createUnionTypeAnnotation(argumentTypes);
      }, exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = function() {
        return genericTypeAnnotation(identifier("Function"));
      }, Object.defineProperty(exports, "Identifier", {
        enumerable: !0,
        get: function() {
          return _infererReference.default;
        }
      }), exports.LogicalExpression = function() {
        const argumentTypes = [ this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation() ];
        if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) return createTSUnionType(argumentTypes);
        if (createFlowUnionType) return createFlowUnionType(argumentTypes);
        return createUnionTypeAnnotation(argumentTypes);
      }, exports.NewExpression = function(node) {
        if (this.get("callee").isIdentifier()) return genericTypeAnnotation(node.callee);
      }, exports.NullLiteral = function() {
        return nullLiteralTypeAnnotation();
      }, exports.NumericLiteral = function() {
        return numberTypeAnnotation();
      }, exports.ObjectExpression = function() {
        return genericTypeAnnotation(identifier("Object"));
      }, exports.ParenthesizedExpression = function() {
        return this.get("expression").getTypeAnnotation();
      }, exports.RegExpLiteral = function() {
        return genericTypeAnnotation(identifier("RegExp"));
      }, exports.RestElement = RestElement, exports.SequenceExpression = function() {
        return this.get("expressions").pop().getTypeAnnotation();
      }, exports.StringLiteral = function() {
        return stringTypeAnnotation();
      }, exports.TaggedTemplateExpression = function() {
        return resolveCall(this.get("tag"));
      }, exports.TemplateLiteral = function() {
        return stringTypeAnnotation();
      }, exports.TypeCastExpression = TypeCastExpression, exports.UnaryExpression = function(node) {
        const operator = node.operator;
        if ("void" === operator) return voidTypeAnnotation();
        if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) return numberTypeAnnotation();
        if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) return stringTypeAnnotation();
        if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) return booleanTypeAnnotation();
      }, exports.UpdateExpression = function(node) {
        const operator = node.operator;
        if ("++" === operator || "--" === operator) return numberTypeAnnotation();
      }, exports.VariableDeclarator = function() {
        var _type;
        if (!this.get("id").isIdentifier()) return;
        const init = this.get("init");
        let type = init.getTypeAnnotation();
        "AnyTypeAnnotation" === (null == (_type = type) ? void 0 : _type.type) && init.isCallExpression() && init.get("callee").isIdentifier({
          name: "Array"
        }) && !init.scope.hasBinding("Array", !0) && (type = ArrayExpression());
        return type;
      };
      var _t = __webpack_require__(8218), _infererReference = __webpack_require__(1674);
      const {BOOLEAN_BINARY_OPERATORS, BOOLEAN_UNARY_OPERATORS, NUMBER_BINARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS, anyTypeAnnotation, arrayTypeAnnotation, booleanTypeAnnotation, buildMatchMemberExpression, createFlowUnionType, createTSUnionType, createUnionTypeAnnotation, genericTypeAnnotation, identifier, isTSTypeAnnotation, nullLiteralTypeAnnotation, numberTypeAnnotation, stringTypeAnnotation, tupleTypeAnnotation, unionTypeAnnotation, voidTypeAnnotation} = _t;
      function TypeCastExpression(node) {
        return node.typeAnnotation;
      }
      function ArrayExpression() {
        return genericTypeAnnotation(identifier("Array"));
      }
      function RestElement() {
        return ArrayExpression();
      }
      TypeCastExpression.validParent = !0, RestElement.validParent = !0;
      const isArrayFrom = buildMatchMemberExpression("Array.from"), isObjectKeys = buildMatchMemberExpression("Object.keys"), isObjectValues = buildMatchMemberExpression("Object.values"), isObjectEntries = buildMatchMemberExpression("Object.entries");
      function resolveCall(callee) {
        if ((callee = callee.resolve()).isFunction()) {
          if (callee.is("async")) return callee.is("generator") ? genericTypeAnnotation(identifier("AsyncIterator")) : genericTypeAnnotation(identifier("Promise"));
          if (callee.node.returnType) return callee.node.returnType;
        }
      }
    },
    7743: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._guessExecutionStatusRelativeTo = function(target) {
        const funcParent = {
          this: getOuterFunction(this),
          target: getOuterFunction(target)
        };
        if (funcParent.target.node !== funcParent.this.node) return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
        const paths = {
          target: target.getAncestry(),
          this: this.getAncestry()
        };
        if (paths.target.indexOf(this) >= 0) return "after";
        if (paths.this.indexOf(target) >= 0) return "before";
        let commonPath;
        const commonIndex = {
          target: 0,
          this: 0
        };
        for (;!commonPath && commonIndex.this < paths.this.length; ) {
          const path = paths.this[commonIndex.this];
          commonIndex.target = paths.target.indexOf(path), commonIndex.target >= 0 ? commonPath = path : commonIndex.this++;
        }
        if (!commonPath) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
        if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) return "unknown";
        const divergence = {
          this: paths.this[commonIndex.this - 1],
          target: paths.target[commonIndex.target - 1]
        };
        if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) return divergence.target.key > divergence.this.key ? "before" : "after";
        const keys = VISITOR_KEYS[commonPath.type], keyPosition = {
          this: keys.indexOf(divergence.this.parentKey),
          target: keys.indexOf(divergence.target.parentKey)
        };
        return keyPosition.target > keyPosition.this ? "before" : "after";
      }, exports._guessExecutionStatusRelativeToDifferentFunctions = function(target) {
        if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) return "unknown";
        const binding = target.scope.getBinding(target.node.id.name);
        if (!binding.references) return "before";
        const referencePaths = binding.referencePaths;
        let allStatus;
        for (const path of referencePaths) {
          if (!!path.find((path => path.node === target.node))) continue;
          if ("callee" !== path.key || !path.parentPath.isCallExpression()) return "unknown";
          if (executionOrderCheckedNodes.has(path.node)) continue;
          executionOrderCheckedNodes.add(path.node);
          const status = this._guessExecutionStatusRelativeTo(path);
          if (executionOrderCheckedNodes.delete(path.node), allStatus && allStatus !== status) return "unknown";
          allStatus = status;
        }
        return allStatus;
      }, exports._resolve = function(dangerous, resolved) {
        if (resolved && resolved.indexOf(this) >= 0) return;
        if ((resolved = resolved || []).push(this), this.isVariableDeclarator()) {
          if (this.get("id").isIdentifier()) return this.get("init").resolve(dangerous, resolved);
        } else if (this.isReferencedIdentifier()) {
          const binding = this.scope.getBinding(this.node.name);
          if (!binding) return;
          if (!binding.constant) return;
          if ("module" === binding.kind) return;
          if (binding.path !== this) {
            const ret = binding.path.resolve(dangerous, resolved);
            if (this.find((parent => parent.node === ret.node))) return;
            return ret;
          }
        } else {
          if (this.isTypeCastExpression()) return this.get("expression").resolve(dangerous, resolved);
          if (dangerous && this.isMemberExpression()) {
            const targetKey = this.toComputedKey();
            if (!isLiteral(targetKey)) return;
            const targetName = targetKey.value, target = this.get("object").resolve(dangerous, resolved);
            if (target.isObjectExpression()) {
              const props = target.get("properties");
              for (const prop of props) {
                if (!prop.isProperty()) continue;
                const key = prop.get("key");
                let match = prop.isnt("computed") && key.isIdentifier({
                  name: targetName
                });
                if (match = match || key.isLiteral({
                  value: targetName
                }), match) return prop.get("value").resolve(dangerous, resolved);
              }
            } else if (target.isArrayExpression() && !isNaN(+targetName)) {
              const elem = target.get("elements")[targetName];
              if (elem) return elem.resolve(dangerous, resolved);
            }
          }
        }
      }, exports.canHaveVariableDeclarationOrExpression = function() {
        return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
      }, exports.canSwapBetweenExpressionAndStatement = function(replacement) {
        if ("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) return !1;
        if (this.isExpression()) return isBlockStatement(replacement);
        if (this.isBlockStatement()) return isExpression(replacement);
        return !1;
      }, exports.equals = function(key, value) {
        return this.node[key] === value;
      }, exports.getSource = function() {
        const node = this.node;
        if (node.end) {
          const code = this.hub.getCode();
          if (code) return code.slice(node.start, node.end);
        }
        return "";
      }, exports.has = has, exports.is = void 0, exports.isCompletionRecord = function(allowInsideFunction) {
        let path = this, first = !0;
        do {
          const container = path.container;
          if (path.isFunction() && !first) return !!allowInsideFunction;
          if (first = !1, Array.isArray(container) && path.key !== container.length - 1) return !1;
        } while ((path = path.parentPath) && !path.isProgram());
        return !0;
      }, exports.isConstantExpression = function() {
        if (this.isIdentifier()) {
          const binding = this.scope.getBinding(this.node.name);
          return !!binding && binding.constant;
        }
        if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((expression => expression.isConstantExpression())));
        if (this.isUnaryExpression()) return "void" === this.node.operator && this.get("argument").isConstantExpression();
        if (this.isBinaryExpression()) return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
        return !1;
      }, exports.isInStrictMode = function() {
        const start = this.isProgram() ? this : this.parentPath;
        return !!start.find((path => {
          if (path.isProgram({
            sourceType: "module"
          })) return !0;
          if (path.isClass()) return !0;
          if (!path.isProgram() && !path.isFunction()) return !1;
          if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) return !1;
          const body = path.isFunction() ? path.node.body : path.node;
          for (const directive of body.directives) if ("use strict" === directive.value.value) return !0;
        }));
      }, exports.isNodeType = function(type) {
        return isType(this.type, type);
      }, exports.isStatementOrBlock = function() {
        return !this.parentPath.isLabeledStatement() && !isBlockStatement(this.container) && STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }, exports.isStatic = function() {
        return this.scope.isStatic(this.node);
      }, exports.isnt = function(key) {
        return !this.has(key);
      }, exports.matchesPattern = function(pattern, allowPartial) {
        return _matchesPattern(this.node, pattern, allowPartial);
      }, exports.referencesImport = function(moduleSource, importName) {
        if (!this.isReferencedIdentifier()) {
          if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
            value: importName
          }) : this.node.property.name === importName)) {
            const object = this.get("object");
            return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
          }
          return !1;
        }
        const binding = this.scope.getBinding(this.node.name);
        if (!binding || "module" !== binding.kind) return !1;
        const path = binding.path, parent = path.parentPath;
        if (!parent.isImportDeclaration()) return !1;
        if (parent.node.source.value !== moduleSource) return !1;
        if (!importName) return !0;
        if (path.isImportDefaultSpecifier() && "default" === importName) return !0;
        if (path.isImportNamespaceSpecifier() && "*" === importName) return !0;
        if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
          name: importName
        })) return !0;
        return !1;
      }, exports.resolve = function(dangerous, resolved) {
        return this._resolve(dangerous, resolved) || this;
      }, exports.willIMaybeExecuteBefore = function(target) {
        return "after" !== this._guessExecutionStatusRelativeTo(target);
      };
      var _t = __webpack_require__(8218);
      const {STATEMENT_OR_BLOCK_KEYS, VISITOR_KEYS, isBlockStatement, isExpression, isIdentifier, isLiteral, isStringLiteral, isType, matchesPattern: _matchesPattern} = _t;
      function has(key) {
        const val = this.node && this.node[key];
        return val && Array.isArray(val) ? !!val.length : !!val;
      }
      const is = has;
      function getOuterFunction(path) {
        return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
      }
      function isExecutionUncertain(type, key) {
        switch (type) {
         case "LogicalExpression":
         case "AssignmentPattern":
          return "right" === key;

         case "ConditionalExpression":
         case "IfStatement":
          return "consequent" === key || "alternate" === key;

         case "WhileStatement":
         case "DoWhileStatement":
         case "ForInStatement":
         case "ForOfStatement":
          return "body" === key;

         case "ForStatement":
          return "body" === key || "update" === key;

         case "SwitchStatement":
          return "cases" === key;

         case "TryStatement":
          return "handler" === key;

         case "OptionalMemberExpression":
          return "property" === key;

         case "OptionalCallExpression":
          return "arguments" === key;

         default:
          return !1;
        }
      }
      function isExecutionUncertainInList(paths, maxIndex) {
        for (let i = 0; i < maxIndex; i++) {
          const path = paths[i];
          if (isExecutionUncertain(path.parent.type, path.parentKey)) return !0;
        }
        return !1;
      }
      exports.is = is;
      const executionOrderCheckedNodes = new WeakSet;
    },
    9380: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _t = __webpack_require__(8218), _t2 = _t;
      const {react} = _t, {cloneNode, jsxExpressionContainer, variableDeclaration, variableDeclarator} = _t2, referenceVisitor = {
        ReferencedIdentifier(path, state) {
          if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) return;
          if ("this" === path.node.name) {
            let scope = path.scope;
            do {
              if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) break;
            } while (scope = scope.parent);
            scope && state.breakOnScopePaths.push(scope.path);
          }
          const binding = path.scope.getBinding(path.node.name);
          if (binding) {
            for (const violation of binding.constantViolations) if (violation.scope !== binding.path.scope) return state.mutableBinding = !0, 
            void path.stop();
            binding === state.scope.getBinding(path.node.name) && (state.bindings[path.node.name] = binding);
          }
        }
      };
      exports.default = class {
        constructor(path, scope) {
          this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, 
          this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, 
          this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], 
          this.scope = scope, this.path = path, this.attachAfter = !1;
        }
        isCompatibleScope(scope) {
          for (const key of Object.keys(this.bindings)) {
            const binding = this.bindings[key];
            if (!scope.bindingIdentifierEquals(key, binding.identifier)) return !1;
          }
          return !0;
        }
        getCompatibleScopes() {
          let scope = this.path.scope;
          do {
            if (!this.isCompatibleScope(scope)) break;
            if (this.scopes.push(scope), this.breakOnScopePaths.indexOf(scope.path) >= 0) break;
          } while (scope = scope.parent);
        }
        getAttachmentPath() {
          let path = this._getAttachmentPath();
          if (!path) return;
          let targetScope = path.scope;
          if (targetScope.path === path && (targetScope = path.scope.parent), targetScope.path.isProgram() || targetScope.path.isFunction()) for (const name of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name)) continue;
            const binding = this.bindings[name];
            if ("param" === binding.kind || "params" === binding.path.parentKey) continue;
            if (this.getAttachmentParentForPath(binding.path).key >= path.key) {
              this.attachAfter = !0, path = binding.path;
              for (const violationPath of binding.constantViolations) this.getAttachmentParentForPath(violationPath).key > path.key && (path = violationPath);
            }
          }
          return path;
        }
        _getAttachmentPath() {
          const scope = this.scopes.pop();
          if (scope) if (scope.path.isFunction()) {
            if (!this.hasOwnParamBindings(scope)) return this.getNextScopeAttachmentParent();
            {
              if (this.scope === scope) return;
              const bodies = scope.path.get("body").get("body");
              for (let i = 0; i < bodies.length; i++) if (!bodies[i].node._blockHoist) return bodies[i];
            }
          } else if (scope.path.isProgram()) return this.getNextScopeAttachmentParent();
        }
        getNextScopeAttachmentParent() {
          const scope = this.scopes.pop();
          if (scope) return this.getAttachmentParentForPath(scope.path);
        }
        getAttachmentParentForPath(path) {
          do {
            if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) return path;
          } while (path = path.parentPath);
        }
        hasOwnParamBindings(scope) {
          for (const name of Object.keys(this.bindings)) {
            if (!scope.hasOwnBinding(name)) continue;
            const binding = this.bindings[name];
            if ("param" === binding.kind && binding.constant) return !0;
          }
          return !1;
        }
        run() {
          if (this.path.traverse(referenceVisitor, this), this.mutableBinding) return;
          this.getCompatibleScopes();
          const attachTo = this.getAttachmentPath();
          if (!attachTo) return;
          if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
          let uid = attachTo.scope.generateUidIdentifier("ref");
          const declarator = variableDeclarator(uid, this.path.node), insertFn = this.attachAfter ? "insertAfter" : "insertBefore", [attached] = attachTo[insertFn]([ attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [ declarator ]) ]), parent = this.path.parentPath;
          return parent.isJSXElement() && this.path.container === parent.node.children && (uid = jsxExpressionContainer(uid)), 
          this.path.replaceWith(cloneNode(uid)), attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
        }
      };
    },
    1233: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.hooks = void 0;
      exports.hooks = [ function(self, parent) {
        if ("test" === self.key && (parent.isWhile() || parent.isSwitchCase()) || "declaration" === self.key && parent.isExportDeclaration() || "body" === self.key && parent.isLabeledStatement() || "declarations" === self.listKey && parent.isVariableDeclaration() && 1 === parent.node.declarations.length || "expression" === self.key && parent.isExpressionStatement()) return parent.remove(), 
        !0;
      }, function(self, parent) {
        if (parent.isSequenceExpression() && 1 === parent.node.expressions.length) return parent.replaceWith(parent.node.expressions[0]), 
        !0;
      }, function(self, parent) {
        if (parent.isBinary()) return "left" === self.key ? parent.replaceWith(parent.node.right) : parent.replaceWith(parent.node.left), 
        !0;
      }, function(self, parent) {
        if (parent.isIfStatement() && ("consequent" === self.key || "alternate" === self.key) || "body" === self.key && (parent.isLoop() || parent.isArrowFunctionExpression())) return self.replaceWith({
          type: "BlockStatement",
          body: []
        }), !0;
      } ];
    },
    4387: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;
      var _t = __webpack_require__(8218);
      const {isBinding, isBlockScoped, isExportDeclaration, isExpression, isFlow, isForStatement, isForXStatement, isIdentifier, isImportDeclaration, isImportSpecifier, isJSXIdentifier, isJSXMemberExpression, isMemberExpression, isReferenced, isScope, isStatement, isVar, isVariableDeclaration, react} = _t, {isCompatTag} = react, ReferencedIdentifier = {
        types: [ "Identifier", "JSXIdentifier" ],
        checkPath(path, opts) {
          const {node, parent} = path;
          if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
            if (!isJSXIdentifier(node, opts)) return !1;
            if (isCompatTag(node.name)) return !1;
          }
          return isReferenced(node, parent, path.parentPath.parent);
        }
      };
      exports.ReferencedIdentifier = ReferencedIdentifier;
      const ReferencedMemberExpression = {
        types: [ "MemberExpression" ],
        checkPath: ({node, parent}) => isMemberExpression(node) && isReferenced(node, parent)
      };
      exports.ReferencedMemberExpression = ReferencedMemberExpression;
      const BindingIdentifier = {
        types: [ "Identifier" ],
        checkPath(path) {
          const {node, parent} = path, grandparent = path.parentPath.parent;
          return isIdentifier(node) && isBinding(node, parent, grandparent);
        }
      };
      exports.BindingIdentifier = BindingIdentifier;
      const Statement = {
        types: [ "Statement" ],
        checkPath({node, parent}) {
          if (isStatement(node)) {
            if (isVariableDeclaration(node)) {
              if (isForXStatement(parent, {
                left: node
              })) return !1;
              if (isForStatement(parent, {
                init: node
              })) return !1;
            }
            return !0;
          }
          return !1;
        }
      };
      exports.Statement = Statement;
      const Expression = {
        types: [ "Expression" ],
        checkPath: path => path.isIdentifier() ? path.isReferencedIdentifier() : isExpression(path.node)
      };
      exports.Expression = Expression;
      const Scope = {
        types: [ "Scopable", "Pattern" ],
        checkPath: path => isScope(path.node, path.parent)
      };
      exports.Scope = Scope;
      const Referenced = {
        checkPath: path => isReferenced(path.node, path.parent)
      };
      exports.Referenced = Referenced;
      const BlockScoped = {
        checkPath: path => isBlockScoped(path.node)
      };
      exports.BlockScoped = BlockScoped;
      const Var = {
        types: [ "VariableDeclaration" ],
        checkPath: path => isVar(path.node)
      };
      exports.Var = Var;
      const User = {
        checkPath: path => path.node && !!path.node.loc
      };
      exports.User = User;
      const Generated = {
        checkPath: path => !path.isUser()
      };
      exports.Generated = Generated;
      const Pure = {
        checkPath: (path, constantsOnly) => path.scope.isPure(path.node, constantsOnly)
      };
      exports.Pure = Pure;
      const Flow = {
        types: [ "Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier" ],
        checkPath: ({node}) => !!isFlow(node) || (isImportDeclaration(node) ? "type" === node.importKind || "typeof" === node.importKind : isExportDeclaration(node) ? "type" === node.exportKind : !!isImportSpecifier(node) && ("type" === node.importKind || "typeof" === node.importKind))
      };
      exports.Flow = Flow;
      const RestProperty = {
        types: [ "RestElement" ],
        checkPath: path => path.parentPath && path.parentPath.isObjectPattern()
      };
      exports.RestProperty = RestProperty;
      const SpreadProperty = {
        types: [ "RestElement" ],
        checkPath: path => path.parentPath && path.parentPath.isObjectExpression()
      };
      exports.SpreadProperty = SpreadProperty;
      exports.ExistentialTypeParam = {
        types: [ "ExistsTypeAnnotation" ]
      };
      exports.NumericLiteralTypeAnnotation = {
        types: [ "NumberLiteralTypeAnnotation" ]
      };
      const ForAwaitStatement = {
        types: [ "ForOfStatement" ],
        checkPath: ({node}) => !0 === node.await
      };
      exports.ForAwaitStatement = ForAwaitStatement;
    },
    8129: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._containerInsert = function(from, nodes) {
        this.updateSiblingKeys(from, nodes.length);
        const paths = [];
        this.container.splice(from, 0, ...nodes);
        for (let i = 0; i < nodes.length; i++) {
          const to = from + i, path = this.getSibling(to);
          paths.push(path), this.context && this.context.queue && path.pushContext(this.context);
        }
        const contexts = this._getQueueContexts();
        for (const path of paths) {
          path.setScope(), path.debug("Inserted.");
          for (const context of contexts) context.maybeQueue(path, !0);
        }
        return paths;
      }, exports._containerInsertAfter = function(nodes) {
        return this._containerInsert(this.key + 1, nodes);
      }, exports._containerInsertBefore = function(nodes) {
        return this._containerInsert(this.key, nodes);
      }, exports._verifyNodeList = function(nodes) {
        if (!nodes) return [];
        Array.isArray(nodes) || (nodes = [ nodes ]);
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          let msg;
          if (node ? "object" != typeof node ? msg = "contains a non-object node" : node.type ? node instanceof _index.default && (msg = "has a NodePath when it expected a raw object") : msg = "without a type" : msg = "has falsy node", 
          msg) {
            const type = Array.isArray(node) ? "array" : typeof node;
            throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
          }
        }
        return nodes;
      }, exports.hoist = function(scope = this.scope) {
        return new _hoister.default(this, scope).run();
      }, exports.insertAfter = function(nodes_) {
        if (this._assertUnremoved(), this.isSequenceExpression()) return last(this.get("expressions")).insertAfter(nodes_);
        const nodes = this._verifyNodeList(nodes_), {parentPath} = this;
        if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) return parentPath.insertAfter(nodes.map((node => isExpression(node) ? expressionStatement(node) : node)));
        if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && "init" === this.key) {
          if (this.node) {
            const node = this.node;
            let {scope} = this;
            if (scope.path.isPattern()) return assertExpression(node), this.replaceWith(callExpression(arrowFunctionExpression([], node), [])), 
            this.get("callee.body").insertAfter(nodes), [ this ];
            if (isHiddenInSequenceExpression(this)) nodes.unshift(node); else if (isCallExpression(node) && isSuper(node.callee)) nodes.unshift(node), 
            nodes.push(thisExpression()); else if (function(node, scope) {
              if (!isAssignmentExpression(node) || !isIdentifier(node.left)) return !1;
              const blockScope = scope.getBlockParent();
              return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
            }(node, scope)) nodes.unshift(node), nodes.push(cloneNode(node.left)); else if (scope.isPure(node, !0)) nodes.push(node); else {
              parentPath.isMethod({
                computed: !0,
                key: node
              }) && (scope = scope.parent);
              const temp = scope.generateDeclaredUidIdentifier();
              nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node))), 
              nodes.push(expressionStatement(cloneNode(temp)));
            }
          }
          return this.replaceExpressionWithStatements(nodes);
        }
        if (Array.isArray(this.container)) return this._containerInsertAfter(nodes);
        if (this.isStatementOrBlock()) {
          const node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || null != node.expression);
          return this.replaceWith(blockStatement(shouldInsertCurrentNode ? [ node ] : [])), 
          this.pushContainer("body", nodes);
        }
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }, exports.insertBefore = function(nodes_) {
        this._assertUnremoved();
        const nodes = this._verifyNodeList(nodes_), {parentPath} = this;
        if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) return parentPath.insertBefore(nodes);
        if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && "init" === this.key) return this.node && nodes.push(this.node), 
        this.replaceExpressionWithStatements(nodes);
        if (Array.isArray(this.container)) return this._containerInsertBefore(nodes);
        if (this.isStatementOrBlock()) {
          const node = this.node, shouldInsertCurrentNode = node && (!this.isExpressionStatement() || null != node.expression);
          return this.replaceWith(blockStatement(shouldInsertCurrentNode ? [ node ] : [])), 
          this.unshiftContainer("body", nodes);
        }
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }, exports.pushContainer = function(listKey, nodes) {
        this._assertUnremoved();
        const verifiedNodes = this._verifyNodeList(nodes), container = this.node[listKey];
        return _index.default.get({
          parentPath: this,
          parent: this.node,
          container,
          listKey,
          key: container.length
        }).setContext(this.context).replaceWithMultiple(verifiedNodes);
      }, exports.unshiftContainer = function(listKey, nodes) {
        this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
        return _index.default.get({
          parentPath: this,
          parent: this.node,
          container: this.node[listKey],
          listKey,
          key: 0
        }).setContext(this.context)._containerInsertBefore(nodes);
      }, exports.updateSiblingKeys = function(fromIndex, incrementBy) {
        if (!this.parent) return;
        const paths = _cache.path.get(this.parent);
        for (const [, path] of paths) path.key >= fromIndex && (path.key += incrementBy);
      };
      var _cache = __webpack_require__(732), _hoister = __webpack_require__(9380), _index = __webpack_require__(2969), _t = __webpack_require__(8218);
      const {arrowFunctionExpression, assertExpression, assignmentExpression, blockStatement, callExpression, cloneNode, expressionStatement, isAssignmentExpression, isCallExpression, isExpression, isIdentifier, isSequenceExpression, isSuper, thisExpression} = _t;
      const last = arr => arr[arr.length - 1];
      function isHiddenInSequenceExpression(path) {
        return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
      }
    },
    2052: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._assertUnremoved = function() {
        if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }, exports._callRemovalHooks = function() {
        for (const fn of _removalHooks.hooks) if (fn(this, this.parentPath)) return !0;
      }, exports._markRemoved = function() {
        this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED, this.parent && _cache.path.get(this.parent).delete(this.node);
        this.node = null;
      }, exports._remove = function() {
        Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
      }, exports._removeFromScope = function() {
        const bindings = this.getBindingIdentifiers();
        Object.keys(bindings).forEach((name => this.scope.removeBinding(name)));
      }, exports.remove = function() {
        var _this$opts;
        this._assertUnremoved(), this.resync(), null != (_this$opts = this.opts) && _this$opts.noScope || this._removeFromScope();
        if (this._callRemovalHooks()) return void this._markRemoved();
        this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
      };
      var _removalHooks = __webpack_require__(1233), _cache = __webpack_require__(732), _index = __webpack_require__(2969);
    },
    23: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports._replaceWith = function(node) {
        var _pathCache$get2;
        if (!this.container) throw new ReferenceError("Container is falsy");
        this.inList ? validate(this.parent, this.key, [ node ]) : validate(this.parent, this.key, node);
        this.debug(`Replace with ${null == node ? void 0 : node.type}`), null == (_pathCache$get2 = _cache.path.get(this.parent)) || _pathCache$get2.set(node, this).delete(this.node), 
        this.node = this.container[this.key] = node;
      }, exports.replaceExpressionWithStatements = function(nodes) {
        this.resync();
        const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);
        if (nodesAsSequenceExpression) return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
        const functionParent = this.getFunctionParent(), isParentAsync = null == functionParent ? void 0 : functionParent.is("async"), isParentGenerator = null == functionParent ? void 0 : functionParent.is("generator"), container = arrowFunctionExpression([], blockStatement(nodes));
        this.replaceWith(callExpression(container, []));
        const callee = this.get("callee");
        (0, _helperHoistVariables.default)(callee.get("body"), (id => {
          this.scope.push({
            id
          });
        }), "var");
        const completionRecords = this.get("callee").getCompletionRecords();
        for (const path of completionRecords) {
          if (!path.isExpressionStatement()) continue;
          const loop = path.findParent((path => path.isLoop()));
          if (loop) {
            let uid = loop.getData("expressionReplacementReturnUid");
            uid ? uid = identifier(uid.name) : (uid = callee.scope.generateDeclaredUidIdentifier("ret"), 
            callee.get("body").pushContainer("body", returnStatement(cloneNode(uid))), loop.setData("expressionReplacementReturnUid", uid)), 
            path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
          } else path.replaceWith(returnStatement(path.node.expression));
        }
        callee.arrowFunctionToExpression();
        const newCallee = callee, needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES), needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
        needToAwaitFunction && (newCallee.set("async", !0), needToYieldFunction || this.replaceWith(awaitExpression(this.node)));
        needToYieldFunction && (newCallee.set("generator", !0), this.replaceWith(yieldExpression(this.node, !0)));
        return newCallee.get("body.body");
      }, exports.replaceInline = function(nodes) {
        if (this.resync(), Array.isArray(nodes)) {
          if (Array.isArray(this.container)) {
            nodes = this._verifyNodeList(nodes);
            const paths = this._containerInsertAfter(nodes);
            return this.remove(), paths;
          }
          return this.replaceWithMultiple(nodes);
        }
        return this.replaceWith(nodes);
      }, exports.replaceWith = function(replacement) {
        if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
        replacement instanceof _index2.default && (replacement = replacement.node);
        if (!replacement) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
        if (this.node === replacement) return [ this ];
        if (this.isProgram() && !isProgram(replacement)) throw new Error("You can only replace a Program root node with another Program node");
        if (Array.isArray(replacement)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
        if ("string" == typeof replacement) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
        let nodePath = "";
        this.isNodeType("Statement") && isExpression(replacement) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(replacement) || this.parentPath.isExportDefaultDeclaration() || (replacement = expressionStatement(replacement), 
        nodePath = "expression"));
        if (this.isNodeType("Expression") && isStatement(replacement) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) return this.replaceExpressionWithStatements([ replacement ]);
        const oldNode = this.node;
        oldNode && (inheritsComments(replacement, oldNode), removeComments(oldNode));
        return this._replaceWith(replacement), this.type = replacement.type, this.setScope(), 
        this.requeue(), [ nodePath ? this.get(nodePath) : this ];
      }, exports.replaceWithMultiple = function(nodes) {
        var _pathCache$get;
        this.resync(), nodes = this._verifyNodeList(nodes), inheritLeadingComments(nodes[0], this.node), 
        inheritTrailingComments(nodes[nodes.length - 1], this.node), null == (_pathCache$get = _cache.path.get(this.parent)) || _pathCache$get.delete(this.node), 
        this.node = this.container[this.key] = null;
        const paths = this.insertAfter(nodes);
        this.node ? this.requeue() : this.remove();
        return paths;
      }, exports.replaceWithSourceString = function(replacement) {
        this.resync();
        try {
          replacement = `(${replacement})`, replacement = (0, _parser.parse)(replacement);
        } catch (err) {
          const loc = err.loc;
          throw loc && (err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          }), err.code = "BABEL_REPLACE_SOURCE_ERROR"), err;
        }
        return replacement = replacement.program.body[0].expression, _index.default.removeProperties(replacement), 
        this.replaceWith(replacement);
      };
      var _codeFrame = __webpack_require__(4709), _index = __webpack_require__(9838), _index2 = __webpack_require__(2969), _cache = __webpack_require__(732), _parser = __webpack_require__(3834), _t = __webpack_require__(8218), _helperHoistVariables = __webpack_require__(9061);
      const {FUNCTION_TYPES, arrowFunctionExpression, assignmentExpression, awaitExpression, blockStatement, callExpression, cloneNode, expressionStatement, identifier, inheritLeadingComments, inheritTrailingComments, inheritsComments, isExpression, isProgram, isStatement, removeComments, returnStatement, toSequenceExpression, validate, yieldExpression} = _t;
    },
    8287: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      exports.default = class {
        constructor({identifier, scope, path, kind}) {
          this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, 
          this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, 
          this.references = 0, this.identifier = identifier, this.scope = scope, this.path = path, 
          this.kind = kind, this.clearValue();
        }
        deoptValue() {
          this.clearValue(), this.hasDeoptedValue = !0;
        }
        setValue(value) {
          this.hasDeoptedValue || (this.hasValue = !0, this.value = value);
        }
        clearValue() {
          this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
        }
        reassign(path) {
          this.constant = !1, -1 === this.constantViolations.indexOf(path) && this.constantViolations.push(path);
        }
        reference(path) {
          -1 === this.referencePaths.indexOf(path) && (this.referenced = !0, this.references++, 
          this.referencePaths.push(path));
        }
        dereference() {
          this.references--, this.referenced = !!this.references;
        }
      };
    },
    2570: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _renamer = __webpack_require__(1669), _index = __webpack_require__(9838), _binding = __webpack_require__(8287), _globals = __webpack_require__(1272), _t = __webpack_require__(8218), _cache = __webpack_require__(732);
      const {NOT_LOCAL_BINDING, callExpression, cloneNode, getBindingIdentifiers, identifier, isArrayExpression, isBinary, isClass, isClassBody, isClassDeclaration, isExportAllDeclaration, isExportDefaultDeclaration, isExportNamedDeclaration, isFunctionDeclaration, isIdentifier, isImportDeclaration, isLiteral, isMethod, isModuleDeclaration, isModuleSpecifier, isObjectExpression, isProperty, isPureish, isSuper, isTaggedTemplateExpression, isTemplateLiteral, isThisExpression, isUnaryExpression, isVariableDeclaration, matchesPattern, memberExpression, numericLiteral, toIdentifier, unaryExpression, variableDeclaration, variableDeclarator, isRecordExpression, isTupleExpression, isObjectProperty, isTopicReference, isMetaProperty, isPrivateName} = _t;
      function gatherNodeParts(node, parts) {
        switch (null == node ? void 0 : node.type) {
         default:
          if (isModuleDeclaration(node)) if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) gatherNodeParts(node.source, parts); else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) for (const e of node.specifiers) gatherNodeParts(e, parts); else (isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration && gatherNodeParts(node.declaration, parts); else isModuleSpecifier(node) ? gatherNodeParts(node.local, parts) : isLiteral(node) && parts.push(node.value);
          break;

         case "MemberExpression":
         case "OptionalMemberExpression":
         case "JSXMemberExpression":
          gatherNodeParts(node.object, parts), gatherNodeParts(node.property, parts);
          break;

         case "Identifier":
         case "JSXIdentifier":
         case "JSXOpeningElement":
          parts.push(node.name);
          break;

         case "CallExpression":
         case "OptionalCallExpression":
         case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;

         case "ObjectExpression":
         case "ObjectPattern":
          for (const e of node.properties) gatherNodeParts(e, parts);
          break;

         case "SpreadElement":
         case "RestElement":
         case "UnaryExpression":
         case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;

         case "ObjectProperty":
         case "ObjectMethod":
         case "ClassProperty":
         case "ClassMethod":
         case "ClassPrivateProperty":
         case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;

         case "ThisExpression":
          parts.push("this");
          break;

         case "Super":
          parts.push("super");
          break;

         case "Import":
          parts.push("import");
          break;

         case "DoExpression":
          parts.push("do");
          break;

         case "YieldExpression":
          parts.push("yield"), gatherNodeParts(node.argument, parts);
          break;

         case "AwaitExpression":
          parts.push("await"), gatherNodeParts(node.argument, parts);
          break;

         case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;

         case "VariableDeclarator":
         case "FunctionExpression":
         case "FunctionDeclaration":
         case "ClassExpression":
         case "ClassDeclaration":
         case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;

         case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;

         case "MetaProperty":
          gatherNodeParts(node.meta, parts), gatherNodeParts(node.property, parts);
          break;

         case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;

         case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;

         case "JSXOpeningFragment":
          parts.push("Fragment");
          break;

         case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts), gatherNodeParts(node.name, parts);
        }
      }
      const collectorVisitor = {
        ForStatement(path) {
          const declar = path.get("init");
          if (declar.isVar()) {
            const {scope} = path;
            (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", declar);
          }
        },
        Declaration(path) {
          if (path.isBlockScoped()) return;
          if (path.isImportDeclaration()) return;
          if (path.isExportDeclaration()) return;
          (path.scope.getFunctionParent() || path.scope.getProgramParent()).registerDeclaration(path);
        },
        ImportDeclaration(path) {
          path.scope.getBlockParent().registerDeclaration(path);
        },
        ReferencedIdentifier(path, state) {
          state.references.push(path);
        },
        ForXStatement(path, state) {
          const left = path.get("left");
          if (left.isPattern() || left.isIdentifier()) state.constantViolations.push(path); else if (left.isVar()) {
            const {scope} = path;
            (scope.getFunctionParent() || scope.getProgramParent()).registerBinding("var", left);
          }
        },
        ExportDeclaration: {
          exit(path) {
            const {node, scope} = path;
            if (isExportAllDeclaration(node)) return;
            const declar = node.declaration;
            if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
              const id = declar.id;
              if (!id) return;
              const binding = scope.getBinding(id.name);
              null == binding || binding.reference(path);
            } else if (isVariableDeclaration(declar)) for (const decl of declar.declarations) for (const name of Object.keys(getBindingIdentifiers(decl))) {
              const binding = scope.getBinding(name);
              null == binding || binding.reference(path);
            }
          }
        },
        LabeledStatement(path) {
          path.scope.getBlockParent().registerDeclaration(path);
        },
        AssignmentExpression(path, state) {
          state.assignments.push(path);
        },
        UpdateExpression(path, state) {
          state.constantViolations.push(path);
        },
        UnaryExpression(path, state) {
          "delete" === path.node.operator && state.constantViolations.push(path);
        },
        BlockScoped(path) {
          let scope = path.scope;
          scope.path === path && (scope = scope.parent);
          if (scope.getBlockParent().registerDeclaration(path), path.isClassDeclaration() && path.node.id) {
            const name = path.node.id.name;
            path.scope.bindings[name] = path.scope.parent.getBinding(name);
          }
        },
        CatchClause(path) {
          path.scope.registerBinding("let", path);
        },
        Function(path) {
          const params = path.get("params");
          for (const param of params) path.scope.registerBinding("param", param);
          path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path.get("id"), path);
        },
        ClassExpression(path) {
          path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path);
        }
      };
      let uid = 0;
      class Scope {
        constructor(path) {
          this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, 
          this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, 
          this.uids = void 0, this.data = void 0, this.crawling = void 0;
          const {node} = path, cached = _cache.scope.get(node);
          if ((null == cached ? void 0 : cached.path) === path) return cached;
          _cache.scope.set(node, this), this.uid = uid++, this.block = node, this.path = path, 
          this.labels = new Map, this.inited = !1;
        }
        get parent() {
          var _parent;
          let parent, path = this.path;
          do {
            const isKey = "key" === path.key;
            path = path.parentPath, isKey && path.isMethod() && (path = path.parentPath), path && path.isScope() && (parent = path);
          } while (path && !parent);
          return null == (_parent = parent) ? void 0 : _parent.scope;
        }
        get parentBlock() {
          return this.path.parent;
        }
        get hub() {
          return this.path.hub;
        }
        traverse(node, opts, state) {
          (0, _index.default)(node, opts, this, state, this.path);
        }
        generateDeclaredUidIdentifier(name) {
          const id = this.generateUidIdentifier(name);
          return this.push({
            id
          }), cloneNode(id);
        }
        generateUidIdentifier(name) {
          return identifier(this.generateUid(name));
        }
        generateUid(name = "temp") {
          let uid;
          name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
          let i = 1;
          do {
            uid = this._generateUid(name, i), i++;
          } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
          const program = this.getProgramParent();
          return program.references[uid] = !0, program.uids[uid] = !0, uid;
        }
        _generateUid(name, i) {
          let id = name;
          return i > 1 && (id += i), `_${id}`;
        }
        generateUidBasedOnNode(node, defaultName) {
          const parts = [];
          gatherNodeParts(node, parts);
          let id = parts.join("$");
          return id = id.replace(/^_/, "") || defaultName || "ref", this.generateUid(id.slice(0, 20));
        }
        generateUidIdentifierBasedOnNode(node, defaultName) {
          return identifier(this.generateUidBasedOnNode(node, defaultName));
        }
        isStatic(node) {
          if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) return !0;
          if (isIdentifier(node)) {
            const binding = this.getBinding(node.name);
            return binding ? binding.constant : this.hasBinding(node.name);
          }
          return !1;
        }
        maybeGenerateMemoised(node, dontPush) {
          if (this.isStatic(node)) return null;
          {
            const id = this.generateUidIdentifierBasedOnNode(node);
            return dontPush ? id : (this.push({
              id
            }), cloneNode(id));
          }
        }
        checkBlockScopedCollisions(local, kind, name, id) {
          if ("param" === kind) return;
          if ("local" === local.kind) return;
          if ("let" === kind || "let" === local.kind || "const" === local.kind || "module" === local.kind || "param" === local.kind && "const" === kind) throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
        }
        rename(oldName, newName, block) {
          const binding = this.getBinding(oldName);
          if (binding) return newName = newName || this.generateUidIdentifier(oldName).name, 
          new _renamer.default(binding, oldName, newName).rename(block);
        }
        _renameFromMap(map, oldName, newName, value) {
          map[oldName] && (map[newName] = value, map[oldName] = null);
        }
        dump() {
          const sep = "-".repeat(60);
          console.log(sep);
          let scope = this;
          do {
            console.log("#", scope.block.type);
            for (const name of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name];
              console.log(" -", name, {
                constant: binding.constant,
                references: binding.references,
                violations: binding.constantViolations.length,
                kind: binding.kind
              });
            }
          } while (scope = scope.parent);
          console.log(sep);
        }
        toArray(node, i, arrayLikeIsIterable) {
          if (isIdentifier(node)) {
            const binding = this.getBinding(node.name);
            if (null != binding && binding.constant && binding.path.isGenericType("Array")) return node;
          }
          if (isArrayExpression(node)) return node;
          if (isIdentifier(node, {
            name: "arguments"
          })) return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [ node ]);
          let helperName;
          const args = [ node ];
          return !0 === i ? helperName = "toConsumableArray" : i ? (args.push(numericLiteral(i)), 
          helperName = "slicedToArray") : helperName = "toArray", arrayLikeIsIterable && (args.unshift(this.hub.addHelper(helperName)), 
          helperName = "maybeArrayLike"), callExpression(this.hub.addHelper(helperName), args);
        }
        hasLabel(name) {
          return !!this.getLabel(name);
        }
        getLabel(name) {
          return this.labels.get(name);
        }
        registerLabel(path) {
          this.labels.set(path.node.label.name, path);
        }
        registerDeclaration(path) {
          if (path.isLabeledStatement()) this.registerLabel(path); else if (path.isFunctionDeclaration()) this.registerBinding("hoisted", path.get("id"), path); else if (path.isVariableDeclaration()) {
            const declarations = path.get("declarations");
            for (const declar of declarations) this.registerBinding(path.node.kind, declar);
          } else if (path.isClassDeclaration()) {
            if (path.node.declare) return;
            this.registerBinding("let", path);
          } else if (path.isImportDeclaration()) {
            const specifiers = path.get("specifiers");
            for (const specifier of specifiers) this.registerBinding("module", specifier);
          } else if (path.isExportDeclaration()) {
            const declar = path.get("declaration");
            (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) && this.registerDeclaration(declar);
          } else this.registerBinding("unknown", path);
        }
        buildUndefinedNode() {
          return unaryExpression("void", numericLiteral(0), !0);
        }
        registerConstantViolation(path) {
          const ids = path.getBindingIdentifiers();
          for (const name of Object.keys(ids)) {
            const binding = this.getBinding(name);
            binding && binding.reassign(path);
          }
        }
        registerBinding(kind, path, bindingPath = path) {
          if (!kind) throw new ReferenceError("no `kind`");
          if (path.isVariableDeclaration()) {
            const declarators = path.get("declarations");
            for (const declar of declarators) this.registerBinding(kind, declar);
            return;
          }
          const parent = this.getProgramParent(), ids = path.getOuterBindingIdentifiers(!0);
          for (const name of Object.keys(ids)) {
            parent.references[name] = !0;
            for (const id of ids[name]) {
              const local = this.getOwnBinding(name);
              if (local) {
                if (local.identifier === id) continue;
                this.checkBlockScopedCollisions(local, kind, name, id);
              }
              local ? this.registerConstantViolation(bindingPath) : this.bindings[name] = new _binding.default({
                identifier: id,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
        addGlobal(node) {
          this.globals[node.name] = node;
        }
        hasUid(name) {
          let scope = this;
          do {
            if (scope.uids[name]) return !0;
          } while (scope = scope.parent);
          return !1;
        }
        hasGlobal(name) {
          let scope = this;
          do {
            if (scope.globals[name]) return !0;
          } while (scope = scope.parent);
          return !1;
        }
        hasReference(name) {
          return !!this.getProgramParent().references[name];
        }
        isPure(node, constantsOnly) {
          if (isIdentifier(node)) {
            const binding = this.getBinding(node.name);
            return !!binding && (!constantsOnly || binding.constant);
          }
          if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) return !0;
          var _node$decorators, _node$decorators2, _node$decorators3;
          if (isClass(node)) return !(node.superClass && !this.isPure(node.superClass, constantsOnly)) && (!((null == (_node$decorators = node.decorators) ? void 0 : _node$decorators.length) > 0) && this.isPure(node.body, constantsOnly));
          if (isClassBody(node)) {
            for (const method of node.body) if (!this.isPure(method, constantsOnly)) return !1;
            return !0;
          }
          if (isBinary(node)) return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
          if (isArrayExpression(node) || isTupleExpression(node)) {
            for (const elem of node.elements) if (null !== elem && !this.isPure(elem, constantsOnly)) return !1;
            return !0;
          }
          if (isObjectExpression(node) || isRecordExpression(node)) {
            for (const prop of node.properties) if (!this.isPure(prop, constantsOnly)) return !1;
            return !0;
          }
          if (isMethod(node)) return !(node.computed && !this.isPure(node.key, constantsOnly)) && !((null == (_node$decorators2 = node.decorators) ? void 0 : _node$decorators2.length) > 0);
          if (isProperty(node)) return !(node.computed && !this.isPure(node.key, constantsOnly)) && (!((null == (_node$decorators3 = node.decorators) ? void 0 : _node$decorators3.length) > 0) && !((isObjectProperty(node) || node.static) && null !== node.value && !this.isPure(node.value, constantsOnly)));
          if (isUnaryExpression(node)) return this.isPure(node.argument, constantsOnly);
          if (isTaggedTemplateExpression(node)) return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(node.quasi, constantsOnly);
          if (isTemplateLiteral(node)) {
            for (const expression of node.expressions) if (!this.isPure(expression, constantsOnly)) return !1;
            return !0;
          }
          return isPureish(node);
        }
        setData(key, val) {
          return this.data[key] = val;
        }
        getData(key) {
          let scope = this;
          do {
            const data = scope.data[key];
            if (null != data) return data;
          } while (scope = scope.parent);
        }
        removeData(key) {
          let scope = this;
          do {
            null != scope.data[key] && (scope.data[key] = null);
          } while (scope = scope.parent);
        }
        init() {
          this.inited || (this.inited = !0, this.crawl());
        }
        crawl() {
          const path = this.path;
          this.references = Object.create(null), this.bindings = Object.create(null), this.globals = Object.create(null), 
          this.uids = Object.create(null), this.data = Object.create(null);
          const programParent = this.getProgramParent();
          if (programParent.crawling) return;
          const state = {
            references: [],
            constantViolations: [],
            assignments: []
          };
          if (this.crawling = !0, "Program" !== path.type && collectorVisitor._exploded) {
            for (const visit of collectorVisitor.enter) visit(path, state);
            const typeVisitors = collectorVisitor[path.type];
            if (typeVisitors) for (const visit of typeVisitors.enter) visit(path, state);
          }
          path.traverse(collectorVisitor, state), this.crawling = !1;
          for (const path of state.assignments) {
            const ids = path.getBindingIdentifiers();
            for (const name of Object.keys(ids)) path.scope.getBinding(name) || programParent.addGlobal(ids[name]);
            path.scope.registerConstantViolation(path);
          }
          for (const ref of state.references) {
            const binding = ref.scope.getBinding(ref.node.name);
            binding ? binding.reference(ref) : programParent.addGlobal(ref.node);
          }
          for (const path of state.constantViolations) path.scope.registerConstantViolation(path);
        }
        push(opts) {
          let path = this.path;
          path.isBlockStatement() || path.isProgram() || (path = this.getBlockParent().path), 
          path.isSwitchStatement() && (path = (this.getFunctionParent() || this.getProgramParent()).path), 
          (path.isLoop() || path.isCatchClause() || path.isFunction()) && (path.ensureBlock(), 
          path = path.get("body"));
          const unique = opts.unique, kind = opts.kind || "var", blockHoist = null == opts._blockHoist ? 2 : opts._blockHoist, dataKey = `declaration:${kind}:${blockHoist}`;
          let declarPath = !unique && path.getData(dataKey);
          if (!declarPath) {
            const declar = variableDeclaration(kind, []);
            declar._blockHoist = blockHoist, [declarPath] = path.unshiftContainer("body", [ declar ]), 
            unique || path.setData(dataKey, declarPath);
          }
          const declarator = variableDeclarator(opts.id, opts.init), len = declarPath.node.declarations.push(declarator);
          path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
        }
        getProgramParent() {
          let scope = this;
          do {
            if (scope.path.isProgram()) return scope;
          } while (scope = scope.parent);
          throw new Error("Couldn't find a Program");
        }
        getFunctionParent() {
          let scope = this;
          do {
            if (scope.path.isFunctionParent()) return scope;
          } while (scope = scope.parent);
          return null;
        }
        getBlockParent() {
          let scope = this;
          do {
            if (scope.path.isBlockParent()) return scope;
          } while (scope = scope.parent);
          throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
        }
        getAllBindings() {
          const ids = Object.create(null);
          let scope = this;
          do {
            for (const key of Object.keys(scope.bindings)) key in ids == !1 && (ids[key] = scope.bindings[key]);
            scope = scope.parent;
          } while (scope);
          return ids;
        }
        getAllBindingsOfKind(...kinds) {
          const ids = Object.create(null);
          for (const kind of kinds) {
            let scope = this;
            do {
              for (const name of Object.keys(scope.bindings)) {
                const binding = scope.bindings[name];
                binding.kind === kind && (ids[name] = binding);
              }
              scope = scope.parent;
            } while (scope);
          }
          return ids;
        }
        bindingIdentifierEquals(name, node) {
          return this.getBindingIdentifier(name) === node;
        }
        getBinding(name) {
          let previousPath, scope = this;
          do {
            const binding = scope.getOwnBinding(name);
            var _previousPath;
            if (binding) {
              if (null == (_previousPath = previousPath) || !_previousPath.isPattern() || "param" === binding.kind || "local" === binding.kind) return binding;
            } else if (!binding && "arguments" === name && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) break;
            previousPath = scope.path;
          } while (scope = scope.parent);
        }
        getOwnBinding(name) {
          return this.bindings[name];
        }
        getBindingIdentifier(name) {
          var _this$getBinding;
          return null == (_this$getBinding = this.getBinding(name)) ? void 0 : _this$getBinding.identifier;
        }
        getOwnBindingIdentifier(name) {
          const binding = this.bindings[name];
          return null == binding ? void 0 : binding.identifier;
        }
        hasOwnBinding(name) {
          return !!this.getOwnBinding(name);
        }
        hasBinding(name, noGlobals) {
          return !!name && (!!this.hasOwnBinding(name) || (!!this.parentHasBinding(name, noGlobals) || (!!this.hasUid(name) || (!(noGlobals || !Scope.globals.includes(name)) || !(noGlobals || !Scope.contextVariables.includes(name))))));
        }
        parentHasBinding(name, noGlobals) {
          var _this$parent;
          return null == (_this$parent = this.parent) ? void 0 : _this$parent.hasBinding(name, noGlobals);
        }
        moveBindingTo(name, scope) {
          const info = this.getBinding(name);
          info && (info.scope.removeOwnBinding(name), info.scope = scope, scope.bindings[name] = info);
        }
        removeOwnBinding(name) {
          delete this.bindings[name];
        }
        removeBinding(name) {
          var _this$getBinding2;
          null == (_this$getBinding2 = this.getBinding(name)) || _this$getBinding2.scope.removeOwnBinding(name);
          let scope = this;
          do {
            scope.uids[name] && (scope.uids[name] = !1);
          } while (scope = scope.parent);
        }
      }
      exports.default = Scope, Scope.globals = Object.keys(_globals.builtin), Scope.contextVariables = [ "arguments", "undefined", "Infinity", "NaN" ];
    },
    1669: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      __webpack_require__(8287);
      var _helperSplitExportDeclaration = __webpack_require__(4170), _t = __webpack_require__(8218);
      const {VISITOR_KEYS, assignmentExpression, identifier, toExpression, variableDeclaration, variableDeclarator} = _t, renameVisitor = {
        ReferencedIdentifier({node}, state) {
          node.name === state.oldName && (node.name = state.newName);
        },
        Scope(path, state) {
          path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier) || function(path) {
            if (!path.isMethod() || !path.node.computed) return void path.skip();
            const keys = VISITOR_KEYS[path.type];
            for (const key of keys) "key" !== key && path.skipKey(key);
          }(path);
        },
        "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
          if (path.isVariableDeclaration()) return;
          const ids = path.getOuterBindingIdentifiers();
          for (const name in ids) name === state.oldName && (ids[name].name = state.newName);
        }
      };
      exports.default = class {
        constructor(binding, oldName, newName) {
          this.newName = newName, this.oldName = oldName, this.binding = binding;
        }
        maybeConvertFromExportDeclaration(parentDeclar) {
          const maybeExportDeclar = parentDeclar.parentPath;
          maybeExportDeclar.isExportDeclaration() && (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id || (0, 
          _helperSplitExportDeclaration.default)(maybeExportDeclar));
        }
        maybeConvertFromClassFunctionDeclaration(path) {}
        maybeConvertFromClassFunctionExpression(path) {}
        rename(block) {
          const {binding, oldName, newName} = this, {scope, path} = binding, parentDeclar = path.find((path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression()));
          if (parentDeclar) {
            parentDeclar.getOuterBindingIdentifiers()[oldName] === binding.identifier && this.maybeConvertFromExportDeclaration(parentDeclar);
          }
          const blockToTraverse = block || scope.block;
          "SwitchStatement" === (null == blockToTraverse ? void 0 : blockToTraverse.type) ? blockToTraverse.cases.forEach((c => {
            scope.traverse(c, renameVisitor, this);
          })) : scope.traverse(blockToTraverse, renameVisitor, this), block || (scope.removeOwnBinding(oldName), 
          scope.bindings[newName] = binding, this.binding.identifier.name = newName), parentDeclar && (this.maybeConvertFromClassFunctionDeclaration(parentDeclar), 
          this.maybeConvertFromClassFunctionExpression(parentDeclar));
        }
      };
    },
    6033: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.traverseNode = function(node, opts, scope, state, path, skipKeys) {
        const keys = VISITOR_KEYS[node.type];
        if (!keys) return !1;
        const context = new _context.default(scope, opts, state, path);
        for (const key of keys) if ((!skipKeys || !skipKeys[key]) && context.visit(node, key)) return !0;
        return !1;
      };
      var _context = __webpack_require__(6617), _t = __webpack_require__(8218);
      const {VISITOR_KEYS} = _t;
    },
    1169: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.explode = explode, exports.merge = function(visitors, states = [], wrapper) {
        const rootVisitor = {};
        for (let i = 0; i < visitors.length; i++) {
          const visitor = visitors[i], state = states[i];
          explode(visitor);
          for (const type of Object.keys(visitor)) {
            let visitorType = visitor[type];
            (state || wrapper) && (visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper));
            mergePair(rootVisitor[type] = rootVisitor[type] || {}, visitorType);
          }
        }
        return rootVisitor;
      }, exports.verify = verify;
      var virtualTypes = __webpack_require__(4387), _t = __webpack_require__(8218);
      const {DEPRECATED_KEYS, FLIPPED_ALIAS_KEYS, TYPES} = _t;
      function explode(visitor) {
        if (visitor._exploded) return visitor;
        visitor._exploded = !0;
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType)) continue;
          const parts = nodeType.split("|");
          if (1 === parts.length) continue;
          const fns = visitor[nodeType];
          delete visitor[nodeType];
          for (const part of parts) visitor[part] = fns;
        }
        verify(visitor), delete visitor.__esModule, function(obj) {
          for (const key of Object.keys(obj)) {
            if (shouldIgnoreKey(key)) continue;
            const fns = obj[key];
            "function" == typeof fns && (obj[key] = {
              enter: fns
            });
          }
        }(visitor), ensureCallbackArrays(visitor);
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType)) continue;
          const wrapper = virtualTypes[nodeType];
          if (!wrapper) continue;
          const fns = visitor[nodeType];
          for (const type of Object.keys(fns)) fns[type] = wrapCheck(wrapper, fns[type]);
          if (delete visitor[nodeType], wrapper.types) for (const type of wrapper.types) visitor[type] ? mergePair(visitor[type], fns) : visitor[type] = fns; else mergePair(visitor, fns);
        }
        for (const nodeType of Object.keys(visitor)) {
          if (shouldIgnoreKey(nodeType)) continue;
          const fns = visitor[nodeType];
          let aliases = FLIPPED_ALIAS_KEYS[nodeType];
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          if (deprecatedKey && (console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`), 
          aliases = [ deprecatedKey ]), aliases) {
            delete visitor[nodeType];
            for (const alias of aliases) {
              const existing = visitor[alias];
              existing ? mergePair(existing, fns) : visitor[alias] = Object.assign({}, fns);
            }
          }
        }
        for (const nodeType of Object.keys(visitor)) shouldIgnoreKey(nodeType) || ensureCallbackArrays(visitor[nodeType]);
        return visitor;
      }
      function verify(visitor) {
        if (!visitor._verified) {
          if ("function" == typeof visitor) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
          for (const nodeType of Object.keys(visitor)) {
            if ("enter" !== nodeType && "exit" !== nodeType || validateVisitorMethods(nodeType, visitor[nodeType]), 
            shouldIgnoreKey(nodeType)) continue;
            if (TYPES.indexOf(nodeType) < 0) throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
            const visitors = visitor[nodeType];
            if ("object" == typeof visitors) for (const visitorKey of Object.keys(visitors)) {
              if ("enter" !== visitorKey && "exit" !== visitorKey) throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            }
          }
          visitor._verified = !0;
        }
      }
      function validateVisitorMethods(path, val) {
        const fns = [].concat(val);
        for (const fn of fns) if ("function" != typeof fn) throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
      }
      function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
        const newVisitor = {};
        for (const key of Object.keys(oldVisitor)) {
          let fns = oldVisitor[key];
          Array.isArray(fns) && (fns = fns.map((function(fn) {
            let newFn = fn;
            return state && (newFn = function(path) {
              return fn.call(state, path, state);
            }), wrapper && (newFn = wrapper(state.key, key, newFn)), newFn !== fn && (newFn.toString = () => fn.toString()), 
            newFn;
          })), newVisitor[key] = fns);
        }
        return newVisitor;
      }
      function ensureCallbackArrays(obj) {
        obj.enter && !Array.isArray(obj.enter) && (obj.enter = [ obj.enter ]), obj.exit && !Array.isArray(obj.exit) && (obj.exit = [ obj.exit ]);
      }
      function wrapCheck(wrapper, fn) {
        const newFn = function(path) {
          if (wrapper.checkPath(path)) return fn.apply(this, arguments);
        };
        return newFn.toString = () => fn.toString(), newFn;
      }
      function shouldIgnoreKey(key) {
        return "_" === key[0] || ("enter" === key || "exit" === key || "shouldSkip" === key || ("denylist" === key || "noScope" === key || "skipKeys" === key || "blacklist" === key));
      }
      function mergePair(dest, src) {
        for (const key of Object.keys(src)) dest[key] = [].concat(dest[key] || [], src[key]);
      }
    },
    245: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        if (!(0, _isNode.default)(node)) {
          var _node$type;
          const type = null != (_node$type = null == node ? void 0 : node.type) ? _node$type : JSON.stringify(node);
          throw new TypeError(`Not a valid node of type "${type}"`);
        }
      };
      var _isNode = __webpack_require__(8523);
    },
    7133: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.assertAccessor = function(node, opts) {
        assert("Accessor", node, opts);
      }, exports.assertAnyTypeAnnotation = function(node, opts) {
        assert("AnyTypeAnnotation", node, opts);
      }, exports.assertArgumentPlaceholder = function(node, opts) {
        assert("ArgumentPlaceholder", node, opts);
      }, exports.assertArrayExpression = function(node, opts) {
        assert("ArrayExpression", node, opts);
      }, exports.assertArrayPattern = function(node, opts) {
        assert("ArrayPattern", node, opts);
      }, exports.assertArrayTypeAnnotation = function(node, opts) {
        assert("ArrayTypeAnnotation", node, opts);
      }, exports.assertArrowFunctionExpression = function(node, opts) {
        assert("ArrowFunctionExpression", node, opts);
      }, exports.assertAssignmentExpression = function(node, opts) {
        assert("AssignmentExpression", node, opts);
      }, exports.assertAssignmentPattern = function(node, opts) {
        assert("AssignmentPattern", node, opts);
      }, exports.assertAwaitExpression = function(node, opts) {
        assert("AwaitExpression", node, opts);
      }, exports.assertBigIntLiteral = function(node, opts) {
        assert("BigIntLiteral", node, opts);
      }, exports.assertBinary = function(node, opts) {
        assert("Binary", node, opts);
      }, exports.assertBinaryExpression = function(node, opts) {
        assert("BinaryExpression", node, opts);
      }, exports.assertBindExpression = function(node, opts) {
        assert("BindExpression", node, opts);
      }, exports.assertBlock = function(node, opts) {
        assert("Block", node, opts);
      }, exports.assertBlockParent = function(node, opts) {
        assert("BlockParent", node, opts);
      }, exports.assertBlockStatement = function(node, opts) {
        assert("BlockStatement", node, opts);
      }, exports.assertBooleanLiteral = function(node, opts) {
        assert("BooleanLiteral", node, opts);
      }, exports.assertBooleanLiteralTypeAnnotation = function(node, opts) {
        assert("BooleanLiteralTypeAnnotation", node, opts);
      }, exports.assertBooleanTypeAnnotation = function(node, opts) {
        assert("BooleanTypeAnnotation", node, opts);
      }, exports.assertBreakStatement = function(node, opts) {
        assert("BreakStatement", node, opts);
      }, exports.assertCallExpression = function(node, opts) {
        assert("CallExpression", node, opts);
      }, exports.assertCatchClause = function(node, opts) {
        assert("CatchClause", node, opts);
      }, exports.assertClass = function(node, opts) {
        assert("Class", node, opts);
      }, exports.assertClassAccessorProperty = function(node, opts) {
        assert("ClassAccessorProperty", node, opts);
      }, exports.assertClassBody = function(node, opts) {
        assert("ClassBody", node, opts);
      }, exports.assertClassDeclaration = function(node, opts) {
        assert("ClassDeclaration", node, opts);
      }, exports.assertClassExpression = function(node, opts) {
        assert("ClassExpression", node, opts);
      }, exports.assertClassImplements = function(node, opts) {
        assert("ClassImplements", node, opts);
      }, exports.assertClassMethod = function(node, opts) {
        assert("ClassMethod", node, opts);
      }, exports.assertClassPrivateMethod = function(node, opts) {
        assert("ClassPrivateMethod", node, opts);
      }, exports.assertClassPrivateProperty = function(node, opts) {
        assert("ClassPrivateProperty", node, opts);
      }, exports.assertClassProperty = function(node, opts) {
        assert("ClassProperty", node, opts);
      }, exports.assertCompletionStatement = function(node, opts) {
        assert("CompletionStatement", node, opts);
      }, exports.assertConditional = function(node, opts) {
        assert("Conditional", node, opts);
      }, exports.assertConditionalExpression = function(node, opts) {
        assert("ConditionalExpression", node, opts);
      }, exports.assertContinueStatement = function(node, opts) {
        assert("ContinueStatement", node, opts);
      }, exports.assertDebuggerStatement = function(node, opts) {
        assert("DebuggerStatement", node, opts);
      }, exports.assertDecimalLiteral = function(node, opts) {
        assert("DecimalLiteral", node, opts);
      }, exports.assertDeclaration = function(node, opts) {
        assert("Declaration", node, opts);
      }, exports.assertDeclareClass = function(node, opts) {
        assert("DeclareClass", node, opts);
      }, exports.assertDeclareExportAllDeclaration = function(node, opts) {
        assert("DeclareExportAllDeclaration", node, opts);
      }, exports.assertDeclareExportDeclaration = function(node, opts) {
        assert("DeclareExportDeclaration", node, opts);
      }, exports.assertDeclareFunction = function(node, opts) {
        assert("DeclareFunction", node, opts);
      }, exports.assertDeclareInterface = function(node, opts) {
        assert("DeclareInterface", node, opts);
      }, exports.assertDeclareModule = function(node, opts) {
        assert("DeclareModule", node, opts);
      }, exports.assertDeclareModuleExports = function(node, opts) {
        assert("DeclareModuleExports", node, opts);
      }, exports.assertDeclareOpaqueType = function(node, opts) {
        assert("DeclareOpaqueType", node, opts);
      }, exports.assertDeclareTypeAlias = function(node, opts) {
        assert("DeclareTypeAlias", node, opts);
      }, exports.assertDeclareVariable = function(node, opts) {
        assert("DeclareVariable", node, opts);
      }, exports.assertDeclaredPredicate = function(node, opts) {
        assert("DeclaredPredicate", node, opts);
      }, exports.assertDecorator = function(node, opts) {
        assert("Decorator", node, opts);
      }, exports.assertDirective = function(node, opts) {
        assert("Directive", node, opts);
      }, exports.assertDirectiveLiteral = function(node, opts) {
        assert("DirectiveLiteral", node, opts);
      }, exports.assertDoExpression = function(node, opts) {
        assert("DoExpression", node, opts);
      }, exports.assertDoWhileStatement = function(node, opts) {
        assert("DoWhileStatement", node, opts);
      }, exports.assertEmptyStatement = function(node, opts) {
        assert("EmptyStatement", node, opts);
      }, exports.assertEmptyTypeAnnotation = function(node, opts) {
        assert("EmptyTypeAnnotation", node, opts);
      }, exports.assertEnumBody = function(node, opts) {
        assert("EnumBody", node, opts);
      }, exports.assertEnumBooleanBody = function(node, opts) {
        assert("EnumBooleanBody", node, opts);
      }, exports.assertEnumBooleanMember = function(node, opts) {
        assert("EnumBooleanMember", node, opts);
      }, exports.assertEnumDeclaration = function(node, opts) {
        assert("EnumDeclaration", node, opts);
      }, exports.assertEnumDefaultedMember = function(node, opts) {
        assert("EnumDefaultedMember", node, opts);
      }, exports.assertEnumMember = function(node, opts) {
        assert("EnumMember", node, opts);
      }, exports.assertEnumNumberBody = function(node, opts) {
        assert("EnumNumberBody", node, opts);
      }, exports.assertEnumNumberMember = function(node, opts) {
        assert("EnumNumberMember", node, opts);
      }, exports.assertEnumStringBody = function(node, opts) {
        assert("EnumStringBody", node, opts);
      }, exports.assertEnumStringMember = function(node, opts) {
        assert("EnumStringMember", node, opts);
      }, exports.assertEnumSymbolBody = function(node, opts) {
        assert("EnumSymbolBody", node, opts);
      }, exports.assertExistsTypeAnnotation = function(node, opts) {
        assert("ExistsTypeAnnotation", node, opts);
      }, exports.assertExportAllDeclaration = function(node, opts) {
        assert("ExportAllDeclaration", node, opts);
      }, exports.assertExportDeclaration = function(node, opts) {
        assert("ExportDeclaration", node, opts);
      }, exports.assertExportDefaultDeclaration = function(node, opts) {
        assert("ExportDefaultDeclaration", node, opts);
      }, exports.assertExportDefaultSpecifier = function(node, opts) {
        assert("ExportDefaultSpecifier", node, opts);
      }, exports.assertExportNamedDeclaration = function(node, opts) {
        assert("ExportNamedDeclaration", node, opts);
      }, exports.assertExportNamespaceSpecifier = function(node, opts) {
        assert("ExportNamespaceSpecifier", node, opts);
      }, exports.assertExportSpecifier = function(node, opts) {
        assert("ExportSpecifier", node, opts);
      }, exports.assertExpression = function(node, opts) {
        assert("Expression", node, opts);
      }, exports.assertExpressionStatement = function(node, opts) {
        assert("ExpressionStatement", node, opts);
      }, exports.assertExpressionWrapper = function(node, opts) {
        assert("ExpressionWrapper", node, opts);
      }, exports.assertFile = function(node, opts) {
        assert("File", node, opts);
      }, exports.assertFlow = function(node, opts) {
        assert("Flow", node, opts);
      }, exports.assertFlowBaseAnnotation = function(node, opts) {
        assert("FlowBaseAnnotation", node, opts);
      }, exports.assertFlowDeclaration = function(node, opts) {
        assert("FlowDeclaration", node, opts);
      }, exports.assertFlowPredicate = function(node, opts) {
        assert("FlowPredicate", node, opts);
      }, exports.assertFlowType = function(node, opts) {
        assert("FlowType", node, opts);
      }, exports.assertFor = function(node, opts) {
        assert("For", node, opts);
      }, exports.assertForInStatement = function(node, opts) {
        assert("ForInStatement", node, opts);
      }, exports.assertForOfStatement = function(node, opts) {
        assert("ForOfStatement", node, opts);
      }, exports.assertForStatement = function(node, opts) {
        assert("ForStatement", node, opts);
      }, exports.assertForXStatement = function(node, opts) {
        assert("ForXStatement", node, opts);
      }, exports.assertFunction = function(node, opts) {
        assert("Function", node, opts);
      }, exports.assertFunctionDeclaration = function(node, opts) {
        assert("FunctionDeclaration", node, opts);
      }, exports.assertFunctionExpression = function(node, opts) {
        assert("FunctionExpression", node, opts);
      }, exports.assertFunctionParent = function(node, opts) {
        assert("FunctionParent", node, opts);
      }, exports.assertFunctionTypeAnnotation = function(node, opts) {
        assert("FunctionTypeAnnotation", node, opts);
      }, exports.assertFunctionTypeParam = function(node, opts) {
        assert("FunctionTypeParam", node, opts);
      }, exports.assertGenericTypeAnnotation = function(node, opts) {
        assert("GenericTypeAnnotation", node, opts);
      }, exports.assertIdentifier = function(node, opts) {
        assert("Identifier", node, opts);
      }, exports.assertIfStatement = function(node, opts) {
        assert("IfStatement", node, opts);
      }, exports.assertImmutable = function(node, opts) {
        assert("Immutable", node, opts);
      }, exports.assertImport = function(node, opts) {
        assert("Import", node, opts);
      }, exports.assertImportAttribute = function(node, opts) {
        assert("ImportAttribute", node, opts);
      }, exports.assertImportDeclaration = function(node, opts) {
        assert("ImportDeclaration", node, opts);
      }, exports.assertImportDefaultSpecifier = function(node, opts) {
        assert("ImportDefaultSpecifier", node, opts);
      }, exports.assertImportNamespaceSpecifier = function(node, opts) {
        assert("ImportNamespaceSpecifier", node, opts);
      }, exports.assertImportSpecifier = function(node, opts) {
        assert("ImportSpecifier", node, opts);
      }, exports.assertIndexedAccessType = function(node, opts) {
        assert("IndexedAccessType", node, opts);
      }, exports.assertInferredPredicate = function(node, opts) {
        assert("InferredPredicate", node, opts);
      }, exports.assertInterfaceDeclaration = function(node, opts) {
        assert("InterfaceDeclaration", node, opts);
      }, exports.assertInterfaceExtends = function(node, opts) {
        assert("InterfaceExtends", node, opts);
      }, exports.assertInterfaceTypeAnnotation = function(node, opts) {
        assert("InterfaceTypeAnnotation", node, opts);
      }, exports.assertInterpreterDirective = function(node, opts) {
        assert("InterpreterDirective", node, opts);
      }, exports.assertIntersectionTypeAnnotation = function(node, opts) {
        assert("IntersectionTypeAnnotation", node, opts);
      }, exports.assertJSX = function(node, opts) {
        assert("JSX", node, opts);
      }, exports.assertJSXAttribute = function(node, opts) {
        assert("JSXAttribute", node, opts);
      }, exports.assertJSXClosingElement = function(node, opts) {
        assert("JSXClosingElement", node, opts);
      }, exports.assertJSXClosingFragment = function(node, opts) {
        assert("JSXClosingFragment", node, opts);
      }, exports.assertJSXElement = function(node, opts) {
        assert("JSXElement", node, opts);
      }, exports.assertJSXEmptyExpression = function(node, opts) {
        assert("JSXEmptyExpression", node, opts);
      }, exports.assertJSXExpressionContainer = function(node, opts) {
        assert("JSXExpressionContainer", node, opts);
      }, exports.assertJSXFragment = function(node, opts) {
        assert("JSXFragment", node, opts);
      }, exports.assertJSXIdentifier = function(node, opts) {
        assert("JSXIdentifier", node, opts);
      }, exports.assertJSXMemberExpression = function(node, opts) {
        assert("JSXMemberExpression", node, opts);
      }, exports.assertJSXNamespacedName = function(node, opts) {
        assert("JSXNamespacedName", node, opts);
      }, exports.assertJSXOpeningElement = function(node, opts) {
        assert("JSXOpeningElement", node, opts);
      }, exports.assertJSXOpeningFragment = function(node, opts) {
        assert("JSXOpeningFragment", node, opts);
      }, exports.assertJSXSpreadAttribute = function(node, opts) {
        assert("JSXSpreadAttribute", node, opts);
      }, exports.assertJSXSpreadChild = function(node, opts) {
        assert("JSXSpreadChild", node, opts);
      }, exports.assertJSXText = function(node, opts) {
        assert("JSXText", node, opts);
      }, exports.assertLVal = function(node, opts) {
        assert("LVal", node, opts);
      }, exports.assertLabeledStatement = function(node, opts) {
        assert("LabeledStatement", node, opts);
      }, exports.assertLiteral = function(node, opts) {
        assert("Literal", node, opts);
      }, exports.assertLogicalExpression = function(node, opts) {
        assert("LogicalExpression", node, opts);
      }, exports.assertLoop = function(node, opts) {
        assert("Loop", node, opts);
      }, exports.assertMemberExpression = function(node, opts) {
        assert("MemberExpression", node, opts);
      }, exports.assertMetaProperty = function(node, opts) {
        assert("MetaProperty", node, opts);
      }, exports.assertMethod = function(node, opts) {
        assert("Method", node, opts);
      }, exports.assertMiscellaneous = function(node, opts) {
        assert("Miscellaneous", node, opts);
      }, exports.assertMixedTypeAnnotation = function(node, opts) {
        assert("MixedTypeAnnotation", node, opts);
      }, exports.assertModuleDeclaration = function(node, opts) {
        assert("ModuleDeclaration", node, opts);
      }, exports.assertModuleExpression = function(node, opts) {
        assert("ModuleExpression", node, opts);
      }, exports.assertModuleSpecifier = function(node, opts) {
        assert("ModuleSpecifier", node, opts);
      }, exports.assertNewExpression = function(node, opts) {
        assert("NewExpression", node, opts);
      }, exports.assertNoop = function(node, opts) {
        assert("Noop", node, opts);
      }, exports.assertNullLiteral = function(node, opts) {
        assert("NullLiteral", node, opts);
      }, exports.assertNullLiteralTypeAnnotation = function(node, opts) {
        assert("NullLiteralTypeAnnotation", node, opts);
      }, exports.assertNullableTypeAnnotation = function(node, opts) {
        assert("NullableTypeAnnotation", node, opts);
      }, exports.assertNumberLiteral = function(node, opts) {
        console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), 
        assert("NumberLiteral", node, opts);
      }, exports.assertNumberLiteralTypeAnnotation = function(node, opts) {
        assert("NumberLiteralTypeAnnotation", node, opts);
      }, exports.assertNumberTypeAnnotation = function(node, opts) {
        assert("NumberTypeAnnotation", node, opts);
      }, exports.assertNumericLiteral = function(node, opts) {
        assert("NumericLiteral", node, opts);
      }, exports.assertObjectExpression = function(node, opts) {
        assert("ObjectExpression", node, opts);
      }, exports.assertObjectMember = function(node, opts) {
        assert("ObjectMember", node, opts);
      }, exports.assertObjectMethod = function(node, opts) {
        assert("ObjectMethod", node, opts);
      }, exports.assertObjectPattern = function(node, opts) {
        assert("ObjectPattern", node, opts);
      }, exports.assertObjectProperty = function(node, opts) {
        assert("ObjectProperty", node, opts);
      }, exports.assertObjectTypeAnnotation = function(node, opts) {
        assert("ObjectTypeAnnotation", node, opts);
      }, exports.assertObjectTypeCallProperty = function(node, opts) {
        assert("ObjectTypeCallProperty", node, opts);
      }, exports.assertObjectTypeIndexer = function(node, opts) {
        assert("ObjectTypeIndexer", node, opts);
      }, exports.assertObjectTypeInternalSlot = function(node, opts) {
        assert("ObjectTypeInternalSlot", node, opts);
      }, exports.assertObjectTypeProperty = function(node, opts) {
        assert("ObjectTypeProperty", node, opts);
      }, exports.assertObjectTypeSpreadProperty = function(node, opts) {
        assert("ObjectTypeSpreadProperty", node, opts);
      }, exports.assertOpaqueType = function(node, opts) {
        assert("OpaqueType", node, opts);
      }, exports.assertOptionalCallExpression = function(node, opts) {
        assert("OptionalCallExpression", node, opts);
      }, exports.assertOptionalIndexedAccessType = function(node, opts) {
        assert("OptionalIndexedAccessType", node, opts);
      }, exports.assertOptionalMemberExpression = function(node, opts) {
        assert("OptionalMemberExpression", node, opts);
      }, exports.assertParenthesizedExpression = function(node, opts) {
        assert("ParenthesizedExpression", node, opts);
      }, exports.assertPattern = function(node, opts) {
        assert("Pattern", node, opts);
      }, exports.assertPatternLike = function(node, opts) {
        assert("PatternLike", node, opts);
      }, exports.assertPipelineBareFunction = function(node, opts) {
        assert("PipelineBareFunction", node, opts);
      }, exports.assertPipelinePrimaryTopicReference = function(node, opts) {
        assert("PipelinePrimaryTopicReference", node, opts);
      }, exports.assertPipelineTopicExpression = function(node, opts) {
        assert("PipelineTopicExpression", node, opts);
      }, exports.assertPlaceholder = function(node, opts) {
        assert("Placeholder", node, opts);
      }, exports.assertPrivate = function(node, opts) {
        assert("Private", node, opts);
      }, exports.assertPrivateName = function(node, opts) {
        assert("PrivateName", node, opts);
      }, exports.assertProgram = function(node, opts) {
        assert("Program", node, opts);
      }, exports.assertProperty = function(node, opts) {
        assert("Property", node, opts);
      }, exports.assertPureish = function(node, opts) {
        assert("Pureish", node, opts);
      }, exports.assertQualifiedTypeIdentifier = function(node, opts) {
        assert("QualifiedTypeIdentifier", node, opts);
      }, exports.assertRecordExpression = function(node, opts) {
        assert("RecordExpression", node, opts);
      }, exports.assertRegExpLiteral = function(node, opts) {
        assert("RegExpLiteral", node, opts);
      }, exports.assertRegexLiteral = function(node, opts) {
        console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), assert("RegexLiteral", node, opts);
      }, exports.assertRestElement = function(node, opts) {
        assert("RestElement", node, opts);
      }, exports.assertRestProperty = function(node, opts) {
        console.trace("The node type RestProperty has been renamed to RestElement"), assert("RestProperty", node, opts);
      }, exports.assertReturnStatement = function(node, opts) {
        assert("ReturnStatement", node, opts);
      }, exports.assertScopable = function(node, opts) {
        assert("Scopable", node, opts);
      }, exports.assertSequenceExpression = function(node, opts) {
        assert("SequenceExpression", node, opts);
      }, exports.assertSpreadElement = function(node, opts) {
        assert("SpreadElement", node, opts);
      }, exports.assertSpreadProperty = function(node, opts) {
        console.trace("The node type SpreadProperty has been renamed to SpreadElement"), 
        assert("SpreadProperty", node, opts);
      }, exports.assertStandardized = function(node, opts) {
        assert("Standardized", node, opts);
      }, exports.assertStatement = function(node, opts) {
        assert("Statement", node, opts);
      }, exports.assertStaticBlock = function(node, opts) {
        assert("StaticBlock", node, opts);
      }, exports.assertStringLiteral = function(node, opts) {
        assert("StringLiteral", node, opts);
      }, exports.assertStringLiteralTypeAnnotation = function(node, opts) {
        assert("StringLiteralTypeAnnotation", node, opts);
      }, exports.assertStringTypeAnnotation = function(node, opts) {
        assert("StringTypeAnnotation", node, opts);
      }, exports.assertSuper = function(node, opts) {
        assert("Super", node, opts);
      }, exports.assertSwitchCase = function(node, opts) {
        assert("SwitchCase", node, opts);
      }, exports.assertSwitchStatement = function(node, opts) {
        assert("SwitchStatement", node, opts);
      }, exports.assertSymbolTypeAnnotation = function(node, opts) {
        assert("SymbolTypeAnnotation", node, opts);
      }, exports.assertTSAnyKeyword = function(node, opts) {
        assert("TSAnyKeyword", node, opts);
      }, exports.assertTSArrayType = function(node, opts) {
        assert("TSArrayType", node, opts);
      }, exports.assertTSAsExpression = function(node, opts) {
        assert("TSAsExpression", node, opts);
      }, exports.assertTSBaseType = function(node, opts) {
        assert("TSBaseType", node, opts);
      }, exports.assertTSBigIntKeyword = function(node, opts) {
        assert("TSBigIntKeyword", node, opts);
      }, exports.assertTSBooleanKeyword = function(node, opts) {
        assert("TSBooleanKeyword", node, opts);
      }, exports.assertTSCallSignatureDeclaration = function(node, opts) {
        assert("TSCallSignatureDeclaration", node, opts);
      }, exports.assertTSConditionalType = function(node, opts) {
        assert("TSConditionalType", node, opts);
      }, exports.assertTSConstructSignatureDeclaration = function(node, opts) {
        assert("TSConstructSignatureDeclaration", node, opts);
      }, exports.assertTSConstructorType = function(node, opts) {
        assert("TSConstructorType", node, opts);
      }, exports.assertTSDeclareFunction = function(node, opts) {
        assert("TSDeclareFunction", node, opts);
      }, exports.assertTSDeclareMethod = function(node, opts) {
        assert("TSDeclareMethod", node, opts);
      }, exports.assertTSEntityName = function(node, opts) {
        assert("TSEntityName", node, opts);
      }, exports.assertTSEnumDeclaration = function(node, opts) {
        assert("TSEnumDeclaration", node, opts);
      }, exports.assertTSEnumMember = function(node, opts) {
        assert("TSEnumMember", node, opts);
      }, exports.assertTSExportAssignment = function(node, opts) {
        assert("TSExportAssignment", node, opts);
      }, exports.assertTSExpressionWithTypeArguments = function(node, opts) {
        assert("TSExpressionWithTypeArguments", node, opts);
      }, exports.assertTSExternalModuleReference = function(node, opts) {
        assert("TSExternalModuleReference", node, opts);
      }, exports.assertTSFunctionType = function(node, opts) {
        assert("TSFunctionType", node, opts);
      }, exports.assertTSImportEqualsDeclaration = function(node, opts) {
        assert("TSImportEqualsDeclaration", node, opts);
      }, exports.assertTSImportType = function(node, opts) {
        assert("TSImportType", node, opts);
      }, exports.assertTSIndexSignature = function(node, opts) {
        assert("TSIndexSignature", node, opts);
      }, exports.assertTSIndexedAccessType = function(node, opts) {
        assert("TSIndexedAccessType", node, opts);
      }, exports.assertTSInferType = function(node, opts) {
        assert("TSInferType", node, opts);
      }, exports.assertTSInterfaceBody = function(node, opts) {
        assert("TSInterfaceBody", node, opts);
      }, exports.assertTSInterfaceDeclaration = function(node, opts) {
        assert("TSInterfaceDeclaration", node, opts);
      }, exports.assertTSIntersectionType = function(node, opts) {
        assert("TSIntersectionType", node, opts);
      }, exports.assertTSIntrinsicKeyword = function(node, opts) {
        assert("TSIntrinsicKeyword", node, opts);
      }, exports.assertTSLiteralType = function(node, opts) {
        assert("TSLiteralType", node, opts);
      }, exports.assertTSMappedType = function(node, opts) {
        assert("TSMappedType", node, opts);
      }, exports.assertTSMethodSignature = function(node, opts) {
        assert("TSMethodSignature", node, opts);
      }, exports.assertTSModuleBlock = function(node, opts) {
        assert("TSModuleBlock", node, opts);
      }, exports.assertTSModuleDeclaration = function(node, opts) {
        assert("TSModuleDeclaration", node, opts);
      }, exports.assertTSNamedTupleMember = function(node, opts) {
        assert("TSNamedTupleMember", node, opts);
      }, exports.assertTSNamespaceExportDeclaration = function(node, opts) {
        assert("TSNamespaceExportDeclaration", node, opts);
      }, exports.assertTSNeverKeyword = function(node, opts) {
        assert("TSNeverKeyword", node, opts);
      }, exports.assertTSNonNullExpression = function(node, opts) {
        assert("TSNonNullExpression", node, opts);
      }, exports.assertTSNullKeyword = function(node, opts) {
        assert("TSNullKeyword", node, opts);
      }, exports.assertTSNumberKeyword = function(node, opts) {
        assert("TSNumberKeyword", node, opts);
      }, exports.assertTSObjectKeyword = function(node, opts) {
        assert("TSObjectKeyword", node, opts);
      }, exports.assertTSOptionalType = function(node, opts) {
        assert("TSOptionalType", node, opts);
      }, exports.assertTSParameterProperty = function(node, opts) {
        assert("TSParameterProperty", node, opts);
      }, exports.assertTSParenthesizedType = function(node, opts) {
        assert("TSParenthesizedType", node, opts);
      }, exports.assertTSPropertySignature = function(node, opts) {
        assert("TSPropertySignature", node, opts);
      }, exports.assertTSQualifiedName = function(node, opts) {
        assert("TSQualifiedName", node, opts);
      }, exports.assertTSRestType = function(node, opts) {
        assert("TSRestType", node, opts);
      }, exports.assertTSStringKeyword = function(node, opts) {
        assert("TSStringKeyword", node, opts);
      }, exports.assertTSSymbolKeyword = function(node, opts) {
        assert("TSSymbolKeyword", node, opts);
      }, exports.assertTSThisType = function(node, opts) {
        assert("TSThisType", node, opts);
      }, exports.assertTSTupleType = function(node, opts) {
        assert("TSTupleType", node, opts);
      }, exports.assertTSType = function(node, opts) {
        assert("TSType", node, opts);
      }, exports.assertTSTypeAliasDeclaration = function(node, opts) {
        assert("TSTypeAliasDeclaration", node, opts);
      }, exports.assertTSTypeAnnotation = function(node, opts) {
        assert("TSTypeAnnotation", node, opts);
      }, exports.assertTSTypeAssertion = function(node, opts) {
        assert("TSTypeAssertion", node, opts);
      }, exports.assertTSTypeElement = function(node, opts) {
        assert("TSTypeElement", node, opts);
      }, exports.assertTSTypeLiteral = function(node, opts) {
        assert("TSTypeLiteral", node, opts);
      }, exports.assertTSTypeOperator = function(node, opts) {
        assert("TSTypeOperator", node, opts);
      }, exports.assertTSTypeParameter = function(node, opts) {
        assert("TSTypeParameter", node, opts);
      }, exports.assertTSTypeParameterDeclaration = function(node, opts) {
        assert("TSTypeParameterDeclaration", node, opts);
      }, exports.assertTSTypeParameterInstantiation = function(node, opts) {
        assert("TSTypeParameterInstantiation", node, opts);
      }, exports.assertTSTypePredicate = function(node, opts) {
        assert("TSTypePredicate", node, opts);
      }, exports.assertTSTypeQuery = function(node, opts) {
        assert("TSTypeQuery", node, opts);
      }, exports.assertTSTypeReference = function(node, opts) {
        assert("TSTypeReference", node, opts);
      }, exports.assertTSUndefinedKeyword = function(node, opts) {
        assert("TSUndefinedKeyword", node, opts);
      }, exports.assertTSUnionType = function(node, opts) {
        assert("TSUnionType", node, opts);
      }, exports.assertTSUnknownKeyword = function(node, opts) {
        assert("TSUnknownKeyword", node, opts);
      }, exports.assertTSVoidKeyword = function(node, opts) {
        assert("TSVoidKeyword", node, opts);
      }, exports.assertTaggedTemplateExpression = function(node, opts) {
        assert("TaggedTemplateExpression", node, opts);
      }, exports.assertTemplateElement = function(node, opts) {
        assert("TemplateElement", node, opts);
      }, exports.assertTemplateLiteral = function(node, opts) {
        assert("TemplateLiteral", node, opts);
      }, exports.assertTerminatorless = function(node, opts) {
        assert("Terminatorless", node, opts);
      }, exports.assertThisExpression = function(node, opts) {
        assert("ThisExpression", node, opts);
      }, exports.assertThisTypeAnnotation = function(node, opts) {
        assert("ThisTypeAnnotation", node, opts);
      }, exports.assertThrowStatement = function(node, opts) {
        assert("ThrowStatement", node, opts);
      }, exports.assertTopicReference = function(node, opts) {
        assert("TopicReference", node, opts);
      }, exports.assertTryStatement = function(node, opts) {
        assert("TryStatement", node, opts);
      }, exports.assertTupleExpression = function(node, opts) {
        assert("TupleExpression", node, opts);
      }, exports.assertTupleTypeAnnotation = function(node, opts) {
        assert("TupleTypeAnnotation", node, opts);
      }, exports.assertTypeAlias = function(node, opts) {
        assert("TypeAlias", node, opts);
      }, exports.assertTypeAnnotation = function(node, opts) {
        assert("TypeAnnotation", node, opts);
      }, exports.assertTypeCastExpression = function(node, opts) {
        assert("TypeCastExpression", node, opts);
      }, exports.assertTypeParameter = function(node, opts) {
        assert("TypeParameter", node, opts);
      }, exports.assertTypeParameterDeclaration = function(node, opts) {
        assert("TypeParameterDeclaration", node, opts);
      }, exports.assertTypeParameterInstantiation = function(node, opts) {
        assert("TypeParameterInstantiation", node, opts);
      }, exports.assertTypeScript = function(node, opts) {
        assert("TypeScript", node, opts);
      }, exports.assertTypeofTypeAnnotation = function(node, opts) {
        assert("TypeofTypeAnnotation", node, opts);
      }, exports.assertUnaryExpression = function(node, opts) {
        assert("UnaryExpression", node, opts);
      }, exports.assertUnaryLike = function(node, opts) {
        assert("UnaryLike", node, opts);
      }, exports.assertUnionTypeAnnotation = function(node, opts) {
        assert("UnionTypeAnnotation", node, opts);
      }, exports.assertUpdateExpression = function(node, opts) {
        assert("UpdateExpression", node, opts);
      }, exports.assertUserWhitespacable = function(node, opts) {
        assert("UserWhitespacable", node, opts);
      }, exports.assertV8IntrinsicIdentifier = function(node, opts) {
        assert("V8IntrinsicIdentifier", node, opts);
      }, exports.assertVariableDeclaration = function(node, opts) {
        assert("VariableDeclaration", node, opts);
      }, exports.assertVariableDeclarator = function(node, opts) {
        assert("VariableDeclarator", node, opts);
      }, exports.assertVariance = function(node, opts) {
        assert("Variance", node, opts);
      }, exports.assertVoidTypeAnnotation = function(node, opts) {
        assert("VoidTypeAnnotation", node, opts);
      }, exports.assertWhile = function(node, opts) {
        assert("While", node, opts);
      }, exports.assertWhileStatement = function(node, opts) {
        assert("WhileStatement", node, opts);
      }, exports.assertWithStatement = function(node, opts) {
        assert("WithStatement", node, opts);
      }, exports.assertYieldExpression = function(node, opts) {
        assert("YieldExpression", node, opts);
      };
      var _is = __webpack_require__(7275);
      function assert(type, node, opts) {
        if (!(0, _is.default)(type, node, opts)) throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
      }
    },
    1585: () => {},
    4745: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function() {
        const type = this, keys = _definitions.BUILDER_KEYS[type], countArgs = arguments.length;
        if (countArgs > keys.length) throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
        const node = {
          type
        };
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i], field = _definitions.NODE_FIELDS[type][key];
          let arg;
          i < countArgs && (arg = arguments[i]), void 0 === arg && (arg = Array.isArray(field.default) ? [] : field.default), 
          node[key] = arg;
        }
        for (const key in node) (0, _validate.default)(node, key, node[key]);
        return node;
      };
      var _definitions = __webpack_require__(6507), _validate = __webpack_require__(3804);
    },
    9983: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(types) {
        const flattened = (0, _removeTypeDuplicates.default)(types);
        return 1 === flattened.length ? flattened[0] : (0, _generated.unionTypeAnnotation)(flattened);
      };
      var _generated = __webpack_require__(4391), _removeTypeDuplicates = __webpack_require__(7321);
    },
    949: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _generated = __webpack_require__(4391), _default = function(type) {
        switch (type) {
         case "string":
          return (0, _generated.stringTypeAnnotation)();

         case "number":
          return (0, _generated.numberTypeAnnotation)();

         case "undefined":
          return (0, _generated.voidTypeAnnotation)();

         case "boolean":
          return (0, _generated.booleanTypeAnnotation)();

         case "function":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));

         case "object":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));

         case "symbol":
          return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));

         case "bigint":
          return (0, _generated.anyTypeAnnotation)();
        }
        throw new Error("Invalid typeof value: " + type);
      };
      exports.default = _default;
    },
    4391: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.anyTypeAnnotation = function() {
        return _builder.default.apply("AnyTypeAnnotation", arguments);
      }, exports.argumentPlaceholder = function() {
        return _builder.default.apply("ArgumentPlaceholder", arguments);
      }, exports.arrayExpression = function(elements) {
        return _builder.default.apply("ArrayExpression", arguments);
      }, exports.arrayPattern = function(elements) {
        return _builder.default.apply("ArrayPattern", arguments);
      }, exports.arrayTypeAnnotation = function(elementType) {
        return _builder.default.apply("ArrayTypeAnnotation", arguments);
      }, exports.arrowFunctionExpression = function(params, body, async) {
        return _builder.default.apply("ArrowFunctionExpression", arguments);
      }, exports.assignmentExpression = function(operator, left, right) {
        return _builder.default.apply("AssignmentExpression", arguments);
      }, exports.assignmentPattern = function(left, right) {
        return _builder.default.apply("AssignmentPattern", arguments);
      }, exports.awaitExpression = function(argument) {
        return _builder.default.apply("AwaitExpression", arguments);
      }, exports.bigIntLiteral = function(value) {
        return _builder.default.apply("BigIntLiteral", arguments);
      }, exports.binaryExpression = function(operator, left, right) {
        return _builder.default.apply("BinaryExpression", arguments);
      }, exports.bindExpression = function(object, callee) {
        return _builder.default.apply("BindExpression", arguments);
      }, exports.blockStatement = function(body, directives) {
        return _builder.default.apply("BlockStatement", arguments);
      }, exports.booleanLiteral = function(value) {
        return _builder.default.apply("BooleanLiteral", arguments);
      }, exports.booleanLiteralTypeAnnotation = function(value) {
        return _builder.default.apply("BooleanLiteralTypeAnnotation", arguments);
      }, exports.booleanTypeAnnotation = function() {
        return _builder.default.apply("BooleanTypeAnnotation", arguments);
      }, exports.breakStatement = function(label) {
        return _builder.default.apply("BreakStatement", arguments);
      }, exports.callExpression = function(callee, _arguments) {
        return _builder.default.apply("CallExpression", arguments);
      }, exports.catchClause = function(param, body) {
        return _builder.default.apply("CatchClause", arguments);
      }, exports.classAccessorProperty = function(key, value, typeAnnotation, decorators, computed, _static) {
        return _builder.default.apply("ClassAccessorProperty", arguments);
      }, exports.classBody = function(body) {
        return _builder.default.apply("ClassBody", arguments);
      }, exports.classDeclaration = function(id, superClass, body, decorators) {
        return _builder.default.apply("ClassDeclaration", arguments);
      }, exports.classExpression = function(id, superClass, body, decorators) {
        return _builder.default.apply("ClassExpression", arguments);
      }, exports.classImplements = function(id, typeParameters) {
        return _builder.default.apply("ClassImplements", arguments);
      }, exports.classMethod = function(kind, key, params, body, computed, _static, generator, async) {
        return _builder.default.apply("ClassMethod", arguments);
      }, exports.classPrivateMethod = function(kind, key, params, body, _static) {
        return _builder.default.apply("ClassPrivateMethod", arguments);
      }, exports.classPrivateProperty = function(key, value, decorators, _static) {
        return _builder.default.apply("ClassPrivateProperty", arguments);
      }, exports.classProperty = function(key, value, typeAnnotation, decorators, computed, _static) {
        return _builder.default.apply("ClassProperty", arguments);
      }, exports.conditionalExpression = function(test, consequent, alternate) {
        return _builder.default.apply("ConditionalExpression", arguments);
      }, exports.continueStatement = function(label) {
        return _builder.default.apply("ContinueStatement", arguments);
      }, exports.debuggerStatement = function() {
        return _builder.default.apply("DebuggerStatement", arguments);
      }, exports.decimalLiteral = function(value) {
        return _builder.default.apply("DecimalLiteral", arguments);
      }, exports.declareClass = function(id, typeParameters, _extends, body) {
        return _builder.default.apply("DeclareClass", arguments);
      }, exports.declareExportAllDeclaration = function(source) {
        return _builder.default.apply("DeclareExportAllDeclaration", arguments);
      }, exports.declareExportDeclaration = function(declaration, specifiers, source) {
        return _builder.default.apply("DeclareExportDeclaration", arguments);
      }, exports.declareFunction = function(id) {
        return _builder.default.apply("DeclareFunction", arguments);
      }, exports.declareInterface = function(id, typeParameters, _extends, body) {
        return _builder.default.apply("DeclareInterface", arguments);
      }, exports.declareModule = function(id, body, kind) {
        return _builder.default.apply("DeclareModule", arguments);
      }, exports.declareModuleExports = function(typeAnnotation) {
        return _builder.default.apply("DeclareModuleExports", arguments);
      }, exports.declareOpaqueType = function(id, typeParameters, supertype) {
        return _builder.default.apply("DeclareOpaqueType", arguments);
      }, exports.declareTypeAlias = function(id, typeParameters, right) {
        return _builder.default.apply("DeclareTypeAlias", arguments);
      }, exports.declareVariable = function(id) {
        return _builder.default.apply("DeclareVariable", arguments);
      }, exports.declaredPredicate = function(value) {
        return _builder.default.apply("DeclaredPredicate", arguments);
      }, exports.decorator = function(expression) {
        return _builder.default.apply("Decorator", arguments);
      }, exports.directive = function(value) {
        return _builder.default.apply("Directive", arguments);
      }, exports.directiveLiteral = function(value) {
        return _builder.default.apply("DirectiveLiteral", arguments);
      }, exports.doExpression = function(body, async) {
        return _builder.default.apply("DoExpression", arguments);
      }, exports.doWhileStatement = function(test, body) {
        return _builder.default.apply("DoWhileStatement", arguments);
      }, exports.emptyStatement = function() {
        return _builder.default.apply("EmptyStatement", arguments);
      }, exports.emptyTypeAnnotation = function() {
        return _builder.default.apply("EmptyTypeAnnotation", arguments);
      }, exports.enumBooleanBody = function(members) {
        return _builder.default.apply("EnumBooleanBody", arguments);
      }, exports.enumBooleanMember = function(id) {
        return _builder.default.apply("EnumBooleanMember", arguments);
      }, exports.enumDeclaration = function(id, body) {
        return _builder.default.apply("EnumDeclaration", arguments);
      }, exports.enumDefaultedMember = function(id) {
        return _builder.default.apply("EnumDefaultedMember", arguments);
      }, exports.enumNumberBody = function(members) {
        return _builder.default.apply("EnumNumberBody", arguments);
      }, exports.enumNumberMember = function(id, init) {
        return _builder.default.apply("EnumNumberMember", arguments);
      }, exports.enumStringBody = function(members) {
        return _builder.default.apply("EnumStringBody", arguments);
      }, exports.enumStringMember = function(id, init) {
        return _builder.default.apply("EnumStringMember", arguments);
      }, exports.enumSymbolBody = function(members) {
        return _builder.default.apply("EnumSymbolBody", arguments);
      }, exports.existsTypeAnnotation = function() {
        return _builder.default.apply("ExistsTypeAnnotation", arguments);
      }, exports.exportAllDeclaration = function(source) {
        return _builder.default.apply("ExportAllDeclaration", arguments);
      }, exports.exportDefaultDeclaration = function(declaration) {
        return _builder.default.apply("ExportDefaultDeclaration", arguments);
      }, exports.exportDefaultSpecifier = function(exported) {
        return _builder.default.apply("ExportDefaultSpecifier", arguments);
      }, exports.exportNamedDeclaration = function(declaration, specifiers, source) {
        return _builder.default.apply("ExportNamedDeclaration", arguments);
      }, exports.exportNamespaceSpecifier = function(exported) {
        return _builder.default.apply("ExportNamespaceSpecifier", arguments);
      }, exports.exportSpecifier = function(local, exported) {
        return _builder.default.apply("ExportSpecifier", arguments);
      }, exports.expressionStatement = function(expression) {
        return _builder.default.apply("ExpressionStatement", arguments);
      }, exports.file = function(program, comments, tokens) {
        return _builder.default.apply("File", arguments);
      }, exports.forInStatement = function(left, right, body) {
        return _builder.default.apply("ForInStatement", arguments);
      }, exports.forOfStatement = function(left, right, body, _await) {
        return _builder.default.apply("ForOfStatement", arguments);
      }, exports.forStatement = function(init, test, update, body) {
        return _builder.default.apply("ForStatement", arguments);
      }, exports.functionDeclaration = function(id, params, body, generator, async) {
        return _builder.default.apply("FunctionDeclaration", arguments);
      }, exports.functionExpression = function(id, params, body, generator, async) {
        return _builder.default.apply("FunctionExpression", arguments);
      }, exports.functionTypeAnnotation = function(typeParameters, params, rest, returnType) {
        return _builder.default.apply("FunctionTypeAnnotation", arguments);
      }, exports.functionTypeParam = function(name, typeAnnotation) {
        return _builder.default.apply("FunctionTypeParam", arguments);
      }, exports.genericTypeAnnotation = function(id, typeParameters) {
        return _builder.default.apply("GenericTypeAnnotation", arguments);
      }, exports.identifier = function(name) {
        return _builder.default.apply("Identifier", arguments);
      }, exports.ifStatement = function(test, consequent, alternate) {
        return _builder.default.apply("IfStatement", arguments);
      }, exports.import = function() {
        return _builder.default.apply("Import", arguments);
      }, exports.importAttribute = function(key, value) {
        return _builder.default.apply("ImportAttribute", arguments);
      }, exports.importDeclaration = function(specifiers, source) {
        return _builder.default.apply("ImportDeclaration", arguments);
      }, exports.importDefaultSpecifier = function(local) {
        return _builder.default.apply("ImportDefaultSpecifier", arguments);
      }, exports.importNamespaceSpecifier = function(local) {
        return _builder.default.apply("ImportNamespaceSpecifier", arguments);
      }, exports.importSpecifier = function(local, imported) {
        return _builder.default.apply("ImportSpecifier", arguments);
      }, exports.indexedAccessType = function(objectType, indexType) {
        return _builder.default.apply("IndexedAccessType", arguments);
      }, exports.inferredPredicate = function() {
        return _builder.default.apply("InferredPredicate", arguments);
      }, exports.interfaceDeclaration = function(id, typeParameters, _extends, body) {
        return _builder.default.apply("InterfaceDeclaration", arguments);
      }, exports.interfaceExtends = function(id, typeParameters) {
        return _builder.default.apply("InterfaceExtends", arguments);
      }, exports.interfaceTypeAnnotation = function(_extends, body) {
        return _builder.default.apply("InterfaceTypeAnnotation", arguments);
      }, exports.interpreterDirective = function(value) {
        return _builder.default.apply("InterpreterDirective", arguments);
      }, exports.intersectionTypeAnnotation = function(types) {
        return _builder.default.apply("IntersectionTypeAnnotation", arguments);
      }, exports.jSXAttribute = exports.jsxAttribute = function(name, value) {
        return _builder.default.apply("JSXAttribute", arguments);
      }, exports.jSXClosingElement = exports.jsxClosingElement = function(name) {
        return _builder.default.apply("JSXClosingElement", arguments);
      }, exports.jSXClosingFragment = exports.jsxClosingFragment = function() {
        return _builder.default.apply("JSXClosingFragment", arguments);
      }, exports.jSXElement = exports.jsxElement = function(openingElement, closingElement, children, selfClosing) {
        return _builder.default.apply("JSXElement", arguments);
      }, exports.jSXEmptyExpression = exports.jsxEmptyExpression = function() {
        return _builder.default.apply("JSXEmptyExpression", arguments);
      }, exports.jSXExpressionContainer = exports.jsxExpressionContainer = function(expression) {
        return _builder.default.apply("JSXExpressionContainer", arguments);
      }, exports.jSXFragment = exports.jsxFragment = function(openingFragment, closingFragment, children) {
        return _builder.default.apply("JSXFragment", arguments);
      }, exports.jSXIdentifier = exports.jsxIdentifier = function(name) {
        return _builder.default.apply("JSXIdentifier", arguments);
      }, exports.jSXMemberExpression = exports.jsxMemberExpression = function(object, property) {
        return _builder.default.apply("JSXMemberExpression", arguments);
      }, exports.jSXNamespacedName = exports.jsxNamespacedName = function(namespace, name) {
        return _builder.default.apply("JSXNamespacedName", arguments);
      }, exports.jSXOpeningElement = exports.jsxOpeningElement = function(name, attributes, selfClosing) {
        return _builder.default.apply("JSXOpeningElement", arguments);
      }, exports.jSXOpeningFragment = exports.jsxOpeningFragment = function() {
        return _builder.default.apply("JSXOpeningFragment", arguments);
      }, exports.jSXSpreadAttribute = exports.jsxSpreadAttribute = function(argument) {
        return _builder.default.apply("JSXSpreadAttribute", arguments);
      }, exports.jSXSpreadChild = exports.jsxSpreadChild = function(expression) {
        return _builder.default.apply("JSXSpreadChild", arguments);
      }, exports.jSXText = exports.jsxText = function(value) {
        return _builder.default.apply("JSXText", arguments);
      }, exports.labeledStatement = function(label, body) {
        return _builder.default.apply("LabeledStatement", arguments);
      }, exports.logicalExpression = function(operator, left, right) {
        return _builder.default.apply("LogicalExpression", arguments);
      }, exports.memberExpression = function(object, property, computed, optional) {
        return _builder.default.apply("MemberExpression", arguments);
      }, exports.metaProperty = function(meta, property) {
        return _builder.default.apply("MetaProperty", arguments);
      }, exports.mixedTypeAnnotation = function() {
        return _builder.default.apply("MixedTypeAnnotation", arguments);
      }, exports.moduleExpression = function(body) {
        return _builder.default.apply("ModuleExpression", arguments);
      }, exports.newExpression = function(callee, _arguments) {
        return _builder.default.apply("NewExpression", arguments);
      }, exports.noop = function() {
        return _builder.default.apply("Noop", arguments);
      }, exports.nullLiteral = function() {
        return _builder.default.apply("NullLiteral", arguments);
      }, exports.nullLiteralTypeAnnotation = function() {
        return _builder.default.apply("NullLiteralTypeAnnotation", arguments);
      }, exports.nullableTypeAnnotation = function(typeAnnotation) {
        return _builder.default.apply("NullableTypeAnnotation", arguments);
      }, exports.numberLiteral = function(value) {
        return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), 
        _builder.default.apply("NumberLiteral", arguments);
      }, exports.numberLiteralTypeAnnotation = function(value) {
        return _builder.default.apply("NumberLiteralTypeAnnotation", arguments);
      }, exports.numberTypeAnnotation = function() {
        return _builder.default.apply("NumberTypeAnnotation", arguments);
      }, exports.numericLiteral = function(value) {
        return _builder.default.apply("NumericLiteral", arguments);
      }, exports.objectExpression = function(properties) {
        return _builder.default.apply("ObjectExpression", arguments);
      }, exports.objectMethod = function(kind, key, params, body, computed, generator, async) {
        return _builder.default.apply("ObjectMethod", arguments);
      }, exports.objectPattern = function(properties) {
        return _builder.default.apply("ObjectPattern", arguments);
      }, exports.objectProperty = function(key, value, computed, shorthand, decorators) {
        return _builder.default.apply("ObjectProperty", arguments);
      }, exports.objectTypeAnnotation = function(properties, indexers, callProperties, internalSlots, exact) {
        return _builder.default.apply("ObjectTypeAnnotation", arguments);
      }, exports.objectTypeCallProperty = function(value) {
        return _builder.default.apply("ObjectTypeCallProperty", arguments);
      }, exports.objectTypeIndexer = function(id, key, value, variance) {
        return _builder.default.apply("ObjectTypeIndexer", arguments);
      }, exports.objectTypeInternalSlot = function(id, value, optional, _static, method) {
        return _builder.default.apply("ObjectTypeInternalSlot", arguments);
      }, exports.objectTypeProperty = function(key, value, variance) {
        return _builder.default.apply("ObjectTypeProperty", arguments);
      }, exports.objectTypeSpreadProperty = function(argument) {
        return _builder.default.apply("ObjectTypeSpreadProperty", arguments);
      }, exports.opaqueType = function(id, typeParameters, supertype, impltype) {
        return _builder.default.apply("OpaqueType", arguments);
      }, exports.optionalCallExpression = function(callee, _arguments, optional) {
        return _builder.default.apply("OptionalCallExpression", arguments);
      }, exports.optionalIndexedAccessType = function(objectType, indexType) {
        return _builder.default.apply("OptionalIndexedAccessType", arguments);
      }, exports.optionalMemberExpression = function(object, property, computed, optional) {
        return _builder.default.apply("OptionalMemberExpression", arguments);
      }, exports.parenthesizedExpression = function(expression) {
        return _builder.default.apply("ParenthesizedExpression", arguments);
      }, exports.pipelineBareFunction = function(callee) {
        return _builder.default.apply("PipelineBareFunction", arguments);
      }, exports.pipelinePrimaryTopicReference = function() {
        return _builder.default.apply("PipelinePrimaryTopicReference", arguments);
      }, exports.pipelineTopicExpression = function(expression) {
        return _builder.default.apply("PipelineTopicExpression", arguments);
      }, exports.placeholder = function(expectedNode, name) {
        return _builder.default.apply("Placeholder", arguments);
      }, exports.privateName = function(id) {
        return _builder.default.apply("PrivateName", arguments);
      }, exports.program = function(body, directives, sourceType, interpreter) {
        return _builder.default.apply("Program", arguments);
      }, exports.qualifiedTypeIdentifier = function(id, qualification) {
        return _builder.default.apply("QualifiedTypeIdentifier", arguments);
      }, exports.recordExpression = function(properties) {
        return _builder.default.apply("RecordExpression", arguments);
      }, exports.regExpLiteral = function(pattern, flags) {
        return _builder.default.apply("RegExpLiteral", arguments);
      }, exports.regexLiteral = function(pattern, flags) {
        return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), 
        _builder.default.apply("RegexLiteral", arguments);
      }, exports.restElement = function(argument) {
        return _builder.default.apply("RestElement", arguments);
      }, exports.restProperty = function(argument) {
        return console.trace("The node type RestProperty has been renamed to RestElement"), 
        _builder.default.apply("RestProperty", arguments);
      }, exports.returnStatement = function(argument) {
        return _builder.default.apply("ReturnStatement", arguments);
      }, exports.sequenceExpression = function(expressions) {
        return _builder.default.apply("SequenceExpression", arguments);
      }, exports.spreadElement = function(argument) {
        return _builder.default.apply("SpreadElement", arguments);
      }, exports.spreadProperty = function(argument) {
        return console.trace("The node type SpreadProperty has been renamed to SpreadElement"), 
        _builder.default.apply("SpreadProperty", arguments);
      }, exports.staticBlock = function(body) {
        return _builder.default.apply("StaticBlock", arguments);
      }, exports.stringLiteral = function(value) {
        return _builder.default.apply("StringLiteral", arguments);
      }, exports.stringLiteralTypeAnnotation = function(value) {
        return _builder.default.apply("StringLiteralTypeAnnotation", arguments);
      }, exports.stringTypeAnnotation = function() {
        return _builder.default.apply("StringTypeAnnotation", arguments);
      }, exports.super = function() {
        return _builder.default.apply("Super", arguments);
      }, exports.switchCase = function(test, consequent) {
        return _builder.default.apply("SwitchCase", arguments);
      }, exports.switchStatement = function(discriminant, cases) {
        return _builder.default.apply("SwitchStatement", arguments);
      }, exports.symbolTypeAnnotation = function() {
        return _builder.default.apply("SymbolTypeAnnotation", arguments);
      }, exports.taggedTemplateExpression = function(tag, quasi) {
        return _builder.default.apply("TaggedTemplateExpression", arguments);
      }, exports.templateElement = function(value, tail) {
        return _builder.default.apply("TemplateElement", arguments);
      }, exports.templateLiteral = function(quasis, expressions) {
        return _builder.default.apply("TemplateLiteral", arguments);
      }, exports.thisExpression = function() {
        return _builder.default.apply("ThisExpression", arguments);
      }, exports.thisTypeAnnotation = function() {
        return _builder.default.apply("ThisTypeAnnotation", arguments);
      }, exports.throwStatement = function(argument) {
        return _builder.default.apply("ThrowStatement", arguments);
      }, exports.topicReference = function() {
        return _builder.default.apply("TopicReference", arguments);
      }, exports.tryStatement = function(block, handler, finalizer) {
        return _builder.default.apply("TryStatement", arguments);
      }, exports.tSAnyKeyword = exports.tsAnyKeyword = function() {
        return _builder.default.apply("TSAnyKeyword", arguments);
      }, exports.tSArrayType = exports.tsArrayType = function(elementType) {
        return _builder.default.apply("TSArrayType", arguments);
      }, exports.tSAsExpression = exports.tsAsExpression = function(expression, typeAnnotation) {
        return _builder.default.apply("TSAsExpression", arguments);
      }, exports.tSBigIntKeyword = exports.tsBigIntKeyword = function() {
        return _builder.default.apply("TSBigIntKeyword", arguments);
      }, exports.tSBooleanKeyword = exports.tsBooleanKeyword = function() {
        return _builder.default.apply("TSBooleanKeyword", arguments);
      }, exports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = function(typeParameters, parameters, typeAnnotation) {
        return _builder.default.apply("TSCallSignatureDeclaration", arguments);
      }, exports.tSConditionalType = exports.tsConditionalType = function(checkType, extendsType, trueType, falseType) {
        return _builder.default.apply("TSConditionalType", arguments);
      }, exports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = function(typeParameters, parameters, typeAnnotation) {
        return _builder.default.apply("TSConstructSignatureDeclaration", arguments);
      }, exports.tSConstructorType = exports.tsConstructorType = function(typeParameters, parameters, typeAnnotation) {
        return _builder.default.apply("TSConstructorType", arguments);
      }, exports.tSDeclareFunction = exports.tsDeclareFunction = function(id, typeParameters, params, returnType) {
        return _builder.default.apply("TSDeclareFunction", arguments);
      }, exports.tSDeclareMethod = exports.tsDeclareMethod = function(decorators, key, typeParameters, params, returnType) {
        return _builder.default.apply("TSDeclareMethod", arguments);
      }, exports.tSEnumDeclaration = exports.tsEnumDeclaration = function(id, members) {
        return _builder.default.apply("TSEnumDeclaration", arguments);
      }, exports.tSEnumMember = exports.tsEnumMember = function(id, initializer) {
        return _builder.default.apply("TSEnumMember", arguments);
      }, exports.tSExportAssignment = exports.tsExportAssignment = function(expression) {
        return _builder.default.apply("TSExportAssignment", arguments);
      }, exports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = function(expression, typeParameters) {
        return _builder.default.apply("TSExpressionWithTypeArguments", arguments);
      }, exports.tSExternalModuleReference = exports.tsExternalModuleReference = function(expression) {
        return _builder.default.apply("TSExternalModuleReference", arguments);
      }, exports.tSFunctionType = exports.tsFunctionType = function(typeParameters, parameters, typeAnnotation) {
        return _builder.default.apply("TSFunctionType", arguments);
      }, exports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = function(id, moduleReference) {
        return _builder.default.apply("TSImportEqualsDeclaration", arguments);
      }, exports.tSImportType = exports.tsImportType = function(argument, qualifier, typeParameters) {
        return _builder.default.apply("TSImportType", arguments);
      }, exports.tSIndexSignature = exports.tsIndexSignature = function(parameters, typeAnnotation) {
        return _builder.default.apply("TSIndexSignature", arguments);
      }, exports.tSIndexedAccessType = exports.tsIndexedAccessType = function(objectType, indexType) {
        return _builder.default.apply("TSIndexedAccessType", arguments);
      }, exports.tSInferType = exports.tsInferType = function(typeParameter) {
        return _builder.default.apply("TSInferType", arguments);
      }, exports.tSInterfaceBody = exports.tsInterfaceBody = function(body) {
        return _builder.default.apply("TSInterfaceBody", arguments);
      }, exports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = function(id, typeParameters, _extends, body) {
        return _builder.default.apply("TSInterfaceDeclaration", arguments);
      }, exports.tSIntersectionType = exports.tsIntersectionType = function(types) {
        return _builder.default.apply("TSIntersectionType", arguments);
      }, exports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = function() {
        return _builder.default.apply("TSIntrinsicKeyword", arguments);
      }, exports.tSLiteralType = exports.tsLiteralType = function(literal) {
        return _builder.default.apply("TSLiteralType", arguments);
      }, exports.tSMappedType = exports.tsMappedType = function(typeParameter, typeAnnotation, nameType) {
        return _builder.default.apply("TSMappedType", arguments);
      }, exports.tSMethodSignature = exports.tsMethodSignature = function(key, typeParameters, parameters, typeAnnotation) {
        return _builder.default.apply("TSMethodSignature", arguments);
      }, exports.tSModuleBlock = exports.tsModuleBlock = function(body) {
        return _builder.default.apply("TSModuleBlock", arguments);
      }, exports.tSModuleDeclaration = exports.tsModuleDeclaration = function(id, body) {
        return _builder.default.apply("TSModuleDeclaration", arguments);
      }, exports.tSNamedTupleMember = exports.tsNamedTupleMember = function(label, elementType, optional) {
        return _builder.default.apply("TSNamedTupleMember", arguments);
      }, exports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = function(id) {
        return _builder.default.apply("TSNamespaceExportDeclaration", arguments);
      }, exports.tSNeverKeyword = exports.tsNeverKeyword = function() {
        return _builder.default.apply("TSNeverKeyword", arguments);
      }, exports.tSNonNullExpression = exports.tsNonNullExpression = function(expression) {
        return _builder.default.apply("TSNonNullExpression", arguments);
      }, exports.tSNullKeyword = exports.tsNullKeyword = function() {
        return _builder.default.apply("TSNullKeyword", arguments);
      }, exports.tSNumberKeyword = exports.tsNumberKeyword = function() {
        return _builder.default.apply("TSNumberKeyword", arguments);
      }, exports.tSObjectKeyword = exports.tsObjectKeyword = function() {
        return _builder.default.apply("TSObjectKeyword", arguments);
      }, exports.tSOptionalType = exports.tsOptionalType = function(typeAnnotation) {
        return _builder.default.apply("TSOptionalType", arguments);
      }, exports.tSParameterProperty = exports.tsParameterProperty = function(parameter) {
        return _builder.default.apply("TSParameterProperty", arguments);
      }, exports.tSParenthesizedType = exports.tsParenthesizedType = function(typeAnnotation) {
        return _builder.default.apply("TSParenthesizedType", arguments);
      }, exports.tSPropertySignature = exports.tsPropertySignature = function(key, typeAnnotation, initializer) {
        return _builder.default.apply("TSPropertySignature", arguments);
      }, exports.tSQualifiedName = exports.tsQualifiedName = function(left, right) {
        return _builder.default.apply("TSQualifiedName", arguments);
      }, exports.tSRestType = exports.tsRestType = function(typeAnnotation) {
        return _builder.default.apply("TSRestType", arguments);
      }, exports.tSStringKeyword = exports.tsStringKeyword = function() {
        return _builder.default.apply("TSStringKeyword", arguments);
      }, exports.tSSymbolKeyword = exports.tsSymbolKeyword = function() {
        return _builder.default.apply("TSSymbolKeyword", arguments);
      }, exports.tSThisType = exports.tsThisType = function() {
        return _builder.default.apply("TSThisType", arguments);
      }, exports.tSTupleType = exports.tsTupleType = function(elementTypes) {
        return _builder.default.apply("TSTupleType", arguments);
      }, exports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = function(id, typeParameters, typeAnnotation) {
        return _builder.default.apply("TSTypeAliasDeclaration", arguments);
      }, exports.tSTypeAnnotation = exports.tsTypeAnnotation = function(typeAnnotation) {
        return _builder.default.apply("TSTypeAnnotation", arguments);
      }, exports.tSTypeAssertion = exports.tsTypeAssertion = function(typeAnnotation, expression) {
        return _builder.default.apply("TSTypeAssertion", arguments);
      }, exports.tSTypeLiteral = exports.tsTypeLiteral = function(members) {
        return _builder.default.apply("TSTypeLiteral", arguments);
      }, exports.tSTypeOperator = exports.tsTypeOperator = function(typeAnnotation) {
        return _builder.default.apply("TSTypeOperator", arguments);
      }, exports.tSTypeParameter = exports.tsTypeParameter = function(constraint, _default, name) {
        return _builder.default.apply("TSTypeParameter", arguments);
      }, exports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = function(params) {
        return _builder.default.apply("TSTypeParameterDeclaration", arguments);
      }, exports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = function(params) {
        return _builder.default.apply("TSTypeParameterInstantiation", arguments);
      }, exports.tSTypePredicate = exports.tsTypePredicate = function(parameterName, typeAnnotation, asserts) {
        return _builder.default.apply("TSTypePredicate", arguments);
      }, exports.tSTypeQuery = exports.tsTypeQuery = function(exprName) {
        return _builder.default.apply("TSTypeQuery", arguments);
      }, exports.tSTypeReference = exports.tsTypeReference = function(typeName, typeParameters) {
        return _builder.default.apply("TSTypeReference", arguments);
      }, exports.tSUndefinedKeyword = exports.tsUndefinedKeyword = function() {
        return _builder.default.apply("TSUndefinedKeyword", arguments);
      }, exports.tSUnionType = exports.tsUnionType = function(types) {
        return _builder.default.apply("TSUnionType", arguments);
      }, exports.tSUnknownKeyword = exports.tsUnknownKeyword = function() {
        return _builder.default.apply("TSUnknownKeyword", arguments);
      }, exports.tSVoidKeyword = exports.tsVoidKeyword = function() {
        return _builder.default.apply("TSVoidKeyword", arguments);
      }, exports.tupleExpression = function(elements) {
        return _builder.default.apply("TupleExpression", arguments);
      }, exports.tupleTypeAnnotation = function(types) {
        return _builder.default.apply("TupleTypeAnnotation", arguments);
      }, exports.typeAlias = function(id, typeParameters, right) {
        return _builder.default.apply("TypeAlias", arguments);
      }, exports.typeAnnotation = function(typeAnnotation) {
        return _builder.default.apply("TypeAnnotation", arguments);
      }, exports.typeCastExpression = function(expression, typeAnnotation) {
        return _builder.default.apply("TypeCastExpression", arguments);
      }, exports.typeParameter = function(bound, _default, variance) {
        return _builder.default.apply("TypeParameter", arguments);
      }, exports.typeParameterDeclaration = function(params) {
        return _builder.default.apply("TypeParameterDeclaration", arguments);
      }, exports.typeParameterInstantiation = function(params) {
        return _builder.default.apply("TypeParameterInstantiation", arguments);
      }, exports.typeofTypeAnnotation = function(argument) {
        return _builder.default.apply("TypeofTypeAnnotation", arguments);
      }, exports.unaryExpression = function(operator, argument, prefix) {
        return _builder.default.apply("UnaryExpression", arguments);
      }, exports.unionTypeAnnotation = function(types) {
        return _builder.default.apply("UnionTypeAnnotation", arguments);
      }, exports.updateExpression = function(operator, argument, prefix) {
        return _builder.default.apply("UpdateExpression", arguments);
      }, exports.v8IntrinsicIdentifier = function(name) {
        return _builder.default.apply("V8IntrinsicIdentifier", arguments);
      }, exports.variableDeclaration = function(kind, declarations) {
        return _builder.default.apply("VariableDeclaration", arguments);
      }, exports.variableDeclarator = function(id, init) {
        return _builder.default.apply("VariableDeclarator", arguments);
      }, exports.variance = function(kind) {
        return _builder.default.apply("Variance", arguments);
      }, exports.voidTypeAnnotation = function() {
        return _builder.default.apply("VoidTypeAnnotation", arguments);
      }, exports.whileStatement = function(test, body) {
        return _builder.default.apply("WhileStatement", arguments);
      }, exports.withStatement = function(object, body) {
        return _builder.default.apply("WithStatement", arguments);
      }, exports.yieldExpression = function(argument, delegate) {
        return _builder.default.apply("YieldExpression", arguments);
      };
      var _builder = __webpack_require__(4745);
    },
    6104: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "AnyTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.anyTypeAnnotation;
        }
      }), Object.defineProperty(exports, "ArgumentPlaceholder", {
        enumerable: !0,
        get: function() {
          return _index.argumentPlaceholder;
        }
      }), Object.defineProperty(exports, "ArrayExpression", {
        enumerable: !0,
        get: function() {
          return _index.arrayExpression;
        }
      }), Object.defineProperty(exports, "ArrayPattern", {
        enumerable: !0,
        get: function() {
          return _index.arrayPattern;
        }
      }), Object.defineProperty(exports, "ArrayTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.arrayTypeAnnotation;
        }
      }), Object.defineProperty(exports, "ArrowFunctionExpression", {
        enumerable: !0,
        get: function() {
          return _index.arrowFunctionExpression;
        }
      }), Object.defineProperty(exports, "AssignmentExpression", {
        enumerable: !0,
        get: function() {
          return _index.assignmentExpression;
        }
      }), Object.defineProperty(exports, "AssignmentPattern", {
        enumerable: !0,
        get: function() {
          return _index.assignmentPattern;
        }
      }), Object.defineProperty(exports, "AwaitExpression", {
        enumerable: !0,
        get: function() {
          return _index.awaitExpression;
        }
      }), Object.defineProperty(exports, "BigIntLiteral", {
        enumerable: !0,
        get: function() {
          return _index.bigIntLiteral;
        }
      }), Object.defineProperty(exports, "BinaryExpression", {
        enumerable: !0,
        get: function() {
          return _index.binaryExpression;
        }
      }), Object.defineProperty(exports, "BindExpression", {
        enumerable: !0,
        get: function() {
          return _index.bindExpression;
        }
      }), Object.defineProperty(exports, "BlockStatement", {
        enumerable: !0,
        get: function() {
          return _index.blockStatement;
        }
      }), Object.defineProperty(exports, "BooleanLiteral", {
        enumerable: !0,
        get: function() {
          return _index.booleanLiteral;
        }
      }), Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.booleanLiteralTypeAnnotation;
        }
      }), Object.defineProperty(exports, "BooleanTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.booleanTypeAnnotation;
        }
      }), Object.defineProperty(exports, "BreakStatement", {
        enumerable: !0,
        get: function() {
          return _index.breakStatement;
        }
      }), Object.defineProperty(exports, "CallExpression", {
        enumerable: !0,
        get: function() {
          return _index.callExpression;
        }
      }), Object.defineProperty(exports, "CatchClause", {
        enumerable: !0,
        get: function() {
          return _index.catchClause;
        }
      }), Object.defineProperty(exports, "ClassAccessorProperty", {
        enumerable: !0,
        get: function() {
          return _index.classAccessorProperty;
        }
      }), Object.defineProperty(exports, "ClassBody", {
        enumerable: !0,
        get: function() {
          return _index.classBody;
        }
      }), Object.defineProperty(exports, "ClassDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.classDeclaration;
        }
      }), Object.defineProperty(exports, "ClassExpression", {
        enumerable: !0,
        get: function() {
          return _index.classExpression;
        }
      }), Object.defineProperty(exports, "ClassImplements", {
        enumerable: !0,
        get: function() {
          return _index.classImplements;
        }
      }), Object.defineProperty(exports, "ClassMethod", {
        enumerable: !0,
        get: function() {
          return _index.classMethod;
        }
      }), Object.defineProperty(exports, "ClassPrivateMethod", {
        enumerable: !0,
        get: function() {
          return _index.classPrivateMethod;
        }
      }), Object.defineProperty(exports, "ClassPrivateProperty", {
        enumerable: !0,
        get: function() {
          return _index.classPrivateProperty;
        }
      }), Object.defineProperty(exports, "ClassProperty", {
        enumerable: !0,
        get: function() {
          return _index.classProperty;
        }
      }), Object.defineProperty(exports, "ConditionalExpression", {
        enumerable: !0,
        get: function() {
          return _index.conditionalExpression;
        }
      }), Object.defineProperty(exports, "ContinueStatement", {
        enumerable: !0,
        get: function() {
          return _index.continueStatement;
        }
      }), Object.defineProperty(exports, "DebuggerStatement", {
        enumerable: !0,
        get: function() {
          return _index.debuggerStatement;
        }
      }), Object.defineProperty(exports, "DecimalLiteral", {
        enumerable: !0,
        get: function() {
          return _index.decimalLiteral;
        }
      }), Object.defineProperty(exports, "DeclareClass", {
        enumerable: !0,
        get: function() {
          return _index.declareClass;
        }
      }), Object.defineProperty(exports, "DeclareExportAllDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.declareExportAllDeclaration;
        }
      }), Object.defineProperty(exports, "DeclareExportDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.declareExportDeclaration;
        }
      }), Object.defineProperty(exports, "DeclareFunction", {
        enumerable: !0,
        get: function() {
          return _index.declareFunction;
        }
      }), Object.defineProperty(exports, "DeclareInterface", {
        enumerable: !0,
        get: function() {
          return _index.declareInterface;
        }
      }), Object.defineProperty(exports, "DeclareModule", {
        enumerable: !0,
        get: function() {
          return _index.declareModule;
        }
      }), Object.defineProperty(exports, "DeclareModuleExports", {
        enumerable: !0,
        get: function() {
          return _index.declareModuleExports;
        }
      }), Object.defineProperty(exports, "DeclareOpaqueType", {
        enumerable: !0,
        get: function() {
          return _index.declareOpaqueType;
        }
      }), Object.defineProperty(exports, "DeclareTypeAlias", {
        enumerable: !0,
        get: function() {
          return _index.declareTypeAlias;
        }
      }), Object.defineProperty(exports, "DeclareVariable", {
        enumerable: !0,
        get: function() {
          return _index.declareVariable;
        }
      }), Object.defineProperty(exports, "DeclaredPredicate", {
        enumerable: !0,
        get: function() {
          return _index.declaredPredicate;
        }
      }), Object.defineProperty(exports, "Decorator", {
        enumerable: !0,
        get: function() {
          return _index.decorator;
        }
      }), Object.defineProperty(exports, "Directive", {
        enumerable: !0,
        get: function() {
          return _index.directive;
        }
      }), Object.defineProperty(exports, "DirectiveLiteral", {
        enumerable: !0,
        get: function() {
          return _index.directiveLiteral;
        }
      }), Object.defineProperty(exports, "DoExpression", {
        enumerable: !0,
        get: function() {
          return _index.doExpression;
        }
      }), Object.defineProperty(exports, "DoWhileStatement", {
        enumerable: !0,
        get: function() {
          return _index.doWhileStatement;
        }
      }), Object.defineProperty(exports, "EmptyStatement", {
        enumerable: !0,
        get: function() {
          return _index.emptyStatement;
        }
      }), Object.defineProperty(exports, "EmptyTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.emptyTypeAnnotation;
        }
      }), Object.defineProperty(exports, "EnumBooleanBody", {
        enumerable: !0,
        get: function() {
          return _index.enumBooleanBody;
        }
      }), Object.defineProperty(exports, "EnumBooleanMember", {
        enumerable: !0,
        get: function() {
          return _index.enumBooleanMember;
        }
      }), Object.defineProperty(exports, "EnumDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.enumDeclaration;
        }
      }), Object.defineProperty(exports, "EnumDefaultedMember", {
        enumerable: !0,
        get: function() {
          return _index.enumDefaultedMember;
        }
      }), Object.defineProperty(exports, "EnumNumberBody", {
        enumerable: !0,
        get: function() {
          return _index.enumNumberBody;
        }
      }), Object.defineProperty(exports, "EnumNumberMember", {
        enumerable: !0,
        get: function() {
          return _index.enumNumberMember;
        }
      }), Object.defineProperty(exports, "EnumStringBody", {
        enumerable: !0,
        get: function() {
          return _index.enumStringBody;
        }
      }), Object.defineProperty(exports, "EnumStringMember", {
        enumerable: !0,
        get: function() {
          return _index.enumStringMember;
        }
      }), Object.defineProperty(exports, "EnumSymbolBody", {
        enumerable: !0,
        get: function() {
          return _index.enumSymbolBody;
        }
      }), Object.defineProperty(exports, "ExistsTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.existsTypeAnnotation;
        }
      }), Object.defineProperty(exports, "ExportAllDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.exportAllDeclaration;
        }
      }), Object.defineProperty(exports, "ExportDefaultDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.exportDefaultDeclaration;
        }
      }), Object.defineProperty(exports, "ExportDefaultSpecifier", {
        enumerable: !0,
        get: function() {
          return _index.exportDefaultSpecifier;
        }
      }), Object.defineProperty(exports, "ExportNamedDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.exportNamedDeclaration;
        }
      }), Object.defineProperty(exports, "ExportNamespaceSpecifier", {
        enumerable: !0,
        get: function() {
          return _index.exportNamespaceSpecifier;
        }
      }), Object.defineProperty(exports, "ExportSpecifier", {
        enumerable: !0,
        get: function() {
          return _index.exportSpecifier;
        }
      }), Object.defineProperty(exports, "ExpressionStatement", {
        enumerable: !0,
        get: function() {
          return _index.expressionStatement;
        }
      }), Object.defineProperty(exports, "File", {
        enumerable: !0,
        get: function() {
          return _index.file;
        }
      }), Object.defineProperty(exports, "ForInStatement", {
        enumerable: !0,
        get: function() {
          return _index.forInStatement;
        }
      }), Object.defineProperty(exports, "ForOfStatement", {
        enumerable: !0,
        get: function() {
          return _index.forOfStatement;
        }
      }), Object.defineProperty(exports, "ForStatement", {
        enumerable: !0,
        get: function() {
          return _index.forStatement;
        }
      }), Object.defineProperty(exports, "FunctionDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.functionDeclaration;
        }
      }), Object.defineProperty(exports, "FunctionExpression", {
        enumerable: !0,
        get: function() {
          return _index.functionExpression;
        }
      }), Object.defineProperty(exports, "FunctionTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.functionTypeAnnotation;
        }
      }), Object.defineProperty(exports, "FunctionTypeParam", {
        enumerable: !0,
        get: function() {
          return _index.functionTypeParam;
        }
      }), Object.defineProperty(exports, "GenericTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.genericTypeAnnotation;
        }
      }), Object.defineProperty(exports, "Identifier", {
        enumerable: !0,
        get: function() {
          return _index.identifier;
        }
      }), Object.defineProperty(exports, "IfStatement", {
        enumerable: !0,
        get: function() {
          return _index.ifStatement;
        }
      }), Object.defineProperty(exports, "Import", {
        enumerable: !0,
        get: function() {
          return _index.import;
        }
      }), Object.defineProperty(exports, "ImportAttribute", {
        enumerable: !0,
        get: function() {
          return _index.importAttribute;
        }
      }), Object.defineProperty(exports, "ImportDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.importDeclaration;
        }
      }), Object.defineProperty(exports, "ImportDefaultSpecifier", {
        enumerable: !0,
        get: function() {
          return _index.importDefaultSpecifier;
        }
      }), Object.defineProperty(exports, "ImportNamespaceSpecifier", {
        enumerable: !0,
        get: function() {
          return _index.importNamespaceSpecifier;
        }
      }), Object.defineProperty(exports, "ImportSpecifier", {
        enumerable: !0,
        get: function() {
          return _index.importSpecifier;
        }
      }), Object.defineProperty(exports, "IndexedAccessType", {
        enumerable: !0,
        get: function() {
          return _index.indexedAccessType;
        }
      }), Object.defineProperty(exports, "InferredPredicate", {
        enumerable: !0,
        get: function() {
          return _index.inferredPredicate;
        }
      }), Object.defineProperty(exports, "InterfaceDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.interfaceDeclaration;
        }
      }), Object.defineProperty(exports, "InterfaceExtends", {
        enumerable: !0,
        get: function() {
          return _index.interfaceExtends;
        }
      }), Object.defineProperty(exports, "InterfaceTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.interfaceTypeAnnotation;
        }
      }), Object.defineProperty(exports, "InterpreterDirective", {
        enumerable: !0,
        get: function() {
          return _index.interpreterDirective;
        }
      }), Object.defineProperty(exports, "IntersectionTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.intersectionTypeAnnotation;
        }
      }), Object.defineProperty(exports, "JSXAttribute", {
        enumerable: !0,
        get: function() {
          return _index.jsxAttribute;
        }
      }), Object.defineProperty(exports, "JSXClosingElement", {
        enumerable: !0,
        get: function() {
          return _index.jsxClosingElement;
        }
      }), Object.defineProperty(exports, "JSXClosingFragment", {
        enumerable: !0,
        get: function() {
          return _index.jsxClosingFragment;
        }
      }), Object.defineProperty(exports, "JSXElement", {
        enumerable: !0,
        get: function() {
          return _index.jsxElement;
        }
      }), Object.defineProperty(exports, "JSXEmptyExpression", {
        enumerable: !0,
        get: function() {
          return _index.jsxEmptyExpression;
        }
      }), Object.defineProperty(exports, "JSXExpressionContainer", {
        enumerable: !0,
        get: function() {
          return _index.jsxExpressionContainer;
        }
      }), Object.defineProperty(exports, "JSXFragment", {
        enumerable: !0,
        get: function() {
          return _index.jsxFragment;
        }
      }), Object.defineProperty(exports, "JSXIdentifier", {
        enumerable: !0,
        get: function() {
          return _index.jsxIdentifier;
        }
      }), Object.defineProperty(exports, "JSXMemberExpression", {
        enumerable: !0,
        get: function() {
          return _index.jsxMemberExpression;
        }
      }), Object.defineProperty(exports, "JSXNamespacedName", {
        enumerable: !0,
        get: function() {
          return _index.jsxNamespacedName;
        }
      }), Object.defineProperty(exports, "JSXOpeningElement", {
        enumerable: !0,
        get: function() {
          return _index.jsxOpeningElement;
        }
      }), Object.defineProperty(exports, "JSXOpeningFragment", {
        enumerable: !0,
        get: function() {
          return _index.jsxOpeningFragment;
        }
      }), Object.defineProperty(exports, "JSXSpreadAttribute", {
        enumerable: !0,
        get: function() {
          return _index.jsxSpreadAttribute;
        }
      }), Object.defineProperty(exports, "JSXSpreadChild", {
        enumerable: !0,
        get: function() {
          return _index.jsxSpreadChild;
        }
      }), Object.defineProperty(exports, "JSXText", {
        enumerable: !0,
        get: function() {
          return _index.jsxText;
        }
      }), Object.defineProperty(exports, "LabeledStatement", {
        enumerable: !0,
        get: function() {
          return _index.labeledStatement;
        }
      }), Object.defineProperty(exports, "LogicalExpression", {
        enumerable: !0,
        get: function() {
          return _index.logicalExpression;
        }
      }), Object.defineProperty(exports, "MemberExpression", {
        enumerable: !0,
        get: function() {
          return _index.memberExpression;
        }
      }), Object.defineProperty(exports, "MetaProperty", {
        enumerable: !0,
        get: function() {
          return _index.metaProperty;
        }
      }), Object.defineProperty(exports, "MixedTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.mixedTypeAnnotation;
        }
      }), Object.defineProperty(exports, "ModuleExpression", {
        enumerable: !0,
        get: function() {
          return _index.moduleExpression;
        }
      }), Object.defineProperty(exports, "NewExpression", {
        enumerable: !0,
        get: function() {
          return _index.newExpression;
        }
      }), Object.defineProperty(exports, "Noop", {
        enumerable: !0,
        get: function() {
          return _index.noop;
        }
      }), Object.defineProperty(exports, "NullLiteral", {
        enumerable: !0,
        get: function() {
          return _index.nullLiteral;
        }
      }), Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.nullLiteralTypeAnnotation;
        }
      }), Object.defineProperty(exports, "NullableTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.nullableTypeAnnotation;
        }
      }), Object.defineProperty(exports, "NumberLiteral", {
        enumerable: !0,
        get: function() {
          return _index.numberLiteral;
        }
      }), Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.numberLiteralTypeAnnotation;
        }
      }), Object.defineProperty(exports, "NumberTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.numberTypeAnnotation;
        }
      }), Object.defineProperty(exports, "NumericLiteral", {
        enumerable: !0,
        get: function() {
          return _index.numericLiteral;
        }
      }), Object.defineProperty(exports, "ObjectExpression", {
        enumerable: !0,
        get: function() {
          return _index.objectExpression;
        }
      }), Object.defineProperty(exports, "ObjectMethod", {
        enumerable: !0,
        get: function() {
          return _index.objectMethod;
        }
      }), Object.defineProperty(exports, "ObjectPattern", {
        enumerable: !0,
        get: function() {
          return _index.objectPattern;
        }
      }), Object.defineProperty(exports, "ObjectProperty", {
        enumerable: !0,
        get: function() {
          return _index.objectProperty;
        }
      }), Object.defineProperty(exports, "ObjectTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.objectTypeAnnotation;
        }
      }), Object.defineProperty(exports, "ObjectTypeCallProperty", {
        enumerable: !0,
        get: function() {
          return _index.objectTypeCallProperty;
        }
      }), Object.defineProperty(exports, "ObjectTypeIndexer", {
        enumerable: !0,
        get: function() {
          return _index.objectTypeIndexer;
        }
      }), Object.defineProperty(exports, "ObjectTypeInternalSlot", {
        enumerable: !0,
        get: function() {
          return _index.objectTypeInternalSlot;
        }
      }), Object.defineProperty(exports, "ObjectTypeProperty", {
        enumerable: !0,
        get: function() {
          return _index.objectTypeProperty;
        }
      }), Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
        enumerable: !0,
        get: function() {
          return _index.objectTypeSpreadProperty;
        }
      }), Object.defineProperty(exports, "OpaqueType", {
        enumerable: !0,
        get: function() {
          return _index.opaqueType;
        }
      }), Object.defineProperty(exports, "OptionalCallExpression", {
        enumerable: !0,
        get: function() {
          return _index.optionalCallExpression;
        }
      }), Object.defineProperty(exports, "OptionalIndexedAccessType", {
        enumerable: !0,
        get: function() {
          return _index.optionalIndexedAccessType;
        }
      }), Object.defineProperty(exports, "OptionalMemberExpression", {
        enumerable: !0,
        get: function() {
          return _index.optionalMemberExpression;
        }
      }), Object.defineProperty(exports, "ParenthesizedExpression", {
        enumerable: !0,
        get: function() {
          return _index.parenthesizedExpression;
        }
      }), Object.defineProperty(exports, "PipelineBareFunction", {
        enumerable: !0,
        get: function() {
          return _index.pipelineBareFunction;
        }
      }), Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
        enumerable: !0,
        get: function() {
          return _index.pipelinePrimaryTopicReference;
        }
      }), Object.defineProperty(exports, "PipelineTopicExpression", {
        enumerable: !0,
        get: function() {
          return _index.pipelineTopicExpression;
        }
      }), Object.defineProperty(exports, "Placeholder", {
        enumerable: !0,
        get: function() {
          return _index.placeholder;
        }
      }), Object.defineProperty(exports, "PrivateName", {
        enumerable: !0,
        get: function() {
          return _index.privateName;
        }
      }), Object.defineProperty(exports, "Program", {
        enumerable: !0,
        get: function() {
          return _index.program;
        }
      }), Object.defineProperty(exports, "QualifiedTypeIdentifier", {
        enumerable: !0,
        get: function() {
          return _index.qualifiedTypeIdentifier;
        }
      }), Object.defineProperty(exports, "RecordExpression", {
        enumerable: !0,
        get: function() {
          return _index.recordExpression;
        }
      }), Object.defineProperty(exports, "RegExpLiteral", {
        enumerable: !0,
        get: function() {
          return _index.regExpLiteral;
        }
      }), Object.defineProperty(exports, "RegexLiteral", {
        enumerable: !0,
        get: function() {
          return _index.regexLiteral;
        }
      }), Object.defineProperty(exports, "RestElement", {
        enumerable: !0,
        get: function() {
          return _index.restElement;
        }
      }), Object.defineProperty(exports, "RestProperty", {
        enumerable: !0,
        get: function() {
          return _index.restProperty;
        }
      }), Object.defineProperty(exports, "ReturnStatement", {
        enumerable: !0,
        get: function() {
          return _index.returnStatement;
        }
      }), Object.defineProperty(exports, "SequenceExpression", {
        enumerable: !0,
        get: function() {
          return _index.sequenceExpression;
        }
      }), Object.defineProperty(exports, "SpreadElement", {
        enumerable: !0,
        get: function() {
          return _index.spreadElement;
        }
      }), Object.defineProperty(exports, "SpreadProperty", {
        enumerable: !0,
        get: function() {
          return _index.spreadProperty;
        }
      }), Object.defineProperty(exports, "StaticBlock", {
        enumerable: !0,
        get: function() {
          return _index.staticBlock;
        }
      }), Object.defineProperty(exports, "StringLiteral", {
        enumerable: !0,
        get: function() {
          return _index.stringLiteral;
        }
      }), Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.stringLiteralTypeAnnotation;
        }
      }), Object.defineProperty(exports, "StringTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.stringTypeAnnotation;
        }
      }), Object.defineProperty(exports, "Super", {
        enumerable: !0,
        get: function() {
          return _index.super;
        }
      }), Object.defineProperty(exports, "SwitchCase", {
        enumerable: !0,
        get: function() {
          return _index.switchCase;
        }
      }), Object.defineProperty(exports, "SwitchStatement", {
        enumerable: !0,
        get: function() {
          return _index.switchStatement;
        }
      }), Object.defineProperty(exports, "SymbolTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.symbolTypeAnnotation;
        }
      }), Object.defineProperty(exports, "TSAnyKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsAnyKeyword;
        }
      }), Object.defineProperty(exports, "TSArrayType", {
        enumerable: !0,
        get: function() {
          return _index.tsArrayType;
        }
      }), Object.defineProperty(exports, "TSAsExpression", {
        enumerable: !0,
        get: function() {
          return _index.tsAsExpression;
        }
      }), Object.defineProperty(exports, "TSBigIntKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsBigIntKeyword;
        }
      }), Object.defineProperty(exports, "TSBooleanKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsBooleanKeyword;
        }
      }), Object.defineProperty(exports, "TSCallSignatureDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsCallSignatureDeclaration;
        }
      }), Object.defineProperty(exports, "TSConditionalType", {
        enumerable: !0,
        get: function() {
          return _index.tsConditionalType;
        }
      }), Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsConstructSignatureDeclaration;
        }
      }), Object.defineProperty(exports, "TSConstructorType", {
        enumerable: !0,
        get: function() {
          return _index.tsConstructorType;
        }
      }), Object.defineProperty(exports, "TSDeclareFunction", {
        enumerable: !0,
        get: function() {
          return _index.tsDeclareFunction;
        }
      }), Object.defineProperty(exports, "TSDeclareMethod", {
        enumerable: !0,
        get: function() {
          return _index.tsDeclareMethod;
        }
      }), Object.defineProperty(exports, "TSEnumDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsEnumDeclaration;
        }
      }), Object.defineProperty(exports, "TSEnumMember", {
        enumerable: !0,
        get: function() {
          return _index.tsEnumMember;
        }
      }), Object.defineProperty(exports, "TSExportAssignment", {
        enumerable: !0,
        get: function() {
          return _index.tsExportAssignment;
        }
      }), Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
        enumerable: !0,
        get: function() {
          return _index.tsExpressionWithTypeArguments;
        }
      }), Object.defineProperty(exports, "TSExternalModuleReference", {
        enumerable: !0,
        get: function() {
          return _index.tsExternalModuleReference;
        }
      }), Object.defineProperty(exports, "TSFunctionType", {
        enumerable: !0,
        get: function() {
          return _index.tsFunctionType;
        }
      }), Object.defineProperty(exports, "TSImportEqualsDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsImportEqualsDeclaration;
        }
      }), Object.defineProperty(exports, "TSImportType", {
        enumerable: !0,
        get: function() {
          return _index.tsImportType;
        }
      }), Object.defineProperty(exports, "TSIndexSignature", {
        enumerable: !0,
        get: function() {
          return _index.tsIndexSignature;
        }
      }), Object.defineProperty(exports, "TSIndexedAccessType", {
        enumerable: !0,
        get: function() {
          return _index.tsIndexedAccessType;
        }
      }), Object.defineProperty(exports, "TSInferType", {
        enumerable: !0,
        get: function() {
          return _index.tsInferType;
        }
      }), Object.defineProperty(exports, "TSInterfaceBody", {
        enumerable: !0,
        get: function() {
          return _index.tsInterfaceBody;
        }
      }), Object.defineProperty(exports, "TSInterfaceDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsInterfaceDeclaration;
        }
      }), Object.defineProperty(exports, "TSIntersectionType", {
        enumerable: !0,
        get: function() {
          return _index.tsIntersectionType;
        }
      }), Object.defineProperty(exports, "TSIntrinsicKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsIntrinsicKeyword;
        }
      }), Object.defineProperty(exports, "TSLiteralType", {
        enumerable: !0,
        get: function() {
          return _index.tsLiteralType;
        }
      }), Object.defineProperty(exports, "TSMappedType", {
        enumerable: !0,
        get: function() {
          return _index.tsMappedType;
        }
      }), Object.defineProperty(exports, "TSMethodSignature", {
        enumerable: !0,
        get: function() {
          return _index.tsMethodSignature;
        }
      }), Object.defineProperty(exports, "TSModuleBlock", {
        enumerable: !0,
        get: function() {
          return _index.tsModuleBlock;
        }
      }), Object.defineProperty(exports, "TSModuleDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsModuleDeclaration;
        }
      }), Object.defineProperty(exports, "TSNamedTupleMember", {
        enumerable: !0,
        get: function() {
          return _index.tsNamedTupleMember;
        }
      }), Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsNamespaceExportDeclaration;
        }
      }), Object.defineProperty(exports, "TSNeverKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsNeverKeyword;
        }
      }), Object.defineProperty(exports, "TSNonNullExpression", {
        enumerable: !0,
        get: function() {
          return _index.tsNonNullExpression;
        }
      }), Object.defineProperty(exports, "TSNullKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsNullKeyword;
        }
      }), Object.defineProperty(exports, "TSNumberKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsNumberKeyword;
        }
      }), Object.defineProperty(exports, "TSObjectKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsObjectKeyword;
        }
      }), Object.defineProperty(exports, "TSOptionalType", {
        enumerable: !0,
        get: function() {
          return _index.tsOptionalType;
        }
      }), Object.defineProperty(exports, "TSParameterProperty", {
        enumerable: !0,
        get: function() {
          return _index.tsParameterProperty;
        }
      }), Object.defineProperty(exports, "TSParenthesizedType", {
        enumerable: !0,
        get: function() {
          return _index.tsParenthesizedType;
        }
      }), Object.defineProperty(exports, "TSPropertySignature", {
        enumerable: !0,
        get: function() {
          return _index.tsPropertySignature;
        }
      }), Object.defineProperty(exports, "TSQualifiedName", {
        enumerable: !0,
        get: function() {
          return _index.tsQualifiedName;
        }
      }), Object.defineProperty(exports, "TSRestType", {
        enumerable: !0,
        get: function() {
          return _index.tsRestType;
        }
      }), Object.defineProperty(exports, "TSStringKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsStringKeyword;
        }
      }), Object.defineProperty(exports, "TSSymbolKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsSymbolKeyword;
        }
      }), Object.defineProperty(exports, "TSThisType", {
        enumerable: !0,
        get: function() {
          return _index.tsThisType;
        }
      }), Object.defineProperty(exports, "TSTupleType", {
        enumerable: !0,
        get: function() {
          return _index.tsTupleType;
        }
      }), Object.defineProperty(exports, "TSTypeAliasDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeAliasDeclaration;
        }
      }), Object.defineProperty(exports, "TSTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeAnnotation;
        }
      }), Object.defineProperty(exports, "TSTypeAssertion", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeAssertion;
        }
      }), Object.defineProperty(exports, "TSTypeLiteral", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeLiteral;
        }
      }), Object.defineProperty(exports, "TSTypeOperator", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeOperator;
        }
      }), Object.defineProperty(exports, "TSTypeParameter", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeParameter;
        }
      }), Object.defineProperty(exports, "TSTypeParameterDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeParameterDeclaration;
        }
      }), Object.defineProperty(exports, "TSTypeParameterInstantiation", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeParameterInstantiation;
        }
      }), Object.defineProperty(exports, "TSTypePredicate", {
        enumerable: !0,
        get: function() {
          return _index.tsTypePredicate;
        }
      }), Object.defineProperty(exports, "TSTypeQuery", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeQuery;
        }
      }), Object.defineProperty(exports, "TSTypeReference", {
        enumerable: !0,
        get: function() {
          return _index.tsTypeReference;
        }
      }), Object.defineProperty(exports, "TSUndefinedKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsUndefinedKeyword;
        }
      }), Object.defineProperty(exports, "TSUnionType", {
        enumerable: !0,
        get: function() {
          return _index.tsUnionType;
        }
      }), Object.defineProperty(exports, "TSUnknownKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsUnknownKeyword;
        }
      }), Object.defineProperty(exports, "TSVoidKeyword", {
        enumerable: !0,
        get: function() {
          return _index.tsVoidKeyword;
        }
      }), Object.defineProperty(exports, "TaggedTemplateExpression", {
        enumerable: !0,
        get: function() {
          return _index.taggedTemplateExpression;
        }
      }), Object.defineProperty(exports, "TemplateElement", {
        enumerable: !0,
        get: function() {
          return _index.templateElement;
        }
      }), Object.defineProperty(exports, "TemplateLiteral", {
        enumerable: !0,
        get: function() {
          return _index.templateLiteral;
        }
      }), Object.defineProperty(exports, "ThisExpression", {
        enumerable: !0,
        get: function() {
          return _index.thisExpression;
        }
      }), Object.defineProperty(exports, "ThisTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.thisTypeAnnotation;
        }
      }), Object.defineProperty(exports, "ThrowStatement", {
        enumerable: !0,
        get: function() {
          return _index.throwStatement;
        }
      }), Object.defineProperty(exports, "TopicReference", {
        enumerable: !0,
        get: function() {
          return _index.topicReference;
        }
      }), Object.defineProperty(exports, "TryStatement", {
        enumerable: !0,
        get: function() {
          return _index.tryStatement;
        }
      }), Object.defineProperty(exports, "TupleExpression", {
        enumerable: !0,
        get: function() {
          return _index.tupleExpression;
        }
      }), Object.defineProperty(exports, "TupleTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.tupleTypeAnnotation;
        }
      }), Object.defineProperty(exports, "TypeAlias", {
        enumerable: !0,
        get: function() {
          return _index.typeAlias;
        }
      }), Object.defineProperty(exports, "TypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.typeAnnotation;
        }
      }), Object.defineProperty(exports, "TypeCastExpression", {
        enumerable: !0,
        get: function() {
          return _index.typeCastExpression;
        }
      }), Object.defineProperty(exports, "TypeParameter", {
        enumerable: !0,
        get: function() {
          return _index.typeParameter;
        }
      }), Object.defineProperty(exports, "TypeParameterDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.typeParameterDeclaration;
        }
      }), Object.defineProperty(exports, "TypeParameterInstantiation", {
        enumerable: !0,
        get: function() {
          return _index.typeParameterInstantiation;
        }
      }), Object.defineProperty(exports, "TypeofTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.typeofTypeAnnotation;
        }
      }), Object.defineProperty(exports, "UnaryExpression", {
        enumerable: !0,
        get: function() {
          return _index.unaryExpression;
        }
      }), Object.defineProperty(exports, "UnionTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.unionTypeAnnotation;
        }
      }), Object.defineProperty(exports, "UpdateExpression", {
        enumerable: !0,
        get: function() {
          return _index.updateExpression;
        }
      }), Object.defineProperty(exports, "V8IntrinsicIdentifier", {
        enumerable: !0,
        get: function() {
          return _index.v8IntrinsicIdentifier;
        }
      }), Object.defineProperty(exports, "VariableDeclaration", {
        enumerable: !0,
        get: function() {
          return _index.variableDeclaration;
        }
      }), Object.defineProperty(exports, "VariableDeclarator", {
        enumerable: !0,
        get: function() {
          return _index.variableDeclarator;
        }
      }), Object.defineProperty(exports, "Variance", {
        enumerable: !0,
        get: function() {
          return _index.variance;
        }
      }), Object.defineProperty(exports, "VoidTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _index.voidTypeAnnotation;
        }
      }), Object.defineProperty(exports, "WhileStatement", {
        enumerable: !0,
        get: function() {
          return _index.whileStatement;
        }
      }), Object.defineProperty(exports, "WithStatement", {
        enumerable: !0,
        get: function() {
          return _index.withStatement;
        }
      }), Object.defineProperty(exports, "YieldExpression", {
        enumerable: !0,
        get: function() {
          return _index.yieldExpression;
        }
      });
      var _index = __webpack_require__(4391);
    },
    8478: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        const elements = [];
        for (let i = 0; i < node.children.length; i++) {
          let child = node.children[i];
          (0, _generated.isJSXText)(child) ? (0, _cleanJSXElementLiteralChild.default)(child, elements) : ((0, 
          _generated.isJSXExpressionContainer)(child) && (child = child.expression), (0, _generated.isJSXEmptyExpression)(child) || elements.push(child));
        }
        return elements;
      };
      var _generated = __webpack_require__(4746), _cleanJSXElementLiteralChild = __webpack_require__(5835);
    },
    4571: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(typeAnnotations) {
        const types = typeAnnotations.map((type => type.typeAnnotation)), flattened = (0, 
        _removeTypeDuplicates.default)(types);
        return 1 === flattened.length ? flattened[0] : (0, _generated.tsUnionType)(flattened);
      };
      var _generated = __webpack_require__(4391), _removeTypeDuplicates = __webpack_require__(1954);
    },
    2363: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _cloneNode.default)(node, !1);
      };
      var _cloneNode = __webpack_require__(6209);
    },
    6953: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _cloneNode.default)(node);
      };
      var _cloneNode = __webpack_require__(6209);
    },
    863: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _cloneNode.default)(node, !0, !0);
      };
      var _cloneNode = __webpack_require__(6209);
    },
    6209: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = cloneNode;
      var _definitions = __webpack_require__(6507), _generated = __webpack_require__(4746);
      const has = Function.call.bind(Object.prototype.hasOwnProperty);
      function cloneIfNode(obj, deep, withoutLoc) {
        return obj && "string" == typeof obj.type ? cloneNode(obj, deep, withoutLoc) : obj;
      }
      function cloneIfNodeOrArray(obj, deep, withoutLoc) {
        return Array.isArray(obj) ? obj.map((node => cloneIfNode(node, deep, withoutLoc))) : cloneIfNode(obj, deep, withoutLoc);
      }
      function cloneNode(node, deep = !0, withoutLoc = !1) {
        if (!node) return node;
        const {type} = node, newNode = {
          type: node.type
        };
        if ((0, _generated.isIdentifier)(node)) newNode.name = node.name, has(node, "optional") && "boolean" == typeof node.optional && (newNode.optional = node.optional), 
        has(node, "typeAnnotation") && (newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, !0, withoutLoc) : node.typeAnnotation); else {
          if (!has(_definitions.NODE_FIELDS, type)) throw new Error(`Unknown node type: "${type}"`);
          for (const field of Object.keys(_definitions.NODE_FIELDS[type])) has(node, field) && (newNode[field] = deep ? (0, 
          _generated.isFile)(node) && "comments" === field ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], !0, withoutLoc) : node[field]);
        }
        return has(node, "loc") && (newNode.loc = withoutLoc ? null : node.loc), has(node, "leadingComments") && (newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc)), 
        has(node, "innerComments") && (newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc)), 
        has(node, "trailingComments") && (newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc)), 
        has(node, "extra") && (newNode.extra = Object.assign({}, node.extra)), newNode;
      }
      function maybeCloneComments(comments, deep, withoutLoc) {
        return comments && deep ? comments.map((({type, value, loc}) => withoutLoc ? {
          type,
          value,
          loc: null
        } : {
          type,
          value,
          loc
        })) : comments;
      }
    },
    748: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _cloneNode.default)(node, !1, !0);
      };
      var _cloneNode = __webpack_require__(6209);
    },
    9529: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, type, content, line) {
        return (0, _addComments.default)(node, type, [ {
          type: line ? "CommentLine" : "CommentBlock",
          value: content
        } ]);
      };
      var _addComments = __webpack_require__(6182);
    },
    6182: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, type, comments) {
        if (!comments || !node) return node;
        const key = `${type}Comments`;
        node[key] ? "leading" === type ? node[key] = comments.concat(node[key]) : node[key].push(...comments) : node[key] = comments;
        return node;
      };
    },
    6455: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(child, parent) {
        (0, _inherit.default)("innerComments", child, parent);
      };
      var _inherit = __webpack_require__(8834);
    },
    1835: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(child, parent) {
        (0, _inherit.default)("leadingComments", child, parent);
      };
      var _inherit = __webpack_require__(8834);
    },
    9653: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(child, parent) {
        (0, _inherit.default)("trailingComments", child, parent);
      };
      var _inherit = __webpack_require__(8834);
    },
    9564: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(child, parent) {
        return (0, _inheritTrailingComments.default)(child, parent), (0, _inheritLeadingComments.default)(child, parent), 
        (0, _inheritInnerComments.default)(child, parent), child;
      };
      var _inheritTrailingComments = __webpack_require__(9653), _inheritLeadingComments = __webpack_require__(1835), _inheritInnerComments = __webpack_require__(6455);
    },
    1200: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return _constants.COMMENT_KEYS.forEach((key => {
          node[key] = null;
        })), node;
      };
      var _constants = __webpack_require__(6325);
    },
    8267: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;
      var _definitions = __webpack_require__(6507);
      const STANDARDIZED_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Standardized;
      exports.STANDARDIZED_TYPES = STANDARDIZED_TYPES;
      const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Expression;
      exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
      const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Binary;
      exports.BINARY_TYPES = BINARY_TYPES;
      const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Scopable;
      exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
      const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.BlockParent;
      exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
      const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Block;
      exports.BLOCK_TYPES = BLOCK_TYPES;
      const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Statement;
      exports.STATEMENT_TYPES = STATEMENT_TYPES;
      const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Terminatorless;
      exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
      const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.CompletionStatement;
      exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
      const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Conditional;
      exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
      const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Loop;
      exports.LOOP_TYPES = LOOP_TYPES;
      const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.While;
      exports.WHILE_TYPES = WHILE_TYPES;
      const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
      exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
      const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS.For;
      exports.FOR_TYPES = FOR_TYPES;
      const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ForXStatement;
      exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
      const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Function;
      exports.FUNCTION_TYPES = FUNCTION_TYPES;
      const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FunctionParent;
      exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
      const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pureish;
      exports.PUREISH_TYPES = PUREISH_TYPES;
      const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Declaration;
      exports.DECLARATION_TYPES = DECLARATION_TYPES;
      const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.PatternLike;
      exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
      const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.LVal;
      exports.LVAL_TYPES = LVAL_TYPES;
      const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSEntityName;
      exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
      const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Literal;
      exports.LITERAL_TYPES = LITERAL_TYPES;
      const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Immutable;
      exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
      const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UserWhitespacable;
      exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
      const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Method;
      exports.METHOD_TYPES = METHOD_TYPES;
      const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ObjectMember;
      exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
      const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Property;
      exports.PROPERTY_TYPES = PROPERTY_TYPES;
      const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UnaryLike;
      exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
      const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pattern;
      exports.PATTERN_TYPES = PATTERN_TYPES;
      const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Class;
      exports.CLASS_TYPES = CLASS_TYPES;
      const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
      exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
      const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExportDeclaration;
      exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
      const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
      exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
      const ACCESSOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Accessor;
      exports.ACCESSOR_TYPES = ACCESSOR_TYPES;
      const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Private;
      exports.PRIVATE_TYPES = PRIVATE_TYPES;
      const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Flow;
      exports.FLOW_TYPES = FLOW_TYPES;
      const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowType;
      exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
      const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
      exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
      const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowDeclaration;
      exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
      const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowPredicate;
      exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
      const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumBody;
      exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
      const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumMember;
      exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
      const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS.JSX;
      exports.JSX_TYPES = JSX_TYPES;
      const MISCELLANEOUS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Miscellaneous;
      exports.MISCELLANEOUS_TYPES = MISCELLANEOUS_TYPES;
      const TYPESCRIPT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TypeScript;
      exports.TYPESCRIPT_TYPES = TYPESCRIPT_TYPES;
      const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSTypeElement;
      exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
      const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSType;
      exports.TSTYPE_TYPES = TSTYPE_TYPES;
      const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSBaseType;
      exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
    },
    6325: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;
      exports.STATEMENT_OR_BLOCK_KEYS = [ "consequent", "body", "alternate" ];
      exports.FLATTENABLE_KEYS = [ "body", "expressions" ];
      exports.FOR_INIT_KEYS = [ "left", "init" ];
      exports.COMMENT_KEYS = [ "leadingComments", "trailingComments", "innerComments" ];
      const LOGICAL_OPERATORS = [ "||", "&&", "??" ];
      exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
      exports.UPDATE_OPERATORS = [ "++", "--" ];
      const BOOLEAN_NUMBER_BINARY_OPERATORS = [ ">", "<", ">=", "<=" ];
      exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
      const EQUALITY_BINARY_OPERATORS = [ "==", "===", "!=", "!==" ];
      exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
      const COMPARISON_BINARY_OPERATORS = [ ...EQUALITY_BINARY_OPERATORS, "in", "instanceof" ];
      exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
      const BOOLEAN_BINARY_OPERATORS = [ ...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS ];
      exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
      const NUMBER_BINARY_OPERATORS = [ "-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^" ];
      exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
      const BINARY_OPERATORS = [ "+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS ];
      exports.BINARY_OPERATORS = BINARY_OPERATORS;
      const ASSIGNMENT_OPERATORS = [ "=", "+=", ...NUMBER_BINARY_OPERATORS.map((op => op + "=")), ...LOGICAL_OPERATORS.map((op => op + "=")) ];
      exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
      const BOOLEAN_UNARY_OPERATORS = [ "delete", "!" ];
      exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
      const NUMBER_UNARY_OPERATORS = [ "+", "-", "~" ];
      exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
      const STRING_UNARY_OPERATORS = [ "typeof" ];
      exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
      const UNARY_OPERATORS = [ "void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS ];
      exports.UNARY_OPERATORS = UNARY_OPERATORS;
      exports.INHERIT_KEYS = {
        optional: [ "typeAnnotation", "typeParameters", "returnType" ],
        force: [ "start", "loc", "end" ]
      };
      const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
      exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
      const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
      exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
    },
    4315: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, key = "body") {
        return node[key] = (0, _toBlock.default)(node[key], node);
      };
      var _toBlock = __webpack_require__(9276);
    },
    696: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function gatherSequenceExpressions(nodes, scope, declars) {
        const exprs = [];
        let ensureLastUndefined = !0;
        for (const node of nodes) if ((0, _generated.isEmptyStatement)(node) || (ensureLastUndefined = !1), 
        (0, _generated.isExpression)(node)) exprs.push(node); else if ((0, _generated.isExpressionStatement)(node)) exprs.push(node.expression); else if ((0, 
        _generated.isVariableDeclaration)(node)) {
          if ("var" !== node.kind) return;
          for (const declar of node.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) declars.push({
              kind: node.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
            declar.init && exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
          }
          ensureLastUndefined = !0;
        } else if ((0, _generated.isIfStatement)(node)) {
          const consequent = node.consequent ? gatherSequenceExpressions([ node.consequent ], scope, declars) : scope.buildUndefinedNode(), alternate = node.alternate ? gatherSequenceExpressions([ node.alternate ], scope, declars) : scope.buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _generated.isBlockStatement)(node)) {
          const body = gatherSequenceExpressions(node.body, scope, declars);
          if (!body) return;
          exprs.push(body);
        } else {
          if (!(0, _generated.isEmptyStatement)(node)) return;
          0 === nodes.indexOf(node) && (ensureLastUndefined = !0);
        }
        ensureLastUndefined && exprs.push(scope.buildUndefinedNode());
        return 1 === exprs.length ? exprs[0] : (0, _generated2.sequenceExpression)(exprs);
      };
      var _getBindingIdentifiers = __webpack_require__(1477), _generated = __webpack_require__(4746), _generated2 = __webpack_require__(4391), _cloneNode = __webpack_require__(6209);
    },
    8316: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(name) {
        "eval" !== (name = (0, _toIdentifier.default)(name)) && "arguments" !== name || (name = "_" + name);
        return name;
      };
      var _toIdentifier = __webpack_require__(1309);
    },
    9276: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, parent) {
        if ((0, _generated.isBlockStatement)(node)) return node;
        let blockNodes = [];
        (0, _generated.isEmptyStatement)(node) ? blockNodes = [] : ((0, _generated.isStatement)(node) || (node = (0, 
        _generated.isFunction)(parent) ? (0, _generated2.returnStatement)(node) : (0, _generated2.expressionStatement)(node)), 
        blockNodes = [ node ]);
        return (0, _generated2.blockStatement)(blockNodes);
      };
      var _generated = __webpack_require__(4746), _generated2 = __webpack_require__(4391);
    },
    9434: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, key = node.key || node.property) {
        !node.computed && (0, _generated.isIdentifier)(key) && (key = (0, _generated2.stringLiteral)(key.name));
        return key;
      };
      var _generated = __webpack_require__(4746), _generated2 = __webpack_require__(4391);
    },
    3348: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _generated = __webpack_require__(4746), _default = function(node) {
        (0, _generated.isExpressionStatement)(node) && (node = node.expression);
        if ((0, _generated.isExpression)(node)) return node;
        (0, _generated.isClass)(node) ? node.type = "ClassExpression" : (0, _generated.isFunction)(node) && (node.type = "FunctionExpression");
        if (!(0, _generated.isExpression)(node)) throw new Error(`cannot turn ${node.type} to an expression`);
        return node;
      };
      exports.default = _default;
    },
    1309: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(input) {
        input += "";
        let name = "";
        for (const c of input) name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
        name = name.replace(/^[-0-9]+/, ""), name = name.replace(/[-\s]+(.)?/g, (function(match, c) {
          return c ? c.toUpperCase() : "";
        })), (0, _isValidIdentifier.default)(name) || (name = `_${name}`);
        return name || "_";
      };
      var _isValidIdentifier = __webpack_require__(3045), _helperValidatorIdentifier = __webpack_require__(720);
    },
    510: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = toKeyAlias;
      var _generated = __webpack_require__(4746), _cloneNode = __webpack_require__(6209), _removePropertiesDeep = __webpack_require__(4936);
      function toKeyAlias(node, key = node.key) {
        let alias;
        return "method" === node.kind ? toKeyAlias.increment() + "" : (alias = (0, _generated.isIdentifier)(key) ? key.name : (0, 
        _generated.isStringLiteral)(key) ? JSON.stringify(key.value) : JSON.stringify((0, 
        _removePropertiesDeep.default)((0, _cloneNode.default)(key))), node.computed && (alias = `[${alias}]`), 
        node.static && (alias = `static:${alias}`), alias);
      }
      toKeyAlias.uid = 0, toKeyAlias.increment = function() {
        return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
      };
    },
    1435: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(nodes, scope) {
        if (null == nodes || !nodes.length) return;
        const declars = [], result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
        if (!result) return;
        for (const declar of declars) scope.push(declar);
        return result;
      };
      var _gatherSequenceExpressions = __webpack_require__(696);
    },
    2307: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _generated = __webpack_require__(4746), _generated2 = __webpack_require__(4391), _default = function(node, ignore) {
        if ((0, _generated.isStatement)(node)) return node;
        let newType, mustHaveId = !1;
        if ((0, _generated.isClass)(node)) mustHaveId = !0, newType = "ClassDeclaration"; else if ((0, 
        _generated.isFunction)(node)) mustHaveId = !0, newType = "FunctionDeclaration"; else if ((0, 
        _generated.isAssignmentExpression)(node)) return (0, _generated2.expressionStatement)(node);
        mustHaveId && !node.id && (newType = !1);
        if (!newType) {
          if (ignore) return !1;
          throw new Error(`cannot turn ${node.type} to a statement`);
        }
        return node.type = newType, node;
      };
      exports.default = _default;
    },
    6794: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _isValidIdentifier = __webpack_require__(3045), _generated = __webpack_require__(4391), _default = function valueToNode(value) {
        if (void 0 === value) return (0, _generated.identifier)("undefined");
        if (!0 === value || !1 === value) return (0, _generated.booleanLiteral)(value);
        if (null === value) return (0, _generated.nullLiteral)();
        if ("string" == typeof value) return (0, _generated.stringLiteral)(value);
        if ("number" == typeof value) {
          let result;
          if (Number.isFinite(value)) result = (0, _generated.numericLiteral)(Math.abs(value)); else {
            let numerator;
            numerator = Number.isNaN(value) ? (0, _generated.numericLiteral)(0) : (0, _generated.numericLiteral)(1), 
            result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
          }
          return (value < 0 || Object.is(value, -0)) && (result = (0, _generated.unaryExpression)("-", result)), 
          result;
        }
        if (function(value) {
          return "[object RegExp]" === objectToString(value);
        }(value)) {
          const pattern = value.source, flags = value.toString().match(/\/([a-z]+|)$/)[1];
          return (0, _generated.regExpLiteral)(pattern, flags);
        }
        if (Array.isArray(value)) return (0, _generated.arrayExpression)(value.map(valueToNode));
        if (function(value) {
          if ("object" != typeof value || null === value || "[object Object]" !== Object.prototype.toString.call(value)) return !1;
          const proto = Object.getPrototypeOf(value);
          return null === proto || null === Object.getPrototypeOf(proto);
        }(value)) {
          const props = [];
          for (const key of Object.keys(value)) {
            let nodeKey;
            nodeKey = (0, _isValidIdentifier.default)(key) ? (0, _generated.identifier)(key) : (0, 
            _generated.stringLiteral)(key), props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
          }
          return (0, _generated.objectExpression)(props);
        }
        throw new Error("don't know how to turn this value into a node");
      };
      exports.default = _default;
      const objectToString = Function.call.bind(Object.prototype.toString);
    },
    4457: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
      var _is = __webpack_require__(7275), _isValidIdentifier = __webpack_require__(3045), _helperValidatorIdentifier = __webpack_require__(720), _constants = __webpack_require__(6325), _utils = __webpack_require__(4913);
      const defineType = (0, _utils.defineAliasedType)("Standardized");
      defineType("ArrayExpression", {
        fields: {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
            default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
          }
        },
        visitor: [ "elements" ],
        aliases: [ "Expression" ]
      }), defineType("AssignmentExpression", {
        fields: {
          operator: {
            validate: function() {
              if (!process.env.BABEL_TYPES_8_BREAKING) return (0, _utils.assertValueType)("string");
              const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS), pattern = (0, 
              _utils.assertOneOf)("=");
              return function(node, key, val) {
                ((0, _is.default)("Pattern", node.left) ? pattern : identifier)(node, key, val);
              };
            }()
          },
          left: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0, 
            _utils.assertNodeType)("LVal")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        builder: [ "operator", "left", "right" ],
        visitor: [ "left", "right" ],
        aliases: [ "Expression" ]
      }), defineType("BinaryExpression", {
        builder: [ "operator", "left", "right" ],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
          },
          left: {
            validate: function() {
              const expression = (0, _utils.assertNodeType)("Expression"), inOp = (0, _utils.assertNodeType)("Expression", "PrivateName"), validator = function(node, key, val) {
                ("in" === node.operator ? inOp : expression)(node, key, val);
              };
              return validator.oneOfNodeTypes = [ "Expression", "PrivateName" ], validator;
            }()
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        visitor: [ "left", "right" ],
        aliases: [ "Binary", "Expression" ]
      }), defineType("InterpreterDirective", {
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      }), defineType("Directive", {
        visitor: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertNodeType)("DirectiveLiteral")
          }
        }
      }), defineType("DirectiveLiteral", {
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      }), defineType("BlockStatement", {
        builder: [ "body", "directives" ],
        visitor: [ "directives", "body" ],
        fields: {
          directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Directive"))),
            default: []
          },
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Statement")))
          }
        },
        aliases: [ "Scopable", "BlockParent", "Block", "Statement" ]
      }), defineType("BreakStatement", {
        visitor: [ "label" ],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: !0
          }
        },
        aliases: [ "Statement", "Terminatorless", "CompletionStatement" ]
      }), defineType("CallExpression", {
        visitor: [ "callee", "arguments", "typeParameters", "typeArguments" ],
        builder: [ "callee", "arguments" ],
        aliases: [ "Expression" ],
        fields: Object.assign({
          callee: {
            validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
          },
          arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
          }
        }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
          optional: {
            validate: (0, _utils.assertOneOf)(!0, !1),
            optional: !0
          }
        }, {
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: !0
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: !0
          }
        })
      }), defineType("CatchClause", {
        visitor: [ "param", "body" ],
        fields: {
          param: {
            validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
            optional: !0
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        },
        aliases: [ "Scopable", "BlockParent" ]
      }), defineType("ConditionalExpression", {
        visitor: [ "test", "consequent", "alternate" ],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          consequent: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          alternate: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: [ "Expression", "Conditional" ]
      }), defineType("ContinueStatement", {
        visitor: [ "label" ],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: !0
          }
        },
        aliases: [ "Statement", "Terminatorless", "CompletionStatement" ]
      }), defineType("DebuggerStatement", {
        aliases: [ "Statement" ]
      }), defineType("DoWhileStatement", {
        visitor: [ "test", "body" ],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        },
        aliases: [ "Statement", "BlockParent", "Loop", "While", "Scopable" ]
      }), defineType("EmptyStatement", {
        aliases: [ "Statement" ]
      }), defineType("ExpressionStatement", {
        visitor: [ "expression" ],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: [ "Statement", "ExpressionWrapper" ]
      }), defineType("File", {
        builder: [ "program", "comments", "tokens" ],
        visitor: [ "program" ],
        fields: {
          program: {
            validate: (0, _utils.assertNodeType)("Program")
          },
          comments: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign((() => {}), {
              each: {
                oneOfNodeTypes: [ "CommentBlock", "CommentLine" ]
              }
            }),
            optional: !0
          },
          tokens: {
            validate: (0, _utils.assertEach)(Object.assign((() => {}), {
              type: "any"
            })),
            optional: !0
          }
        }
      }), defineType("ForInStatement", {
        visitor: [ "left", "right", "body" ],
        aliases: [ "Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement" ],
        fields: {
          left: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0, 
            _utils.assertNodeType)("VariableDeclaration", "LVal")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      }), defineType("ForStatement", {
        visitor: [ "init", "test", "update", "body" ],
        aliases: [ "Scopable", "Statement", "For", "BlockParent", "Loop" ],
        fields: {
          init: {
            validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
            optional: !0
          },
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          },
          update: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      });
      const functionCommon = {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
          _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
        },
        generator: {
          default: !1
        },
        async: {
          default: !1
        }
      };
      exports.functionCommon = functionCommon;
      const functionTypeAnnotationCommon = {
        returnType: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: !0
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: !0
        }
      };
      exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
      const functionDeclarationCommon = Object.assign({}, functionCommon, {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: !0
        }
      });
      exports.functionDeclarationCommon = functionDeclarationCommon, defineType("FunctionDeclaration", {
        builder: [ "id", "params", "body", "generator", "async" ],
        visitor: [ "id", "params", "body", "returnType", "typeParameters" ],
        fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }),
        aliases: [ "Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration" ],
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            (0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id);
          };
        }()
      }), defineType("FunctionExpression", {
        inherits: "FunctionDeclaration",
        aliases: [ "Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish" ],
        fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: !0
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      });
      const patternLikeCommon = {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
          _utils.assertNodeType)("Decorator")))
        }
      };
      exports.patternLikeCommon = patternLikeCommon, defineType("Identifier", {
        builder: [ "name" ],
        visitor: [ "typeAnnotation", "decorators" ],
        aliases: [ "Expression", "PatternLike", "LVal", "TSEntityName" ],
        fields: Object.assign({}, patternLikeCommon, {
          name: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign((function(node, key, val) {
              if (process.env.BABEL_TYPES_8_BREAKING && !(0, _isValidIdentifier.default)(val, !1)) throw new TypeError(`"${val}" is not a valid identifier name`);
            }), {
              type: "string"
            }))
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          }
        }),
        validate(parent, key, node) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          const match = /\.(\w+)$/.exec(key);
          if (!match) return;
          const [, parentKey] = match, nonComp = {
            computed: !1
          };
          if ("property" === parentKey) {
            if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
            if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
          } else if ("key" === parentKey) {
            if ((0, _is.default)("Property", parent, nonComp)) return;
            if ((0, _is.default)("Method", parent, nonComp)) return;
          } else if ("exported" === parentKey) {
            if ((0, _is.default)("ExportSpecifier", parent)) return;
          } else if ("imported" === parentKey) {
            if ((0, _is.default)("ImportSpecifier", parent, {
              imported: node
            })) return;
          } else if ("meta" === parentKey && (0, _is.default)("MetaProperty", parent, {
            meta: node
          })) return;
          if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, !1)) && "this" !== node.name) throw new TypeError(`"${node.name}" is not a valid identifier`);
        }
      }), defineType("IfStatement", {
        visitor: [ "test", "consequent", "alternate" ],
        aliases: [ "Statement", "Conditional" ],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          consequent: {
            validate: (0, _utils.assertNodeType)("Statement")
          },
          alternate: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      }), defineType("LabeledStatement", {
        visitor: [ "label", "body" ],
        aliases: [ "Statement" ],
        fields: {
          label: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      }), defineType("StringLiteral", {
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
      }), defineType("NumericLiteral", {
        builder: [ "value" ],
        deprecatedAlias: "NumberLiteral",
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("number")
          }
        },
        aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
      }), defineType("NullLiteral", {
        aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
      }), defineType("BooleanLiteral", {
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("boolean")
          }
        },
        aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
      }), defineType("RegExpLiteral", {
        builder: [ "pattern", "flags" ],
        deprecatedAlias: "RegexLiteral",
        aliases: [ "Expression", "Pureish", "Literal" ],
        fields: {
          pattern: {
            validate: (0, _utils.assertValueType)("string")
          },
          flags: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign((function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              const invalid = /[^gimsuy]/.exec(val);
              if (invalid) throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }), {
              type: "string"
            })),
            default: ""
          }
        }
      }), defineType("LogicalExpression", {
        builder: [ "operator", "left", "right" ],
        visitor: [ "left", "right" ],
        aliases: [ "Binary", "Expression" ],
        fields: {
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
          },
          left: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("MemberExpression", {
        builder: [ "object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : [ "optional" ] ],
        visitor: [ "object", "property" ],
        aliases: [ "Expression", "LVal" ],
        fields: Object.assign({
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          property: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName"), computed = (0, 
              _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
                (node.computed ? computed : normal)(node, key, val);
              };
              return validator.oneOfNodeTypes = [ "Expression", "Identifier", "PrivateName" ], 
              validator;
            }()
          },
          computed: {
            default: !1
          }
        }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
          optional: {
            validate: (0, _utils.assertOneOf)(!0, !1),
            optional: !0
          }
        })
      }), defineType("NewExpression", {
        inherits: "CallExpression"
      }), defineType("Program", {
        visitor: [ "directives", "body" ],
        builder: [ "body", "directives", "sourceType", "interpreter" ],
        fields: {
          sourceFile: {
            validate: (0, _utils.assertValueType)("string")
          },
          sourceType: {
            validate: (0, _utils.assertOneOf)("script", "module"),
            default: "script"
          },
          interpreter: {
            validate: (0, _utils.assertNodeType)("InterpreterDirective"),
            default: null,
            optional: !0
          },
          directives: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Directive"))),
            default: []
          },
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Statement")))
          }
        },
        aliases: [ "Scopable", "BlockParent", "Block" ]
      }), defineType("ObjectExpression", {
        visitor: [ "properties" ],
        aliases: [ "Expression" ],
        fields: {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
          }
        }
      }), defineType("ObjectMethod", {
        builder: [ "kind", "key", "params", "body", "computed", "generator", "async" ],
        fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
          kind: Object.assign({
            validate: (0, _utils.assertOneOf)("method", "get", "set")
          }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
            default: "method"
          }),
          computed: {
            default: !1
          },
          key: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, 
              _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
                (node.computed ? computed : normal)(node, key, val);
              };
              return validator.oneOfNodeTypes = [ "Expression", "Identifier", "StringLiteral", "NumericLiteral" ], 
              validator;
            }()
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }),
        visitor: [ "key", "params", "body", "decorators", "returnType", "typeParameters" ],
        aliases: [ "UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember" ]
      }), defineType("ObjectProperty", {
        builder: [ "key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : [ "decorators" ] ],
        fields: {
          computed: {
            default: !1
          },
          key: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, 
              _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
                (node.computed ? computed : normal)(node, key, val);
              };
              return validator.oneOfNodeTypes = [ "Expression", "Identifier", "StringLiteral", "NumericLiteral" ], 
              validator;
            }()
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
          },
          shorthand: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign((function(node, key, val) {
              if (process.env.BABEL_TYPES_8_BREAKING && val && node.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }), {
              type: "boolean"
            }), (function(node, key, val) {
              if (process.env.BABEL_TYPES_8_BREAKING && val && !(0, _is.default)("Identifier", node.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            })),
            default: !1
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          }
        },
        visitor: [ "key", "value", "decorators" ],
        aliases: [ "UserWhitespacable", "Property", "ObjectMember" ],
        validate: function() {
          const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern"), expression = (0, 
          _utils.assertNodeType)("Expression");
          return function(parent, key, node) {
            if (!process.env.BABEL_TYPES_8_BREAKING) return;
            ((0, _is.default)("ObjectPattern", parent) ? pattern : expression)(node, "value", node.value);
          };
        }()
      }), defineType("RestElement", {
        visitor: [ "argument", "typeAnnotation" ],
        builder: [ "argument" ],
        aliases: [ "LVal", "PatternLike" ],
        deprecatedAlias: "RestProperty",
        fields: Object.assign({}, patternLikeCommon, {
          argument: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression") : (0, 
            _utils.assertNodeType)("LVal")
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          }
        }),
        validate(parent, key) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          const match = /(\w+)\[(\d+)\]/.exec(key);
          if (!match) throw new Error("Internal Babel error: malformed key.");
          const [, listKey, index] = match;
          if (parent[listKey].length > index + 1) throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      }), defineType("ReturnStatement", {
        visitor: [ "argument" ],
        aliases: [ "Statement", "Terminatorless", "CompletionStatement" ],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          }
        }
      }), defineType("SequenceExpression", {
        visitor: [ "expressions" ],
        fields: {
          expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Expression")))
          }
        },
        aliases: [ "Expression" ]
      }), defineType("ParenthesizedExpression", {
        visitor: [ "expression" ],
        aliases: [ "Expression", "ExpressionWrapper" ],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("SwitchCase", {
        visitor: [ "test", "consequent" ],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          },
          consequent: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Statement")))
          }
        }
      }), defineType("SwitchStatement", {
        visitor: [ "discriminant", "cases" ],
        aliases: [ "Statement", "BlockParent", "Scopable" ],
        fields: {
          discriminant: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          cases: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("SwitchCase")))
          }
        }
      }), defineType("ThisExpression", {
        aliases: [ "Expression" ]
      }), defineType("ThrowStatement", {
        visitor: [ "argument" ],
        aliases: [ "Statement", "Terminatorless", "CompletionStatement" ],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("TryStatement", {
        visitor: [ "block", "handler", "finalizer" ],
        aliases: [ "Statement" ],
        fields: {
          block: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign((function(node) {
              if (process.env.BABEL_TYPES_8_BREAKING && !node.handler && !node.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }), {
              oneOfNodeTypes: [ "BlockStatement" ]
            }))
          },
          handler: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("CatchClause")
          },
          finalizer: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        }
      }), defineType("UnaryExpression", {
        builder: [ "operator", "argument", "prefix" ],
        fields: {
          prefix: {
            default: !0
          },
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
          }
        },
        visitor: [ "argument" ],
        aliases: [ "UnaryLike", "Expression" ]
      }), defineType("UpdateExpression", {
        builder: [ "operator", "argument", "prefix" ],
        fields: {
          prefix: {
            default: !1
          },
          argument: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression") : (0, 
            _utils.assertNodeType)("Expression")
          },
          operator: {
            validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
          }
        },
        visitor: [ "argument" ],
        aliases: [ "Expression" ]
      }), defineType("VariableDeclaration", {
        builder: [ "kind", "declarations" ],
        visitor: [ "declarations" ],
        aliases: [ "Statement", "Declaration" ],
        fields: {
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          kind: {
            validate: (0, _utils.assertOneOf)("var", "let", "const")
          },
          declarations: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("VariableDeclarator")))
          }
        },
        validate(parent, key, node) {
          if (process.env.BABEL_TYPES_8_BREAKING && (0, _is.default)("ForXStatement", parent, {
            left: node
          }) && 1 !== node.declarations.length) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
        }
      }), defineType("VariableDeclarator", {
        visitor: [ "id", "init" ],
        fields: {
          id: {
            validate: function() {
              if (!process.env.BABEL_TYPES_8_BREAKING) return (0, _utils.assertNodeType)("LVal");
              const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), without = (0, 
              _utils.assertNodeType)("Identifier");
              return function(node, key, val) {
                (node.init ? normal : without)(node, key, val);
              };
            }()
          },
          definite: {
            optional: !0,
            validate: (0, _utils.assertValueType)("boolean")
          },
          init: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("WhileStatement", {
        visitor: [ "test", "body" ],
        aliases: [ "Statement", "BlockParent", "Loop", "While", "Scopable" ],
        fields: {
          test: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      }), defineType("WithStatement", {
        visitor: [ "object", "body" ],
        aliases: [ "Statement" ],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          }
        }
      }), defineType("AssignmentPattern", {
        visitor: [ "left", "right", "decorators" ],
        builder: [ "left", "right" ],
        aliases: [ "Pattern", "PatternLike", "LVal" ],
        fields: Object.assign({}, patternLikeCommon, {
          left: {
            validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          }
        })
      }), defineType("ArrayPattern", {
        visitor: [ "elements", "typeAnnotation" ],
        builder: [ "elements" ],
        aliases: [ "Pattern", "PatternLike", "LVal" ],
        fields: Object.assign({}, patternLikeCommon, {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeOrValueType)("null", "PatternLike")))
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          optional: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          }
        })
      }), defineType("ArrowFunctionExpression", {
        builder: [ "params", "body", "async" ],
        visitor: [ "params", "body", "returnType", "typeParameters" ],
        aliases: [ "Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish" ],
        fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
          expression: {
            validate: (0, _utils.assertValueType)("boolean")
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
          }
        })
      }), defineType("ClassBody", {
        visitor: [ "body" ],
        fields: {
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
          }
        }
      }), defineType("ClassExpression", {
        builder: [ "id", "superClass", "body", "decorators" ],
        visitor: [ "id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators" ],
        aliases: [ "Scopable", "Class", "Expression" ],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier"),
            optional: !0
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: !0
          },
          body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
          },
          superClass: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: !0
          },
          implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: !0
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: !0
          }
        }
      }), defineType("ClassDeclaration", {
        inherits: "ClassExpression",
        aliases: [ "Scopable", "Class", "Statement", "Declaration" ],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
            optional: !0
          },
          body: {
            validate: (0, _utils.assertNodeType)("ClassBody")
          },
          superClass: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("Expression")
          },
          superTypeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: !0
          },
          implements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
            optional: !0
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          mixins: {
            validate: (0, _utils.assertNodeType)("InterfaceExtends"),
            optional: !0
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          abstract: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          }
        },
        validate: function() {
          const identifier = (0, _utils.assertNodeType)("Identifier");
          return function(parent, key, node) {
            process.env.BABEL_TYPES_8_BREAKING && ((0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id));
          };
        }()
      }), defineType("ExportAllDeclaration", {
        visitor: [ "source" ],
        aliases: [ "Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration" ],
        fields: {
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
          assertions: {
            optional: !0,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ImportAttribute")))
          }
        }
      }), defineType("ExportDefaultDeclaration", {
        visitor: [ "declaration" ],
        aliases: [ "Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration" ],
        fields: {
          declaration: {
            validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
        }
      }), defineType("ExportNamedDeclaration", {
        visitor: [ "declaration", "specifiers", "source" ],
        aliases: [ "Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration" ],
        fields: {
          declaration: {
            optional: !0,
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign((function(node, key, val) {
              if (process.env.BABEL_TYPES_8_BREAKING && val && node.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }), {
              oneOfNodeTypes: [ "Declaration" ]
            }), (function(node, key, val) {
              if (process.env.BABEL_TYPES_8_BREAKING && val && node.source) throw new TypeError("Cannot export a declaration from a source");
            }))
          },
          assertions: {
            optional: !0,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ImportAttribute")))
          },
          specifiers: {
            default: [],
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
              const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), sourceless = (0, 
              _utils.assertNodeType)("ExportSpecifier");
              return process.env.BABEL_TYPES_8_BREAKING ? function(node, key, val) {
                (node.source ? sourced : sourceless)(node, key, val);
              } : sourced;
            }()))
          },
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral"),
            optional: !0
          },
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
        }
      }), defineType("ExportSpecifier", {
        visitor: [ "local", "exported" ],
        aliases: [ "ModuleSpecifier" ],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          exportKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: !0
          }
        }
      }), defineType("ForOfStatement", {
        visitor: [ "left", "right", "body" ],
        builder: [ "left", "right", "body", "await" ],
        aliases: [ "Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement" ],
        fields: {
          left: {
            validate: function() {
              if (!process.env.BABEL_TYPES_8_BREAKING) return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
              const declaration = (0, _utils.assertNodeType)("VariableDeclaration"), lval = (0, 
              _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
              return function(node, key, val) {
                (0, _is.default)("VariableDeclaration", val) ? declaration(node, key, val) : lval(node, key, val);
              };
            }()
          },
          right: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          body: {
            validate: (0, _utils.assertNodeType)("Statement")
          },
          await: {
            default: !1
          }
        }
      }), defineType("ImportDeclaration", {
        visitor: [ "specifiers", "source" ],
        aliases: [ "Statement", "Declaration", "ModuleDeclaration" ],
        fields: {
          assertions: {
            optional: !0,
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ImportAttribute")))
          },
          specifiers: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
          },
          source: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: !0
          }
        }
      }), defineType("ImportDefaultSpecifier", {
        visitor: [ "local" ],
        aliases: [ "ModuleSpecifier" ],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      }), defineType("ImportNamespaceSpecifier", {
        visitor: [ "local" ],
        aliases: [ "ModuleSpecifier" ],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      }), defineType("ImportSpecifier", {
        visitor: [ "local", "imported" ],
        aliases: [ "ModuleSpecifier" ],
        fields: {
          local: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          imported: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
            optional: !0
          }
        }
      }), defineType("MetaProperty", {
        visitor: [ "meta", "property" ],
        aliases: [ "Expression" ],
        fields: {
          meta: {
            validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign((function(node, key, val) {
              if (!process.env.BABEL_TYPES_8_BREAKING) return;
              let property;
              switch (val.name) {
               case "function":
                property = "sent";
                break;

               case "new":
                property = "target";
                break;

               case "import":
                property = "meta";
              }
              if (!(0, _is.default)("Identifier", node.property, {
                name: property
              })) throw new TypeError("Unrecognised MetaProperty");
            }), {
              oneOfNodeTypes: [ "Identifier" ]
            }))
          },
          property: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      });
      const classMethodOrPropertyCommon = {
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: !0
        },
        static: {
          default: !1
        },
        override: {
          default: !1
        },
        computed: {
          default: !1
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: !0
        },
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, 
            _utils.assertNodeType)("Expression");
            return function(node, key, val) {
              (node.computed ? computed : normal)(node, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
        }
      };
      exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
      const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
        params: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
          _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
        },
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
          default: "method"
        },
        access: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
          optional: !0
        },
        decorators: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
          _utils.assertNodeType)("Decorator"))),
          optional: !0
        }
      });
      exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon, defineType("ClassMethod", {
        aliases: [ "Function", "Scopable", "BlockParent", "FunctionParent", "Method" ],
        builder: [ "kind", "key", "params", "body", "computed", "static", "generator", "async" ],
        visitor: [ "key", "params", "body", "decorators", "returnType", "typeParameters" ],
        fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      }), defineType("ObjectPattern", {
        visitor: [ "properties", "typeAnnotation", "decorators" ],
        builder: [ "properties" ],
        aliases: [ "Pattern", "PatternLike", "LVal" ],
        fields: Object.assign({}, patternLikeCommon, {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("RestElement", "ObjectProperty")))
          }
        })
      }), defineType("SpreadElement", {
        visitor: [ "argument" ],
        aliases: [ "UnaryLike" ],
        deprecatedAlias: "SpreadProperty",
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("Super", {
        aliases: [ "Expression" ]
      }), defineType("TaggedTemplateExpression", {
        visitor: [ "tag", "quasi", "typeParameters" ],
        builder: [ "tag", "quasi" ],
        aliases: [ "Expression" ],
        fields: {
          tag: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          quasi: {
            validate: (0, _utils.assertNodeType)("TemplateLiteral")
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: !0
          }
        }
      }), defineType("TemplateElement", {
        builder: [ "value", "tail" ],
        fields: {
          value: {
            validate: (0, _utils.assertShape)({
              raw: {
                validate: (0, _utils.assertValueType)("string")
              },
              cooked: {
                validate: (0, _utils.assertValueType)("string"),
                optional: !0
              }
            })
          },
          tail: {
            default: !1
          }
        }
      }), defineType("TemplateLiteral", {
        visitor: [ "quasis", "expressions" ],
        aliases: [ "Expression", "Literal" ],
        fields: {
          quasis: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("TemplateElement")))
          },
          expressions: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Expression", "TSType")), (function(node, key, val) {
              if (node.quasis.length !== val.length + 1) throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
            }))
          }
        }
      }), defineType("YieldExpression", {
        builder: [ "argument", "delegate" ],
        visitor: [ "argument" ],
        aliases: [ "Expression", "Terminatorless" ],
        fields: {
          delegate: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign((function(node, key, val) {
              if (process.env.BABEL_TYPES_8_BREAKING && val && !node.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }), {
              type: "boolean"
            })),
            default: !1
          },
          argument: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("AwaitExpression", {
        builder: [ "argument" ],
        visitor: [ "argument" ],
        aliases: [ "Expression", "Terminatorless" ],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("Import", {
        aliases: [ "Expression" ]
      }), defineType("BigIntLiteral", {
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
      }), defineType("ExportNamespaceSpecifier", {
        visitor: [ "exported" ],
        aliases: [ "ModuleSpecifier" ],
        fields: {
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      }), defineType("OptionalMemberExpression", {
        builder: [ "object", "property", "computed", "optional" ],
        visitor: [ "object", "property" ],
        aliases: [ "Expression" ],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          property: {
            validate: function() {
              const normal = (0, _utils.assertNodeType)("Identifier"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
                (node.computed ? computed : normal)(node, key, val);
              };
              return validator.oneOfNodeTypes = [ "Expression", "Identifier" ], validator;
            }()
          },
          computed: {
            default: !1
          },
          optional: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, 
            _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean")
          }
        }
      }), defineType("OptionalCallExpression", {
        visitor: [ "callee", "arguments", "typeParameters", "typeArguments" ],
        builder: [ "callee", "arguments", "optional" ],
        aliases: [ "Expression" ],
        fields: {
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          arguments: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
          },
          optional: {
            validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, 
            _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean")
          },
          typeArguments: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
            optional: !0
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
            optional: !0
          }
        }
      }), defineType("ClassProperty", {
        visitor: [ "key", "value", "typeAnnotation", "decorators" ],
        builder: [ "key", "value", "typeAnnotation", "decorators", "computed", "static" ],
        aliases: [ "Property" ],
        fields: Object.assign({}, classMethodOrPropertyCommon, {
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: !0
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: !0
          }
        })
      }), defineType("ClassAccessorProperty", {
        visitor: [ "key", "value", "typeAnnotation", "decorators" ],
        builder: [ "key", "value", "typeAnnotation", "decorators", "computed", "static" ],
        aliases: [ "Property", "Accessor" ],
        fields: Object.assign({}, classMethodOrPropertyCommon, {
          key: {
            validate: (0, _utils.chain)(function() {
              const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "PrivateName"), computed = (0, 
              _utils.assertNodeType)("Expression");
              return function(node, key, val) {
                (node.computed ? computed : normal)(node, key, val);
              };
            }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression", "PrivateName"))
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: !0
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          declare: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: !0
          }
        })
      }), defineType("ClassPrivateProperty", {
        visitor: [ "key", "value", "decorators", "typeAnnotation" ],
        builder: [ "key", "value", "decorators", "static" ],
        aliases: [ "Property", "Private" ],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
          },
          value: {
            validate: (0, _utils.assertNodeType)("Expression"),
            optional: !0
          },
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
            optional: !0
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          definite: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          variance: {
            validate: (0, _utils.assertNodeType)("Variance"),
            optional: !0
          }
        }
      }), defineType("ClassPrivateMethod", {
        builder: [ "kind", "key", "params", "body", "static" ],
        visitor: [ "key", "params", "body", "decorators", "returnType", "typeParameters" ],
        aliases: [ "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private" ],
        fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
          key: {
            validate: (0, _utils.assertNodeType)("PrivateName")
          },
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          }
        })
      }), defineType("PrivateName", {
        visitor: [ "id" ],
        aliases: [ "Private" ],
        fields: {
          id: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      }), defineType("StaticBlock", {
        visitor: [ "body" ],
        fields: {
          body: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Statement")))
          }
        },
        aliases: [ "Scopable", "BlockParent", "FunctionParent" ]
      });
    },
    1456: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _utils = __webpack_require__(4913);
      (0, _utils.default)("ArgumentPlaceholder", {}), (0, _utils.default)("BindExpression", {
        visitor: [ "object", "callee" ],
        aliases: [ "Expression" ],
        fields: process.env.BABEL_TYPES_8_BREAKING ? {
          object: {
            validate: (0, _utils.assertNodeType)("Expression")
          },
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        } : {
          object: {
            validate: Object.assign((() => {}), {
              oneOfNodeTypes: [ "Expression" ]
            })
          },
          callee: {
            validate: Object.assign((() => {}), {
              oneOfNodeTypes: [ "Expression" ]
            })
          }
        }
      }), (0, _utils.default)("ImportAttribute", {
        visitor: [ "key", "value" ],
        fields: {
          key: {
            validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
          },
          value: {
            validate: (0, _utils.assertNodeType)("StringLiteral")
          }
        }
      }), (0, _utils.default)("Decorator", {
        visitor: [ "expression" ],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), (0, _utils.default)("DoExpression", {
        visitor: [ "body" ],
        builder: [ "body", "async" ],
        aliases: [ "Expression" ],
        fields: {
          body: {
            validate: (0, _utils.assertNodeType)("BlockStatement")
          },
          async: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: !1
          }
        }
      }), (0, _utils.default)("ExportDefaultSpecifier", {
        visitor: [ "exported" ],
        aliases: [ "ModuleSpecifier" ],
        fields: {
          exported: {
            validate: (0, _utils.assertNodeType)("Identifier")
          }
        }
      }), (0, _utils.default)("RecordExpression", {
        visitor: [ "properties" ],
        aliases: [ "Expression" ],
        fields: {
          properties: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
          }
        }
      }), (0, _utils.default)("TupleExpression", {
        fields: {
          elements: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Expression", "SpreadElement"))),
            default: []
          }
        },
        visitor: [ "elements" ],
        aliases: [ "Expression" ]
      }), (0, _utils.default)("DecimalLiteral", {
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
      }), (0, _utils.default)("ModuleExpression", {
        visitor: [ "body" ],
        fields: {
          body: {
            validate: (0, _utils.assertNodeType)("Program")
          }
        },
        aliases: [ "Expression" ]
      }), (0, _utils.default)("TopicReference", {
        aliases: [ "Expression" ]
      }), (0, _utils.default)("PipelineTopicExpression", {
        builder: [ "expression" ],
        visitor: [ "expression" ],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: [ "Expression" ]
      }), (0, _utils.default)("PipelineBareFunction", {
        builder: [ "callee" ],
        visitor: [ "callee" ],
        fields: {
          callee: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        },
        aliases: [ "Expression" ]
      }), (0, _utils.default)("PipelinePrimaryTopicReference", {
        aliases: [ "Expression" ]
      });
    },
    5391: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _utils = __webpack_require__(4913);
      const defineType = (0, _utils.defineAliasedType)("Flow"), defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
        defineType(name, {
          builder: [ "id", "typeParameters", "extends", "body" ],
          visitor: [ "id", "typeParameters", "extends", "mixins", "implements", "body" ],
          aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
          fields: {
            id: (0, _utils.validateType)("Identifier"),
            typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
            extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
            implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
            body: (0, _utils.validateType)("ObjectTypeAnnotation")
          }
        });
      };
      defineType("AnyTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("ArrayTypeAnnotation", {
        visitor: [ "elementType" ],
        aliases: [ "FlowType" ],
        fields: {
          elementType: (0, _utils.validateType)("FlowType")
        }
      }), defineType("BooleanTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("BooleanLiteralTypeAnnotation", {
        builder: [ "value" ],
        aliases: [ "FlowType" ],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("NullLiteralTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("ClassImplements", {
        visitor: [ "id", "typeParameters" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      }), defineInterfaceishType("DeclareClass"), defineType("DeclareFunction", {
        visitor: [ "id" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
        }
      }), defineInterfaceishType("DeclareInterface"), defineType("DeclareModule", {
        builder: [ "id", "body", "kind" ],
        visitor: [ "id", "body" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
          body: (0, _utils.validateType)("BlockStatement"),
          kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
        }
      }), defineType("DeclareModuleExports", {
        visitor: [ "typeAnnotation" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      }), defineType("DeclareTypeAlias", {
        visitor: [ "id", "typeParameters", "right" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          right: (0, _utils.validateType)("FlowType")
        }
      }), defineType("DeclareOpaqueType", {
        visitor: [ "id", "typeParameters", "supertype" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateOptionalType)("FlowType")
        }
      }), defineType("DeclareVariable", {
        visitor: [ "id" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      }), defineType("DeclareExportDeclaration", {
        visitor: [ "declaration", "specifiers", "source" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          declaration: (0, _utils.validateOptionalType)("Flow"),
          specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([ "ExportSpecifier", "ExportNamespaceSpecifier" ])),
          source: (0, _utils.validateOptionalType)("StringLiteral"),
          default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("DeclareExportAllDeclaration", {
        visitor: [ "source" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          source: (0, _utils.validateType)("StringLiteral"),
          exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
        }
      }), defineType("DeclaredPredicate", {
        visitor: [ "value" ],
        aliases: [ "FlowPredicate" ],
        fields: {
          value: (0, _utils.validateType)("Flow")
        }
      }), defineType("ExistsTypeAnnotation", {
        aliases: [ "FlowType" ]
      }), defineType("FunctionTypeAnnotation", {
        visitor: [ "typeParameters", "params", "rest", "returnType" ],
        aliases: [ "FlowType" ],
        fields: {
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
          rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
          returnType: (0, _utils.validateType)("FlowType")
        }
      }), defineType("FunctionTypeParam", {
        visitor: [ "name", "typeAnnotation" ],
        fields: {
          name: (0, _utils.validateOptionalType)("Identifier"),
          typeAnnotation: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("GenericTypeAnnotation", {
        visitor: [ "id", "typeParameters" ],
        aliases: [ "FlowType" ],
        fields: {
          id: (0, _utils.validateType)([ "Identifier", "QualifiedTypeIdentifier" ]),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      }), defineType("InferredPredicate", {
        aliases: [ "FlowPredicate" ]
      }), defineType("InterfaceExtends", {
        visitor: [ "id", "typeParameters" ],
        fields: {
          id: (0, _utils.validateType)([ "Identifier", "QualifiedTypeIdentifier" ]),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
        }
      }), defineInterfaceishType("InterfaceDeclaration"), defineType("InterfaceTypeAnnotation", {
        visitor: [ "extends", "body" ],
        aliases: [ "FlowType" ],
        fields: {
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        }
      }), defineType("IntersectionTypeAnnotation", {
        visitor: [ "types" ],
        aliases: [ "FlowType" ],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      }), defineType("MixedTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("EmptyTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("NullableTypeAnnotation", {
        visitor: [ "typeAnnotation" ],
        aliases: [ "FlowType" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("FlowType")
        }
      }), defineType("NumberLiteralTypeAnnotation", {
        builder: [ "value" ],
        aliases: [ "FlowType" ],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
        }
      }), defineType("NumberTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("ObjectTypeAnnotation", {
        visitor: [ "properties", "indexers", "callProperties", "internalSlots" ],
        aliases: [ "FlowType" ],
        builder: [ "properties", "indexers", "callProperties", "internalSlots", "exact" ],
        fields: {
          properties: (0, _utils.validate)((0, _utils.arrayOfType)([ "ObjectTypeProperty", "ObjectTypeSpreadProperty" ])),
          indexers: {
            validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
            optional: !0,
            default: void 0
          },
          callProperties: {
            validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
            optional: !0,
            default: void 0
          },
          internalSlots: {
            validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
            optional: !0,
            default: void 0
          },
          exact: {
            validate: (0, _utils.assertValueType)("boolean"),
            default: !1
          },
          inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("ObjectTypeInternalSlot", {
        visitor: [ "id", "value", "optional", "static", "method" ],
        aliases: [ "UserWhitespacable" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          value: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("ObjectTypeCallProperty", {
        visitor: [ "value" ],
        aliases: [ "UserWhitespacable" ],
        fields: {
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("ObjectTypeIndexer", {
        visitor: [ "id", "key", "value", "variance" ],
        aliases: [ "UserWhitespacable" ],
        fields: {
          id: (0, _utils.validateOptionalType)("Identifier"),
          key: (0, _utils.validateType)("FlowType"),
          value: (0, _utils.validateType)("FlowType"),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      }), defineType("ObjectTypeProperty", {
        visitor: [ "key", "value", "variance" ],
        aliases: [ "UserWhitespacable" ],
        fields: {
          key: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
          value: (0, _utils.validateType)("FlowType"),
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
          static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          variance: (0, _utils.validateOptionalType)("Variance"),
          method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("ObjectTypeSpreadProperty", {
        visitor: [ "argument" ],
        aliases: [ "UserWhitespacable" ],
        fields: {
          argument: (0, _utils.validateType)("FlowType")
        }
      }), defineType("OpaqueType", {
        visitor: [ "id", "typeParameters", "supertype", "impltype" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          supertype: (0, _utils.validateOptionalType)("FlowType"),
          impltype: (0, _utils.validateType)("FlowType")
        }
      }), defineType("QualifiedTypeIdentifier", {
        visitor: [ "id", "qualification" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          qualification: (0, _utils.validateType)([ "Identifier", "QualifiedTypeIdentifier" ])
        }
      }), defineType("StringLiteralTypeAnnotation", {
        builder: [ "value" ],
        aliases: [ "FlowType" ],
        fields: {
          value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
        }
      }), defineType("StringTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("SymbolTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("ThisTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("TupleTypeAnnotation", {
        visitor: [ "types" ],
        aliases: [ "FlowType" ],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      }), defineType("TypeofTypeAnnotation", {
        visitor: [ "argument" ],
        aliases: [ "FlowType" ],
        fields: {
          argument: (0, _utils.validateType)("FlowType")
        }
      }), defineType("TypeAlias", {
        visitor: [ "id", "typeParameters", "right" ],
        aliases: [ "FlowDeclaration", "Statement", "Declaration" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          right: (0, _utils.validateType)("FlowType")
        }
      }), defineType("TypeAnnotation", {
        visitor: [ "typeAnnotation" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("FlowType")
        }
      }), defineType("TypeCastExpression", {
        visitor: [ "expression", "typeAnnotation" ],
        aliases: [ "ExpressionWrapper", "Expression" ],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
        }
      }), defineType("TypeParameter", {
        visitor: [ "bound", "default", "variance" ],
        fields: {
          name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
          default: (0, _utils.validateOptionalType)("FlowType"),
          variance: (0, _utils.validateOptionalType)("Variance")
        }
      }), defineType("TypeParameterDeclaration", {
        visitor: [ "params" ],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
        }
      }), defineType("TypeParameterInstantiation", {
        visitor: [ "params" ],
        fields: {
          params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      }), defineType("UnionTypeAnnotation", {
        visitor: [ "types" ],
        aliases: [ "FlowType" ],
        fields: {
          types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
        }
      }), defineType("Variance", {
        builder: [ "kind" ],
        fields: {
          kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
        }
      }), defineType("VoidTypeAnnotation", {
        aliases: [ "FlowType", "FlowBaseAnnotation" ]
      }), defineType("EnumDeclaration", {
        aliases: [ "Statement", "Declaration" ],
        visitor: [ "id", "body" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          body: (0, _utils.validateType)([ "EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody" ])
        }
      }), defineType("EnumBooleanBody", {
        aliases: [ "EnumBody" ],
        visitor: [ "members" ],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("EnumNumberBody", {
        aliases: [ "EnumBody" ],
        visitor: [ "members" ],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("EnumStringBody", {
        aliases: [ "EnumBody" ],
        visitor: [ "members" ],
        fields: {
          explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
          members: (0, _utils.validateArrayOfType)([ "EnumStringMember", "EnumDefaultedMember" ]),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("EnumSymbolBody", {
        aliases: [ "EnumBody" ],
        visitor: [ "members" ],
        fields: {
          members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
          hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      }), defineType("EnumBooleanMember", {
        aliases: [ "EnumMember" ],
        visitor: [ "id" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("BooleanLiteral")
        }
      }), defineType("EnumNumberMember", {
        aliases: [ "EnumMember" ],
        visitor: [ "id", "init" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("NumericLiteral")
        }
      }), defineType("EnumStringMember", {
        aliases: [ "EnumMember" ],
        visitor: [ "id", "init" ],
        fields: {
          id: (0, _utils.validateType)("Identifier"),
          init: (0, _utils.validateType)("StringLiteral")
        }
      }), defineType("EnumDefaultedMember", {
        aliases: [ "EnumMember" ],
        visitor: [ "id" ],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      }), defineType("IndexedAccessType", {
        visitor: [ "objectType", "indexType" ],
        aliases: [ "FlowType" ],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType")
        }
      }), defineType("OptionalIndexedAccessType", {
        visitor: [ "objectType", "indexType" ],
        aliases: [ "FlowType" ],
        fields: {
          objectType: (0, _utils.validateType)("FlowType"),
          indexType: (0, _utils.validateType)("FlowType"),
          optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
        }
      });
    },
    6507: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), Object.defineProperty(exports, "ALIAS_KEYS", {
        enumerable: !0,
        get: function() {
          return _utils.ALIAS_KEYS;
        }
      }), Object.defineProperty(exports, "BUILDER_KEYS", {
        enumerable: !0,
        get: function() {
          return _utils.BUILDER_KEYS;
        }
      }), Object.defineProperty(exports, "DEPRECATED_KEYS", {
        enumerable: !0,
        get: function() {
          return _utils.DEPRECATED_KEYS;
        }
      }), Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
        enumerable: !0,
        get: function() {
          return _utils.FLIPPED_ALIAS_KEYS;
        }
      }), Object.defineProperty(exports, "NODE_FIELDS", {
        enumerable: !0,
        get: function() {
          return _utils.NODE_FIELDS;
        }
      }), Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
        enumerable: !0,
        get: function() {
          return _utils.NODE_PARENT_VALIDATIONS;
        }
      }), Object.defineProperty(exports, "PLACEHOLDERS", {
        enumerable: !0,
        get: function() {
          return _placeholders.PLACEHOLDERS;
        }
      }), Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
        enumerable: !0,
        get: function() {
          return _placeholders.PLACEHOLDERS_ALIAS;
        }
      }), Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
        enumerable: !0,
        get: function() {
          return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
        }
      }), exports.TYPES = void 0, Object.defineProperty(exports, "VISITOR_KEYS", {
        enumerable: !0,
        get: function() {
          return _utils.VISITOR_KEYS;
        }
      });
      var _toFastProperties = __webpack_require__(3164);
      __webpack_require__(4457), __webpack_require__(5391), __webpack_require__(8565), 
      __webpack_require__(5030), __webpack_require__(1456), __webpack_require__(45);
      var _utils = __webpack_require__(4913), _placeholders = __webpack_require__(9488);
      _toFastProperties(_utils.VISITOR_KEYS), _toFastProperties(_utils.ALIAS_KEYS), _toFastProperties(_utils.FLIPPED_ALIAS_KEYS), 
      _toFastProperties(_utils.NODE_FIELDS), _toFastProperties(_utils.BUILDER_KEYS), _toFastProperties(_utils.DEPRECATED_KEYS), 
      _toFastProperties(_placeholders.PLACEHOLDERS_ALIAS), _toFastProperties(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
      const TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
      exports.TYPES = TYPES;
    },
    8565: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _utils = __webpack_require__(4913);
      const defineType = (0, _utils.defineAliasedType)("JSX");
      defineType("JSXAttribute", {
        visitor: [ "name", "value" ],
        aliases: [ "Immutable" ],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
          },
          value: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
          }
        }
      }), defineType("JSXClosingElement", {
        visitor: [ "name" ],
        aliases: [ "Immutable" ],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
          }
        }
      }), defineType("JSXElement", {
        builder: [ "openingElement", "closingElement", "children", "selfClosing" ],
        visitor: [ "openingElement", "children", "closingElement" ],
        aliases: [ "Immutable", "Expression" ],
        fields: Object.assign({
          openingElement: {
            validate: (0, _utils.assertNodeType)("JSXOpeningElement")
          },
          closingElement: {
            optional: !0,
            validate: (0, _utils.assertNodeType)("JSXClosingElement")
          },
          children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
          }
        }, {
          selfClosing: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          }
        })
      }), defineType("JSXEmptyExpression", {}), defineType("JSXExpressionContainer", {
        visitor: [ "expression" ],
        aliases: [ "Immutable" ],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
          }
        }
      }), defineType("JSXSpreadChild", {
        visitor: [ "expression" ],
        aliases: [ "Immutable" ],
        fields: {
          expression: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("JSXIdentifier", {
        builder: [ "name" ],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      }), defineType("JSXMemberExpression", {
        visitor: [ "object", "property" ],
        fields: {
          object: {
            validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
          },
          property: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          }
        }
      }), defineType("JSXNamespacedName", {
        visitor: [ "namespace", "name" ],
        fields: {
          namespace: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          },
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier")
          }
        }
      }), defineType("JSXOpeningElement", {
        builder: [ "name", "attributes", "selfClosing" ],
        visitor: [ "name", "attributes" ],
        aliases: [ "Immutable" ],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
          },
          selfClosing: {
            default: !1
          },
          attributes: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
          },
          typeParameters: {
            validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
            optional: !0
          }
        }
      }), defineType("JSXSpreadAttribute", {
        visitor: [ "argument" ],
        fields: {
          argument: {
            validate: (0, _utils.assertNodeType)("Expression")
          }
        }
      }), defineType("JSXText", {
        aliases: [ "Immutable" ],
        builder: [ "value" ],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      }), defineType("JSXFragment", {
        builder: [ "openingFragment", "closingFragment", "children" ],
        visitor: [ "openingFragment", "children", "closingFragment" ],
        aliases: [ "Immutable", "Expression" ],
        fields: {
          openingFragment: {
            validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
          },
          closingFragment: {
            validate: (0, _utils.assertNodeType)("JSXClosingFragment")
          },
          children: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
          }
        }
      }), defineType("JSXOpeningFragment", {
        aliases: [ "Immutable" ]
      }), defineType("JSXClosingFragment", {
        aliases: [ "Immutable" ]
      });
    },
    5030: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _utils = __webpack_require__(4913), _placeholders = __webpack_require__(9488);
      const defineType = (0, _utils.defineAliasedType)("Miscellaneous");
      defineType("Noop", {
        visitor: []
      }), defineType("Placeholder", {
        visitor: [],
        builder: [ "expectedNode", "name" ],
        fields: {
          name: {
            validate: (0, _utils.assertNodeType)("Identifier")
          },
          expectedNode: {
            validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
          }
        }
      }), defineType("V8IntrinsicIdentifier", {
        builder: [ "name" ],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          }
        }
      });
    },
    9488: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
      var _utils = __webpack_require__(4913);
      const PLACEHOLDERS = [ "Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern" ];
      exports.PLACEHOLDERS = PLACEHOLDERS;
      const PLACEHOLDERS_ALIAS = {
        Declaration: [ "Statement" ],
        Pattern: [ "PatternLike", "LVal" ]
      };
      exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
      for (const type of PLACEHOLDERS) {
        const alias = _utils.ALIAS_KEYS[type];
        null != alias && alias.length && (PLACEHOLDERS_ALIAS[type] = alias);
      }
      const PLACEHOLDERS_FLIPPED_ALIAS = {};
      exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS, Object.keys(PLACEHOLDERS_ALIAS).forEach((type => {
        PLACEHOLDERS_ALIAS[type].forEach((alias => {
          Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias) || (PLACEHOLDERS_FLIPPED_ALIAS[alias] = []), 
          PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
        }));
      }));
    },
    45: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var _utils = __webpack_require__(4913), _core = __webpack_require__(4457), _is = __webpack_require__(7275);
      const defineType = (0, _utils.defineAliasedType)("TypeScript"), bool = (0, _utils.assertValueType)("boolean"), tSFunctionTypeAnnotationCommon = {
        returnType: {
          validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
          optional: !0
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
          optional: !0
        }
      };
      defineType("TSParameterProperty", {
        aliases: [ "LVal" ],
        visitor: [ "parameter" ],
        fields: {
          accessibility: {
            validate: (0, _utils.assertOneOf)("public", "private", "protected"),
            optional: !0
          },
          readonly: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          parameter: {
            validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
          },
          override: {
            validate: (0, _utils.assertValueType)("boolean"),
            optional: !0
          },
          decorators: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("Decorator"))),
            optional: !0
          }
        }
      }), defineType("TSDeclareFunction", {
        aliases: [ "Statement", "Declaration" ],
        visitor: [ "id", "typeParameters", "params", "returnType" ],
        fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
      }), defineType("TSDeclareMethod", {
        visitor: [ "decorators", "key", "typeParameters", "params", "returnType" ],
        fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
      }), defineType("TSQualifiedName", {
        aliases: [ "TSEntityName" ],
        visitor: [ "left", "right" ],
        fields: {
          left: (0, _utils.validateType)("TSEntityName"),
          right: (0, _utils.validateType)("Identifier")
        }
      });
      const signatureDeclarationCommon = {
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        parameters: (0, _utils.validateArrayOfType)([ "Identifier", "RestElement" ]),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }, callConstructSignatureDeclaration = {
        aliases: [ "TSTypeElement" ],
        visitor: [ "typeParameters", "parameters", "typeAnnotation" ],
        fields: signatureDeclarationCommon
      };
      defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration), defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
      const namedTypeElementCommon = {
        key: (0, _utils.validateType)("Expression"),
        computed: (0, _utils.validate)(bool),
        optional: (0, _utils.validateOptional)(bool)
      };
      defineType("TSPropertySignature", {
        aliases: [ "TSTypeElement" ],
        visitor: [ "key", "typeAnnotation", "initializer" ],
        fields: Object.assign({}, namedTypeElementCommon, {
          readonly: (0, _utils.validateOptional)(bool),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          initializer: (0, _utils.validateOptionalType)("Expression"),
          kind: {
            validate: (0, _utils.assertOneOf)("get", "set")
          }
        })
      }), defineType("TSMethodSignature", {
        aliases: [ "TSTypeElement" ],
        visitor: [ "key", "typeParameters", "parameters", "typeAnnotation" ],
        fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
          kind: {
            validate: (0, _utils.assertOneOf)("method", "get", "set")
          }
        })
      }), defineType("TSIndexSignature", {
        aliases: [ "TSTypeElement" ],
        visitor: [ "parameters", "typeAnnotation" ],
        fields: {
          readonly: (0, _utils.validateOptional)(bool),
          static: (0, _utils.validateOptional)(bool),
          parameters: (0, _utils.validateArrayOfType)("Identifier"),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
        }
      });
      const tsKeywordTypes = [ "TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword" ];
      for (const type of tsKeywordTypes) defineType(type, {
        aliases: [ "TSType", "TSBaseType" ],
        visitor: [],
        fields: {}
      });
      defineType("TSThisType", {
        aliases: [ "TSType", "TSBaseType" ],
        visitor: [],
        fields: {}
      });
      const fnOrCtrBase = {
        aliases: [ "TSType" ],
        visitor: [ "typeParameters", "parameters", "typeAnnotation" ]
      };
      defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
        fields: signatureDeclarationCommon
      })), defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
        fields: Object.assign({}, signatureDeclarationCommon, {
          abstract: (0, _utils.validateOptional)(bool)
        })
      })), defineType("TSTypeReference", {
        aliases: [ "TSType" ],
        visitor: [ "typeName", "typeParameters" ],
        fields: {
          typeName: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      }), defineType("TSTypePredicate", {
        aliases: [ "TSType" ],
        visitor: [ "parameterName", "typeAnnotation" ],
        builder: [ "parameterName", "typeAnnotation", "asserts" ],
        fields: {
          parameterName: (0, _utils.validateType)([ "Identifier", "TSThisType" ]),
          typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
          asserts: (0, _utils.validateOptional)(bool)
        }
      }), defineType("TSTypeQuery", {
        aliases: [ "TSType" ],
        visitor: [ "exprName" ],
        fields: {
          exprName: (0, _utils.validateType)([ "TSEntityName", "TSImportType" ])
        }
      }), defineType("TSTypeLiteral", {
        aliases: [ "TSType" ],
        visitor: [ "members" ],
        fields: {
          members: (0, _utils.validateArrayOfType)("TSTypeElement")
        }
      }), defineType("TSArrayType", {
        aliases: [ "TSType" ],
        visitor: [ "elementType" ],
        fields: {
          elementType: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSTupleType", {
        aliases: [ "TSType" ],
        visitor: [ "elementTypes" ],
        fields: {
          elementTypes: (0, _utils.validateArrayOfType)([ "TSType", "TSNamedTupleMember" ])
        }
      }), defineType("TSOptionalType", {
        aliases: [ "TSType" ],
        visitor: [ "typeAnnotation" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSRestType", {
        aliases: [ "TSType" ],
        visitor: [ "typeAnnotation" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSNamedTupleMember", {
        visitor: [ "label", "elementType" ],
        builder: [ "label", "elementType", "optional" ],
        fields: {
          label: (0, _utils.validateType)("Identifier"),
          optional: {
            validate: bool,
            default: !1
          },
          elementType: (0, _utils.validateType)("TSType")
        }
      });
      const unionOrIntersection = {
        aliases: [ "TSType" ],
        visitor: [ "types" ],
        fields: {
          types: (0, _utils.validateArrayOfType)("TSType")
        }
      };
      defineType("TSUnionType", unionOrIntersection), defineType("TSIntersectionType", unionOrIntersection), 
      defineType("TSConditionalType", {
        aliases: [ "TSType" ],
        visitor: [ "checkType", "extendsType", "trueType", "falseType" ],
        fields: {
          checkType: (0, _utils.validateType)("TSType"),
          extendsType: (0, _utils.validateType)("TSType"),
          trueType: (0, _utils.validateType)("TSType"),
          falseType: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSInferType", {
        aliases: [ "TSType" ],
        visitor: [ "typeParameter" ],
        fields: {
          typeParameter: (0, _utils.validateType)("TSTypeParameter")
        }
      }), defineType("TSParenthesizedType", {
        aliases: [ "TSType" ],
        visitor: [ "typeAnnotation" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSTypeOperator", {
        aliases: [ "TSType" ],
        visitor: [ "typeAnnotation" ],
        fields: {
          operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSIndexedAccessType", {
        aliases: [ "TSType" ],
        visitor: [ "objectType", "indexType" ],
        fields: {
          objectType: (0, _utils.validateType)("TSType"),
          indexType: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSMappedType", {
        aliases: [ "TSType" ],
        visitor: [ "typeParameter", "typeAnnotation", "nameType" ],
        fields: {
          readonly: (0, _utils.validateOptional)(bool),
          typeParameter: (0, _utils.validateType)("TSTypeParameter"),
          optional: (0, _utils.validateOptional)(bool),
          typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
          nameType: (0, _utils.validateOptionalType)("TSType")
        }
      }), defineType("TSLiteralType", {
        aliases: [ "TSType", "TSBaseType" ],
        visitor: [ "literal" ],
        fields: {
          literal: {
            validate: function() {
              const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral"), unaryOperator = (0, 
              _utils.assertOneOf)("-"), literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral");
              function validator(parent, key, node) {
                (0, _is.default)("UnaryExpression", node) ? (unaryOperator(node, "operator", node.operator), 
                unaryExpression(node, "argument", node.argument)) : literal(parent, key, node);
              }
              return validator.oneOfNodeTypes = [ "NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "UnaryExpression" ], 
              validator;
            }()
          }
        }
      }), defineType("TSExpressionWithTypeArguments", {
        aliases: [ "TSType" ],
        visitor: [ "expression", "typeParameters" ],
        fields: {
          expression: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      }), defineType("TSInterfaceDeclaration", {
        aliases: [ "Statement", "Declaration" ],
        visitor: [ "id", "typeParameters", "extends", "body" ],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
          body: (0, _utils.validateType)("TSInterfaceBody")
        }
      }), defineType("TSInterfaceBody", {
        visitor: [ "body" ],
        fields: {
          body: (0, _utils.validateArrayOfType)("TSTypeElement")
        }
      }), defineType("TSTypeAliasDeclaration", {
        aliases: [ "Statement", "Declaration" ],
        visitor: [ "id", "typeParameters", "typeAnnotation" ],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSAsExpression", {
        aliases: [ "Expression" ],
        visitor: [ "expression", "typeAnnotation" ],
        fields: {
          expression: (0, _utils.validateType)("Expression"),
          typeAnnotation: (0, _utils.validateType)("TSType")
        }
      }), defineType("TSTypeAssertion", {
        aliases: [ "Expression" ],
        visitor: [ "typeAnnotation", "expression" ],
        fields: {
          typeAnnotation: (0, _utils.validateType)("TSType"),
          expression: (0, _utils.validateType)("Expression")
        }
      }), defineType("TSEnumDeclaration", {
        aliases: [ "Statement", "Declaration" ],
        visitor: [ "id", "members" ],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          const: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          members: (0, _utils.validateArrayOfType)("TSEnumMember"),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      }), defineType("TSEnumMember", {
        visitor: [ "id", "initializer" ],
        fields: {
          id: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
          initializer: (0, _utils.validateOptionalType)("Expression")
        }
      }), defineType("TSModuleDeclaration", {
        aliases: [ "Statement", "Declaration" ],
        visitor: [ "id", "body" ],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          global: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
          body: (0, _utils.validateType)([ "TSModuleBlock", "TSModuleDeclaration" ])
        }
      }), defineType("TSModuleBlock", {
        aliases: [ "Scopable", "Block", "BlockParent" ],
        visitor: [ "body" ],
        fields: {
          body: (0, _utils.validateArrayOfType)("Statement")
        }
      }), defineType("TSImportType", {
        aliases: [ "TSType" ],
        visitor: [ "argument", "qualifier", "typeParameters" ],
        fields: {
          argument: (0, _utils.validateType)("StringLiteral"),
          qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      }), defineType("TSImportEqualsDeclaration", {
        aliases: [ "Statement" ],
        visitor: [ "id", "moduleReference" ],
        fields: {
          isExport: (0, _utils.validate)(bool),
          id: (0, _utils.validateType)("Identifier"),
          moduleReference: (0, _utils.validateType)([ "TSEntityName", "TSExternalModuleReference" ]),
          importKind: {
            validate: (0, _utils.assertOneOf)("type", "value"),
            optional: !0
          }
        }
      }), defineType("TSExternalModuleReference", {
        visitor: [ "expression" ],
        fields: {
          expression: (0, _utils.validateType)("StringLiteral")
        }
      }), defineType("TSNonNullExpression", {
        aliases: [ "Expression" ],
        visitor: [ "expression" ],
        fields: {
          expression: (0, _utils.validateType)("Expression")
        }
      }), defineType("TSExportAssignment", {
        aliases: [ "Statement" ],
        visitor: [ "expression" ],
        fields: {
          expression: (0, _utils.validateType)("Expression")
        }
      }), defineType("TSNamespaceExportDeclaration", {
        aliases: [ "Statement" ],
        visitor: [ "id" ],
        fields: {
          id: (0, _utils.validateType)("Identifier")
        }
      }), defineType("TSTypeAnnotation", {
        visitor: [ "typeAnnotation" ],
        fields: {
          typeAnnotation: {
            validate: (0, _utils.assertNodeType)("TSType")
          }
        }
      }), defineType("TSTypeParameterInstantiation", {
        visitor: [ "params" ],
        fields: {
          params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("TSType")))
          }
        }
      }), defineType("TSTypeParameterDeclaration", {
        visitor: [ "params" ],
        fields: {
          params: {
            validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
            _utils.assertNodeType)("TSTypeParameter")))
          }
        }
      }), defineType("TSTypeParameter", {
        builder: [ "constraint", "default", "name" ],
        visitor: [ "constraint", "default" ],
        fields: {
          name: {
            validate: (0, _utils.assertValueType)("string")
          },
          constraint: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: !0
          },
          default: {
            validate: (0, _utils.assertNodeType)("TSType"),
            optional: !0
          }
        }
      });
    },
    4913: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0, 
      exports.arrayOf = arrayOf, exports.arrayOfType = arrayOfType, exports.assertEach = assertEach, 
      exports.assertNodeOrValueType = function(...types) {
        function validate(node, key, val) {
          for (const type of types) if (getType(val) === type || (0, _is.default)(type, val)) return void (0, 
          _validate.validateChild)(node, key, val);
          throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null == val ? void 0 : val.type)}`);
        }
        return validate.oneOfNodeOrValueTypes = types, validate;
      }, exports.assertNodeType = assertNodeType, exports.assertOneOf = function(...values) {
        function validate(node, key, val) {
          if (values.indexOf(val) < 0) throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
        return validate.oneOf = values, validate;
      }, exports.assertOptionalChainStart = function() {
        return function(node) {
          var _current;
          let current = node;
          for (;node; ) {
            const {type} = current;
            if ("OptionalCallExpression" !== type) {
              if ("OptionalMemberExpression" !== type) break;
              if (current.optional) return;
              current = current.object;
            } else {
              if (current.optional) return;
              current = current.callee;
            }
          }
          throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (_current = current) ? void 0 : _current.type}`);
        };
      }, exports.assertShape = function(shape) {
        function validate(node, key, val) {
          const errors = [];
          for (const property of Object.keys(shape)) try {
            (0, _validate.validateField)(node, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
          if (errors.length) throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
        }
        return validate.shapeOf = shape, validate;
      }, exports.assertValueType = assertValueType, exports.chain = chain, exports.default = defineType, 
      exports.defineAliasedType = function(...aliases) {
        return (type, opts = {}) => {
          let defined = opts.aliases;
          var _store$opts$inherits$;
          defined || (opts.inherits && (defined = null == (_store$opts$inherits$ = store[opts.inherits].aliases) ? void 0 : _store$opts$inherits$.slice()), 
          null != defined || (defined = []), opts.aliases = defined);
          const additional = aliases.filter((a => !defined.includes(a)));
          return defined.unshift(...additional), defineType(type, opts);
        };
      }, exports.typeIs = typeIs, exports.validate = validate, exports.validateArrayOfType = function(typeName) {
        return validate(arrayOfType(typeName));
      }, exports.validateOptional = function(validate) {
        return {
          validate,
          optional: !0
        };
      }, exports.validateOptionalType = function(typeName) {
        return {
          validate: typeIs(typeName),
          optional: !0
        };
      }, exports.validateType = function(typeName) {
        return validate(typeIs(typeName));
      };
      var _is = __webpack_require__(7275), _validate = __webpack_require__(3804);
      const VISITOR_KEYS = {};
      exports.VISITOR_KEYS = VISITOR_KEYS;
      const ALIAS_KEYS = {};
      exports.ALIAS_KEYS = ALIAS_KEYS;
      const FLIPPED_ALIAS_KEYS = {};
      exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
      const NODE_FIELDS = {};
      exports.NODE_FIELDS = NODE_FIELDS;
      const BUILDER_KEYS = {};
      exports.BUILDER_KEYS = BUILDER_KEYS;
      const DEPRECATED_KEYS = {};
      exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
      const NODE_PARENT_VALIDATIONS = {};
      function getType(val) {
        return Array.isArray(val) ? "array" : null === val ? "null" : typeof val;
      }
      function validate(validate) {
        return {
          validate
        };
      }
      function typeIs(typeName) {
        return "string" == typeof typeName ? assertNodeType(typeName) : assertNodeType(...typeName);
      }
      function arrayOf(elementType) {
        return chain(assertValueType("array"), assertEach(elementType));
      }
      function arrayOfType(typeName) {
        return arrayOf(typeIs(typeName));
      }
      function assertEach(callback) {
        function validator(node, key, val) {
          if (Array.isArray(val)) for (let i = 0; i < val.length; i++) {
            const subkey = `${key}[${i}]`, v = val[i];
            callback(node, subkey, v), process.env.BABEL_TYPES_8_BREAKING && (0, _validate.validateChild)(node, subkey, v);
          }
        }
        return validator.each = callback, validator;
      }
      function assertNodeType(...types) {
        function validate(node, key, val) {
          for (const type of types) if ((0, _is.default)(type, val)) return void (0, _validate.validateChild)(node, key, val);
          throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null == val ? void 0 : val.type)}`);
        }
        return validate.oneOfNodeTypes = types, validate;
      }
      function assertValueType(type) {
        function validate(node, key, val) {
          if (!(getType(val) === type)) throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
        return validate.type = type, validate;
      }
      function chain(...fns) {
        function validate(...args) {
          for (const fn of fns) fn(...args);
        }
        if (validate.chainOf = fns, fns.length >= 2 && "type" in fns[0] && "array" === fns[0].type && !("each" in fns[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
        return validate;
      }
      exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
      const validTypeOpts = [ "aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate" ], validFieldKeys = [ "default", "optional", "validate" ];
      function defineType(type, opts = {}) {
        const inherits = opts.inherits && store[opts.inherits] || {};
        let fields = opts.fields;
        if (!fields && (fields = {}, inherits.fields)) {
          const keys = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys) {
            const field = inherits.fields[key], def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && "object" == typeof def) throw new Error("field defaults can only be primitives or empty arrays currently");
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              validate: field.validate
            };
          }
        }
        const visitor = opts.visitor || inherits.visitor || [], aliases = opts.aliases || inherits.aliases || [], builder = opts.builder || inherits.builder || opts.visitor || [];
        for (const k of Object.keys(opts)) if (-1 === validTypeOpts.indexOf(k)) throw new Error(`Unknown type option "${k}" on ${type}`);
        opts.deprecatedAlias && (DEPRECATED_KEYS[opts.deprecatedAlias] = type);
        for (const key of visitor.concat(builder)) fields[key] = fields[key] || {};
        for (const key of Object.keys(fields)) {
          const field = fields[key];
          void 0 !== field.default && -1 === builder.indexOf(key) && (field.optional = !0), 
          void 0 === field.default ? field.default = null : field.validate || null == field.default || (field.validate = assertValueType(getType(field.default)));
          for (const k of Object.keys(field)) if (-1 === validFieldKeys.indexOf(k)) throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
        VISITOR_KEYS[type] = opts.visitor = visitor, BUILDER_KEYS[type] = opts.builder = builder, 
        NODE_FIELDS[type] = opts.fields = fields, ALIAS_KEYS[type] = opts.aliases = aliases, 
        aliases.forEach((alias => {
          FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [], FLIPPED_ALIAS_KEYS[alias].push(type);
        })), opts.validate && (NODE_PARENT_VALIDATIONS[type] = opts.validate), store[type] = opts;
      }
      const store = {};
    },
    8218: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var _exportNames = {
        react: !0,
        assertNode: !0,
        createTypeAnnotationBasedOnTypeof: !0,
        createUnionTypeAnnotation: !0,
        createFlowUnionType: !0,
        createTSUnionType: !0,
        cloneNode: !0,
        clone: !0,
        cloneDeep: !0,
        cloneDeepWithoutLoc: !0,
        cloneWithoutLoc: !0,
        addComment: !0,
        addComments: !0,
        inheritInnerComments: !0,
        inheritLeadingComments: !0,
        inheritsComments: !0,
        inheritTrailingComments: !0,
        removeComments: !0,
        ensureBlock: !0,
        toBindingIdentifierName: !0,
        toBlock: !0,
        toComputedKey: !0,
        toExpression: !0,
        toIdentifier: !0,
        toKeyAlias: !0,
        toSequenceExpression: !0,
        toStatement: !0,
        valueToNode: !0,
        appendToMemberExpression: !0,
        inherits: !0,
        prependToMemberExpression: !0,
        removeProperties: !0,
        removePropertiesDeep: !0,
        removeTypeDuplicates: !0,
        getBindingIdentifiers: !0,
        getOuterBindingIdentifiers: !0,
        traverse: !0,
        traverseFast: !0,
        shallowEqual: !0,
        is: !0,
        isBinding: !0,
        isBlockScoped: !0,
        isImmutable: !0,
        isLet: !0,
        isNode: !0,
        isNodesEquivalent: !0,
        isPlaceholderType: !0,
        isReferenced: !0,
        isScope: !0,
        isSpecifierDefault: !0,
        isType: !0,
        isValidES3Identifier: !0,
        isValidIdentifier: !0,
        isVar: !0,
        matchesPattern: !0,
        validate: !0,
        buildMatchMemberExpression: !0
      };
      Object.defineProperty(exports, "addComment", {
        enumerable: !0,
        get: function() {
          return _addComment.default;
        }
      }), Object.defineProperty(exports, "addComments", {
        enumerable: !0,
        get: function() {
          return _addComments.default;
        }
      }), Object.defineProperty(exports, "appendToMemberExpression", {
        enumerable: !0,
        get: function() {
          return _appendToMemberExpression.default;
        }
      }), Object.defineProperty(exports, "assertNode", {
        enumerable: !0,
        get: function() {
          return _assertNode.default;
        }
      }), Object.defineProperty(exports, "buildMatchMemberExpression", {
        enumerable: !0,
        get: function() {
          return _buildMatchMemberExpression.default;
        }
      }), Object.defineProperty(exports, "clone", {
        enumerable: !0,
        get: function() {
          return _clone.default;
        }
      }), Object.defineProperty(exports, "cloneDeep", {
        enumerable: !0,
        get: function() {
          return _cloneDeep.default;
        }
      }), Object.defineProperty(exports, "cloneDeepWithoutLoc", {
        enumerable: !0,
        get: function() {
          return _cloneDeepWithoutLoc.default;
        }
      }), Object.defineProperty(exports, "cloneNode", {
        enumerable: !0,
        get: function() {
          return _cloneNode.default;
        }
      }), Object.defineProperty(exports, "cloneWithoutLoc", {
        enumerable: !0,
        get: function() {
          return _cloneWithoutLoc.default;
        }
      }), Object.defineProperty(exports, "createFlowUnionType", {
        enumerable: !0,
        get: function() {
          return _createFlowUnionType.default;
        }
      }), Object.defineProperty(exports, "createTSUnionType", {
        enumerable: !0,
        get: function() {
          return _createTSUnionType.default;
        }
      }), Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
        enumerable: !0,
        get: function() {
          return _createTypeAnnotationBasedOnTypeof.default;
        }
      }), Object.defineProperty(exports, "createUnionTypeAnnotation", {
        enumerable: !0,
        get: function() {
          return _createFlowUnionType.default;
        }
      }), Object.defineProperty(exports, "ensureBlock", {
        enumerable: !0,
        get: function() {
          return _ensureBlock.default;
        }
      }), Object.defineProperty(exports, "getBindingIdentifiers", {
        enumerable: !0,
        get: function() {
          return _getBindingIdentifiers.default;
        }
      }), Object.defineProperty(exports, "getOuterBindingIdentifiers", {
        enumerable: !0,
        get: function() {
          return _getOuterBindingIdentifiers.default;
        }
      }), Object.defineProperty(exports, "inheritInnerComments", {
        enumerable: !0,
        get: function() {
          return _inheritInnerComments.default;
        }
      }), Object.defineProperty(exports, "inheritLeadingComments", {
        enumerable: !0,
        get: function() {
          return _inheritLeadingComments.default;
        }
      }), Object.defineProperty(exports, "inheritTrailingComments", {
        enumerable: !0,
        get: function() {
          return _inheritTrailingComments.default;
        }
      }), Object.defineProperty(exports, "inherits", {
        enumerable: !0,
        get: function() {
          return _inherits.default;
        }
      }), Object.defineProperty(exports, "inheritsComments", {
        enumerable: !0,
        get: function() {
          return _inheritsComments.default;
        }
      }), Object.defineProperty(exports, "is", {
        enumerable: !0,
        get: function() {
          return _is.default;
        }
      }), Object.defineProperty(exports, "isBinding", {
        enumerable: !0,
        get: function() {
          return _isBinding.default;
        }
      }), Object.defineProperty(exports, "isBlockScoped", {
        enumerable: !0,
        get: function() {
          return _isBlockScoped.default;
        }
      }), Object.defineProperty(exports, "isImmutable", {
        enumerable: !0,
        get: function() {
          return _isImmutable.default;
        }
      }), Object.defineProperty(exports, "isLet", {
        enumerable: !0,
        get: function() {
          return _isLet.default;
        }
      }), Object.defineProperty(exports, "isNode", {
        enumerable: !0,
        get: function() {
          return _isNode.default;
        }
      }), Object.defineProperty(exports, "isNodesEquivalent", {
        enumerable: !0,
        get: function() {
          return _isNodesEquivalent.default;
        }
      }), Object.defineProperty(exports, "isPlaceholderType", {
        enumerable: !0,
        get: function() {
          return _isPlaceholderType.default;
        }
      }), Object.defineProperty(exports, "isReferenced", {
        enumerable: !0,
        get: function() {
          return _isReferenced.default;
        }
      }), Object.defineProperty(exports, "isScope", {
        enumerable: !0,
        get: function() {
          return _isScope.default;
        }
      }), Object.defineProperty(exports, "isSpecifierDefault", {
        enumerable: !0,
        get: function() {
          return _isSpecifierDefault.default;
        }
      }), Object.defineProperty(exports, "isType", {
        enumerable: !0,
        get: function() {
          return _isType.default;
        }
      }), Object.defineProperty(exports, "isValidES3Identifier", {
        enumerable: !0,
        get: function() {
          return _isValidES3Identifier.default;
        }
      }), Object.defineProperty(exports, "isValidIdentifier", {
        enumerable: !0,
        get: function() {
          return _isValidIdentifier.default;
        }
      }), Object.defineProperty(exports, "isVar", {
        enumerable: !0,
        get: function() {
          return _isVar.default;
        }
      }), Object.defineProperty(exports, "matchesPattern", {
        enumerable: !0,
        get: function() {
          return _matchesPattern.default;
        }
      }), Object.defineProperty(exports, "prependToMemberExpression", {
        enumerable: !0,
        get: function() {
          return _prependToMemberExpression.default;
        }
      }), exports.react = void 0, Object.defineProperty(exports, "removeComments", {
        enumerable: !0,
        get: function() {
          return _removeComments.default;
        }
      }), Object.defineProperty(exports, "removeProperties", {
        enumerable: !0,
        get: function() {
          return _removeProperties.default;
        }
      }), Object.defineProperty(exports, "removePropertiesDeep", {
        enumerable: !0,
        get: function() {
          return _removePropertiesDeep.default;
        }
      }), Object.defineProperty(exports, "removeTypeDuplicates", {
        enumerable: !0,
        get: function() {
          return _removeTypeDuplicates.default;
        }
      }), Object.defineProperty(exports, "shallowEqual", {
        enumerable: !0,
        get: function() {
          return _shallowEqual.default;
        }
      }), Object.defineProperty(exports, "toBindingIdentifierName", {
        enumerable: !0,
        get: function() {
          return _toBindingIdentifierName.default;
        }
      }), Object.defineProperty(exports, "toBlock", {
        enumerable: !0,
        get: function() {
          return _toBlock.default;
        }
      }), Object.defineProperty(exports, "toComputedKey", {
        enumerable: !0,
        get: function() {
          return _toComputedKey.default;
        }
      }), Object.defineProperty(exports, "toExpression", {
        enumerable: !0,
        get: function() {
          return _toExpression.default;
        }
      }), Object.defineProperty(exports, "toIdentifier", {
        enumerable: !0,
        get: function() {
          return _toIdentifier.default;
        }
      }), Object.defineProperty(exports, "toKeyAlias", {
        enumerable: !0,
        get: function() {
          return _toKeyAlias.default;
        }
      }), Object.defineProperty(exports, "toSequenceExpression", {
        enumerable: !0,
        get: function() {
          return _toSequenceExpression.default;
        }
      }), Object.defineProperty(exports, "toStatement", {
        enumerable: !0,
        get: function() {
          return _toStatement.default;
        }
      }), Object.defineProperty(exports, "traverse", {
        enumerable: !0,
        get: function() {
          return _traverse.default;
        }
      }), Object.defineProperty(exports, "traverseFast", {
        enumerable: !0,
        get: function() {
          return _traverseFast.default;
        }
      }), Object.defineProperty(exports, "validate", {
        enumerable: !0,
        get: function() {
          return _validate.default;
        }
      }), Object.defineProperty(exports, "valueToNode", {
        enumerable: !0,
        get: function() {
          return _valueToNode.default;
        }
      });
      var _isReactComponent = __webpack_require__(6035), _isCompatTag = __webpack_require__(3193), _buildChildren = __webpack_require__(8478), _assertNode = __webpack_require__(245), _generated = __webpack_require__(7133);
      Object.keys(_generated).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _generated[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _generated[key];
          }
        }));
      }));
      var _createTypeAnnotationBasedOnTypeof = __webpack_require__(949), _createFlowUnionType = __webpack_require__(9983), _createTSUnionType = __webpack_require__(4571), _generated2 = __webpack_require__(4391);
      Object.keys(_generated2).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _generated2[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _generated2[key];
          }
        }));
      }));
      var _uppercase = __webpack_require__(6104);
      Object.keys(_uppercase).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _uppercase[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _uppercase[key];
          }
        }));
      }));
      var _cloneNode = __webpack_require__(6209), _clone = __webpack_require__(2363), _cloneDeep = __webpack_require__(6953), _cloneDeepWithoutLoc = __webpack_require__(863), _cloneWithoutLoc = __webpack_require__(748), _addComment = __webpack_require__(9529), _addComments = __webpack_require__(6182), _inheritInnerComments = __webpack_require__(6455), _inheritLeadingComments = __webpack_require__(1835), _inheritsComments = __webpack_require__(9564), _inheritTrailingComments = __webpack_require__(9653), _removeComments = __webpack_require__(1200), _generated3 = __webpack_require__(8267);
      Object.keys(_generated3).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _generated3[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _generated3[key];
          }
        }));
      }));
      var _constants = __webpack_require__(6325);
      Object.keys(_constants).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _constants[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _constants[key];
          }
        }));
      }));
      var _ensureBlock = __webpack_require__(4315), _toBindingIdentifierName = __webpack_require__(8316), _toBlock = __webpack_require__(9276), _toComputedKey = __webpack_require__(9434), _toExpression = __webpack_require__(3348), _toIdentifier = __webpack_require__(1309), _toKeyAlias = __webpack_require__(510), _toSequenceExpression = __webpack_require__(1435), _toStatement = __webpack_require__(2307), _valueToNode = __webpack_require__(6794), _definitions = __webpack_require__(6507);
      Object.keys(_definitions).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _definitions[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _definitions[key];
          }
        }));
      }));
      var _appendToMemberExpression = __webpack_require__(7899), _inherits = __webpack_require__(3633), _prependToMemberExpression = __webpack_require__(3094), _removeProperties = __webpack_require__(2714), _removePropertiesDeep = __webpack_require__(4936), _removeTypeDuplicates = __webpack_require__(7321), _getBindingIdentifiers = __webpack_require__(1477), _getOuterBindingIdentifiers = __webpack_require__(2812), _traverse = __webpack_require__(8880);
      Object.keys(_traverse).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _traverse[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _traverse[key];
          }
        }));
      }));
      var _traverseFast = __webpack_require__(2862), _shallowEqual = __webpack_require__(7610), _is = __webpack_require__(7275), _isBinding = __webpack_require__(6971), _isBlockScoped = __webpack_require__(443), _isImmutable = __webpack_require__(9268), _isLet = __webpack_require__(7182), _isNode = __webpack_require__(8523), _isNodesEquivalent = __webpack_require__(4635), _isPlaceholderType = __webpack_require__(15), _isReferenced = __webpack_require__(4837), _isScope = __webpack_require__(6400), _isSpecifierDefault = __webpack_require__(2800), _isType = __webpack_require__(1452), _isValidES3Identifier = __webpack_require__(8917), _isValidIdentifier = __webpack_require__(3045), _isVar = __webpack_require__(830), _matchesPattern = __webpack_require__(2205), _validate = __webpack_require__(3804), _buildMatchMemberExpression = __webpack_require__(8847), _generated4 = __webpack_require__(4746);
      Object.keys(_generated4).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _generated4[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _generated4[key];
          }
        }));
      }));
      var _generated5 = __webpack_require__(1585);
      Object.keys(_generated5).forEach((function(key) {
        "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || key in exports && exports[key] === _generated5[key] || Object.defineProperty(exports, key, {
          enumerable: !0,
          get: function() {
            return _generated5[key];
          }
        }));
      }));
      const react = {
        isReactComponent: _isReactComponent.default,
        isCompatTag: _isCompatTag.default,
        buildChildren: _buildChildren.default
      };
      exports.react = react;
    },
    7899: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(member, append, computed = !1) {
        return member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed), 
        member.property = append, member.computed = !!computed, member;
      };
      var _generated = __webpack_require__(4391);
    },
    7321: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function removeTypeDuplicates(nodes) {
        const generics = {}, bases = {}, typeGroups = new Set, types = [];
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node && !(types.indexOf(node) >= 0)) {
            if ((0, _generated.isAnyTypeAnnotation)(node)) return [ node ];
            if ((0, _generated.isFlowBaseAnnotation)(node)) bases[node.type] = node; else if ((0, 
            _generated.isUnionTypeAnnotation)(node)) typeGroups.has(node.types) || (nodes = nodes.concat(node.types), 
            typeGroups.add(node.types)); else if ((0, _generated.isGenericTypeAnnotation)(node)) {
              const name = getQualifiedName(node.id);
              if (generics[name]) {
                let existing = generics[name];
                existing.typeParameters ? node.typeParameters && (existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params))) : existing = node.typeParameters;
              } else generics[name] = node;
            } else types.push(node);
          }
        }
        for (const type of Object.keys(bases)) types.push(bases[type]);
        for (const name of Object.keys(generics)) types.push(generics[name]);
        return types;
      };
      var _generated = __webpack_require__(4746);
      function getQualifiedName(node) {
        return (0, _generated.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
      }
    },
    3633: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(child, parent) {
        if (!child || !parent) return child;
        for (const key of _constants.INHERIT_KEYS.optional) null == child[key] && (child[key] = parent[key]);
        for (const key of Object.keys(parent)) "_" === key[0] && "__clone" !== key && (child[key] = parent[key]);
        for (const key of _constants.INHERIT_KEYS.force) child[key] = parent[key];
        return (0, _inheritsComments.default)(child, parent), child;
      };
      var _constants = __webpack_require__(6325), _inheritsComments = __webpack_require__(9564);
    },
    3094: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(member, prepend) {
        return member.object = (0, _generated.memberExpression)(prepend, member.object), 
        member;
      };
      var _generated = __webpack_require__(4391);
    },
    2714: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, opts = {}) {
        const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
        for (const key of map) null != node[key] && (node[key] = void 0);
        for (const key of Object.keys(node)) "_" === key[0] && null != node[key] && (node[key] = void 0);
        const symbols = Object.getOwnPropertySymbols(node);
        for (const sym of symbols) node[sym] = null;
      };
      var _constants = __webpack_require__(6325);
      const CLEAR_KEYS = [ "tokens", "start", "end", "loc", "raw", "rawValue" ], CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([ "comments" ]).concat(CLEAR_KEYS);
    },
    4936: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(tree, opts) {
        return (0, _traverseFast.default)(tree, _removeProperties.default, opts), tree;
      };
      var _traverseFast = __webpack_require__(2862), _removeProperties = __webpack_require__(2714);
    },
    1954: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(nodes) {
        const generics = {}, bases = {}, typeGroups = new Set, types = [];
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node && !(types.indexOf(node) >= 0)) {
            if ((0, _generated.isTSAnyKeyword)(node)) return [ node ];
            (0, _generated.isTSBaseType)(node) ? bases[node.type] = node : (0, _generated.isTSUnionType)(node) ? typeGroups.has(node.types) || (nodes.push(...node.types), 
            typeGroups.add(node.types)) : types.push(node);
          }
        }
        for (const type of Object.keys(bases)) types.push(bases[type]);
        for (const name of Object.keys(generics)) types.push(generics[name]);
        return types;
      };
      var _generated = __webpack_require__(4746);
    },
    1477: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = getBindingIdentifiers;
      var _generated = __webpack_require__(4746);
      function getBindingIdentifiers(node, duplicates, outerOnly) {
        let search = [].concat(node);
        const ids = Object.create(null);
        for (;search.length; ) {
          const id = search.shift();
          if (!id) continue;
          const keys = getBindingIdentifiers.keys[id.type];
          if ((0, _generated.isIdentifier)(id)) if (duplicates) {
            (ids[id.name] = ids[id.name] || []).push(id);
          } else ids[id.name] = id; else if (!(0, _generated.isExportDeclaration)(id) || (0, 
          _generated.isExportAllDeclaration)(id)) {
            if (outerOnly) {
              if ((0, _generated.isFunctionDeclaration)(id)) {
                search.push(id.id);
                continue;
              }
              if ((0, _generated.isFunctionExpression)(id)) continue;
            }
            if (keys) for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              id[key] && (search = search.concat(id[key]));
            }
          } else (0, _generated.isDeclaration)(id.declaration) && search.push(id.declaration);
        }
        return ids;
      }
      getBindingIdentifiers.keys = {
        DeclareClass: [ "id" ],
        DeclareFunction: [ "id" ],
        DeclareModule: [ "id" ],
        DeclareVariable: [ "id" ],
        DeclareInterface: [ "id" ],
        DeclareTypeAlias: [ "id" ],
        DeclareOpaqueType: [ "id" ],
        InterfaceDeclaration: [ "id" ],
        TypeAlias: [ "id" ],
        OpaqueType: [ "id" ],
        CatchClause: [ "param" ],
        LabeledStatement: [ "label" ],
        UnaryExpression: [ "argument" ],
        AssignmentExpression: [ "left" ],
        ImportSpecifier: [ "local" ],
        ImportNamespaceSpecifier: [ "local" ],
        ImportDefaultSpecifier: [ "local" ],
        ImportDeclaration: [ "specifiers" ],
        ExportSpecifier: [ "exported" ],
        ExportNamespaceSpecifier: [ "exported" ],
        ExportDefaultSpecifier: [ "exported" ],
        FunctionDeclaration: [ "id", "params" ],
        FunctionExpression: [ "id", "params" ],
        ArrowFunctionExpression: [ "params" ],
        ObjectMethod: [ "params" ],
        ClassMethod: [ "params" ],
        ClassPrivateMethod: [ "params" ],
        ForInStatement: [ "left" ],
        ForOfStatement: [ "left" ],
        ClassDeclaration: [ "id" ],
        ClassExpression: [ "id" ],
        RestElement: [ "argument" ],
        UpdateExpression: [ "argument" ],
        ObjectProperty: [ "value" ],
        AssignmentPattern: [ "left" ],
        ArrayPattern: [ "elements" ],
        ObjectPattern: [ "properties" ],
        VariableDeclaration: [ "declarations" ],
        VariableDeclarator: [ "id" ]
      };
    },
    2812: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _getBindingIdentifiers = __webpack_require__(1477), _default = function(node, duplicates) {
        return (0, _getBindingIdentifiers.default)(node, duplicates, !0);
      };
      exports.default = _default;
    },
    8880: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, handlers, state) {
        "function" == typeof handlers && (handlers = {
          enter: handlers
        });
        const {enter, exit} = handlers;
        traverseSimpleImpl(node, enter, exit, state, []);
      };
      var _definitions = __webpack_require__(6507);
      function traverseSimpleImpl(node, enter, exit, state, ancestors) {
        const keys = _definitions.VISITOR_KEYS[node.type];
        if (keys) {
          enter && enter(node, ancestors, state);
          for (const key of keys) {
            const subNode = node[key];
            if (Array.isArray(subNode)) for (let i = 0; i < subNode.length; i++) {
              const child = subNode[i];
              child && (ancestors.push({
                node,
                key,
                index: i
              }), traverseSimpleImpl(child, enter, exit, state, ancestors), ancestors.pop());
            } else subNode && (ancestors.push({
              node,
              key
            }), traverseSimpleImpl(subNode, enter, exit, state, ancestors), ancestors.pop());
          }
          exit && exit(node, ancestors, state);
        }
      }
    },
    2862: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function traverseFast(node, enter, opts) {
        if (!node) return;
        const keys = _definitions.VISITOR_KEYS[node.type];
        if (!keys) return;
        enter(node, opts = opts || {});
        for (const key of keys) {
          const subNode = node[key];
          if (Array.isArray(subNode)) for (const node of subNode) traverseFast(node, enter, opts); else traverseFast(subNode, enter, opts);
        }
      };
      var _definitions = __webpack_require__(6507);
    },
    8834: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(key, child, parent) {
        child && parent && (child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean))));
      };
    },
    5835: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(child, args) {
        const lines = child.value.split(/\r\n|\n|\r/);
        let lastNonEmptyLine = 0;
        for (let i = 0; i < lines.length; i++) lines[i].match(/[^ \t]/) && (lastNonEmptyLine = i);
        let str = "";
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i], isFirstLine = 0 === i, isLastLine = i === lines.length - 1, isLastNonEmptyLine = i === lastNonEmptyLine;
          let trimmedLine = line.replace(/\t/g, " ");
          isFirstLine || (trimmedLine = trimmedLine.replace(/^[ ]+/, "")), isLastLine || (trimmedLine = trimmedLine.replace(/[ ]+$/, "")), 
          trimmedLine && (isLastNonEmptyLine || (trimmedLine += " "), str += trimmedLine);
        }
        str && args.push((0, _generated.stringLiteral)(str));
      };
      var _generated = __webpack_require__(4391);
    },
    7610: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(actual, expected) {
        const keys = Object.keys(expected);
        for (const key of keys) if (actual[key] !== expected[key]) return !1;
        return !0;
      };
    },
    8847: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(match, allowPartial) {
        const parts = match.split(".");
        return member => (0, _matchesPattern.default)(member, parts, allowPartial);
      };
      var _matchesPattern = __webpack_require__(2205);
    },
    4746: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.isAccessor = function(node, opts) {
        if (!node) return !1;
        if ("ClassAccessorProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isAnyTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("AnyTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isArgumentPlaceholder = function(node, opts) {
        if (!node) return !1;
        if ("ArgumentPlaceholder" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isArrayExpression = function(node, opts) {
        if (!node) return !1;
        if ("ArrayExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isArrayPattern = function(node, opts) {
        if (!node) return !1;
        if ("ArrayPattern" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isArrayTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("ArrayTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isArrowFunctionExpression = function(node, opts) {
        if (!node) return !1;
        if ("ArrowFunctionExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isAssignmentExpression = function(node, opts) {
        if (!node) return !1;
        if ("AssignmentExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isAssignmentPattern = function(node, opts) {
        if (!node) return !1;
        if ("AssignmentPattern" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isAwaitExpression = function(node, opts) {
        if (!node) return !1;
        if ("AwaitExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBigIntLiteral = function(node, opts) {
        if (!node) return !1;
        if ("BigIntLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBinary = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBinaryExpression = function(node, opts) {
        if (!node) return !1;
        if ("BinaryExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBindExpression = function(node, opts) {
        if (!node) return !1;
        if ("BindExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBlock = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || "Placeholder" === nodeType && "BlockStatement" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBlockParent = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || "Placeholder" === nodeType && "BlockStatement" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBlockStatement = function(node, opts) {
        if (!node) return !1;
        if ("BlockStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBooleanLiteral = function(node, opts) {
        if (!node) return !1;
        if ("BooleanLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBooleanLiteralTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("BooleanLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBooleanTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("BooleanTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isBreakStatement = function(node, opts) {
        if (!node) return !1;
        if ("BreakStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isCallExpression = function(node, opts) {
        if (!node) return !1;
        if ("CallExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isCatchClause = function(node, opts) {
        if (!node) return !1;
        if ("CatchClause" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClass = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassAccessorProperty = function(node, opts) {
        if (!node) return !1;
        if ("ClassAccessorProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassBody = function(node, opts) {
        if (!node) return !1;
        if ("ClassBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("ClassDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassExpression = function(node, opts) {
        if (!node) return !1;
        if ("ClassExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassImplements = function(node, opts) {
        if (!node) return !1;
        if ("ClassImplements" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassMethod = function(node, opts) {
        if (!node) return !1;
        if ("ClassMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassPrivateMethod = function(node, opts) {
        if (!node) return !1;
        if ("ClassPrivateMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassPrivateProperty = function(node, opts) {
        if (!node) return !1;
        if ("ClassPrivateProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isClassProperty = function(node, opts) {
        if (!node) return !1;
        if ("ClassProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isCompletionStatement = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isConditional = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isConditionalExpression = function(node, opts) {
        if (!node) return !1;
        if ("ConditionalExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isContinueStatement = function(node, opts) {
        if (!node) return !1;
        if ("ContinueStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDebuggerStatement = function(node, opts) {
        if (!node) return !1;
        if ("DebuggerStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDecimalLiteral = function(node, opts) {
        if (!node) return !1;
        if ("DecimalLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclaration = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "Placeholder" === nodeType && "Declaration" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareClass = function(node, opts) {
        if (!node) return !1;
        if ("DeclareClass" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareExportAllDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("DeclareExportAllDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareExportDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("DeclareExportDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareFunction = function(node, opts) {
        if (!node) return !1;
        if ("DeclareFunction" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareInterface = function(node, opts) {
        if (!node) return !1;
        if ("DeclareInterface" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareModule = function(node, opts) {
        if (!node) return !1;
        if ("DeclareModule" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareModuleExports = function(node, opts) {
        if (!node) return !1;
        if ("DeclareModuleExports" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareOpaqueType = function(node, opts) {
        if (!node) return !1;
        if ("DeclareOpaqueType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareTypeAlias = function(node, opts) {
        if (!node) return !1;
        if ("DeclareTypeAlias" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclareVariable = function(node, opts) {
        if (!node) return !1;
        if ("DeclareVariable" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDeclaredPredicate = function(node, opts) {
        if (!node) return !1;
        if ("DeclaredPredicate" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDecorator = function(node, opts) {
        if (!node) return !1;
        if ("Decorator" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDirective = function(node, opts) {
        if (!node) return !1;
        if ("Directive" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDirectiveLiteral = function(node, opts) {
        if (!node) return !1;
        if ("DirectiveLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDoExpression = function(node, opts) {
        if (!node) return !1;
        if ("DoExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isDoWhileStatement = function(node, opts) {
        if (!node) return !1;
        if ("DoWhileStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEmptyStatement = function(node, opts) {
        if (!node) return !1;
        if ("EmptyStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEmptyTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("EmptyTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumBody = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumBooleanBody = function(node, opts) {
        if (!node) return !1;
        if ("EnumBooleanBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumBooleanMember = function(node, opts) {
        if (!node) return !1;
        if ("EnumBooleanMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("EnumDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumDefaultedMember = function(node, opts) {
        if (!node) return !1;
        if ("EnumDefaultedMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumMember = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumNumberBody = function(node, opts) {
        if (!node) return !1;
        if ("EnumNumberBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumNumberMember = function(node, opts) {
        if (!node) return !1;
        if ("EnumNumberMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumStringBody = function(node, opts) {
        if (!node) return !1;
        if ("EnumStringBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumStringMember = function(node, opts) {
        if (!node) return !1;
        if ("EnumStringMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isEnumSymbolBody = function(node, opts) {
        if (!node) return !1;
        if ("EnumSymbolBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExistsTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("ExistsTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportAllDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("ExportAllDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportDeclaration = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportDefaultDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("ExportDefaultDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportDefaultSpecifier = function(node, opts) {
        if (!node) return !1;
        if ("ExportDefaultSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportNamedDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("ExportNamedDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportNamespaceSpecifier = function(node, opts) {
        if (!node) return !1;
        if ("ExportNamespaceSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExportSpecifier = function(node, opts) {
        if (!node) return !1;
        if ("ExportSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExpression = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || "Placeholder" === nodeType && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExpressionStatement = function(node, opts) {
        if (!node) return !1;
        if ("ExpressionStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isExpressionWrapper = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFile = function(node, opts) {
        if (!node) return !1;
        if ("File" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFlow = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFlowBaseAnnotation = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFlowDeclaration = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFlowPredicate = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFlowType = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFor = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isForInStatement = function(node, opts) {
        if (!node) return !1;
        if ("ForInStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isForOfStatement = function(node, opts) {
        if (!node) return !1;
        if ("ForOfStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isForStatement = function(node, opts) {
        if (!node) return !1;
        if ("ForStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isForXStatement = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFunction = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFunctionDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("FunctionDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFunctionExpression = function(node, opts) {
        if (!node) return !1;
        if ("FunctionExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFunctionParent = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFunctionTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("FunctionTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isFunctionTypeParam = function(node, opts) {
        if (!node) return !1;
        if ("FunctionTypeParam" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isGenericTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("GenericTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isIdentifier = function(node, opts) {
        if (!node) return !1;
        if ("Identifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isIfStatement = function(node, opts) {
        if (!node) return !1;
        if ("IfStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImmutable = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || "Placeholder" === nodeType && "StringLiteral" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImport = function(node, opts) {
        if (!node) return !1;
        if ("Import" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImportAttribute = function(node, opts) {
        if (!node) return !1;
        if ("ImportAttribute" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImportDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("ImportDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImportDefaultSpecifier = function(node, opts) {
        if (!node) return !1;
        if ("ImportDefaultSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImportNamespaceSpecifier = function(node, opts) {
        if (!node) return !1;
        if ("ImportNamespaceSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isImportSpecifier = function(node, opts) {
        if (!node) return !1;
        if ("ImportSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isIndexedAccessType = function(node, opts) {
        if (!node) return !1;
        if ("IndexedAccessType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isInferredPredicate = function(node, opts) {
        if (!node) return !1;
        if ("InferredPredicate" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isInterfaceDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("InterfaceDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isInterfaceExtends = function(node, opts) {
        if (!node) return !1;
        if ("InterfaceExtends" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isInterfaceTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("InterfaceTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isInterpreterDirective = function(node, opts) {
        if (!node) return !1;
        if ("InterpreterDirective" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isIntersectionTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("IntersectionTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSX = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXAttribute = function(node, opts) {
        if (!node) return !1;
        if ("JSXAttribute" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXClosingElement = function(node, opts) {
        if (!node) return !1;
        if ("JSXClosingElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXClosingFragment = function(node, opts) {
        if (!node) return !1;
        if ("JSXClosingFragment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXElement = function(node, opts) {
        if (!node) return !1;
        if ("JSXElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXEmptyExpression = function(node, opts) {
        if (!node) return !1;
        if ("JSXEmptyExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXExpressionContainer = function(node, opts) {
        if (!node) return !1;
        if ("JSXExpressionContainer" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXFragment = function(node, opts) {
        if (!node) return !1;
        if ("JSXFragment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXIdentifier = function(node, opts) {
        if (!node) return !1;
        if ("JSXIdentifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXMemberExpression = function(node, opts) {
        if (!node) return !1;
        if ("JSXMemberExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXNamespacedName = function(node, opts) {
        if (!node) return !1;
        if ("JSXNamespacedName" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXOpeningElement = function(node, opts) {
        if (!node) return !1;
        if ("JSXOpeningElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXOpeningFragment = function(node, opts) {
        if (!node) return !1;
        if ("JSXOpeningFragment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXSpreadAttribute = function(node, opts) {
        if (!node) return !1;
        if ("JSXSpreadAttribute" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXSpreadChild = function(node, opts) {
        if (!node) return !1;
        if ("JSXSpreadChild" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isJSXText = function(node, opts) {
        if (!node) return !1;
        if ("JSXText" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isLVal = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || "Placeholder" === nodeType && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isLabeledStatement = function(node, opts) {
        if (!node) return !1;
        if ("LabeledStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isLiteral = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || "Placeholder" === nodeType && "StringLiteral" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isLogicalExpression = function(node, opts) {
        if (!node) return !1;
        if ("LogicalExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isLoop = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isMemberExpression = function(node, opts) {
        if (!node) return !1;
        if ("MemberExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isMetaProperty = function(node, opts) {
        if (!node) return !1;
        if ("MetaProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isMethod = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isMiscellaneous = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isMixedTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("MixedTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isModuleDeclaration = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isModuleExpression = function(node, opts) {
        if (!node) return !1;
        if ("ModuleExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isModuleSpecifier = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNewExpression = function(node, opts) {
        if (!node) return !1;
        if ("NewExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNoop = function(node, opts) {
        if (!node) return !1;
        if ("Noop" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNullLiteral = function(node, opts) {
        if (!node) return !1;
        if ("NullLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNullLiteralTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("NullLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNullableTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("NullableTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNumberLiteral = function(node, opts) {
        if (console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), 
        !node) return !1;
        if ("NumberLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNumberLiteralTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("NumberLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNumberTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("NumberTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isNumericLiteral = function(node, opts) {
        if (!node) return !1;
        if ("NumericLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectExpression = function(node, opts) {
        if (!node) return !1;
        if ("ObjectExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectMember = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectMethod = function(node, opts) {
        if (!node) return !1;
        if ("ObjectMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectPattern = function(node, opts) {
        if (!node) return !1;
        if ("ObjectPattern" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectProperty = function(node, opts) {
        if (!node) return !1;
        if ("ObjectProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("ObjectTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectTypeCallProperty = function(node, opts) {
        if (!node) return !1;
        if ("ObjectTypeCallProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectTypeIndexer = function(node, opts) {
        if (!node) return !1;
        if ("ObjectTypeIndexer" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectTypeInternalSlot = function(node, opts) {
        if (!node) return !1;
        if ("ObjectTypeInternalSlot" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectTypeProperty = function(node, opts) {
        if (!node) return !1;
        if ("ObjectTypeProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isObjectTypeSpreadProperty = function(node, opts) {
        if (!node) return !1;
        if ("ObjectTypeSpreadProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isOpaqueType = function(node, opts) {
        if (!node) return !1;
        if ("OpaqueType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isOptionalCallExpression = function(node, opts) {
        if (!node) return !1;
        if ("OptionalCallExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isOptionalIndexedAccessType = function(node, opts) {
        if (!node) return !1;
        if ("OptionalIndexedAccessType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isOptionalMemberExpression = function(node, opts) {
        if (!node) return !1;
        if ("OptionalMemberExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isParenthesizedExpression = function(node, opts) {
        if (!node) return !1;
        if ("ParenthesizedExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPattern = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "Placeholder" === nodeType && "Pattern" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPatternLike = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "Placeholder" === nodeType && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPipelineBareFunction = function(node, opts) {
        if (!node) return !1;
        if ("PipelineBareFunction" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPipelinePrimaryTopicReference = function(node, opts) {
        if (!node) return !1;
        if ("PipelinePrimaryTopicReference" === node.type) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPipelineTopicExpression = function(node, opts) {
        if (!node) return !1;
        if ("PipelineTopicExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPlaceholder = function(node, opts) {
        if (!node) return !1;
        if ("Placeholder" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPrivate = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPrivateName = function(node, opts) {
        if (!node) return !1;
        if ("PrivateName" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isProgram = function(node, opts) {
        if (!node) return !1;
        if ("Program" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isProperty = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isPureish = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || "Placeholder" === nodeType && "StringLiteral" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isQualifiedTypeIdentifier = function(node, opts) {
        if (!node) return !1;
        if ("QualifiedTypeIdentifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isRecordExpression = function(node, opts) {
        if (!node) return !1;
        if ("RecordExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isRegExpLiteral = function(node, opts) {
        if (!node) return !1;
        if ("RegExpLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isRegexLiteral = function(node, opts) {
        if (console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), 
        !node) return !1;
        if ("RegexLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isRestElement = function(node, opts) {
        if (!node) return !1;
        if ("RestElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isRestProperty = function(node, opts) {
        if (console.trace("The node type RestProperty has been renamed to RestElement"), 
        !node) return !1;
        if ("RestProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isReturnStatement = function(node, opts) {
        if (!node) return !1;
        if ("ReturnStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isScopable = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || "Placeholder" === nodeType && "BlockStatement" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSequenceExpression = function(node, opts) {
        if (!node) return !1;
        if ("SequenceExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSpreadElement = function(node, opts) {
        if (!node) return !1;
        if ("SpreadElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSpreadProperty = function(node, opts) {
        if (console.trace("The node type SpreadProperty has been renamed to SpreadElement"), 
        !node) return !1;
        if ("SpreadProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isStandardized = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || "Placeholder" === nodeType && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isStatement = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "Placeholder" === nodeType && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isStaticBlock = function(node, opts) {
        if (!node) return !1;
        if ("StaticBlock" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isStringLiteral = function(node, opts) {
        if (!node) return !1;
        if ("StringLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isStringLiteralTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("StringLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isStringTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("StringTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSuper = function(node, opts) {
        if (!node) return !1;
        if ("Super" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSwitchCase = function(node, opts) {
        if (!node) return !1;
        if ("SwitchCase" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSwitchStatement = function(node, opts) {
        if (!node) return !1;
        if ("SwitchStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isSymbolTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("SymbolTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSAnyKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSAnyKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSArrayType = function(node, opts) {
        if (!node) return !1;
        if ("TSArrayType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSAsExpression = function(node, opts) {
        if (!node) return !1;
        if ("TSAsExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSBaseType = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSBigIntKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSBigIntKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSBooleanKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSBooleanKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSCallSignatureDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSCallSignatureDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSConditionalType = function(node, opts) {
        if (!node) return !1;
        if ("TSConditionalType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSConstructSignatureDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSConstructSignatureDeclaration" === node.type) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSConstructorType = function(node, opts) {
        if (!node) return !1;
        if ("TSConstructorType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSDeclareFunction = function(node, opts) {
        if (!node) return !1;
        if ("TSDeclareFunction" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSDeclareMethod = function(node, opts) {
        if (!node) return !1;
        if ("TSDeclareMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSEntityName = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || "Placeholder" === nodeType && "Identifier" === node.expectedNode) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSEnumDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSEnumDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSEnumMember = function(node, opts) {
        if (!node) return !1;
        if ("TSEnumMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSExportAssignment = function(node, opts) {
        if (!node) return !1;
        if ("TSExportAssignment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSExpressionWithTypeArguments = function(node, opts) {
        if (!node) return !1;
        if ("TSExpressionWithTypeArguments" === node.type) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSExternalModuleReference = function(node, opts) {
        if (!node) return !1;
        if ("TSExternalModuleReference" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSFunctionType = function(node, opts) {
        if (!node) return !1;
        if ("TSFunctionType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSImportEqualsDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSImportEqualsDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSImportType = function(node, opts) {
        if (!node) return !1;
        if ("TSImportType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSIndexSignature = function(node, opts) {
        if (!node) return !1;
        if ("TSIndexSignature" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSIndexedAccessType = function(node, opts) {
        if (!node) return !1;
        if ("TSIndexedAccessType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSInferType = function(node, opts) {
        if (!node) return !1;
        if ("TSInferType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSInterfaceBody = function(node, opts) {
        if (!node) return !1;
        if ("TSInterfaceBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSInterfaceDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSInterfaceDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSIntersectionType = function(node, opts) {
        if (!node) return !1;
        if ("TSIntersectionType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSIntrinsicKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSIntrinsicKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSLiteralType = function(node, opts) {
        if (!node) return !1;
        if ("TSLiteralType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSMappedType = function(node, opts) {
        if (!node) return !1;
        if ("TSMappedType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSMethodSignature = function(node, opts) {
        if (!node) return !1;
        if ("TSMethodSignature" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSModuleBlock = function(node, opts) {
        if (!node) return !1;
        if ("TSModuleBlock" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSModuleDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSModuleDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSNamedTupleMember = function(node, opts) {
        if (!node) return !1;
        if ("TSNamedTupleMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSNamespaceExportDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSNamespaceExportDeclaration" === node.type) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSNeverKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSNeverKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSNonNullExpression = function(node, opts) {
        if (!node) return !1;
        if ("TSNonNullExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSNullKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSNullKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSNumberKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSNumberKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSObjectKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSObjectKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSOptionalType = function(node, opts) {
        if (!node) return !1;
        if ("TSOptionalType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSParameterProperty = function(node, opts) {
        if (!node) return !1;
        if ("TSParameterProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSParenthesizedType = function(node, opts) {
        if (!node) return !1;
        if ("TSParenthesizedType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSPropertySignature = function(node, opts) {
        if (!node) return !1;
        if ("TSPropertySignature" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSQualifiedName = function(node, opts) {
        if (!node) return !1;
        if ("TSQualifiedName" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSRestType = function(node, opts) {
        if (!node) return !1;
        if ("TSRestType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSStringKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSStringKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSSymbolKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSSymbolKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSThisType = function(node, opts) {
        if (!node) return !1;
        if ("TSThisType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTupleType = function(node, opts) {
        if (!node) return !1;
        if ("TSTupleType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSType = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeAliasDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeAliasDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeAssertion = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeAssertion" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeElement = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeLiteral = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeOperator = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeOperator" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeParameter = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeParameter" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeParameterDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeParameterDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeParameterInstantiation = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeParameterInstantiation" === node.type) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypePredicate = function(node, opts) {
        if (!node) return !1;
        if ("TSTypePredicate" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeQuery = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeQuery" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSTypeReference = function(node, opts) {
        if (!node) return !1;
        if ("TSTypeReference" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSUndefinedKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSUndefinedKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSUnionType = function(node, opts) {
        if (!node) return !1;
        if ("TSUnionType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSUnknownKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSUnknownKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTSVoidKeyword = function(node, opts) {
        if (!node) return !1;
        if ("TSVoidKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTaggedTemplateExpression = function(node, opts) {
        if (!node) return !1;
        if ("TaggedTemplateExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTemplateElement = function(node, opts) {
        if (!node) return !1;
        if ("TemplateElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTemplateLiteral = function(node, opts) {
        if (!node) return !1;
        if ("TemplateLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTerminatorless = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isThisExpression = function(node, opts) {
        if (!node) return !1;
        if ("ThisExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isThisTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("ThisTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isThrowStatement = function(node, opts) {
        if (!node) return !1;
        if ("ThrowStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTopicReference = function(node, opts) {
        if (!node) return !1;
        if ("TopicReference" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTryStatement = function(node, opts) {
        if (!node) return !1;
        if ("TryStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTupleExpression = function(node, opts) {
        if (!node) return !1;
        if ("TupleExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTupleTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("TupleTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeAlias = function(node, opts) {
        if (!node) return !1;
        if ("TypeAlias" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("TypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeCastExpression = function(node, opts) {
        if (!node) return !1;
        if ("TypeCastExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeParameter = function(node, opts) {
        if (!node) return !1;
        if ("TypeParameter" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeParameterDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("TypeParameterDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeParameterInstantiation = function(node, opts) {
        if (!node) return !1;
        if ("TypeParameterInstantiation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeScript = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isTypeofTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("TypeofTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isUnaryExpression = function(node, opts) {
        if (!node) return !1;
        if ("UnaryExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isUnaryLike = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isUnionTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("UnionTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isUpdateExpression = function(node, opts) {
        if (!node) return !1;
        if ("UpdateExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isUserWhitespacable = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isV8IntrinsicIdentifier = function(node, opts) {
        if (!node) return !1;
        if ("V8IntrinsicIdentifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isVariableDeclaration = function(node, opts) {
        if (!node) return !1;
        if ("VariableDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isVariableDeclarator = function(node, opts) {
        if (!node) return !1;
        if ("VariableDeclarator" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isVariance = function(node, opts) {
        if (!node) return !1;
        if ("Variance" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isVoidTypeAnnotation = function(node, opts) {
        if (!node) return !1;
        if ("VoidTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isWhile = function(node, opts) {
        if (!node) return !1;
        const nodeType = node.type;
        if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) return void 0 === opts || (0, 
        _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isWhileStatement = function(node, opts) {
        if (!node) return !1;
        if ("WhileStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isWithStatement = function(node, opts) {
        if (!node) return !1;
        if ("WithStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      }, exports.isYieldExpression = function(node, opts) {
        if (!node) return !1;
        if ("YieldExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
        return !1;
      };
      var _shallowEqual = __webpack_require__(7610);
    },
    7275: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(type, node, opts) {
        if (!node) return !1;
        if (!(0, _isType.default)(node.type, type)) return !opts && "Placeholder" === node.type && type in _definitions.FLIPPED_ALIAS_KEYS && (0, 
        _isPlaceholderType.default)(node.expectedNode, type);
        return void 0 === opts || (0, _shallowEqual.default)(node, opts);
      };
      var _shallowEqual = __webpack_require__(7610), _isType = __webpack_require__(1452), _isPlaceholderType = __webpack_require__(15), _definitions = __webpack_require__(6507);
    },
    6971: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, parent, grandparent) {
        if (grandparent && "Identifier" === node.type && "ObjectProperty" === parent.type && "ObjectExpression" === grandparent.type) return !1;
        const keys = _getBindingIdentifiers.default.keys[parent.type];
        if (keys) for (let i = 0; i < keys.length; i++) {
          const key = keys[i], val = parent[key];
          if (Array.isArray(val)) {
            if (val.indexOf(node) >= 0) return !0;
          } else if (val === node) return !0;
        }
        return !1;
      };
      var _getBindingIdentifiers = __webpack_require__(1477);
    },
    443: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, 
        _isLet.default)(node);
      };
      var _generated = __webpack_require__(4746), _isLet = __webpack_require__(7182);
    },
    9268: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        if ((0, _isType.default)(node.type, "Immutable")) return !0;
        if ((0, _generated.isIdentifier)(node)) return "undefined" === node.name;
        return !1;
      };
      var _isType = __webpack_require__(1452), _generated = __webpack_require__(4746);
    },
    7182: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _generated.isVariableDeclaration)(node) && ("var" !== node.kind || node[_constants.BLOCK_SCOPED_SYMBOL]);
      };
      var _generated = __webpack_require__(4746), _constants = __webpack_require__(6325);
    },
    8523: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return !(!node || !_definitions.VISITOR_KEYS[node.type]);
      };
      var _definitions = __webpack_require__(6507);
    },
    4635: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function isNodesEquivalent(a, b) {
        if ("object" != typeof a || "object" != typeof b || null == a || null == b) return a === b;
        if (a.type !== b.type) return !1;
        const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type), visitorKeys = _definitions.VISITOR_KEYS[a.type];
        for (const field of fields) {
          if (typeof a[field] != typeof b[field]) return !1;
          if (null != a[field] || null != b[field]) {
            if (null == a[field] || null == b[field]) return !1;
            if (Array.isArray(a[field])) {
              if (!Array.isArray(b[field])) return !1;
              if (a[field].length !== b[field].length) return !1;
              for (let i = 0; i < a[field].length; i++) if (!isNodesEquivalent(a[field][i], b[field][i])) return !1;
            } else if ("object" != typeof a[field] || null != visitorKeys && visitorKeys.includes(field)) {
              if (!isNodesEquivalent(a[field], b[field])) return !1;
            } else for (const key of Object.keys(a[field])) if (a[field][key] !== b[field][key]) return !1;
          }
        }
        return !0;
      };
      var _definitions = __webpack_require__(6507);
    },
    15: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(placeholderType, targetType) {
        if (placeholderType === targetType) return !0;
        const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
        if (aliases) for (const alias of aliases) if (targetType === alias) return !0;
        return !1;
      };
      var _definitions = __webpack_require__(6507);
    },
    4837: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, parent, grandparent) {
        switch (parent.type) {
         case "MemberExpression":
         case "OptionalMemberExpression":
          return parent.property === node ? !!parent.computed : parent.object === node;

         case "JSXMemberExpression":
          return parent.object === node;

         case "VariableDeclarator":
          return parent.init === node;

         case "ArrowFunctionExpression":
          return parent.body === node;

         case "PrivateName":
         case "LabeledStatement":
         case "CatchClause":
         case "RestElement":
         case "BreakStatement":
         case "ContinueStatement":
         case "FunctionDeclaration":
         case "FunctionExpression":
         case "ExportNamespaceSpecifier":
         case "ExportDefaultSpecifier":
         case "ImportDefaultSpecifier":
         case "ImportNamespaceSpecifier":
         case "ImportSpecifier":
         case "ImportAttribute":
         case "JSXAttribute":
         case "ObjectPattern":
         case "ArrayPattern":
         case "MetaProperty":
          return !1;

         case "ClassMethod":
         case "ClassPrivateMethod":
         case "ObjectMethod":
          return parent.key === node && !!parent.computed;

         case "ObjectProperty":
          return parent.key === node ? !!parent.computed : !grandparent || "ObjectPattern" !== grandparent.type;

         case "ClassProperty":
         case "ClassAccessorProperty":
         case "TSPropertySignature":
          return parent.key !== node || !!parent.computed;

         case "ClassPrivateProperty":
         case "ObjectTypeProperty":
          return parent.key !== node;

         case "ClassDeclaration":
         case "ClassExpression":
          return parent.superClass === node;

         case "AssignmentExpression":
         case "AssignmentPattern":
          return parent.right === node;

         case "ExportSpecifier":
          return (null == grandparent || !grandparent.source) && parent.local === node;

         case "TSEnumMember":
          return parent.id !== node;
        }
        return !0;
      };
    },
    6400: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, parent) {
        if ((0, _generated.isBlockStatement)(node) && ((0, _generated.isFunction)(parent) || (0, 
        _generated.isCatchClause)(parent))) return !1;
        if ((0, _generated.isPattern)(node) && ((0, _generated.isFunction)(parent) || (0, 
        _generated.isCatchClause)(parent))) return !0;
        return (0, _generated.isScopable)(node);
      };
      var _generated = __webpack_require__(4746);
    },
    2800: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(specifier) {
        return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
          name: "default"
        });
      };
      var _generated = __webpack_require__(4746);
    },
    1452: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(nodeType, targetType) {
        if (nodeType === targetType) return !0;
        if (_definitions.ALIAS_KEYS[targetType]) return !1;
        const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
        if (aliases) {
          if (aliases[0] === nodeType) return !0;
          for (const alias of aliases) if (nodeType === alias) return !0;
        }
        return !1;
      };
      var _definitions = __webpack_require__(6507);
    },
    8917: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(name) {
        return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
      };
      var _isValidIdentifier = __webpack_require__(3045);
      const RESERVED_WORDS_ES3_ONLY = new Set([ "abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile" ]);
    },
    3045: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(name, reserved = !0) {
        if ("string" != typeof name) return !1;
        if (reserved && ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, !0))) return !1;
        return (0, _helperValidatorIdentifier.isIdentifierName)(name);
      };
      var _helperValidatorIdentifier = __webpack_require__(720);
    },
    830: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node) {
        return (0, _generated.isVariableDeclaration)(node, {
          kind: "var"
        }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
      };
      var _generated = __webpack_require__(4746), _constants = __webpack_require__(6325);
    },
    2205: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(member, match, allowPartial) {
        if (!(0, _generated.isMemberExpression)(member)) return !1;
        const parts = Array.isArray(match) ? match : match.split("."), nodes = [];
        let node;
        for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) nodes.push(node.property);
        if (nodes.push(node), nodes.length < parts.length) return !1;
        if (!allowPartial && nodes.length > parts.length) return !1;
        for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
          const node = nodes[j];
          let value;
          if ((0, _generated.isIdentifier)(node)) value = node.name; else if ((0, _generated.isStringLiteral)(node)) value = node.value; else {
            if (!(0, _generated.isThisExpression)(node)) return !1;
            value = "this";
          }
          if (parts[i] !== value) return !1;
        }
        return !0;
      };
      var _generated = __webpack_require__(4746);
    },
    3193: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(tagName) {
        return !!tagName && /^[a-z]/.test(tagName);
      };
    },
    6035: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = void 0;
      var _default = (0, __webpack_require__(8847).default)("React.Component");
      exports.default = _default;
    },
    3804: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = function(node, key, val) {
        if (!node) return;
        const fields = _definitions.NODE_FIELDS[node.type];
        if (!fields) return;
        const field = fields[key];
        validateField(node, key, val, field), validateChild(node, key, val);
      }, exports.validateChild = validateChild, exports.validateField = validateField;
      var _definitions = __webpack_require__(6507);
      function validateField(node, key, val, field) {
        null != field && field.validate && (field.optional && null == val || field.validate(node, key, val));
      }
      function validateChild(node, key, val) {
        if (null == val) return;
        const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
        validate && validate(node, key, val);
      }
    },
    2509: function(__unused_webpack_module, exports, __webpack_require__) {
      !function(exports, setArray, sourcemapCodec) {
        "use strict";
        exports.addSegment = void 0, exports.addMapping = void 0, exports.setSourceContent = void 0, 
        exports.decodedMap = void 0, exports.encodedMap = void 0, exports.allMappings = void 0;
        class GenMapping {
          constructor({file, sourceRoot} = {}) {
            this._names = new setArray.SetArray, this._sources = new setArray.SetArray, this._sourcesContent = [], 
            this._mappings = [], this.file = file, this.sourceRoot = sourceRoot;
          }
        }
        function getLine(mappings, index) {
          for (let i = mappings.length; i <= index; i++) mappings[i] = [];
          return mappings[index];
        }
        function getColumnIndex(line, column, seg) {
          let index = line.length;
          for (let i = index - 1; i >= 0; i--, index--) {
            const current = line[i], col = current[0];
            if (col > column) continue;
            if (col < column) break;
            const cmp = compare(current, seg);
            if (0 === cmp) return index;
            if (cmp < 0) break;
          }
          return index;
        }
        function compare(a, b) {
          let cmp = compareNum(a.length, b.length);
          return 0 !== cmp ? cmp : 1 === a.length ? 0 : (cmp = compareNum(a[1], b[1]), 0 !== cmp ? cmp : (cmp = compareNum(a[2], b[2]), 
          0 !== cmp ? cmp : (cmp = compareNum(a[3], b[3]), 0 !== cmp ? cmp : 4 === a.length ? 0 : compareNum(a[4], b[4]))));
        }
        function compareNum(a, b) {
          return a - b;
        }
        function insert(array, index, value) {
          if (-1 !== index) {
            for (let i = array.length; i > index; i--) array[i] = array[i - 1];
            array[index] = value;
          }
        }
        exports.addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {
          const {_mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names} = map, line = getLine(mappings, genLine);
          if (null == source) {
            const seg = [ genColumn ];
            return insert(line, getColumnIndex(line, genColumn, seg), seg);
          }
          const sourcesIndex = setArray.put(sources, source), seg = name ? [ genColumn, sourcesIndex, sourceLine, sourceColumn, setArray.put(names, name) ] : [ genColumn, sourcesIndex, sourceLine, sourceColumn ], index = getColumnIndex(line, genColumn, seg);
          sourcesIndex === sourcesContent.length && (sourcesContent[sourcesIndex] = null), 
          insert(line, index, seg);
        }, exports.addMapping = (map, mapping) => {
          const {generated, source, original, name} = mapping;
          return exports.addSegment(map, generated.line - 1, generated.column, source, null == original ? void 0 : original.line - 1, null == original ? void 0 : original.column, name);
        }, exports.setSourceContent = (map, source, content) => {
          const {_sources: sources, _sourcesContent: sourcesContent} = map;
          sourcesContent[setArray.put(sources, source)] = content;
        }, exports.decodedMap = map => {
          const {file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names} = map;
          return {
            version: 3,
            file,
            names: names.array,
            sourceRoot: sourceRoot || void 0,
            sources: sources.array,
            sourcesContent,
            mappings
          };
        }, exports.encodedMap = map => {
          const decoded = exports.decodedMap(map);
          return Object.assign(Object.assign({}, decoded), {
            mappings: sourcemapCodec.encode(decoded.mappings)
          });
        }, exports.allMappings = map => {
          const out = [], {_mappings: mappings, _sources: sources, _names: names} = map;
          for (let i = 0; i < mappings.length; i++) {
            const line = mappings[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j], generated = {
                line: i + 1,
                column: seg[0]
              };
              let source, original, name;
              1 !== seg.length && (source = sources.array[seg[1]], original = {
                line: seg[2] + 1,
                column: seg[3]
              }, 5 === seg.length && (name = names.array[seg[4]])), out.push({
                generated,
                source,
                original,
                name
              });
            }
          }
          return out;
        }, exports.GenMapping = GenMapping, Object.defineProperty(exports, "__esModule", {
          value: !0
        });
      }(exports, __webpack_require__(2208), __webpack_require__(2297));
    },
    2208: function(__unused_webpack_module, exports) {
      !function(exports) {
        "use strict";
        exports.get = void 0, exports.put = void 0, exports.pop = void 0;
        class SetArray {
          constructor() {
            this._indexes = {
              __proto__: null
            }, this.array = [];
          }
        }
        exports.get = (strarr, key) => strarr._indexes[key], exports.put = (strarr, key) => {
          const index = exports.get(strarr, key);
          if (void 0 !== index) return index;
          const {array, _indexes: indexes} = strarr;
          return indexes[key] = array.push(key) - 1;
        }, exports.pop = strarr => {
          const {array, _indexes: indexes} = strarr;
          0 !== array.length && (indexes[array.pop()] = void 0);
        }, exports.SetArray = SetArray, Object.defineProperty(exports, "__esModule", {
          value: !0
        });
      }(exports);
    },
    2297: function(__unused_webpack_module, exports) {
      !function(exports) {
        "use strict";
        const comma = ",".charCodeAt(0), semicolon = ";".charCodeAt(0), chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);
        for (let i = 0; i < chars.length; i++) {
          const c = chars.charCodeAt(i);
          intToChar[i] = c, charToInt[c] = i;
        }
        const td = "undefined" != typeof TextDecoder ? new TextDecoder : "undefined" != typeof Buffer ? {
          decode: buf => Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString()
        } : {
          decode(buf) {
            let out = "";
            for (let i = 0; i < buf.length; i++) out += String.fromCharCode(buf[i]);
            return out;
          }
        };
        function decode(mappings) {
          const state = new Int32Array(5), decoded = [];
          let index = 0;
          do {
            const semi = indexOf(mappings, index), line = [];
            let sorted = !0, lastCol = 0;
            state[0] = 0;
            for (let i = index; i < semi; i++) {
              let seg;
              i = decodeInteger(mappings, i, state, 0);
              const col = state[0];
              col < lastCol && (sorted = !1), lastCol = col, hasMoreVlq(mappings, i, semi) ? (i = decodeInteger(mappings, i, state, 1), 
              i = decodeInteger(mappings, i, state, 2), i = decodeInteger(mappings, i, state, 3), 
              hasMoreVlq(mappings, i, semi) ? (i = decodeInteger(mappings, i, state, 4), seg = [ col, state[1], state[2], state[3], state[4] ]) : seg = [ col, state[1], state[2], state[3] ]) : seg = [ col ], 
              line.push(seg);
            }
            sorted || sort(line), decoded.push(line), index = semi + 1;
          } while (index <= mappings.length);
          return decoded;
        }
        function indexOf(mappings, index) {
          const idx = mappings.indexOf(";", index);
          return -1 === idx ? mappings.length : idx;
        }
        function decodeInteger(mappings, pos, state, j) {
          let value = 0, shift = 0, integer = 0;
          do {
            const c = mappings.charCodeAt(pos++);
            integer = charToInt[c], value |= (31 & integer) << shift, shift += 5;
          } while (32 & integer);
          const shouldNegate = 1 & value;
          return value >>>= 1, shouldNegate && (value = -2147483648 | -value), state[j] += value, 
          pos;
        }
        function hasMoreVlq(mappings, i, length) {
          return !(i >= length) && mappings.charCodeAt(i) !== comma;
        }
        function sort(line) {
          line.sort(sortComparator);
        }
        function sortComparator(a, b) {
          return a[0] - b[0];
        }
        function encode(decoded) {
          const state = new Int32Array(5), bufLength = 16384, subLength = bufLength - 36, buf = new Uint8Array(bufLength), sub = buf.subarray(0, subLength);
          let pos = 0, out = "";
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            if (i > 0 && (pos === bufLength && (out += td.decode(buf), pos = 0), buf[pos++] = semicolon), 
            0 !== line.length) {
              state[0] = 0;
              for (let j = 0; j < line.length; j++) {
                const segment = line[j];
                pos > subLength && (out += td.decode(sub), buf.copyWithin(0, subLength, pos), pos -= subLength), 
                j > 0 && (buf[pos++] = comma), pos = encodeInteger(buf, pos, state, segment, 0), 
                1 !== segment.length && (pos = encodeInteger(buf, pos, state, segment, 1), pos = encodeInteger(buf, pos, state, segment, 2), 
                pos = encodeInteger(buf, pos, state, segment, 3), 4 !== segment.length && (pos = encodeInteger(buf, pos, state, segment, 4)));
              }
            }
          }
          return out + td.decode(buf.subarray(0, pos));
        }
        function encodeInteger(buf, pos, state, segment, j) {
          const next = segment[j];
          let num = next - state[j];
          state[j] = next, num = num < 0 ? -num << 1 | 1 : num << 1;
          do {
            let clamped = 31 & num;
            num >>>= 5, num > 0 && (clamped |= 32), buf[pos++] = intToChar[clamped];
          } while (num > 0);
          return pos;
        }
        exports.decode = decode, exports.encode = encode, Object.defineProperty(exports, "__esModule", {
          value: !0
        });
      }(exports);
    },
    7449: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: !0
      });
      var _slicedToArray = function(arr, i) {
        if (Array.isArray(arr)) return arr;
        if (Symbol.iterator in Object(arr)) return function(arr, i) {
          var _arr = [], _n = !0, _d = !1, _e = void 0;
          try {
            for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
            !i || _arr.length !== i); _n = !0) ;
          } catch (err) {
            _d = !0, _e = err;
          } finally {
            try {
              !_n && _i.return && _i.return();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }(arr, i);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
      function getImportSource(t, callNode) {
        var importArguments = callNode.arguments, importPath = _slicedToArray(importArguments, 1)[0];
        return t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath) ? (t.removeComments(importPath), 
        importPath) : t.templateLiteral([ t.templateElement({
          raw: "",
          cooked: ""
        }), t.templateElement({
          raw: "",
          cooked: ""
        }, !0) ], importArguments);
      }
      exports.getImportSource = getImportSource, exports.createDynamicImportTransform = function(_ref) {
        var template = _ref.template, t = _ref.types, builders = {
          static: {
            interop: template("Promise.resolve().then(() => INTEROP(require(SOURCE)))"),
            noInterop: template("Promise.resolve().then(() => require(SOURCE))")
          },
          dynamic: {
            interop: template("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"),
            noInterop: template("Promise.resolve(SOURCE).then(s => require(s))")
          }
        }, visited = "function" == typeof WeakSet && new WeakSet;
        return function(context, path) {
          if (visited) {
            if (visited.has(path)) return;
            visited.add(path);
          }
          var node, SOURCE = getImportSource(t, path.parent), builder = (node = SOURCE, t.isStringLiteral(node) || t.isTemplateLiteral(node) && 0 === node.expressions.length ? builders.static : builders.dynamic), newImport = context.opts.noInterop ? builder.noInterop({
            SOURCE
          }) : builder.interop({
            SOURCE,
            INTEROP: context.addHelper("interopRequireWildcard")
          });
          path.parentPath.replaceWith(newImport);
        };
      };
    },
    6113: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(7449);
    },
    9869: (__unused_webpack_module, exports) => {
      "use strict";
      function _extends() {
        return _extends = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
          return target;
        }, _extends.apply(this, arguments);
      }
      exports.__esModule = !0, exports.default = function(targets, method, polyfills) {
        const targetNames = Object.keys(targets), isAnyTarget = !targetNames.length, isWebTarget = targetNames.some((name => "node" !== name));
        return _extends({}, polyfills, "usage-pure" === method ? purePolyfills : null, isAnyTarget || isWebTarget ? webPolyfills : null);
      };
      const webPolyfills = {
        "web.timers": {},
        "web.immediate": {},
        "web.dom.iterable": {}
      }, purePolyfills = {
        "es6.parse-float": {},
        "es6.parse-int": {},
        "es7.string.at": {}
      };
    },
    9479: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.StaticProperties = exports.InstanceProperties = exports.BuiltIns = exports.CommonIterators = void 0;
      var obj, _corejs2BuiltIns = (obj = __webpack_require__(9797)) && obj.__esModule ? obj : {
        default: obj
      };
      const define = (name, pure, global = [], meta) => ({
        name,
        pure,
        global,
        meta
      }), pureAndGlobal = (pure, global, minRuntimeVersion = null) => define(global[0], pure, global, {
        minRuntimeVersion
      }), globalOnly = global => define(global[0], null, global), pureOnly = (pure, name) => define(name, pure, []), ArrayNatureIterators = [ "es6.object.to-string", "es6.array.iterator", "web.dom.iterable" ], CommonIterators = [ "es6.string.iterator", ...ArrayNatureIterators ];
      exports.CommonIterators = CommonIterators;
      const PromiseDependencies = [ "es6.object.to-string", "es6.promise" ], BuiltIns = {
        DataView: globalOnly([ "es6.typed.data-view" ]),
        Float32Array: globalOnly([ "es6.typed.float32-array" ]),
        Float64Array: globalOnly([ "es6.typed.float64-array" ]),
        Int8Array: globalOnly([ "es6.typed.int8-array" ]),
        Int16Array: globalOnly([ "es6.typed.int16-array" ]),
        Int32Array: globalOnly([ "es6.typed.int32-array" ]),
        Map: pureAndGlobal("map", [ "es6.map", ...CommonIterators ]),
        Number: globalOnly([ "es6.number.constructor" ]),
        Promise: pureAndGlobal("promise", PromiseDependencies),
        RegExp: globalOnly([ "es6.regexp.constructor" ]),
        Set: pureAndGlobal("set", [ "es6.set", ...CommonIterators ]),
        Symbol: pureAndGlobal("symbol", [ "es6.symbol" ]),
        Uint8Array: globalOnly([ "es6.typed.uint8-array" ]),
        Uint8ClampedArray: globalOnly([ "es6.typed.uint8-clamped-array" ]),
        Uint16Array: globalOnly([ "es6.typed.uint16-array" ]),
        Uint32Array: globalOnly([ "es6.typed.uint32-array" ]),
        WeakMap: pureAndGlobal("weak-map", [ "es6.weak-map", ...CommonIterators ]),
        WeakSet: pureAndGlobal("weak-set", [ "es6.weak-set", ...CommonIterators ]),
        setImmediate: pureOnly("set-immediate", "web.immediate"),
        clearImmediate: pureOnly("clear-immediate", "web.immediate"),
        parseFloat: pureOnly("parse-float", "es6.parse-float"),
        parseInt: pureOnly("parse-int", "es6.parse-int")
      };
      exports.BuiltIns = BuiltIns;
      const InstanceProperties = {
        __defineGetter__: globalOnly([ "es7.object.define-getter" ]),
        __defineSetter__: globalOnly([ "es7.object.define-setter" ]),
        __lookupGetter__: globalOnly([ "es7.object.lookup-getter" ]),
        __lookupSetter__: globalOnly([ "es7.object.lookup-setter" ]),
        anchor: globalOnly([ "es6.string.anchor" ]),
        big: globalOnly([ "es6.string.big" ]),
        bind: globalOnly([ "es6.function.bind" ]),
        blink: globalOnly([ "es6.string.blink" ]),
        bold: globalOnly([ "es6.string.bold" ]),
        codePointAt: globalOnly([ "es6.string.code-point-at" ]),
        copyWithin: globalOnly([ "es6.array.copy-within" ]),
        endsWith: globalOnly([ "es6.string.ends-with" ]),
        entries: globalOnly(ArrayNatureIterators),
        every: globalOnly([ "es6.array.every" ]),
        fill: globalOnly([ "es6.array.fill" ]),
        filter: globalOnly([ "es6.array.filter" ]),
        finally: globalOnly([ "es7.promise.finally", ...PromiseDependencies ]),
        find: globalOnly([ "es6.array.find" ]),
        findIndex: globalOnly([ "es6.array.find-index" ]),
        fixed: globalOnly([ "es6.string.fixed" ]),
        flags: globalOnly([ "es6.regexp.flags" ]),
        flatMap: globalOnly([ "es7.array.flat-map" ]),
        fontcolor: globalOnly([ "es6.string.fontcolor" ]),
        fontsize: globalOnly([ "es6.string.fontsize" ]),
        forEach: globalOnly([ "es6.array.for-each" ]),
        includes: globalOnly([ "es6.string.includes", "es7.array.includes" ]),
        indexOf: globalOnly([ "es6.array.index-of" ]),
        italics: globalOnly([ "es6.string.italics" ]),
        keys: globalOnly(ArrayNatureIterators),
        lastIndexOf: globalOnly([ "es6.array.last-index-of" ]),
        link: globalOnly([ "es6.string.link" ]),
        map: globalOnly([ "es6.array.map" ]),
        match: globalOnly([ "es6.regexp.match" ]),
        name: globalOnly([ "es6.function.name" ]),
        padStart: globalOnly([ "es7.string.pad-start" ]),
        padEnd: globalOnly([ "es7.string.pad-end" ]),
        reduce: globalOnly([ "es6.array.reduce" ]),
        reduceRight: globalOnly([ "es6.array.reduce-right" ]),
        repeat: globalOnly([ "es6.string.repeat" ]),
        replace: globalOnly([ "es6.regexp.replace" ]),
        search: globalOnly([ "es6.regexp.search" ]),
        small: globalOnly([ "es6.string.small" ]),
        some: globalOnly([ "es6.array.some" ]),
        sort: globalOnly([ "es6.array.sort" ]),
        split: globalOnly([ "es6.regexp.split" ]),
        startsWith: globalOnly([ "es6.string.starts-with" ]),
        strike: globalOnly([ "es6.string.strike" ]),
        sub: globalOnly([ "es6.string.sub" ]),
        sup: globalOnly([ "es6.string.sup" ]),
        toISOString: globalOnly([ "es6.date.to-iso-string" ]),
        toJSON: globalOnly([ "es6.date.to-json" ]),
        toString: globalOnly([ "es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string" ]),
        trim: globalOnly([ "es6.string.trim" ]),
        trimEnd: globalOnly([ "es7.string.trim-right" ]),
        trimLeft: globalOnly([ "es7.string.trim-left" ]),
        trimRight: globalOnly([ "es7.string.trim-right" ]),
        trimStart: globalOnly([ "es7.string.trim-left" ]),
        values: globalOnly(ArrayNatureIterators)
      };
      exports.InstanceProperties = InstanceProperties, "es6.array.slice" in _corejs2BuiltIns.default && (InstanceProperties.slice = globalOnly([ "es6.array.slice" ]));
      const StaticProperties = {
        Array: {
          from: pureAndGlobal("array/from", [ "es6.symbol", "es6.array.from", ...CommonIterators ]),
          isArray: pureAndGlobal("array/is-array", [ "es6.array.is-array" ]),
          of: pureAndGlobal("array/of", [ "es6.array.of" ])
        },
        Date: {
          now: pureAndGlobal("date/now", [ "es6.date.now" ])
        },
        JSON: {
          stringify: pureOnly("json/stringify", "es6.symbol")
        },
        Math: {
          acosh: pureAndGlobal("math/acosh", [ "es6.math.acosh" ], "7.0.1"),
          asinh: pureAndGlobal("math/asinh", [ "es6.math.asinh" ], "7.0.1"),
          atanh: pureAndGlobal("math/atanh", [ "es6.math.atanh" ], "7.0.1"),
          cbrt: pureAndGlobal("math/cbrt", [ "es6.math.cbrt" ], "7.0.1"),
          clz32: pureAndGlobal("math/clz32", [ "es6.math.clz32" ], "7.0.1"),
          cosh: pureAndGlobal("math/cosh", [ "es6.math.cosh" ], "7.0.1"),
          expm1: pureAndGlobal("math/expm1", [ "es6.math.expm1" ], "7.0.1"),
          fround: pureAndGlobal("math/fround", [ "es6.math.fround" ], "7.0.1"),
          hypot: pureAndGlobal("math/hypot", [ "es6.math.hypot" ], "7.0.1"),
          imul: pureAndGlobal("math/imul", [ "es6.math.imul" ], "7.0.1"),
          log1p: pureAndGlobal("math/log1p", [ "es6.math.log1p" ], "7.0.1"),
          log10: pureAndGlobal("math/log10", [ "es6.math.log10" ], "7.0.1"),
          log2: pureAndGlobal("math/log2", [ "es6.math.log2" ], "7.0.1"),
          sign: pureAndGlobal("math/sign", [ "es6.math.sign" ], "7.0.1"),
          sinh: pureAndGlobal("math/sinh", [ "es6.math.sinh" ], "7.0.1"),
          tanh: pureAndGlobal("math/tanh", [ "es6.math.tanh" ], "7.0.1"),
          trunc: pureAndGlobal("math/trunc", [ "es6.math.trunc" ], "7.0.1")
        },
        Number: {
          EPSILON: pureAndGlobal("number/epsilon", [ "es6.number.epsilon" ]),
          MIN_SAFE_INTEGER: pureAndGlobal("number/min-safe-integer", [ "es6.number.min-safe-integer" ]),
          MAX_SAFE_INTEGER: pureAndGlobal("number/max-safe-integer", [ "es6.number.max-safe-integer" ]),
          isFinite: pureAndGlobal("number/is-finite", [ "es6.number.is-finite" ]),
          isInteger: pureAndGlobal("number/is-integer", [ "es6.number.is-integer" ]),
          isSafeInteger: pureAndGlobal("number/is-safe-integer", [ "es6.number.is-safe-integer" ]),
          isNaN: pureAndGlobal("number/is-nan", [ "es6.number.is-nan" ]),
          parseFloat: pureAndGlobal("number/parse-float", [ "es6.number.parse-float" ]),
          parseInt: pureAndGlobal("number/parse-int", [ "es6.number.parse-int" ])
        },
        Object: {
          assign: pureAndGlobal("object/assign", [ "es6.object.assign" ]),
          create: pureAndGlobal("object/create", [ "es6.object.create" ]),
          defineProperties: pureAndGlobal("object/define-properties", [ "es6.object.define-properties" ]),
          defineProperty: pureAndGlobal("object/define-property", [ "es6.object.define-property" ]),
          entries: pureAndGlobal("object/entries", [ "es7.object.entries" ]),
          freeze: pureAndGlobal("object/freeze", [ "es6.object.freeze" ]),
          getOwnPropertyDescriptor: pureAndGlobal("object/get-own-property-descriptor", [ "es6.object.get-own-property-descriptor" ]),
          getOwnPropertyDescriptors: pureAndGlobal("object/get-own-property-descriptors", [ "es7.object.get-own-property-descriptors" ]),
          getOwnPropertyNames: pureAndGlobal("object/get-own-property-names", [ "es6.object.get-own-property-names" ]),
          getOwnPropertySymbols: pureAndGlobal("object/get-own-property-symbols", [ "es6.symbol" ]),
          getPrototypeOf: pureAndGlobal("object/get-prototype-of", [ "es6.object.get-prototype-of" ]),
          is: pureAndGlobal("object/is", [ "es6.object.is" ]),
          isExtensible: pureAndGlobal("object/is-extensible", [ "es6.object.is-extensible" ]),
          isFrozen: pureAndGlobal("object/is-frozen", [ "es6.object.is-frozen" ]),
          isSealed: pureAndGlobal("object/is-sealed", [ "es6.object.is-sealed" ]),
          keys: pureAndGlobal("object/keys", [ "es6.object.keys" ]),
          preventExtensions: pureAndGlobal("object/prevent-extensions", [ "es6.object.prevent-extensions" ]),
          seal: pureAndGlobal("object/seal", [ "es6.object.seal" ]),
          setPrototypeOf: pureAndGlobal("object/set-prototype-of", [ "es6.object.set-prototype-of" ]),
          values: pureAndGlobal("object/values", [ "es7.object.values" ])
        },
        Promise: {
          all: globalOnly(CommonIterators),
          race: globalOnly(CommonIterators)
        },
        Reflect: {
          apply: pureAndGlobal("reflect/apply", [ "es6.reflect.apply" ]),
          construct: pureAndGlobal("reflect/construct", [ "es6.reflect.construct" ]),
          defineProperty: pureAndGlobal("reflect/define-property", [ "es6.reflect.define-property" ]),
          deleteProperty: pureAndGlobal("reflect/delete-property", [ "es6.reflect.delete-property" ]),
          get: pureAndGlobal("reflect/get", [ "es6.reflect.get" ]),
          getOwnPropertyDescriptor: pureAndGlobal("reflect/get-own-property-descriptor", [ "es6.reflect.get-own-property-descriptor" ]),
          getPrototypeOf: pureAndGlobal("reflect/get-prototype-of", [ "es6.reflect.get-prototype-of" ]),
          has: pureAndGlobal("reflect/has", [ "es6.reflect.has" ]),
          isExtensible: pureAndGlobal("reflect/is-extensible", [ "es6.reflect.is-extensible" ]),
          ownKeys: pureAndGlobal("reflect/own-keys", [ "es6.reflect.own-keys" ]),
          preventExtensions: pureAndGlobal("reflect/prevent-extensions", [ "es6.reflect.prevent-extensions" ]),
          set: pureAndGlobal("reflect/set", [ "es6.reflect.set" ]),
          setPrototypeOf: pureAndGlobal("reflect/set-prototype-of", [ "es6.reflect.set-prototype-of" ])
        },
        String: {
          at: pureOnly("string/at", "es7.string.at"),
          fromCodePoint: pureAndGlobal("string/from-code-point", [ "es6.string.from-code-point" ]),
          raw: pureAndGlobal("string/raw", [ "es6.string.raw" ])
        },
        Symbol: {
          asyncIterator: globalOnly([ "es6.symbol", "es7.symbol.async-iterator" ]),
          for: pureOnly("symbol/for", "es6.symbol"),
          hasInstance: pureOnly("symbol/has-instance", "es6.symbol"),
          isConcatSpreadable: pureOnly("symbol/is-concat-spreadable", "es6.symbol"),
          iterator: define("es6.symbol", "symbol/iterator", CommonIterators),
          keyFor: pureOnly("symbol/key-for", "es6.symbol"),
          match: pureAndGlobal("symbol/match", [ "es6.regexp.match" ]),
          replace: pureOnly("symbol/replace", "es6.symbol"),
          search: pureOnly("symbol/search", "es6.symbol"),
          species: pureOnly("symbol/species", "es6.symbol"),
          split: pureOnly("symbol/split", "es6.symbol"),
          toPrimitive: pureOnly("symbol/to-primitive", "es6.symbol"),
          toStringTag: pureOnly("symbol/to-string-tag", "es6.symbol"),
          unscopables: pureOnly("symbol/unscopables", "es6.symbol")
        }
      };
      exports.StaticProperties = StaticProperties;
    },
    6740: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.hasMinVersion = function(minVersion, runtimeVersion) {
        if (!runtimeVersion || !minVersion) return !0;
        _semver.default.valid(runtimeVersion) && (runtimeVersion = `^${runtimeVersion}`);
        return !_semver.default.intersects(`<${minVersion}`, runtimeVersion) && !_semver.default.intersects(">=8.0.0", runtimeVersion);
      };
      var obj, _semver = (obj = __webpack_require__(6625)) && obj.__esModule ? obj : {
        default: obj
      };
    },
    1815: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _corejs2BuiltIns = _interopRequireDefault(__webpack_require__(9797)), _builtInDefinitions = __webpack_require__(9479), _addPlatformSpecificPolyfills = _interopRequireDefault(__webpack_require__(9869)), _helpers = __webpack_require__(6740), _helperDefinePolyfillProvider = _interopRequireDefault(__webpack_require__(9695)), babel = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4629));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      const {types: t} = babel.default || babel, has = Function.call.bind(Object.hasOwnProperty);
      var _default = (0, _helperDefinePolyfillProvider.default)((function(api, {"#__secret_key__@babel/preset-env__compatibility": {entryInjectRegenerator} = {}, "#__secret_key__@babel/runtime__compatibility": {useBabelRuntime, runtimeVersion, ext = ".js"} = {}}) {
        const resolve = api.createMetaResolver({
          global: _builtInDefinitions.BuiltIns,
          static: _builtInDefinitions.StaticProperties,
          instance: _builtInDefinitions.InstanceProperties
        }), {debug, shouldInjectPolyfill, method} = api, polyfills = (0, _addPlatformSpecificPolyfills.default)(api.targets, method, _corejs2BuiltIns.default), coreJSBase = useBabelRuntime ? `${useBabelRuntime}/core-js` : "usage-pure" === method ? "core-js/library/fn" : "core-js/modules";
        function inject(name, utils) {
          "string" != typeof name ? name.forEach((name => inject(name, utils))) : has(polyfills, name) && shouldInjectPolyfill(name) && (debug(name), 
          utils.injectGlobalImport(`${coreJSBase}/${name}.js`));
        }
        return {
          name: "corejs2",
          polyfills,
          entryGlobal(meta, utils, path) {
            "import" === meta.kind && "core-js" === meta.source && (debug(null), inject(Object.keys(polyfills), utils), 
            entryInjectRegenerator && utils.injectGlobalImport("regenerator-runtime/runtime.js"), 
            path.remove());
          },
          usageGlobal(meta, utils) {
            const resolved = resolve(meta);
            if (!resolved) return;
            let deps = resolved.desc.global;
            if ("global" !== resolved.kind && meta.object && "prototype" === meta.placement) {
              const low = meta.object.toLowerCase();
              deps = deps.filter((m => m.includes(low)));
            }
            inject(deps, utils);
          },
          usagePure(meta, utils, path) {
            if ("in" === meta.kind) return void ("Symbol.iterator" === meta.key && path.replaceWith(t.callExpression(utils.injectDefaultImport(`${coreJSBase}/is-iterable${ext}`, "isIterable"), [ path.node.right ])));
            if (path.parentPath.isUnaryExpression({
              operator: "delete"
            })) return;
            if ("property" === meta.kind) {
              if (!path.isMemberExpression()) return;
              if (!path.isReferenced()) return;
              if ("Symbol.iterator" === meta.key && shouldInjectPolyfill("es6.symbol") && path.parentPath.isCallExpression({
                callee: path.node
              }) && 0 === path.parent.arguments.length) return path.parentPath.replaceWith(t.callExpression(utils.injectDefaultImport(`${coreJSBase}/get-iterator${ext}`, "getIterator"), [ path.node.object ])), 
              void path.skip();
            }
            const resolved = resolve(meta);
            if (!resolved) return;
            const id = function(desc, hint, utils) {
              const {pure, meta, name} = desc;
              if (pure && shouldInjectPolyfill(name) && (!(runtimeVersion && meta && meta.minRuntimeVersion) || (0, 
              _helpers.hasMinVersion)(meta && meta.minRuntimeVersion, runtimeVersion))) return utils.injectDefaultImport(`${coreJSBase}/${pure}${ext}`, hint);
            }(resolved.desc, resolved.name, utils);
            id && path.replaceWith(id);
          },
          visitor: "usage-global" === method && {
            YieldExpression(path) {
              path.node.delegate && inject("web.dom.iterable", api.getUtils(path));
            },
            "ForOfStatement|ArrayPattern"(path) {
              _builtInDefinitions.CommonIterators.forEach((name => inject(name, api.getUtils(path))));
            }
          }
        };
      }));
      exports.default = _default;
    },
    7026: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(6578);
    },
    2729: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(4881);
    },
    6864: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = __webpack_require__(3082);
    },
    9930: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.CommonInstanceDependencies = exports.InstanceProperties = exports.StaticProperties = exports.BuiltIns = exports.PromiseDependenciesWithIterators = exports.PromiseDependencies = exports.CommonIterators = void 0;
      var obj, _data = (obj = __webpack_require__(7026)) && obj.__esModule ? obj : {
        default: obj
      };
      const polyfillsOrder = {};
      Object.keys(_data.default).forEach(((name, index) => {
        polyfillsOrder[name] = index;
      }));
      const define = (pure, global, name = global[0], exclude) => ({
        name,
        pure,
        global: global.sort(((a, b) => polyfillsOrder[a] - polyfillsOrder[b])),
        exclude
      }), typed = name => define(null, [ name, ...TypedArrayDependencies ]), ArrayNatureIterators = [ "es.array.iterator", "web.dom-collections.iterator" ], CommonIterators = [ "es.string.iterator", ...ArrayNatureIterators ];
      exports.CommonIterators = CommonIterators;
      const ArrayNatureIteratorsWithTag = [ "es.object.to-string", ...ArrayNatureIterators ], CommonIteratorsWithTag = [ "es.object.to-string", ...CommonIterators ], ErrorDependencies = [ "es.error.cause", "es.error.to-string" ], TypedArrayDependencies = [ "es.typed-array.at", "es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice", "esnext.typed-array.filter-reject", "esnext.typed-array.find-last", "esnext.typed-array.find-last-index", "esnext.typed-array.group-by", "esnext.typed-array.to-reversed", "esnext.typed-array.to-sorted", "esnext.typed-array.to-spliced", "esnext.typed-array.unique-by", "esnext.typed-array.with" ], PromiseDependencies = [ "es.promise", "es.object.to-string" ];
      exports.PromiseDependencies = PromiseDependencies;
      const PromiseDependenciesWithIterators = [ ...PromiseDependencies, ...CommonIterators ];
      exports.PromiseDependenciesWithIterators = PromiseDependenciesWithIterators;
      const MapDependencies = [ "es.map", "esnext.map.delete-all", "esnext.map.emplace", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update", ...CommonIteratorsWithTag ], SetDependencies = [ "es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union", ...CommonIteratorsWithTag ], WeakMapDependencies = [ "es.weak-map", "esnext.weak-map.delete-all", "esnext.weak-map.emplace", ...CommonIteratorsWithTag ], WeakSetDependencies = [ "es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all", ...CommonIteratorsWithTag ], DOMExceptionDependencies = [ "web.dom-exception.constructor", "web.dom-exception.stack", "web.dom-exception.to-string-tag", "es.error.to-string" ], URLSearchParamsDependencies = [ "web.url-search-params", ...CommonIteratorsWithTag ], AsyncIteratorDependencies = [ "esnext.async-iterator.constructor", ...PromiseDependencies ], AsyncIteratorProblemMethods = [ "esnext.async-iterator.every", "esnext.async-iterator.filter", "esnext.async-iterator.find", "esnext.async-iterator.flat-map", "esnext.async-iterator.for-each", "esnext.async-iterator.map", "esnext.async-iterator.reduce", "esnext.async-iterator.some" ], IteratorDependencies = [ "esnext.iterator.constructor", "es.object.to-string" ], TypedArrayStaticMethods = {
        from: define(null, [ "es.typed-array.from" ]),
        fromAsync: define(null, [ "esnext.typed-array.from-async", ...PromiseDependenciesWithIterators ]),
        of: define(null, [ "es.typed-array.of" ])
      }, BuiltIns = {
        AsyncIterator: define("async-iterator/index", AsyncIteratorDependencies),
        AggregateError: define("aggregate-error", [ "es.aggregate-error", ...ErrorDependencies, ...CommonIteratorsWithTag, "es.aggregate-error.cause" ]),
        ArrayBuffer: define(null, [ "es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string" ]),
        DataView: define(null, [ "es.data-view", "es.array-buffer.slice", "es.object.to-string" ]),
        Date: define(null, [ "es.date.to-string" ]),
        DOMException: define("dom-exception", DOMExceptionDependencies),
        Error: define(null, ErrorDependencies),
        EvalError: define(null, ErrorDependencies),
        Float32Array: typed("es.typed-array.float32-array"),
        Float64Array: typed("es.typed-array.float64-array"),
        Int8Array: typed("es.typed-array.int8-array"),
        Int16Array: typed("es.typed-array.int16-array"),
        Int32Array: typed("es.typed-array.int32-array"),
        Iterator: define("iterator/index", IteratorDependencies),
        Uint8Array: typed("es.typed-array.uint8-array"),
        Uint8ClampedArray: typed("es.typed-array.uint8-clamped-array"),
        Uint16Array: typed("es.typed-array.uint16-array"),
        Uint32Array: typed("es.typed-array.uint32-array"),
        Map: define("map/index", MapDependencies),
        Number: define(null, [ "es.number.constructor" ]),
        Observable: define("observable/index", [ "esnext.observable", "esnext.symbol.observable", "es.object.to-string", ...CommonIteratorsWithTag ]),
        Promise: define("promise/index", PromiseDependencies),
        RangeError: define(null, ErrorDependencies),
        ReferenceError: define(null, ErrorDependencies),
        Reflect: define(null, [ "es.reflect.to-string-tag", "es.object.to-string" ]),
        RegExp: define(null, [ "es.regexp.constructor", "es.regexp.dot-all", "es.regexp.exec", "es.regexp.sticky", "es.regexp.to-string" ]),
        Set: define("set/index", SetDependencies),
        Symbol: define("symbol/index", [ "es.symbol", "es.symbol.description", "es.object.to-string" ]),
        SyntaxError: define(null, ErrorDependencies),
        TypeError: define(null, ErrorDependencies),
        URIError: define(null, ErrorDependencies),
        URL: define("url/index", [ "web.url", ...URLSearchParamsDependencies ]),
        URLSearchParams: define("url-search-params/index", URLSearchParamsDependencies),
        WeakMap: define("weak-map/index", WeakMapDependencies),
        WeakSet: define("weak-set/index", WeakSetDependencies),
        atob: define("atob", [ "web.atob", ...DOMExceptionDependencies ]),
        btoa: define("btoa", [ "web.btoa", ...DOMExceptionDependencies ]),
        clearImmediate: define("clear-immediate", [ "web.immediate" ]),
        compositeKey: define("composite-key", [ "esnext.composite-key" ]),
        compositeSymbol: define("composite-symbol", [ "esnext.composite-symbol" ]),
        escape: define("escape", [ "es.escape" ]),
        fetch: define(null, PromiseDependencies),
        globalThis: define("global-this", [ "es.global-this" ]),
        parseFloat: define("parse-float", [ "es.parse-float" ]),
        parseInt: define("parse-int", [ "es.parse-int" ]),
        queueMicrotask: define("queue-microtask", [ "web.queue-microtask" ]),
        setImmediate: define("set-immediate", [ "web.immediate" ]),
        setInterval: define("set-interval", [ "web.timers" ]),
        setTimeout: define("set-timeout", [ "web.timers" ]),
        structuredClone: define("structured-clone", [ "web.structured-clone", ...DOMExceptionDependencies, "es.array.iterator", "es.object.keys", "es.object.to-string", "es.map", "es.set" ]),
        unescape: define("unescape", [ "es.unescape" ])
      };
      exports.BuiltIns = BuiltIns;
      const StaticProperties = {
        AsyncIterator: {
          from: define("async-iterator/from", [ "esnext.async-iterator.from", ...AsyncIteratorDependencies, ...AsyncIteratorProblemMethods, ...CommonIterators ])
        },
        Array: {
          from: define("array/from", [ "es.array.from", "es.string.iterator" ]),
          fromAsync: define("array/from-async", [ "esnext.array.from-async", ...PromiseDependenciesWithIterators ]),
          isArray: define("array/is-array", [ "es.array.is-array" ]),
          isTemplateObject: define("array/is-template-object", [ "esnext.array.is-template-object" ]),
          of: define("array/of", [ "es.array.of" ])
        },
        ArrayBuffer: {
          isView: define(null, [ "es.array-buffer.is-view" ])
        },
        BigInt: {
          range: define("bigint/range", [ "esnext.bigint.range", "es.object.to-string" ])
        },
        Date: {
          now: define("date/now", [ "es.date.now" ])
        },
        Function: {
          isCallable: define("function/is-callable", [ "esnext.function.is-callable" ]),
          isConstructor: define("function/is-constructor", [ "esnext.function.is-constructor" ])
        },
        Iterator: {
          from: define("iterator/from", [ "esnext.iterator.from", ...IteratorDependencies, ...CommonIterators ])
        },
        JSON: {
          stringify: define("json/stringify", [ "es.json.stringify" ], "es.symbol")
        },
        Math: {
          DEG_PER_RAD: define("math/deg-per-rad", [ "esnext.math.deg-per-rad" ]),
          RAD_PER_DEG: define("math/rad-per-deg", [ "esnext.math.rad-per-deg" ]),
          acosh: define("math/acosh", [ "es.math.acosh" ]),
          asinh: define("math/asinh", [ "es.math.asinh" ]),
          atanh: define("math/atanh", [ "es.math.atanh" ]),
          cbrt: define("math/cbrt", [ "es.math.cbrt" ]),
          clamp: define("math/clamp", [ "esnext.math.clamp" ]),
          clz32: define("math/clz32", [ "es.math.clz32" ]),
          cosh: define("math/cosh", [ "es.math.cosh" ]),
          degrees: define("math/degrees", [ "esnext.math.degrees" ]),
          expm1: define("math/expm1", [ "es.math.expm1" ]),
          fround: define("math/fround", [ "es.math.fround" ]),
          fscale: define("math/fscale", [ "esnext.math.fscale" ]),
          hypot: define("math/hypot", [ "es.math.hypot" ]),
          iaddh: define("math/iaddh", [ "esnext.math.iaddh" ]),
          imul: define("math/imul", [ "es.math.imul" ]),
          imulh: define("math/imulh", [ "esnext.math.imulh" ]),
          isubh: define("math/isubh", [ "esnext.math.isubh" ]),
          log10: define("math/log10", [ "es.math.log10" ]),
          log1p: define("math/log1p", [ "es.math.log1p" ]),
          log2: define("math/log2", [ "es.math.log2" ]),
          radians: define("math/radians", [ "esnext.math.radians" ]),
          scale: define("math/scale", [ "esnext.math.scale" ]),
          seededPRNG: define("math/seeded-prng", [ "esnext.math.seeded-prng" ]),
          sign: define("math/sign", [ "es.math.sign" ]),
          signbit: define("math/signbit", [ "esnext.math.signbit" ]),
          sinh: define("math/sinh", [ "es.math.sinh" ]),
          tanh: define("math/tanh", [ "es.math.tanh" ]),
          trunc: define("math/trunc", [ "es.math.trunc" ]),
          umulh: define("math/umulh", [ "esnext.math.umulh" ])
        },
        Map: {
          from: define(null, [ "esnext.map.from", ...MapDependencies ]),
          groupBy: define(null, [ "esnext.map.group-by", ...MapDependencies ]),
          keyBy: define(null, [ "esnext.map.key-by", ...MapDependencies ]),
          of: define(null, [ "esnext.map.of", ...MapDependencies ])
        },
        Number: {
          EPSILON: define("number/epsilon", [ "es.number.epsilon" ]),
          MAX_SAFE_INTEGER: define("number/max-safe-integer", [ "es.number.max-safe-integer" ]),
          MIN_SAFE_INTEGER: define("number/min-safe-integer", [ "es.number.min-safe-integer" ]),
          fromString: define("number/from-string", [ "esnext.number.from-string" ]),
          isFinite: define("number/is-finite", [ "es.number.is-finite" ]),
          isInteger: define("number/is-integer", [ "es.number.is-integer" ]),
          isNaN: define("number/is-nan", [ "es.number.is-nan" ]),
          isSafeInteger: define("number/is-safe-integer", [ "es.number.is-safe-integer" ]),
          parseFloat: define("number/parse-float", [ "es.number.parse-float" ]),
          parseInt: define("number/parse-int", [ "es.number.parse-int" ]),
          range: define("number/range", [ "esnext.number.range", "es.object.to-string" ])
        },
        Object: {
          assign: define("object/assign", [ "es.object.assign" ]),
          create: define("object/create", [ "es.object.create" ]),
          defineProperties: define("object/define-properties", [ "es.object.define-properties" ]),
          defineProperty: define("object/define-property", [ "es.object.define-property" ]),
          entries: define("object/entries", [ "es.object.entries" ]),
          freeze: define("object/freeze", [ "es.object.freeze" ]),
          fromEntries: define("object/from-entries", [ "es.object.from-entries", "es.array.iterator" ]),
          getOwnPropertyDescriptor: define("object/get-own-property-descriptor", [ "es.object.get-own-property-descriptor" ]),
          getOwnPropertyDescriptors: define("object/get-own-property-descriptors", [ "es.object.get-own-property-descriptors" ]),
          getOwnPropertyNames: define("object/get-own-property-names", [ "es.object.get-own-property-names" ]),
          getOwnPropertySymbols: define("object/get-own-property-symbols", [ "es.symbol" ]),
          getPrototypeOf: define("object/get-prototype-of", [ "es.object.get-prototype-of" ]),
          hasOwn: define("object/has-own", [ "es.object.has-own" ]),
          is: define("object/is", [ "es.object.is" ]),
          isExtensible: define("object/is-extensible", [ "es.object.is-extensible" ]),
          isFrozen: define("object/is-frozen", [ "es.object.is-frozen" ]),
          isSealed: define("object/is-sealed", [ "es.object.is-sealed" ]),
          keys: define("object/keys", [ "es.object.keys" ]),
          preventExtensions: define("object/prevent-extensions", [ "es.object.prevent-extensions" ]),
          seal: define("object/seal", [ "es.object.seal" ]),
          setPrototypeOf: define("object/set-prototype-of", [ "es.object.set-prototype-of" ]),
          values: define("object/values", [ "es.object.values" ])
        },
        Promise: {
          all: define(null, PromiseDependenciesWithIterators),
          allSettled: define(null, [ "es.promise.all-settled", ...PromiseDependenciesWithIterators ]),
          any: define(null, [ "es.promise.any", "es.aggregate-error", ...PromiseDependenciesWithIterators ]),
          race: define(null, PromiseDependenciesWithIterators),
          try: define(null, [ "esnext.promise.try", ...PromiseDependenciesWithIterators ])
        },
        Reflect: {
          apply: define("reflect/apply", [ "es.reflect.apply" ]),
          construct: define("reflect/construct", [ "es.reflect.construct" ]),
          defineMetadata: define("reflect/define-metadata", [ "esnext.reflect.define-metadata" ]),
          defineProperty: define("reflect/define-property", [ "es.reflect.define-property" ]),
          deleteMetadata: define("reflect/delete-metadata", [ "esnext.reflect.delete-metadata" ]),
          deleteProperty: define("reflect/delete-property", [ "es.reflect.delete-property" ]),
          get: define("reflect/get", [ "es.reflect.get" ]),
          getMetadata: define("reflect/get-metadata", [ "esnext.reflect.get-metadata" ]),
          getMetadataKeys: define("reflect/get-metadata-keys", [ "esnext.reflect.get-metadata-keys" ]),
          getOwnMetadata: define("reflect/get-own-metadata", [ "esnext.reflect.get-own-metadata" ]),
          getOwnMetadataKeys: define("reflect/get-own-metadata-keys", [ "esnext.reflect.get-own-metadata-keys" ]),
          getOwnPropertyDescriptor: define("reflect/get-own-property-descriptor", [ "es.reflect.get-own-property-descriptor" ]),
          getPrototypeOf: define("reflect/get-prototype-of", [ "es.reflect.get-prototype-of" ]),
          has: define("reflect/has", [ "es.reflect.has" ]),
          hasMetadata: define("reflect/has-metadata", [ "esnext.reflect.has-metadata" ]),
          hasOwnMetadata: define("reflect/has-own-metadata", [ "esnext.reflect.has-own-metadata" ]),
          isExtensible: define("reflect/is-extensible", [ "es.reflect.is-extensible" ]),
          metadata: define("reflect/metadata", [ "esnext.reflect.metadata" ]),
          ownKeys: define("reflect/own-keys", [ "es.reflect.own-keys" ]),
          preventExtensions: define("reflect/prevent-extensions", [ "es.reflect.prevent-extensions" ]),
          set: define("reflect/set", [ "es.reflect.set" ]),
          setPrototypeOf: define("reflect/set-prototype-of", [ "es.reflect.set-prototype-of" ])
        },
        Set: {
          from: define(null, [ "esnext.set.from", ...SetDependencies ]),
          of: define(null, [ "esnext.set.of", ...SetDependencies ])
        },
        String: {
          cooked: define("string/cooked", [ "esnext.string.cooked" ]),
          fromCodePoint: define("string/from-code-point", [ "es.string.from-code-point" ]),
          raw: define("string/raw", [ "es.string.raw" ])
        },
        Symbol: {
          asyncDispose: define("symbol/async-dispose", [ "esnext.symbol.async-dispose" ]),
          asyncIterator: define("symbol/async-iterator", [ "es.symbol.async-iterator" ]),
          dispose: define("symbol/dispose", [ "esnext.symbol.dispose" ]),
          for: define("symbol/for", [], "es.symbol"),
          hasInstance: define("symbol/has-instance", [ "es.symbol.has-instance", "es.function.has-instance" ]),
          isConcatSpreadable: define("symbol/is-concat-spreadable", [ "es.symbol.is-concat-spreadable", "es.array.concat" ]),
          iterator: define("symbol/iterator", [ "es.symbol.iterator", ...CommonIteratorsWithTag ]),
          keyFor: define("symbol/key-for", [], "es.symbol"),
          match: define("symbol/match", [ "es.symbol.match", "es.string.match" ]),
          matcher: define("symbol/matcher", [ "esnext.symbol.matcher" ]),
          matchAll: define("symbol/match-all", [ "es.symbol.match-all", "es.string.match-all" ]),
          metadata: define("symbol/metadata", [ "esnext.symbol.metadata" ]),
          observable: define("symbol/observable", [ "esnext.symbol.observable" ]),
          patternMatch: define("symbol/pattern-match", [ "esnext.symbol.pattern-match" ]),
          replace: define("symbol/replace", [ "es.symbol.replace", "es.string.replace" ]),
          search: define("symbol/search", [ "es.symbol.search", "es.string.search" ]),
          species: define("symbol/species", [ "es.symbol.species", "es.array.species" ]),
          split: define("symbol/split", [ "es.symbol.split", "es.string.split" ]),
          toPrimitive: define("symbol/to-primitive", [ "es.symbol.to-primitive", "es.date.to-primitive" ]),
          toStringTag: define("symbol/to-string-tag", [ "es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag" ]),
          unscopables: define("symbol/unscopables", [ "es.symbol.unscopables" ])
        },
        WeakMap: {
          from: define(null, [ "esnext.weak-map.from", ...WeakMapDependencies ]),
          of: define(null, [ "esnext.weak-map.of", ...WeakMapDependencies ])
        },
        WeakSet: {
          from: define(null, [ "esnext.weak-set.from", ...WeakSetDependencies ]),
          of: define(null, [ "esnext.weak-set.of", ...WeakSetDependencies ])
        },
        Int8Array: TypedArrayStaticMethods,
        Uint8Array: TypedArrayStaticMethods,
        Uint8ClampedArray: TypedArrayStaticMethods,
        Int16Array: TypedArrayStaticMethods,
        Uint16Array: TypedArrayStaticMethods,
        Int32Array: TypedArrayStaticMethods,
        Uint32Array: TypedArrayStaticMethods,
        Float32Array: TypedArrayStaticMethods,
        Float64Array: TypedArrayStaticMethods,
        WebAssembly: {
          CompileError: define(null, ErrorDependencies),
          LinkError: define(null, ErrorDependencies),
          RuntimeError: define(null, ErrorDependencies)
        }
      };
      exports.StaticProperties = StaticProperties;
      const InstanceProperties = {
        asIndexedPairs: define("instance/asIndexedPairs", [ "esnext.async-iterator.as-indexed-pairs", ...AsyncIteratorDependencies, "esnext.iterator.as-indexed-pairs", ...IteratorDependencies ]),
        at: define("instance/at", [ "esnext.string.at", "es.string.at-alternative", "es.array.at" ]),
        anchor: define(null, [ "es.string.anchor" ]),
        big: define(null, [ "es.string.big" ]),
        bind: define("instance/bind", [ "es.function.bind" ]),
        blink: define(null, [ "es.string.blink" ]),
        bold: define(null, [ "es.string.bold" ]),
        codePointAt: define("instance/code-point-at", [ "es.string.code-point-at" ]),
        codePoints: define("instance/code-points", [ "esnext.string.code-points" ]),
        concat: define("instance/concat", [ "es.array.concat" ], void 0, [ "String" ]),
        copyWithin: define("instance/copy-within", [ "es.array.copy-within" ]),
        description: define(null, [ "es.symbol", "es.symbol.description" ]),
        dotAll: define("instance/dot-all", [ "es.regexp.dot-all" ]),
        drop: define("instance/drop", [ "esnext.async-iterator.drop", ...AsyncIteratorDependencies, "esnext.iterator.drop", ...IteratorDependencies ]),
        emplace: define("instance/emplace", [ "esnext.map.emplace", "esnext.weak-map.emplace" ]),
        endsWith: define("instance/ends-with", [ "es.string.ends-with" ]),
        entries: define("instance/entries", ArrayNatureIteratorsWithTag),
        every: define("instance/every", [ "es.array.every", "esnext.async-iterator.every", "esnext.iterator.every", ...IteratorDependencies ]),
        exec: define(null, [ "es.regexp.exec" ]),
        fill: define("instance/fill", [ "es.array.fill" ]),
        filter: define("instance/filter", [ "es.array.filter", "esnext.async-iterator.filter", "esnext.iterator.filter", ...IteratorDependencies ]),
        filterReject: define("instance/filterReject", [ "esnext.array.filter-reject" ]),
        finally: define(null, [ "es.promise.finally", ...PromiseDependencies ]),
        find: define("instance/find", [ "es.array.find", "esnext.async-iterator.find", "esnext.iterator.find", ...IteratorDependencies ]),
        findIndex: define("instance/find-index", [ "es.array.find-index" ]),
        findLast: define("instance/find-last", [ "esnext.array.find-last" ]),
        findLastIndex: define("instance/find-last-index", [ "esnext.array.find-last-index" ]),
        fixed: define(null, [ "es.string.fixed" ]),
        flags: define("instance/flags", [ "es.regexp.flags" ]),
        flatMap: define("instance/flat-map", [ "es.array.flat-map", "es.array.unscopables.flat-map", "esnext.async-iterator.flat-map", "esnext.iterator.flat-map", ...IteratorDependencies ]),
        flat: define("instance/flat", [ "es.array.flat", "es.array.unscopables.flat" ]),
        getYear: define(null, [ "es.date.get-year" ]),
        groupBy: define("instance/group-by", [ "esnext.array.group-by" ]),
        groupByToMap: define("instance/group-by-to-map", [ "esnext.array.group-by-to-map", "es.map", "es.object.to-string" ]),
        fontcolor: define(null, [ "es.string.fontcolor" ]),
        fontsize: define(null, [ "es.string.fontsize" ]),
        forEach: define("instance/for-each", [ "es.array.for-each", "esnext.async-iterator.for-each", "esnext.iterator.for-each", ...IteratorDependencies, "web.dom-collections.for-each" ]),
        includes: define("instance/includes", [ "es.array.includes", "es.string.includes" ]),
        indexOf: define("instance/index-of", [ "es.array.index-of" ]),
        italic: define(null, [ "es.string.italics" ]),
        join: define(null, [ "es.array.join" ]),
        keys: define("instance/keys", ArrayNatureIteratorsWithTag),
        lastIndex: define(null, [ "esnext.array.last-index" ]),
        lastIndexOf: define("instance/last-index-of", [ "es.array.last-index-of" ]),
        lastItem: define(null, [ "esnext.array.last-item" ]),
        link: define(null, [ "es.string.link" ]),
        map: define("instance/map", [ "es.array.map", "esnext.async-iterator.map", "esnext.iterator.map" ]),
        match: define(null, [ "es.string.match", "es.regexp.exec" ]),
        matchAll: define("instance/match-all", [ "es.string.match-all", "es.regexp.exec" ]),
        name: define(null, [ "es.function.name" ]),
        padEnd: define("instance/pad-end", [ "es.string.pad-end" ]),
        padStart: define("instance/pad-start", [ "es.string.pad-start" ]),
        reduce: define("instance/reduce", [ "es.array.reduce", "esnext.async-iterator.reduce", "esnext.iterator.reduce", ...IteratorDependencies ]),
        reduceRight: define("instance/reduce-right", [ "es.array.reduce-right" ]),
        repeat: define("instance/repeat", [ "es.string.repeat" ]),
        replace: define(null, [ "es.string.replace", "es.regexp.exec" ]),
        replaceAll: define("instance/replace-all", [ "es.string.replace-all", "es.string.replace", "es.regexp.exec" ]),
        reverse: define("instance/reverse", [ "es.array.reverse" ]),
        search: define(null, [ "es.string.search", "es.regexp.exec" ]),
        setYear: define(null, [ "es.date.set-year" ]),
        slice: define("instance/slice", [ "es.array.slice" ]),
        small: define(null, [ "es.string.small" ]),
        some: define("instance/some", [ "es.array.some", "esnext.async-iterator.some", "esnext.iterator.some", ...IteratorDependencies ]),
        sort: define("instance/sort", [ "es.array.sort" ]),
        splice: define("instance/splice", [ "es.array.splice" ]),
        split: define(null, [ "es.string.split", "es.regexp.exec" ]),
        startsWith: define("instance/starts-with", [ "es.string.starts-with" ]),
        sticky: define("instance/sticky", [ "es.regexp.sticky" ]),
        strike: define(null, [ "es.string.strike" ]),
        sub: define(null, [ "es.string.sub" ]),
        substr: define(null, [ "es.string.substr" ]),
        sup: define(null, [ "es.string.sup" ]),
        take: define("instance/take", [ "esnext.async-iterator.take", ...AsyncIteratorDependencies, "esnext.iterator.take", ...IteratorDependencies ]),
        test: define("instance/test", [ "es.regexp.test", "es.regexp.exec" ]),
        toArray: define("instance/to-array", [ "esnext.async-iterator.to-array", ...AsyncIteratorDependencies, "esnext.iterator.to-array", ...IteratorDependencies ]),
        toAsync: define(null, [ "esnext.iterator.to-async", ...IteratorDependencies, ...AsyncIteratorDependencies, ...AsyncIteratorProblemMethods ]),
        toExponential: define(null, [ "es.number.to-exponential" ]),
        toFixed: define(null, [ "es.number.to-fixed" ]),
        toGMTString: define(null, [ "es.date.to-gmt-string" ]),
        toISOString: define(null, [ "es.date.to-iso-string" ]),
        toJSON: define(null, [ "es.date.to-json", "web.url.to-json" ]),
        toPrecision: define(null, [ "es.number.to-precision" ]),
        toReversed: define("instance/to-reversed", [ "esnext.array.to-reversed" ]),
        toSorted: define("instance/to-sorted", [ "esnext.array.to-sorted", "es.array.sort" ]),
        toSpliced: define("instance/to-reversed", [ "esnext.array.to-spliced" ]),
        toString: define(null, [ "es.object.to-string", "es.error.to-string", "es.date.to-string", "es.regexp.to-string" ]),
        trim: define("instance/trim", [ "es.string.trim" ]),
        trimEnd: define("instance/trim-end", [ "es.string.trim-end" ]),
        trimLeft: define("instance/trim-left", [ "es.string.trim-start" ]),
        trimRight: define("instance/trim-right", [ "es.string.trim-end" ]),
        trimStart: define("instance/trim-start", [ "es.string.trim-start" ]),
        uniqueBy: define("instance/unique-by", [ "esnext.array.unique-by", "es.map" ]),
        unThis: define("instance/un-this", [ "esnext.function.un-this" ]),
        values: define("instance/values", ArrayNatureIteratorsWithTag),
        with: define("instance/with", [ "esnext.array.with" ]),
        __defineGetter__: define(null, [ "es.object.define-getter" ]),
        __defineSetter__: define(null, [ "es.object.define-setter" ]),
        __lookupGetter__: define(null, [ "es.object.lookup-getter" ]),
        __lookupSetter__: define(null, [ "es.object.lookup-setter" ])
      };
      exports.InstanceProperties = InstanceProperties;
      const CommonInstanceDependencies = new Set([ "es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec" ]);
      exports.CommonInstanceDependencies = CommonInstanceDependencies;
    },
    1515: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _data = _interopRequireDefault(__webpack_require__(7026)), _shippedProposals = _interopRequireDefault(__webpack_require__(7237)), _getModulesListForTargetVersion = _interopRequireDefault(__webpack_require__(6864)), _builtInDefinitions = __webpack_require__(9930), babel = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4629)), _utils = __webpack_require__(9596), _helperDefinePolyfillProvider = _interopRequireDefault(__webpack_require__(9695));
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      function _extends() {
        return _extends = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
          return target;
        }, _extends.apply(this, arguments);
      }
      const {types: t} = babel.default || babel, esnextFallback = (name, cb) => {
        if (cb(name)) return !0;
        if (!name.startsWith("es.")) return !1;
        const fallback = `esnext.${name.slice(3)}`;
        return !!_data.default[fallback] && cb(fallback);
      };
      var _default = (0, _helperDefinePolyfillProvider.default)((function({getUtils, method, shouldInjectPolyfill, createMetaResolver, debug, babel}, {version = 3, proposals, shippedProposals, "#__secret_key__@babel/runtime__compatibility": {useBabelRuntime, ext = ".js"} = {}}) {
        const isWebpack = babel.caller((caller => "babel-loader" === (null == caller ? void 0 : caller.name))), resolve = createMetaResolver({
          global: _builtInDefinitions.BuiltIns,
          static: _builtInDefinitions.StaticProperties,
          instance: _builtInDefinitions.InstanceProperties
        }), available = new Set((0, _getModulesListForTargetVersion.default)(version));
        function maybeInjectGlobalImpl(name, utils) {
          return !!shouldInjectPolyfill(name) && (debug(name), utils.injectGlobalImport((0, 
          _utils.coreJSModule)(name)), !0);
        }
        function maybeInjectGlobal(names, utils, fallback = !0) {
          for (const name of names) fallback ? esnextFallback(name, (name => maybeInjectGlobalImpl(name, utils))) : maybeInjectGlobalImpl(name, utils);
        }
        function maybeInjectPure(desc, hint, utils, object) {
          if (desc.pure && !(object && desc.exclude && desc.exclude.includes(object)) && esnextFallback(desc.name, shouldInjectPolyfill)) {
            const {name} = desc;
            let useProposalBase = !1;
            (proposals || shippedProposals && name.startsWith("esnext.") || name.startsWith("es.") && !available.has(name)) && (useProposalBase = !0);
            const coreJSPureBase = function(useProposalBase) {
              return useBabelRuntime ? useProposalBase ? `${useBabelRuntime}/core-js` : `${useBabelRuntime}/core-js-stable` : useProposalBase ? "core-js-pure/features" : "core-js-pure/stable";
            }(useProposalBase);
            return utils.injectDefaultImport(`${coreJSPureBase}/${desc.pure}${ext}`, hint);
          }
        }
        return {
          name: "corejs3",
          polyfills: _data.default,
          filterPolyfills: name => !!available.has(name) && (!(!proposals && "entry-global" !== method) || (!(!shippedProposals || !_shippedProposals.default.has(name)) || function(name) {
            if (name.startsWith("esnext.")) return `es.${name.slice(7)}` in _data.default;
            return !0;
          }(name))),
          entryGlobal(meta, utils, path) {
            if ("import" !== meta.kind) return;
            const modules = (0, _utils.isCoreJSSource)(meta.source);
            if (!modules) return;
            if (1 === modules.length && meta.source === (0, _utils.coreJSModule)(modules[0]) && shouldInjectPolyfill(modules[0])) return void debug(null);
            const modulesSet = new Set(modules);
            maybeInjectGlobal(modules.filter((module => {
              if (!module.startsWith("esnext.")) return !0;
              const stable = module.replace("esnext.", "es.");
              return !modulesSet.has(stable) || !shouldInjectPolyfill(stable);
            })), utils, !1), path.remove();
          },
          usageGlobal(meta, utils) {
            const resolved = resolve(meta);
            if (!resolved) return;
            let deps = resolved.desc.global;
            if ("global" !== resolved.kind && meta.object && "prototype" === meta.placement) {
              const low = meta.object.toLowerCase();
              deps = deps.filter((m => m.includes(low) || _builtInDefinitions.CommonInstanceDependencies.has(m)));
            }
            maybeInjectGlobal(deps, utils);
          },
          usagePure(meta, utils, path) {
            if ("in" === meta.kind) return void ("Symbol.iterator" === meta.key && path.replaceWith(t.callExpression(utils.injectDefaultImport((0, 
            _utils.coreJSPureHelper)("is-iterable", useBabelRuntime, ext), "isIterable"), [ path.node.right ])));
            if (path.parentPath.isUnaryExpression({
              operator: "delete"
            })) return;
            let isCall;
            if ("property" === meta.kind) {
              if (!path.isMemberExpression()) return;
              if (!path.isReferenced()) return;
              if (isCall = path.parentPath.isCallExpression({
                callee: path.node
              }), "Symbol.iterator" === meta.key) {
                if (!shouldInjectPolyfill("es.symbol.iterator")) return;
                return void (isCall ? 0 === path.parent.arguments.length ? (path.parentPath.replaceWith(t.callExpression(utils.injectDefaultImport((0, 
                _utils.coreJSPureHelper)("get-iterator", useBabelRuntime, ext), "getIterator"), [ path.node.object ])), 
                path.skip()) : (0, _utils.callMethod)(path, utils.injectDefaultImport((0, _utils.coreJSPureHelper)("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod")) : path.replaceWith(t.callExpression(utils.injectDefaultImport((0, 
                _utils.coreJSPureHelper)("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"), [ path.node.object ])));
              }
            }
            let resolved = resolve(meta);
            if (resolved) if (useBabelRuntime && resolved.desc.pure && "/index" === resolved.desc.pure.slice(-6) && (resolved = _extends({}, resolved, {
              desc: _extends({}, resolved.desc, {
                pure: resolved.desc.pure.slice(0, -6)
              })
            })), "global" === resolved.kind) {
              const id = maybeInjectPure(resolved.desc, resolved.name, utils);
              id && path.replaceWith(id);
            } else if ("static" === resolved.kind) {
              const id = maybeInjectPure(resolved.desc, resolved.name, utils, meta.object);
              id && path.replaceWith(id);
            } else if ("instance" === resolved.kind) {
              const id = maybeInjectPure(resolved.desc, `${resolved.name}InstanceProperty`, utils, meta.object);
              if (!id) return;
              isCall ? (0, _utils.callMethod)(path, id) : path.replaceWith(t.callExpression(id, [ path.node.object ]));
            }
          },
          visitor: "usage-global" === method && {
            CallExpression(path) {
              if (path.get("callee").isImport()) {
                const utils = getUtils(path);
                maybeInjectGlobal(isWebpack ? _builtInDefinitions.PromiseDependenciesWithIterators : _builtInDefinitions.PromiseDependencies, utils);
              }
            },
            Function(path) {
              path.node.async && maybeInjectGlobal(_builtInDefinitions.PromiseDependencies, getUtils(path));
            },
            "ForOfStatement|ArrayPattern"(path) {
              maybeInjectGlobal(_builtInDefinitions.CommonIterators, getUtils(path));
            },
            SpreadElement(path) {
              path.parentPath.isObjectExpression() || maybeInjectGlobal(_builtInDefinitions.CommonIterators, getUtils(path));
            },
            YieldExpression(path) {
              path.node.delegate && maybeInjectGlobal(_builtInDefinitions.CommonIterators, getUtils(path));
            }
          }
        };
      }));
      exports.default = _default;
    },
    7237: (__unused_webpack_module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var _default = new Set([ "esnext.array.find-last", "esnext.array.find-last-index", "esnext.typed-array.find-last", "esnext.typed-array.find-last-index" ]);
      exports.default = _default;
    },
    9596: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.callMethod = function(path, id) {
        const {object} = path.node;
        let context1, context2;
        t.isIdentifier(object) ? (context1 = object, context2 = t.cloneNode(object)) : (context1 = path.scope.generateDeclaredUidIdentifier("context"), 
        context2 = t.assignmentExpression("=", t.cloneNode(context1), object));
        path.replaceWith(t.memberExpression(t.callExpression(id, [ context2 ]), t.identifier("call"))), 
        path.parentPath.unshiftContainer("arguments", context1);
      }, exports.isCoreJSSource = function(source) {
        "string" == typeof source && (source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase());
        return hasOwnProperty.call(_entries.default, source) && _entries.default[source];
      }, exports.coreJSModule = function(name) {
        return `core-js/modules/${name}.js`;
      }, exports.coreJSPureHelper = function(name, useBabelRuntime, ext) {
        return useBabelRuntime ? `${useBabelRuntime}/core-js/${name}${ext}` : `core-js-pure/features/${name}.js`;
      };
      var obj, babel = function(obj) {
        if (obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache();
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4629)), _entries = (obj = __webpack_require__(2729)) && obj.__esModule ? obj : {
        default: obj
      };
      function _getRequireWildcardCache() {
        if ("function" != typeof WeakMap) return null;
        var cache = new WeakMap;
        return _getRequireWildcardCache = function() {
          return cache;
        }, cache;
      }
      const {types: t} = babel.default || babel;
    },
    205: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = void 0;
      var obj, _helperDefinePolyfillProvider = (obj = __webpack_require__(9695)) && obj.__esModule ? obj : {
        default: obj
      };
      const runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
      var _default = (0, _helperDefinePolyfillProvider.default)((({debug}, options) => {
        const {[runtimeCompat]: {useBabelRuntime} = {}} = options, pureName = useBabelRuntime ? `${useBabelRuntime}/regenerator` : "regenerator-runtime";
        return {
          name: "regenerator",
          polyfills: [ "regenerator-runtime" ],
          usageGlobal(meta, utils) {
            isRegenerator(meta) && (debug("regenerator-runtime"), utils.injectGlobalImport("regenerator-runtime/runtime.js"));
          },
          usagePure(meta, utils, path) {
            isRegenerator(meta) && path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
          }
        };
      }));
      exports.default = _default;
      const isRegenerator = meta => "global" === meta.kind && "regeneratorRuntime" === meta.name;
    },
    3082: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const {compare, intersection, semver} = __webpack_require__(3485), modulesByVersions = __webpack_require__(2878), modules = __webpack_require__(9343);
      module.exports = function(raw) {
        const corejs = semver(raw);
        if (3 !== corejs.major) throw RangeError("This version of `core-js-compat` works only with `core-js@3`.");
        const result = [];
        for (const version of Object.keys(modulesByVersions)) compare(version, "<=", corejs) && result.push(...modulesByVersions[version]);
        return intersection(result, modules);
      };
    },
    3485: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const cmp = __webpack_require__(2774), semver = __webpack_require__(1495), has = Function.call.bind({}.hasOwnProperty);
      module.exports = {
        compare: function(a, operator, b) {
          return cmp(semver(a), operator, semver(b));
        },
        filterOutStabilizedProposals: function(modules) {
          const modulesSet = new Set(modules);
          for (const $module of modulesSet) $module.startsWith("esnext.") && modulesSet.has($module.replace(/^esnext\./, "es.")) && modulesSet.delete($module);
          return [ ...modulesSet ];
        },
        has,
        intersection: function(list, order) {
          const set = list instanceof Set ? list : new Set(list);
          return order.filter((name => set.has(name)));
        },
        semver,
        sortObjectByKey: function(object, fn) {
          return Object.keys(object).sort(fn).reduce(((memo, key) => (memo[key] = object[key], 
          memo)), {});
        }
      };
    },
    5293: (module, __unused_webpack_exports, __webpack_require__) => {
      const debug = __webpack_require__(958), {MAX_LENGTH, MAX_SAFE_INTEGER} = __webpack_require__(9363), {re, t} = __webpack_require__(5073), {compareIdentifiers} = __webpack_require__(9251);
      class SemVer {
        constructor(version, options) {
          if (options && "object" == typeof options || (options = {
            loose: !!options,
            includePrerelease: !1
          }), version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
            version = version.version;
          } else if ("string" != typeof version) throw new TypeError(`Invalid Version: ${version}`);
          if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
          debug("SemVer", version, options), this.options = options, this.loose = !!options.loose, 
          this.includePrerelease = !!options.includePrerelease;
          const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) throw new TypeError(`Invalid Version: ${version}`);
          if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
          this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
          m[4] ? this.prerelease = m[4].split(".").map((id => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
            }
            return id;
          })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
        }
        format() {
          return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), 
          this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
            if ("string" == typeof other && other === this.version) return 0;
            other = new SemVer(other, this.options);
          }
          return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
          if (!this.prerelease.length && other.prerelease.length) return 1;
          if (!this.prerelease.length && !other.prerelease.length) return 0;
          let i = 0;
          do {
            const a = this.prerelease[i], b = other.prerelease[i];
            if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
            if (void 0 === b) return 1;
            if (void 0 === a) return -1;
            if (a !== b) return compareIdentifiers(a, b);
          } while (++i);
        }
        compareBuild(other) {
          other instanceof SemVer || (other = new SemVer(other, this.options));
          let i = 0;
          do {
            const a = this.build[i], b = other.build[i];
            if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
            if (void 0 === b) return 1;
            if (void 0 === a) return -1;
            if (a !== b) return compareIdentifiers(a, b);
          } while (++i);
        }
        inc(release, identifier) {
          switch (release) {
           case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
            break;

           case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
            break;

           case "prepatch":
            this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
            break;

           case "prerelease":
            0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
            break;

           case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
            this.minor = 0, this.patch = 0, this.prerelease = [];
            break;

           case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
            this.prerelease = [];
            break;

           case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;

           case "pre":
            if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
              let i = this.prerelease.length;
              for (;--i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
              i = -2);
              -1 === i && this.prerelease.push(0);
            }
            identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
            break;

           default:
            throw new Error(`invalid increment argument: ${release}`);
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      module.exports = SemVer;
    },
    2774: (module, __unused_webpack_exports, __webpack_require__) => {
      const eq = __webpack_require__(5881), neq = __webpack_require__(3618), gt = __webpack_require__(3362), gte = __webpack_require__(5180), lt = __webpack_require__(7651), lte = __webpack_require__(5423);
      module.exports = (a, op, b, loose) => {
        switch (op) {
         case "===":
          return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
          a === b;

         case "!==":
          return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
          a !== b;

         case "":
         case "=":
         case "==":
          return eq(a, b, loose);

         case "!=":
          return neq(a, b, loose);

         case ">":
          return gt(a, b, loose);

         case ">=":
          return gte(a, b, loose);

         case "<":
          return lt(a, b, loose);

         case "<=":
          return lte(a, b, loose);

         default:
          throw new TypeError(`Invalid operator: ${op}`);
        }
      };
    },
    1495: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(5293), parse = __webpack_require__(110), {re, t} = __webpack_require__(5073);
      module.exports = (version, options) => {
        if (version instanceof SemVer) return version;
        if ("number" == typeof version && (version = String(version)), "string" != typeof version) return null;
        let match = null;
        if ((options = options || {}).rtl) {
          let next;
          for (;(next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length); ) match && next.index + next[0].length === match.index + match[0].length || (match = next), 
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          re[t.COERCERTL].lastIndex = -1;
        } else match = version.match(re[t.COERCE]);
        return null === match ? null : parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
      };
    },
    1439: (module, __unused_webpack_exports, __webpack_require__) => {
      const SemVer = __webpack_require__(5293);
      module.exports = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    },
    5881: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(1439);
      module.exports = (a, b, loose) => 0 === compare(a, b, loose);
    },
    3362: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(1439);
      module.exports = (a, b, loose) => compare(a, b, loose) > 0;
    },
    5180: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(1439);
      module.exports = (a, b, loose) => compare(a, b, loose) >= 0;
    },
    7651: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(1439);
      module.exports = (a, b, loose) => compare(a, b, loose) < 0;
    },
    5423: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(1439);
      module.exports = (a, b, loose) => compare(a, b, loose) <= 0;
    },
    3618: (module, __unused_webpack_exports, __webpack_require__) => {
      const compare = __webpack_require__(1439);
      module.exports = (a, b, loose) => 0 !== compare(a, b, loose);
    },
    110: (module, __unused_webpack_exports, __webpack_require__) => {
      const {MAX_LENGTH} = __webpack_require__(9363), {re, t} = __webpack_require__(5073), SemVer = __webpack_require__(5293);
      module.exports = (version, options) => {
        if (options && "object" == typeof options || (options = {
          loose: !!options,
          includePrerelease: !1
        }), version instanceof SemVer) return version;
        if ("string" != typeof version) return null;
        if (version.length > MAX_LENGTH) return null;
        if (!(options.loose ? re[t.LOOSE] : re[t.FULL]).test(version)) return null;
        try {
          return new SemVer(version, options);
        } catch (er) {
          return null;
        }
      };
    },
    9363: module => {
      const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      module.exports = {
        SEMVER_SPEC_VERSION: "2.0.0",
        MAX_LENGTH: 256,
        MAX_SAFE_INTEGER,
        MAX_SAFE_COMPONENT_LENGTH: 16
      };
    },
    958: module => {
      const debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
      module.exports = debug;
    },
    9251: module => {
      const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
        const anum = numeric.test(a), bnum = numeric.test(b);
        return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      module.exports = {
        compareIdentifiers,
        rcompareIdentifiers: (a, b) => compareIdentifiers(b, a)
      };
    },
    5073: (module, exports, __webpack_require__) => {
      const {MAX_SAFE_COMPONENT_LENGTH} = __webpack_require__(9363), debug = __webpack_require__(958), re = (exports = module.exports = {}).re = [], src = exports.src = [], t = exports.t = {};
      let R = 0;
      const createToken = (name, value, isGlobal) => {
        const index = R++;
        debug(index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), 
      createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), 
      createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), 
      createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), 
      createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), 
      createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), 
      createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), 
      createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), 
      createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), 
      createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), 
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), 
      createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), 
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), 
      createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), 
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), 
      createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), 
      createToken("COERCERTL", src[t.COERCE], !0), createToken("LONETILDE", "(?:~>?)"), 
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0), exports.tildeTrimReplace = "$1~", 
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), 
      createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0), 
      exports.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), 
      createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), 
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0), 
      exports.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), 
      createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), 
      createToken("STAR", "(<|>)?=?\\s*\\*");
    },
    1227: (module, exports, __webpack_require__) => {
      exports.formatArgs = function(args) {
        if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), 
        !this.useColors) return;
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0, lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match => {
          "%%" !== match && (index++, "%c" === match && (lastC = index));
        })), args.splice(lastC, 0, c);
      }, exports.save = function(namespaces) {
        try {
          namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
        } catch (error) {}
      }, exports.load = function() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {}
        !r && "undefined" != typeof process && "env" in process && (r = process.env.DEBUG);
        return r;
      }, exports.useColors = function() {
        if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return !0;
        if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
        return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }, exports.storage = function() {
        try {
          return localStorage;
        } catch (error) {}
      }(), exports.destroy = (() => {
        let warned = !1;
        return () => {
          warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
      })(), exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ], 
      exports.log = console.debug || console.log || (() => {}), module.exports = __webpack_require__(2447)(exports);
      const {formatters} = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    },
    2447: (module, __unused_webpack_exports, __webpack_require__) => {
      module.exports = function(env) {
        function createDebug(namespace) {
          let prevTime, namespacesCache, enabledCache, enableOverride = null;
          function debug(...args) {
            if (!debug.enabled) return;
            const self = debug, curr = Number(new Date), ms = curr - (prevTime || curr);
            self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), 
            "string" != typeof args[0] && args.unshift("%O");
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, ((match, format) => {
              if ("%%" === match) return "%";
              index++;
              const formatter = createDebug.formatters[format];
              if ("function" == typeof formatter) {
                const val = args[index];
                match = formatter.call(self, val), args.splice(index, 1), index--;
              }
              return match;
            })), createDebug.formatArgs.call(self, args);
            (self.log || createDebug.log).apply(self, args);
          }
          return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), 
          debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: () => null !== enableOverride ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, 
            enabledCache = createDebug.enabled(namespace)), enabledCache),
            set: v => {
              enableOverride = v;
            }
          }), "function" == typeof createDebug.init && createDebug.init(debug), debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ":" : delimiter) + namespace);
          return newDebug.log = this.log, newDebug;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        return createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = function(val) {
          if (val instanceof Error) return val.stack || val.message;
          return val;
        }, createDebug.disable = function() {
          const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((namespace => "-" + namespace)) ].join(",");
          return createDebug.enable(""), namespaces;
        }, createDebug.enable = function(namespaces) {
          let i;
          createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], 
          createDebug.skips = [];
          const split = ("string" == typeof namespaces ? namespaces : "").split(/[\s,]+/), len = split.length;
          for (i = 0; i < len; i++) split[i] && ("-" === (namespaces = split[i].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
        }, createDebug.enabled = function(name) {
          if ("*" === name[name.length - 1]) return !0;
          let i, len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return !1;
          for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return !0;
          return !1;
        }, createDebug.humanize = __webpack_require__(7824), createDebug.destroy = function() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }, Object.keys(env).forEach((key => {
          createDebug[key] = env[key];
        })), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {}, 
        createDebug.selectColor = function(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), 
          hash |= 0;
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }, createDebug.enable(createDebug.load()), createDebug;
      };
    },
    5158: (module, __unused_webpack_exports, __webpack_require__) => {
      "undefined" == typeof process || "renderer" === process.type || !0 === process.browser || process.__nwjs ? module.exports = __webpack_require__(1227) : module.exports = __webpack_require__(39);
    },
    39: (module, exports, __webpack_require__) => {
      const tty = __webpack_require__(6224), util = __webpack_require__(3837);
      exports.init = function(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }, exports.log = function(...args) {
        return process.stderr.write(util.format(...args) + "\n");
      }, exports.formatArgs = function(args) {
        const {namespace: name, useColors} = this;
        if (useColors) {
          const c = this.color, colorCode = "[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} [0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "[0m");
        } else args[0] = function() {
          if (exports.inspectOpts.hideDate) return "";
          return (new Date).toISOString() + " ";
        }() + name + " " + args[0];
      }, exports.save = function(namespaces) {
        namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
      }, exports.load = function() {
        return process.env.DEBUG;
      }, exports.useColors = function() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }, exports.destroy = util.deprecate((() => {}), "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), 
      exports.colors = [ 6, 2, 3, 4, 5, 1 ];
      try {
        const supportsColor = __webpack_require__(2130);
        supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [ 20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221 ]);
      } catch (error) {}
      exports.inspectOpts = Object.keys(process.env).filter((key => /^debug_/i.test(key))).reduce(((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, ((_, k) => k.toUpperCase()));
        let val = process.env[key];
        return val = !!/^(yes|on|true|enabled)$/i.test(val) || !/^(no|off|false|disabled)$/i.test(val) && ("null" === val ? null : Number(val)), 
        obj[prop] = val, obj;
      }), {}), module.exports = __webpack_require__(2447)(exports);
      const {formatters} = module.exports;
      formatters.o = function(v) {
        return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split("\n").map((str => str.trim())).join(" ");
      }, formatters.O = function(v) {
        return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
      };
    },
    7648: module => {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", slice = Array.prototype.slice, toStr = Object.prototype.toString;
      module.exports = function(that) {
        var target = this;
        if ("function" != typeof target || "[object Function]" !== toStr.call(target)) throw new TypeError(ERROR_MESSAGE + target);
        for (var bound, args = slice.call(arguments, 1), binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            return Object(result) === result ? result : this;
          }
          return target.apply(that, args.concat(slice.call(arguments)));
        }, boundLength = Math.max(0, target.length - args.length), boundArgs = [], i = 0; i < boundLength; i++) boundArgs.push("$" + i);
        if (bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder), 
        target.prototype) {
          var Empty = function() {};
          Empty.prototype = target.prototype, bound.prototype = new Empty, Empty.prototype = null;
        }
        return bound;
      };
    },
    8612: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var implementation = __webpack_require__(7648);
      module.exports = Function.prototype.bind || implementation;
    },
    1272: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      module.exports = __webpack_require__(8487);
    },
    6560: module => {
      "use strict";
      module.exports = (flag, argv) => {
        argv = argv || process.argv;
        const prefix = flag.startsWith("-") ? "" : 1 === flag.length ? "-" : "--", pos = argv.indexOf(prefix + flag), terminatorPos = argv.indexOf("--");
        return -1 !== pos && (-1 === terminatorPos || pos < terminatorPos);
      };
    },
    7642: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var bind = __webpack_require__(8612);
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    },
    8295: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      var has = __webpack_require__(7642);
      function specifierIncluded(current, specifier) {
        for (var nodeParts = current.split("."), parts = specifier.split(" "), op = parts.length > 1 ? parts[0] : "=", versionParts = (parts.length > 1 ? parts[1] : parts[0]).split("."), i = 0; i < 3; ++i) {
          var cur = parseInt(nodeParts[i] || 0, 10), ver = parseInt(versionParts[i] || 0, 10);
          if (cur !== ver) return "<" === op ? cur < ver : ">=" === op && cur >= ver;
        }
        return ">=" === op;
      }
      function matchesRange(current, range) {
        var specifiers = range.split(/ ?&& ?/);
        if (0 === specifiers.length) return !1;
        for (var i = 0; i < specifiers.length; ++i) if (!specifierIncluded(current, specifiers[i])) return !1;
        return !0;
      }
      var data = __webpack_require__(6151);
      module.exports = function(x, nodeVersion) {
        return has(data, x) && function(nodeVersion, specifierValue) {
          if ("boolean" == typeof specifierValue) return specifierValue;
          var current = void 0 === nodeVersion ? process.versions && process.versions.node : nodeVersion;
          if ("string" != typeof current) throw new TypeError(void 0 === nodeVersion ? "Unable to determine current node version" : "If provided, a valid node version is required");
          if (specifierValue && "object" == typeof specifierValue) {
            for (var i = 0; i < specifierValue.length; ++i) if (matchesRange(current, specifierValue[i])) return !0;
            return !1;
          }
          return matchesRange(current, specifierValue);
        }(nodeVersion, data[x]);
      };
    },
    6188: (__unused_webpack_module, exports) => {
      Object.defineProperty(exports, "__esModule", {
        value: !0
      }), exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, 
      exports.matchToToken = function(match) {
        var token = {
          type: "invalid",
          value: match[0],
          closed: void 0
        };
        return match[1] ? (token.type = "string", token.closed = !(!match[3] && !match[4])) : match[5] ? token.type = "comment" : match[6] ? (token.type = "comment", 
        token.closed = !!match[7]) : match[8] ? token.type = "regex" : match[9] ? token.type = "number" : match[10] ? token.type = "name" : match[11] ? token.type = "punctuator" : match[12] && (token.type = "whitespace"), 
        token;
      };
    },
    3312: module => {
      "use strict";
      const object = {}, hasOwnProperty = object.hasOwnProperty, forOwn = (object, callback) => {
        for (const key in object) hasOwnProperty.call(object, key) && callback(key, object[key]);
      }, toString = object.toString, isArray = Array.isArray, isBuffer = Buffer.isBuffer, singleEscapes = {
        '"': '\\"',
        "'": "\\'",
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "\t": "\\t"
      }, regexSingleEscape = /["'\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitelist = /[ !#-&\(-\[\]-_a-~]/, jsesc = (argument, options) => {
        const increaseIndentation = () => {
          oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
        }, defaults = {
          escapeEverything: !1,
          minimal: !1,
          isScriptContext: !1,
          quotes: "single",
          wrap: !1,
          es6: !1,
          json: !1,
          compact: !0,
          lowercaseHex: !1,
          numbers: "decimal",
          indent: "\t",
          indentLevel: 0,
          __inline1__: !1,
          __inline2__: !1
        }, json = options && options.json;
        var destination, source;
        json && (defaults.quotes = "double", defaults.wrap = !0), destination = defaults, 
        options = (source = options) ? (forOwn(source, ((key, value) => {
          destination[key] = value;
        })), destination) : destination, "single" != options.quotes && "double" != options.quotes && "backtick" != options.quotes && (options.quotes = "single");
        const quote = "double" == options.quotes ? '"' : "backtick" == options.quotes ? "`" : "'", compact = options.compact, lowercaseHex = options.lowercaseHex;
        let indent = options.indent.repeat(options.indentLevel), oldIndent = "";
        const inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact ? "" : "\n";
        let result, isEmpty = !0;
        const useBinNumbers = "binary" == options.numbers, useOctNumbers = "octal" == options.numbers, useDecNumbers = "decimal" == options.numbers, useHexNumbers = "hexadecimal" == options.numbers;
        if (json && argument && "function" == typeof argument.toJSON && (argument = argument.toJSON()), 
        !(value => "string" == typeof value || "[object String]" == toString.call(value))(argument)) {
          if ((value => "[object Map]" == toString.call(value))(argument)) return 0 == argument.size ? "new Map()" : (compact || (options.__inline1__ = !0, 
          options.__inline2__ = !1), "new Map(" + jsesc(Array.from(argument), options) + ")");
          if ((value => "[object Set]" == toString.call(value))(argument)) return 0 == argument.size ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
          if (isBuffer(argument)) return 0 == argument.length ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
          if (isArray(argument)) return result = [], options.wrap = !0, inline1 && (options.__inline1__ = !1, 
          options.__inline2__ = !0), inline2 || increaseIndentation(), ((array, callback) => {
            const length = array.length;
            let index = -1;
            for (;++index < length; ) callback(array[index]);
          })(argument, (value => {
            isEmpty = !1, inline2 && (options.__inline2__ = !1), result.push((compact || inline2 ? "" : indent) + jsesc(value, options));
          })), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
          if (!(value => "number" == typeof value || "[object Number]" == toString.call(value))(argument)) return (value => "[object Object]" == toString.call(value))(argument) ? (result = [], 
          options.wrap = !0, increaseIndentation(), forOwn(argument, ((key, value) => {
            isEmpty = !1, result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
          })), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}") : json ? JSON.stringify(argument) || "null" : String(argument);
          if (json) return JSON.stringify(argument);
          if (useDecNumbers) return String(argument);
          if (useHexNumbers) {
            let hexadecimal = argument.toString(16);
            return lowercaseHex || (hexadecimal = hexadecimal.toUpperCase()), "0x" + hexadecimal;
          }
          if (useBinNumbers) return "0b" + argument.toString(2);
          if (useOctNumbers) return "0o" + argument.toString(8);
        }
        const string = argument;
        let index = -1;
        const length = string.length;
        for (result = ""; ++index < length; ) {
          const character = string.charAt(index);
          if (options.es6) {
            const first = string.charCodeAt(index);
            if (first >= 55296 && first <= 56319 && length > index + 1) {
              const second = string.charCodeAt(index + 1);
              if (second >= 56320 && second <= 57343) {
                let hexadecimal = (1024 * (first - 55296) + second - 56320 + 65536).toString(16);
                lowercaseHex || (hexadecimal = hexadecimal.toUpperCase()), result += "\\u{" + hexadecimal + "}", 
                ++index;
                continue;
              }
            }
          }
          if (!options.escapeEverything) {
            if (regexWhitelist.test(character)) {
              result += character;
              continue;
            }
            if ('"' == character) {
              result += quote == character ? '\\"' : character;
              continue;
            }
            if ("`" == character) {
              result += quote == character ? "\\`" : character;
              continue;
            }
            if ("'" == character) {
              result += quote == character ? "\\'" : character;
              continue;
            }
          }
          if ("\0" == character && !json && !regexDigit.test(string.charAt(index + 1))) {
            result += "\\0";
            continue;
          }
          if (regexSingleEscape.test(character)) {
            result += singleEscapes[character];
            continue;
          }
          const charCode = character.charCodeAt(0);
          if (options.minimal && 8232 != charCode && 8233 != charCode) {
            result += character;
            continue;
          }
          let hexadecimal = charCode.toString(16);
          lowercaseHex || (hexadecimal = hexadecimal.toUpperCase());
          const longhand = hexadecimal.length > 2 || json, escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
          result += escaped;
        }
        return options.wrap && (result = quote + result + quote), "`" == quote && (result = result.replace(/\$\{/g, "\\${")), 
        options.isScriptContext ? result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--") : result;
      };
      jsesc.version = "2.5.2", module.exports = jsesc;
    },
    1296: module => {
      var reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), objectToString = Object.prototype.toString, nativeMax = Math.max, nativeMin = Math.min, now = function() {
        return root.Date.now();
      };
      function isObject(value) {
        var type = typeof value;
        return !!value && ("object" == type || "function" == type);
      }
      function toNumber(value) {
        if ("number" == typeof value) return value;
        if (function(value) {
          return "symbol" == typeof value || function(value) {
            return !!value && "object" == typeof value;
          }(value) && "[object Symbol]" == objectToString.call(value);
        }(value)) return NaN;
        if (isObject(value)) {
          var other = "function" == typeof value.valueOf ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if ("string" != typeof value) return 0 === value ? value : +value;
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
      }
      module.exports = function(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
        if ("function" != typeof func) throw new TypeError("Expected a function");
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
        }
        function leadingEdge(time) {
          return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime;
          return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) return trailingEdge(time);
          timerId = setTimeout(timerExpired, function(time) {
            var result = wait - (time - lastCallTime);
            return maxing ? nativeMin(result, maxWait - (time - lastInvokeTime)) : result;
          }(time));
        }
        function trailingEdge(time) {
          return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
          result);
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
            if (void 0 === timerId) return leadingEdge(lastCallTime);
            if (maxing) return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
          }
          return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
        }
        return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
        maxWait = (maxing = "maxWait" in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
        trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function() {
          void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
        }, debounced.flush = function() {
          return void 0 === timerId ? result : trailingEdge(now());
        }, debounced;
      };
    },
    7824: module => {
      var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, w = 7 * d, y = 365.25 * d;
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= 1.5 * n;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if ("string" === type && val.length > 0) return function(str) {
          if ((str = String(str)).length > 100) return;
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
          if (!match) return;
          var n = parseFloat(match[1]);
          switch ((match[2] || "ms").toLowerCase()) {
           case "years":
           case "year":
           case "yrs":
           case "yr":
           case "y":
            return n * y;

           case "weeks":
           case "week":
           case "w":
            return n * w;

           case "days":
           case "day":
           case "d":
            return n * d;

           case "hours":
           case "hour":
           case "hrs":
           case "hr":
           case "h":
            return n * h;

           case "minutes":
           case "minute":
           case "mins":
           case "min":
           case "m":
            return n * m;

           case "seconds":
           case "second":
           case "secs":
           case "sec":
           case "s":
            return n * s;

           case "milliseconds":
           case "millisecond":
           case "msecs":
           case "msec":
           case "ms":
            return n;

           default:
            return;
          }
        }(val);
        if ("number" === type && isFinite(val)) return options.long ? function(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) return plural(ms, msAbs, d, "day");
          if (msAbs >= h) return plural(ms, msAbs, h, "hour");
          if (msAbs >= m) return plural(ms, msAbs, m, "minute");
          if (msAbs >= s) return plural(ms, msAbs, s, "second");
          return ms + " ms";
        }(val) : function(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) return Math.round(ms / d) + "d";
          if (msAbs >= h) return Math.round(ms / h) + "h";
          if (msAbs >= m) return Math.round(ms / m) + "m";
          if (msAbs >= s) return Math.round(ms / s) + "s";
          return ms + "ms";
        }(val);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
    },
    762: module => {
      "use strict";
      var isWindows = "win32" === process.platform, splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/, win32 = {};
      win32.parse = function(pathString) {
        if ("string" != typeof pathString) throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
        var filename, allParts = (filename = pathString, splitWindowsRe.exec(filename).slice(1));
        if (!allParts || 5 !== allParts.length) throw new TypeError("Invalid path '" + pathString + "'");
        return {
          root: allParts[1],
          dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
          base: allParts[2],
          ext: allParts[4],
          name: allParts[3]
        };
      };
      var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/, posix = {};
      posix.parse = function(pathString) {
        if ("string" != typeof pathString) throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
        var filename, allParts = (filename = pathString, splitPathRe.exec(filename).slice(1));
        if (!allParts || 5 !== allParts.length) throw new TypeError("Invalid path '" + pathString + "'");
        return {
          root: allParts[1],
          dir: allParts[0].slice(0, -1),
          base: allParts[2],
          ext: allParts[4],
          name: allParts[3]
        };
      }, module.exports = isWindows ? win32.parse : posix.parse, module.exports.posix = posix.parse, 
      module.exports.win32 = win32.parse;
    },
    2781: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var _assert = __webpack_require__(5318)(__webpack_require__(9491)), leap = _interopRequireWildcard(__webpack_require__(6145)), meta = _interopRequireWildcard(__webpack_require__(9084)), util = _interopRequireWildcard(__webpack_require__(4723));
      function _getRequireWildcardCache(nodeInterop) {
        if ("function" != typeof WeakMap) return null;
        var cacheBabelInterop = new WeakMap, cacheNodeInterop = new WeakMap;
        return (_getRequireWildcardCache = function(nodeInterop) {
          return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
      }
      var hasOwn = Object.prototype.hasOwnProperty;
      function Emitter(contextId) {
        _assert.default.ok(this instanceof Emitter), util.getTypes().assertIdentifier(contextId), 
        this.nextTempId = 0, this.contextId = contextId, this.listing = [], this.marked = [ !0 ], 
        this.insertedLocs = new Set, this.finalLoc = this.loc(), this.tryEntries = [], this.leapManager = new leap.LeapManager(this);
      }
      var Ep = Emitter.prototype;
      function getDeclError(node) {
        return new Error("all declarations should have been transformed into assignments before the Exploder began its work: " + JSON.stringify(node));
      }
      exports.Emitter = Emitter, Ep.loc = function() {
        var l = util.getTypes().numericLiteral(-1);
        return this.insertedLocs.add(l), l;
      }, Ep.getInsertedLocs = function() {
        return this.insertedLocs;
      }, Ep.getContextId = function() {
        return util.getTypes().clone(this.contextId);
      }, Ep.mark = function(loc) {
        util.getTypes().assertLiteral(loc);
        var index = this.listing.length;
        return -1 === loc.value ? loc.value = index : _assert.default.strictEqual(loc.value, index), 
        this.marked[index] = !0, loc;
      }, Ep.emit = function(node) {
        var t = util.getTypes();
        t.isExpression(node) && (node = t.expressionStatement(node)), t.assertStatement(node), 
        this.listing.push(node);
      }, Ep.emitAssign = function(lhs, rhs) {
        return this.emit(this.assign(lhs, rhs)), lhs;
      }, Ep.assign = function(lhs, rhs) {
        var t = util.getTypes();
        return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
      }, Ep.contextProperty = function(name, computed) {
        var t = util.getTypes();
        return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
      }, Ep.stop = function(rval) {
        rval && this.setReturnValue(rval), this.jump(this.finalLoc);
      }, Ep.setReturnValue = function(valuePath) {
        util.getTypes().assertExpression(valuePath.value), this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
      }, Ep.clearPendingException = function(tryLoc, assignee) {
        var t = util.getTypes();
        t.assertLiteral(tryLoc);
        var catchCall = t.callExpression(this.contextProperty("catch", !0), [ t.clone(tryLoc) ]);
        assignee ? this.emitAssign(assignee, catchCall) : this.emit(catchCall);
      }, Ep.jump = function(toLoc) {
        this.emitAssign(this.contextProperty("next"), toLoc), this.emit(util.getTypes().breakStatement());
      }, Ep.jumpIf = function(test, toLoc) {
        var t = util.getTypes();
        t.assertExpression(test), t.assertLiteral(toLoc), this.emit(t.ifStatement(test, t.blockStatement([ this.assign(this.contextProperty("next"), toLoc), t.breakStatement() ])));
      }, Ep.jumpIfNot = function(test, toLoc) {
        var negatedTest, t = util.getTypes();
        t.assertExpression(test), t.assertLiteral(toLoc), negatedTest = t.isUnaryExpression(test) && "!" === test.operator ? test.argument : t.unaryExpression("!", test), 
        this.emit(t.ifStatement(negatedTest, t.blockStatement([ this.assign(this.contextProperty("next"), toLoc), t.breakStatement() ])));
      }, Ep.makeTempVar = function() {
        return this.contextProperty("t" + this.nextTempId++);
      }, Ep.getContextFunction = function(id) {
        var t = util.getTypes();
        return t.functionExpression(id || null, [ this.getContextId() ], t.blockStatement([ this.getDispatchLoop() ]), !1, !1);
      }, Ep.getDispatchLoop = function() {
        var current, self = this, t = util.getTypes(), cases = [], alreadyEnded = !1;
        return self.listing.forEach((function(stmt, i) {
          self.marked.hasOwnProperty(i) && (cases.push(t.switchCase(t.numericLiteral(i), current = [])), 
          alreadyEnded = !1), alreadyEnded || (current.push(stmt), t.isCompletionStatement(stmt) && (alreadyEnded = !0));
        })), this.finalLoc.value = this.listing.length, cases.push(t.switchCase(this.finalLoc, []), t.switchCase(t.stringLiteral("end"), [ t.returnStatement(t.callExpression(this.contextProperty("stop"), [])) ])), 
        t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
      }, Ep.getTryLocsList = function() {
        if (0 === this.tryEntries.length) return null;
        var t = util.getTypes(), lastLocValue = 0;
        return t.arrayExpression(this.tryEntries.map((function(tryEntry) {
          var thisLocValue = tryEntry.firstLoc.value;
          _assert.default.ok(thisLocValue >= lastLocValue, "try entries out of order"), lastLocValue = thisLocValue;
          var ce = tryEntry.catchEntry, fe = tryEntry.finallyEntry, locs = [ tryEntry.firstLoc, ce ? ce.firstLoc : null ];
          return fe && (locs[2] = fe.firstLoc, locs[3] = fe.afterLoc), t.arrayExpression(locs.map((function(loc) {
            return loc && t.clone(loc);
          })));
        })));
      }, Ep.explode = function(path, ignoreResult) {
        var t = util.getTypes(), node = path.node;
        if (t.assertNode(node), t.isDeclaration(node)) throw getDeclError(node);
        if (t.isStatement(node)) return this.explodeStatement(path);
        if (t.isExpression(node)) return this.explodeExpression(path, ignoreResult);
        switch (node.type) {
         case "Program":
          return path.get("body").map(this.explodeStatement, this);

         case "VariableDeclarator":
          throw getDeclError(node);

         case "Property":
         case "SwitchCase":
         case "CatchClause":
          throw new Error(node.type + " nodes should be handled by their parents");

         default:
          throw new Error("unknown Node of type " + JSON.stringify(node.type));
        }
      }, Ep.explodeStatement = function(path, labelId) {
        var before, after, head, t = util.getTypes(), stmt = path.node, self = this;
        if (t.assertStatement(stmt), labelId ? t.assertIdentifier(labelId) : labelId = null, 
        t.isBlockStatement(stmt)) path.get("body").forEach((function(path) {
          self.explodeStatement(path);
        })); else if (meta.containsLeap(stmt)) switch (stmt.type) {
         case "ExpressionStatement":
          self.explodeExpression(path.get("expression"), !0);
          break;

         case "LabeledStatement":
          after = this.loc(), self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), (function() {
            self.explodeStatement(path.get("body"), stmt.label);
          })), self.mark(after);
          break;

         case "WhileStatement":
          before = this.loc(), after = this.loc(), self.mark(before), self.jumpIfNot(self.explodeExpression(path.get("test")), after), 
          self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), (function() {
            self.explodeStatement(path.get("body"));
          })), self.jump(before), self.mark(after);
          break;

         case "DoWhileStatement":
          var first = this.loc(), test = this.loc();
          after = this.loc(), self.mark(first), self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), (function() {
            self.explode(path.get("body"));
          })), self.mark(test), self.jumpIf(self.explodeExpression(path.get("test")), first), 
          self.mark(after);
          break;

         case "ForStatement":
          head = this.loc();
          var update = this.loc();
          after = this.loc(), stmt.init && self.explode(path.get("init"), !0), self.mark(head), 
          stmt.test && self.jumpIfNot(self.explodeExpression(path.get("test")), after), self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), (function() {
            self.explodeStatement(path.get("body"));
          })), self.mark(update), stmt.update && self.explode(path.get("update"), !0), self.jump(head), 
          self.mark(after);
          break;

         case "TypeCastExpression":
          return self.explodeExpression(path.get("expression"));

         case "ForInStatement":
          head = this.loc(), after = this.loc();
          var keyIterNextFn = self.makeTempVar();
          self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty("keys"), [ self.explodeExpression(path.get("right")) ])), 
          self.mark(head);
          var keyInfoTmpVar = self.makeTempVar();
          self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), !1), after), 
          self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), !1)), 
          self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), (function() {
            self.explodeStatement(path.get("body"));
          })), self.jump(head), self.mark(after);
          break;

         case "BreakStatement":
          self.emitAbruptCompletion({
            type: "break",
            target: self.leapManager.getBreakLoc(stmt.label)
          });
          break;

         case "ContinueStatement":
          self.emitAbruptCompletion({
            type: "continue",
            target: self.leapManager.getContinueLoc(stmt.label)
          });
          break;

         case "SwitchStatement":
          var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
          after = this.loc();
          for (var defaultLoc = this.loc(), condition = defaultLoc, caseLocs = [], cases = stmt.cases || [], i = cases.length - 1; i >= 0; --i) {
            var c = cases[i];
            t.assertSwitchCase(c), c.test ? condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition) : caseLocs[i] = defaultLoc;
          }
          var discriminant = path.get("discriminant");
          util.replaceWithOrRemove(discriminant, condition), self.jump(self.explodeExpression(discriminant)), 
          self.leapManager.withEntry(new leap.SwitchEntry(after), (function() {
            path.get("cases").forEach((function(casePath) {
              var i = casePath.key;
              self.mark(caseLocs[i]), casePath.get("consequent").forEach((function(path) {
                self.explodeStatement(path);
              }));
            }));
          })), self.mark(after), -1 === defaultLoc.value && (self.mark(defaultLoc), _assert.default.strictEqual(after.value, defaultLoc.value));
          break;

         case "IfStatement":
          var elseLoc = stmt.alternate && this.loc();
          after = this.loc(), self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after), 
          self.explodeStatement(path.get("consequent")), elseLoc && (self.jump(after), self.mark(elseLoc), 
          self.explodeStatement(path.get("alternate"))), self.mark(after);
          break;

         case "ReturnStatement":
          self.emitAbruptCompletion({
            type: "return",
            value: self.explodeExpression(path.get("argument"))
          });
          break;

         case "WithStatement":
          throw new Error("WithStatement not supported in generator functions.");

         case "TryStatement":
          after = this.loc();
          var handler = stmt.handler, catchLoc = handler && this.loc(), catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param), finallyLoc = stmt.finalizer && this.loc(), finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after), tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
          self.tryEntries.push(tryEntry), self.updateContextPrevLoc(tryEntry.firstLoc), self.leapManager.withEntry(tryEntry, (function() {
            if (self.explodeStatement(path.get("block")), catchLoc) {
              finallyLoc ? self.jump(finallyLoc) : self.jump(after), self.updateContextPrevLoc(self.mark(catchLoc));
              var bodyPath = path.get("handler.body"), safeParam = self.makeTempVar();
              self.clearPendingException(tryEntry.firstLoc, safeParam), bodyPath.traverse(catchParamVisitor, {
                getSafeParam: function() {
                  return t.cloneDeep(safeParam);
                },
                catchParamName: handler.param.name
              }), self.leapManager.withEntry(catchEntry, (function() {
                self.explodeStatement(bodyPath);
              }));
            }
            finallyLoc && (self.updateContextPrevLoc(self.mark(finallyLoc)), self.leapManager.withEntry(finallyEntry, (function() {
              self.explodeStatement(path.get("finalizer"));
            })), self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [ finallyEntry.firstLoc ]))));
          })), self.mark(after);
          break;

         case "ThrowStatement":
          self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
          break;

         case "ClassDeclaration":
          self.emit(self.explodeClass(path));
          break;

         default:
          throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
        } else self.emit(stmt);
      };
      var catchParamVisitor = {
        Identifier: function(path, state) {
          path.node.name === state.catchParamName && util.isReference(path) && util.replaceWithOrRemove(path, state.getSafeParam());
        },
        Scope: function(path, state) {
          path.scope.hasOwnBinding(state.catchParamName) && path.skip();
        }
      };
      Ep.emitAbruptCompletion = function(record) {
        (function(record) {
          var type = record.type;
          if ("normal" === type) return !hasOwn.call(record, "target");
          if ("break" === type || "continue" === type) return !hasOwn.call(record, "value") && util.getTypes().isLiteral(record.target);
          if ("return" === type || "throw" === type) return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
          return !1;
        })(record) || _assert.default.ok(!1, "invalid completion record: " + JSON.stringify(record)), 
        _assert.default.notStrictEqual(record.type, "normal", "normal completions are not abrupt");
        var t = util.getTypes(), abruptArgs = [ t.stringLiteral(record.type) ];
        "break" === record.type || "continue" === record.type ? (t.assertLiteral(record.target), 
        abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target)) : "return" !== record.type && "throw" !== record.type || record.value && (t.assertExpression(record.value), 
        abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value)), 
        this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
      }, Ep.getUnmarkedCurrentLoc = function() {
        return util.getTypes().numericLiteral(this.listing.length);
      }, Ep.updateContextPrevLoc = function(loc) {
        var t = util.getTypes();
        loc ? (t.assertLiteral(loc), -1 === loc.value ? loc.value = this.listing.length : _assert.default.strictEqual(loc.value, this.listing.length)) : loc = this.getUnmarkedCurrentLoc(), 
        this.emitAssign(this.contextProperty("prev"), loc);
      }, Ep.explodeViaTempVar = function(tempVar, childPath, hasLeapingChildren, ignoreChildResult) {
        _assert.default.ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to be assigned to a temporary variable?");
        var t = util.getTypes(), result = this.explodeExpression(childPath, ignoreChildResult);
        return ignoreChildResult || (tempVar || hasLeapingChildren && !t.isLiteral(result)) && (result = this.emitAssign(tempVar || this.makeTempVar(), result)), 
        result;
      }, Ep.explodeExpression = function(path, ignoreResult) {
        var t = util.getTypes(), expr = path.node;
        if (!expr) return expr;
        t.assertExpression(expr);
        var result, after, self = this;
        function finish(expr) {
          return t.assertExpression(expr), ignoreResult && self.emit(expr), expr;
        }
        if (!meta.containsLeap(expr)) return finish(expr);
        var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);
        switch (expr.type) {
         case "MemberExpression":
          return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? self.explodeViaTempVar(null, path.get("property"), hasLeapingChildren) : expr.property, expr.computed));

         case "CallExpression":
          var newCallee, newArgs, calleePath = path.get("callee"), argsPath = path.get("arguments"), hasLeapingArgs = argsPath.some((function(argPath) {
            return meta.containsLeap(argPath.node);
          })), injectFirstArg = null;
          if (t.isMemberExpression(calleePath.node)) if (hasLeapingArgs) {
            var newObject = self.explodeViaTempVar(self.makeTempVar(), calleePath.get("object"), hasLeapingChildren), newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get("property"), hasLeapingChildren) : calleePath.node.property;
            injectFirstArg = newObject, newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), !1);
          } else newCallee = self.explodeExpression(calleePath); else newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren), 
          t.isMemberExpression(newCallee) && (newCallee = t.sequenceExpression([ t.numericLiteral(0), t.cloneDeep(newCallee) ]));
          return hasLeapingArgs ? (newArgs = argsPath.map((function(argPath) {
            return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
          })), injectFirstArg && newArgs.unshift(injectFirstArg), newArgs = newArgs.map((function(arg) {
            return t.cloneDeep(arg);
          }))) : newArgs = path.node.arguments, finish(t.callExpression(newCallee, newArgs));

         case "NewExpression":
          return finish(t.newExpression(self.explodeViaTempVar(null, path.get("callee"), hasLeapingChildren), path.get("arguments").map((function(argPath) {
            return self.explodeViaTempVar(null, argPath, hasLeapingChildren);
          }))));

         case "ObjectExpression":
          return finish(t.objectExpression(path.get("properties").map((function(propPath) {
            return propPath.isObjectProperty() ? t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get("value"), hasLeapingChildren), propPath.node.computed) : propPath.node;
          }))));

         case "ArrayExpression":
          return finish(t.arrayExpression(path.get("elements").map((function(elemPath) {
            return elemPath.isSpreadElement() ? t.spreadElement(self.explodeViaTempVar(null, elemPath.get("argument"), hasLeapingChildren)) : self.explodeViaTempVar(null, elemPath, hasLeapingChildren);
          }))));

         case "SequenceExpression":
          var lastIndex = expr.expressions.length - 1;
          return path.get("expressions").forEach((function(exprPath) {
            exprPath.key === lastIndex ? result = self.explodeExpression(exprPath, ignoreResult) : self.explodeExpression(exprPath, !0);
          })), result;

         case "LogicalExpression":
          after = this.loc(), ignoreResult || (result = self.makeTempVar());
          var left = self.explodeViaTempVar(result, path.get("left"), hasLeapingChildren);
          return "&&" === expr.operator ? self.jumpIfNot(left, after) : (_assert.default.strictEqual(expr.operator, "||"), 
          self.jumpIf(left, after)), self.explodeViaTempVar(result, path.get("right"), hasLeapingChildren, ignoreResult), 
          self.mark(after), result;

         case "ConditionalExpression":
          var elseLoc = this.loc();
          after = this.loc();
          var test = self.explodeExpression(path.get("test"));
          return self.jumpIfNot(test, elseLoc), ignoreResult || (result = self.makeTempVar()), 
          self.explodeViaTempVar(result, path.get("consequent"), hasLeapingChildren, ignoreResult), 
          self.jump(after), self.mark(elseLoc), self.explodeViaTempVar(result, path.get("alternate"), hasLeapingChildren, ignoreResult), 
          self.mark(after), result;

         case "UnaryExpression":
          return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));

         case "BinaryExpression":
          return finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get("left"), hasLeapingChildren), self.explodeViaTempVar(null, path.get("right"), hasLeapingChildren)));

         case "AssignmentExpression":
          if ("=" === expr.operator) return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
          var lhs = self.explodeExpression(path.get("left")), temp = self.emitAssign(self.makeTempVar(), lhs);
          return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

         case "UpdateExpression":
          return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

         case "YieldExpression":
          after = this.loc();
          var arg = expr.argument && self.explodeExpression(path.get("argument"));
          if (arg && expr.delegate) {
            var _result = self.makeTempVar(), _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [ arg, t.stringLiteral(_result.property.name), after ]));
            return _ret.loc = expr.loc, self.emit(_ret), self.mark(after), _result;
          }
          self.emitAssign(self.contextProperty("next"), after);
          var ret = t.returnStatement(t.cloneDeep(arg) || null);
          return ret.loc = expr.loc, self.emit(ret), self.mark(after), self.contextProperty("sent");

         case "ClassExpression":
          return finish(self.explodeClass(path));

         default:
          throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
        }
      }, Ep.explodeClass = function(path) {
        var explodingChildren = [];
        path.node.superClass && explodingChildren.push(path.get("superClass")), path.get("body.body").forEach((function(member) {
          member.node.computed && explodingChildren.push(member.get("key"));
        }));
        for (var hasLeapingChildren = explodingChildren.some((function(child) {
          return meta.containsLeap(child);
        })), i = 0; i < explodingChildren.length; i++) {
          var child = explodingChildren[i];
          i === explodingChildren.length - 1 ? child.replaceWith(this.explodeExpression(child)) : child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));
        }
        return path.node;
      };
    },
    5477: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var util = function(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4723));
      function _getRequireWildcardCache(nodeInterop) {
        if ("function" != typeof WeakMap) return null;
        var cacheBabelInterop = new WeakMap, cacheNodeInterop = new WeakMap;
        return (_getRequireWildcardCache = function(nodeInterop) {
          return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      var hasOwn = Object.prototype.hasOwnProperty;
      exports.hoist = function(funPath) {
        var t = util.getTypes();
        t.assertFunction(funPath.node);
        var vars = {};
        function varDeclToExpr(_ref, includeIdentifiers) {
          var vdec = _ref.node, scope = _ref.scope;
          t.assertVariableDeclaration(vdec);
          var exprs = [];
          return vdec.declarations.forEach((function(dec) {
            vars[dec.id.name] = t.identifier(dec.id.name), scope.removeBinding(dec.id.name), 
            dec.init ? exprs.push(t.assignmentExpression("=", dec.id, dec.init)) : includeIdentifiers && exprs.push(dec.id);
          })), 0 === exprs.length ? null : 1 === exprs.length ? exprs[0] : t.sequenceExpression(exprs);
        }
        funPath.get("body").traverse({
          VariableDeclaration: {
            exit: function(path) {
              var expr = varDeclToExpr(path, !1);
              null === expr ? path.remove() : util.replaceWithOrRemove(path, t.expressionStatement(expr)), 
              path.skip();
            }
          },
          ForStatement: function(path) {
            var init = path.get("init");
            init.isVariableDeclaration() && util.replaceWithOrRemove(init, varDeclToExpr(init, !1));
          },
          ForXStatement: function(path) {
            var left = path.get("left");
            left.isVariableDeclaration() && util.replaceWithOrRemove(left, varDeclToExpr(left, !0));
          },
          FunctionDeclaration: function(path) {
            var node = path.node;
            vars[node.id.name] = node.id;
            var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
            path.parentPath.isBlockStatement() ? (path.parentPath.unshiftContainer("body", assignment), 
            path.remove()) : util.replaceWithOrRemove(path, assignment), path.scope.removeBinding(node.id.name), 
            path.skip();
          },
          FunctionExpression: function(path) {
            path.skip();
          },
          ArrowFunctionExpression: function(path) {
            path.skip();
          }
        });
        var paramNames = {};
        funPath.get("params").forEach((function(paramPath) {
          var param = paramPath.node;
          t.isIdentifier(param) && (paramNames[param.name] = param);
        }));
        var declarations = [];
        return Object.keys(vars).forEach((function(name) {
          hasOwn.call(paramNames, name) || declarations.push(t.variableDeclarator(vars[name], null));
        })), 0 === declarations.length ? null : t.variableDeclaration("var", declarations);
      };
    },
    5833: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(context) {
        var plugin = {
          visitor: (0, _visit.getVisitor)(context)
        }, version = context && context.version;
        version && parseInt(version, 10) >= 7 && (plugin.name = "regenerator-transform");
        return plugin;
      };
      var _visit = __webpack_require__(4218);
    },
    6145: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var _assert = __webpack_require__(5318)(__webpack_require__(9491)), _emit = __webpack_require__(2781), _util = __webpack_require__(3837), _util2 = __webpack_require__(4723);
      function Entry() {
        _assert.default.ok(this instanceof Entry);
      }
      function FunctionEntry(returnLoc) {
        Entry.call(this), (0, _util2.getTypes)().assertLiteral(returnLoc), this.returnLoc = returnLoc;
      }
      function LoopEntry(breakLoc, continueLoc, label) {
        Entry.call(this);
        var t = (0, _util2.getTypes)();
        t.assertLiteral(breakLoc), t.assertLiteral(continueLoc), label ? t.assertIdentifier(label) : label = null, 
        this.breakLoc = breakLoc, this.continueLoc = continueLoc, this.label = label;
      }
      function SwitchEntry(breakLoc) {
        Entry.call(this), (0, _util2.getTypes)().assertLiteral(breakLoc), this.breakLoc = breakLoc;
      }
      function TryEntry(firstLoc, catchEntry, finallyEntry) {
        Entry.call(this), (0, _util2.getTypes)().assertLiteral(firstLoc), catchEntry ? _assert.default.ok(catchEntry instanceof CatchEntry) : catchEntry = null, 
        finallyEntry ? _assert.default.ok(finallyEntry instanceof FinallyEntry) : finallyEntry = null, 
        _assert.default.ok(catchEntry || finallyEntry), this.firstLoc = firstLoc, this.catchEntry = catchEntry, 
        this.finallyEntry = finallyEntry;
      }
      function CatchEntry(firstLoc, paramId) {
        Entry.call(this);
        var t = (0, _util2.getTypes)();
        t.assertLiteral(firstLoc), t.assertIdentifier(paramId), this.firstLoc = firstLoc, 
        this.paramId = paramId;
      }
      function FinallyEntry(firstLoc, afterLoc) {
        Entry.call(this);
        var t = (0, _util2.getTypes)();
        t.assertLiteral(firstLoc), t.assertLiteral(afterLoc), this.firstLoc = firstLoc, 
        this.afterLoc = afterLoc;
      }
      function LabeledEntry(breakLoc, label) {
        Entry.call(this);
        var t = (0, _util2.getTypes)();
        t.assertLiteral(breakLoc), t.assertIdentifier(label), this.breakLoc = breakLoc, 
        this.label = label;
      }
      function LeapManager(emitter) {
        _assert.default.ok(this instanceof LeapManager), _assert.default.ok(emitter instanceof _emit.Emitter), 
        this.emitter = emitter, this.entryStack = [ new FunctionEntry(emitter.finalLoc) ];
      }
      (0, _util.inherits)(FunctionEntry, Entry), exports.FunctionEntry = FunctionEntry, 
      (0, _util.inherits)(LoopEntry, Entry), exports.LoopEntry = LoopEntry, (0, _util.inherits)(SwitchEntry, Entry), 
      exports.SwitchEntry = SwitchEntry, (0, _util.inherits)(TryEntry, Entry), exports.TryEntry = TryEntry, 
      (0, _util.inherits)(CatchEntry, Entry), exports.CatchEntry = CatchEntry, (0, _util.inherits)(FinallyEntry, Entry), 
      exports.FinallyEntry = FinallyEntry, (0, _util.inherits)(LabeledEntry, Entry), exports.LabeledEntry = LabeledEntry;
      var LMp = LeapManager.prototype;
      exports.LeapManager = LeapManager, LMp.withEntry = function(entry, callback) {
        _assert.default.ok(entry instanceof Entry), this.entryStack.push(entry);
        try {
          callback.call(this.emitter);
        } finally {
          var popped = this.entryStack.pop();
          _assert.default.strictEqual(popped, entry);
        }
      }, LMp._findLeapLocation = function(property, label) {
        for (var i = this.entryStack.length - 1; i >= 0; --i) {
          var entry = this.entryStack[i], loc = entry[property];
          if (loc) if (label) {
            if (entry.label && entry.label.name === label.name) return loc;
          } else if (!(entry instanceof LabeledEntry)) return loc;
        }
        return null;
      }, LMp.getBreakLoc = function(label) {
        return this._findLeapLocation("breakLoc", label);
      }, LMp.getContinueLoc = function(label) {
        return this._findLeapLocation("continueLoc", label);
      };
    },
    9084: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var _assert = __webpack_require__(5318)(__webpack_require__(9491)), _util = __webpack_require__(4723), mMap = new WeakMap;
      var hasOwn = Object.prototype.hasOwnProperty;
      function makePredicate(propertyName, knownTypes) {
        function onlyChildren(node) {
          var t = (0, _util.getTypes)();
          t.assertNode(node);
          var result = !1;
          function check(child) {
            return result || (Array.isArray(child) ? child.some(check) : t.isNode(child) && (_assert.default.strictEqual(result, !1), 
            result = predicate(child))), result;
          }
          var keys = t.VISITOR_KEYS[node.type];
          if (keys) for (var i = 0; i < keys.length; i++) {
            check(node[keys[i]]);
          }
          return result;
        }
        function predicate(node) {
          (0, _util.getTypes)().assertNode(node);
          var meta = function(node) {
            return mMap.has(node) || mMap.set(node, {}), mMap.get(node);
          }(node);
          return hasOwn.call(meta, propertyName) ? meta[propertyName] : hasOwn.call(opaqueTypes, node.type) ? meta[propertyName] = !1 : hasOwn.call(knownTypes, node.type) ? meta[propertyName] = !0 : meta[propertyName] = onlyChildren(node);
        }
        return predicate.onlyChildren = onlyChildren, predicate;
      }
      var opaqueTypes = {
        FunctionExpression: !0,
        ArrowFunctionExpression: !0
      }, sideEffectTypes = {
        CallExpression: !0,
        ForInStatement: !0,
        UnaryExpression: !0,
        BinaryExpression: !0,
        AssignmentExpression: !0,
        UpdateExpression: !0,
        NewExpression: !0
      }, leapTypes = {
        YieldExpression: !0,
        BreakStatement: !0,
        ContinueStatement: !0,
        ReturnStatement: !0,
        ThrowStatement: !0
      };
      for (var type in leapTypes) hasOwn.call(leapTypes, type) && (sideEffectTypes[type] = leapTypes[type]);
      exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes), exports.containsLeap = makePredicate("containsLeap", leapTypes);
    },
    9457: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.default = function(path) {
        var t = util.getTypes();
        if (!path.node || !t.isFunction(path.node)) throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
        if (!t.isObjectMethod(path.node)) return path;
        if (!path.node.generator) return path;
        var parameters = path.node.params.map((function(param) {
          return t.cloneDeep(param);
        })), functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
        return util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, !1)), 
        path.get("value");
      };
      var util = function(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4723));
      function _getRequireWildcardCache(nodeInterop) {
        if ("function" != typeof WeakMap) return null;
        var cacheBabelInterop = new WeakMap, cacheNodeInterop = new WeakMap;
        return (_getRequireWildcardCache = function(nodeInterop) {
          return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
    },
    4723: (__unused_webpack_module, exports) => {
      "use strict";
      exports.__esModule = !0, exports.wrapWithTypes = function(types, fn) {
        return function() {
          var oldTypes = currentTypes;
          currentTypes = types;
          try {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return fn.apply(this, args);
          } finally {
            currentTypes = oldTypes;
          }
        };
      }, exports.getTypes = getTypes, exports.runtimeProperty = function(name) {
        var t = getTypes();
        return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), !1);
      }, exports.isReference = function(path) {
        return path.isReferenced() || path.parentPath.isAssignmentExpression({
          left: path.node
        });
      }, exports.replaceWithOrRemove = function(path, replacement) {
        replacement ? path.replaceWith(replacement) : path.remove();
      };
      var currentTypes = null;
      function getTypes() {
        return currentTypes;
      }
    },
    4218: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      var _interopRequireDefault = __webpack_require__(5318), _assert = _interopRequireDefault(__webpack_require__(9491)), _hoist = __webpack_require__(5477), _emit = __webpack_require__(2781), _replaceShorthandObjectMethod = _interopRequireDefault(__webpack_require__(9457)), util = function(obj, nodeInterop) {
        if (!nodeInterop && obj && obj.__esModule) return obj;
        if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
          default: obj
        };
        var cache = _getRequireWildcardCache(nodeInterop);
        if (cache && cache.has(obj)) return cache.get(obj);
        var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
        }
        newObj.default = obj, cache && cache.set(obj, newObj);
        return newObj;
      }(__webpack_require__(4723));
      function _getRequireWildcardCache(nodeInterop) {
        if ("function" != typeof WeakMap) return null;
        var cacheBabelInterop = new WeakMap, cacheNodeInterop = new WeakMap;
        return (_getRequireWildcardCache = function(nodeInterop) {
          return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function shouldRegenerate(node, state) {
        return node.generator ? node.async ? !1 !== state.opts.asyncGenerators : !1 !== state.opts.generators : !!node.async && !1 !== state.opts.async;
      }
      exports.getVisitor = function(_ref) {
        var t = _ref.types;
        return {
          Method: function(path, state) {
            var node = path.node;
            if (shouldRegenerate(node, state)) {
              var container = t.functionExpression(null, [], t.cloneNode(node.body, !1), node.generator, node.async);
              path.get("body").set("body", [ t.returnStatement(t.callExpression(container, [])) ]), 
              node.async = !1, node.generator = !1, path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
            }
          },
          Function: {
            exit: util.wrapWithTypes(t, (function(path, state) {
              var node = path.node;
              if (shouldRegenerate(node, state)) {
                node = (path = (0, _replaceShorthandObjectMethod.default)(path)).node;
                var contextId = path.scope.generateUidIdentifier("context"), argsId = path.scope.generateUidIdentifier("args");
                path.ensureBlock();
                var bodyBlockPath = path.get("body");
                node.async && bodyBlockPath.traverse(awaitVisitor), bodyBlockPath.traverse(functionSentVisitor, {
                  context: contextId
                });
                var outerBody = [], innerBody = [];
                bodyBlockPath.get("body").forEach((function(childPath) {
                  var node = childPath.node;
                  t.isExpressionStatement(node) && t.isStringLiteral(node.expression) || node && null != node._blockHoist ? outerBody.push(node) : innerBody.push(node);
                })), outerBody.length > 0 && (bodyBlockPath.node.body = innerBody);
                var outerFnExpr = function(funPath) {
                  var t = util.getTypes(), node = funPath.node;
                  t.assertFunction(node), node.id || (node.id = funPath.scope.parent.generateUidIdentifier("callee"));
                  if (node.generator && t.isFunctionDeclaration(node)) return function(funPath) {
                    var t = util.getTypes(), node = funPath.node;
                    t.assertIdentifier(node.id);
                    var blockPath = funPath.findParent((function(path) {
                      return path.isProgram() || path.isBlockStatement();
                    }));
                    if (!blockPath) return node.id;
                    var block = blockPath.node;
                    _assert.default.ok(Array.isArray(block.body));
                    var info = function(node) {
                      markInfo.has(node) || markInfo.set(node, {});
                      return markInfo.get(node);
                    }(block);
                    info.decl || (info.decl = t.variableDeclaration("var", []), blockPath.unshiftContainer("body", info.decl), 
                    info.declPath = blockPath.get("body.0"));
                    _assert.default.strictEqual(info.declPath.node, info.decl);
                    var markedId = blockPath.scope.generateUidIdentifier("marked"), markCallExp = t.callExpression(util.runtimeProperty("mark"), [ t.clone(node.id) ]), index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1, markCallExpPath = info.declPath.get("declarations." + index + ".init");
                    return _assert.default.strictEqual(markCallExpPath.node, markCallExp), markCallExpPath.addComment("leading", "#__PURE__"), 
                    t.clone(markedId);
                  }(funPath);
                  return t.clone(node.id);
                }(path);
                t.assertIdentifier(node.id);
                var innerFnId = t.identifier(node.id.name + "$"), vars = (0, _hoist.hoist)(path), context = {
                  usesThis: !1,
                  usesArguments: !1,
                  getArgsId: function() {
                    return t.clone(argsId);
                  }
                };
                path.traverse(argumentsThisVisitor, context), context.usesArguments && (vars = vars || t.variableDeclaration("var", [])).declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")));
                var emitter = new _emit.Emitter(contextId);
                emitter.explode(path.get("body")), vars && vars.declarations.length > 0 && outerBody.push(vars);
                var wrapArgs = [ emitter.getContextFunction(innerFnId) ], tryLocsList = emitter.getTryLocsList();
                if (node.generator ? wrapArgs.push(outerFnExpr) : (context.usesThis || tryLocsList || node.async) && wrapArgs.push(t.nullLiteral()), 
                context.usesThis ? wrapArgs.push(t.thisExpression()) : (tryLocsList || node.async) && wrapArgs.push(t.nullLiteral()), 
                tryLocsList ? wrapArgs.push(tryLocsList) : node.async && wrapArgs.push(t.nullLiteral()), 
                node.async) {
                  var currentScope = path.scope;
                  do {
                    currentScope.hasOwnBinding("Promise") && currentScope.rename("Promise");
                  } while (currentScope = currentScope.parent);
                  wrapArgs.push(t.identifier("Promise"));
                }
                var wrapCall = t.callExpression(util.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
                outerBody.push(t.returnStatement(wrapCall)), node.body = t.blockStatement(outerBody), 
                path.get("body.body").forEach((function(p) {
                  return p.scope.registerDeclaration(p);
                }));
                var oldDirectives = bodyBlockPath.node.directives;
                oldDirectives && (node.body.directives = oldDirectives);
                var wasGeneratorFunction = node.generator;
                wasGeneratorFunction && (node.generator = !1), node.async && (node.async = !1), 
                wasGeneratorFunction && t.isExpression(node) && (util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty("mark"), [ node ])), 
                path.addComment("leading", "#__PURE__"));
                var insertedLocs = emitter.getInsertedLocs();
                path.traverse({
                  NumericLiteral: function(path) {
                    insertedLocs.has(path.node) && path.replaceWith(t.numericLiteral(path.node.value));
                  }
                }), path.requeue();
              }
            }))
          }
        };
      };
      var markInfo = new WeakMap;
      var argumentsThisVisitor = {
        "FunctionExpression|FunctionDeclaration|Method": function(path) {
          path.skip();
        },
        Identifier: function(path, state) {
          "arguments" === path.node.name && util.isReference(path) && (util.replaceWithOrRemove(path, state.getArgsId()), 
          state.usesArguments = !0);
        },
        ThisExpression: function(path, state) {
          state.usesThis = !0;
        }
      }, functionSentVisitor = {
        MetaProperty: function(path) {
          var node = path.node;
          if ("function" === node.meta.name && "sent" === node.property.name) {
            var t = util.getTypes();
            util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
          }
        }
      }, awaitVisitor = {
        Function: function(path) {
          path.skip();
        },
        AwaitExpression: function(path) {
          var t = util.getTypes(), argument = path.node.argument;
          util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty("awrap"), [ argument ]), !1));
        }
      };
    },
    6313: (module, __unused_webpack_exports, __webpack_require__) => {
      var async = __webpack_require__(8821);
      async.core = __webpack_require__(6610), async.isCore = __webpack_require__(206), 
      async.sync = __webpack_require__(6406), module.exports = async;
    },
    8821: (module, __unused_webpack_exports, __webpack_require__) => {
      var fs = __webpack_require__(7147), path = __webpack_require__(1017), caller = __webpack_require__(6628), nodeModulesPaths = __webpack_require__(3754), normalizeOptions = __webpack_require__(5031), isCore = __webpack_require__(8295), realpathFS = fs.realpath && "function" == typeof fs.realpath.native ? fs.realpath.native : fs.realpath, defaultIsFile = function(file, cb) {
        fs.stat(file, (function(err, stat) {
          return err ? "ENOENT" === err.code || "ENOTDIR" === err.code ? cb(null, !1) : cb(err) : cb(null, stat.isFile() || stat.isFIFO());
        }));
      }, defaultIsDir = function(dir, cb) {
        fs.stat(dir, (function(err, stat) {
          return err ? "ENOENT" === err.code || "ENOTDIR" === err.code ? cb(null, !1) : cb(err) : cb(null, stat.isDirectory());
        }));
      }, defaultRealpath = function(x, cb) {
        realpathFS(x, (function(realpathErr, realPath) {
          realpathErr && "ENOENT" !== realpathErr.code ? cb(realpathErr) : cb(null, realpathErr ? x : realPath);
        }));
      }, maybeRealpath = function(realpath, x, opts, cb) {
        opts && !1 === opts.preserveSymlinks ? realpath(x, cb) : cb(null, x);
      }, defaultReadPackage = function(readFile, pkgfile, cb) {
        readFile(pkgfile, (function(readFileErr, body) {
          if (readFileErr) cb(readFileErr); else try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }));
      };
      module.exports = function(x, options, callback) {
        var cb = callback, opts = options;
        if ("function" == typeof options && (cb = opts, opts = {}), "string" != typeof x) {
          var err = new TypeError("Path must be a string.");
          return process.nextTick((function() {
            cb(err);
          }));
        }
        var isFile = (opts = normalizeOptions(x, opts)).isFile || defaultIsFile, isDirectory = opts.isDirectory || defaultIsDir, readFile = opts.readFile || fs.readFile, realpath = opts.realpath || defaultRealpath, readPackage = opts.readPackage || defaultReadPackage;
        if (opts.readFile && opts.readPackage) {
          var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
          return process.nextTick((function() {
            cb(conflictErr);
          }));
        }
        var packageIterator = opts.packageIterator, extensions = opts.extensions || [ ".js" ], includeCoreModules = !1 !== opts.includeCoreModules, basedir = opts.basedir || path.dirname(caller()), parent = opts.filename || basedir;
        opts.paths = opts.paths || [];
        var res, absoluteStart = path.resolve(basedir);
        function onfile(err, m, pkg) {
          err ? cb(err) : m ? cb(null, m, pkg) : loadAsDirectory(res, (function(err, d, pkg) {
            if (err) cb(err); else if (d) maybeRealpath(realpath, d, opts, (function(err, realD) {
              err ? cb(err) : cb(null, realD, pkg);
            })); else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND", cb(moduleError);
            }
          }));
        }
        function loadAsFile(x, thePackage, callback) {
          var loadAsFilePackage = thePackage, cb = callback;
          "function" == typeof loadAsFilePackage && (cb = loadAsFilePackage, loadAsFilePackage = void 0), 
          function load(exts, x, loadPackage) {
            if (0 === exts.length) return cb(null, void 0, loadPackage);
            var file = x + exts[0], pkg = loadPackage;
            pkg ? onpkg(null, pkg) : loadpkg(path.dirname(file), onpkg);
            function onpkg(err, pkg_, dir) {
              if (pkg = pkg_, err) return cb(err);
              if (dir && pkg && opts.pathFilter) {
                var rfile = path.relative(dir, file), rel = rfile.slice(0, rfile.length - exts[0].length), r = opts.pathFilter(pkg, x, rel);
                if (r) return load([ "" ].concat(extensions.slice()), path.resolve(dir, r), pkg);
              }
              isFile(file, onex);
            }
            function onex(err, ex) {
              return err ? cb(err) : ex ? cb(null, file, pkg) : void load(exts.slice(1), x, pkg);
            }
          }([ "" ].concat(extensions), x, loadAsFilePackage);
        }
        function loadpkg(dir, cb) {
          return "" === dir || "/" === dir || "win32" === process.platform && /^\w:[/\\]*$/.test(dir) || /[/\\]node_modules[/\\]*$/.test(dir) ? cb(null) : void maybeRealpath(realpath, dir, opts, (function(unwrapErr, pkgdir) {
            if (unwrapErr) return loadpkg(path.dirname(dir), cb);
            var pkgfile = path.join(pkgdir, "package.json");
            isFile(pkgfile, (function(err, ex) {
              if (!ex) return loadpkg(path.dirname(dir), cb);
              readPackage(readFile, pkgfile, (function(err, pkgParam) {
                err && cb(err);
                var pkg = pkgParam;
                pkg && opts.packageFilter && (pkg = opts.packageFilter(pkg, pkgfile)), cb(null, pkg, dir);
              }));
            }));
          }));
        }
        function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
          var cb = callback, fpkg = loadAsDirectoryPackage;
          "function" == typeof fpkg && (cb = fpkg, fpkg = opts.package), maybeRealpath(realpath, x, opts, (function(unwrapErr, pkgdir) {
            if (unwrapErr) return cb(unwrapErr);
            var pkgfile = path.join(pkgdir, "package.json");
            isFile(pkgfile, (function(err, ex) {
              return err ? cb(err) : ex ? void readPackage(readFile, pkgfile, (function(err, pkgParam) {
                if (err) return cb(err);
                var pkg = pkgParam;
                if (pkg && opts.packageFilter && (pkg = opts.packageFilter(pkg, pkgfile)), pkg && pkg.main) {
                  if ("string" != typeof pkg.main) {
                    var mainError = new TypeError("package " + pkg.name + " `main` must be a string");
                    return mainError.code = "INVALID_PACKAGE_MAIN", cb(mainError);
                  }
                  return "." !== pkg.main && "./" !== pkg.main || (pkg.main = "index"), void loadAsFile(path.resolve(x, pkg.main), pkg, (function(err, m, pkg) {
                    return err ? cb(err) : m ? cb(null, m, pkg) : pkg ? void loadAsDirectory(path.resolve(x, pkg.main), pkg, (function(err, n, pkg) {
                      return err ? cb(err) : n ? cb(null, n, pkg) : void loadAsFile(path.join(x, "index"), pkg, cb);
                    })) : loadAsFile(path.join(x, "index"), pkg, cb);
                  }));
                }
                loadAsFile(path.join(x, "/index"), pkg, cb);
              })) : loadAsFile(path.join(x, "index"), fpkg, cb);
            }));
          }));
        }
        function processDirs(cb, dirs) {
          if (0 === dirs.length) return cb(null, void 0);
          var dir = dirs[0];
          function onfile(err, m, pkg) {
            return err ? cb(err) : m ? cb(null, m, pkg) : void loadAsDirectory(dir, opts.package, ondir);
          }
          function ondir(err, n, pkg) {
            return err ? cb(err) : n ? cb(null, n, pkg) : void processDirs(cb, dirs.slice(1));
          }
          isDirectory(path.dirname(dir), (function(err, isdir) {
            if (err) return cb(err);
            if (!isdir) return processDirs(cb, dirs.slice(1));
            loadAsFile(dir, opts.package, onfile);
          }));
        }
        maybeRealpath(realpath, absoluteStart, opts, (function(err, realStart) {
          err ? cb(err) : function(basedir) {
            if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) res = path.resolve(basedir, x), 
            "." !== x && ".." !== x && "/" !== x.slice(-1) || (res += "/"), /\/$/.test(x) && res === basedir ? loadAsDirectory(res, opts.package, onfile) : loadAsFile(res, opts.package, onfile); else {
              if (includeCoreModules && isCore(x)) return cb(null, x);
              !function(x, start, cb) {
                var thunk = function() {
                  return function(x, start, opts) {
                    for (var dirs = nodeModulesPaths(start, opts, x), i = 0; i < dirs.length; i++) dirs[i] = path.join(dirs[i], x);
                    return dirs;
                  }(x, start, opts);
                };
                processDirs(cb, packageIterator ? packageIterator(x, start, thunk, opts) : thunk());
              }(x, basedir, (function(err, n, pkg) {
                if (err) cb(err); else {
                  if (n) return maybeRealpath(realpath, n, opts, (function(err, realN) {
                    err ? cb(err) : cb(null, realN, pkg);
                  }));
                  var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                  moduleError.code = "MODULE_NOT_FOUND", cb(moduleError);
                }
              }));
            }
          }(realStart);
        }));
      };
    },
    6628: module => {
      module.exports = function() {
        var origPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = function(_, stack) {
          return stack;
        };
        var stack = (new Error).stack;
        return Error.prepareStackTrace = origPrepareStackTrace, stack[2].getFileName();
      };
    },
    6610: (module, __unused_webpack_exports, __webpack_require__) => {
      var current = process.versions && process.versions.node && process.versions.node.split(".") || [];
      function specifierIncluded(specifier) {
        for (var parts = specifier.split(" "), op = parts.length > 1 ? parts[0] : "=", versionParts = (parts.length > 1 ? parts[1] : parts[0]).split("."), i = 0; i < 3; ++i) {
          var cur = parseInt(current[i] || 0, 10), ver = parseInt(versionParts[i] || 0, 10);
          if (cur !== ver) return "<" === op ? cur < ver : ">=" === op && cur >= ver;
        }
        return ">=" === op;
      }
      function matchesRange(range) {
        var specifiers = range.split(/ ?&& ?/);
        if (0 === specifiers.length) return !1;
        for (var i = 0; i < specifiers.length; ++i) if (!specifierIncluded(specifiers[i])) return !1;
        return !0;
      }
      function versionIncluded(specifierValue) {
        if ("boolean" == typeof specifierValue) return specifierValue;
        if (specifierValue && "object" == typeof specifierValue) {
          for (var i = 0; i < specifierValue.length; ++i) if (matchesRange(specifierValue[i])) return !0;
          return !1;
        }
        return matchesRange(specifierValue);
      }
      var data = __webpack_require__(4503), core = {};
      for (var mod in data) Object.prototype.hasOwnProperty.call(data, mod) && (core[mod] = versionIncluded(data[mod]));
      module.exports = core;
    },
    206: (module, __unused_webpack_exports, __webpack_require__) => {
      var isCoreModule = __webpack_require__(8295);
      module.exports = function(x) {
        return isCoreModule(x);
      };
    },
    3754: (module, __unused_webpack_exports, __webpack_require__) => {
      var path = __webpack_require__(1017), parse = path.parse || __webpack_require__(762), getNodeModulesDirs = function(absoluteStart, modules) {
        var prefix = "/";
        /^([A-Za-z]:)/.test(absoluteStart) ? prefix = "" : /^\\\\/.test(absoluteStart) && (prefix = "\\\\");
        for (var paths = [ absoluteStart ], parsed = parse(absoluteStart); parsed.dir !== paths[paths.length - 1]; ) paths.push(parsed.dir), 
        parsed = parse(parsed.dir);
        return paths.reduce((function(dirs, aPath) {
          return dirs.concat(modules.map((function(moduleDir) {
            return path.resolve(prefix, aPath, moduleDir);
          })));
        }), []);
      };
      module.exports = function(start, opts, request) {
        var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : [ "node_modules" ];
        if (opts && "function" == typeof opts.paths) return opts.paths(request, start, (function() {
          return getNodeModulesDirs(start, modules);
        }), opts);
        var dirs = getNodeModulesDirs(start, modules);
        return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
      };
    },
    5031: module => {
      module.exports = function(x, opts) {
        return opts || {};
      };
    },
    6406: (module, __unused_webpack_exports, __webpack_require__) => {
      var isCore = __webpack_require__(8295), fs = __webpack_require__(7147), path = __webpack_require__(1017), caller = __webpack_require__(6628), nodeModulesPaths = __webpack_require__(3754), normalizeOptions = __webpack_require__(5031), realpathFS = fs.realpathSync && "function" == typeof fs.realpathSync.native ? fs.realpathSync.native : fs.realpathSync, defaultIsFile = function(file) {
        try {
          var stat = fs.statSync(file);
        } catch (e) {
          if (e && ("ENOENT" === e.code || "ENOTDIR" === e.code)) return !1;
          throw e;
        }
        return stat.isFile() || stat.isFIFO();
      }, defaultIsDir = function(dir) {
        try {
          var stat = fs.statSync(dir);
        } catch (e) {
          if (e && ("ENOENT" === e.code || "ENOTDIR" === e.code)) return !1;
          throw e;
        }
        return stat.isDirectory();
      }, defaultRealpathSync = function(x) {
        try {
          return realpathFS(x);
        } catch (realpathErr) {
          if ("ENOENT" !== realpathErr.code) throw realpathErr;
        }
        return x;
      }, maybeRealpathSync = function(realpathSync, x, opts) {
        return opts && !1 === opts.preserveSymlinks ? realpathSync(x) : x;
      }, defaultReadPackageSync = function(readFileSync, pkgfile) {
        var body = readFileSync(pkgfile);
        try {
          return JSON.parse(body);
        } catch (jsonErr) {}
      };
      module.exports = function(x, options) {
        if ("string" != typeof x) throw new TypeError("Path must be a string.");
        var opts = normalizeOptions(x, options), isFile = opts.isFile || defaultIsFile, readFileSync = opts.readFileSync || fs.readFileSync, isDirectory = opts.isDirectory || defaultIsDir, realpathSync = opts.realpathSync || defaultRealpathSync, readPackageSync = opts.readPackageSync || defaultReadPackageSync;
        if (opts.readFileSync && opts.readPackageSync) throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
        var packageIterator = opts.packageIterator, extensions = opts.extensions || [ ".js" ], includeCoreModules = !1 !== opts.includeCoreModules, basedir = opts.basedir || path.dirname(caller()), parent = opts.filename || basedir;
        opts.paths = opts.paths || [];
        var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          var res = path.resolve(absoluteStart, x);
          "." !== x && ".." !== x && "/" !== x.slice(-1) || (res += "/");
          var m = loadAsFileSync(res) || loadAsDirectorySync(res);
          if (m) return maybeRealpathSync(realpathSync, m, opts);
        } else {
          if (includeCoreModules && isCore(x)) return x;
          var n = function(x, start) {
            for (var thunk = function() {
              return function(x, start, opts) {
                for (var dirs = nodeModulesPaths(start, opts, x), i = 0; i < dirs.length; i++) dirs[i] = path.join(dirs[i], x);
                return dirs;
              }(x, start, opts);
            }, dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk(), i = 0; i < dirs.length; i++) {
              var dir = dirs[i];
              if (isDirectory(path.dirname(dir))) {
                var m = loadAsFileSync(dir);
                if (m) return m;
                var n = loadAsDirectorySync(dir);
                if (n) return n;
              }
            }
          }(x, absoluteStart);
          if (n) return maybeRealpathSync(realpathSync, n, opts);
        }
        var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
        throw err.code = "MODULE_NOT_FOUND", err;
        function loadAsFileSync(x) {
          var pkg = loadpkg(path.dirname(x));
          if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
            var rfile = path.relative(pkg.dir, x), r = opts.pathFilter(pkg.pkg, x, rfile);
            r && (x = path.resolve(pkg.dir, r));
          }
          if (isFile(x)) return x;
          for (var i = 0; i < extensions.length; i++) {
            var file = x + extensions[i];
            if (isFile(file)) return file;
          }
        }
        function loadpkg(dir) {
          if ("" !== dir && "/" !== dir && !("win32" === process.platform && /^\w:[/\\]*$/.test(dir) || /[/\\]node_modules[/\\]*$/.test(dir))) {
            var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
            if (!isFile(pkgfile)) return loadpkg(path.dirname(dir));
            var pkg = readPackageSync(readFileSync, pkgfile);
            return pkg && opts.packageFilter && (pkg = opts.packageFilter(pkg, dir)), {
              pkg,
              dir
            };
          }
        }
        function loadAsDirectorySync(x) {
          var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), "/package.json");
          if (isFile(pkgfile)) {
            try {
              var pkg = readPackageSync(readFileSync, pkgfile);
            } catch (e) {}
            if (pkg && opts.packageFilter && (pkg = opts.packageFilter(pkg, x)), pkg && pkg.main) {
              if ("string" != typeof pkg.main) {
                var mainError = new TypeError("package " + pkg.name + " `main` must be a string");
                throw mainError.code = "INVALID_PACKAGE_MAIN", mainError;
              }
              "." !== pkg.main && "./" !== pkg.main || (pkg.main = "index");
              try {
                var m = loadAsFileSync(path.resolve(x, pkg.main));
                if (m) return m;
                var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                if (n) return n;
              } catch (e) {}
            }
          }
          return loadAsFileSync(path.join(x, "/index"));
        }
      };
    },
    6625: (module, exports) => {
      var debug;
      exports = module.exports = SemVer, debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER"), console.log.apply(console, args);
      } : function() {}, exports.SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, re = exports.re = [], src = exports.src = [], t = exports.tokens = {}, R = 0;
      function tok(n) {
        t[n] = R++;
      }
      tok("NUMERICIDENTIFIER"), src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*", tok("NUMERICIDENTIFIERLOOSE"), 
      src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+", tok("NONNUMERICIDENTIFIER"), src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", 
      tok("MAINVERSION"), src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")", 
      tok("MAINVERSIONLOOSE"), src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")", 
      tok("PRERELEASEIDENTIFIER"), src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")", 
      tok("PRERELEASEIDENTIFIERLOOSE"), src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")", 
      tok("PRERELEASE"), src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))", 
      tok("PRERELEASELOOSE"), src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))", 
      tok("BUILDIDENTIFIER"), src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+", tok("BUILD"), 
      src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))", 
      tok("FULL"), tok("FULLPLAIN"), src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?", 
      src[t.FULL] = "^" + src[t.FULLPLAIN] + "$", tok("LOOSEPLAIN"), src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?", 
      tok("LOOSE"), src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$", tok("GTLT"), src[t.GTLT] = "((?:<|>)?=?)", 
      tok("XRANGEIDENTIFIERLOOSE"), src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", 
      tok("XRANGEIDENTIFIER"), src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*", 
      tok("XRANGEPLAIN"), src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?", 
      tok("XRANGEPLAINLOOSE"), src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?", 
      tok("XRANGE"), src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$", 
      tok("XRANGELOOSE"), src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$", 
      tok("COERCE"), src[t.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", 
      tok("COERCERTL"), re[t.COERCERTL] = new RegExp(src[t.COERCE], "g"), tok("LONETILDE"), 
      src[t.LONETILDE] = "(?:~>?)", tok("TILDETRIM"), src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+", 
      re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
      tok("TILDE"), src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$", 
      tok("TILDELOOSE"), src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$", 
      tok("LONECARET"), src[t.LONECARET] = "(?:\\^)", tok("CARETTRIM"), src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+", 
      re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
      tok("CARET"), src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$", 
      tok("CARETLOOSE"), src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$", 
      tok("COMPARATORLOOSE"), src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$", 
      tok("COMPARATOR"), src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$", 
      tok("COMPARATORTRIM"), src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", 
      re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
      tok("HYPHENRANGE"), src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$", 
      tok("HYPHENRANGELOOSE"), src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$", 
      tok("STAR"), src[t.STAR] = "(<|>)?=?\\s*\\*";
      for (var i = 0; i < R; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
      function parse(version, options) {
        if (options && "object" == typeof options || (options = {
          loose: !!options,
          includePrerelease: !1
        }), version instanceof SemVer) return version;
        if ("string" != typeof version) return null;
        if (version.length > 256) return null;
        if (!(options.loose ? re[t.LOOSE] : re[t.FULL]).test(version)) return null;
        try {
          return new SemVer(version, options);
        } catch (er) {
          return null;
        }
      }
      function SemVer(version, options) {
        if (options && "object" == typeof options || (options = {
          loose: !!options,
          includePrerelease: !1
        }), version instanceof SemVer) {
          if (version.loose === options.loose) return version;
          version = version.version;
        } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);
        if (version.length > 256) throw new TypeError("version is longer than 256 characters");
        if (!(this instanceof SemVer)) return new SemVer(version, options);
        debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
        var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) throw new TypeError("Invalid Version: " + version);
        if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
        this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
        m[4] ? this.prerelease = m[4].split(".").map((function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
          }
          return id;
        })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
      }
      exports.parse = parse, exports.valid = function(version, options) {
        var v = parse(version, options);
        return v ? v.version : null;
      }, exports.clean = function(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      }, exports.SemVer = SemVer, SemVer.prototype.format = function() {
        return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), 
        this.version;
      }, SemVer.prototype.toString = function() {
        return this.version;
      }, SemVer.prototype.compare = function(other) {
        return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), 
        this.compareMain(other) || this.comparePre(other);
      }, SemVer.prototype.compareMain = function(other) {
        return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }, SemVer.prototype.comparePre = function(other) {
        if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
        if (!this.prerelease.length && other.prerelease.length) return 1;
        if (!this.prerelease.length && !other.prerelease.length) return 0;
        var i = 0;
        do {
          var a = this.prerelease[i], b = other.prerelease[i];
          if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
          if (void 0 === b) return 1;
          if (void 0 === a) return -1;
          if (a !== b) return compareIdentifiers(a, b);
        } while (++i);
      }, SemVer.prototype.compareBuild = function(other) {
        other instanceof SemVer || (other = new SemVer(other, this.options));
        var i = 0;
        do {
          var a = this.build[i], b = other.build[i];
          if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
          if (void 0 === b) return 1;
          if (void 0 === a) return -1;
          if (a !== b) return compareIdentifiers(a, b);
        } while (++i);
      }, SemVer.prototype.inc = function(release, identifier) {
        switch (release) {
         case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
          break;

         case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
          break;

         case "prepatch":
          this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
          break;

         case "prerelease":
          0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
          break;

         case "major":
          0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
          this.minor = 0, this.patch = 0, this.prerelease = [];
          break;

         case "minor":
          0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
          this.prerelease = [];
          break;

         case "patch":
          0 === this.prerelease.length && this.patch++, this.prerelease = [];
          break;

         case "pre":
          if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
            for (var i = this.prerelease.length; --i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
            i = -2);
            -1 === i && this.prerelease.push(0);
          }
          identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
          break;

         default:
          throw new Error("invalid increment argument: " + release);
        }
        return this.format(), this.raw = this.version, this;
      }, exports.inc = function(version, release, loose, identifier) {
        "string" == typeof loose && (identifier = loose, loose = void 0);
        try {
          return new SemVer(version, loose).inc(release, identifier).version;
        } catch (er) {
          return null;
        }
      }, exports.diff = function(version1, version2) {
        if (eq(version1, version2)) return null;
        var v1 = parse(version1), v2 = parse(version2), prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return prefix + key;
        return defaultResult;
      }, exports.compareIdentifiers = compareIdentifiers;
      var numeric = /^[0-9]+$/;
      function compareIdentifiers(a, b) {
        var anum = numeric.test(a), bnum = numeric.test(b);
        return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      }
      function compare(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose));
      }
      function gt(a, b, loose) {
        return compare(a, b, loose) > 0;
      }
      function lt(a, b, loose) {
        return compare(a, b, loose) < 0;
      }
      function eq(a, b, loose) {
        return 0 === compare(a, b, loose);
      }
      function neq(a, b, loose) {
        return 0 !== compare(a, b, loose);
      }
      function gte(a, b, loose) {
        return compare(a, b, loose) >= 0;
      }
      function lte(a, b, loose) {
        return compare(a, b, loose) <= 0;
      }
      function cmp(a, op, b, loose) {
        switch (op) {
         case "===":
          return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
          a === b;

         case "!==":
          return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
          a !== b;

         case "":
         case "=":
         case "==":
          return eq(a, b, loose);

         case "!=":
          return neq(a, b, loose);

         case ">":
          return gt(a, b, loose);

         case ">=":
          return gte(a, b, loose);

         case "<":
          return lt(a, b, loose);

         case "<=":
          return lte(a, b, loose);

         default:
          throw new TypeError("Invalid operator: " + op);
        }
      }
      function Comparator(comp, options) {
        if (options && "object" == typeof options || (options = {
          loose: !!options,
          includePrerelease: !1
        }), comp instanceof Comparator) {
          if (comp.loose === !!options.loose) return comp;
          comp = comp.value;
        }
        if (!(this instanceof Comparator)) return new Comparator(comp, options);
        debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, 
        this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
        debug("comp", this);
      }
      exports.rcompareIdentifiers = function(a, b) {
        return compareIdentifiers(b, a);
      }, exports.major = function(a, loose) {
        return new SemVer(a, loose).major;
      }, exports.minor = function(a, loose) {
        return new SemVer(a, loose).minor;
      }, exports.patch = function(a, loose) {
        return new SemVer(a, loose).patch;
      }, exports.compare = compare, exports.compareLoose = function(a, b) {
        return compare(a, b, !0);
      }, exports.compareBuild = function(a, b, loose) {
        var versionA = new SemVer(a, loose), versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      }, exports.rcompare = function(a, b, loose) {
        return compare(b, a, loose);
      }, exports.sort = function(list, loose) {
        return list.sort((function(a, b) {
          return exports.compareBuild(a, b, loose);
        }));
      }, exports.rsort = function(list, loose) {
        return list.sort((function(a, b) {
          return exports.compareBuild(b, a, loose);
        }));
      }, exports.gt = gt, exports.lt = lt, exports.eq = eq, exports.neq = neq, exports.gte = gte, 
      exports.lte = lte, exports.cmp = cmp, exports.Comparator = Comparator;
      var ANY = {};
      function Range(range, options) {
        if (options && "object" == typeof options || (options = {
          loose: !!options,
          includePrerelease: !1
        }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
        if (range instanceof Comparator) return new Range(range.value, options);
        if (!(this instanceof Range)) return new Range(range, options);
        if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
        this.raw = range, this.set = range.split(/\s*\|\|\s*/).map((function(range) {
          return this.parseRange(range.trim());
        }), this).filter((function(c) {
          return c.length;
        })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + range);
        this.format();
      }
      function isSatisfiable(comparators, options) {
        for (var result = !0, remainingComparators = comparators.slice(), testComparator = remainingComparators.pop(); result && remainingComparators.length; ) result = remainingComparators.every((function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        })), testComparator = remainingComparators.pop();
        return result;
      }
      function isX(id) {
        return !id || "x" === id.toLowerCase() || "*" === id;
      }
      function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
        return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
      }
      function testSet(set, version, options) {
        for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
        if (version.prerelease.length && !options.includePrerelease) {
          for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
          }
          return !1;
        }
        return !0;
      }
      function satisfies(version, range, options) {
        try {
          range = new Range(range, options);
        } catch (er) {
          return !1;
        }
        return range.test(version);
      }
      function outside(version, range, hilo, options) {
        var gtfn, ltefn, ltfn, comp, ecomp;
        switch (version = new SemVer(version, options), range = new Range(range, options), 
        hilo) {
         case ">":
          gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
          break;

         case "<":
          gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
          break;

         default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version, range, options)) return !1;
        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i], high = null, low = null;
          if (comparators.forEach((function(comparator) {
            comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
            low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
          })), high.operator === comp || high.operator === ecomp) return !1;
          if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
          if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
        }
        return !0;
      }
      Comparator.prototype.parse = function(comp) {
        var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], m = comp.match(r);
        if (!m) throw new TypeError("Invalid comparator: " + comp);
        this.operator = void 0 !== m[1] ? m[1] : "", "=" === this.operator && (this.operator = ""), 
        m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
      }, Comparator.prototype.toString = function() {
        return this.value;
      }, Comparator.prototype.test = function(version) {
        if (debug("Comparator.test", version, this.options.loose), this.semver === ANY || version === ANY) return !0;
        if ("string" == typeof version) try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return !1;
        }
        return cmp(version, this.operator, this.semver, this.options);
      }, Comparator.prototype.intersects = function(comp, options) {
        if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
        var rangeTmp;
        if (options && "object" == typeof options || (options = {
          loose: !!options,
          includePrerelease: !1
        }), "" === this.operator) return "" === this.value || (rangeTmp = new Range(comp.value, options), 
        satisfies(this.value, rangeTmp, options));
        if ("" === comp.operator) return "" === comp.value || (rangeTmp = new Range(this.value, options), 
        satisfies(comp.semver, rangeTmp, options));
        var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator), sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }, exports.Range = Range, Range.prototype.format = function() {
        return this.range = this.set.map((function(comps) {
          return comps.join(" ").trim();
        })).join("||").trim(), this.range;
      }, Range.prototype.toString = function() {
        return this.range;
      }, Range.prototype.parseRange = function(range) {
        var loose = this.options.loose;
        range = range.trim();
        var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[t.COMPARATORTRIM], "$1$2$3"), 
        debug("comparator trim", range, re[t.COMPARATORTRIM]), range = (range = (range = range.replace(re[t.TILDETRIM], "$1~")).replace(re[t.CARETTRIM], "$1^")).split(/\s+/).join(" ");
        var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR], set = range.split(" ").map((function(comp) {
          return function(comp, options) {
            return debug("comp", comp, options), comp = function(comp, options) {
              return comp.trim().split(/\s+/).map((function(comp) {
                return function(comp, options) {
                  debug("caret", comp, options);
                  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
                  return comp.replace(r, (function(_, M, m, p, pr) {
                    var ret;
                    return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), 
                    ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), 
                    ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), 
                    debug("caret return", ret), ret;
                  }));
                }(comp, options);
              })).join(" ");
            }(comp, options), debug("caret", comp), comp = function(comp, options) {
              return comp.trim().split(/\s+/).map((function(comp) {
                return function(comp, options) {
                  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
                  return comp.replace(r, (function(_, M, m, p, pr) {
                    var ret;
                    return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), 
                    ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", 
                    debug("tilde return", ret), ret;
                  }));
                }(comp, options);
              })).join(" ");
            }(comp, options), debug("tildes", comp), comp = function(comp, options) {
              return debug("replaceXRanges", comp, options), comp.split(/\s+/).map((function(comp) {
                return function(comp, options) {
                  comp = comp.trim();
                  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
                  return comp.replace(r, (function(ret, gtlt, M, m, p, pr) {
                    debug("xRange", comp, ret, gtlt, M, m, p, pr);
                    var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p), anyX = xp;
                    return "=" === gtlt && anyX && (gtlt = ""), pr = options.includePrerelease ? "-0" : "", 
                    xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0-0" : "*" : gtlt && anyX ? (xm && (m = 0), 
                    p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
                    p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p + pr) : xm ? ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr : xp && (ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr), 
                    debug("xRange return", ret), ret;
                  }));
                }(comp, options);
              })).join(" ");
            }(comp, options), debug("xrange", comp), comp = function(comp, options) {
              return debug("replaceStars", comp, options), comp.trim().replace(re[t.STAR], "");
            }(comp, options), debug("stars", comp), comp;
          }(comp, this.options);
        }), this).join(" ").split(/\s+/);
        return this.options.loose && (set = set.filter((function(comp) {
          return !!comp.match(compRe);
        }))), set = set.map((function(comp) {
          return new Comparator(comp, this.options);
        }), this);
      }, Range.prototype.intersects = function(range, options) {
        if (!(range instanceof Range)) throw new TypeError("a Range is required");
        return this.set.some((function(thisComparators) {
          return isSatisfiable(thisComparators, options) && range.set.some((function(rangeComparators) {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((function(thisComparator) {
              return rangeComparators.every((function(rangeComparator) {
                return thisComparator.intersects(rangeComparator, options);
              }));
            }));
          }));
        }));
      }, exports.toComparators = function(range, options) {
        return new Range(range, options).set.map((function(comp) {
          return comp.map((function(c) {
            return c.value;
          })).join(" ").trim().split(" ");
        }));
      }, Range.prototype.test = function(version) {
        if (!version) return !1;
        if ("string" == typeof version) try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return !1;
        }
        for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
        return !1;
      }, exports.satisfies = satisfies, exports.maxSatisfying = function(versions, range, options) {
        var max = null, maxSV = null;
        try {
          var rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        return versions.forEach((function(v) {
          rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (maxSV = new SemVer(max = v, options)));
        })), max;
      }, exports.minSatisfying = function(versions, range, options) {
        var min = null, minSV = null;
        try {
          var rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        return versions.forEach((function(v) {
          rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (minSV = new SemVer(min = v, options)));
        })), min;
      }, exports.minVersion = function(range, loose) {
        range = new Range(range, loose);
        var minver = new SemVer("0.0.0");
        if (range.test(minver)) return minver;
        if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
        minver = null;
        for (var i = 0; i < range.set.length; ++i) {
          range.set[i].forEach((function(comparator) {
            var compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
             case ">":
              0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
              compver.raw = compver.format();

             case "":
             case ">=":
              minver && !gt(minver, compver) || (minver = compver);
              break;

             case "<":
             case "<=":
              break;

             default:
              throw new Error("Unexpected operation: " + comparator.operator);
            }
          }));
        }
        if (minver && range.test(minver)) return minver;
        return null;
      }, exports.validRange = function(range, options) {
        try {
          return new Range(range, options).range || "*";
        } catch (er) {
          return null;
        }
      }, exports.ltr = function(version, range, options) {
        return outside(version, range, "<", options);
      }, exports.gtr = function(version, range, options) {
        return outside(version, range, ">", options);
      }, exports.outside = outside, exports.prerelease = function(version, options) {
        var parsed = parse(version, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      }, exports.intersects = function(r1, r2, options) {
        return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
      }, exports.coerce = function(version, options) {
        if (version instanceof SemVer) return version;
        "number" == typeof version && (version = String(version));
        if ("string" != typeof version) return null;
        var match = null;
        if ((options = options || {}).rtl) {
          for (var next; (next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length); ) match && next.index + next[0].length === match.index + match[0].length || (match = next), 
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          re[t.COERCERTL].lastIndex = -1;
        } else match = version.match(re[t.COERCE]);
        if (null === match) return null;
        return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
      };
    },
    3495: (__unused_webpack_module, exports, __webpack_require__) => {
      "use strict";
      exports.__esModule = !0, exports.resolve = function(dirname, moduleName, absoluteImports) {
        if (!1 === absoluteImports) return moduleName;
        let basedir = dirname;
        "string" == typeof absoluteImports && (basedir = _path.default.resolve(basedir, absoluteImports));
        try {
          return nativeRequireResolve ? __webpack_require__(5965).resolve(moduleName, {
            paths: [ basedir ]
          }) : _resolve.default.sync(moduleName, {
            basedir
          });
        } catch (err) {
          if ("MODULE_NOT_FOUND" !== err.code) throw err;
          throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
            code: "BABEL_POLYFILL_NOT_FOUND",
            polyfill: moduleName,
            dirname
          });
        }
      }, exports.has = function(basedir, name) {
        try {
          return nativeRequireResolve ? __webpack_require__(5965).resolve(name, {
            paths: [ basedir ]
          }) : _resolve.default.sync(name, {
            basedir
          }), !0;
        } catch (_unused) {
          return !1;
        }
      }, exports.logMissing = logMissing, exports.laterLogMissing = function(missingDeps) {
        if (0 === missingDeps.size) return;
        missingDeps.forEach((name => allMissingDeps.add(name))), laterLogMissingDependencies();
      };
      var _path = _interopRequireDefault(__webpack_require__(1017)), _lodash = _interopRequireDefault(__webpack_require__(1296)), _resolve = _interopRequireDefault(__webpack_require__(6313));
      __webpack_require__(8188);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj
        };
      }
      const nativeRequireResolve = parseFloat(process.versions.node) >= 8.9;
      function logMissing(missingDeps) {
        if (0 === missingDeps.size) return;
        const deps = Array.from(missingDeps).sort().join(" ");
        console.warn(`\nSome polyfills have been added but are not present in your dependencies.\nPlease run one of the following commands:\n\tnpm install --save ${deps}\n\tyarn add ${deps}\n`), 
        process.exitCode = 1;
      }
      let allMissingDeps = new Set;
      const laterLogMissingDependencies = (0, _lodash.default)((() => {
        logMissing(allMissingDeps), allMissingDeps = new Set;
      }), 100);
    },
    2130: (module, __unused_webpack_exports, __webpack_require__) => {
      "use strict";
      const os = __webpack_require__(2037), hasFlag = __webpack_require__(6560), env = process.env;
      let forceColor;
      function getSupportLevel(stream) {
        const level = function(stream) {
          if (!1 === forceColor) return 0;
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
          if (hasFlag("color=256")) return 2;
          if (stream && !stream.isTTY && !0 !== forceColor) return 0;
          const min = forceColor ? 1 : 0;
          if ("win32" === process.platform) {
            const osRelease = os.release().split(".");
            return Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in env) return [ "TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI" ].some((sign => sign in env)) || "codeship" === env.CI_NAME ? 1 : min;
          if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
          if ("truecolor" === env.COLORTERM) return 3;
          if ("TERM_PROGRAM" in env) {
            const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env.TERM_PROGRAM) {
             case "iTerm.app":
              return version >= 3 ? 3 : 2;

             case "Apple_Terminal":
              return 2;
            }
          }
          return /-256(color)?$/i.test(env.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM) || "COLORTERM" in env ? 1 : (env.TERM, 
          min);
        }(stream);
        return function(level) {
          return 0 !== level && {
            level,
            hasBasic: !0,
            has256: level >= 2,
            has16m: level >= 3
          };
        }(level);
      }
      hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") ? forceColor = !1 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (forceColor = !0), 
      "FORCE_COLOR" in env && (forceColor = 0 === env.FORCE_COLOR.length || 0 !== parseInt(env.FORCE_COLOR, 10)), 
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr)
      };
    },
    3164: module => {
      "use strict";
      let fastProto = null;
      function FastObject(o) {
        if (null !== fastProto && (fastProto.property, 1)) {
          const result = fastProto;
          return fastProto = FastObject.prototype = null, result;
        }
        return fastProto = FastObject.prototype = null == o ? Object.create(null) : o, new FastObject;
      }
      FastObject(), module.exports = function(o) {
        return FastObject(o);
      };
    },
    4629: module => {
      "use strict";
      module.exports = require("@babel/core");
    },
    5965: module => {
      "use strict";
      module.exports = require;
    },
    1991: module => {
      "use strict";
      module.exports = require("browserslist");
    },
    3920: module => {
      "use strict";
      module.exports = require("chalk");
    },
    3144: module => {
      "use strict";
      module.exports = require("regexpu-core");
    },
    9491: module => {
      "use strict";
      module.exports = require("assert");
    },
    7147: module => {
      "use strict";
      module.exports = require("fs");
    },
    8188: module => {
      "use strict";
      module.exports = require("module");
    },
    2037: module => {
      "use strict";
      module.exports = require("os");
    },
    1017: module => {
      "use strict";
      module.exports = require("path");
    },
    6224: module => {
      "use strict";
      module.exports = require("tty");
    },
    3837: module => {
      "use strict";
      module.exports = require("util");
    },
    4817: module => {
      "use strict";
      module.exports = JSON.parse('{"es6.array.copy-within":{"chrome":"45","opera":"32","edge":"12","firefox":"32","safari":"9","node":"4","ios":"9","samsung":"5","rhino":"1.7.13","electron":"0.31"},"es6.array.every":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.fill":{"chrome":"45","opera":"32","edge":"12","firefox":"31","safari":"7.1","node":"4","ios":"8","samsung":"5","rhino":"1.7.13","electron":"0.31"},"es6.array.filter":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.array.find":{"chrome":"45","opera":"32","edge":"12","firefox":"25","safari":"7.1","node":"4","ios":"8","samsung":"5","rhino":"1.7.13","electron":"0.31"},"es6.array.find-index":{"chrome":"45","opera":"32","edge":"12","firefox":"25","safari":"7.1","node":"4","ios":"8","samsung":"5","rhino":"1.7.13","electron":"0.31"},"es7.array.flat-map":{"chrome":"69","opera":"56","edge":"79","firefox":"62","safari":"12","node":"11","ios":"12","samsung":"10","electron":"4.0"},"es6.array.for-each":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.from":{"chrome":"51","opera":"38","edge":"15","firefox":"36","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es7.array.includes":{"chrome":"47","opera":"34","edge":"14","firefox":"43","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.36"},"es6.array.index-of":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.is-array":{"chrome":"5","opera":"10.50","edge":"12","firefox":"4","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.iterator":{"chrome":"66","opera":"53","edge":"12","firefox":"60","safari":"9","node":"10","ios":"9","samsung":"9","rhino":"1.7.13","electron":"3.0"},"es6.array.last-index-of":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.map":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.array.of":{"chrome":"45","opera":"32","edge":"12","firefox":"25","safari":"9","node":"4","ios":"9","samsung":"5","rhino":"1.7.13","electron":"0.31"},"es6.array.reduce":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.reduce-right":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.slice":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.array.some":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.array.sort":{"chrome":"63","opera":"50","edge":"12","firefox":"5","safari":"12","node":"10","ie":"9","ios":"12","samsung":"8","rhino":"1.7.13","electron":"3.0"},"es6.array.species":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.date.now":{"chrome":"5","opera":"10.50","edge":"12","firefox":"2","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.date.to-iso-string":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3.5","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.date.to-json":{"chrome":"5","opera":"12.10","edge":"12","firefox":"4","safari":"10","node":"0.10","ie":"9","android":"4","ios":"10","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.date.to-primitive":{"chrome":"47","opera":"34","edge":"15","firefox":"44","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.36"},"es6.date.to-string":{"chrome":"5","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"10","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.function.bind":{"chrome":"7","opera":"12","edge":"12","firefox":"4","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.function.has-instance":{"chrome":"51","opera":"38","edge":"15","firefox":"50","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.function.name":{"chrome":"5","opera":"10.50","edge":"14","firefox":"2","safari":"4","node":"0.10","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.map":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.math.acosh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.asinh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.atanh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.cbrt":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.clz32":{"chrome":"38","opera":"25","edge":"12","firefox":"31","safari":"9","node":"0.12","ios":"9","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.cosh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.expm1":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.fround":{"chrome":"38","opera":"25","edge":"12","firefox":"26","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.hypot":{"chrome":"38","opera":"25","edge":"12","firefox":"27","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.imul":{"chrome":"30","opera":"17","edge":"12","firefox":"23","safari":"7","node":"0.12","android":"4.4","ios":"7","samsung":"2","rhino":"1.7.13","electron":"0.20"},"es6.math.log1p":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.log10":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.log2":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.sign":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.sinh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.tanh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.math.trunc":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.number.constructor":{"chrome":"41","opera":"28","edge":"12","firefox":"36","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.number.epsilon":{"chrome":"34","opera":"21","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.14","electron":"0.20"},"es6.number.is-finite":{"chrome":"19","opera":"15","edge":"12","firefox":"16","safari":"9","node":"0.12","android":"4.1","ios":"9","samsung":"1.5","rhino":"1.7.13","electron":"0.20"},"es6.number.is-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"16","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.13","electron":"0.20"},"es6.number.is-nan":{"chrome":"19","opera":"15","edge":"12","firefox":"15","safari":"9","node":"0.12","android":"4.1","ios":"9","samsung":"1.5","rhino":"1.7.13","electron":"0.20"},"es6.number.is-safe-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"32","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.13","electron":"0.20"},"es6.number.max-safe-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"31","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.13","electron":"0.20"},"es6.number.min-safe-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"31","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.13","electron":"0.20"},"es6.number.parse-float":{"chrome":"34","opera":"21","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.14","electron":"0.20"},"es6.number.parse-int":{"chrome":"34","opera":"21","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"2","rhino":"1.7.14","electron":"0.20"},"es6.object.assign":{"chrome":"49","opera":"36","edge":"13","firefox":"36","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.object.create":{"chrome":"5","opera":"12","edge":"12","firefox":"4","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es7.object.define-getter":{"chrome":"62","opera":"49","edge":"16","firefox":"48","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3.0"},"es7.object.define-setter":{"chrome":"62","opera":"49","edge":"16","firefox":"48","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3.0"},"es6.object.define-property":{"chrome":"5","opera":"12","edge":"12","firefox":"4","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.object.define-properties":{"chrome":"5","opera":"12","edge":"12","firefox":"4","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es7.object.entries":{"chrome":"54","opera":"41","edge":"14","firefox":"47","safari":"10.1","node":"7","ios":"10.3","samsung":"6","rhino":"1.7.14","electron":"1.4"},"es6.object.freeze":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es6.object.get-own-property-descriptor":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es7.object.get-own-property-descriptors":{"chrome":"54","opera":"41","edge":"15","firefox":"50","safari":"10.1","node":"7","ios":"10.3","samsung":"6","electron":"1.4"},"es6.object.get-own-property-names":{"chrome":"40","opera":"27","edge":"12","firefox":"33","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.object.get-prototype-of":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es7.object.lookup-getter":{"chrome":"62","opera":"49","edge":"79","firefox":"36","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3.0"},"es7.object.lookup-setter":{"chrome":"62","opera":"49","edge":"79","firefox":"36","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3.0"},"es6.object.prevent-extensions":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es6.object.to-string":{"chrome":"57","opera":"44","edge":"15","firefox":"51","safari":"10","node":"8","ios":"10","samsung":"7","electron":"1.7"},"es6.object.is":{"chrome":"19","opera":"15","edge":"12","firefox":"22","safari":"9","node":"0.12","android":"4.1","ios":"9","samsung":"1.5","rhino":"1.7.13","electron":"0.20"},"es6.object.is-frozen":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es6.object.is-sealed":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es6.object.is-extensible":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es6.object.keys":{"chrome":"40","opera":"27","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.object.seal":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.13","electron":"0.30"},"es6.object.set-prototype-of":{"chrome":"34","opera":"21","edge":"12","firefox":"31","safari":"9","node":"0.12","ie":"11","ios":"9","samsung":"2","rhino":"1.7.13","electron":"0.20"},"es7.object.values":{"chrome":"54","opera":"41","edge":"14","firefox":"47","safari":"10.1","node":"7","ios":"10.3","samsung":"6","rhino":"1.7.14","electron":"1.4"},"es6.promise":{"chrome":"51","opera":"38","edge":"14","firefox":"45","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es7.promise.finally":{"chrome":"63","opera":"50","edge":"18","firefox":"58","safari":"11.1","node":"10","ios":"11.3","samsung":"8","electron":"3.0"},"es6.reflect.apply":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.construct":{"chrome":"49","opera":"36","edge":"13","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.define-property":{"chrome":"49","opera":"36","edge":"13","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.delete-property":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.get":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.get-own-property-descriptor":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.get-prototype-of":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.has":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.is-extensible":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.own-keys":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.prevent-extensions":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.set":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.set-prototype-of":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.regexp.constructor":{"chrome":"50","opera":"37","edge":"79","firefox":"40","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.flags":{"chrome":"49","opera":"36","edge":"79","firefox":"37","safari":"9","node":"6","ios":"9","samsung":"5","electron":"0.37"},"es6.regexp.match":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","rhino":"1.7.13","electron":"1.1"},"es6.regexp.replace":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.split":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.search":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","rhino":"1.7.13","electron":"1.1"},"es6.regexp.to-string":{"chrome":"50","opera":"37","edge":"79","firefox":"39","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.set":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.symbol":{"chrome":"51","opera":"38","edge":"79","firefox":"51","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es7.symbol.async-iterator":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","ios":"12","samsung":"8","electron":"3.0"},"es6.string.anchor":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.big":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.blink":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.bold":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.code-point-at":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.string.ends-with":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.string.fixed":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.fontcolor":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.fontsize":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.from-code-point":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.string.includes":{"chrome":"41","opera":"28","edge":"12","firefox":"40","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.string.italics":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.iterator":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","ios":"9","samsung":"3","rhino":"1.7.13","electron":"0.20"},"es6.string.link":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es7.string.pad-start":{"chrome":"57","opera":"44","edge":"15","firefox":"48","safari":"10","node":"8","ios":"10","samsung":"7","rhino":"1.7.13","electron":"1.7"},"es7.string.pad-end":{"chrome":"57","opera":"44","edge":"15","firefox":"48","safari":"10","node":"8","ios":"10","samsung":"7","rhino":"1.7.13","electron":"1.7"},"es6.string.raw":{"chrome":"41","opera":"28","edge":"12","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.14","electron":"0.21"},"es6.string.repeat":{"chrome":"41","opera":"28","edge":"12","firefox":"24","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.string.small":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.starts-with":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","rhino":"1.7.13","electron":"0.21"},"es6.string.strike":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.sub":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.sup":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","rhino":"1.7.14","electron":"0.20"},"es6.string.trim":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3.5","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es7.string.trim-left":{"chrome":"66","opera":"53","edge":"79","firefox":"61","safari":"12","node":"10","ios":"12","samsung":"9","rhino":"1.7.13","electron":"3.0"},"es7.string.trim-right":{"chrome":"66","opera":"53","edge":"79","firefox":"61","safari":"12","node":"10","ios":"12","samsung":"9","rhino":"1.7.13","electron":"3.0"},"es6.typed.array-buffer":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.data-view":{"chrome":"5","opera":"12","edge":"12","firefox":"15","safari":"5.1","node":"0.10","ie":"10","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"es6.typed.int8-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint8-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint8-clamped-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.int16-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint16-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.int32-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint32-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.float32-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.float64-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.weak-map":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"9","node":"6.5","ios":"9","samsung":"5","electron":"1.2"},"es6.weak-set":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"9","node":"6.5","ios":"9","samsung":"5","electron":"1.2"}}');
    },
    8392: module => {
      "use strict";
      module.exports = JSON.parse('{"es6.module":{"chrome":"61","and_chr":"61","edge":"16","firefox":"60","and_ff":"60","node":"13.2.0","opera":"48","op_mob":"48","safari":"10.1","ios":"10.3","samsung":"8.2","android":"61","electron":"2.0","ios_saf":"10.3"}}');
    },
    5224: module => {
      "use strict";
      module.exports = JSON.parse('{"transform-async-to-generator":["bugfix/transform-async-arrows-in-class"],"transform-parameters":["bugfix/transform-edge-default-parameters","bugfix/transform-safari-id-destructuring-collision-in-function-expression"],"transform-function-name":["bugfix/transform-edge-function-name"],"transform-block-scoping":["bugfix/transform-safari-block-shadowing","bugfix/transform-safari-for-shadowing"],"transform-template-literals":["bugfix/transform-tagged-template-caching"],"proposal-optional-chaining":["bugfix/transform-v8-spread-parameters-in-optional-chaining"]}');
    },
    4374: module => {
      "use strict";
      module.exports = JSON.parse('{"bugfix/transform-async-arrows-in-class":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","ios":"11","samsung":"6","electron":"1.6"},"bugfix/transform-edge-default-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"52","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"bugfix/transform-edge-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"bugfix/transform-safari-block-shadowing":{"chrome":"49","opera":"36","edge":"12","firefox":"44","safari":"11","node":"6","ie":"11","ios":"11","samsung":"5","electron":"0.37"},"bugfix/transform-safari-for-shadowing":{"chrome":"49","opera":"36","edge":"12","firefox":"4","safari":"11","node":"6","ie":"11","ios":"11","samsung":"5","rhino":"1.7.13","electron":"0.37"},"bugfix/transform-safari-id-destructuring-collision-in-function-expression":{"chrome":"49","opera":"36","edge":"14","firefox":"2","node":"6","samsung":"5","electron":"0.37"},"bugfix/transform-tagged-template-caching":{"chrome":"41","opera":"28","edge":"12","firefox":"34","safari":"13","node":"4","ios":"13","samsung":"3.4","rhino":"1.7.14","electron":"0.21"},"bugfix/transform-v8-spread-parameters-in-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","ios":"13.4","electron":"13.0"},"proposal-optional-chaining":{"chrome":"80","opera":"67","edge":"80","firefox":"74","safari":"13.1","node":"14","ios":"13.4","samsung":"13","electron":"8.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"15","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"10.1","node":"7.6","ios":"10.3","samsung":"6","electron":"1.6"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.21"},"transform-function-name":{"chrome":"51","opera":"38","edge":"14","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-block-scoping":{"chrome":"49","opera":"36","edge":"14","firefox":"51","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"}}');
    },
    7867: module => {
      "use strict";
      module.exports = JSON.parse('{"proposal-class-static-block":{"chrome":"94","opera":"80","edge":"94","firefox":"93","node":"16.11","electron":"15.0"},"proposal-private-property-in-object":{"chrome":"91","opera":"77","edge":"91","firefox":"90","safari":"15","node":"16.9","ios":"15","electron":"13.0"},"proposal-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","ios":"15","samsung":"11","electron":"6.0"},"proposal-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","ios":"15","samsung":"14","electron":"10.0"},"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","ios":"13","samsung":"11","rhino":"1.7.14","electron":"6.0"},"proposal-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","ios":"14","samsung":"14","electron":"10.0"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","ios":"13.4","samsung":"13","electron":"8.0"},"proposal-optional-chaining":{"chrome":"91","opera":"77","edge":"91","firefox":"74","safari":"13.1","node":"16.9","ios":"13.4","electron":"13.0"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","ios":"12","samsung":"9","rhino":"1.7.14","electron":"3.0"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","node":"6","samsung":"5","electron":"0.37"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","ios":"12","samsung":"8","electron":"3.0"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","ios":"11.3","samsung":"8","electron":"2.0"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","ios":"11.3","samsung":"8","electron":"3.0"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3.0"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3.0"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","ios":"11","samsung":"6","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","ios":"10.3","samsung":"6","rhino":"1.7.14","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","ios":"13","samsung":"3.4","electron":"0.21"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"43","safari":"10","node":"6","ios":"10","samsung":"5","rhino":"1.7.13","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","ie":"11","ios":"10","samsung":"3.4","electron":"0.21"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","ios":"9","samsung":"4","rhino":"1.7.14","electron":"0.27"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","ios":"8","samsung":"4","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","ios":"12","samsung":"5","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-block-scoping":{"chrome":"49","opera":"36","edge":"14","firefox":"51","safari":"11","node":"6","ios":"11","samsung":"5","electron":"0.37"},"transform-typeof-symbol":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","ios":"9","samsung":"3","rhino":"1.7.13","electron":"0.20"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4.4","ios":"6","phantom":"2","samsung":"1","rhino":"1.7.13","electron":"0.20"},"proposal-export-namespace-from":{"chrome":"72","and_chr":"72","edge":"79","firefox":"80","and_ff":"80","node":"13.2","opera":"60","op_mob":"51","samsung":"11.0","android":"72","electron":"5.0"}}');
    },
    6578: module => {
      "use strict";
      module.exports = JSON.parse('{"es.symbol":{"android":"49","chrome":"49","deno":"1.0","edge":"15","electron":"0.37","firefox":"51","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.symbol.description":{"android":"70","chrome":"70","deno":"1.0","edge":"74","electron":"5.0","firefox":"63","ios":"12.2","node":"11.0","opera":"57","opera_mobile":"49","safari":"12.1","samsung":"10.0"},"es.symbol.async-iterator":{"android":"63","chrome":"63","deno":"1.0","edge":"74","electron":"3.0","firefox":"55","ios":"12.0","node":"10.0","opera":"50","opera_mobile":"46","safari":"12.0","samsung":"8.0"},"es.symbol.has-instance":{"android":"50","chrome":"50","deno":"1.0","edge":"15","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.is-concat-spreadable":{"android":"48","chrome":"48","deno":"1.0","edge":"15","electron":"0.37","firefox":"48","ios":"10.0","node":"6.0","opera":"35","opera_mobile":"35","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.iterator":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"36","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.symbol.match":{"android":"50","chrome":"50","deno":"1.0","edge":"74","electron":"1.1","firefox":"40","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.match-all":{"android":"73","chrome":"73","deno":"1.0","edge":"74","electron":"5.0","firefox":"67","ios":"13.0","node":"12.0","opera":"60","opera_mobile":"52","safari":"13","samsung":"11.0"},"es.symbol.replace":{"android":"50","chrome":"50","deno":"1.0","edge":"74","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.search":{"android":"50","chrome":"50","deno":"1.0","edge":"74","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.species":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"41","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.split":{"android":"50","chrome":"50","deno":"1.0","edge":"74","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.to-primitive":{"android":"47","chrome":"47","deno":"1.0","edge":"15","electron":"0.36","firefox":"44","ios":"10.0","node":"6.0","opera":"34","opera_mobile":"34","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.to-string-tag":{"android":"49","chrome":"49","deno":"1.0","edge":"15","electron":"0.37","firefox":"51","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.symbol.unscopables":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"48","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.error.cause":{"android":"94","chrome":"94","deno":"1.14","edge":"94","electron":"15.0","firefox":"91","ios":"15.0","node":"16.11","opera":"80","opera_mobile":"66","safari":"15.0","samsung":"17.0"},"es.error.to-string":{"android":"4.4.3","chrome":"33","deno":"1.0","edge":"12","electron":"0.20","firefox":"11","ie":"9","ios":"9.0","node":"0.11.13","opera":"20","opera_mobile":"20","rhino":"1.7.14","safari":"8.0","samsung":"2.0"},"es.aggregate-error":{"android":"85","chrome":"85","deno":"1.2","edge":"85","electron":"10.0","firefox":"79","ios":"14.0","node":"15.0","opera":"71","opera_mobile":"60","safari":"14.0","samsung":"14.0"},"es.aggregate-error.cause":{"android":"94","chrome":"94","deno":"1.14","edge":"94","electron":"15.0","firefox":"91","ios":"15.0","node":"16.11","opera":"80","opera_mobile":"66","safari":"15.0","samsung":"17.0"},"es.array.at":{"android":"92","chrome":"92","deno":"1.12","edge":"92","electron":"14.0","firefox":"90","ios":"15.4","node":"16.6","opera":"78","opera_mobile":"65","safari":"15.4","samsung":"16.0"},"es.array.concat":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.copy-within":{"android":"45","chrome":"45","deno":"1.0","edge":"12","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.every":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.array.fill":{"android":"45","chrome":"45","deno":"1.0","edge":"12","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.filter":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.find":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.find-index":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.flat":{"android":"69","chrome":"69","deno":"1.0","edge":"74","electron":"4.0","firefox":"62","ios":"12.0","node":"11.0","opera":"56","opera_mobile":"48","safari":"12.0","samsung":"10.0"},"es.array.flat-map":{"android":"69","chrome":"69","deno":"1.0","edge":"74","electron":"4.0","firefox":"62","ios":"12.0","node":"11.0","opera":"56","opera_mobile":"48","safari":"12.0","samsung":"10.0"},"es.array.for-each":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.array.from":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"53","ios":"9.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"9.0","samsung":"5.0"},"es.array.includes":{"android":"53","chrome":"53","deno":"1.0","edge":"14","electron":"1.4","firefox":"102","ios":"10.0","node":"7.0","opera":"40","opera_mobile":"40","safari":"10.0","samsung":"6.0"},"es.array.index-of":{"android":"51","chrome":"51","deno":"1.0","edge":"12","electron":"1.2","firefox":"47","ie":"9","ios":"8.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"7.1","samsung":"5.0"},"es.array.is-array":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"3.2","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"4.0","samsung":"1.0"},"es.array.iterator":{"android":"66","chrome":"66","deno":"1.0","edge":"15","electron":"3.0","firefox":"60","ios":"10.0","node":"10.0","opera":"53","opera_mobile":"47","safari":"10.0","samsung":"9.0"},"es.array.join":{"android":"4.4","chrome":"26","deno":"1.0","edge":"13","electron":"0.20","firefox":"4","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.array.last-index-of":{"android":"51","chrome":"51","deno":"1.0","edge":"12","electron":"1.2","firefox":"47","ie":"9","ios":"8.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"7.1","samsung":"5.0"},"es.array.map":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"50","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.of":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"25","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","rhino":"1.7.13","safari":"9.0","samsung":"5.0"},"es.array.reduce":{"android":"83","chrome":"83","deno":"1.0","edge":"12","electron":"9.0","firefox":"4","ie":"9","ios":"8.0","node":"6.0","opera":"69","opera_mobile":"59","rhino":"1.7.13","safari":"7.1","samsung":"13.0"},"es.array.reduce-right":{"android":"83","chrome":"83","deno":"1.0","edge":"12","electron":"9.0","firefox":"4","ie":"9","ios":"8.0","node":"6.0","opera":"69","opera_mobile":"59","rhino":"1.7.13","safari":"7.1","samsung":"13.0"},"es.array.reverse":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"5.5","ios":"12.2","node":"0.0.3","opera":"10.50","opera_mobile":"10.50","rhino":"1.7.13","safari":"12.0.2","samsung":"1.0"},"es.array.slice":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.some":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.array.sort":{"android":"70","chrome":"70","deno":"1.0","edge":"74","electron":"5.0","firefox":"4","ios":"12.0","node":"11.0","opera":"57","opera_mobile":"49","safari":"12.0","samsung":"10.0"},"es.array.species":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.splice":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"49","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.unscopables.flat":{"android":"73","chrome":"73","deno":"1.0","edge":"74","electron":"5.0","firefox":"67","ios":"13.0","node":"12.0","opera":"60","opera_mobile":"52","safari":"13","samsung":"11.0"},"es.array.unscopables.flat-map":{"android":"73","chrome":"73","deno":"1.0","edge":"74","electron":"5.0","firefox":"67","ios":"13.0","node":"12.0","opera":"60","opera_mobile":"52","safari":"13","samsung":"11.0"},"es.array-buffer.constructor":{"android":"4.4","chrome":"26","deno":"1.0","edge":"14","electron":"0.20","firefox":"44","ios":"12.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"12.0","samsung":"1.5"},"es.array-buffer.is-view":{"android":"4.4.3","chrome":"32","deno":"1.0","edge":"12","electron":"0.20","firefox":"29","ie":"11","ios":"8.0","node":"0.11.9","opera":"19","opera_mobile":"19","safari":"7.1","samsung":"2.0"},"es.array-buffer.slice":{"android":"4.4.3","chrome":"31","deno":"1.0","edge":"12","electron":"0.20","firefox":"46","ie":"11","ios":"12.2","node":"0.11.8","opera":"18","opera_mobile":"18","rhino":"1.7.13","safari":"12.1","samsung":"2.0"},"es.data-view":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"15","ie":"10","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.date.get-year":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"9","ios":"1.0","node":"0.0.3","opera":"3","opera_mobile":"3","phantom":"1.9","rhino":"1.7.13","safari":"1","samsung":"1.0"},"es.date.now":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ie":"9","ios":"3.2","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"4.0","samsung":"1.0"},"es.date.set-year":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"3","ios":"1.0","node":"0.0.3","opera":"3","opera_mobile":"3","phantom":"1.9","rhino":"1.7.13","safari":"1","samsung":"1.0"},"es.date.to-gmt-string":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"3","ios":"1.0","node":"0.0.3","opera":"3","opera_mobile":"3","phantom":"1.9","rhino":"1.7.13","safari":"1","samsung":"1.0"},"es.date.to-iso-string":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"7","ie":"9","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.date.to-json":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"10.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"10.0","samsung":"1.5"},"es.date.to-primitive":{"android":"47","chrome":"47","deno":"1.0","edge":"15","electron":"0.36","firefox":"44","ios":"10.0","node":"6.0","opera":"34","opera_mobile":"34","safari":"10.0","samsung":"5.0"},"es.date.to-string":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ie":"9","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.escape":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"3","ios":"1.0","node":"0.0.3","opera":"3","opera_mobile":"3","phantom":"1.9","rhino":"1.7.13","safari":"1","samsung":"1.0"},"es.function.bind":{"android":"3.0","chrome":"7","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"5.1","node":"0.1.101","opera":"12","opera_mobile":"12","phantom":"2.0","rhino":"1.7.13","safari":"5.1","samsung":"1.0"},"es.function.has-instance":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"50","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.function.name":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"3.2","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"4.0","samsung":"1.0"},"es.global-this":{"android":"71","chrome":"71","deno":"1.0","edge":"74","electron":"5.0","firefox":"65","ios":"12.2","node":"12.0","opera":"58","opera_mobile":"50","rhino":"1.7.14","safari":"12.1","samsung":"10.0"},"es.json.stringify":{"android":"72","chrome":"72","deno":"1.0","edge":"74","electron":"5.0","firefox":"64","ios":"12.2","node":"12.0","opera":"59","opera_mobile":"51","safari":"12.1","samsung":"11.0"},"es.json.to-string-tag":{"android":"50","chrome":"50","deno":"1.0","edge":"15","electron":"1.1","firefox":"51","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.map":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.math.acosh":{"android":"54","chrome":"54","deno":"1.0","edge":"13","electron":"1.4","firefox":"25","ios":"8.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"7.1","samsung":"6.0"},"es.math.asinh":{"android":"38","chrome":"38","deno":"1.0","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.atanh":{"android":"38","chrome":"38","deno":"1.0","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.cbrt":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.clz32":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"31","ios":"9.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"9.0","samsung":"3.0"},"es.math.cosh":{"android":"39","chrome":"39","deno":"1.0","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"1.0","opera":"26","opera_mobile":"26","rhino":"1.7.13","safari":"7.1","samsung":"3.4"},"es.math.expm1":{"android":"39","chrome":"39","deno":"1.0","edge":"13","electron":"0.20","firefox":"46","ios":"8.0","node":"1.0","opera":"26","opera_mobile":"26","rhino":"1.7.13","safari":"7.1","samsung":"3.4"},"es.math.fround":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"26","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.hypot":{"android":"78","chrome":"78","deno":"1.0","edge":"12","electron":"7.0","firefox":"27","ios":"8.0","node":"13.0","opera":"65","opera_mobile":"56","rhino":"1.7.13","safari":"7.1","samsung":"12.0"},"es.math.imul":{"android":"4.4","chrome":"28","deno":"1.0","edge":"13","electron":"0.20","firefox":"20","ios":"9.0","node":"0.11.1","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"9.0","samsung":"1.5"},"es.math.log10":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.log1p":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.log2":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.sign":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"9.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"9.0","samsung":"3.0"},"es.math.sinh":{"android":"39","chrome":"39","deno":"1.0","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"1.0","opera":"26","opera_mobile":"26","rhino":"1.7.13","safari":"7.1","samsung":"3.4"},"es.math.tanh":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.math.to-string-tag":{"android":"50","chrome":"50","deno":"1.0","edge":"15","electron":"1.1","firefox":"51","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.math.trunc":{"android":"38","chrome":"38","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.number.constructor":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"46","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.number.epsilon":{"android":"37","chrome":"34","deno":"1.0","edge":"12","electron":"0.20","firefox":"25","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","rhino":"1.7.14","safari":"9.0","samsung":"2.0"},"es.number.is-finite":{"android":"4.1","chrome":"19","deno":"1.0","edge":"12","electron":"0.20","firefox":"16","ios":"9.0","node":"0.7.3","opera":"15","opera_mobile":"15","rhino":"1.7.13","safari":"9.0","samsung":"1.5"},"es.number.is-integer":{"android":"37","chrome":"34","deno":"1.0","edge":"12","electron":"0.20","firefox":"16","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","rhino":"1.7.13","safari":"9.0","samsung":"2.0"},"es.number.is-nan":{"android":"4.1","chrome":"19","deno":"1.0","edge":"12","electron":"0.20","firefox":"15","ios":"9.0","node":"0.7.3","opera":"15","opera_mobile":"15","rhino":"1.7.13","safari":"9.0","samsung":"1.5"},"es.number.is-safe-integer":{"android":"37","chrome":"34","deno":"1.0","edge":"12","electron":"0.20","firefox":"32","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","rhino":"1.7.13","safari":"9.0","samsung":"2.0"},"es.number.max-safe-integer":{"android":"37","chrome":"34","deno":"1.0","edge":"12","electron":"0.20","firefox":"31","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","rhino":"1.7.13","safari":"9.0","samsung":"2.0"},"es.number.min-safe-integer":{"android":"37","chrome":"34","deno":"1.0","edge":"12","electron":"0.20","firefox":"31","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","rhino":"1.7.13","safari":"9.0","samsung":"2.0"},"es.number.parse-float":{"android":"37","chrome":"35","deno":"1.0","edge":"74","electron":"0.20","firefox":"39","ios":"11.0","node":"0.11.13","opera":"22","opera_mobile":"22","rhino":"1.7.14","safari":"11.0","samsung":"3.0"},"es.number.parse-int":{"android":"37","chrome":"35","deno":"1.0","edge":"74","electron":"0.20","firefox":"39","ios":"9.0","node":"0.11.13","opera":"22","opera_mobile":"22","rhino":"1.7.14","safari":"9.0","samsung":"3.0"},"es.number.to-exponential":{"android":"51","chrome":"51","deno":"1.0","edge":"18","electron":"1.2","firefox":"87","ios":"11.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.14","safari":"11","samsung":"5.0"},"es.number.to-fixed":{"android":"4.4","chrome":"26","deno":"1.0","edge":"74","electron":"0.20","firefox":"4","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.number.to-precision":{"android":"4.4","chrome":"26","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"8","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","rhino":"1.7.13","safari":"7.1","samsung":"1.5"},"es.object.assign":{"android":"49","chrome":"49","deno":"1.0","edge":"74","electron":"0.37","firefox":"36","ios":"9.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"9.0","samsung":"5.0"},"es.object.create":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"3.2","node":"0.1.27","opera":"12","opera_mobile":"12","phantom":"1.9","rhino":"1.7.13","safari":"4.0","samsung":"1.0"},"es.object.define-getter":{"android":"62","chrome":"62","deno":"1.0","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","rhino":"1.7.13","safari":"7.1","samsung":"8.0"},"es.object.define-properties":{"android":"37","chrome":"37","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"5.1","node":"0.11.15","opera":"12","opera_mobile":"12","phantom":"2.0","rhino":"1.7.13","safari":"5.1","samsung":"3.0"},"es.object.define-property":{"android":"37","chrome":"37","deno":"1.0","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"5.1","node":"0.11.15","opera":"12","opera_mobile":"12","phantom":"2.0","rhino":"1.7.13","safari":"5.1","samsung":"3.0"},"es.object.define-setter":{"android":"62","chrome":"62","deno":"1.0","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","rhino":"1.7.13","safari":"7.1","samsung":"8.0"},"es.object.entries":{"android":"54","chrome":"54","deno":"1.0","edge":"14","electron":"1.4","firefox":"47","ios":"10.3","node":"7.0","opera":"41","opera_mobile":"41","rhino":"1.7.14","safari":"10.1","samsung":"6.0"},"es.object.freeze":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.from-entries":{"android":"73","chrome":"73","deno":"1.0","edge":"74","electron":"5.0","firefox":"63","ios":"12.2","node":"12.0","opera":"60","opera_mobile":"52","rhino":"1.7.14","safari":"12.1","samsung":"11.0"},"es.object.get-own-property-descriptor":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.get-own-property-descriptors":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"50","ios":"10.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"10.0","samsung":"6.0"},"es.object.get-own-property-names":{"android":"40","chrome":"40","deno":"1.0","edge":"13","electron":"0.21","firefox":"34","ios":"9.0","node":"1.0","opera":"27","opera_mobile":"27","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.object.get-prototype-of":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.has-own":{"android":"93","chrome":"93","deno":"1.13","edge":"93","electron":"14.0","firefox":"92","ios":"15.4","node":"16.9","opera":"79","opera_mobile":"66","safari":"15.4","samsung":"17.0"},"es.object.is":{"android":"4.1","chrome":"19","deno":"1.0","edge":"12","electron":"0.20","firefox":"22","ios":"9.0","node":"0.7.3","opera":"15","opera_mobile":"15","rhino":"1.7.13","safari":"9.0","samsung":"1.5"},"es.object.is-extensible":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.is-frozen":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.is-sealed":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.keys":{"android":"40","chrome":"40","deno":"1.0","edge":"13","electron":"0.21","firefox":"35","ios":"9.0","node":"1.0","opera":"27","opera_mobile":"27","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.object.lookup-getter":{"android":"62","chrome":"62","deno":"1.0","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","rhino":"1.7.13","safari":"7.1","samsung":"8.0"},"es.object.lookup-setter":{"android":"62","chrome":"62","deno":"1.0","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","rhino":"1.7.13","safari":"7.1","samsung":"8.0"},"es.object.prevent-extensions":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.seal":{"android":"44","chrome":"44","deno":"1.0","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","rhino":"1.7.13","safari":"9.0","samsung":"4.0"},"es.object.set-prototype-of":{"android":"37","chrome":"34","deno":"1.0","edge":"12","electron":"0.20","firefox":"31","ie":"11","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","rhino":"1.7.13","safari":"9.0","samsung":"2.0"},"es.object.to-string":{"android":"49","chrome":"49","deno":"1.0","edge":"15","electron":"0.37","firefox":"51","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.object.values":{"android":"54","chrome":"54","deno":"1.0","edge":"14","electron":"1.4","firefox":"47","ios":"10.3","node":"7.0","opera":"41","opera_mobile":"41","rhino":"1.7.14","safari":"10.1","samsung":"6.0"},"es.parse-float":{"android":"37","chrome":"35","deno":"1.0","edge":"74","electron":"0.20","firefox":"8","ie":"8","ios":"8.0","node":"0.11.13","opera":"22","opera_mobile":"22","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.parse-int":{"android":"37","chrome":"35","deno":"1.0","edge":"74","electron":"0.20","firefox":"21","ie":"9","ios":"8.0","node":"0.11.13","opera":"22","opera_mobile":"22","rhino":"1.7.13","safari":"7.1","samsung":"3.0"},"es.promise":{"android":"67","chrome":"67","deno":"1.0","edge":"74","electron":"4.0","firefox":"69","ios":"11.0","node":"10.4","opera":"54","opera_mobile":"48","rhino":"1.7.14","safari":"11.0","samsung":"9.0"},"es.promise.all-settled":{"android":"76","chrome":"76","deno":"1.0","edge":"76","electron":"6.0","firefox":"71","ios":"13.0","node":"12.9","opera":"63","opera_mobile":"54","safari":"13","samsung":"12.0"},"es.promise.any":{"android":"85","chrome":"85","deno":"1.2","edge":"85","electron":"10.0","firefox":"79","ios":"14.0","node":"15.0","opera":"71","opera_mobile":"60","safari":"14.0","samsung":"14.0"},"es.promise.finally":{"android":"67","chrome":"67","deno":"1.0","edge":"74","electron":"4.0","firefox":"69","ios":"13.2.3","node":"10.4","opera":"54","opera_mobile":"48","rhino":"1.7.14","safari":"13.0.3","samsung":"9.0"},"es.reflect.apply":{"android":"49","chrome":"49","deno":"1.0","edge":"15","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.construct":{"android":"49","chrome":"49","deno":"1.0","edge":"15","electron":"0.37","firefox":"44","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.define-property":{"android":"49","chrome":"49","deno":"1.0","edge":"13","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.delete-property":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.get":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.get-own-property-descriptor":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.get-prototype-of":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.has":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.is-extensible":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.own-keys":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.prevent-extensions":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.set":{"android":"49","chrome":"49","deno":"1.0","edge":"74","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.set-prototype-of":{"android":"49","chrome":"49","deno":"1.0","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.to-string-tag":{"android":"86","chrome":"86","deno":"1.3","edge":"86","electron":"11.0","firefox":"82","ios":"14.0","node":"15.0","opera":"72","opera_mobile":"61","safari":"14.0","samsung":"14.0"},"es.regexp.constructor":{"android":"64","chrome":"64","deno":"1.0","edge":"74","electron":"3.0","firefox":"78","ios":"11.3","node":"10.0","opera":"51","opera_mobile":"47","safari":"11.1","samsung":"9.0"},"es.regexp.dot-all":{"android":"62","chrome":"62","deno":"1.0","edge":"74","electron":"3.0","firefox":"78","ios":"11.3","node":"8.10","opera":"49","opera_mobile":"46","safari":"11.1","samsung":"8.0"},"es.regexp.exec":{"android":"64","chrome":"64","deno":"1.0","edge":"74","electron":"3.0","firefox":"78","ios":"11.3","node":"10.0","opera":"51","opera_mobile":"47","safari":"11.1","samsung":"9.0"},"es.regexp.flags":{"android":"62","chrome":"62","deno":"1.0","edge":"74","electron":"3.0","firefox":"78","ios":"11.3","node":"8.10","opera":"49","opera_mobile":"46","safari":"11.1","samsung":"8.0"},"es.regexp.sticky":{"android":"49","chrome":"49","deno":"1.0","edge":"13","electron":"0.37","firefox":"3","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.regexp.test":{"android":"51","chrome":"51","deno":"1.0","edge":"74","electron":"1.2","firefox":"46","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.regexp.to-string":{"android":"50","chrome":"50","deno":"1.0","edge":"74","electron":"1.1","firefox":"46","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.set":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.string.at-alternative":{"android":"92","chrome":"92","deno":"1.12","edge":"92","electron":"14.0","firefox":"90","ios":"15.4","node":"16.6","opera":"78","opera_mobile":"65","safari":"15.4","samsung":"16.0"},"es.string.code-point-at":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"29","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.string.ends-with":{"android":"51","chrome":"51","deno":"1.0","edge":"74","electron":"1.2","firefox":"40","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.from-code-point":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"29","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.string.includes":{"android":"51","chrome":"51","deno":"1.0","edge":"74","electron":"1.2","firefox":"40","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.iterator":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"36","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.string.match":{"android":"51","chrome":"51","deno":"1.0","edge":"74","electron":"1.2","firefox":"49","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.match-all":{"android":"80","chrome":"80","deno":"1.0","edge":"80","electron":"8.0","firefox":"73","ios":"13.4","node":"14.0","opera":"67","opera_mobile":"57","safari":"13.1","samsung":"13.0"},"es.string.pad-end":{"android":"57","chrome":"57","deno":"1.0","edge":"15","electron":"1.7","firefox":"48","ios":"11.0","node":"8.0","opera":"44","opera_mobile":"43","rhino":"1.7.13","safari":"11.0","samsung":"7.0"},"es.string.pad-start":{"android":"57","chrome":"57","deno":"1.0","edge":"15","electron":"1.7","firefox":"48","ios":"11.0","node":"8.0","opera":"44","opera_mobile":"43","rhino":"1.7.13","safari":"11.0","samsung":"7.0"},"es.string.raw":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"34","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.14","safari":"9.0","samsung":"3.4"},"es.string.repeat":{"android":"41","chrome":"41","deno":"1.0","edge":"13","electron":"0.21","firefox":"24","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","rhino":"1.7.13","safari":"9.0","samsung":"3.4"},"es.string.replace":{"android":"64","chrome":"64","deno":"1.0","edge":"74","electron":"3.0","firefox":"78","ios":"14.0","node":"10.0","opera":"51","opera_mobile":"47","safari":"14.0","samsung":"9.0"},"es.string.replace-all":{"android":"85","chrome":"85","deno":"1.2","edge":"85","electron":"10.0","firefox":"77","ios":"13.4","node":"15.0","opera":"71","opera_mobile":"60","safari":"13.1","samsung":"14.0"},"es.string.search":{"android":"51","chrome":"51","deno":"1.0","edge":"74","electron":"1.2","firefox":"49","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.split":{"android":"54","chrome":"54","deno":"1.0","edge":"74","electron":"1.4","firefox":"49","ios":"10.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"10.0","samsung":"6.0"},"es.string.starts-with":{"android":"51","chrome":"51","deno":"1.0","edge":"74","electron":"1.2","firefox":"40","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.substr":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"9","ios":"1.0","node":"0.0.3","opera":"4","opera_mobile":"4","phantom":"1.9","rhino":"1.7.13","safari":"1","samsung":"1.0"},"es.string.trim":{"android":"59","chrome":"59","deno":"1.0","edge":"15","electron":"1.8","firefox":"52","ios":"12.2","node":"8.3","opera":"46","opera_mobile":"43","safari":"12.1","samsung":"7.0"},"es.string.trim-end":{"android":"66","chrome":"66","deno":"1.0","edge":"74","electron":"3.0","firefox":"61","ios":"12.2","node":"10.0","opera":"53","opera_mobile":"47","safari":"12.1","samsung":"9.0"},"es.string.trim-start":{"android":"66","chrome":"66","deno":"1.0","edge":"74","electron":"3.0","firefox":"61","ios":"12.0","node":"10.0","opera":"53","opera_mobile":"47","safari":"12.0","samsung":"9.0"},"es.string.anchor":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","rhino":"1.7.14","safari":"6.0","samsung":"1.0"},"es.string.big":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.blink":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.bold":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.fixed":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.fontcolor":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","rhino":"1.7.14","safari":"6.0","samsung":"1.0"},"es.string.fontsize":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","rhino":"1.7.14","safari":"6.0","samsung":"1.0"},"es.string.italics":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.link":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","rhino":"1.7.14","safari":"6.0","samsung":"1.0"},"es.string.small":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.strike":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.sub":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.string.sup":{"android":"3.0","chrome":"5","deno":"1.0","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","rhino":"1.7.13","safari":"3.1","samsung":"1.0"},"es.typed-array.float32-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.float64-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.int8-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.int16-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.int32-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.uint8-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.uint8-clamped-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.uint16-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.uint32-array":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.at":{"android":"92","chrome":"92","deno":"1.12","edge":"92","electron":"14.0","firefox":"90","ios":"15.4","node":"16.6","opera":"78","opera_mobile":"65","safari":"15.4","samsung":"16.0"},"es.typed-array.copy-within":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"34","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.every":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.fill":{"android":"58","chrome":"58","deno":"1.0","edge":"74","electron":"1.7","firefox":"55","ios":"14.5","node":"8.0","opera":"45","opera_mobile":"43","safari":"14.1","samsung":"7.0"},"es.typed-array.filter":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.find":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.find-index":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.for-each":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.from":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.includes":{"android":"49","chrome":"49","deno":"1.0","edge":"14","electron":"0.37","firefox":"43","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.typed-array.index-of":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.iterator":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"37","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.typed-array.join":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.last-index-of":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.map":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.of":{"android":"54","chrome":"54","deno":"1.0","edge":"15","electron":"1.4","firefox":"55","ios":"14.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"14.0","samsung":"6.0"},"es.typed-array.reduce":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.reduce-right":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.reverse":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.set":{"android":"95","chrome":"95","deno":"1.15","edge":"95","electron":"16.0","firefox":"54","ios":"14.5","node":"17.0","opera":"81","opera_mobile":"67","safari":"14.1","samsung":"17.0"},"es.typed-array.slice":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.some":{"android":"45","chrome":"45","deno":"1.0","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.sort":{"android":"74","chrome":"74","deno":"1.0","edge":"74","electron":"6.0","firefox":"67","ios":"14.5","node":"12.0","opera":"61","opera_mobile":"53","safari":"14.1","samsung":"11.0"},"es.typed-array.subarray":{"android":"4.4","chrome":"26","deno":"1.0","edge":"13","electron":"0.20","firefox":"15","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.typed-array.to-locale-string":{"android":"45","chrome":"45","deno":"1.0","edge":"74","electron":"0.31","firefox":"51","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.to-string":{"android":"51","chrome":"51","deno":"1.0","edge":"13","electron":"1.2","firefox":"51","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.unescape":{"android":"3.0","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"3","ios":"1.0","node":"0.0.3","opera":"3","opera_mobile":"3","phantom":"1.9","rhino":"1.7.13","safari":"1","samsung":"1.0"},"es.weak-map":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"es.weak-set":{"android":"51","chrome":"51","deno":"1.0","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","rhino":"1.7.13","safari":"10.0","samsung":"5.0"},"esnext.aggregate-error":{"android":"85","chrome":"85","deno":"1.2","edge":"85","electron":"10.0","firefox":"79","ios":"14.0","node":"15.0","opera":"71","opera_mobile":"60","safari":"14.0","samsung":"14.0"},"esnext.array.from-async":{},"esnext.array.at":{"android":"92","chrome":"92","deno":"1.12","edge":"92","electron":"14.0","firefox":"90","ios":"15.4","node":"16.6","opera":"78","opera_mobile":"65","safari":"15.4","samsung":"16.0"},"esnext.array.filter-out":{},"esnext.array.filter-reject":{},"esnext.array.find-last":{"android":"97","chrome":"97","deno":"1.16","edge":"97","electron":"17.0","ios":"15.4","node":"18.0","opera":"83","opera_mobile":"68","safari":"15.4"},"esnext.array.find-last-index":{"android":"97","chrome":"97","deno":"1.16","edge":"97","electron":"17.0","ios":"15.4","node":"18.0","opera":"83","opera_mobile":"68","safari":"15.4"},"esnext.array.group-by":{},"esnext.array.group-by-to-map":{},"esnext.array.is-template-object":{},"esnext.array.last-index":{},"esnext.array.last-item":{},"esnext.array.to-reversed":{},"esnext.array.to-sorted":{},"esnext.array.to-spliced":{},"esnext.array.unique-by":{},"esnext.array.with":{},"esnext.async-iterator.constructor":{},"esnext.async-iterator.as-indexed-pairs":{},"esnext.async-iterator.drop":{},"esnext.async-iterator.every":{},"esnext.async-iterator.filter":{},"esnext.async-iterator.find":{},"esnext.async-iterator.flat-map":{},"esnext.async-iterator.for-each":{},"esnext.async-iterator.from":{},"esnext.async-iterator.map":{},"esnext.async-iterator.reduce":{},"esnext.async-iterator.some":{},"esnext.async-iterator.take":{},"esnext.async-iterator.to-array":{},"esnext.bigint.range":{},"esnext.composite-key":{},"esnext.composite-symbol":{},"esnext.function.is-callable":{},"esnext.function.is-constructor":{},"esnext.function.un-this":{},"esnext.global-this":{"android":"71","chrome":"71","deno":"1.0","edge":"74","electron":"5.0","firefox":"65","ios":"12.2","node":"12.0","opera":"58","opera_mobile":"50","rhino":"1.7.14","safari":"12.1","samsung":"10.0"},"esnext.iterator.constructor":{},"esnext.iterator.as-indexed-pairs":{},"esnext.iterator.drop":{},"esnext.iterator.every":{},"esnext.iterator.filter":{},"esnext.iterator.find":{},"esnext.iterator.flat-map":{},"esnext.iterator.for-each":{},"esnext.iterator.from":{},"esnext.iterator.map":{},"esnext.iterator.reduce":{},"esnext.iterator.some":{},"esnext.iterator.take":{},"esnext.iterator.to-array":{},"esnext.iterator.to-async":{},"esnext.map.delete-all":{},"esnext.map.emplace":{},"esnext.map.every":{},"esnext.map.filter":{},"esnext.map.find":{},"esnext.map.find-key":{},"esnext.map.from":{},"esnext.map.group-by":{},"esnext.map.includes":{},"esnext.map.key-by":{},"esnext.map.key-of":{},"esnext.map.map-keys":{},"esnext.map.map-values":{},"esnext.map.merge":{},"esnext.map.of":{},"esnext.map.reduce":{},"esnext.map.some":{},"esnext.map.update":{},"esnext.map.update-or-insert":{},"esnext.map.upsert":{},"esnext.math.clamp":{},"esnext.math.deg-per-rad":{},"esnext.math.degrees":{},"esnext.math.fscale":{},"esnext.math.iaddh":{},"esnext.math.imulh":{},"esnext.math.isubh":{},"esnext.math.rad-per-deg":{},"esnext.math.radians":{},"esnext.math.scale":{},"esnext.math.seeded-prng":{},"esnext.math.signbit":{},"esnext.math.umulh":{},"esnext.number.from-string":{},"esnext.number.range":{},"esnext.object.has-own":{"android":"93","chrome":"93","deno":"1.13","edge":"93","electron":"14.0","firefox":"92","ios":"15.4","node":"16.9","opera":"79","opera_mobile":"66","safari":"15.4","samsung":"17.0"},"esnext.object.iterate-entries":{},"esnext.object.iterate-keys":{},"esnext.object.iterate-values":{},"esnext.observable":{},"esnext.promise.all-settled":{"android":"76","chrome":"76","deno":"1.0","edge":"76","electron":"6.0","firefox":"71","ios":"13.0","node":"12.9","opera":"63","opera_mobile":"54","safari":"13","samsung":"12.0"},"esnext.promise.any":{"android":"85","chrome":"85","deno":"1.2","edge":"85","electron":"10.0","firefox":"79","ios":"14.0","node":"15.0","opera":"71","opera_mobile":"60","safari":"14.0","samsung":"14.0"},"esnext.promise.try":{},"esnext.reflect.define-metadata":{},"esnext.reflect.delete-metadata":{},"esnext.reflect.get-metadata":{},"esnext.reflect.get-metadata-keys":{},"esnext.reflect.get-own-metadata":{},"esnext.reflect.get-own-metadata-keys":{},"esnext.reflect.has-metadata":{},"esnext.reflect.has-own-metadata":{},"esnext.reflect.metadata":{},"esnext.set.add-all":{},"esnext.set.delete-all":{},"esnext.set.difference":{},"esnext.set.every":{},"esnext.set.filter":{},"esnext.set.find":{},"esnext.set.from":{},"esnext.set.intersection":{},"esnext.set.is-disjoint-from":{},"esnext.set.is-subset-of":{},"esnext.set.is-superset-of":{},"esnext.set.join":{},"esnext.set.map":{},"esnext.set.of":{},"esnext.set.reduce":{},"esnext.set.some":{},"esnext.set.symmetric-difference":{},"esnext.set.union":{},"esnext.string.at":{},"esnext.string.cooked":{},"esnext.string.code-points":{},"esnext.string.match-all":{"android":"80","chrome":"80","deno":"1.0","edge":"80","electron":"8.0","firefox":"73","ios":"13.4","node":"14.0","opera":"67","opera_mobile":"57","safari":"13.1","samsung":"13.0"},"esnext.string.replace-all":{"android":"85","chrome":"85","deno":"1.2","edge":"85","electron":"10.0","firefox":"77","ios":"13.4","node":"15.0","opera":"71","opera_mobile":"60","safari":"13.1","samsung":"14.0"},"esnext.symbol.async-dispose":{},"esnext.symbol.dispose":{},"esnext.symbol.matcher":{},"esnext.symbol.metadata":{},"esnext.symbol.observable":{},"esnext.symbol.pattern-match":{},"esnext.symbol.replace-all":{},"esnext.typed-array.from-async":{},"esnext.typed-array.at":{"android":"92","chrome":"92","deno":"1.12","edge":"92","electron":"14.0","firefox":"90","ios":"15.4","node":"16.6","opera":"78","opera_mobile":"65","safari":"15.4","samsung":"16.0"},"esnext.typed-array.filter-out":{},"esnext.typed-array.filter-reject":{},"esnext.typed-array.find-last":{"android":"97","chrome":"97","deno":"1.16","edge":"97","electron":"17.0","ios":"15.4","node":"18.0","opera":"83","opera_mobile":"68","safari":"15.4"},"esnext.typed-array.find-last-index":{"android":"97","chrome":"97","deno":"1.16","edge":"97","electron":"17.0","ios":"15.4","node":"18.0","opera":"83","opera_mobile":"68","safari":"15.4"},"esnext.typed-array.group-by":{},"esnext.typed-array.to-reversed":{},"esnext.typed-array.to-sorted":{},"esnext.typed-array.to-spliced":{},"esnext.typed-array.unique-by":{},"esnext.typed-array.with":{},"esnext.weak-map.delete-all":{},"esnext.weak-map.from":{},"esnext.weak-map.of":{},"esnext.weak-map.emplace":{},"esnext.weak-map.upsert":{},"esnext.weak-set.add-all":{},"esnext.weak-set.delete-all":{},"esnext.weak-set.from":{},"esnext.weak-set.of":{},"web.atob":{"android":"37","chrome":"34","deno":"1.0","edge":"16","electron":"0.20","firefox":"27","ios":"10.3","node":"18.0","opera":"10.5","opera_mobile":"10.5","safari":"10.1","samsung":"2.0"},"web.btoa":{"android":"3.0","chrome":"4","deno":"1.0","edge":"16","electron":"0.20","firefox":"27","ios":"1.0","node":"17.5","opera":"10.5","opera_mobile":"10.5","phantom":"1.9","safari":"3.0","samsung":"1.0"},"web.dom-collections.for-each":{"android":"58","chrome":"58","deno":"1.0","edge":"16","electron":"1.7","firefox":"50","ios":"10.0","node":"0.0.1","opera":"45","opera_mobile":"43","rhino":"1.7.13","safari":"10.0","samsung":"7.0"},"web.dom-collections.iterator":{"android":"66","chrome":"66","deno":"1.0","edge":"74","electron":"3.0","firefox":"60","ios":"13.4","node":"0.0.1","opera":"53","opera_mobile":"47","rhino":"1.7.13","safari":"13.1","samsung":"9.0"},"web.dom-exception.constructor":{"android":"46","chrome":"46","deno":"1.7","edge":"74","electron":"0.36","firefox":"37","ios":"11.3","node":"17.0","opera":"33","opera_mobile":"33","safari":"11.1","samsung":"5.0"},"web.dom-exception.stack":{"deno":"1.15","firefox":"37","node":"17.0"},"web.dom-exception.to-string-tag":{"android":"49","chrome":"49","deno":"1.7","edge":"74","electron":"0.37","firefox":"51","ios":"11.3","node":"17.0","opera":"36","opera_mobile":"36","safari":"11.1","samsung":"5.0"},"web.immediate":{"ie":"10","node":"0.9.1"},"web.queue-microtask":{"android":"71","chrome":"71","deno":"1.0","edge":"74","electron":"5.0","firefox":"69","ios":"12.2","node":"12.0","opera":"58","opera_mobile":"50","safari":"12.1","samsung":"10.0"},"web.structured-clone":{},"web.timers":{"android":"1.5","chrome":"1","deno":"1.0","edge":"12","electron":"0.20","firefox":"1","ie":"10","ios":"1.0","node":"0.0.1","opera":"7","opera_mobile":"7","phantom":"1.9","rhino":"1.7.13","safari":"1.0","samsung":"1.0"},"web.url":{"android":"67","chrome":"67","deno":"1.0","edge":"74","electron":"4.0","firefox":"57","ios":"14.0","node":"10.0","opera":"54","opera_mobile":"48","safari":"14.0","samsung":"9.0"},"web.url.to-json":{"android":"71","chrome":"71","deno":"1.0","edge":"74","electron":"5.0","firefox":"57","ios":"14.0","node":"10.0","opera":"58","opera_mobile":"50","safari":"14.0","samsung":"10.0"},"web.url-search-params":{"android":"67","chrome":"67","deno":"1.0","edge":"74","electron":"4.0","firefox":"57","ios":"14.0","node":"10.0","opera":"54","opera_mobile":"48","safari":"14.0","samsung":"9.0"}}');
    },
    4881: module => {
      "use strict";
      module.exports = JSON.parse('{"core-js":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/actual":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.at","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with","esnext.global-this","esnext.object.has-own","esnext.promise.all-settled","esnext.promise.any","esnext.string.match-all","esnext.string.replace-all","esnext.typed-array.at","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with","web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/actual/aggregate-error":["es.error.cause","es.aggregate-error","es.aggregate-error.cause","es.array.iterator","es.string.iterator","esnext.aggregate-error","web.dom-collections.iterator"],"core-js/actual/array":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.map","es.object.to-string","es.string.iterator","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with"],"core-js/actual/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/actual/array-buffer/constructor":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string"],"core-js/actual/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/actual/array-buffer/slice":["es.array-buffer.slice"],"core-js/actual/array/at":["es.array.at"],"core-js/actual/array/concat":["es.array.concat"],"core-js/actual/array/copy-within":["es.array.copy-within"],"core-js/actual/array/entries":["es.array.iterator","es.object.to-string"],"core-js/actual/array/every":["es.array.every"],"core-js/actual/array/fill":["es.array.fill"],"core-js/actual/array/filter":["es.array.filter"],"core-js/actual/array/find":["es.array.find"],"core-js/actual/array/find-index":["es.array.find-index"],"core-js/actual/array/find-last":["esnext.array.find-last"],"core-js/actual/array/find-last-index":["esnext.array.find-last-index"],"core-js/actual/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/actual/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/actual/array/for-each":["es.array.for-each"],"core-js/actual/array/from":["es.array.from","es.string.iterator"],"core-js/actual/array/group-by":["esnext.array.group-by"],"core-js/actual/array/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/actual/array/includes":["es.array.includes"],"core-js/actual/array/index-of":["es.array.index-of"],"core-js/actual/array/is-array":["es.array.is-array"],"core-js/actual/array/iterator":["es.array.iterator","es.object.to-string"],"core-js/actual/array/join":["es.array.join"],"core-js/actual/array/keys":["es.array.iterator","es.object.to-string"],"core-js/actual/array/last-index-of":["es.array.last-index-of"],"core-js/actual/array/map":["es.array.map"],"core-js/actual/array/of":["es.array.of"],"core-js/actual/array/reduce":["es.array.reduce"],"core-js/actual/array/reduce-right":["es.array.reduce-right"],"core-js/actual/array/reverse":["es.array.reverse"],"core-js/actual/array/slice":["es.array.slice"],"core-js/actual/array/some":["es.array.some"],"core-js/actual/array/sort":["es.array.sort"],"core-js/actual/array/splice":["es.array.splice"],"core-js/actual/array/to-reversed":["esnext.array.to-reversed"],"core-js/actual/array/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/actual/array/to-spliced":["esnext.array.to-spliced"],"core-js/actual/array/values":["es.array.iterator","es.object.to-string"],"core-js/actual/array/virtual":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.map","es.object.to-string","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with"],"core-js/actual/array/virtual/at":["es.array.at"],"core-js/actual/array/virtual/concat":["es.array.concat"],"core-js/actual/array/virtual/copy-within":["es.array.copy-within"],"core-js/actual/array/virtual/entries":["es.array.iterator","es.object.to-string"],"core-js/actual/array/virtual/every":["es.array.every"],"core-js/actual/array/virtual/fill":["es.array.fill"],"core-js/actual/array/virtual/filter":["es.array.filter"],"core-js/actual/array/virtual/find":["es.array.find"],"core-js/actual/array/virtual/find-index":["es.array.find-index"],"core-js/actual/array/virtual/find-last":["esnext.array.find-last"],"core-js/actual/array/virtual/find-last-index":["esnext.array.find-last-index"],"core-js/actual/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/actual/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/actual/array/virtual/for-each":["es.array.for-each"],"core-js/actual/array/virtual/group-by":["esnext.array.group-by"],"core-js/actual/array/virtual/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/actual/array/virtual/includes":["es.array.includes"],"core-js/actual/array/virtual/index-of":["es.array.index-of"],"core-js/actual/array/virtual/iterator":["es.array.iterator","es.object.to-string"],"core-js/actual/array/virtual/join":["es.array.join"],"core-js/actual/array/virtual/keys":["es.array.iterator","es.object.to-string"],"core-js/actual/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/actual/array/virtual/map":["es.array.map"],"core-js/actual/array/virtual/reduce":["es.array.reduce"],"core-js/actual/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/actual/array/virtual/reverse":["es.array.reverse"],"core-js/actual/array/virtual/slice":["es.array.slice"],"core-js/actual/array/virtual/some":["es.array.some"],"core-js/actual/array/virtual/sort":["es.array.sort"],"core-js/actual/array/virtual/splice":["es.array.splice"],"core-js/actual/array/virtual/to-reversed":["esnext.array.to-reversed"],"core-js/actual/array/virtual/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/actual/array/virtual/to-spliced":["esnext.array.to-spliced"],"core-js/actual/array/virtual/values":["es.array.iterator","es.object.to-string"],"core-js/actual/array/virtual/with":["esnext.array.with"],"core-js/actual/array/with":["esnext.array.with"],"core-js/actual/atob":["es.error.to-string","es.object.to-string","web.atob","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/actual/btoa":["es.error.to-string","es.object.to-string","web.btoa","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/actual/clear-immediate":["web.immediate"],"core-js/actual/data-view":["es.array-buffer.constructor","es.array-buffer.slice","es.data-view","es.object.to-string"],"core-js/actual/date":["es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/actual/date/get-year":["es.date.get-year"],"core-js/actual/date/now":["es.date.now"],"core-js/actual/date/set-year":["es.date.set-year"],"core-js/actual/date/to-gmt-string":["es.date.to-gmt-string"],"core-js/actual/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/actual/date/to-json":["es.date.to-json"],"core-js/actual/date/to-primitive":["es.date.to-primitive"],"core-js/actual/date/to-string":["es.date.to-string"],"core-js/actual/dom-collections":["es.array.iterator","es.object.to-string","web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/actual/dom-collections/for-each":["web.dom-collections.for-each"],"core-js/actual/dom-collections/iterator":["es.object.to-string","web.dom-collections.iterator"],"core-js/actual/dom-exception":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/actual/dom-exception/constructor":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack"],"core-js/actual/dom-exception/to-string-tag":["web.dom-exception.to-string-tag"],"core-js/actual/error":["es.error.cause","es.error.to-string"],"core-js/actual/error/constructor":["es.error.cause"],"core-js/actual/error/to-string":["es.error.to-string"],"core-js/actual/escape":["es.escape"],"core-js/actual/function":["es.function.bind","es.function.has-instance","es.function.name"],"core-js/actual/function/bind":["es.function.bind"],"core-js/actual/function/has-instance":["es.function.has-instance"],"core-js/actual/function/name":["es.function.name"],"core-js/actual/function/virtual":["es.function.bind"],"core-js/actual/function/virtual/bind":["es.function.bind"],"core-js/actual/get-iterator":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/get-iterator-method":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/global-this":["es.global-this"],"core-js/actual/instance/at":["es.array.at","es.string.at-alternative"],"core-js/actual/instance/bind":["es.function.bind"],"core-js/actual/instance/code-point-at":["es.string.code-point-at"],"core-js/actual/instance/concat":["es.array.concat"],"core-js/actual/instance/copy-within":["es.array.copy-within"],"core-js/actual/instance/ends-with":["es.string.ends-with"],"core-js/actual/instance/entries":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/actual/instance/every":["es.array.every"],"core-js/actual/instance/fill":["es.array.fill"],"core-js/actual/instance/filter":["es.array.filter"],"core-js/actual/instance/find":["es.array.find"],"core-js/actual/instance/find-index":["es.array.find-index"],"core-js/actual/instance/find-last":["esnext.array.find-last"],"core-js/actual/instance/find-last-index":["esnext.array.find-last-index"],"core-js/actual/instance/flags":["es.regexp.flags"],"core-js/actual/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/actual/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/actual/instance/for-each":["es.array.for-each","web.dom-collections.iterator"],"core-js/actual/instance/group-by":["esnext.array.group-by"],"core-js/actual/instance/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/actual/instance/includes":["es.array.includes","es.string.includes"],"core-js/actual/instance/index-of":["es.array.index-of"],"core-js/actual/instance/keys":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/actual/instance/last-index-of":["es.array.last-index-of"],"core-js/actual/instance/map":["es.array.map"],"core-js/actual/instance/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/actual/instance/pad-end":["es.string.pad-end"],"core-js/actual/instance/pad-start":["es.string.pad-start"],"core-js/actual/instance/reduce":["es.array.reduce"],"core-js/actual/instance/reduce-right":["es.array.reduce-right"],"core-js/actual/instance/repeat":["es.string.repeat"],"core-js/actual/instance/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/actual/instance/reverse":["es.array.reverse"],"core-js/actual/instance/slice":["es.array.slice"],"core-js/actual/instance/some":["es.array.some"],"core-js/actual/instance/sort":["es.array.sort"],"core-js/actual/instance/splice":["es.array.splice"],"core-js/actual/instance/starts-with":["es.string.starts-with"],"core-js/actual/instance/to-reversed":["esnext.array.to-reversed"],"core-js/actual/instance/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/actual/instance/to-spliced":["esnext.array.to-spliced"],"core-js/actual/instance/trim":["es.string.trim"],"core-js/actual/instance/trim-end":["es.string.trim-end"],"core-js/actual/instance/trim-left":["es.string.trim-start"],"core-js/actual/instance/trim-right":["es.string.trim-end"],"core-js/actual/instance/trim-start":["es.string.trim-start"],"core-js/actual/instance/values":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/actual/instance/with":["esnext.array.with"],"core-js/actual/is-iterable":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/json":["es.json.stringify","es.json.to-string-tag"],"core-js/actual/json/stringify":["es.json.stringify"],"core-js/actual/json/to-string-tag":["es.json.to-string-tag"],"core-js/actual/map":["es.array.iterator","es.map","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc"],"core-js/actual/math/acosh":["es.math.acosh"],"core-js/actual/math/asinh":["es.math.asinh"],"core-js/actual/math/atanh":["es.math.atanh"],"core-js/actual/math/cbrt":["es.math.cbrt"],"core-js/actual/math/clz32":["es.math.clz32"],"core-js/actual/math/cosh":["es.math.cosh"],"core-js/actual/math/expm1":["es.math.expm1"],"core-js/actual/math/fround":["es.math.fround"],"core-js/actual/math/hypot":["es.math.hypot"],"core-js/actual/math/imul":["es.math.imul"],"core-js/actual/math/log10":["es.math.log10"],"core-js/actual/math/log1p":["es.math.log1p"],"core-js/actual/math/log2":["es.math.log2"],"core-js/actual/math/sign":["es.math.sign"],"core-js/actual/math/sinh":["es.math.sinh"],"core-js/actual/math/tanh":["es.math.tanh"],"core-js/actual/math/to-string-tag":["es.math.to-string-tag"],"core-js/actual/math/trunc":["es.math.trunc"],"core-js/actual/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/actual/number/constructor":["es.number.constructor"],"core-js/actual/number/epsilon":["es.number.epsilon"],"core-js/actual/number/is-finite":["es.number.is-finite"],"core-js/actual/number/is-integer":["es.number.is-integer"],"core-js/actual/number/is-nan":["es.number.is-nan"],"core-js/actual/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/actual/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/actual/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/actual/number/parse-float":["es.number.parse-float"],"core-js/actual/number/parse-int":["es.number.parse-int"],"core-js/actual/number/to-exponential":["es.number.to-exponential"],"core-js/actual/number/to-fixed":["es.number.to-fixed"],"core-js/actual/number/to-precision":["es.number.to-precision"],"core-js/actual/number/virtual":["es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/actual/number/virtual/to-exponential":["es.number.to-exponential"],"core-js/actual/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/actual/number/virtual/to-precision":["es.number.to-precision"],"core-js/actual/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.reflect.to-string-tag","web.dom-collections.iterator"],"core-js/actual/object/assign":["es.object.assign"],"core-js/actual/object/create":["es.object.create"],"core-js/actual/object/define-getter":["es.object.define-getter"],"core-js/actual/object/define-properties":["es.object.define-properties"],"core-js/actual/object/define-property":["es.object.define-property"],"core-js/actual/object/define-setter":["es.object.define-setter"],"core-js/actual/object/entries":["es.object.entries"],"core-js/actual/object/freeze":["es.object.freeze"],"core-js/actual/object/from-entries":["es.array.iterator","es.object.from-entries","web.dom-collections.iterator"],"core-js/actual/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/actual/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/actual/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/actual/object/get-own-property-symbols":["es.symbol"],"core-js/actual/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/actual/object/has-own":["es.object.has-own"],"core-js/actual/object/is":["es.object.is"],"core-js/actual/object/is-extensible":["es.object.is-extensible"],"core-js/actual/object/is-frozen":["es.object.is-frozen"],"core-js/actual/object/is-sealed":["es.object.is-sealed"],"core-js/actual/object/keys":["es.object.keys"],"core-js/actual/object/lookup-getter":["es.object.lookup-getter"],"core-js/actual/object/lookup-setter":["es.object.lookup-setter"],"core-js/actual/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/actual/object/seal":["es.object.seal"],"core-js/actual/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/actual/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/actual/object/values":["es.object.values"],"core-js/actual/parse-float":["es.parse-float"],"core-js/actual/parse-int":["es.parse-int"],"core-js/actual/promise":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/promise/all-settled":["es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/promise/any":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.any","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/promise/finally":["es.object.to-string","es.promise","es.promise.finally"],"core-js/actual/queue-microtask":["web.queue-microtask"],"core-js/actual/reflect":["es.object.to-string","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag"],"core-js/actual/reflect/apply":["es.reflect.apply"],"core-js/actual/reflect/construct":["es.reflect.construct"],"core-js/actual/reflect/define-property":["es.reflect.define-property"],"core-js/actual/reflect/delete-property":["es.reflect.delete-property"],"core-js/actual/reflect/get":["es.reflect.get"],"core-js/actual/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/actual/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/actual/reflect/has":["es.reflect.has"],"core-js/actual/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/actual/reflect/own-keys":["es.reflect.own-keys"],"core-js/actual/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/actual/reflect/set":["es.reflect.set"],"core-js/actual/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/actual/reflect/to-string-tag":["es.reflect.to-string-tag"],"core-js/actual/regexp":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/actual/regexp/constructor":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.sticky"],"core-js/actual/regexp/dot-all":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec"],"core-js/actual/regexp/flags":["es.regexp.flags"],"core-js/actual/regexp/match":["es.regexp.exec","es.string.match"],"core-js/actual/regexp/replace":["es.regexp.exec","es.string.replace"],"core-js/actual/regexp/search":["es.regexp.exec","es.string.search"],"core-js/actual/regexp/split":["es.regexp.exec","es.string.split"],"core-js/actual/regexp/sticky":["es.regexp.constructor","es.regexp.exec","es.regexp.sticky"],"core-js/actual/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/actual/regexp/to-string":["es.regexp.to-string"],"core-js/actual/set":["es.array.iterator","es.object.to-string","es.set","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/set-immediate":["web.immediate"],"core-js/actual/set-interval":["web.timers"],"core-js/actual/set-timeout":["web.timers"],"core-js/actual/string":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/actual/string/anchor":["es.string.anchor"],"core-js/actual/string/at":["es.string.at-alternative"],"core-js/actual/string/big":["es.string.big"],"core-js/actual/string/blink":["es.string.blink"],"core-js/actual/string/bold":["es.string.bold"],"core-js/actual/string/code-point-at":["es.string.code-point-at"],"core-js/actual/string/ends-with":["es.string.ends-with"],"core-js/actual/string/fixed":["es.string.fixed"],"core-js/actual/string/fontcolor":["es.string.fontcolor"],"core-js/actual/string/fontsize":["es.string.fontsize"],"core-js/actual/string/from-code-point":["es.string.from-code-point"],"core-js/actual/string/includes":["es.string.includes"],"core-js/actual/string/italics":["es.string.italics"],"core-js/actual/string/iterator":["es.object.to-string","es.string.iterator"],"core-js/actual/string/link":["es.string.link"],"core-js/actual/string/match":["es.regexp.exec","es.string.match"],"core-js/actual/string/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/actual/string/pad-end":["es.string.pad-end"],"core-js/actual/string/pad-start":["es.string.pad-start"],"core-js/actual/string/raw":["es.string.raw"],"core-js/actual/string/repeat":["es.string.repeat"],"core-js/actual/string/replace":["es.regexp.exec","es.string.replace"],"core-js/actual/string/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/actual/string/search":["es.regexp.exec","es.string.search"],"core-js/actual/string/small":["es.string.small"],"core-js/actual/string/split":["es.regexp.exec","es.string.split"],"core-js/actual/string/starts-with":["es.string.starts-with"],"core-js/actual/string/strike":["es.string.strike"],"core-js/actual/string/sub":["es.string.sub"],"core-js/actual/string/substr":["es.string.substr"],"core-js/actual/string/sup":["es.string.sup"],"core-js/actual/string/trim":["es.string.trim"],"core-js/actual/string/trim-end":["es.string.trim-end"],"core-js/actual/string/trim-left":["es.string.trim-start"],"core-js/actual/string/trim-right":["es.string.trim-end"],"core-js/actual/string/trim-start":["es.string.trim-start"],"core-js/actual/string/virtual":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/actual/string/virtual/anchor":["es.string.anchor"],"core-js/actual/string/virtual/at":["es.string.at-alternative"],"core-js/actual/string/virtual/big":["es.string.big"],"core-js/actual/string/virtual/blink":["es.string.blink"],"core-js/actual/string/virtual/bold":["es.string.bold"],"core-js/actual/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/actual/string/virtual/ends-with":["es.string.ends-with"],"core-js/actual/string/virtual/fixed":["es.string.fixed"],"core-js/actual/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/actual/string/virtual/fontsize":["es.string.fontsize"],"core-js/actual/string/virtual/includes":["es.string.includes"],"core-js/actual/string/virtual/italics":["es.string.italics"],"core-js/actual/string/virtual/iterator":["es.object.to-string","es.string.iterator"],"core-js/actual/string/virtual/link":["es.string.link"],"core-js/actual/string/virtual/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/actual/string/virtual/pad-end":["es.string.pad-end"],"core-js/actual/string/virtual/pad-start":["es.string.pad-start"],"core-js/actual/string/virtual/repeat":["es.string.repeat"],"core-js/actual/string/virtual/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/actual/string/virtual/small":["es.string.small"],"core-js/actual/string/virtual/starts-with":["es.string.starts-with"],"core-js/actual/string/virtual/strike":["es.string.strike"],"core-js/actual/string/virtual/sub":["es.string.sub"],"core-js/actual/string/virtual/substr":["es.string.substr"],"core-js/actual/string/virtual/sup":["es.string.sup"],"core-js/actual/string/virtual/trim":["es.string.trim"],"core-js/actual/string/virtual/trim-end":["es.string.trim-end"],"core-js/actual/string/virtual/trim-left":["es.string.trim-start"],"core-js/actual/string/virtual/trim-right":["es.string.trim-end"],"core-js/actual/string/virtual/trim-start":["es.string.trim-start"],"core-js/actual/structured-clone":["es.error.to-string","es.array.iterator","es.map","es.object.keys","es.object.to-string","es.set","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.structured-clone"],"core-js/actual/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag","web.dom-collections.iterator"],"core-js/actual/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/actual/symbol/description":["es.symbol.description"],"core-js/actual/symbol/for":["es.symbol"],"core-js/actual/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/actual/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/actual/symbol/iterator":["es.symbol.iterator","es.array.iterator","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/actual/symbol/key-for":["es.symbol"],"core-js/actual/symbol/match":["es.symbol.match","es.regexp.exec","es.string.match"],"core-js/actual/symbol/match-all":["es.symbol.match-all","es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/actual/symbol/replace":["es.symbol.replace","es.regexp.exec","es.string.replace"],"core-js/actual/symbol/search":["es.symbol.search","es.regexp.exec","es.string.search"],"core-js/actual/symbol/species":["es.symbol.species"],"core-js/actual/symbol/split":["es.symbol.split","es.regexp.exec","es.string.split"],"core-js/actual/symbol/to-primitive":["es.symbol.to-primitive","es.date.to-primitive"],"core-js/actual/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/actual/symbol/unscopables":["es.symbol.unscopables"],"core-js/actual/typed-array":["es.object.to-string","es.string.iterator","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/at":["es.typed-array.at"],"core-js/actual/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/actual/typed-array/entries":["es.object.to-string","es.typed-array.iterator"],"core-js/actual/typed-array/every":["es.typed-array.every"],"core-js/actual/typed-array/fill":["es.typed-array.fill"],"core-js/actual/typed-array/filter":["es.typed-array.filter"],"core-js/actual/typed-array/find":["es.typed-array.find"],"core-js/actual/typed-array/find-index":["es.typed-array.find-index"],"core-js/actual/typed-array/find-last":["esnext.typed-array.find-last"],"core-js/actual/typed-array/find-last-index":["esnext.typed-array.find-last-index"],"core-js/actual/typed-array/float32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.float32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/float64-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.float64-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/for-each":["es.typed-array.for-each"],"core-js/actual/typed-array/from":["es.typed-array.from"],"core-js/actual/typed-array/includes":["es.typed-array.includes"],"core-js/actual/typed-array/index-of":["es.typed-array.index-of"],"core-js/actual/typed-array/int16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/int32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/int8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/iterator":["es.object.to-string","es.typed-array.iterator"],"core-js/actual/typed-array/join":["es.typed-array.join"],"core-js/actual/typed-array/keys":["es.object.to-string","es.typed-array.iterator"],"core-js/actual/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/actual/typed-array/map":["es.typed-array.map"],"core-js/actual/typed-array/methods":["es.object.to-string","es.string.iterator","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/of":["es.typed-array.of"],"core-js/actual/typed-array/reduce":["es.typed-array.reduce"],"core-js/actual/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/actual/typed-array/reverse":["es.typed-array.reverse"],"core-js/actual/typed-array/set":["es.typed-array.set"],"core-js/actual/typed-array/slice":["es.typed-array.slice"],"core-js/actual/typed-array/some":["es.typed-array.some"],"core-js/actual/typed-array/sort":["es.typed-array.sort"],"core-js/actual/typed-array/subarray":["es.typed-array.subarray"],"core-js/actual/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/actual/typed-array/to-reversed":["esnext.typed-array.to-reversed"],"core-js/actual/typed-array/to-sorted":["es.typed-array.sort","esnext.typed-array.to-sorted"],"core-js/actual/typed-array/to-spliced":["esnext.typed-array.to-spliced"],"core-js/actual/typed-array/to-string":["es.typed-array.to-string"],"core-js/actual/typed-array/uint16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/uint32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/uint8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/uint8-clamped-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint8-clamped-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/actual/typed-array/values":["es.object.to-string","es.typed-array.iterator"],"core-js/actual/typed-array/with":["esnext.typed-array.with"],"core-js/actual/unescape":["es.unescape"],"core-js/actual/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/actual/url-search-params":["web.dom-collections.iterator","web.url-search-params"],"core-js/actual/url/to-json":["web.url.to-json"],"core-js/actual/weak-map":["es.array.iterator","es.object.to-string","es.weak-map","web.dom-collections.iterator"],"core-js/actual/weak-set":["es.array.iterator","es.object.to-string","es.weak-set","web.dom-collections.iterator"],"core-js/es":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set"],"core-js/es/aggregate-error":["es.error.cause","es.aggregate-error","es.aggregate-error.cause","es.array.iterator","es.string.iterator"],"core-js/es/array":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.object.to-string","es.string.iterator"],"core-js/es/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/es/array-buffer/constructor":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string"],"core-js/es/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/es/array-buffer/slice":["es.array-buffer.slice"],"core-js/es/array/at":["es.array.at"],"core-js/es/array/concat":["es.array.concat"],"core-js/es/array/copy-within":["es.array.copy-within"],"core-js/es/array/entries":["es.array.iterator","es.object.to-string"],"core-js/es/array/every":["es.array.every"],"core-js/es/array/fill":["es.array.fill"],"core-js/es/array/filter":["es.array.filter"],"core-js/es/array/find":["es.array.find"],"core-js/es/array/find-index":["es.array.find-index"],"core-js/es/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/es/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/es/array/for-each":["es.array.for-each"],"core-js/es/array/from":["es.array.from","es.string.iterator"],"core-js/es/array/includes":["es.array.includes"],"core-js/es/array/index-of":["es.array.index-of"],"core-js/es/array/is-array":["es.array.is-array"],"core-js/es/array/iterator":["es.array.iterator","es.object.to-string"],"core-js/es/array/join":["es.array.join"],"core-js/es/array/keys":["es.array.iterator","es.object.to-string"],"core-js/es/array/last-index-of":["es.array.last-index-of"],"core-js/es/array/map":["es.array.map"],"core-js/es/array/of":["es.array.of"],"core-js/es/array/reduce":["es.array.reduce"],"core-js/es/array/reduce-right":["es.array.reduce-right"],"core-js/es/array/reverse":["es.array.reverse"],"core-js/es/array/slice":["es.array.slice"],"core-js/es/array/some":["es.array.some"],"core-js/es/array/sort":["es.array.sort"],"core-js/es/array/splice":["es.array.splice"],"core-js/es/array/values":["es.array.iterator","es.object.to-string"],"core-js/es/array/virtual":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.object.to-string"],"core-js/es/array/virtual/at":["es.array.at"],"core-js/es/array/virtual/concat":["es.array.concat"],"core-js/es/array/virtual/copy-within":["es.array.copy-within"],"core-js/es/array/virtual/entries":["es.array.iterator","es.object.to-string"],"core-js/es/array/virtual/every":["es.array.every"],"core-js/es/array/virtual/fill":["es.array.fill"],"core-js/es/array/virtual/filter":["es.array.filter"],"core-js/es/array/virtual/find":["es.array.find"],"core-js/es/array/virtual/find-index":["es.array.find-index"],"core-js/es/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/es/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/es/array/virtual/for-each":["es.array.for-each"],"core-js/es/array/virtual/includes":["es.array.includes"],"core-js/es/array/virtual/index-of":["es.array.index-of"],"core-js/es/array/virtual/iterator":["es.array.iterator","es.object.to-string"],"core-js/es/array/virtual/join":["es.array.join"],"core-js/es/array/virtual/keys":["es.array.iterator","es.object.to-string"],"core-js/es/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/es/array/virtual/map":["es.array.map"],"core-js/es/array/virtual/reduce":["es.array.reduce"],"core-js/es/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/es/array/virtual/reverse":["es.array.reverse"],"core-js/es/array/virtual/slice":["es.array.slice"],"core-js/es/array/virtual/some":["es.array.some"],"core-js/es/array/virtual/sort":["es.array.sort"],"core-js/es/array/virtual/splice":["es.array.splice"],"core-js/es/array/virtual/values":["es.array.iterator","es.object.to-string"],"core-js/es/data-view":["es.array-buffer.constructor","es.array-buffer.slice","es.data-view","es.object.to-string"],"core-js/es/date":["es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/es/date/get-year":["es.date.get-year"],"core-js/es/date/now":["es.date.now"],"core-js/es/date/set-year":["es.date.set-year"],"core-js/es/date/to-gmt-string":["es.date.to-gmt-string"],"core-js/es/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/es/date/to-json":["es.date.to-json"],"core-js/es/date/to-primitive":["es.date.to-primitive"],"core-js/es/date/to-string":["es.date.to-string"],"core-js/es/error":["es.error.cause","es.error.to-string"],"core-js/es/error/constructor":["es.error.cause"],"core-js/es/error/to-string":["es.error.to-string"],"core-js/es/escape":["es.escape"],"core-js/es/function":["es.function.bind","es.function.has-instance","es.function.name"],"core-js/es/function/bind":["es.function.bind"],"core-js/es/function/has-instance":["es.function.has-instance"],"core-js/es/function/name":["es.function.name"],"core-js/es/function/virtual":["es.function.bind"],"core-js/es/function/virtual/bind":["es.function.bind"],"core-js/es/get-iterator":["es.array.iterator","es.string.iterator"],"core-js/es/get-iterator-method":["es.array.iterator","es.string.iterator"],"core-js/es/global-this":["es.global-this"],"core-js/es/instance/at":["es.array.at","es.string.at-alternative"],"core-js/es/instance/bind":["es.function.bind"],"core-js/es/instance/code-point-at":["es.string.code-point-at"],"core-js/es/instance/concat":["es.array.concat"],"core-js/es/instance/copy-within":["es.array.copy-within"],"core-js/es/instance/ends-with":["es.string.ends-with"],"core-js/es/instance/entries":["es.array.iterator","es.object.to-string"],"core-js/es/instance/every":["es.array.every"],"core-js/es/instance/fill":["es.array.fill"],"core-js/es/instance/filter":["es.array.filter"],"core-js/es/instance/find":["es.array.find"],"core-js/es/instance/find-index":["es.array.find-index"],"core-js/es/instance/flags":["es.regexp.flags"],"core-js/es/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/es/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/es/instance/for-each":["es.array.for-each"],"core-js/es/instance/includes":["es.array.includes","es.string.includes"],"core-js/es/instance/index-of":["es.array.index-of"],"core-js/es/instance/keys":["es.array.iterator","es.object.to-string"],"core-js/es/instance/last-index-of":["es.array.last-index-of"],"core-js/es/instance/map":["es.array.map"],"core-js/es/instance/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/es/instance/pad-end":["es.string.pad-end"],"core-js/es/instance/pad-start":["es.string.pad-start"],"core-js/es/instance/reduce":["es.array.reduce"],"core-js/es/instance/reduce-right":["es.array.reduce-right"],"core-js/es/instance/repeat":["es.string.repeat"],"core-js/es/instance/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/es/instance/reverse":["es.array.reverse"],"core-js/es/instance/slice":["es.array.slice"],"core-js/es/instance/some":["es.array.some"],"core-js/es/instance/sort":["es.array.sort"],"core-js/es/instance/splice":["es.array.splice"],"core-js/es/instance/starts-with":["es.string.starts-with"],"core-js/es/instance/trim":["es.string.trim"],"core-js/es/instance/trim-end":["es.string.trim-end"],"core-js/es/instance/trim-left":["es.string.trim-start"],"core-js/es/instance/trim-right":["es.string.trim-end"],"core-js/es/instance/trim-start":["es.string.trim-start"],"core-js/es/instance/values":["es.array.iterator","es.object.to-string"],"core-js/es/is-iterable":["es.array.iterator","es.string.iterator"],"core-js/es/json":["es.json.stringify","es.json.to-string-tag"],"core-js/es/json/stringify":["es.json.stringify"],"core-js/es/json/to-string-tag":["es.json.to-string-tag"],"core-js/es/map":["es.array.iterator","es.map","es.object.to-string","es.string.iterator"],"core-js/es/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc"],"core-js/es/math/acosh":["es.math.acosh"],"core-js/es/math/asinh":["es.math.asinh"],"core-js/es/math/atanh":["es.math.atanh"],"core-js/es/math/cbrt":["es.math.cbrt"],"core-js/es/math/clz32":["es.math.clz32"],"core-js/es/math/cosh":["es.math.cosh"],"core-js/es/math/expm1":["es.math.expm1"],"core-js/es/math/fround":["es.math.fround"],"core-js/es/math/hypot":["es.math.hypot"],"core-js/es/math/imul":["es.math.imul"],"core-js/es/math/log10":["es.math.log10"],"core-js/es/math/log1p":["es.math.log1p"],"core-js/es/math/log2":["es.math.log2"],"core-js/es/math/sign":["es.math.sign"],"core-js/es/math/sinh":["es.math.sinh"],"core-js/es/math/tanh":["es.math.tanh"],"core-js/es/math/to-string-tag":["es.math.to-string-tag"],"core-js/es/math/trunc":["es.math.trunc"],"core-js/es/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/es/number/constructor":["es.number.constructor"],"core-js/es/number/epsilon":["es.number.epsilon"],"core-js/es/number/is-finite":["es.number.is-finite"],"core-js/es/number/is-integer":["es.number.is-integer"],"core-js/es/number/is-nan":["es.number.is-nan"],"core-js/es/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/es/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/es/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/es/number/parse-float":["es.number.parse-float"],"core-js/es/number/parse-int":["es.number.parse-int"],"core-js/es/number/to-exponential":["es.number.to-exponential"],"core-js/es/number/to-fixed":["es.number.to-fixed"],"core-js/es/number/to-precision":["es.number.to-precision"],"core-js/es/number/virtual":["es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/es/number/virtual/to-exponential":["es.number.to-exponential"],"core-js/es/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/es/number/virtual/to-precision":["es.number.to-precision"],"core-js/es/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.reflect.to-string-tag"],"core-js/es/object/assign":["es.object.assign"],"core-js/es/object/create":["es.object.create"],"core-js/es/object/define-getter":["es.object.define-getter"],"core-js/es/object/define-properties":["es.object.define-properties"],"core-js/es/object/define-property":["es.object.define-property"],"core-js/es/object/define-setter":["es.object.define-setter"],"core-js/es/object/entries":["es.object.entries"],"core-js/es/object/freeze":["es.object.freeze"],"core-js/es/object/from-entries":["es.array.iterator","es.object.from-entries"],"core-js/es/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/es/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/es/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/es/object/get-own-property-symbols":["es.symbol"],"core-js/es/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/es/object/has-own":["es.object.has-own"],"core-js/es/object/is":["es.object.is"],"core-js/es/object/is-extensible":["es.object.is-extensible"],"core-js/es/object/is-frozen":["es.object.is-frozen"],"core-js/es/object/is-sealed":["es.object.is-sealed"],"core-js/es/object/keys":["es.object.keys"],"core-js/es/object/lookup-getter":["es.object.lookup-getter"],"core-js/es/object/lookup-setter":["es.object.lookup-setter"],"core-js/es/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/es/object/seal":["es.object.seal"],"core-js/es/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/es/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/es/object/values":["es.object.values"],"core-js/es/parse-float":["es.parse-float"],"core-js/es/parse-int":["es.parse-int"],"core-js/es/promise":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.string.iterator"],"core-js/es/promise/all-settled":["es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.string.iterator"],"core-js/es/promise/any":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.any","es.string.iterator"],"core-js/es/promise/finally":["es.object.to-string","es.promise","es.promise.finally"],"core-js/es/reflect":["es.object.to-string","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag"],"core-js/es/reflect/apply":["es.reflect.apply"],"core-js/es/reflect/construct":["es.reflect.construct"],"core-js/es/reflect/define-property":["es.reflect.define-property"],"core-js/es/reflect/delete-property":["es.reflect.delete-property"],"core-js/es/reflect/get":["es.reflect.get"],"core-js/es/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/es/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/es/reflect/has":["es.reflect.has"],"core-js/es/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/es/reflect/own-keys":["es.reflect.own-keys"],"core-js/es/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/es/reflect/set":["es.reflect.set"],"core-js/es/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/es/reflect/to-string-tag":["es.object.to-string","es.reflect.to-string-tag"],"core-js/es/regexp":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/es/regexp/constructor":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.sticky"],"core-js/es/regexp/dot-all":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec"],"core-js/es/regexp/flags":["es.regexp.flags"],"core-js/es/regexp/match":["es.regexp.exec","es.string.match"],"core-js/es/regexp/replace":["es.regexp.exec","es.string.replace"],"core-js/es/regexp/search":["es.regexp.exec","es.string.search"],"core-js/es/regexp/split":["es.regexp.exec","es.string.split"],"core-js/es/regexp/sticky":["es.regexp.constructor","es.regexp.exec","es.regexp.sticky"],"core-js/es/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/es/regexp/to-string":["es.regexp.to-string"],"core-js/es/set":["es.array.iterator","es.object.to-string","es.set","es.string.iterator"],"core-js/es/string":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/es/string/anchor":["es.string.anchor"],"core-js/es/string/at":["es.string.at-alternative"],"core-js/es/string/big":["es.string.big"],"core-js/es/string/blink":["es.string.blink"],"core-js/es/string/bold":["es.string.bold"],"core-js/es/string/code-point-at":["es.string.code-point-at"],"core-js/es/string/ends-with":["es.string.ends-with"],"core-js/es/string/fixed":["es.string.fixed"],"core-js/es/string/fontcolor":["es.string.fontcolor"],"core-js/es/string/fontsize":["es.string.fontsize"],"core-js/es/string/from-code-point":["es.string.from-code-point"],"core-js/es/string/includes":["es.string.includes"],"core-js/es/string/italics":["es.string.italics"],"core-js/es/string/iterator":["es.object.to-string","es.string.iterator"],"core-js/es/string/link":["es.string.link"],"core-js/es/string/match":["es.regexp.exec","es.string.match"],"core-js/es/string/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/es/string/pad-end":["es.string.pad-end"],"core-js/es/string/pad-start":["es.string.pad-start"],"core-js/es/string/raw":["es.string.raw"],"core-js/es/string/repeat":["es.string.repeat"],"core-js/es/string/replace":["es.regexp.exec","es.string.replace"],"core-js/es/string/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/es/string/search":["es.regexp.exec","es.string.search"],"core-js/es/string/small":["es.string.small"],"core-js/es/string/split":["es.regexp.exec","es.string.split"],"core-js/es/string/starts-with":["es.string.starts-with"],"core-js/es/string/strike":["es.string.strike"],"core-js/es/string/sub":["es.string.sub"],"core-js/es/string/substr":["es.string.substr"],"core-js/es/string/sup":["es.string.sup"],"core-js/es/string/trim":["es.string.trim"],"core-js/es/string/trim-end":["es.string.trim-end"],"core-js/es/string/trim-left":["es.string.trim-start"],"core-js/es/string/trim-right":["es.string.trim-end"],"core-js/es/string/trim-start":["es.string.trim-start"],"core-js/es/string/virtual":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/es/string/virtual/anchor":["es.string.anchor"],"core-js/es/string/virtual/at":["es.string.at-alternative"],"core-js/es/string/virtual/big":["es.string.big"],"core-js/es/string/virtual/blink":["es.string.blink"],"core-js/es/string/virtual/bold":["es.string.bold"],"core-js/es/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/es/string/virtual/ends-with":["es.string.ends-with"],"core-js/es/string/virtual/fixed":["es.string.fixed"],"core-js/es/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/es/string/virtual/fontsize":["es.string.fontsize"],"core-js/es/string/virtual/includes":["es.string.includes"],"core-js/es/string/virtual/italics":["es.string.italics"],"core-js/es/string/virtual/iterator":["es.object.to-string","es.string.iterator"],"core-js/es/string/virtual/link":["es.string.link"],"core-js/es/string/virtual/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/es/string/virtual/pad-end":["es.string.pad-end"],"core-js/es/string/virtual/pad-start":["es.string.pad-start"],"core-js/es/string/virtual/repeat":["es.string.repeat"],"core-js/es/string/virtual/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/es/string/virtual/small":["es.string.small"],"core-js/es/string/virtual/starts-with":["es.string.starts-with"],"core-js/es/string/virtual/strike":["es.string.strike"],"core-js/es/string/virtual/sub":["es.string.sub"],"core-js/es/string/virtual/substr":["es.string.substr"],"core-js/es/string/virtual/sup":["es.string.sup"],"core-js/es/string/virtual/trim":["es.string.trim"],"core-js/es/string/virtual/trim-end":["es.string.trim-end"],"core-js/es/string/virtual/trim-left":["es.string.trim-start"],"core-js/es/string/virtual/trim-right":["es.string.trim-end"],"core-js/es/string/virtual/trim-start":["es.string.trim-start"],"core-js/es/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/es/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/es/symbol/description":["es.symbol.description"],"core-js/es/symbol/for":["es.symbol"],"core-js/es/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/es/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/es/symbol/iterator":["es.symbol.iterator","es.array.iterator","es.object.to-string","es.string.iterator"],"core-js/es/symbol/key-for":["es.symbol"],"core-js/es/symbol/match":["es.symbol.match","es.regexp.exec","es.string.match"],"core-js/es/symbol/match-all":["es.symbol.match-all","es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/es/symbol/replace":["es.symbol.replace","es.regexp.exec","es.string.replace"],"core-js/es/symbol/search":["es.symbol.search","es.regexp.exec","es.string.search"],"core-js/es/symbol/species":["es.symbol.species"],"core-js/es/symbol/split":["es.symbol.split","es.regexp.exec","es.string.split"],"core-js/es/symbol/to-primitive":["es.symbol.to-primitive","es.date.to-primitive"],"core-js/es/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/es/symbol/unscopables":["es.symbol.unscopables"],"core-js/es/typed-array":["es.object.to-string","es.string.iterator","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/at":["es.typed-array.at"],"core-js/es/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/es/typed-array/entries":["es.object.to-string","es.typed-array.iterator"],"core-js/es/typed-array/every":["es.typed-array.every"],"core-js/es/typed-array/fill":["es.typed-array.fill"],"core-js/es/typed-array/filter":["es.typed-array.filter"],"core-js/es/typed-array/find":["es.typed-array.find"],"core-js/es/typed-array/find-index":["es.typed-array.find-index"],"core-js/es/typed-array/float32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.float32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/float64-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.float64-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/for-each":["es.typed-array.for-each"],"core-js/es/typed-array/from":["es.typed-array.from"],"core-js/es/typed-array/includes":["es.typed-array.includes"],"core-js/es/typed-array/index-of":["es.typed-array.index-of"],"core-js/es/typed-array/int16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/int32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/int8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/iterator":["es.object.to-string","es.typed-array.iterator"],"core-js/es/typed-array/join":["es.typed-array.join"],"core-js/es/typed-array/keys":["es.object.to-string","es.typed-array.iterator"],"core-js/es/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/es/typed-array/map":["es.typed-array.map"],"core-js/es/typed-array/methods":["es.object.to-string","es.string.iterator","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/of":["es.typed-array.of"],"core-js/es/typed-array/reduce":["es.typed-array.reduce"],"core-js/es/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/es/typed-array/reverse":["es.typed-array.reverse"],"core-js/es/typed-array/set":["es.typed-array.set"],"core-js/es/typed-array/slice":["es.typed-array.slice"],"core-js/es/typed-array/some":["es.typed-array.some"],"core-js/es/typed-array/sort":["es.typed-array.sort"],"core-js/es/typed-array/subarray":["es.typed-array.subarray"],"core-js/es/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/es/typed-array/to-string":["es.typed-array.to-string"],"core-js/es/typed-array/uint16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/uint32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/uint8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/uint8-clamped-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint8-clamped-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/values":["es.object.to-string","es.typed-array.iterator"],"core-js/es/unescape":["es.unescape"],"core-js/es/weak-map":["es.array.iterator","es.object.to-string","es.weak-map"],"core-js/es/weak-set":["es.array.iterator","es.object.to-string","es.weak-set"],"core-js/features":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/features/aggregate-error":["es.error.cause","es.aggregate-error","es.aggregate-error.cause","es.array.iterator","es.string.iterator","esnext.aggregate-error","web.dom-collections.iterator"],"core-js/features/array":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.map","es.object.to-string","es.promise","es.string.iterator","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with"],"core-js/features/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/features/array-buffer/constructor":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string"],"core-js/features/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/features/array-buffer/slice":["es.array-buffer.slice"],"core-js/features/array/at":["es.array.at","esnext.array.at"],"core-js/features/array/concat":["es.array.concat"],"core-js/features/array/copy-within":["es.array.copy-within"],"core-js/features/array/entries":["es.array.iterator","es.object.to-string"],"core-js/features/array/every":["es.array.every"],"core-js/features/array/fill":["es.array.fill"],"core-js/features/array/filter":["es.array.filter"],"core-js/features/array/filter-out":["esnext.array.filter-out"],"core-js/features/array/filter-reject":["esnext.array.filter-reject"],"core-js/features/array/find":["es.array.find"],"core-js/features/array/find-index":["es.array.find-index"],"core-js/features/array/find-last":["esnext.array.find-last"],"core-js/features/array/find-last-index":["esnext.array.find-last-index"],"core-js/features/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/features/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/features/array/for-each":["es.array.for-each"],"core-js/features/array/from":["es.array.from","es.string.iterator"],"core-js/features/array/from-async":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.array.from-async"],"core-js/features/array/group-by":["esnext.array.group-by"],"core-js/features/array/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/features/array/includes":["es.array.includes"],"core-js/features/array/index-of":["es.array.index-of"],"core-js/features/array/is-array":["es.array.is-array"],"core-js/features/array/is-template-object":["esnext.array.is-template-object"],"core-js/features/array/iterator":["es.array.iterator","es.object.to-string"],"core-js/features/array/join":["es.array.join"],"core-js/features/array/keys":["es.array.iterator","es.object.to-string"],"core-js/features/array/last-index":["esnext.array.last-index"],"core-js/features/array/last-index-of":["es.array.last-index-of"],"core-js/features/array/last-item":["esnext.array.last-item"],"core-js/features/array/map":["es.array.map"],"core-js/features/array/of":["es.array.of"],"core-js/features/array/reduce":["es.array.reduce"],"core-js/features/array/reduce-right":["es.array.reduce-right"],"core-js/features/array/reverse":["es.array.reverse"],"core-js/features/array/slice":["es.array.slice"],"core-js/features/array/some":["es.array.some"],"core-js/features/array/sort":["es.array.sort"],"core-js/features/array/splice":["es.array.splice"],"core-js/features/array/to-reversed":["esnext.array.to-reversed"],"core-js/features/array/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/features/array/to-spliced":["esnext.array.to-spliced"],"core-js/features/array/unique-by":["es.map","esnext.array.unique-by"],"core-js/features/array/values":["es.array.iterator","es.object.to-string"],"core-js/features/array/virtual":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.map","es.object.to-string","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with"],"core-js/features/array/virtual/at":["es.array.at","esnext.array.at"],"core-js/features/array/virtual/concat":["es.array.concat"],"core-js/features/array/virtual/copy-within":["es.array.copy-within"],"core-js/features/array/virtual/entries":["es.array.iterator","es.object.to-string"],"core-js/features/array/virtual/every":["es.array.every"],"core-js/features/array/virtual/fill":["es.array.fill"],"core-js/features/array/virtual/filter":["es.array.filter"],"core-js/features/array/virtual/filter-out":["esnext.array.filter-out"],"core-js/features/array/virtual/filter-reject":["esnext.array.filter-reject"],"core-js/features/array/virtual/find":["es.array.find"],"core-js/features/array/virtual/find-index":["es.array.find-index"],"core-js/features/array/virtual/find-last":["esnext.array.find-last"],"core-js/features/array/virtual/find-last-index":["esnext.array.find-last-index"],"core-js/features/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/features/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/features/array/virtual/for-each":["es.array.for-each"],"core-js/features/array/virtual/group-by":["esnext.array.group-by"],"core-js/features/array/virtual/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/features/array/virtual/includes":["es.array.includes"],"core-js/features/array/virtual/index-of":["es.array.index-of"],"core-js/features/array/virtual/iterator":["es.array.iterator","es.object.to-string"],"core-js/features/array/virtual/join":["es.array.join"],"core-js/features/array/virtual/keys":["es.array.iterator","es.object.to-string"],"core-js/features/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/features/array/virtual/map":["es.array.map"],"core-js/features/array/virtual/reduce":["es.array.reduce"],"core-js/features/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/features/array/virtual/reverse":["es.array.reverse"],"core-js/features/array/virtual/slice":["es.array.slice"],"core-js/features/array/virtual/some":["es.array.some"],"core-js/features/array/virtual/sort":["es.array.sort"],"core-js/features/array/virtual/splice":["es.array.splice"],"core-js/features/array/virtual/to-reversed":["esnext.array.to-reversed"],"core-js/features/array/virtual/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/features/array/virtual/to-spliced":["esnext.array.to-spliced"],"core-js/features/array/virtual/unique-by":["es.map","esnext.array.unique-by"],"core-js/features/array/virtual/values":["es.array.iterator","es.object.to-string"],"core-js/features/array/virtual/with":["esnext.array.with"],"core-js/features/array/with":["esnext.array.with"],"core-js/features/async-iterator":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","web.dom-collections.iterator"],"core-js/features/async-iterator/as-indexed-pairs":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs"],"core-js/features/async-iterator/drop":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.drop"],"core-js/features/async-iterator/every":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.every"],"core-js/features/async-iterator/filter":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.filter"],"core-js/features/async-iterator/find":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.find"],"core-js/features/async-iterator/flat-map":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.flat-map"],"core-js/features/async-iterator/for-each":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.for-each"],"core-js/features/async-iterator/from":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.from","web.dom-collections.iterator"],"core-js/features/async-iterator/map":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.map"],"core-js/features/async-iterator/reduce":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.reduce"],"core-js/features/async-iterator/some":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.some"],"core-js/features/async-iterator/take":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.take"],"core-js/features/async-iterator/to-array":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.to-array"],"core-js/features/atob":["es.error.to-string","es.object.to-string","web.atob","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/features/bigint":["es.object.to-string","esnext.bigint.range"],"core-js/features/bigint/range":["es.object.to-string","esnext.bigint.range"],"core-js/features/btoa":["es.error.to-string","es.object.to-string","web.btoa","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/features/clear-immediate":["web.immediate"],"core-js/features/composite-key":["esnext.composite-key"],"core-js/features/composite-symbol":["es.symbol","esnext.composite-symbol"],"core-js/features/data-view":["es.array-buffer.constructor","es.array-buffer.slice","es.data-view","es.object.to-string"],"core-js/features/date":["es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/features/date/get-year":["es.date.get-year"],"core-js/features/date/now":["es.date.now"],"core-js/features/date/set-year":["es.date.set-year"],"core-js/features/date/to-gmt-string":["es.date.to-gmt-string"],"core-js/features/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/features/date/to-json":["es.date.to-json"],"core-js/features/date/to-primitive":["es.date.to-primitive"],"core-js/features/date/to-string":["es.date.to-string"],"core-js/features/dom-collections":["es.array.iterator","es.object.to-string","web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/features/dom-collections/for-each":["web.dom-collections.for-each"],"core-js/features/dom-collections/iterator":["es.object.to-string","web.dom-collections.iterator"],"core-js/features/dom-exception":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/features/dom-exception/constructor":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack"],"core-js/features/dom-exception/to-string-tag":["web.dom-exception.to-string-tag"],"core-js/features/error":["es.error.cause","es.error.to-string"],"core-js/features/error/constructor":["es.error.cause"],"core-js/features/error/to-string":["es.error.to-string"],"core-js/features/escape":["es.escape"],"core-js/features/function":["es.function.bind","es.function.has-instance","es.function.name","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this"],"core-js/features/function/bind":["es.function.bind"],"core-js/features/function/has-instance":["es.function.has-instance"],"core-js/features/function/is-callable":["esnext.function.is-callable"],"core-js/features/function/is-constructor":["esnext.function.is-constructor"],"core-js/features/function/name":["es.function.name"],"core-js/features/function/un-this":["esnext.function.un-this"],"core-js/features/function/virtual":["es.function.bind","esnext.function.un-this"],"core-js/features/function/virtual/bind":["es.function.bind"],"core-js/features/function/virtual/un-this":["esnext.function.un-this"],"core-js/features/get-iterator":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/features/get-iterator-method":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/features/global-this":["es.global-this","esnext.global-this"],"core-js/features/instance/at":["es.array.at","es.string.at-alternative","esnext.array.at","esnext.string.at"],"core-js/features/instance/bind":["es.function.bind"],"core-js/features/instance/code-point-at":["es.string.code-point-at"],"core-js/features/instance/code-points":["es.object.to-string","esnext.string.code-points"],"core-js/features/instance/concat":["es.array.concat"],"core-js/features/instance/copy-within":["es.array.copy-within"],"core-js/features/instance/ends-with":["es.string.ends-with"],"core-js/features/instance/entries":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/features/instance/every":["es.array.every"],"core-js/features/instance/fill":["es.array.fill"],"core-js/features/instance/filter":["es.array.filter"],"core-js/features/instance/filter-out":["esnext.array.filter-out"],"core-js/features/instance/filter-reject":["esnext.array.filter-reject"],"core-js/features/instance/find":["es.array.find"],"core-js/features/instance/find-index":["es.array.find-index"],"core-js/features/instance/find-last":["esnext.array.find-last"],"core-js/features/instance/find-last-index":["esnext.array.find-last-index"],"core-js/features/instance/flags":["es.regexp.flags"],"core-js/features/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/features/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/features/instance/for-each":["es.array.for-each","web.dom-collections.iterator"],"core-js/features/instance/group-by":["esnext.array.group-by"],"core-js/features/instance/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/features/instance/includes":["es.array.includes","es.string.includes"],"core-js/features/instance/index-of":["es.array.index-of"],"core-js/features/instance/keys":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/features/instance/last-index-of":["es.array.last-index-of"],"core-js/features/instance/map":["es.array.map"],"core-js/features/instance/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all","esnext.string.match-all"],"core-js/features/instance/pad-end":["es.string.pad-end"],"core-js/features/instance/pad-start":["es.string.pad-start"],"core-js/features/instance/reduce":["es.array.reduce"],"core-js/features/instance/reduce-right":["es.array.reduce-right"],"core-js/features/instance/repeat":["es.string.repeat"],"core-js/features/instance/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/features/instance/reverse":["es.array.reverse"],"core-js/features/instance/slice":["es.array.slice"],"core-js/features/instance/some":["es.array.some"],"core-js/features/instance/sort":["es.array.sort"],"core-js/features/instance/splice":["es.array.splice"],"core-js/features/instance/starts-with":["es.string.starts-with"],"core-js/features/instance/to-reversed":["esnext.array.to-reversed"],"core-js/features/instance/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/features/instance/to-spliced":["esnext.array.to-spliced"],"core-js/features/instance/trim":["es.string.trim"],"core-js/features/instance/trim-end":["es.string.trim-end"],"core-js/features/instance/trim-left":["es.string.trim-start"],"core-js/features/instance/trim-right":["es.string.trim-end"],"core-js/features/instance/trim-start":["es.string.trim-start"],"core-js/features/instance/un-this":["esnext.function.un-this"],"core-js/features/instance/unique-by":["es.map","esnext.array.unique-by"],"core-js/features/instance/values":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/features/instance/with":["esnext.array.with"],"core-js/features/is-iterable":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/features/iterator":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","web.dom-collections.iterator"],"core-js/features/iterator/as-indexed-pairs":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs"],"core-js/features/iterator/drop":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.drop"],"core-js/features/iterator/every":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.every"],"core-js/features/iterator/filter":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.filter"],"core-js/features/iterator/find":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.find"],"core-js/features/iterator/flat-map":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.flat-map"],"core-js/features/iterator/for-each":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.for-each"],"core-js/features/iterator/from":["es.array.iterator","es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.from","web.dom-collections.iterator"],"core-js/features/iterator/map":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.map"],"core-js/features/iterator/reduce":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.reduce"],"core-js/features/iterator/some":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.some"],"core-js/features/iterator/take":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.take"],"core-js/features/iterator/to-array":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.to-array"],"core-js/features/iterator/to-async":["es.object.to-string","es.promise","esnext.iterator.constructor","esnext.iterator.to-async"],"core-js/features/json":["es.json.stringify","es.json.to-string-tag"],"core-js/features/json/stringify":["es.json.stringify"],"core-js/features/json/to-string-tag":["es.json.to-string-tag"],"core-js/features/map":["es.array.iterator","es.map","es.object.to-string","es.string.iterator","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","web.dom-collections.iterator"],"core-js/features/map/delete-all":["es.map","esnext.map.delete-all"],"core-js/features/map/emplace":["es.map","esnext.map.emplace"],"core-js/features/map/every":["es.map","esnext.map.every"],"core-js/features/map/filter":["es.map","esnext.map.filter"],"core-js/features/map/find":["es.map","esnext.map.find"],"core-js/features/map/find-key":["es.map","esnext.map.find-key"],"core-js/features/map/from":["es.array.iterator","es.map","es.string.iterator","esnext.map.from","web.dom-collections.iterator"],"core-js/features/map/group-by":["es.map","esnext.map.group-by"],"core-js/features/map/includes":["es.map","esnext.map.includes"],"core-js/features/map/key-by":["es.map","esnext.map.key-by"],"core-js/features/map/key-of":["es.map","esnext.map.key-of"],"core-js/features/map/map-keys":["es.map","esnext.map.map-keys"],"core-js/features/map/map-values":["es.map","esnext.map.map-values"],"core-js/features/map/merge":["es.map","esnext.map.merge"],"core-js/features/map/of":["es.array.iterator","es.map","esnext.map.of"],"core-js/features/map/reduce":["es.map","esnext.map.reduce"],"core-js/features/map/some":["es.map","esnext.map.some"],"core-js/features/map/update":["es.map","esnext.map.update"],"core-js/features/map/update-or-insert":["es.map","esnext.map.update-or-insert"],"core-js/features/map/upsert":["es.map","esnext.map.upsert"],"core-js/features/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh"],"core-js/features/math/acosh":["es.math.acosh"],"core-js/features/math/asinh":["es.math.asinh"],"core-js/features/math/atanh":["es.math.atanh"],"core-js/features/math/cbrt":["es.math.cbrt"],"core-js/features/math/clamp":["esnext.math.clamp"],"core-js/features/math/clz32":["es.math.clz32"],"core-js/features/math/cosh":["es.math.cosh"],"core-js/features/math/deg-per-rad":["esnext.math.deg-per-rad"],"core-js/features/math/degrees":["esnext.math.degrees"],"core-js/features/math/expm1":["es.math.expm1"],"core-js/features/math/fround":["es.math.fround"],"core-js/features/math/fscale":["esnext.math.fscale"],"core-js/features/math/hypot":["es.math.hypot"],"core-js/features/math/iaddh":["esnext.math.iaddh"],"core-js/features/math/imul":["es.math.imul"],"core-js/features/math/imulh":["esnext.math.imulh"],"core-js/features/math/isubh":["esnext.math.isubh"],"core-js/features/math/log10":["es.math.log10"],"core-js/features/math/log1p":["es.math.log1p"],"core-js/features/math/log2":["es.math.log2"],"core-js/features/math/rad-per-deg":["esnext.math.rad-per-deg"],"core-js/features/math/radians":["esnext.math.radians"],"core-js/features/math/scale":["esnext.math.scale"],"core-js/features/math/seeded-prng":["esnext.math.seeded-prng"],"core-js/features/math/sign":["es.math.sign"],"core-js/features/math/signbit":["esnext.math.signbit"],"core-js/features/math/sinh":["es.math.sinh"],"core-js/features/math/tanh":["es.math.tanh"],"core-js/features/math/to-string-tag":["es.math.to-string-tag"],"core-js/features/math/trunc":["es.math.trunc"],"core-js/features/math/umulh":["esnext.math.umulh"],"core-js/features/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.to-string","esnext.number.from-string","esnext.number.range"],"core-js/features/number/constructor":["es.number.constructor"],"core-js/features/number/epsilon":["es.number.epsilon"],"core-js/features/number/from-string":["esnext.number.from-string"],"core-js/features/number/is-finite":["es.number.is-finite"],"core-js/features/number/is-integer":["es.number.is-integer"],"core-js/features/number/is-nan":["es.number.is-nan"],"core-js/features/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/features/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/features/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/features/number/parse-float":["es.number.parse-float"],"core-js/features/number/parse-int":["es.number.parse-int"],"core-js/features/number/range":["es.object.to-string","esnext.number.range"],"core-js/features/number/to-exponential":["es.number.to-exponential"],"core-js/features/number/to-fixed":["es.number.to-fixed"],"core-js/features/number/to-precision":["es.number.to-precision"],"core-js/features/number/virtual":["es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/features/number/virtual/to-exponential":["es.number.to-exponential"],"core-js/features/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/features/number/virtual/to-precision":["es.number.to-precision"],"core-js/features/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.reflect.to-string-tag","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","web.dom-collections.iterator"],"core-js/features/object/assign":["es.object.assign"],"core-js/features/object/create":["es.object.create"],"core-js/features/object/define-getter":["es.object.define-getter"],"core-js/features/object/define-properties":["es.object.define-properties"],"core-js/features/object/define-property":["es.object.define-property"],"core-js/features/object/define-setter":["es.object.define-setter"],"core-js/features/object/entries":["es.object.entries"],"core-js/features/object/freeze":["es.object.freeze"],"core-js/features/object/from-entries":["es.array.iterator","es.object.from-entries","web.dom-collections.iterator"],"core-js/features/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/features/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/features/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/features/object/get-own-property-symbols":["es.symbol"],"core-js/features/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/features/object/has-own":["es.object.has-own","esnext.object.has-own"],"core-js/features/object/is":["es.object.is"],"core-js/features/object/is-extensible":["es.object.is-extensible"],"core-js/features/object/is-frozen":["es.object.is-frozen"],"core-js/features/object/is-sealed":["es.object.is-sealed"],"core-js/features/object/iterate-entries":["esnext.object.iterate-entries"],"core-js/features/object/iterate-keys":["esnext.object.iterate-keys"],"core-js/features/object/iterate-values":["esnext.object.iterate-values"],"core-js/features/object/keys":["es.object.keys"],"core-js/features/object/lookup-getter":["es.object.lookup-getter"],"core-js/features/object/lookup-setter":["es.object.lookup-setter"],"core-js/features/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/features/object/seal":["es.object.seal"],"core-js/features/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/features/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/features/object/values":["es.object.values"],"core-js/features/observable":["es.object.to-string","es.string.iterator","esnext.observable","esnext.symbol.observable","web.dom-collections.iterator"],"core-js/features/parse-float":["es.parse-float"],"core-js/features/parse-int":["es.parse-int"],"core-js/features/promise":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.string.iterator","esnext.aggregate-error","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","web.dom-collections.iterator"],"core-js/features/promise/all-settled":["es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.string.iterator","esnext.promise.all-settled","web.dom-collections.iterator"],"core-js/features/promise/any":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.any","es.string.iterator","esnext.aggregate-error","esnext.promise.any","web.dom-collections.iterator"],"core-js/features/promise/finally":["es.object.to-string","es.promise","es.promise.finally"],"core-js/features/promise/try":["es.promise","esnext.promise.try"],"core-js/features/queue-microtask":["web.queue-microtask"],"core-js/features/reflect":["es.object.to-string","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata"],"core-js/features/reflect/apply":["es.reflect.apply"],"core-js/features/reflect/construct":["es.reflect.construct"],"core-js/features/reflect/define-metadata":["esnext.reflect.define-metadata"],"core-js/features/reflect/define-property":["es.reflect.define-property"],"core-js/features/reflect/delete-metadata":["esnext.reflect.delete-metadata"],"core-js/features/reflect/delete-property":["es.reflect.delete-property"],"core-js/features/reflect/get":["es.reflect.get"],"core-js/features/reflect/get-metadata":["esnext.reflect.get-metadata"],"core-js/features/reflect/get-metadata-keys":["esnext.reflect.get-metadata-keys"],"core-js/features/reflect/get-own-metadata":["esnext.reflect.get-own-metadata"],"core-js/features/reflect/get-own-metadata-keys":["esnext.reflect.get-own-metadata-keys"],"core-js/features/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/features/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/features/reflect/has":["es.reflect.has"],"core-js/features/reflect/has-metadata":["esnext.reflect.has-metadata"],"core-js/features/reflect/has-own-metadata":["esnext.reflect.has-own-metadata"],"core-js/features/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/features/reflect/metadata":["esnext.reflect.metadata"],"core-js/features/reflect/own-keys":["es.reflect.own-keys"],"core-js/features/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/features/reflect/set":["es.reflect.set"],"core-js/features/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/features/reflect/to-string-tag":["es.reflect.to-string-tag"],"core-js/features/regexp":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/features/regexp/constructor":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.sticky"],"core-js/features/regexp/dot-all":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec"],"core-js/features/regexp/flags":["es.regexp.flags"],"core-js/features/regexp/match":["es.regexp.exec","es.string.match"],"core-js/features/regexp/replace":["es.regexp.exec","es.string.replace"],"core-js/features/regexp/search":["es.regexp.exec","es.string.search"],"core-js/features/regexp/split":["es.regexp.exec","es.string.split"],"core-js/features/regexp/sticky":["es.regexp.constructor","es.regexp.exec","es.regexp.sticky"],"core-js/features/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/features/regexp/to-string":["es.regexp.to-string"],"core-js/features/set":["es.array.iterator","es.object.to-string","es.set","es.string.iterator","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","web.dom-collections.iterator"],"core-js/features/set-immediate":["web.immediate"],"core-js/features/set-interval":["web.timers"],"core-js/features/set-timeout":["web.timers"],"core-js/features/set/add-all":["es.set","esnext.set.add-all"],"core-js/features/set/delete-all":["es.set","esnext.set.delete-all"],"core-js/features/set/difference":["es.array.iterator","es.set","es.string.iterator","esnext.set.difference","web.dom-collections.iterator"],"core-js/features/set/every":["es.set","esnext.set.every"],"core-js/features/set/filter":["es.set","esnext.set.filter"],"core-js/features/set/find":["es.set","esnext.set.find"],"core-js/features/set/from":["es.array.iterator","es.set","es.string.iterator","esnext.set.from","web.dom-collections.iterator"],"core-js/features/set/intersection":["es.array.iterator","es.set","es.string.iterator","esnext.set.intersection","web.dom-collections.iterator"],"core-js/features/set/is-disjoint-from":["es.array.iterator","es.set","es.string.iterator","esnext.set.is-disjoint-from","web.dom-collections.iterator"],"core-js/features/set/is-subset-of":["es.array.iterator","es.set","es.string.iterator","esnext.set.is-subset-of","web.dom-collections.iterator"],"core-js/features/set/is-superset-of":["es.array.iterator","es.set","es.string.iterator","esnext.set.is-superset-of","web.dom-collections.iterator"],"core-js/features/set/join":["es.set","esnext.set.join"],"core-js/features/set/map":["es.set","esnext.set.map"],"core-js/features/set/of":["es.array.iterator","es.set","esnext.set.of"],"core-js/features/set/reduce":["es.set","esnext.set.reduce"],"core-js/features/set/some":["es.set","esnext.set.some"],"core-js/features/set/symmetric-difference":["es.array.iterator","es.set","es.string.iterator","esnext.set.symmetric-difference","web.dom-collections.iterator"],"core-js/features/set/union":["es.array.iterator","es.set","es.string.iterator","esnext.set.union","web.dom-collections.iterator"],"core-js/features/string":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all"],"core-js/features/string/anchor":["es.string.anchor"],"core-js/features/string/at":["es.string.at-alternative","esnext.string.at"],"core-js/features/string/big":["es.string.big"],"core-js/features/string/blink":["es.string.blink"],"core-js/features/string/bold":["es.string.bold"],"core-js/features/string/code-point-at":["es.string.code-point-at"],"core-js/features/string/code-points":["es.object.to-string","esnext.string.code-points"],"core-js/features/string/cooked":["esnext.string.cooked"],"core-js/features/string/ends-with":["es.string.ends-with"],"core-js/features/string/fixed":["es.string.fixed"],"core-js/features/string/fontcolor":["es.string.fontcolor"],"core-js/features/string/fontsize":["es.string.fontsize"],"core-js/features/string/from-code-point":["es.string.from-code-point"],"core-js/features/string/includes":["es.string.includes"],"core-js/features/string/italics":["es.string.italics"],"core-js/features/string/iterator":["es.object.to-string","es.string.iterator"],"core-js/features/string/link":["es.string.link"],"core-js/features/string/match":["es.regexp.exec","es.string.match"],"core-js/features/string/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all","esnext.string.match-all"],"core-js/features/string/pad-end":["es.string.pad-end"],"core-js/features/string/pad-start":["es.string.pad-start"],"core-js/features/string/raw":["es.string.raw"],"core-js/features/string/repeat":["es.string.repeat"],"core-js/features/string/replace":["es.regexp.exec","es.string.replace"],"core-js/features/string/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all","esnext.string.replace-all"],"core-js/features/string/search":["es.regexp.exec","es.string.search"],"core-js/features/string/small":["es.string.small"],"core-js/features/string/split":["es.regexp.exec","es.string.split"],"core-js/features/string/starts-with":["es.string.starts-with"],"core-js/features/string/strike":["es.string.strike"],"core-js/features/string/sub":["es.string.sub"],"core-js/features/string/substr":["es.string.substr"],"core-js/features/string/sup":["es.string.sup"],"core-js/features/string/trim":["es.string.trim"],"core-js/features/string/trim-end":["es.string.trim-end"],"core-js/features/string/trim-left":["es.string.trim-start"],"core-js/features/string/trim-right":["es.string.trim-end"],"core-js/features/string/trim-start":["es.string.trim-start"],"core-js/features/string/virtual":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all"],"core-js/features/string/virtual/anchor":["es.string.anchor"],"core-js/features/string/virtual/at":["es.string.at-alternative","esnext.string.at"],"core-js/features/string/virtual/big":["es.string.big"],"core-js/features/string/virtual/blink":["es.string.blink"],"core-js/features/string/virtual/bold":["es.string.bold"],"core-js/features/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/features/string/virtual/code-points":["es.object.to-string","esnext.string.code-points"],"core-js/features/string/virtual/ends-with":["es.string.ends-with"],"core-js/features/string/virtual/fixed":["es.string.fixed"],"core-js/features/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/features/string/virtual/fontsize":["es.string.fontsize"],"core-js/features/string/virtual/includes":["es.string.includes"],"core-js/features/string/virtual/italics":["es.string.italics"],"core-js/features/string/virtual/iterator":["es.object.to-string","es.string.iterator"],"core-js/features/string/virtual/link":["es.string.link"],"core-js/features/string/virtual/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all","esnext.string.match-all"],"core-js/features/string/virtual/pad-end":["es.string.pad-end"],"core-js/features/string/virtual/pad-start":["es.string.pad-start"],"core-js/features/string/virtual/repeat":["es.string.repeat"],"core-js/features/string/virtual/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all","esnext.string.replace-all"],"core-js/features/string/virtual/small":["es.string.small"],"core-js/features/string/virtual/starts-with":["es.string.starts-with"],"core-js/features/string/virtual/strike":["es.string.strike"],"core-js/features/string/virtual/sub":["es.string.sub"],"core-js/features/string/virtual/substr":["es.string.substr"],"core-js/features/string/virtual/sup":["es.string.sup"],"core-js/features/string/virtual/trim":["es.string.trim"],"core-js/features/string/virtual/trim-end":["es.string.trim-end"],"core-js/features/string/virtual/trim-left":["es.string.trim-start"],"core-js/features/string/virtual/trim-right":["es.string.trim-end"],"core-js/features/string/virtual/trim-start":["es.string.trim-start"],"core-js/features/structured-clone":["es.error.to-string","es.array.iterator","es.map","es.object.keys","es.object.to-string","es.set","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.structured-clone"],"core-js/features/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","web.dom-collections.iterator"],"core-js/features/symbol/async-dispose":["esnext.symbol.async-dispose"],"core-js/features/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/features/symbol/description":["es.symbol.description"],"core-js/features/symbol/dispose":["esnext.symbol.dispose"],"core-js/features/symbol/for":["es.symbol"],"core-js/features/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/features/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/features/symbol/iterator":["es.symbol.iterator","es.array.iterator","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/features/symbol/key-for":["es.symbol"],"core-js/features/symbol/match":["es.symbol.match","es.regexp.exec","es.string.match"],"core-js/features/symbol/match-all":["es.symbol.match-all","es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/features/symbol/matcher":["esnext.symbol.matcher"],"core-js/features/symbol/metadata":["esnext.symbol.metadata"],"core-js/features/symbol/observable":["esnext.symbol.observable"],"core-js/features/symbol/pattern-match":["esnext.symbol.pattern-match"],"core-js/features/symbol/replace":["es.symbol.replace","es.regexp.exec","es.string.replace"],"core-js/features/symbol/replace-all":["esnext.symbol.replace-all"],"core-js/features/symbol/search":["es.symbol.search","es.regexp.exec","es.string.search"],"core-js/features/symbol/species":["es.symbol.species"],"core-js/features/symbol/split":["es.symbol.split","es.regexp.exec","es.string.split"],"core-js/features/symbol/to-primitive":["es.symbol.to-primitive","es.date.to-primitive"],"core-js/features/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/features/symbol/unscopables":["es.symbol.unscopables"],"core-js/features/typed-array":["es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/at":["es.typed-array.at","esnext.typed-array.at"],"core-js/features/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/features/typed-array/entries":["es.object.to-string","es.typed-array.iterator"],"core-js/features/typed-array/every":["es.typed-array.every"],"core-js/features/typed-array/fill":["es.typed-array.fill"],"core-js/features/typed-array/filter":["es.typed-array.filter"],"core-js/features/typed-array/filter-out":["esnext.typed-array.filter-out"],"core-js/features/typed-array/filter-reject":["esnext.typed-array.filter-reject"],"core-js/features/typed-array/find":["es.typed-array.find"],"core-js/features/typed-array/find-index":["es.typed-array.find-index"],"core-js/features/typed-array/find-last":["esnext.typed-array.find-last"],"core-js/features/typed-array/find-last-index":["esnext.typed-array.find-last-index"],"core-js/features/typed-array/float32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.float32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/float64-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.float64-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/for-each":["es.typed-array.for-each"],"core-js/features/typed-array/from":["es.typed-array.from"],"core-js/features/typed-array/from-async":["esnext.typed-array.from-async"],"core-js/features/typed-array/group-by":["esnext.typed-array.group-by"],"core-js/features/typed-array/includes":["es.typed-array.includes"],"core-js/features/typed-array/index-of":["es.typed-array.index-of"],"core-js/features/typed-array/int16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.int16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/int32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.int32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/int8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.int8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/iterator":["es.object.to-string","es.typed-array.iterator"],"core-js/features/typed-array/join":["es.typed-array.join"],"core-js/features/typed-array/keys":["es.object.to-string","es.typed-array.iterator"],"core-js/features/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/features/typed-array/map":["es.typed-array.map"],"core-js/features/typed-array/methods":["es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/of":["es.typed-array.of"],"core-js/features/typed-array/reduce":["es.typed-array.reduce"],"core-js/features/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/features/typed-array/reverse":["es.typed-array.reverse"],"core-js/features/typed-array/set":["es.typed-array.set"],"core-js/features/typed-array/slice":["es.typed-array.slice"],"core-js/features/typed-array/some":["es.typed-array.some"],"core-js/features/typed-array/sort":["es.typed-array.sort"],"core-js/features/typed-array/subarray":["es.typed-array.subarray"],"core-js/features/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/features/typed-array/to-reversed":["esnext.typed-array.to-reversed"],"core-js/features/typed-array/to-sorted":["es.typed-array.sort","esnext.typed-array.to-sorted"],"core-js/features/typed-array/to-spliced":["esnext.typed-array.to-spliced"],"core-js/features/typed-array/to-string":["es.typed-array.to-string"],"core-js/features/typed-array/uint16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/uint32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/uint8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/uint8-clamped-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint8-clamped-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/features/typed-array/unique-by":["es.map","esnext.typed-array.unique-by"],"core-js/features/typed-array/values":["es.object.to-string","es.typed-array.iterator"],"core-js/features/typed-array/with":["esnext.typed-array.with"],"core-js/features/unescape":["es.unescape"],"core-js/features/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/features/url-search-params":["web.dom-collections.iterator","web.url-search-params"],"core-js/features/url/to-json":["web.url.to-json"],"core-js/features/weak-map":["es.array.iterator","es.object.to-string","es.string.iterator","es.weak-map","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","web.dom-collections.iterator"],"core-js/features/weak-map/delete-all":["es.weak-map","esnext.weak-map.delete-all"],"core-js/features/weak-map/emplace":["es.weak-map","esnext.weak-map.emplace"],"core-js/features/weak-map/from":["es.array.iterator","es.string.iterator","es.weak-map","esnext.weak-map.from","web.dom-collections.iterator"],"core-js/features/weak-map/of":["es.array.iterator","es.weak-map","esnext.weak-map.of"],"core-js/features/weak-map/upsert":["es.weak-map","esnext.weak-map.upsert"],"core-js/features/weak-set":["es.array.iterator","es.object.to-string","es.string.iterator","es.weak-set","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.iterator"],"core-js/features/weak-set/add-all":["es.weak-set","esnext.weak-set.add-all"],"core-js/features/weak-set/delete-all":["es.weak-set","esnext.weak-set.delete-all"],"core-js/features/weak-set/from":["es.array.iterator","es.string.iterator","es.weak-set","esnext.weak-set.from","web.dom-collections.iterator"],"core-js/features/weak-set/of":["es.array.iterator","es.weak-set","esnext.weak-set.of"],"core-js/full":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/full/aggregate-error":["es.error.cause","es.aggregate-error","es.aggregate-error.cause","es.array.iterator","es.string.iterator","esnext.aggregate-error","web.dom-collections.iterator"],"core-js/full/array":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.map","es.object.to-string","es.promise","es.string.iterator","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with"],"core-js/full/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/full/array-buffer/constructor":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string"],"core-js/full/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/full/array-buffer/slice":["es.array-buffer.slice"],"core-js/full/array/at":["es.array.at","esnext.array.at"],"core-js/full/array/concat":["es.array.concat"],"core-js/full/array/copy-within":["es.array.copy-within"],"core-js/full/array/entries":["es.array.iterator","es.object.to-string"],"core-js/full/array/every":["es.array.every"],"core-js/full/array/fill":["es.array.fill"],"core-js/full/array/filter":["es.array.filter"],"core-js/full/array/filter-out":["esnext.array.filter-out"],"core-js/full/array/filter-reject":["esnext.array.filter-reject"],"core-js/full/array/find":["es.array.find"],"core-js/full/array/find-index":["es.array.find-index"],"core-js/full/array/find-last":["esnext.array.find-last"],"core-js/full/array/find-last-index":["esnext.array.find-last-index"],"core-js/full/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/full/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/full/array/for-each":["es.array.for-each"],"core-js/full/array/from":["es.array.from","es.string.iterator"],"core-js/full/array/from-async":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.array.from-async"],"core-js/full/array/group-by":["esnext.array.group-by"],"core-js/full/array/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/full/array/includes":["es.array.includes"],"core-js/full/array/index-of":["es.array.index-of"],"core-js/full/array/is-array":["es.array.is-array"],"core-js/full/array/is-template-object":["esnext.array.is-template-object"],"core-js/full/array/iterator":["es.array.iterator","es.object.to-string"],"core-js/full/array/join":["es.array.join"],"core-js/full/array/keys":["es.array.iterator","es.object.to-string"],"core-js/full/array/last-index":["esnext.array.last-index"],"core-js/full/array/last-index-of":["es.array.last-index-of"],"core-js/full/array/last-item":["esnext.array.last-item"],"core-js/full/array/map":["es.array.map"],"core-js/full/array/of":["es.array.of"],"core-js/full/array/reduce":["es.array.reduce"],"core-js/full/array/reduce-right":["es.array.reduce-right"],"core-js/full/array/reverse":["es.array.reverse"],"core-js/full/array/slice":["es.array.slice"],"core-js/full/array/some":["es.array.some"],"core-js/full/array/sort":["es.array.sort"],"core-js/full/array/splice":["es.array.splice"],"core-js/full/array/to-reversed":["esnext.array.to-reversed"],"core-js/full/array/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/full/array/to-spliced":["esnext.array.to-spliced"],"core-js/full/array/unique-by":["es.map","esnext.array.unique-by"],"core-js/full/array/values":["es.array.iterator","es.object.to-string"],"core-js/full/array/virtual":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.map","es.object.to-string","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with"],"core-js/full/array/virtual/at":["es.array.at","esnext.array.at"],"core-js/full/array/virtual/concat":["es.array.concat"],"core-js/full/array/virtual/copy-within":["es.array.copy-within"],"core-js/full/array/virtual/entries":["es.array.iterator","es.object.to-string"],"core-js/full/array/virtual/every":["es.array.every"],"core-js/full/array/virtual/fill":["es.array.fill"],"core-js/full/array/virtual/filter":["es.array.filter"],"core-js/full/array/virtual/filter-out":["esnext.array.filter-out"],"core-js/full/array/virtual/filter-reject":["esnext.array.filter-reject"],"core-js/full/array/virtual/find":["es.array.find"],"core-js/full/array/virtual/find-index":["es.array.find-index"],"core-js/full/array/virtual/find-last":["esnext.array.find-last"],"core-js/full/array/virtual/find-last-index":["esnext.array.find-last-index"],"core-js/full/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/full/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/full/array/virtual/for-each":["es.array.for-each"],"core-js/full/array/virtual/group-by":["esnext.array.group-by"],"core-js/full/array/virtual/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/full/array/virtual/includes":["es.array.includes"],"core-js/full/array/virtual/index-of":["es.array.index-of"],"core-js/full/array/virtual/iterator":["es.array.iterator","es.object.to-string"],"core-js/full/array/virtual/join":["es.array.join"],"core-js/full/array/virtual/keys":["es.array.iterator","es.object.to-string"],"core-js/full/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/full/array/virtual/map":["es.array.map"],"core-js/full/array/virtual/reduce":["es.array.reduce"],"core-js/full/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/full/array/virtual/reverse":["es.array.reverse"],"core-js/full/array/virtual/slice":["es.array.slice"],"core-js/full/array/virtual/some":["es.array.some"],"core-js/full/array/virtual/sort":["es.array.sort"],"core-js/full/array/virtual/splice":["es.array.splice"],"core-js/full/array/virtual/to-reversed":["esnext.array.to-reversed"],"core-js/full/array/virtual/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/full/array/virtual/to-spliced":["esnext.array.to-spliced"],"core-js/full/array/virtual/unique-by":["es.map","esnext.array.unique-by"],"core-js/full/array/virtual/values":["es.array.iterator","es.object.to-string"],"core-js/full/array/virtual/with":["esnext.array.with"],"core-js/full/array/with":["esnext.array.with"],"core-js/full/async-iterator":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","web.dom-collections.iterator"],"core-js/full/async-iterator/as-indexed-pairs":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs"],"core-js/full/async-iterator/drop":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.drop"],"core-js/full/async-iterator/every":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.every"],"core-js/full/async-iterator/filter":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.filter"],"core-js/full/async-iterator/find":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.find"],"core-js/full/async-iterator/flat-map":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.flat-map"],"core-js/full/async-iterator/for-each":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.for-each"],"core-js/full/async-iterator/from":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.from","web.dom-collections.iterator"],"core-js/full/async-iterator/map":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.map"],"core-js/full/async-iterator/reduce":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.reduce"],"core-js/full/async-iterator/some":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.some"],"core-js/full/async-iterator/take":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.take"],"core-js/full/async-iterator/to-array":["es.object.to-string","es.promise","esnext.async-iterator.constructor","esnext.async-iterator.to-array"],"core-js/full/atob":["es.error.to-string","es.object.to-string","web.atob","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/full/bigint":["es.object.to-string","esnext.bigint.range"],"core-js/full/bigint/range":["es.object.to-string","esnext.bigint.range"],"core-js/full/btoa":["es.error.to-string","es.object.to-string","web.btoa","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/full/clear-immediate":["web.immediate"],"core-js/full/composite-key":["esnext.composite-key"],"core-js/full/composite-symbol":["es.symbol","esnext.composite-symbol"],"core-js/full/data-view":["es.array-buffer.constructor","es.array-buffer.slice","es.data-view","es.object.to-string"],"core-js/full/date":["es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/full/date/get-year":["es.date.get-year"],"core-js/full/date/now":["es.date.now"],"core-js/full/date/set-year":["es.date.set-year"],"core-js/full/date/to-gmt-string":["es.date.to-gmt-string"],"core-js/full/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/full/date/to-json":["es.date.to-json"],"core-js/full/date/to-primitive":["es.date.to-primitive"],"core-js/full/date/to-string":["es.date.to-string"],"core-js/full/dom-collections":["es.array.iterator","es.object.to-string","web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/full/dom-collections/for-each":["web.dom-collections.for-each"],"core-js/full/dom-collections/iterator":["es.object.to-string","web.dom-collections.iterator"],"core-js/full/dom-exception":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/full/dom-exception/constructor":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack"],"core-js/full/dom-exception/to-string-tag":["web.dom-exception.to-string-tag"],"core-js/full/error":["es.error.cause","es.error.to-string"],"core-js/full/error/constructor":["es.error.cause"],"core-js/full/error/to-string":["es.error.to-string"],"core-js/full/escape":["es.escape"],"core-js/full/function":["es.function.bind","es.function.has-instance","es.function.name","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this"],"core-js/full/function/bind":["es.function.bind"],"core-js/full/function/has-instance":["es.function.has-instance"],"core-js/full/function/is-callable":["esnext.function.is-callable"],"core-js/full/function/is-constructor":["esnext.function.is-constructor"],"core-js/full/function/name":["es.function.name"],"core-js/full/function/un-this":["esnext.function.un-this"],"core-js/full/function/virtual":["es.function.bind","esnext.function.un-this"],"core-js/full/function/virtual/bind":["es.function.bind"],"core-js/full/function/virtual/un-this":["esnext.function.un-this"],"core-js/full/get-iterator":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/full/get-iterator-method":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/full/global-this":["es.global-this","esnext.global-this"],"core-js/full/instance/at":["es.array.at","es.string.at-alternative","esnext.array.at","esnext.string.at"],"core-js/full/instance/bind":["es.function.bind"],"core-js/full/instance/code-point-at":["es.string.code-point-at"],"core-js/full/instance/code-points":["es.object.to-string","esnext.string.code-points"],"core-js/full/instance/concat":["es.array.concat"],"core-js/full/instance/copy-within":["es.array.copy-within"],"core-js/full/instance/ends-with":["es.string.ends-with"],"core-js/full/instance/entries":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/full/instance/every":["es.array.every"],"core-js/full/instance/fill":["es.array.fill"],"core-js/full/instance/filter":["es.array.filter"],"core-js/full/instance/filter-out":["esnext.array.filter-out"],"core-js/full/instance/filter-reject":["esnext.array.filter-reject"],"core-js/full/instance/find":["es.array.find"],"core-js/full/instance/find-index":["es.array.find-index"],"core-js/full/instance/find-last":["esnext.array.find-last"],"core-js/full/instance/find-last-index":["esnext.array.find-last-index"],"core-js/full/instance/flags":["es.regexp.flags"],"core-js/full/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/full/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/full/instance/for-each":["es.array.for-each","web.dom-collections.iterator"],"core-js/full/instance/group-by":["esnext.array.group-by"],"core-js/full/instance/group-by-to-map":["es.map","es.object.to-string","esnext.array.group-by-to-map"],"core-js/full/instance/includes":["es.array.includes","es.string.includes"],"core-js/full/instance/index-of":["es.array.index-of"],"core-js/full/instance/keys":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/full/instance/last-index-of":["es.array.last-index-of"],"core-js/full/instance/map":["es.array.map"],"core-js/full/instance/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all","esnext.string.match-all"],"core-js/full/instance/pad-end":["es.string.pad-end"],"core-js/full/instance/pad-start":["es.string.pad-start"],"core-js/full/instance/reduce":["es.array.reduce"],"core-js/full/instance/reduce-right":["es.array.reduce-right"],"core-js/full/instance/repeat":["es.string.repeat"],"core-js/full/instance/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/full/instance/reverse":["es.array.reverse"],"core-js/full/instance/slice":["es.array.slice"],"core-js/full/instance/some":["es.array.some"],"core-js/full/instance/sort":["es.array.sort"],"core-js/full/instance/splice":["es.array.splice"],"core-js/full/instance/starts-with":["es.string.starts-with"],"core-js/full/instance/to-reversed":["esnext.array.to-reversed"],"core-js/full/instance/to-sorted":["es.array.sort","esnext.array.to-sorted"],"core-js/full/instance/to-spliced":["esnext.array.to-spliced"],"core-js/full/instance/trim":["es.string.trim"],"core-js/full/instance/trim-end":["es.string.trim-end"],"core-js/full/instance/trim-left":["es.string.trim-start"],"core-js/full/instance/trim-right":["es.string.trim-end"],"core-js/full/instance/trim-start":["es.string.trim-start"],"core-js/full/instance/un-this":["esnext.function.un-this"],"core-js/full/instance/unique-by":["es.map","esnext.array.unique-by"],"core-js/full/instance/values":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/full/instance/with":["esnext.array.with"],"core-js/full/is-iterable":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/full/iterator":["es.array.iterator","es.object.to-string","es.promise","es.string.iterator","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","web.dom-collections.iterator"],"core-js/full/iterator/as-indexed-pairs":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs"],"core-js/full/iterator/drop":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.drop"],"core-js/full/iterator/every":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.every"],"core-js/full/iterator/filter":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.filter"],"core-js/full/iterator/find":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.find"],"core-js/full/iterator/flat-map":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.flat-map"],"core-js/full/iterator/for-each":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.for-each"],"core-js/full/iterator/from":["es.array.iterator","es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.from","web.dom-collections.iterator"],"core-js/full/iterator/map":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.map"],"core-js/full/iterator/reduce":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.reduce"],"core-js/full/iterator/some":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.some"],"core-js/full/iterator/take":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.take"],"core-js/full/iterator/to-array":["es.object.to-string","esnext.iterator.constructor","esnext.iterator.to-array"],"core-js/full/iterator/to-async":["es.object.to-string","es.promise","esnext.iterator.constructor","esnext.iterator.to-async"],"core-js/full/json":["es.json.stringify","es.json.to-string-tag"],"core-js/full/json/stringify":["es.json.stringify"],"core-js/full/json/to-string-tag":["es.json.to-string-tag"],"core-js/full/map":["es.array.iterator","es.map","es.object.to-string","es.string.iterator","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","web.dom-collections.iterator"],"core-js/full/map/delete-all":["es.map","esnext.map.delete-all"],"core-js/full/map/emplace":["es.map","esnext.map.emplace"],"core-js/full/map/every":["es.map","esnext.map.every"],"core-js/full/map/filter":["es.map","esnext.map.filter"],"core-js/full/map/find":["es.map","esnext.map.find"],"core-js/full/map/find-key":["es.map","esnext.map.find-key"],"core-js/full/map/from":["es.array.iterator","es.map","es.string.iterator","esnext.map.from","web.dom-collections.iterator"],"core-js/full/map/group-by":["es.map","esnext.map.group-by"],"core-js/full/map/includes":["es.map","esnext.map.includes"],"core-js/full/map/key-by":["es.map","esnext.map.key-by"],"core-js/full/map/key-of":["es.map","esnext.map.key-of"],"core-js/full/map/map-keys":["es.map","esnext.map.map-keys"],"core-js/full/map/map-values":["es.map","esnext.map.map-values"],"core-js/full/map/merge":["es.map","esnext.map.merge"],"core-js/full/map/of":["es.array.iterator","es.map","esnext.map.of"],"core-js/full/map/reduce":["es.map","esnext.map.reduce"],"core-js/full/map/some":["es.map","esnext.map.some"],"core-js/full/map/update":["es.map","esnext.map.update"],"core-js/full/map/update-or-insert":["es.map","esnext.map.update-or-insert"],"core-js/full/map/upsert":["es.map","esnext.map.upsert"],"core-js/full/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh"],"core-js/full/math/acosh":["es.math.acosh"],"core-js/full/math/asinh":["es.math.asinh"],"core-js/full/math/atanh":["es.math.atanh"],"core-js/full/math/cbrt":["es.math.cbrt"],"core-js/full/math/clamp":["esnext.math.clamp"],"core-js/full/math/clz32":["es.math.clz32"],"core-js/full/math/cosh":["es.math.cosh"],"core-js/full/math/deg-per-rad":["esnext.math.deg-per-rad"],"core-js/full/math/degrees":["esnext.math.degrees"],"core-js/full/math/expm1":["es.math.expm1"],"core-js/full/math/fround":["es.math.fround"],"core-js/full/math/fscale":["esnext.math.fscale"],"core-js/full/math/hypot":["es.math.hypot"],"core-js/full/math/iaddh":["esnext.math.iaddh"],"core-js/full/math/imul":["es.math.imul"],"core-js/full/math/imulh":["esnext.math.imulh"],"core-js/full/math/isubh":["esnext.math.isubh"],"core-js/full/math/log10":["es.math.log10"],"core-js/full/math/log1p":["es.math.log1p"],"core-js/full/math/log2":["es.math.log2"],"core-js/full/math/rad-per-deg":["esnext.math.rad-per-deg"],"core-js/full/math/radians":["esnext.math.radians"],"core-js/full/math/scale":["esnext.math.scale"],"core-js/full/math/seeded-prng":["esnext.math.seeded-prng"],"core-js/full/math/sign":["es.math.sign"],"core-js/full/math/signbit":["esnext.math.signbit"],"core-js/full/math/sinh":["es.math.sinh"],"core-js/full/math/tanh":["es.math.tanh"],"core-js/full/math/to-string-tag":["es.math.to-string-tag"],"core-js/full/math/trunc":["es.math.trunc"],"core-js/full/math/umulh":["esnext.math.umulh"],"core-js/full/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.to-string","esnext.number.from-string","esnext.number.range"],"core-js/full/number/constructor":["es.number.constructor"],"core-js/full/number/epsilon":["es.number.epsilon"],"core-js/full/number/from-string":["esnext.number.from-string"],"core-js/full/number/is-finite":["es.number.is-finite"],"core-js/full/number/is-integer":["es.number.is-integer"],"core-js/full/number/is-nan":["es.number.is-nan"],"core-js/full/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/full/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/full/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/full/number/parse-float":["es.number.parse-float"],"core-js/full/number/parse-int":["es.number.parse-int"],"core-js/full/number/range":["es.object.to-string","esnext.number.range"],"core-js/full/number/to-exponential":["es.number.to-exponential"],"core-js/full/number/to-fixed":["es.number.to-fixed"],"core-js/full/number/to-precision":["es.number.to-precision"],"core-js/full/number/virtual":["es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/full/number/virtual/to-exponential":["es.number.to-exponential"],"core-js/full/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/full/number/virtual/to-precision":["es.number.to-precision"],"core-js/full/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.reflect.to-string-tag","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","web.dom-collections.iterator"],"core-js/full/object/assign":["es.object.assign"],"core-js/full/object/create":["es.object.create"],"core-js/full/object/define-getter":["es.object.define-getter"],"core-js/full/object/define-properties":["es.object.define-properties"],"core-js/full/object/define-property":["es.object.define-property"],"core-js/full/object/define-setter":["es.object.define-setter"],"core-js/full/object/entries":["es.object.entries"],"core-js/full/object/freeze":["es.object.freeze"],"core-js/full/object/from-entries":["es.array.iterator","es.object.from-entries","web.dom-collections.iterator"],"core-js/full/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/full/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/full/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/full/object/get-own-property-symbols":["es.symbol"],"core-js/full/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/full/object/has-own":["es.object.has-own","esnext.object.has-own"],"core-js/full/object/is":["es.object.is"],"core-js/full/object/is-extensible":["es.object.is-extensible"],"core-js/full/object/is-frozen":["es.object.is-frozen"],"core-js/full/object/is-sealed":["es.object.is-sealed"],"core-js/full/object/iterate-entries":["esnext.object.iterate-entries"],"core-js/full/object/iterate-keys":["esnext.object.iterate-keys"],"core-js/full/object/iterate-values":["esnext.object.iterate-values"],"core-js/full/object/keys":["es.object.keys"],"core-js/full/object/lookup-getter":["es.object.lookup-getter"],"core-js/full/object/lookup-setter":["es.object.lookup-setter"],"core-js/full/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/full/object/seal":["es.object.seal"],"core-js/full/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/full/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/full/object/values":["es.object.values"],"core-js/full/observable":["es.object.to-string","es.string.iterator","esnext.observable","esnext.symbol.observable","web.dom-collections.iterator"],"core-js/full/parse-float":["es.parse-float"],"core-js/full/parse-int":["es.parse-int"],"core-js/full/promise":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.string.iterator","esnext.aggregate-error","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","web.dom-collections.iterator"],"core-js/full/promise/all-settled":["es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.string.iterator","esnext.promise.all-settled","web.dom-collections.iterator"],"core-js/full/promise/any":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.any","es.string.iterator","esnext.aggregate-error","esnext.promise.any","web.dom-collections.iterator"],"core-js/full/promise/finally":["es.object.to-string","es.promise","es.promise.finally"],"core-js/full/promise/try":["es.promise","esnext.promise.try"],"core-js/full/queue-microtask":["web.queue-microtask"],"core-js/full/reflect":["es.object.to-string","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata"],"core-js/full/reflect/apply":["es.reflect.apply"],"core-js/full/reflect/construct":["es.reflect.construct"],"core-js/full/reflect/define-metadata":["esnext.reflect.define-metadata"],"core-js/full/reflect/define-property":["es.reflect.define-property"],"core-js/full/reflect/delete-metadata":["esnext.reflect.delete-metadata"],"core-js/full/reflect/delete-property":["es.reflect.delete-property"],"core-js/full/reflect/get":["es.reflect.get"],"core-js/full/reflect/get-metadata":["esnext.reflect.get-metadata"],"core-js/full/reflect/get-metadata-keys":["esnext.reflect.get-metadata-keys"],"core-js/full/reflect/get-own-metadata":["esnext.reflect.get-own-metadata"],"core-js/full/reflect/get-own-metadata-keys":["esnext.reflect.get-own-metadata-keys"],"core-js/full/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/full/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/full/reflect/has":["es.reflect.has"],"core-js/full/reflect/has-metadata":["esnext.reflect.has-metadata"],"core-js/full/reflect/has-own-metadata":["esnext.reflect.has-own-metadata"],"core-js/full/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/full/reflect/metadata":["esnext.reflect.metadata"],"core-js/full/reflect/own-keys":["es.reflect.own-keys"],"core-js/full/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/full/reflect/set":["es.reflect.set"],"core-js/full/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/full/reflect/to-string-tag":["es.reflect.to-string-tag"],"core-js/full/regexp":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/full/regexp/constructor":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.sticky"],"core-js/full/regexp/dot-all":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec"],"core-js/full/regexp/flags":["es.regexp.flags"],"core-js/full/regexp/match":["es.regexp.exec","es.string.match"],"core-js/full/regexp/replace":["es.regexp.exec","es.string.replace"],"core-js/full/regexp/search":["es.regexp.exec","es.string.search"],"core-js/full/regexp/split":["es.regexp.exec","es.string.split"],"core-js/full/regexp/sticky":["es.regexp.constructor","es.regexp.exec","es.regexp.sticky"],"core-js/full/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/full/regexp/to-string":["es.regexp.to-string"],"core-js/full/set":["es.array.iterator","es.object.to-string","es.set","es.string.iterator","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","web.dom-collections.iterator"],"core-js/full/set-immediate":["web.immediate"],"core-js/full/set-interval":["web.timers"],"core-js/full/set-timeout":["web.timers"],"core-js/full/set/add-all":["es.set","esnext.set.add-all"],"core-js/full/set/delete-all":["es.set","esnext.set.delete-all"],"core-js/full/set/difference":["es.array.iterator","es.set","es.string.iterator","esnext.set.difference","web.dom-collections.iterator"],"core-js/full/set/every":["es.set","esnext.set.every"],"core-js/full/set/filter":["es.set","esnext.set.filter"],"core-js/full/set/find":["es.set","esnext.set.find"],"core-js/full/set/from":["es.array.iterator","es.set","es.string.iterator","esnext.set.from","web.dom-collections.iterator"],"core-js/full/set/intersection":["es.array.iterator","es.set","es.string.iterator","esnext.set.intersection","web.dom-collections.iterator"],"core-js/full/set/is-disjoint-from":["es.array.iterator","es.set","es.string.iterator","esnext.set.is-disjoint-from","web.dom-collections.iterator"],"core-js/full/set/is-subset-of":["es.array.iterator","es.set","es.string.iterator","esnext.set.is-subset-of","web.dom-collections.iterator"],"core-js/full/set/is-superset-of":["es.array.iterator","es.set","es.string.iterator","esnext.set.is-superset-of","web.dom-collections.iterator"],"core-js/full/set/join":["es.set","esnext.set.join"],"core-js/full/set/map":["es.set","esnext.set.map"],"core-js/full/set/of":["es.array.iterator","es.set","esnext.set.of"],"core-js/full/set/reduce":["es.set","esnext.set.reduce"],"core-js/full/set/some":["es.set","esnext.set.some"],"core-js/full/set/symmetric-difference":["es.array.iterator","es.set","es.string.iterator","esnext.set.symmetric-difference","web.dom-collections.iterator"],"core-js/full/set/union":["es.array.iterator","es.set","es.string.iterator","esnext.set.union","web.dom-collections.iterator"],"core-js/full/string":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all"],"core-js/full/string/anchor":["es.string.anchor"],"core-js/full/string/at":["es.string.at-alternative","esnext.string.at"],"core-js/full/string/big":["es.string.big"],"core-js/full/string/blink":["es.string.blink"],"core-js/full/string/bold":["es.string.bold"],"core-js/full/string/code-point-at":["es.string.code-point-at"],"core-js/full/string/code-points":["es.object.to-string","esnext.string.code-points"],"core-js/full/string/cooked":["esnext.string.cooked"],"core-js/full/string/ends-with":["es.string.ends-with"],"core-js/full/string/fixed":["es.string.fixed"],"core-js/full/string/fontcolor":["es.string.fontcolor"],"core-js/full/string/fontsize":["es.string.fontsize"],"core-js/full/string/from-code-point":["es.string.from-code-point"],"core-js/full/string/includes":["es.string.includes"],"core-js/full/string/italics":["es.string.italics"],"core-js/full/string/iterator":["es.object.to-string","es.string.iterator"],"core-js/full/string/link":["es.string.link"],"core-js/full/string/match":["es.regexp.exec","es.string.match"],"core-js/full/string/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all","esnext.string.match-all"],"core-js/full/string/pad-end":["es.string.pad-end"],"core-js/full/string/pad-start":["es.string.pad-start"],"core-js/full/string/raw":["es.string.raw"],"core-js/full/string/repeat":["es.string.repeat"],"core-js/full/string/replace":["es.regexp.exec","es.string.replace"],"core-js/full/string/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all","esnext.string.replace-all"],"core-js/full/string/search":["es.regexp.exec","es.string.search"],"core-js/full/string/small":["es.string.small"],"core-js/full/string/split":["es.regexp.exec","es.string.split"],"core-js/full/string/starts-with":["es.string.starts-with"],"core-js/full/string/strike":["es.string.strike"],"core-js/full/string/sub":["es.string.sub"],"core-js/full/string/substr":["es.string.substr"],"core-js/full/string/sup":["es.string.sup"],"core-js/full/string/trim":["es.string.trim"],"core-js/full/string/trim-end":["es.string.trim-end"],"core-js/full/string/trim-left":["es.string.trim-start"],"core-js/full/string/trim-right":["es.string.trim-end"],"core-js/full/string/trim-start":["es.string.trim-start"],"core-js/full/string/virtual":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all"],"core-js/full/string/virtual/anchor":["es.string.anchor"],"core-js/full/string/virtual/at":["es.string.at-alternative","esnext.string.at"],"core-js/full/string/virtual/big":["es.string.big"],"core-js/full/string/virtual/blink":["es.string.blink"],"core-js/full/string/virtual/bold":["es.string.bold"],"core-js/full/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/full/string/virtual/code-points":["es.object.to-string","esnext.string.code-points"],"core-js/full/string/virtual/ends-with":["es.string.ends-with"],"core-js/full/string/virtual/fixed":["es.string.fixed"],"core-js/full/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/full/string/virtual/fontsize":["es.string.fontsize"],"core-js/full/string/virtual/includes":["es.string.includes"],"core-js/full/string/virtual/italics":["es.string.italics"],"core-js/full/string/virtual/iterator":["es.object.to-string","es.string.iterator"],"core-js/full/string/virtual/link":["es.string.link"],"core-js/full/string/virtual/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all","esnext.string.match-all"],"core-js/full/string/virtual/pad-end":["es.string.pad-end"],"core-js/full/string/virtual/pad-start":["es.string.pad-start"],"core-js/full/string/virtual/repeat":["es.string.repeat"],"core-js/full/string/virtual/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all","esnext.string.replace-all"],"core-js/full/string/virtual/small":["es.string.small"],"core-js/full/string/virtual/starts-with":["es.string.starts-with"],"core-js/full/string/virtual/strike":["es.string.strike"],"core-js/full/string/virtual/sub":["es.string.sub"],"core-js/full/string/virtual/substr":["es.string.substr"],"core-js/full/string/virtual/sup":["es.string.sup"],"core-js/full/string/virtual/trim":["es.string.trim"],"core-js/full/string/virtual/trim-end":["es.string.trim-end"],"core-js/full/string/virtual/trim-left":["es.string.trim-start"],"core-js/full/string/virtual/trim-right":["es.string.trim-end"],"core-js/full/string/virtual/trim-start":["es.string.trim-start"],"core-js/full/structured-clone":["es.error.to-string","es.array.iterator","es.map","es.object.keys","es.object.to-string","es.set","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.structured-clone"],"core-js/full/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","web.dom-collections.iterator"],"core-js/full/symbol/async-dispose":["esnext.symbol.async-dispose"],"core-js/full/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/full/symbol/description":["es.symbol.description"],"core-js/full/symbol/dispose":["esnext.symbol.dispose"],"core-js/full/symbol/for":["es.symbol"],"core-js/full/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/full/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/full/symbol/iterator":["es.symbol.iterator","es.array.iterator","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/full/symbol/key-for":["es.symbol"],"core-js/full/symbol/match":["es.symbol.match","es.regexp.exec","es.string.match"],"core-js/full/symbol/match-all":["es.symbol.match-all","es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/full/symbol/matcher":["esnext.symbol.matcher"],"core-js/full/symbol/metadata":["esnext.symbol.metadata"],"core-js/full/symbol/observable":["esnext.symbol.observable"],"core-js/full/symbol/pattern-match":["esnext.symbol.pattern-match"],"core-js/full/symbol/replace":["es.symbol.replace","es.regexp.exec","es.string.replace"],"core-js/full/symbol/replace-all":["esnext.symbol.replace-all"],"core-js/full/symbol/search":["es.symbol.search","es.regexp.exec","es.string.search"],"core-js/full/symbol/species":["es.symbol.species"],"core-js/full/symbol/split":["es.symbol.split","es.regexp.exec","es.string.split"],"core-js/full/symbol/to-primitive":["es.symbol.to-primitive","es.date.to-primitive"],"core-js/full/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/full/symbol/unscopables":["es.symbol.unscopables"],"core-js/full/typed-array":["es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/at":["es.typed-array.at","esnext.typed-array.at"],"core-js/full/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/full/typed-array/entries":["es.object.to-string","es.typed-array.iterator"],"core-js/full/typed-array/every":["es.typed-array.every"],"core-js/full/typed-array/fill":["es.typed-array.fill"],"core-js/full/typed-array/filter":["es.typed-array.filter"],"core-js/full/typed-array/filter-out":["esnext.typed-array.filter-out"],"core-js/full/typed-array/filter-reject":["esnext.typed-array.filter-reject"],"core-js/full/typed-array/find":["es.typed-array.find"],"core-js/full/typed-array/find-index":["es.typed-array.find-index"],"core-js/full/typed-array/find-last":["esnext.typed-array.find-last"],"core-js/full/typed-array/find-last-index":["esnext.typed-array.find-last-index"],"core-js/full/typed-array/float32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.float32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/float64-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.float64-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/for-each":["es.typed-array.for-each"],"core-js/full/typed-array/from":["es.typed-array.from"],"core-js/full/typed-array/from-async":["esnext.typed-array.from-async"],"core-js/full/typed-array/group-by":["esnext.typed-array.group-by"],"core-js/full/typed-array/includes":["es.typed-array.includes"],"core-js/full/typed-array/index-of":["es.typed-array.index-of"],"core-js/full/typed-array/int16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.int16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/int32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.int32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/int8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.int8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/iterator":["es.object.to-string","es.typed-array.iterator"],"core-js/full/typed-array/join":["es.typed-array.join"],"core-js/full/typed-array/keys":["es.object.to-string","es.typed-array.iterator"],"core-js/full/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/full/typed-array/map":["es.typed-array.map"],"core-js/full/typed-array/methods":["es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/of":["es.typed-array.of"],"core-js/full/typed-array/reduce":["es.typed-array.reduce"],"core-js/full/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/full/typed-array/reverse":["es.typed-array.reverse"],"core-js/full/typed-array/set":["es.typed-array.set"],"core-js/full/typed-array/slice":["es.typed-array.slice"],"core-js/full/typed-array/some":["es.typed-array.some"],"core-js/full/typed-array/sort":["es.typed-array.sort"],"core-js/full/typed-array/subarray":["es.typed-array.subarray"],"core-js/full/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/full/typed-array/to-reversed":["esnext.typed-array.to-reversed"],"core-js/full/typed-array/to-sorted":["es.typed-array.sort","esnext.typed-array.to-sorted"],"core-js/full/typed-array/to-spliced":["esnext.typed-array.to-spliced"],"core-js/full/typed-array/to-string":["es.typed-array.to-string"],"core-js/full/typed-array/uint16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/uint32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/uint8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/uint8-clamped-array":["es.array-buffer.constructor","es.array-buffer.slice","es.map","es.object.to-string","es.promise","es.string.iterator","es.typed-array.uint8-clamped-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with"],"core-js/full/typed-array/unique-by":["es.map","esnext.typed-array.unique-by"],"core-js/full/typed-array/values":["es.object.to-string","es.typed-array.iterator"],"core-js/full/typed-array/with":["esnext.typed-array.with"],"core-js/full/unescape":["es.unescape"],"core-js/full/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/full/url-search-params":["web.dom-collections.iterator","web.url-search-params"],"core-js/full/url/to-json":["web.url.to-json"],"core-js/full/weak-map":["es.array.iterator","es.object.to-string","es.string.iterator","es.weak-map","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","web.dom-collections.iterator"],"core-js/full/weak-map/delete-all":["es.weak-map","esnext.weak-map.delete-all"],"core-js/full/weak-map/emplace":["es.weak-map","esnext.weak-map.emplace"],"core-js/full/weak-map/from":["es.array.iterator","es.string.iterator","es.weak-map","esnext.weak-map.from","web.dom-collections.iterator"],"core-js/full/weak-map/of":["es.array.iterator","es.weak-map","esnext.weak-map.of"],"core-js/full/weak-map/upsert":["es.weak-map","esnext.weak-map.upsert"],"core-js/full/weak-set":["es.array.iterator","es.object.to-string","es.string.iterator","es.weak-set","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.iterator"],"core-js/full/weak-set/add-all":["es.weak-set","esnext.weak-set.add-all"],"core-js/full/weak-set/delete-all":["es.weak-set","esnext.weak-set.delete-all"],"core-js/full/weak-set/from":["es.array.iterator","es.string.iterator","es.weak-set","esnext.weak-set.from","web.dom-collections.iterator"],"core-js/full/weak-set/of":["es.array.iterator","es.weak-set","esnext.weak-set.of"],"core-js/modules/es.aggregate-error":["es.aggregate-error"],"core-js/modules/es.aggregate-error.cause":["es.aggregate-error.cause"],"core-js/modules/es.aggregate-error.constructor":["es.aggregate-error.constructor"],"core-js/modules/es.array-buffer.constructor":["es.array-buffer.constructor"],"core-js/modules/es.array-buffer.is-view":["es.array-buffer.is-view"],"core-js/modules/es.array-buffer.slice":["es.array-buffer.slice"],"core-js/modules/es.array.at":["es.array.at"],"core-js/modules/es.array.concat":["es.array.concat"],"core-js/modules/es.array.copy-within":["es.array.copy-within"],"core-js/modules/es.array.every":["es.array.every"],"core-js/modules/es.array.fill":["es.array.fill"],"core-js/modules/es.array.filter":["es.array.filter"],"core-js/modules/es.array.find":["es.array.find"],"core-js/modules/es.array.find-index":["es.array.find-index"],"core-js/modules/es.array.flat":["es.array.flat"],"core-js/modules/es.array.flat-map":["es.array.flat-map"],"core-js/modules/es.array.for-each":["es.array.for-each"],"core-js/modules/es.array.from":["es.array.from"],"core-js/modules/es.array.includes":["es.array.includes"],"core-js/modules/es.array.index-of":["es.array.index-of"],"core-js/modules/es.array.is-array":["es.array.is-array"],"core-js/modules/es.array.iterator":["es.array.iterator"],"core-js/modules/es.array.join":["es.array.join"],"core-js/modules/es.array.last-index-of":["es.array.last-index-of"],"core-js/modules/es.array.map":["es.array.map"],"core-js/modules/es.array.of":["es.array.of"],"core-js/modules/es.array.reduce":["es.array.reduce"],"core-js/modules/es.array.reduce-right":["es.array.reduce-right"],"core-js/modules/es.array.reverse":["es.array.reverse"],"core-js/modules/es.array.slice":["es.array.slice"],"core-js/modules/es.array.some":["es.array.some"],"core-js/modules/es.array.sort":["es.array.sort"],"core-js/modules/es.array.species":["es.array.species"],"core-js/modules/es.array.splice":["es.array.splice"],"core-js/modules/es.array.unscopables.flat":["es.array.unscopables.flat"],"core-js/modules/es.array.unscopables.flat-map":["es.array.unscopables.flat-map"],"core-js/modules/es.data-view":["es.data-view"],"core-js/modules/es.data-view.constructor":["es.data-view.constructor"],"core-js/modules/es.date.get-year":["es.date.get-year"],"core-js/modules/es.date.now":["es.date.now"],"core-js/modules/es.date.set-year":["es.date.set-year"],"core-js/modules/es.date.to-gmt-string":["es.date.to-gmt-string"],"core-js/modules/es.date.to-iso-string":["es.date.to-iso-string"],"core-js/modules/es.date.to-json":["es.date.to-json"],"core-js/modules/es.date.to-primitive":["es.date.to-primitive"],"core-js/modules/es.date.to-string":["es.date.to-string"],"core-js/modules/es.error.cause":["es.error.cause"],"core-js/modules/es.error.to-string":["es.error.to-string"],"core-js/modules/es.escape":["es.escape"],"core-js/modules/es.function.bind":["es.function.bind"],"core-js/modules/es.function.has-instance":["es.function.has-instance"],"core-js/modules/es.function.name":["es.function.name"],"core-js/modules/es.global-this":["es.global-this"],"core-js/modules/es.json.stringify":["es.json.stringify"],"core-js/modules/es.json.to-string-tag":["es.json.to-string-tag"],"core-js/modules/es.map":["es.map"],"core-js/modules/es.map.constructor":["es.map.constructor"],"core-js/modules/es.math.acosh":["es.math.acosh"],"core-js/modules/es.math.asinh":["es.math.asinh"],"core-js/modules/es.math.atanh":["es.math.atanh"],"core-js/modules/es.math.cbrt":["es.math.cbrt"],"core-js/modules/es.math.clz32":["es.math.clz32"],"core-js/modules/es.math.cosh":["es.math.cosh"],"core-js/modules/es.math.expm1":["es.math.expm1"],"core-js/modules/es.math.fround":["es.math.fround"],"core-js/modules/es.math.hypot":["es.math.hypot"],"core-js/modules/es.math.imul":["es.math.imul"],"core-js/modules/es.math.log10":["es.math.log10"],"core-js/modules/es.math.log1p":["es.math.log1p"],"core-js/modules/es.math.log2":["es.math.log2"],"core-js/modules/es.math.sign":["es.math.sign"],"core-js/modules/es.math.sinh":["es.math.sinh"],"core-js/modules/es.math.tanh":["es.math.tanh"],"core-js/modules/es.math.to-string-tag":["es.math.to-string-tag"],"core-js/modules/es.math.trunc":["es.math.trunc"],"core-js/modules/es.number.constructor":["es.number.constructor"],"core-js/modules/es.number.epsilon":["es.number.epsilon"],"core-js/modules/es.number.is-finite":["es.number.is-finite"],"core-js/modules/es.number.is-integer":["es.number.is-integer"],"core-js/modules/es.number.is-nan":["es.number.is-nan"],"core-js/modules/es.number.is-safe-integer":["es.number.is-safe-integer"],"core-js/modules/es.number.max-safe-integer":["es.number.max-safe-integer"],"core-js/modules/es.number.min-safe-integer":["es.number.min-safe-integer"],"core-js/modules/es.number.parse-float":["es.number.parse-float"],"core-js/modules/es.number.parse-int":["es.number.parse-int"],"core-js/modules/es.number.to-exponential":["es.number.to-exponential"],"core-js/modules/es.number.to-fixed":["es.number.to-fixed"],"core-js/modules/es.number.to-precision":["es.number.to-precision"],"core-js/modules/es.object.assign":["es.object.assign"],"core-js/modules/es.object.create":["es.object.create"],"core-js/modules/es.object.define-getter":["es.object.define-getter"],"core-js/modules/es.object.define-properties":["es.object.define-properties"],"core-js/modules/es.object.define-property":["es.object.define-property"],"core-js/modules/es.object.define-setter":["es.object.define-setter"],"core-js/modules/es.object.entries":["es.object.entries"],"core-js/modules/es.object.freeze":["es.object.freeze"],"core-js/modules/es.object.from-entries":["es.object.from-entries"],"core-js/modules/es.object.get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/modules/es.object.get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/modules/es.object.get-own-property-names":["es.object.get-own-property-names"],"core-js/modules/es.object.get-own-property-symbols":["es.object.get-own-property-symbols"],"core-js/modules/es.object.get-prototype-of":["es.object.get-prototype-of"],"core-js/modules/es.object.has-own":["es.object.has-own"],"core-js/modules/es.object.is":["es.object.is"],"core-js/modules/es.object.is-extensible":["es.object.is-extensible"],"core-js/modules/es.object.is-frozen":["es.object.is-frozen"],"core-js/modules/es.object.is-sealed":["es.object.is-sealed"],"core-js/modules/es.object.keys":["es.object.keys"],"core-js/modules/es.object.lookup-getter":["es.object.lookup-getter"],"core-js/modules/es.object.lookup-setter":["es.object.lookup-setter"],"core-js/modules/es.object.prevent-extensions":["es.object.prevent-extensions"],"core-js/modules/es.object.seal":["es.object.seal"],"core-js/modules/es.object.set-prototype-of":["es.object.set-prototype-of"],"core-js/modules/es.object.to-string":["es.object.to-string"],"core-js/modules/es.object.values":["es.object.values"],"core-js/modules/es.parse-float":["es.parse-float"],"core-js/modules/es.parse-int":["es.parse-int"],"core-js/modules/es.promise":["es.promise"],"core-js/modules/es.promise.all":["es.promise.all"],"core-js/modules/es.promise.all-settled":["es.promise.all-settled"],"core-js/modules/es.promise.any":["es.promise.any"],"core-js/modules/es.promise.catch":["es.promise.catch"],"core-js/modules/es.promise.constructor":["es.promise.constructor"],"core-js/modules/es.promise.finally":["es.promise.finally"],"core-js/modules/es.promise.race":["es.promise.race"],"core-js/modules/es.promise.reject":["es.promise.reject"],"core-js/modules/es.promise.resolve":["es.promise.resolve"],"core-js/modules/es.reflect.apply":["es.reflect.apply"],"core-js/modules/es.reflect.construct":["es.reflect.construct"],"core-js/modules/es.reflect.define-property":["es.reflect.define-property"],"core-js/modules/es.reflect.delete-property":["es.reflect.delete-property"],"core-js/modules/es.reflect.get":["es.reflect.get"],"core-js/modules/es.reflect.get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/modules/es.reflect.get-prototype-of":["es.reflect.get-prototype-of"],"core-js/modules/es.reflect.has":["es.reflect.has"],"core-js/modules/es.reflect.is-extensible":["es.reflect.is-extensible"],"core-js/modules/es.reflect.own-keys":["es.reflect.own-keys"],"core-js/modules/es.reflect.prevent-extensions":["es.reflect.prevent-extensions"],"core-js/modules/es.reflect.set":["es.reflect.set"],"core-js/modules/es.reflect.set-prototype-of":["es.reflect.set-prototype-of"],"core-js/modules/es.reflect.to-string-tag":["es.reflect.to-string-tag"],"core-js/modules/es.regexp.constructor":["es.regexp.constructor"],"core-js/modules/es.regexp.dot-all":["es.regexp.dot-all"],"core-js/modules/es.regexp.exec":["es.regexp.exec"],"core-js/modules/es.regexp.flags":["es.regexp.flags"],"core-js/modules/es.regexp.sticky":["es.regexp.sticky"],"core-js/modules/es.regexp.test":["es.regexp.test"],"core-js/modules/es.regexp.to-string":["es.regexp.to-string"],"core-js/modules/es.set":["es.set"],"core-js/modules/es.set.constructor":["es.set.constructor"],"core-js/modules/es.string.anchor":["es.string.anchor"],"core-js/modules/es.string.at-alternative":["es.string.at-alternative"],"core-js/modules/es.string.big":["es.string.big"],"core-js/modules/es.string.blink":["es.string.blink"],"core-js/modules/es.string.bold":["es.string.bold"],"core-js/modules/es.string.code-point-at":["es.string.code-point-at"],"core-js/modules/es.string.ends-with":["es.string.ends-with"],"core-js/modules/es.string.fixed":["es.string.fixed"],"core-js/modules/es.string.fontcolor":["es.string.fontcolor"],"core-js/modules/es.string.fontsize":["es.string.fontsize"],"core-js/modules/es.string.from-code-point":["es.string.from-code-point"],"core-js/modules/es.string.includes":["es.string.includes"],"core-js/modules/es.string.italics":["es.string.italics"],"core-js/modules/es.string.iterator":["es.string.iterator"],"core-js/modules/es.string.link":["es.string.link"],"core-js/modules/es.string.match":["es.string.match"],"core-js/modules/es.string.match-all":["es.string.match-all"],"core-js/modules/es.string.pad-end":["es.string.pad-end"],"core-js/modules/es.string.pad-start":["es.string.pad-start"],"core-js/modules/es.string.raw":["es.string.raw"],"core-js/modules/es.string.repeat":["es.string.repeat"],"core-js/modules/es.string.replace":["es.string.replace"],"core-js/modules/es.string.replace-all":["es.string.replace-all"],"core-js/modules/es.string.search":["es.string.search"],"core-js/modules/es.string.small":["es.string.small"],"core-js/modules/es.string.split":["es.string.split"],"core-js/modules/es.string.starts-with":["es.string.starts-with"],"core-js/modules/es.string.strike":["es.string.strike"],"core-js/modules/es.string.sub":["es.string.sub"],"core-js/modules/es.string.substr":["es.string.substr"],"core-js/modules/es.string.sup":["es.string.sup"],"core-js/modules/es.string.trim":["es.string.trim"],"core-js/modules/es.string.trim-end":["es.string.trim-end"],"core-js/modules/es.string.trim-left":["es.string.trim-left"],"core-js/modules/es.string.trim-right":["es.string.trim-right"],"core-js/modules/es.string.trim-start":["es.string.trim-start"],"core-js/modules/es.symbol":["es.symbol"],"core-js/modules/es.symbol.async-iterator":["es.symbol.async-iterator"],"core-js/modules/es.symbol.constructor":["es.symbol.constructor"],"core-js/modules/es.symbol.description":["es.symbol.description"],"core-js/modules/es.symbol.for":["es.symbol.for"],"core-js/modules/es.symbol.has-instance":["es.symbol.has-instance"],"core-js/modules/es.symbol.is-concat-spreadable":["es.symbol.is-concat-spreadable"],"core-js/modules/es.symbol.iterator":["es.symbol.iterator"],"core-js/modules/es.symbol.key-for":["es.symbol.key-for"],"core-js/modules/es.symbol.match":["es.symbol.match"],"core-js/modules/es.symbol.match-all":["es.symbol.match-all"],"core-js/modules/es.symbol.replace":["es.symbol.replace"],"core-js/modules/es.symbol.search":["es.symbol.search"],"core-js/modules/es.symbol.species":["es.symbol.species"],"core-js/modules/es.symbol.split":["es.symbol.split"],"core-js/modules/es.symbol.to-primitive":["es.symbol.to-primitive"],"core-js/modules/es.symbol.to-string-tag":["es.symbol.to-string-tag"],"core-js/modules/es.symbol.unscopables":["es.symbol.unscopables"],"core-js/modules/es.typed-array.at":["es.typed-array.at"],"core-js/modules/es.typed-array.copy-within":["es.typed-array.copy-within"],"core-js/modules/es.typed-array.every":["es.typed-array.every"],"core-js/modules/es.typed-array.fill":["es.typed-array.fill"],"core-js/modules/es.typed-array.filter":["es.typed-array.filter"],"core-js/modules/es.typed-array.find":["es.typed-array.find"],"core-js/modules/es.typed-array.find-index":["es.typed-array.find-index"],"core-js/modules/es.typed-array.float32-array":["es.typed-array.float32-array"],"core-js/modules/es.typed-array.float64-array":["es.typed-array.float64-array"],"core-js/modules/es.typed-array.for-each":["es.typed-array.for-each"],"core-js/modules/es.typed-array.from":["es.typed-array.from"],"core-js/modules/es.typed-array.includes":["es.typed-array.includes"],"core-js/modules/es.typed-array.index-of":["es.typed-array.index-of"],"core-js/modules/es.typed-array.int16-array":["es.typed-array.int16-array"],"core-js/modules/es.typed-array.int32-array":["es.typed-array.int32-array"],"core-js/modules/es.typed-array.int8-array":["es.typed-array.int8-array"],"core-js/modules/es.typed-array.iterator":["es.typed-array.iterator"],"core-js/modules/es.typed-array.join":["es.typed-array.join"],"core-js/modules/es.typed-array.last-index-of":["es.typed-array.last-index-of"],"core-js/modules/es.typed-array.map":["es.typed-array.map"],"core-js/modules/es.typed-array.of":["es.typed-array.of"],"core-js/modules/es.typed-array.reduce":["es.typed-array.reduce"],"core-js/modules/es.typed-array.reduce-right":["es.typed-array.reduce-right"],"core-js/modules/es.typed-array.reverse":["es.typed-array.reverse"],"core-js/modules/es.typed-array.set":["es.typed-array.set"],"core-js/modules/es.typed-array.slice":["es.typed-array.slice"],"core-js/modules/es.typed-array.some":["es.typed-array.some"],"core-js/modules/es.typed-array.sort":["es.typed-array.sort"],"core-js/modules/es.typed-array.subarray":["es.typed-array.subarray"],"core-js/modules/es.typed-array.to-locale-string":["es.typed-array.to-locale-string"],"core-js/modules/es.typed-array.to-string":["es.typed-array.to-string"],"core-js/modules/es.typed-array.uint16-array":["es.typed-array.uint16-array"],"core-js/modules/es.typed-array.uint32-array":["es.typed-array.uint32-array"],"core-js/modules/es.typed-array.uint8-array":["es.typed-array.uint8-array"],"core-js/modules/es.typed-array.uint8-clamped-array":["es.typed-array.uint8-clamped-array"],"core-js/modules/es.unescape":["es.unescape"],"core-js/modules/es.weak-map":["es.weak-map"],"core-js/modules/es.weak-map.constructor":["es.weak-map.constructor"],"core-js/modules/es.weak-set":["es.weak-set"],"core-js/modules/es.weak-set.constructor":["es.weak-set.constructor"],"core-js/modules/esnext.aggregate-error":["esnext.aggregate-error"],"core-js/modules/esnext.array.at":["esnext.array.at"],"core-js/modules/esnext.array.filter-out":["esnext.array.filter-out"],"core-js/modules/esnext.array.filter-reject":["esnext.array.filter-reject"],"core-js/modules/esnext.array.find-last":["esnext.array.find-last"],"core-js/modules/esnext.array.find-last-index":["esnext.array.find-last-index"],"core-js/modules/esnext.array.from-async":["esnext.array.from-async"],"core-js/modules/esnext.array.group-by":["esnext.array.group-by"],"core-js/modules/esnext.array.group-by-to-map":["esnext.array.group-by-to-map"],"core-js/modules/esnext.array.is-template-object":["esnext.array.is-template-object"],"core-js/modules/esnext.array.last-index":["esnext.array.last-index"],"core-js/modules/esnext.array.last-item":["esnext.array.last-item"],"core-js/modules/esnext.array.to-reversed":["esnext.array.to-reversed"],"core-js/modules/esnext.array.to-sorted":["esnext.array.to-sorted"],"core-js/modules/esnext.array.to-spliced":["esnext.array.to-spliced"],"core-js/modules/esnext.array.unique-by":["esnext.array.unique-by"],"core-js/modules/esnext.array.with":["esnext.array.with"],"core-js/modules/esnext.async-iterator.as-indexed-pairs":["esnext.async-iterator.as-indexed-pairs"],"core-js/modules/esnext.async-iterator.constructor":["esnext.async-iterator.constructor"],"core-js/modules/esnext.async-iterator.drop":["esnext.async-iterator.drop"],"core-js/modules/esnext.async-iterator.every":["esnext.async-iterator.every"],"core-js/modules/esnext.async-iterator.filter":["esnext.async-iterator.filter"],"core-js/modules/esnext.async-iterator.find":["esnext.async-iterator.find"],"core-js/modules/esnext.async-iterator.flat-map":["esnext.async-iterator.flat-map"],"core-js/modules/esnext.async-iterator.for-each":["esnext.async-iterator.for-each"],"core-js/modules/esnext.async-iterator.from":["esnext.async-iterator.from"],"core-js/modules/esnext.async-iterator.map":["esnext.async-iterator.map"],"core-js/modules/esnext.async-iterator.reduce":["esnext.async-iterator.reduce"],"core-js/modules/esnext.async-iterator.some":["esnext.async-iterator.some"],"core-js/modules/esnext.async-iterator.take":["esnext.async-iterator.take"],"core-js/modules/esnext.async-iterator.to-array":["esnext.async-iterator.to-array"],"core-js/modules/esnext.bigint.range":["esnext.bigint.range"],"core-js/modules/esnext.composite-key":["esnext.composite-key"],"core-js/modules/esnext.composite-symbol":["esnext.composite-symbol"],"core-js/modules/esnext.function.is-callable":["esnext.function.is-callable"],"core-js/modules/esnext.function.is-constructor":["esnext.function.is-constructor"],"core-js/modules/esnext.function.un-this":["esnext.function.un-this"],"core-js/modules/esnext.global-this":["esnext.global-this"],"core-js/modules/esnext.iterator.as-indexed-pairs":["esnext.iterator.as-indexed-pairs"],"core-js/modules/esnext.iterator.constructor":["esnext.iterator.constructor"],"core-js/modules/esnext.iterator.drop":["esnext.iterator.drop"],"core-js/modules/esnext.iterator.every":["esnext.iterator.every"],"core-js/modules/esnext.iterator.filter":["esnext.iterator.filter"],"core-js/modules/esnext.iterator.find":["esnext.iterator.find"],"core-js/modules/esnext.iterator.flat-map":["esnext.iterator.flat-map"],"core-js/modules/esnext.iterator.for-each":["esnext.iterator.for-each"],"core-js/modules/esnext.iterator.from":["esnext.iterator.from"],"core-js/modules/esnext.iterator.map":["esnext.iterator.map"],"core-js/modules/esnext.iterator.reduce":["esnext.iterator.reduce"],"core-js/modules/esnext.iterator.some":["esnext.iterator.some"],"core-js/modules/esnext.iterator.take":["esnext.iterator.take"],"core-js/modules/esnext.iterator.to-array":["esnext.iterator.to-array"],"core-js/modules/esnext.iterator.to-async":["esnext.iterator.to-async"],"core-js/modules/esnext.map.delete-all":["esnext.map.delete-all"],"core-js/modules/esnext.map.emplace":["esnext.map.emplace"],"core-js/modules/esnext.map.every":["esnext.map.every"],"core-js/modules/esnext.map.filter":["esnext.map.filter"],"core-js/modules/esnext.map.find":["esnext.map.find"],"core-js/modules/esnext.map.find-key":["esnext.map.find-key"],"core-js/modules/esnext.map.from":["esnext.map.from"],"core-js/modules/esnext.map.group-by":["esnext.map.group-by"],"core-js/modules/esnext.map.includes":["esnext.map.includes"],"core-js/modules/esnext.map.key-by":["esnext.map.key-by"],"core-js/modules/esnext.map.key-of":["esnext.map.key-of"],"core-js/modules/esnext.map.map-keys":["esnext.map.map-keys"],"core-js/modules/esnext.map.map-values":["esnext.map.map-values"],"core-js/modules/esnext.map.merge":["esnext.map.merge"],"core-js/modules/esnext.map.of":["esnext.map.of"],"core-js/modules/esnext.map.reduce":["esnext.map.reduce"],"core-js/modules/esnext.map.some":["esnext.map.some"],"core-js/modules/esnext.map.update":["esnext.map.update"],"core-js/modules/esnext.map.update-or-insert":["esnext.map.update-or-insert"],"core-js/modules/esnext.map.upsert":["esnext.map.upsert"],"core-js/modules/esnext.math.clamp":["esnext.math.clamp"],"core-js/modules/esnext.math.deg-per-rad":["esnext.math.deg-per-rad"],"core-js/modules/esnext.math.degrees":["esnext.math.degrees"],"core-js/modules/esnext.math.fscale":["esnext.math.fscale"],"core-js/modules/esnext.math.iaddh":["esnext.math.iaddh"],"core-js/modules/esnext.math.imulh":["esnext.math.imulh"],"core-js/modules/esnext.math.isubh":["esnext.math.isubh"],"core-js/modules/esnext.math.rad-per-deg":["esnext.math.rad-per-deg"],"core-js/modules/esnext.math.radians":["esnext.math.radians"],"core-js/modules/esnext.math.scale":["esnext.math.scale"],"core-js/modules/esnext.math.seeded-prng":["esnext.math.seeded-prng"],"core-js/modules/esnext.math.signbit":["esnext.math.signbit"],"core-js/modules/esnext.math.umulh":["esnext.math.umulh"],"core-js/modules/esnext.number.from-string":["esnext.number.from-string"],"core-js/modules/esnext.number.range":["esnext.number.range"],"core-js/modules/esnext.object.has-own":["esnext.object.has-own"],"core-js/modules/esnext.object.iterate-entries":["esnext.object.iterate-entries"],"core-js/modules/esnext.object.iterate-keys":["esnext.object.iterate-keys"],"core-js/modules/esnext.object.iterate-values":["esnext.object.iterate-values"],"core-js/modules/esnext.observable":["esnext.observable"],"core-js/modules/esnext.observable.constructor":["esnext.observable.constructor"],"core-js/modules/esnext.observable.from":["esnext.observable.from"],"core-js/modules/esnext.observable.of":["esnext.observable.of"],"core-js/modules/esnext.promise.all-settled":["esnext.promise.all-settled"],"core-js/modules/esnext.promise.any":["esnext.promise.any"],"core-js/modules/esnext.promise.try":["esnext.promise.try"],"core-js/modules/esnext.reflect.define-metadata":["esnext.reflect.define-metadata"],"core-js/modules/esnext.reflect.delete-metadata":["esnext.reflect.delete-metadata"],"core-js/modules/esnext.reflect.get-metadata":["esnext.reflect.get-metadata"],"core-js/modules/esnext.reflect.get-metadata-keys":["esnext.reflect.get-metadata-keys"],"core-js/modules/esnext.reflect.get-own-metadata":["esnext.reflect.get-own-metadata"],"core-js/modules/esnext.reflect.get-own-metadata-keys":["esnext.reflect.get-own-metadata-keys"],"core-js/modules/esnext.reflect.has-metadata":["esnext.reflect.has-metadata"],"core-js/modules/esnext.reflect.has-own-metadata":["esnext.reflect.has-own-metadata"],"core-js/modules/esnext.reflect.metadata":["esnext.reflect.metadata"],"core-js/modules/esnext.set.add-all":["esnext.set.add-all"],"core-js/modules/esnext.set.delete-all":["esnext.set.delete-all"],"core-js/modules/esnext.set.difference":["esnext.set.difference"],"core-js/modules/esnext.set.every":["esnext.set.every"],"core-js/modules/esnext.set.filter":["esnext.set.filter"],"core-js/modules/esnext.set.find":["esnext.set.find"],"core-js/modules/esnext.set.from":["esnext.set.from"],"core-js/modules/esnext.set.intersection":["esnext.set.intersection"],"core-js/modules/esnext.set.is-disjoint-from":["esnext.set.is-disjoint-from"],"core-js/modules/esnext.set.is-subset-of":["esnext.set.is-subset-of"],"core-js/modules/esnext.set.is-superset-of":["esnext.set.is-superset-of"],"core-js/modules/esnext.set.join":["esnext.set.join"],"core-js/modules/esnext.set.map":["esnext.set.map"],"core-js/modules/esnext.set.of":["esnext.set.of"],"core-js/modules/esnext.set.reduce":["esnext.set.reduce"],"core-js/modules/esnext.set.some":["esnext.set.some"],"core-js/modules/esnext.set.symmetric-difference":["esnext.set.symmetric-difference"],"core-js/modules/esnext.set.union":["esnext.set.union"],"core-js/modules/esnext.string.at":["esnext.string.at"],"core-js/modules/esnext.string.at-alternative":["esnext.string.at-alternative"],"core-js/modules/esnext.string.code-points":["esnext.string.code-points"],"core-js/modules/esnext.string.cooked":["esnext.string.cooked"],"core-js/modules/esnext.string.match-all":["esnext.string.match-all"],"core-js/modules/esnext.string.replace-all":["esnext.string.replace-all"],"core-js/modules/esnext.symbol.async-dispose":["esnext.symbol.async-dispose"],"core-js/modules/esnext.symbol.dispose":["esnext.symbol.dispose"],"core-js/modules/esnext.symbol.matcher":["esnext.symbol.matcher"],"core-js/modules/esnext.symbol.metadata":["esnext.symbol.metadata"],"core-js/modules/esnext.symbol.observable":["esnext.symbol.observable"],"core-js/modules/esnext.symbol.pattern-match":["esnext.symbol.pattern-match"],"core-js/modules/esnext.symbol.replace-all":["esnext.symbol.replace-all"],"core-js/modules/esnext.typed-array.at":["esnext.typed-array.at"],"core-js/modules/esnext.typed-array.filter-out":["esnext.typed-array.filter-out"],"core-js/modules/esnext.typed-array.filter-reject":["esnext.typed-array.filter-reject"],"core-js/modules/esnext.typed-array.find-last":["esnext.typed-array.find-last"],"core-js/modules/esnext.typed-array.find-last-index":["esnext.typed-array.find-last-index"],"core-js/modules/esnext.typed-array.from-async":["esnext.typed-array.from-async"],"core-js/modules/esnext.typed-array.group-by":["esnext.typed-array.group-by"],"core-js/modules/esnext.typed-array.to-reversed":["esnext.typed-array.to-reversed"],"core-js/modules/esnext.typed-array.to-sorted":["esnext.typed-array.to-sorted"],"core-js/modules/esnext.typed-array.to-spliced":["esnext.typed-array.to-spliced"],"core-js/modules/esnext.typed-array.unique-by":["esnext.typed-array.unique-by"],"core-js/modules/esnext.typed-array.with":["esnext.typed-array.with"],"core-js/modules/esnext.weak-map.delete-all":["esnext.weak-map.delete-all"],"core-js/modules/esnext.weak-map.emplace":["esnext.weak-map.emplace"],"core-js/modules/esnext.weak-map.from":["esnext.weak-map.from"],"core-js/modules/esnext.weak-map.of":["esnext.weak-map.of"],"core-js/modules/esnext.weak-map.upsert":["esnext.weak-map.upsert"],"core-js/modules/esnext.weak-set.add-all":["esnext.weak-set.add-all"],"core-js/modules/esnext.weak-set.delete-all":["esnext.weak-set.delete-all"],"core-js/modules/esnext.weak-set.from":["esnext.weak-set.from"],"core-js/modules/esnext.weak-set.of":["esnext.weak-set.of"],"core-js/modules/web.atob":["web.atob"],"core-js/modules/web.btoa":["web.btoa"],"core-js/modules/web.clear-immediate":["web.clear-immediate"],"core-js/modules/web.dom-collections.for-each":["web.dom-collections.for-each"],"core-js/modules/web.dom-collections.iterator":["web.dom-collections.iterator"],"core-js/modules/web.dom-exception.constructor":["web.dom-exception.constructor"],"core-js/modules/web.dom-exception.stack":["web.dom-exception.stack"],"core-js/modules/web.dom-exception.to-string-tag":["web.dom-exception.to-string-tag"],"core-js/modules/web.immediate":["web.immediate"],"core-js/modules/web.queue-microtask":["web.queue-microtask"],"core-js/modules/web.set-immediate":["web.set-immediate"],"core-js/modules/web.set-interval":["web.set-interval"],"core-js/modules/web.set-timeout":["web.set-timeout"],"core-js/modules/web.structured-clone":["web.structured-clone"],"core-js/modules/web.timers":["web.timers"],"core-js/modules/web.url":["web.url"],"core-js/modules/web.url-search-params":["web.url-search-params"],"core-js/modules/web.url-search-params.constructor":["web.url-search-params.constructor"],"core-js/modules/web.url.constructor":["web.url.constructor"],"core-js/modules/web.url.to-json":["web.url.to-json"],"core-js/proposals":["es.map","es.string.at-alternative","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/proposals/accessible-object-hasownproperty":["esnext.object.has-own"],"core-js/proposals/array-filtering":["esnext.array.filter-out","esnext.array.filter-reject","esnext.typed-array.filter-out","esnext.typed-array.filter-reject"],"core-js/proposals/array-filtering-stage-1":["esnext.array.filter-reject","esnext.typed-array.filter-reject"],"core-js/proposals/array-find-from-last":["esnext.array.find-last","esnext.array.find-last-index","esnext.typed-array.find-last","esnext.typed-array.find-last-index"],"core-js/proposals/array-flat-map":["es.array.flat","es.array.flat-map","es.array.unscopables.flat","es.array.unscopables.flat-map"],"core-js/proposals/array-from-async":["esnext.array.from-async","esnext.typed-array.from-async"],"core-js/proposals/array-from-async-stage-2":["esnext.array.from-async"],"core-js/proposals/array-grouping":["esnext.array.group-by","esnext.array.group-by-to-map","esnext.typed-array.group-by"],"core-js/proposals/array-grouping-stage-3":["esnext.array.group-by","esnext.array.group-by-to-map"],"core-js/proposals/array-includes":["es.array.includes","es.typed-array.includes"],"core-js/proposals/array-is-template-object":["esnext.array.is-template-object"],"core-js/proposals/array-last":["esnext.array.last-index","esnext.array.last-item"],"core-js/proposals/array-unique":["es.map","esnext.array.unique-by","esnext.typed-array.unique-by"],"core-js/proposals/async-iteration":["es.symbol.async-iterator"],"core-js/proposals/change-array-by-copy":["esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/proposals/collection-methods":["esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.set.add-all","esnext.set.delete-all","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.join","esnext.set.map","esnext.set.reduce","esnext.set.some","esnext.weak-map.delete-all","esnext.weak-set.add-all","esnext.weak-set.delete-all"],"core-js/proposals/collection-of-from":["esnext.map.from","esnext.map.of","esnext.set.from","esnext.set.of","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-set.from","esnext.weak-set.of"],"core-js/proposals/decorators":["esnext.symbol.metadata"],"core-js/proposals/efficient-64-bit-arithmetic":["esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.umulh"],"core-js/proposals/error-cause":["es.error.cause","es.aggregate-error.cause"],"core-js/proposals/function-is-callable-is-constructor":["esnext.function.is-callable","esnext.function.is-constructor"],"core-js/proposals/function-un-this":["esnext.function.un-this"],"core-js/proposals/global-this":["esnext.global-this"],"core-js/proposals/iterator-helpers":["esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async"],"core-js/proposals/keys-composition":["esnext.composite-key","esnext.composite-symbol"],"core-js/proposals/map-update-or-insert":["esnext.map.emplace","esnext.map.update-or-insert","esnext.map.upsert","esnext.weak-map.emplace","esnext.weak-map.upsert"],"core-js/proposals/map-upsert":["esnext.map.emplace","esnext.map.update-or-insert","esnext.map.upsert","esnext.weak-map.emplace","esnext.weak-map.upsert"],"core-js/proposals/map-upsert-stage-2":["esnext.map.emplace","esnext.weak-map.emplace"],"core-js/proposals/math-extensions":["esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale"],"core-js/proposals/math-signbit":["esnext.math.signbit"],"core-js/proposals/number-from-string":["esnext.number.from-string"],"core-js/proposals/number-range":["esnext.bigint.range","esnext.number.range"],"core-js/proposals/object-from-entries":["es.object.from-entries"],"core-js/proposals/object-getownpropertydescriptors":["es.object.get-own-property-descriptors"],"core-js/proposals/object-iteration":["esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values"],"core-js/proposals/object-values-entries":["es.object.entries","es.object.values"],"core-js/proposals/observable":["esnext.observable","esnext.symbol.observable"],"core-js/proposals/pattern-matching":["esnext.symbol.matcher","esnext.symbol.pattern-match"],"core-js/proposals/promise-all-settled":["esnext.promise.all-settled"],"core-js/proposals/promise-any":["esnext.aggregate-error","esnext.promise.any"],"core-js/proposals/promise-finally":["es.promise.finally"],"core-js/proposals/promise-try":["esnext.promise.try"],"core-js/proposals/reflect-metadata":["esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata"],"core-js/proposals/regexp-dotall-flag":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags"],"core-js/proposals/regexp-named-groups":["es.regexp.constructor","es.regexp.exec","es.string.replace"],"core-js/proposals/relative-indexing-method":["es.string.at-alternative","esnext.array.at","esnext.typed-array.at"],"core-js/proposals/seeded-random":["esnext.math.seeded-prng"],"core-js/proposals/set-methods":["esnext.set.difference","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.symmetric-difference","esnext.set.union"],"core-js/proposals/string-at":["esnext.string.at"],"core-js/proposals/string-code-points":["esnext.string.code-points"],"core-js/proposals/string-cooked":["esnext.string.cooked"],"core-js/proposals/string-left-right-trim":["es.string.trim-end","es.string.trim-start"],"core-js/proposals/string-match-all":["esnext.string.match-all"],"core-js/proposals/string-padding":["es.string.pad-end","es.string.pad-start"],"core-js/proposals/string-replace-all":["esnext.string.replace-all","esnext.symbol.replace-all"],"core-js/proposals/string-replace-all-stage-4":["esnext.string.replace-all"],"core-js/proposals/symbol-description":["es.symbol.description"],"core-js/proposals/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/proposals/using-statement":["esnext.symbol.async-dispose","esnext.symbol.dispose"],"core-js/proposals/well-formed-stringify":["es.json.stringify"],"core-js/stable":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set","web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/stable/aggregate-error":["es.error.cause","es.aggregate-error","es.aggregate-error.cause","es.array.iterator","es.string.iterator","esnext.aggregate-error","web.dom-collections.iterator"],"core-js/stable/array":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.object.to-string","es.string.iterator"],"core-js/stable/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/stable/array-buffer/constructor":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string"],"core-js/stable/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/stable/array-buffer/slice":["es.array-buffer.slice"],"core-js/stable/array/at":["es.array.at"],"core-js/stable/array/concat":["es.array.concat"],"core-js/stable/array/copy-within":["es.array.copy-within"],"core-js/stable/array/entries":["es.array.iterator","es.object.to-string"],"core-js/stable/array/every":["es.array.every"],"core-js/stable/array/fill":["es.array.fill"],"core-js/stable/array/filter":["es.array.filter"],"core-js/stable/array/find":["es.array.find"],"core-js/stable/array/find-index":["es.array.find-index"],"core-js/stable/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/stable/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/stable/array/for-each":["es.array.for-each"],"core-js/stable/array/from":["es.array.from","es.string.iterator"],"core-js/stable/array/includes":["es.array.includes"],"core-js/stable/array/index-of":["es.array.index-of"],"core-js/stable/array/is-array":["es.array.is-array"],"core-js/stable/array/iterator":["es.array.iterator","es.object.to-string"],"core-js/stable/array/join":["es.array.join"],"core-js/stable/array/keys":["es.array.iterator","es.object.to-string"],"core-js/stable/array/last-index-of":["es.array.last-index-of"],"core-js/stable/array/map":["es.array.map"],"core-js/stable/array/of":["es.array.of"],"core-js/stable/array/reduce":["es.array.reduce"],"core-js/stable/array/reduce-right":["es.array.reduce-right"],"core-js/stable/array/reverse":["es.array.reverse"],"core-js/stable/array/slice":["es.array.slice"],"core-js/stable/array/some":["es.array.some"],"core-js/stable/array/sort":["es.array.sort"],"core-js/stable/array/splice":["es.array.splice"],"core-js/stable/array/values":["es.array.iterator","es.object.to-string"],"core-js/stable/array/virtual":["es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.object.to-string"],"core-js/stable/array/virtual/at":["es.array.at"],"core-js/stable/array/virtual/concat":["es.array.concat"],"core-js/stable/array/virtual/copy-within":["es.array.copy-within"],"core-js/stable/array/virtual/entries":["es.array.iterator","es.object.to-string"],"core-js/stable/array/virtual/every":["es.array.every"],"core-js/stable/array/virtual/fill":["es.array.fill"],"core-js/stable/array/virtual/filter":["es.array.filter"],"core-js/stable/array/virtual/find":["es.array.find"],"core-js/stable/array/virtual/find-index":["es.array.find-index"],"core-js/stable/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/stable/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/stable/array/virtual/for-each":["es.array.for-each"],"core-js/stable/array/virtual/includes":["es.array.includes"],"core-js/stable/array/virtual/index-of":["es.array.index-of"],"core-js/stable/array/virtual/iterator":["es.array.iterator","es.object.to-string"],"core-js/stable/array/virtual/join":["es.array.join"],"core-js/stable/array/virtual/keys":["es.array.iterator","es.object.to-string"],"core-js/stable/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/stable/array/virtual/map":["es.array.map"],"core-js/stable/array/virtual/reduce":["es.array.reduce"],"core-js/stable/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/stable/array/virtual/reverse":["es.array.reverse"],"core-js/stable/array/virtual/slice":["es.array.slice"],"core-js/stable/array/virtual/some":["es.array.some"],"core-js/stable/array/virtual/sort":["es.array.sort"],"core-js/stable/array/virtual/splice":["es.array.splice"],"core-js/stable/array/virtual/values":["es.array.iterator","es.object.to-string"],"core-js/stable/atob":["es.error.to-string","es.object.to-string","web.atob","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/stable/btoa":["es.error.to-string","es.object.to-string","web.btoa","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/stable/clear-immediate":["web.immediate"],"core-js/stable/data-view":["es.array-buffer.constructor","es.array-buffer.slice","es.data-view","es.object.to-string"],"core-js/stable/date":["es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/stable/date/get-year":["es.date.get-year"],"core-js/stable/date/now":["es.date.now"],"core-js/stable/date/set-year":["es.date.set-year"],"core-js/stable/date/to-gmt-string":["es.date.to-gmt-string"],"core-js/stable/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/stable/date/to-json":["es.date.to-json"],"core-js/stable/date/to-primitive":["es.date.to-primitive"],"core-js/stable/date/to-string":["es.date.to-string"],"core-js/stable/dom-collections":["es.array.iterator","es.object.to-string","web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/stable/dom-collections/for-each":["web.dom-collections.for-each"],"core-js/stable/dom-collections/iterator":["es.object.to-string","web.dom-collections.iterator"],"core-js/stable/dom-exception":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/stable/dom-exception/constructor":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack"],"core-js/stable/dom-exception/to-string-tag":["web.dom-exception.to-string-tag"],"core-js/stable/error":["es.error.cause","es.error.to-string"],"core-js/stable/error/constructor":["es.error.cause"],"core-js/stable/error/to-string":["es.error.to-string"],"core-js/stable/escape":["es.escape"],"core-js/stable/function":["es.function.bind","es.function.has-instance","es.function.name"],"core-js/stable/function/bind":["es.function.bind"],"core-js/stable/function/has-instance":["es.function.has-instance"],"core-js/stable/function/name":["es.function.name"],"core-js/stable/function/virtual":["es.function.bind"],"core-js/stable/function/virtual/bind":["es.function.bind"],"core-js/stable/get-iterator":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/get-iterator-method":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/global-this":["es.global-this"],"core-js/stable/instance/at":["es.array.at","es.string.at-alternative"],"core-js/stable/instance/bind":["es.function.bind"],"core-js/stable/instance/code-point-at":["es.string.code-point-at"],"core-js/stable/instance/concat":["es.array.concat"],"core-js/stable/instance/copy-within":["es.array.copy-within"],"core-js/stable/instance/ends-with":["es.string.ends-with"],"core-js/stable/instance/entries":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/stable/instance/every":["es.array.every"],"core-js/stable/instance/fill":["es.array.fill"],"core-js/stable/instance/filter":["es.array.filter"],"core-js/stable/instance/find":["es.array.find"],"core-js/stable/instance/find-index":["es.array.find-index"],"core-js/stable/instance/flags":["es.regexp.flags"],"core-js/stable/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/stable/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/stable/instance/for-each":["es.array.for-each","web.dom-collections.iterator"],"core-js/stable/instance/includes":["es.array.includes","es.string.includes"],"core-js/stable/instance/index-of":["es.array.index-of"],"core-js/stable/instance/keys":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/stable/instance/last-index-of":["es.array.last-index-of"],"core-js/stable/instance/map":["es.array.map"],"core-js/stable/instance/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/stable/instance/pad-end":["es.string.pad-end"],"core-js/stable/instance/pad-start":["es.string.pad-start"],"core-js/stable/instance/reduce":["es.array.reduce"],"core-js/stable/instance/reduce-right":["es.array.reduce-right"],"core-js/stable/instance/repeat":["es.string.repeat"],"core-js/stable/instance/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/stable/instance/reverse":["es.array.reverse"],"core-js/stable/instance/slice":["es.array.slice"],"core-js/stable/instance/some":["es.array.some"],"core-js/stable/instance/sort":["es.array.sort"],"core-js/stable/instance/splice":["es.array.splice"],"core-js/stable/instance/starts-with":["es.string.starts-with"],"core-js/stable/instance/trim":["es.string.trim"],"core-js/stable/instance/trim-end":["es.string.trim-end"],"core-js/stable/instance/trim-left":["es.string.trim-start"],"core-js/stable/instance/trim-right":["es.string.trim-end"],"core-js/stable/instance/trim-start":["es.string.trim-start"],"core-js/stable/instance/values":["es.array.iterator","es.object.to-string","web.dom-collections.iterator"],"core-js/stable/is-iterable":["es.array.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/json":["es.json.stringify","es.json.to-string-tag"],"core-js/stable/json/stringify":["es.json.stringify"],"core-js/stable/json/to-string-tag":["es.json.to-string-tag"],"core-js/stable/map":["es.array.iterator","es.map","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc"],"core-js/stable/math/acosh":["es.math.acosh"],"core-js/stable/math/asinh":["es.math.asinh"],"core-js/stable/math/atanh":["es.math.atanh"],"core-js/stable/math/cbrt":["es.math.cbrt"],"core-js/stable/math/clz32":["es.math.clz32"],"core-js/stable/math/cosh":["es.math.cosh"],"core-js/stable/math/expm1":["es.math.expm1"],"core-js/stable/math/fround":["es.math.fround"],"core-js/stable/math/hypot":["es.math.hypot"],"core-js/stable/math/imul":["es.math.imul"],"core-js/stable/math/log10":["es.math.log10"],"core-js/stable/math/log1p":["es.math.log1p"],"core-js/stable/math/log2":["es.math.log2"],"core-js/stable/math/sign":["es.math.sign"],"core-js/stable/math/sinh":["es.math.sinh"],"core-js/stable/math/tanh":["es.math.tanh"],"core-js/stable/math/to-string-tag":["es.math.to-string-tag"],"core-js/stable/math/trunc":["es.math.trunc"],"core-js/stable/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/stable/number/constructor":["es.number.constructor"],"core-js/stable/number/epsilon":["es.number.epsilon"],"core-js/stable/number/is-finite":["es.number.is-finite"],"core-js/stable/number/is-integer":["es.number.is-integer"],"core-js/stable/number/is-nan":["es.number.is-nan"],"core-js/stable/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/stable/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/stable/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/stable/number/parse-float":["es.number.parse-float"],"core-js/stable/number/parse-int":["es.number.parse-int"],"core-js/stable/number/to-exponential":["es.number.to-exponential"],"core-js/stable/number/to-fixed":["es.number.to-fixed"],"core-js/stable/number/to-precision":["es.number.to-precision"],"core-js/stable/number/virtual":["es.number.to-exponential","es.number.to-fixed","es.number.to-precision"],"core-js/stable/number/virtual/to-exponential":["es.number.to-exponential"],"core-js/stable/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/stable/number/virtual/to-precision":["es.number.to-precision"],"core-js/stable/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.reflect.to-string-tag","web.dom-collections.iterator"],"core-js/stable/object/assign":["es.object.assign"],"core-js/stable/object/create":["es.object.create"],"core-js/stable/object/define-getter":["es.object.define-getter"],"core-js/stable/object/define-properties":["es.object.define-properties"],"core-js/stable/object/define-property":["es.object.define-property"],"core-js/stable/object/define-setter":["es.object.define-setter"],"core-js/stable/object/entries":["es.object.entries"],"core-js/stable/object/freeze":["es.object.freeze"],"core-js/stable/object/from-entries":["es.array.iterator","es.object.from-entries","web.dom-collections.iterator"],"core-js/stable/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/stable/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/stable/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/stable/object/get-own-property-symbols":["es.symbol"],"core-js/stable/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/stable/object/has-own":["es.object.has-own"],"core-js/stable/object/is":["es.object.is"],"core-js/stable/object/is-extensible":["es.object.is-extensible"],"core-js/stable/object/is-frozen":["es.object.is-frozen"],"core-js/stable/object/is-sealed":["es.object.is-sealed"],"core-js/stable/object/keys":["es.object.keys"],"core-js/stable/object/lookup-getter":["es.object.lookup-getter"],"core-js/stable/object/lookup-setter":["es.object.lookup-setter"],"core-js/stable/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/stable/object/seal":["es.object.seal"],"core-js/stable/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/stable/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/stable/object/values":["es.object.values"],"core-js/stable/parse-float":["es.parse-float"],"core-js/stable/parse-int":["es.parse-int"],"core-js/stable/promise":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/promise/all-settled":["es.array.iterator","es.object.to-string","es.promise","es.promise.all-settled","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/promise/any":["es.aggregate-error","es.array.iterator","es.object.to-string","es.promise","es.promise.any","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/promise/finally":["es.object.to-string","es.promise","es.promise.finally"],"core-js/stable/queue-microtask":["web.queue-microtask"],"core-js/stable/reflect":["es.object.to-string","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag"],"core-js/stable/reflect/apply":["es.reflect.apply"],"core-js/stable/reflect/construct":["es.reflect.construct"],"core-js/stable/reflect/define-property":["es.reflect.define-property"],"core-js/stable/reflect/delete-property":["es.reflect.delete-property"],"core-js/stable/reflect/get":["es.reflect.get"],"core-js/stable/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/stable/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/stable/reflect/has":["es.reflect.has"],"core-js/stable/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/stable/reflect/own-keys":["es.reflect.own-keys"],"core-js/stable/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/stable/reflect/set":["es.reflect.set"],"core-js/stable/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/stable/reflect/to-string-tag":["es.reflect.to-string-tag"],"core-js/stable/regexp":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/stable/regexp/constructor":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.sticky"],"core-js/stable/regexp/dot-all":["es.regexp.constructor","es.regexp.dot-all","es.regexp.exec"],"core-js/stable/regexp/flags":["es.regexp.flags"],"core-js/stable/regexp/match":["es.regexp.exec","es.string.match"],"core-js/stable/regexp/replace":["es.regexp.exec","es.string.replace"],"core-js/stable/regexp/search":["es.regexp.exec","es.string.search"],"core-js/stable/regexp/split":["es.regexp.exec","es.string.split"],"core-js/stable/regexp/sticky":["es.regexp.constructor","es.regexp.exec","es.regexp.sticky"],"core-js/stable/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/stable/regexp/to-string":["es.regexp.to-string"],"core-js/stable/set":["es.array.iterator","es.object.to-string","es.set","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/set-immediate":["web.immediate"],"core-js/stable/set-interval":["web.timers"],"core-js/stable/set-timeout":["web.timers"],"core-js/stable/string":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/stable/string/anchor":["es.string.anchor"],"core-js/stable/string/at":["es.string.at-alternative"],"core-js/stable/string/big":["es.string.big"],"core-js/stable/string/blink":["es.string.blink"],"core-js/stable/string/bold":["es.string.bold"],"core-js/stable/string/code-point-at":["es.string.code-point-at"],"core-js/stable/string/ends-with":["es.string.ends-with"],"core-js/stable/string/fixed":["es.string.fixed"],"core-js/stable/string/fontcolor":["es.string.fontcolor"],"core-js/stable/string/fontsize":["es.string.fontsize"],"core-js/stable/string/from-code-point":["es.string.from-code-point"],"core-js/stable/string/includes":["es.string.includes"],"core-js/stable/string/italics":["es.string.italics"],"core-js/stable/string/iterator":["es.object.to-string","es.string.iterator"],"core-js/stable/string/link":["es.string.link"],"core-js/stable/string/match":["es.regexp.exec","es.string.match"],"core-js/stable/string/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/stable/string/pad-end":["es.string.pad-end"],"core-js/stable/string/pad-start":["es.string.pad-start"],"core-js/stable/string/raw":["es.string.raw"],"core-js/stable/string/repeat":["es.string.repeat"],"core-js/stable/string/replace":["es.regexp.exec","es.string.replace"],"core-js/stable/string/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/stable/string/search":["es.regexp.exec","es.string.search"],"core-js/stable/string/small":["es.string.small"],"core-js/stable/string/split":["es.regexp.exec","es.string.split"],"core-js/stable/string/starts-with":["es.string.starts-with"],"core-js/stable/string/strike":["es.string.strike"],"core-js/stable/string/sub":["es.string.sub"],"core-js/stable/string/substr":["es.string.substr"],"core-js/stable/string/sup":["es.string.sup"],"core-js/stable/string/trim":["es.string.trim"],"core-js/stable/string/trim-end":["es.string.trim-end"],"core-js/stable/string/trim-left":["es.string.trim-start"],"core-js/stable/string/trim-right":["es.string.trim-end"],"core-js/stable/string/trim-start":["es.string.trim-start"],"core-js/stable/string/virtual":["es.object.to-string","es.regexp.exec","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/stable/string/virtual/anchor":["es.string.anchor"],"core-js/stable/string/virtual/at":["es.string.at-alternative"],"core-js/stable/string/virtual/big":["es.string.big"],"core-js/stable/string/virtual/blink":["es.string.blink"],"core-js/stable/string/virtual/bold":["es.string.bold"],"core-js/stable/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/stable/string/virtual/ends-with":["es.string.ends-with"],"core-js/stable/string/virtual/fixed":["es.string.fixed"],"core-js/stable/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/stable/string/virtual/fontsize":["es.string.fontsize"],"core-js/stable/string/virtual/includes":["es.string.includes"],"core-js/stable/string/virtual/italics":["es.string.italics"],"core-js/stable/string/virtual/iterator":["es.object.to-string","es.string.iterator"],"core-js/stable/string/virtual/link":["es.string.link"],"core-js/stable/string/virtual/match-all":["es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/stable/string/virtual/pad-end":["es.string.pad-end"],"core-js/stable/string/virtual/pad-start":["es.string.pad-start"],"core-js/stable/string/virtual/repeat":["es.string.repeat"],"core-js/stable/string/virtual/replace-all":["es.regexp.exec","es.string.replace","es.string.replace-all"],"core-js/stable/string/virtual/small":["es.string.small"],"core-js/stable/string/virtual/starts-with":["es.string.starts-with"],"core-js/stable/string/virtual/strike":["es.string.strike"],"core-js/stable/string/virtual/sub":["es.string.sub"],"core-js/stable/string/virtual/substr":["es.string.substr"],"core-js/stable/string/virtual/sup":["es.string.sup"],"core-js/stable/string/virtual/trim":["es.string.trim"],"core-js/stable/string/virtual/trim-end":["es.string.trim-end"],"core-js/stable/string/virtual/trim-left":["es.string.trim-start"],"core-js/stable/string/virtual/trim-right":["es.string.trim-end"],"core-js/stable/string/virtual/trim-start":["es.string.trim-start"],"core-js/stable/structured-clone":["es.error.to-string","es.array.iterator","es.map","es.object.keys","es.object.to-string","es.set","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.structured-clone"],"core-js/stable/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag","web.dom-collections.iterator"],"core-js/stable/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/stable/symbol/description":["es.symbol.description"],"core-js/stable/symbol/for":["es.symbol"],"core-js/stable/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/stable/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/stable/symbol/iterator":["es.symbol.iterator","es.array.iterator","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/symbol/key-for":["es.symbol"],"core-js/stable/symbol/match":["es.symbol.match","es.regexp.exec","es.string.match"],"core-js/stable/symbol/match-all":["es.symbol.match-all","es.object.to-string","es.regexp.exec","es.string.match-all"],"core-js/stable/symbol/replace":["es.symbol.replace","es.regexp.exec","es.string.replace"],"core-js/stable/symbol/search":["es.symbol.search","es.regexp.exec","es.string.search"],"core-js/stable/symbol/species":["es.symbol.species"],"core-js/stable/symbol/split":["es.symbol.split","es.regexp.exec","es.string.split"],"core-js/stable/symbol/to-primitive":["es.symbol.to-primitive","es.date.to-primitive"],"core-js/stable/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","es.reflect.to-string-tag"],"core-js/stable/symbol/unscopables":["es.symbol.unscopables"],"core-js/stable/typed-array":["es.object.to-string","es.string.iterator","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/at":["es.typed-array.at"],"core-js/stable/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/stable/typed-array/entries":["es.object.to-string","es.typed-array.iterator"],"core-js/stable/typed-array/every":["es.typed-array.every"],"core-js/stable/typed-array/fill":["es.typed-array.fill"],"core-js/stable/typed-array/filter":["es.typed-array.filter"],"core-js/stable/typed-array/find":["es.typed-array.find"],"core-js/stable/typed-array/find-index":["es.typed-array.find-index"],"core-js/stable/typed-array/float32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.float32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/float64-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.float64-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/for-each":["es.typed-array.for-each"],"core-js/stable/typed-array/from":["es.typed-array.from"],"core-js/stable/typed-array/includes":["es.typed-array.includes"],"core-js/stable/typed-array/index-of":["es.typed-array.index-of"],"core-js/stable/typed-array/int16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/int32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/int8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.int8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/iterator":["es.object.to-string","es.typed-array.iterator"],"core-js/stable/typed-array/join":["es.typed-array.join"],"core-js/stable/typed-array/keys":["es.object.to-string","es.typed-array.iterator"],"core-js/stable/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/stable/typed-array/map":["es.typed-array.map"],"core-js/stable/typed-array/methods":["es.object.to-string","es.string.iterator","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/of":["es.typed-array.of"],"core-js/stable/typed-array/reduce":["es.typed-array.reduce"],"core-js/stable/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/stable/typed-array/reverse":["es.typed-array.reverse"],"core-js/stable/typed-array/set":["es.typed-array.set"],"core-js/stable/typed-array/slice":["es.typed-array.slice"],"core-js/stable/typed-array/some":["es.typed-array.some"],"core-js/stable/typed-array/sort":["es.typed-array.sort"],"core-js/stable/typed-array/subarray":["es.typed-array.subarray"],"core-js/stable/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/stable/typed-array/to-string":["es.typed-array.to-string"],"core-js/stable/typed-array/uint16-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint16-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/uint32-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/uint8-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint8-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/uint8-clamped-array":["es.array-buffer.constructor","es.array-buffer.slice","es.object.to-string","es.string.iterator","es.typed-array.uint8-clamped-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/values":["es.object.to-string","es.typed-array.iterator"],"core-js/stable/unescape":["es.unescape"],"core-js/stable/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/stable/url-search-params":["web.dom-collections.iterator","web.url-search-params"],"core-js/stable/url/to-json":["web.url.to-json"],"core-js/stable/weak-map":["es.array.iterator","es.object.to-string","es.weak-map","web.dom-collections.iterator"],"core-js/stable/weak-set":["es.array.iterator","es.object.to-string","es.weak-set","web.dom-collections.iterator"],"core-js/stage":["es.map","es.string.at-alternative","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/stage/0":["es.map","es.string.at-alternative","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/stage/1":["es.map","es.string.at-alternative","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of"],"core-js/stage/2":["es.string.at-alternative","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.emplace","esnext.object.has-own","esnext.promise.all-settled","esnext.promise.any","esnext.set.difference","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.symmetric-difference","esnext.set.union","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.metadata","esnext.typed-array.at","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with","esnext.weak-map.emplace"],"core-js/stage/3":["es.string.at-alternative","esnext.aggregate-error","esnext.array.at","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with","esnext.global-this","esnext.object.has-own","esnext.promise.all-settled","esnext.promise.any","esnext.string.match-all","esnext.string.replace-all","esnext.typed-array.at","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with"],"core-js/stage/4":["es.string.at-alternative","esnext.aggregate-error","esnext.array.at","esnext.global-this","esnext.object.has-own","esnext.promise.all-settled","esnext.promise.any","esnext.string.match-all","esnext.string.replace-all","esnext.typed-array.at"],"core-js/stage/pre":["es.map","es.string.at-alternative","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/web":["web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/web/dom-collections":["web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/web/dom-exception":["es.error.to-string","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag"],"core-js/web/immediate":["web.immediate"],"core-js/web/queue-microtask":["web.queue-microtask"],"core-js/web/structured-clone":["es.array.iterator","es.map","es.object.to-string","es.set","web.structured-clone"],"core-js/web/timers":["web.timers"],"core-js/web/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/web/url-search-params":["web.url-search-params"]}');
    },
    2878: module => {
      "use strict";
      module.exports = JSON.parse('{"3.0":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.last-index","esnext.array.last-item","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"],"3.1":["es.string.match-all","es.symbol.match-all","esnext.symbol.replace-all"],"3.2":["es.promise.all-settled","esnext.array.is-template-object","esnext.map.update-or-insert","esnext.symbol.async-dispose"],"3.3":["es.global-this","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.upsert","esnext.weak-map.upsert"],"3.4":["es.json.stringify"],"3.5":["esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values"],"3.6":["es.regexp.sticky","es.regexp.test"],"3.7":["es.aggregate-error","es.promise.any","es.reflect.to-string-tag","es.string.replace-all","esnext.map.emplace","esnext.weak-map.emplace"],"3.8":["esnext.array.at","esnext.array.filter-out","esnext.array.unique-by","esnext.bigint.range","esnext.number.range","esnext.typed-array.at","esnext.typed-array.filter-out"],"3.9":["esnext.array.find-last","esnext.array.find-last-index","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.unique-by"],"3.11":["esnext.object.has-own"],"3.12":["esnext.symbol.matcher","esnext.symbol.metadata"],"3.15":["es.date.get-year","es.date.set-year","es.date.to-gmt-string","es.escape","es.regexp.dot-all","es.string.substr","es.unescape"],"3.16":["esnext.array.filter-reject","esnext.array.group-by","esnext.typed-array.filter-reject","esnext.typed-array.group-by"],"3.17":["es.array.at","es.object.has-own","es.string.at-alternative","es.typed-array.at"],"3.18":["esnext.array.from-async","esnext.typed-array.from-async"],"3.20":["es.error.cause","es.error.to-string","es.aggregate-error.cause","es.number.to-exponential","esnext.array.group-by-to-map","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.with","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.iterator.to-async","esnext.string.cooked","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.with","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.structured-clone"],"3.21":["web.atob","web.btoa"]}');
    },
    9343: module => {
      "use strict";
      module.exports = JSON.parse('["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.error.cause","es.error.to-string","es.aggregate-error","es.aggregate-error.cause","es.array.at","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.get-year","es.date.now","es.date.set-year","es.date.to-gmt-string","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.escape","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-exponential","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.has-own","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.any","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.reflect.to-string-tag","es.regexp.constructor","es.regexp.dot-all","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.at-alternative","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.replace-all","es.string.search","es.string.split","es.string.starts-with","es.string.substr","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.at","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.unescape","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.from-async","esnext.array.at","esnext.array.filter-out","esnext.array.filter-reject","esnext.array.find-last","esnext.array.find-last-index","esnext.array.group-by","esnext.array.group-by-to-map","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.array.to-reversed","esnext.array.to-sorted","esnext.array.to-spliced","esnext.array.unique-by","esnext.array.with","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.bigint.range","esnext.composite-key","esnext.composite-symbol","esnext.function.is-callable","esnext.function.is-constructor","esnext.function.un-this","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.iterator.to-async","esnext.map.delete-all","esnext.map.emplace","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.number.range","esnext.object.has-own","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.cooked","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.matcher","esnext.symbol.metadata","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.typed-array.from-async","esnext.typed-array.at","esnext.typed-array.filter-out","esnext.typed-array.filter-reject","esnext.typed-array.find-last","esnext.typed-array.find-last-index","esnext.typed-array.group-by","esnext.typed-array.to-reversed","esnext.typed-array.to-sorted","esnext.typed-array.to-spliced","esnext.typed-array.unique-by","esnext.typed-array.with","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.emplace","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.atob","web.btoa","web.dom-collections.for-each","web.dom-collections.iterator","web.dom-exception.constructor","web.dom-exception.stack","web.dom-exception.to-string-tag","web.immediate","web.queue-microtask","web.structured-clone","web.timers","web.url","web.url.to-json","web.url-search-params"]');
    },
    8487: module => {
      "use strict";
      module.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
    },
    6151: module => {
      "use strict";
      module.exports = JSON.parse('{"assert":true,"node:assert":[">= 14.18 && < 15",">= 16"],"assert/strict":">= 15","node:assert/strict":">= 16","async_hooks":">= 8","node:async_hooks":[">= 14.18 && < 15",">= 16"],"buffer_ieee754":">= 0.5 && < 0.9.7","buffer":true,"node:buffer":[">= 14.18 && < 15",">= 16"],"child_process":true,"node:child_process":[">= 14.18 && < 15",">= 16"],"cluster":">= 0.5","node:cluster":[">= 14.18 && < 15",">= 16"],"console":true,"node:console":[">= 14.18 && < 15",">= 16"],"constants":true,"node:constants":[">= 14.18 && < 15",">= 16"],"crypto":true,"node:crypto":[">= 14.18 && < 15",">= 16"],"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"node:dgram":[">= 14.18 && < 15",">= 16"],"diagnostics_channel":[">= 14.17 && < 15",">= 15.1"],"node:diagnostics_channel":[">= 14.18 && < 15",">= 16"],"dns":true,"node:dns":[">= 14.18 && < 15",">= 16"],"dns/promises":">= 15","node:dns/promises":">= 16","domain":">= 0.7.12","node:domain":[">= 14.18 && < 15",">= 16"],"events":true,"node:events":[">= 14.18 && < 15",">= 16"],"freelist":"< 6","fs":true,"node:fs":[">= 14.18 && < 15",">= 16"],"fs/promises":[">= 10 && < 10.1",">= 14"],"node:fs/promises":[">= 14.18 && < 15",">= 16"],"_http_agent":">= 0.11.1","node:_http_agent":[">= 14.18 && < 15",">= 16"],"_http_client":">= 0.11.1","node:_http_client":[">= 14.18 && < 15",">= 16"],"_http_common":">= 0.11.1","node:_http_common":[">= 14.18 && < 15",">= 16"],"_http_incoming":">= 0.11.1","node:_http_incoming":[">= 14.18 && < 15",">= 16"],"_http_outgoing":">= 0.11.1","node:_http_outgoing":[">= 14.18 && < 15",">= 16"],"_http_server":">= 0.11.1","node:_http_server":[">= 14.18 && < 15",">= 16"],"http":true,"node:http":[">= 14.18 && < 15",">= 16"],"http2":">= 8.8","node:http2":[">= 14.18 && < 15",">= 16"],"https":true,"node:https":[">= 14.18 && < 15",">= 16"],"inspector":">= 8","node:inspector":[">= 14.18 && < 15",">= 16"],"_linklist":"< 8","module":true,"node:module":[">= 14.18 && < 15",">= 16"],"net":true,"node:net":[">= 14.18 && < 15",">= 16"],"node-inspect/lib/_inspect":">= 7.6 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6 && < 12","os":true,"node:os":[">= 14.18 && < 15",">= 16"],"path":true,"node:path":[">= 14.18 && < 15",">= 16"],"path/posix":">= 15.3","node:path/posix":">= 16","path/win32":">= 15.3","node:path/win32":">= 16","perf_hooks":">= 8.5","node:perf_hooks":[">= 14.18 && < 15",">= 16"],"process":">= 1","node:process":[">= 14.18 && < 15",">= 16"],"punycode":">= 0.5","node:punycode":[">= 14.18 && < 15",">= 16"],"querystring":true,"node:querystring":[">= 14.18 && < 15",">= 16"],"readline":true,"node:readline":[">= 14.18 && < 15",">= 16"],"readline/promises":">= 17","node:readline/promises":">= 17","repl":true,"node:repl":[">= 14.18 && < 15",">= 16"],"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","node:_stream_duplex":[">= 14.18 && < 15",">= 16"],"_stream_transform":">= 0.9.4","node:_stream_transform":[">= 14.18 && < 15",">= 16"],"_stream_wrap":">= 1.4.1","node:_stream_wrap":[">= 14.18 && < 15",">= 16"],"_stream_passthrough":">= 0.9.4","node:_stream_passthrough":[">= 14.18 && < 15",">= 16"],"_stream_readable":">= 0.9.4","node:_stream_readable":[">= 14.18 && < 15",">= 16"],"_stream_writable":">= 0.9.4","node:_stream_writable":[">= 14.18 && < 15",">= 16"],"stream":true,"node:stream":[">= 14.18 && < 15",">= 16"],"stream/consumers":">= 16.7","node:stream/consumers":">= 16.7","stream/promises":">= 15","node:stream/promises":">= 16","stream/web":">= 16.5","node:stream/web":">= 16.5","string_decoder":true,"node:string_decoder":[">= 14.18 && < 15",">= 16"],"sys":[">= 0.4 && < 0.7",">= 0.8"],"node:sys":[">= 14.18 && < 15",">= 16"],"node:test":">= 18","timers":true,"node:timers":[">= 14.18 && < 15",">= 16"],"timers/promises":">= 15","node:timers/promises":">= 16","_tls_common":">= 0.11.13","node:_tls_common":[">= 14.18 && < 15",">= 16"],"_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","node:_tls_wrap":[">= 14.18 && < 15",">= 16"],"tls":true,"node:tls":[">= 14.18 && < 15",">= 16"],"trace_events":">= 10","node:trace_events":[">= 14.18 && < 15",">= 16"],"tty":true,"node:tty":[">= 14.18 && < 15",">= 16"],"url":true,"node:url":[">= 14.18 && < 15",">= 16"],"util":true,"node:util":[">= 14.18 && < 15",">= 16"],"util/types":">= 15.3","node:util/types":">= 16","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/consarray":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/csvparser":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/logreader":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/profile_view":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8/tools/splaytree":[">= 4.4 && < 5",">= 5.2 && < 12"],"v8":">= 1","node:v8":[">= 14.18 && < 15",">= 16"],"vm":true,"node:vm":[">= 14.18 && < 15",">= 16"],"wasi":">= 13.4 && < 13.5","worker_threads":">= 11.7","node:worker_threads":[">= 14.18 && < 15",">= 16"],"zlib":">= 0.5","node:zlib":[">= 14.18 && < 15",">= 16"]}');
    },
    4503: module => {
      "use strict";
      module.exports = JSON.parse('{"assert":true,"assert/strict":">= 15","async_hooks":">= 8","buffer_ieee754":"< 0.9.7","buffer":true,"child_process":true,"cluster":true,"console":true,"constants":true,"crypto":true,"_debug_agent":">= 1 && < 8","_debugger":"< 8","dgram":true,"diagnostics_channel":">= 15.1","dns":true,"dns/promises":">= 15","domain":">= 0.7.12","events":true,"freelist":"< 6","fs":true,"fs/promises":[">= 10 && < 10.1",">= 14"],"_http_agent":">= 0.11.1","_http_client":">= 0.11.1","_http_common":">= 0.11.1","_http_incoming":">= 0.11.1","_http_outgoing":">= 0.11.1","_http_server":">= 0.11.1","http":true,"http2":">= 8.8","https":true,"inspector":">= 8.0.0","_linklist":"< 8","module":true,"net":true,"node-inspect/lib/_inspect":">= 7.6.0 && < 12","node-inspect/lib/internal/inspect_client":">= 7.6.0 && < 12","node-inspect/lib/internal/inspect_repl":">= 7.6.0 && < 12","os":true,"path":true,"path/posix":">= 15.3","path/win32":">= 15.3","perf_hooks":">= 8.5","process":">= 1","punycode":true,"querystring":true,"readline":true,"repl":true,"smalloc":">= 0.11.5 && < 3","_stream_duplex":">= 0.9.4","_stream_transform":">= 0.9.4","_stream_wrap":">= 1.4.1","_stream_passthrough":">= 0.9.4","_stream_readable":">= 0.9.4","_stream_writable":">= 0.9.4","stream":true,"stream/promises":">= 15","string_decoder":true,"sys":[">= 0.6 && < 0.7",">= 0.8"],"timers":true,"timers/promises":">= 15","_tls_common":">= 0.11.13","_tls_legacy":">= 0.11.3 && < 10","_tls_wrap":">= 0.11.3","tls":true,"trace_events":">= 10","tty":true,"url":true,"util":true,"util/types":">= 15.3","v8/tools/arguments":">= 10 && < 12","v8/tools/codemap":[">= 4.4.0 && < 5",">= 5.2.0 && < 12"],"v8/tools/consarray":[">= 4.4.0 && < 5",">= 5.2.0 && < 12"],"v8/tools/csvparser":[">= 4.4.0 && < 5",">= 5.2.0 && < 12"],"v8/tools/logreader":[">= 4.4.0 && < 5",">= 5.2.0 && < 12"],"v8/tools/profile_view":[">= 4.4.0 && < 5",">= 5.2.0 && < 12"],"v8/tools/splaytree":[">= 4.4.0 && < 5",">= 5.2.0 && < 12"],"v8":">= 1","vm":true,"wasi":">= 13.4 && < 13.5","worker_threads":">= 11.7","zlib":true}');
    }
  }, __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
      exports: {}
    };
    return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
    module.exports;
  }
  var __webpack_exports__ = {};
  (() => {
    "use strict";
    var exports = __webpack_exports__;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.getPolyfillPlugins = exports.getModulesPluginNames = exports.default = void 0, 
    exports.isPluginRequired = function(targets, support) {
      return (0, _helperCompilationTargets.isRequired)("fake-name", targets, {
        compatData: {
          "fake-name": support
        }
      });
    }, exports.transformIncludesAndExcludes = void 0;
    var _semver = __webpack_require__(6625), _debug = __webpack_require__(2157), _getOptionSpecificExcludes = __webpack_require__(6015), _filterItems = __webpack_require__(8502), _moduleTransformations = __webpack_require__(1049), _normalizeOptions = __webpack_require__(3668), _shippedProposals = __webpack_require__(9279), _pluginsCompatData = __webpack_require__(4600), _overlappingPlugins = __webpack_require__(2624), _regenerator = __webpack_require__(3893), _babelPolyfill = __webpack_require__(9462), _babelPluginPolyfillCorejs = __webpack_require__(1815), _babelPluginPolyfillCorejs2 = __webpack_require__(1515), _babelPluginPolyfillRegenerator = __webpack_require__(205), _helperCompilationTargets = __webpack_require__(4077), _availablePlugins = __webpack_require__(2751), _helperPluginUtils = __webpack_require__(4982);
    const pluginCoreJS2 = _babelPluginPolyfillCorejs.default || _babelPluginPolyfillCorejs, pluginCoreJS3 = _babelPluginPolyfillCorejs2.default || _babelPluginPolyfillCorejs2, pluginRegenerator = _babelPluginPolyfillRegenerator.default || _babelPluginPolyfillRegenerator;
    function filterStageFromList(list, stageList) {
      return Object.keys(list).reduce(((result, item) => (stageList.has(item) || (result[item] = list[item]), 
      result)), {});
    }
    const pluginLists = {
      withProposals: {
        withoutBugfixes: _pluginsCompatData.plugins,
        withBugfixes: Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes)
      },
      withoutProposals: {
        withoutBugfixes: filterStageFromList(_pluginsCompatData.plugins, _shippedProposals.proposalPlugins),
        withBugfixes: filterStageFromList(Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes), _shippedProposals.proposalPlugins)
      }
    };
    const getPlugin = pluginName => {
      const plugin = _availablePlugins.default[pluginName]();
      if (!plugin) throw new Error(`Could not find plugin "${pluginName}". Ensure there is an entry in ./available-plugins.js for it.`);
      return plugin;
    }, transformIncludesAndExcludes = opts => opts.reduce(((result, opt) => (result[opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins"].add(opt), 
    result)), {
      all: opts,
      plugins: new Set,
      builtIns: new Set
    });
    exports.transformIncludesAndExcludes = transformIncludesAndExcludes;
    const getModulesPluginNames = ({modules, transformations, shouldTransformESM, shouldTransformDynamicImport, shouldTransformExportNamespaceFrom, shouldParseTopLevelAwait}) => {
      const modulesPluginNames = [];
      return !1 !== modules && transformations[modules] ? (shouldTransformESM && modulesPluginNames.push(transformations[modules]), 
      shouldTransformDynamicImport && shouldTransformESM && "umd" !== modules ? modulesPluginNames.push("proposal-dynamic-import") : (shouldTransformDynamicImport && console.warn("Dynamic import can only be supported when transforming ES modules to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled."), 
      modulesPluginNames.push("syntax-dynamic-import"))) : modulesPluginNames.push("syntax-dynamic-import"), 
      shouldTransformExportNamespaceFrom ? modulesPluginNames.push("proposal-export-namespace-from") : modulesPluginNames.push("syntax-export-namespace-from"), 
      shouldParseTopLevelAwait && modulesPluginNames.push("syntax-top-level-await"), modulesPluginNames;
    };
    exports.getModulesPluginNames = getModulesPluginNames;
    const getPolyfillPlugins = ({useBuiltIns, corejs, polyfillTargets, include, exclude, proposals, shippedProposals, regenerator, debug}) => {
      const polyfillPlugins = [];
      if ("usage" === useBuiltIns || "entry" === useBuiltIns) {
        const pluginOptions = {
          method: `${useBuiltIns}-global`,
          version: corejs ? corejs.toString() : void 0,
          targets: polyfillTargets,
          include,
          exclude,
          proposals,
          shippedProposals,
          debug
        };
        corejs && ("usage" === useBuiltIns ? (2 === corejs.major ? polyfillPlugins.push([ pluginCoreJS2, pluginOptions ], [ _babelPolyfill.default, {
          usage: !0
        } ]) : polyfillPlugins.push([ pluginCoreJS3, pluginOptions ], [ _babelPolyfill.default, {
          usage: !0,
          deprecated: !0
        } ]), regenerator && polyfillPlugins.push([ pluginRegenerator, {
          method: "usage-global",
          debug
        } ])) : 2 === corejs.major ? polyfillPlugins.push([ _babelPolyfill.default, {
          regenerator
        } ], [ pluginCoreJS2, pluginOptions ]) : (polyfillPlugins.push([ pluginCoreJS3, pluginOptions ], [ _babelPolyfill.default, {
          deprecated: !0
        } ]), regenerator || polyfillPlugins.push([ _regenerator.default, pluginOptions ])));
      }
      return polyfillPlugins;
    };
    function supportsStaticESM(caller) {
      return !(null == caller || !caller.supportsStaticESM);
    }
    function supportsDynamicImport(caller) {
      return !(null == caller || !caller.supportsDynamicImport);
    }
    function supportsExportNamespaceFrom(caller) {
      return !(null == caller || !caller.supportsExportNamespaceFrom);
    }
    function supportsTopLevelAwait(caller) {
      return !(null == caller || !caller.supportsTopLevelAwait);
    }
    exports.getPolyfillPlugins = getPolyfillPlugins;
    var _default = (0, _helperPluginUtils.declare)(((api, opts) => {
      api.assertVersion(7);
      const babelTargets = api.targets(), {bugfixes, configPath, debug, exclude: optionsExclude, forceAllTransforms, ignoreBrowserslistConfig, include: optionsInclude, loose, modules, shippedProposals, spec, targets: optionsTargets, useBuiltIns, corejs: {version: corejs, proposals}, browserslistEnv} = (0, 
      _normalizeOptions.default)(opts);
      let targets = babelTargets;
      if ((0, _semver.lt)(api.version, "7.13.0") || opts.targets || opts.configPath || opts.browserslistEnv || opts.ignoreBrowserslistConfig) {
        var hasUglifyTarget = !1;
        null != optionsTargets && optionsTargets.uglify && (hasUglifyTarget = !0, delete optionsTargets.uglify, 
        console.warn("\nThe uglify target has been deprecated. Set the top level\noption `forceAllTransforms: true` instead.\n")), 
        targets = function(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv) {
          return null != optionsTargets && optionsTargets.esmodules && optionsTargets.browsers && console.warn(`\n@babel/preset-env: esmodules and browsers targets have been specified together.\n\`browsers\` target, \`${optionsTargets.browsers.toString()}\` will be ignored.\n`), 
          (0, _helperCompilationTargets.default)(optionsTargets, {
            ignoreBrowserslistConfig,
            configPath,
            browserslistEnv
          });
        }(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv);
      }
      const transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets, include = transformIncludesAndExcludes(optionsInclude), exclude = transformIncludesAndExcludes(optionsExclude), compatData = function(proposals, bugfixes) {
        return proposals ? bugfixes ? pluginLists.withProposals.withBugfixes : pluginLists.withProposals.withoutBugfixes : bugfixes ? pluginLists.withoutProposals.withBugfixes : pluginLists.withoutProposals.withoutBugfixes;
      }(shippedProposals, bugfixes), shouldSkipExportNamespaceFrom = "auto" === modules && (null == api.caller ? void 0 : api.caller(supportsExportNamespaceFrom)) || !1 === modules && !(0, 
      _helperCompilationTargets.isRequired)("proposal-export-namespace-from", transformTargets, {
        compatData,
        includes: include.plugins,
        excludes: exclude.plugins
      }), modulesPluginNames = getModulesPluginNames({
        modules,
        transformations: _moduleTransformations.default,
        shouldTransformESM: "auto" !== modules || !(null != api.caller && api.caller(supportsStaticESM)),
        shouldTransformDynamicImport: "auto" !== modules || !(null != api.caller && api.caller(supportsDynamicImport)),
        shouldTransformExportNamespaceFrom: !shouldSkipExportNamespaceFrom,
        shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
      }), pluginNames = (0, _helperCompilationTargets.filterItems)(compatData, include.plugins, exclude.plugins, transformTargets, modulesPluginNames, (0, 
      _getOptionSpecificExcludes.default)({
        loose
      }), _shippedProposals.pluginSyntaxMap);
      (0, _filterItems.removeUnnecessaryItems)(pluginNames, _overlappingPlugins), (0, 
      _filterItems.removeUnsupportedItems)(pluginNames, api.version);
      const polyfillPlugins = getPolyfillPlugins({
        useBuiltIns,
        corejs,
        polyfillTargets: targets,
        include: include.builtIns,
        exclude: exclude.builtIns,
        proposals,
        shippedProposals,
        regenerator: pluginNames.has("transform-regenerator"),
        debug
      }), pluginUseBuiltIns = !1 !== useBuiltIns, plugins = Array.from(pluginNames).map((pluginName => "proposal-class-properties" === pluginName || "proposal-private-methods" === pluginName || "proposal-private-property-in-object" === pluginName ? [ getPlugin(pluginName), {
        loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
      } ] : [ getPlugin(pluginName), {
        spec,
        loose,
        useBuiltIns: pluginUseBuiltIns
      } ])).concat(polyfillPlugins);
      return debug && (console.log("@babel/preset-env: `DEBUG` option"), console.log("\nUsing targets:"), 
      console.log(JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2)), 
      console.log(`\nUsing modules transform: ${modules.toString()}`), console.log("\nUsing plugins:"), 
      pluginNames.forEach((pluginName => {
        (0, _debug.logPlugin)(pluginName, targets, compatData);
      })), useBuiltIns || console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.")), 
      {
        plugins
      };
    }));
    exports.default = _default;
  })();
  var __webpack_export_target__ = exports;
  for (var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
  __webpack_exports__.__esModule && Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: !0
  });
})();