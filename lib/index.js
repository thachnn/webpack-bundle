(() => {
var __webpack_modules__ = {
99986: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
Object.defineProperty(exports, "__esModule", {
value: !0
}), exports.importAssertions = function(Parser) {
const acorn = Parser.acorn || _acorn, {tokTypes: tt, TokenType} = acorn;
return class extends Parser {
constructor(...args) {
super(...args), this.assertToken = new TokenType("assert");
}
_codeAt(i) {
return this.input.charCodeAt(i);
}
_eat(t) {
this.type !== t && this.unexpected(), this.next();
}
readToken(code) {
let i = 0;
for (;i < "assert".length; i++) if (this._codeAt(this.pos + i) !== "assert".charCodeAt(i)) return super.readToken(code);
for (;this._codeAt(this.pos + i) !== leftCurlyBrace; i++) if (this._codeAt(this.pos + i) !== space) return super.readToken(code);
return "{" === this.type.label ? super.readToken(code) : (this.pos += "assert".length, 
this.finishToken(this.assertToken));
}
parseDynamicImport(node) {
if (this.next(), node.source = this.parseMaybeAssign(), this.eat(tt.comma)) {
const obj = this.parseObj(!1);
node.arguments = [ obj ];
}
return this._eat(tt.parenR), this.finishNode(node, "ImportExpression");
}
parseExport(node, exports) {
if (this.next(), this.eat(tt.star)) {
if (this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (node.exported = this.parseIdent(!0), 
this.checkExport(exports, node.exported.name, this.lastTokStart)) : node.exported = null), 
this.expectContextual("from"), this.type !== tt.string && this.unexpected(), node.source = this.parseExprAtom(), 
this.type === this.assertToken) {
this.next();
const assertions = this.parseImportAssertions();
assertions && (node.assertions = assertions);
}
return this.semicolon(), this.finishNode(node, "ExportAllDeclaration");
}
if (this.eat(tt._default)) {
var isAsync;
if (this.checkExport(exports, "default", this.lastTokStart), this.type === tt._function || (isAsync = this.isAsyncFunction())) {
var fNode = this.startNode();
this.next(), isAsync && this.next(), node.declaration = this.parseFunction(fNode, 5, !1, isAsync);
} else if (this.type === tt._class) {
var cNode = this.startNode();
node.declaration = this.parseClass(cNode, "nullableID");
} else node.declaration = this.parseMaybeAssign(), this.semicolon();
return this.finishNode(node, "ExportDefaultDeclaration");
}
if (this.shouldParseExportStatement()) node.declaration = this.parseStatement(null), 
"VariableDeclaration" === node.declaration.type ? this.checkVariableExport(exports, node.declaration.declarations) : this.checkExport(exports, node.declaration.id.name, node.declaration.id.start), 
node.specifiers = [], node.source = null; else {
if (node.declaration = null, node.specifiers = this.parseExportSpecifiers(exports), 
this.eatContextual("from")) {
if (this.type !== tt.string && this.unexpected(), node.source = this.parseExprAtom(), 
this.type === this.assertToken) {
this.next();
const assertions = this.parseImportAssertions();
assertions && (node.assertions = assertions);
}
} else {
for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
var spec = list[i];
this.checkUnreserved(spec.local), this.checkLocalExport(spec.local);
}
node.source = null;
}
this.semicolon();
}
return this.finishNode(node, "ExportNamedDeclaration");
}
parseImport(node) {
if (this.next(), this.type === tt.string ? (node.specifiers = [], node.source = this.parseExprAtom()) : (node.specifiers = this.parseImportSpecifiers(), 
this.expectContextual("from"), node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()), 
this.type === this.assertToken) {
this.next();
const assertions = this.parseImportAssertions();
assertions && (node.assertions = assertions);
}
return this.semicolon(), this.finishNode(node, "ImportDeclaration");
}
parseImportAssertions() {
this._eat(tt.braceL);
const attrs = this.parseAssertEntries();
return this._eat(tt.braceR), attrs;
}
parseAssertEntries() {
const attrs = [], attrNames = new Set;
do {
if (this.type === tt.braceR) break;
const node = this.startNode();
let assertionKeyNode;
assertionKeyNode = this.type === tt.string ? this.parseLiteral(this.value) : this.parseIdent(!0), 
this.next(), node.key = assertionKeyNode, attrNames.has(node.key.name) && this.raise(this.pos, "Duplicated key in assertions"), 
attrNames.add(node.key.name), this.type !== tt.string && this.raise(this.pos, "Only string is supported as an assertion value"), 
node.value = this.parseLiteral(this.value), attrs.push(this.finishNode(node, "ImportAttribute"));
} while (this.eat(tt.comma));
return attrs;
}
};
};
var _acorn = function(obj, nodeInterop) {
if (!nodeInterop && obj && obj.__esModule) return obj;
if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
default: obj
};
var cache = _getRequireWildcardCache(nodeInterop);
if (cache && cache.has(obj)) return cache.get(obj);
var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
}
newObj.default = obj, cache && cache.set(obj, newObj);
return newObj;
}(__webpack_require__(1234));
function _getRequireWildcardCache(nodeInterop) {
if ("function" != typeof WeakMap) return null;
var cacheBabelInterop = new WeakMap, cacheNodeInterop = new WeakMap;
return (_getRequireWildcardCache = function(nodeInterop) {
return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
})(nodeInterop);
}
const leftCurlyBrace = "{".charCodeAt(0), space = " ".charCodeAt(0);
},
1234: function(__unused_webpack_module, exports) {
!function(exports) {
"use strict";
var astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239 ], astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938 ], nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", reservedWords = {
3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
5: "class enum extends super const export import",
6: "enum",
strict: "implements interface let package private protected public static yield",
strictBind: "eval arguments"
}, ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", keywords$1 = {
5: ecma5AndLessKeywords,
"5module": ecma5AndLessKeywords + " export import",
6: ecma5AndLessKeywords + " const class extends export import super"
}, keywordRelationalOperator = /^in(stanceof)?$/, nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set) {
for (var pos = 65536, i = 0; i < set.length; i += 2) {
if ((pos += set[i]) > code) return !1;
if ((pos += set[i + 1]) >= code) return !0;
}
}
function isIdentifierStart(code, astral) {
return code < 65 ? 36 === code : code < 91 || (code < 97 ? 95 === code : code < 123 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : !1 !== astral && isInAstralSet(code, astralIdentifierStartCodes)));
}
function isIdentifierChar(code, astral) {
return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code < 91 || (code < 97 ? 95 === code : code < 123 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : !1 !== astral && (isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)))));
}
var TokenType = function(label, conf) {
void 0 === conf && (conf = {}), this.label = label, this.keyword = conf.keyword, 
this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.isLoop = !!conf.isLoop, 
this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, 
this.binop = conf.binop || null, this.updateContext = null;
};
function binop(name, prec) {
return new TokenType(name, {
beforeExpr: !0,
binop: prec
});
}
var beforeExpr = {
beforeExpr: !0
}, startsExpr = {
startsExpr: !0
}, keywords = {};
function kw(name, options) {
return void 0 === options && (options = {}), options.keyword = name, keywords[name] = new TokenType(name, options);
}
var types$1 = {
num: new TokenType("num", startsExpr),
regexp: new TokenType("regexp", startsExpr),
string: new TokenType("string", startsExpr),
name: new TokenType("name", startsExpr),
privateId: new TokenType("privateId", startsExpr),
eof: new TokenType("eof"),
bracketL: new TokenType("[", {
beforeExpr: !0,
startsExpr: !0
}),
bracketR: new TokenType("]"),
braceL: new TokenType("{", {
beforeExpr: !0,
startsExpr: !0
}),
braceR: new TokenType("}"),
parenL: new TokenType("(", {
beforeExpr: !0,
startsExpr: !0
}),
parenR: new TokenType(")"),
comma: new TokenType(",", beforeExpr),
semi: new TokenType(";", beforeExpr),
colon: new TokenType(":", beforeExpr),
dot: new TokenType("."),
question: new TokenType("?", beforeExpr),
questionDot: new TokenType("?."),
arrow: new TokenType("=>", beforeExpr),
template: new TokenType("template"),
invalidTemplate: new TokenType("invalidTemplate"),
ellipsis: new TokenType("...", beforeExpr),
backQuote: new TokenType("`", startsExpr),
dollarBraceL: new TokenType("${", {
beforeExpr: !0,
startsExpr: !0
}),
eq: new TokenType("=", {
beforeExpr: !0,
isAssign: !0
}),
assign: new TokenType("_=", {
beforeExpr: !0,
isAssign: !0
}),
incDec: new TokenType("++/--", {
prefix: !0,
postfix: !0,
startsExpr: !0
}),
prefix: new TokenType("!/~", {
beforeExpr: !0,
prefix: !0,
startsExpr: !0
}),
logicalOR: binop("||", 1),
logicalAND: binop("&&", 2),
bitwiseOR: binop("|", 3),
bitwiseXOR: binop("^", 4),
bitwiseAND: binop("&", 5),
equality: binop("==/!=/===/!==", 6),
relational: binop("</>/<=/>=", 7),
bitShift: binop("<</>>/>>>", 8),
plusMin: new TokenType("+/-", {
beforeExpr: !0,
binop: 9,
prefix: !0,
startsExpr: !0
}),
modulo: binop("%", 10),
star: binop("*", 10),
slash: binop("/", 10),
starstar: new TokenType("**", {
beforeExpr: !0
}),
coalesce: binop("??", 1),
_break: kw("break"),
_case: kw("case", beforeExpr),
_catch: kw("catch"),
_continue: kw("continue"),
_debugger: kw("debugger"),
_default: kw("default", beforeExpr),
_do: kw("do", {
isLoop: !0,
beforeExpr: !0
}),
_else: kw("else", beforeExpr),
_finally: kw("finally"),
_for: kw("for", {
isLoop: !0
}),
_function: kw("function", startsExpr),
_if: kw("if"),
_return: kw("return", beforeExpr),
_switch: kw("switch"),
_throw: kw("throw", beforeExpr),
_try: kw("try"),
_var: kw("var"),
_const: kw("const"),
_while: kw("while", {
isLoop: !0
}),
_with: kw("with"),
_new: kw("new", {
beforeExpr: !0,
startsExpr: !0
}),
_this: kw("this", startsExpr),
_super: kw("super", startsExpr),
_class: kw("class", startsExpr),
_extends: kw("extends", beforeExpr),
_export: kw("export"),
_import: kw("import", startsExpr),
_null: kw("null", startsExpr),
_true: kw("true", startsExpr),
_false: kw("false", startsExpr),
_in: kw("in", {
beforeExpr: !0,
binop: 7
}),
_instanceof: kw("instanceof", {
beforeExpr: !0,
binop: 7
}),
_typeof: kw("typeof", {
beforeExpr: !0,
prefix: !0,
startsExpr: !0
}),
_void: kw("void", {
beforeExpr: !0,
prefix: !0,
startsExpr: !0
}),
_delete: kw("delete", {
beforeExpr: !0,
prefix: !0,
startsExpr: !0
})
}, lineBreak = /\r\n?|\n|\u2028|\u2029/, lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
return 10 === code || 13 === code || 8232 === code || 8233 === code;
}
function nextLineBreak(code, from, end) {
void 0 === end && (end = code.length);
for (var i = from; i < end; i++) {
var next = code.charCodeAt(i);
if (isNewLine(next)) return i < end - 1 && 13 === next && 10 === code.charCodeAt(i + 1) ? i + 2 : i + 1;
}
return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ref = Object.prototype, hasOwnProperty = ref.hasOwnProperty, toString = ref.toString, hasOwn = Object.hasOwn || function(obj, propName) {
return hasOwnProperty.call(obj, propName);
}, isArray = Array.isArray || function(obj) {
return "[object Array]" === toString.call(obj);
};
function wordsRegexp(words) {
return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
return code <= 65535 ? String.fromCharCode(code) : (code -= 65536, String.fromCharCode(55296 + (code >> 10), 56320 + (1023 & code)));
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Position = function(line, col) {
this.line = line, this.column = col;
};
Position.prototype.offset = function(n) {
return new Position(this.line, this.column + n);
};
var SourceLocation = function(p, start, end) {
this.start = start, this.end = end, null !== p.sourceFile && (this.source = p.sourceFile);
};
function getLineInfo(input, offset) {
for (var line = 1, cur = 0; ;) {
var nextBreak = nextLineBreak(input, cur, offset);
if (nextBreak < 0) return new Position(line, offset - cur);
++line, cur = nextBreak;
}
}
var defaultOptions = {
ecmaVersion: null,
sourceType: "script",
onInsertedSemicolon: null,
onTrailingComma: null,
allowReserved: null,
allowReturnOutsideFunction: !1,
allowImportExportEverywhere: !1,
allowAwaitOutsideFunction: null,
allowSuperOutsideMethod: null,
allowHashBang: !1,
locations: !1,
onToken: null,
onComment: null,
ranges: !1,
program: null,
sourceFile: null,
directSourceFile: null,
preserveParens: !1
}, warnedAboutEcmaVersion = !1;
function getOptions(opts) {
var options = {};
for (var opt in defaultOptions) options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
if ("latest" === options.ecmaVersion ? options.ecmaVersion = 1e8 : null == options.ecmaVersion ? (!warnedAboutEcmaVersion && "object" == typeof console && console.warn && (warnedAboutEcmaVersion = !0, 
console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), 
options.ecmaVersion = 11) : options.ecmaVersion >= 2015 && (options.ecmaVersion -= 2009), 
null == options.allowReserved && (options.allowReserved = options.ecmaVersion < 5), 
isArray(options.onToken)) {
var tokens = options.onToken;
options.onToken = function(token) {
return tokens.push(token);
};
}
return isArray(options.onComment) && (options.onComment = pushComment(options, options.onComment)), 
options;
}
function pushComment(options, array) {
return function(block, text, start, end, startLoc, endLoc) {
var comment = {
type: block ? "Block" : "Line",
value: text,
start,
end
};
options.locations && (comment.loc = new SourceLocation(this, startLoc, endLoc)), 
options.ranges && (comment.range = [ start, end ]), array.push(comment);
};
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5, Parser = function(options, input, startPos) {
this.options = options = getOptions(options), this.sourceFile = options.sourceFile, 
this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : "module" === options.sourceType ? "5module" : 5]);
var reserved = "";
!0 !== options.allowReserved && (reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : 5 === options.ecmaVersion ? 5 : 3], 
"module" === options.sourceType && (reserved += " await")), this.reservedWords = wordsRegexp(reserved);
var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
this.reservedWordsStrict = wordsRegexp(reservedStrict), this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind), 
this.input = String(input), this.containsEsc = !1, startPos ? (this.pos = startPos, 
this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length) : (this.pos = this.lineStart = 0, 
this.curLine = 1), this.type = types$1.eof, this.value = null, this.start = this.end = this.pos, 
this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, 
this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), 
this.exprAllowed = !0, this.inModule = "module" === options.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), 
this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, 
this.labels = [], this.undefinedExports = Object.create(null), 0 === this.pos && options.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), 
this.scopeStack = [], this.enterScope(SCOPE_TOP), this.regexpState = null, this.privateNameStack = [];
}, prototypeAccessors = {
inFunction: {
configurable: !0
},
inGenerator: {
configurable: !0
},
inAsync: {
configurable: !0
},
canAwait: {
configurable: !0
},
allowSuper: {
configurable: !0
},
allowDirectSuper: {
configurable: !0
},
treatFunctionsAsVar: {
configurable: !0
},
allowNewDotTarget: {
configurable: !0
},
inClassStaticBlock: {
configurable: !0
}
};
Parser.prototype.parse = function() {
var node = this.options.program || this.startNode();
return this.nextToken(), this.parseTopLevel(node);
}, prototypeAccessors.inFunction.get = function() {
return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
}, prototypeAccessors.inGenerator.get = function() {
return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
}, prototypeAccessors.inAsync.get = function() {
return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
}, prototypeAccessors.canAwait.get = function() {
for (var i = this.scopeStack.length - 1; i >= 0; i--) {
var scope = this.scopeStack[i];
if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) return !1;
if (scope.flags & SCOPE_FUNCTION) return (scope.flags & SCOPE_ASYNC) > 0;
}
return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
}, prototypeAccessors.allowSuper.get = function() {
var ref = this.currentThisScope(), flags = ref.flags, inClassFieldInit = ref.inClassFieldInit;
return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
}, prototypeAccessors.allowDirectSuper.get = function() {
return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
}, prototypeAccessors.treatFunctionsAsVar.get = function() {
return this.treatFunctionsAsVarInScope(this.currentScope());
}, prototypeAccessors.allowNewDotTarget.get = function() {
var ref = this.currentThisScope(), flags = ref.flags, inClassFieldInit = ref.inClassFieldInit;
return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
}, prototypeAccessors.inClassStaticBlock.get = function() {
return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
}, Parser.extend = function() {
for (var plugins = [], len = arguments.length; len--; ) plugins[len] = arguments[len];
for (var cls = this, i = 0; i < plugins.length; i++) cls = plugins[i](cls);
return cls;
}, Parser.parse = function(input, options) {
return new this(options, input).parse();
}, Parser.parseExpressionAt = function(input, pos, options) {
var parser = new this(options, input, pos);
return parser.nextToken(), parser.parseExpression();
}, Parser.tokenizer = function(input, options) {
return new this(options, input);
}, Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype, literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
if (this.options.ecmaVersion < 5) return !1;
for (;;) {
skipWhiteSpace.lastIndex = start, start += skipWhiteSpace.exec(this.input)[0].length;
var match = literal.exec(this.input.slice(start));
if (!match) return !1;
if ("use strict" === (match[1] || match[2])) {
skipWhiteSpace.lastIndex = start + match[0].length;
var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length, next = this.input.charAt(end);
return ";" === next || "}" === next || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || "!" === next && "=" === this.input.charAt(end + 1));
}
start += match[0].length, skipWhiteSpace.lastIndex = start, start += skipWhiteSpace.exec(this.input)[0].length, 
";" === this.input[start] && start++;
}
}, pp$9.eat = function(type) {
return this.type === type && (this.next(), !0);
}, pp$9.isContextual = function(name) {
return this.type === types$1.name && this.value === name && !this.containsEsc;
}, pp$9.eatContextual = function(name) {
return !!this.isContextual(name) && (this.next(), !0);
}, pp$9.expectContextual = function(name) {
this.eatContextual(name) || this.unexpected();
}, pp$9.canInsertSemicolon = function() {
return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
}, pp$9.insertSemicolon = function() {
if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), 
!0;
}, pp$9.semicolon = function() {
this.eat(types$1.semi) || this.insertSemicolon() || this.unexpected();
}, pp$9.afterTrailingComma = function(tokType, notNext) {
if (this.type === tokType) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), 
notNext || this.next(), !0;
}, pp$9.expect = function(type) {
this.eat(type) || this.unexpected();
}, pp$9.unexpected = function(pos) {
this.raise(null != pos ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function() {
this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
if (refDestructuringErrors) {
refDestructuringErrors.trailingComma > -1 && this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
parens > -1 && this.raiseRecoverable(parens, "Parenthesized pattern");
}
}, pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
if (!refDestructuringErrors) return !1;
var shorthandAssign = refDestructuringErrors.shorthandAssign, doubleProto = refDestructuringErrors.doubleProto;
if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
shorthandAssign >= 0 && this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"), 
doubleProto >= 0 && this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
}, pp$9.checkYieldAwaitInDefaultParams = function() {
this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), 
this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
}, pp$9.isSimpleAssignTarget = function(expr) {
return "ParenthesizedExpression" === expr.type ? this.isSimpleAssignTarget(expr.expression) : "Identifier" === expr.type || "MemberExpression" === expr.type;
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
var exports = Object.create(null);
for (node.body || (node.body = []); this.type !== types$1.eof; ) {
var stmt = this.parseStatement(null, !0, exports);
node.body.push(stmt);
}
if (this.inModule) for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
var name = list[i];
this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
}
return this.adaptDirectivePrologue(node.body), this.next(), node.sourceType = this.options.sourceType, 
this.finishNode(node, "Program");
};
var loopLabel = {
kind: "loop"
}, switchLabel = {
kind: "switch"
};
pp$8.isLet = function(context) {
if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
skipWhiteSpace.lastIndex = this.pos;
var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
if (91 === nextCh || 92 === nextCh || nextCh > 55295 && nextCh < 56320) return !0;
if (context) return !1;
if (123 === nextCh) return !0;
if (isIdentifierStart(nextCh, !0)) {
for (var pos = next + 1; isIdentifierChar(nextCh = this.input.charCodeAt(pos), !0); ) ++pos;
if (92 === nextCh || nextCh > 55295 && nextCh < 56320) return !0;
var ident = this.input.slice(next, pos);
if (!keywordRelationalOperator.test(ident)) return !0;
}
return !1;
}, pp$8.isAsyncFunction = function() {
if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
skipWhiteSpace.lastIndex = this.pos;
var after, skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length;
return !(lineBreak.test(this.input.slice(this.pos, next)) || "function" !== this.input.slice(next, next + 8) || next + 8 !== this.input.length && (isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
}, pp$8.parseStatement = function(context, topLevel, exports) {
var kind, starttype = this.type, node = this.startNode();
switch (this.isLet(context) && (starttype = types$1._var, kind = "let"), starttype) {
case types$1._break:
case types$1._continue:
return this.parseBreakContinueStatement(node, starttype.keyword);

case types$1._debugger:
return this.parseDebuggerStatement(node);

case types$1._do:
return this.parseDoStatement(node);

case types$1._for:
return this.parseForStatement(node);

case types$1._function:
return context && (this.strict || "if" !== context && "label" !== context) && this.options.ecmaVersion >= 6 && this.unexpected(), 
this.parseFunctionStatement(node, !1, !context);

case types$1._class:
return context && this.unexpected(), this.parseClass(node, !0);

case types$1._if:
return this.parseIfStatement(node);

case types$1._return:
return this.parseReturnStatement(node);

case types$1._switch:
return this.parseSwitchStatement(node);

case types$1._throw:
return this.parseThrowStatement(node);

case types$1._try:
return this.parseTryStatement(node);

case types$1._const:
case types$1._var:
return kind = kind || this.value, context && "var" !== kind && this.unexpected(), 
this.parseVarStatement(node, kind);

case types$1._while:
return this.parseWhileStatement(node);

case types$1._with:
return this.parseWithStatement(node);

case types$1.braceL:
return this.parseBlock(!0, node);

case types$1.semi:
return this.parseEmptyStatement(node);

case types$1._export:
case types$1._import:
if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
skipWhiteSpace.lastIndex = this.pos;
var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
if (40 === nextCh || 46 === nextCh) return this.parseExpressionStatement(node, this.parseExpression());
}
return this.options.allowImportExportEverywhere || (topLevel || this.raise(this.start, "'import' and 'export' may only appear at the top level"), 
this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), 
starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);

default:
if (this.isAsyncFunction()) return context && this.unexpected(), this.next(), this.parseFunctionStatement(node, !0, !context);
var maybeName = this.value, expr = this.parseExpression();
return starttype === types$1.name && "Identifier" === expr.type && this.eat(types$1.colon) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
}
}, pp$8.parseBreakContinueStatement = function(node, keyword) {
var isBreak = "break" === keyword;
this.next(), this.eat(types$1.semi) || this.insertSemicolon() ? node.label = null : this.type !== types$1.name ? this.unexpected() : (node.label = this.parseIdent(), 
this.semicolon());
for (var i = 0; i < this.labels.length; ++i) {
var lab = this.labels[i];
if (null == node.label || lab.name === node.label.name) {
if (null != lab.kind && (isBreak || "loop" === lab.kind)) break;
if (node.label && isBreak) break;
}
}
return i === this.labels.length && this.raise(node.start, "Unsyntactic " + keyword), 
this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
}, pp$8.parseDebuggerStatement = function(node) {
return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
}, pp$8.parseDoStatement = function(node) {
return this.next(), this.labels.push(loopLabel), node.body = this.parseStatement("do"), 
this.labels.pop(), this.expect(types$1._while), node.test = this.parseParenExpression(), 
this.options.ecmaVersion >= 6 ? this.eat(types$1.semi) : this.semicolon(), this.finishNode(node, "DoWhileStatement");
}, pp$8.parseForStatement = function(node) {
this.next();
var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
if (this.labels.push(loopLabel), this.enterScope(0), this.expect(types$1.parenL), 
this.type === types$1.semi) return awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, null);
var isLet = this.isLet();
if (this.type === types$1._var || this.type === types$1._const || isLet) {
var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
return this.next(), this.parseVar(init$1, !0, kind), this.finishNode(init$1, "VariableDeclaration"), 
(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === init$1.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === types$1._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), 
this.parseForIn(node, init$1)) : (awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init$1));
}
var startsWithLet = this.isContextual("let"), isForOf = !1, refDestructuringErrors = new DestructuringErrors, init = this.parseExpression(!(awaitAt > -1) || "await", refDestructuringErrors);
return this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === types$1._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), 
startsWithLet && isForOf && this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."), 
this.toAssignable(init, !1, refDestructuringErrors), this.checkLValPattern(init), 
this.parseForIn(node, init)) : (this.checkExpressionErrors(refDestructuringErrors, !0), 
awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init));
}, pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
return this.next(), this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), !1, isAsync);
}, pp$8.parseIfStatement = function(node) {
return this.next(), node.test = this.parseParenExpression(), node.consequent = this.parseStatement("if"), 
node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
}, pp$8.parseReturnStatement = function(node) {
return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), 
this.next(), this.eat(types$1.semi) || this.insertSemicolon() ? node.argument = null : (node.argument = this.parseExpression(), 
this.semicolon()), this.finishNode(node, "ReturnStatement");
}, pp$8.parseSwitchStatement = function(node) {
var cur;
this.next(), node.discriminant = this.parseParenExpression(), node.cases = [], this.expect(types$1.braceL), 
this.labels.push(switchLabel), this.enterScope(0);
for (var sawDefault = !1; this.type !== types$1.braceR; ) if (this.type === types$1._case || this.type === types$1._default) {
var isCase = this.type === types$1._case;
cur && this.finishNode(cur, "SwitchCase"), node.cases.push(cur = this.startNode()), 
cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), 
sawDefault = !0, cur.test = null), this.expect(types$1.colon);
} else cur || this.unexpected(), cur.consequent.push(this.parseStatement(null));
return this.exitScope(), cur && this.finishNode(cur, "SwitchCase"), this.next(), 
this.labels.pop(), this.finishNode(node, "SwitchStatement");
}, pp$8.parseThrowStatement = function(node) {
return this.next(), lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), 
node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node) {
if (this.next(), node.block = this.parseBlock(), node.handler = null, this.type === types$1._catch) {
var clause = this.startNode();
if (this.next(), this.eat(types$1.parenL)) {
clause.param = this.parseBindingAtom();
var simple = "Identifier" === clause.param.type;
this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0), this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL), 
this.expect(types$1.parenR);
} else this.options.ecmaVersion < 10 && this.unexpected(), clause.param = null, 
this.enterScope(0);
clause.body = this.parseBlock(!1), this.exitScope(), node.handler = this.finishNode(clause, "CatchClause");
}
return node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(node.start, "Missing catch or finally clause"), 
this.finishNode(node, "TryStatement");
}, pp$8.parseVarStatement = function(node, kind) {
return this.next(), this.parseVar(node, !1, kind), this.semicolon(), this.finishNode(node, "VariableDeclaration");
}, pp$8.parseWhileStatement = function(node) {
return this.next(), node.test = this.parseParenExpression(), this.labels.push(loopLabel), 
node.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(node, "WhileStatement");
}, pp$8.parseWithStatement = function(node) {
return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), 
node.object = this.parseParenExpression(), node.body = this.parseStatement("with"), 
this.finishNode(node, "WithStatement");
}, pp$8.parseEmptyStatement = function(node) {
return this.next(), this.finishNode(node, "EmptyStatement");
}, pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) list[i$1].name === maybeName && this.raise(expr.start, "Label '" + maybeName + "' is already declared");
for (var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null, i = this.labels.length - 1; i >= 0; i--) {
var label$1 = this.labels[i];
if (label$1.statementStart !== node.start) break;
label$1.statementStart = this.start, label$1.kind = kind;
}
return this.labels.push({
name: maybeName,
kind,
statementStart: this.start
}), node.body = this.parseStatement(context ? -1 === context.indexOf("label") ? context + "label" : context : "label"), 
this.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
}, pp$8.parseExpressionStatement = function(node, expr) {
return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
}, pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
for (void 0 === createNewLexicalScope && (createNewLexicalScope = !0), void 0 === node && (node = this.startNode()), 
node.body = [], this.expect(types$1.braceL), createNewLexicalScope && this.enterScope(0); this.type !== types$1.braceR; ) {
var stmt = this.parseStatement(null);
node.body.push(stmt);
}
return exitStrict && (this.strict = !1), this.next(), createNewLexicalScope && this.exitScope(), 
this.finishNode(node, "BlockStatement");
}, pp$8.parseFor = function(node, init) {
return node.init = init, this.expect(types$1.semi), node.test = this.type === types$1.semi ? null : this.parseExpression(), 
this.expect(types$1.semi), node.update = this.type === types$1.parenR ? null : this.parseExpression(), 
this.expect(types$1.parenR), node.body = this.parseStatement("for"), this.exitScope(), 
this.labels.pop(), this.finishNode(node, "ForStatement");
}, pp$8.parseForIn = function(node, init) {
var isForIn = this.type === types$1._in;
return this.next(), "VariableDeclaration" === init.type && null != init.declarations[0].init && (!isForIn || this.options.ecmaVersion < 8 || this.strict || "var" !== init.kind || "Identifier" !== init.declarations[0].id.type) && this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), 
node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign(), 
this.expect(types$1.parenR), node.body = this.parseStatement("for"), this.exitScope(), 
this.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
}, pp$8.parseVar = function(node, isFor, kind) {
for (node.declarations = [], node.kind = kind; ;) {
var decl = this.startNode();
if (this.parseVarId(decl, kind), this.eat(types$1.eq) ? decl.init = this.parseMaybeAssign(isFor) : "const" !== kind || this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? "Identifier" === decl.id.type || isFor && (this.type === types$1._in || this.isContextual("of")) ? decl.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), 
node.declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(types$1.comma)) break;
}
return node;
}, pp$8.parseVarId = function(decl, kind) {
decl.id = this.parseBindingAtom(), this.checkLValPattern(decl.id, "var" === kind ? BIND_VAR : BIND_LEXICAL, !1);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
function isPrivateNameConflicted(privateNameMap, element) {
var name = element.key.name, curr = privateNameMap[name], next = "true";
return "MethodDefinition" !== element.type || "get" !== element.kind && "set" !== element.kind || (next = (element.static ? "s" : "i") + element.kind), 
"iget" === curr && "iset" === next || "iset" === curr && "iget" === next || "sget" === curr && "sset" === next || "sset" === curr && "sget" === next ? (privateNameMap[name] = "true", 
!1) : !!curr || (privateNameMap[name] = next, !1);
}
function checkKeyName(node, name) {
var computed = node.computed, key = node.key;
return !computed && ("Identifier" === key.type && key.name === name || "Literal" === key.type && key.value === name);
}
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
this.initFunction(node), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) && (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT && this.unexpected(), 
node.generator = this.eat(types$1.star)), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), 
statement & FUNC_STATEMENT && (node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent(), 
!node.id || statement & FUNC_HANGING_STATEMENT || this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION));
var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(node.async, node.generator)), 
statement & FUNC_STATEMENT || (node.id = this.type === types$1.name ? this.parseIdent() : null), 
this.parseFunctionParams(node), this.parseFunctionBody(node, allowExpressionBody, !1, forInit), 
this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
}, pp$8.parseFunctionParams = function(node) {
this.expect(types$1.parenL), node.params = this.parseBindingList(types$1.parenR, !1, this.options.ecmaVersion >= 8), 
this.checkYieldAwaitInDefaultParams();
}, pp$8.parseClass = function(node, isStatement) {
this.next();
var oldStrict = this.strict;
this.strict = !0, this.parseClassId(node, isStatement), this.parseClassSuper(node);
var privateNameMap = this.enterClassBody(), classBody = this.startNode(), hadConstructor = !1;
for (classBody.body = [], this.expect(types$1.braceL); this.type !== types$1.braceR; ) {
var element = this.parseClassElement(null !== node.superClass);
element && (classBody.body.push(element), "MethodDefinition" === element.type && "constructor" === element.kind ? (hadConstructor && this.raise(element.start, "Duplicate constructor in the same class"), 
hadConstructor = !0) : element.key && "PrivateIdentifier" === element.key.type && isPrivateNameConflicted(privateNameMap, element) && this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared"));
}
return this.strict = oldStrict, this.next(), node.body = this.finishNode(classBody, "ClassBody"), 
this.exitClassBody(), this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
}, pp$8.parseClassElement = function(constructorAllowsSuper) {
if (this.eat(types$1.semi)) return null;
var ecmaVersion = this.options.ecmaVersion, node = this.startNode(), keyName = "", isGenerator = !1, isAsync = !1, kind = "method", isStatic = !1;
if (this.eatContextual("static")) {
if (ecmaVersion >= 13 && this.eat(types$1.braceL)) return this.parseClassStaticBlock(node), 
node;
this.isClassElementNameStart() || this.type === types$1.star ? isStatic = !0 : keyName = "static";
}
if (node.static = isStatic, !keyName && ecmaVersion >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== types$1.star || this.canInsertSemicolon() ? keyName = "async" : isAsync = !0), 
!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star) && (isGenerator = !0), 
!keyName && !isAsync && !isGenerator) {
var lastValue = this.value;
(this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? kind = lastValue : keyName = lastValue);
}
if (keyName ? (node.computed = !1, node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), 
node.key.name = keyName, this.finishNode(node.key, "Identifier")) : this.parseClassElementName(node), 
ecmaVersion < 13 || this.type === types$1.parenL || "method" !== kind || isGenerator || isAsync) {
var isConstructor = !node.static && checkKeyName(node, "constructor"), allowsDirectSuper = isConstructor && constructorAllowsSuper;
isConstructor && "method" !== kind && this.raise(node.key.start, "Constructor can't have get/set modifier"), 
node.kind = isConstructor ? "constructor" : kind, this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
} else this.parseClassField(node);
return node;
}, pp$8.isClassElementNameStart = function() {
return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
}, pp$8.parseClassElementName = function(element) {
this.type === types$1.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), 
element.computed = !1, element.key = this.parsePrivateIdent()) : this.parsePropertyName(element);
}, pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
var key = method.key;
"constructor" === method.kind ? (isGenerator && this.raise(key.start, "Constructor can't be a generator"), 
isAsync && this.raise(key.start, "Constructor can't be an async method")) : method.static && checkKeyName(method, "prototype") && this.raise(key.start, "Classes may not have a static property named prototype");
var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
return "get" === method.kind && 0 !== value.params.length && this.raiseRecoverable(value.start, "getter should have no params"), 
"set" === method.kind && 1 !== value.params.length && this.raiseRecoverable(value.start, "setter should have exactly one param"), 
"set" === method.kind && "RestElement" === value.params[0].type && this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"), 
this.finishNode(method, "MethodDefinition");
}, pp$8.parseClassField = function(field) {
if (checkKeyName(field, "constructor") ? this.raise(field.key.start, "Classes can't have a field named 'constructor'") : field.static && checkKeyName(field, "prototype") && this.raise(field.key.start, "Classes can't have a static field named 'prototype'"), 
this.eat(types$1.eq)) {
var scope = this.currentThisScope(), inClassFieldInit = scope.inClassFieldInit;
scope.inClassFieldInit = !0, field.value = this.parseMaybeAssign(), scope.inClassFieldInit = inClassFieldInit;
} else field.value = null;
return this.semicolon(), this.finishNode(field, "PropertyDefinition");
}, pp$8.parseClassStaticBlock = function(node) {
node.body = [];
var oldLabels = this.labels;
for (this.labels = [], this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER); this.type !== types$1.braceR; ) {
var stmt = this.parseStatement(null);
node.body.push(stmt);
}
return this.next(), this.exitScope(), this.labels = oldLabels, this.finishNode(node, "StaticBlock");
}, pp$8.parseClassId = function(node, isStatement) {
this.type === types$1.name ? (node.id = this.parseIdent(), isStatement && this.checkLValSimple(node.id, BIND_LEXICAL, !1)) : (!0 === isStatement && this.unexpected(), 
node.id = null);
}, pp$8.parseClassSuper = function(node) {
node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(!1) : null;
}, pp$8.enterClassBody = function() {
var element = {
declared: Object.create(null),
used: []
};
return this.privateNameStack.push(element), element.declared;
}, pp$8.exitClassBody = function() {
for (var ref = this.privateNameStack.pop(), declared = ref.declared, used = ref.used, len = this.privateNameStack.length, parent = 0 === len ? null : this.privateNameStack[len - 1], i = 0; i < used.length; ++i) {
var id = used[i];
hasOwn(declared, id.name) || (parent ? parent.used.push(id) : this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class"));
}
}, pp$8.parseExport = function(node, exports) {
if (this.next(), this.eat(types$1.star)) return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (node.exported = this.parseModuleExportName(), 
this.checkExport(exports, node.exported, this.lastTokStart)) : node.exported = null), 
this.expectContextual("from"), this.type !== types$1.string && this.unexpected(), 
node.source = this.parseExprAtom(), this.semicolon(), this.finishNode(node, "ExportAllDeclaration");
if (this.eat(types$1._default)) {
var isAsync;
if (this.checkExport(exports, "default", this.lastTokStart), this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
var fNode = this.startNode();
this.next(), isAsync && this.next(), node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, !1, isAsync);
} else if (this.type === types$1._class) {
var cNode = this.startNode();
node.declaration = this.parseClass(cNode, "nullableID");
} else node.declaration = this.parseMaybeAssign(), this.semicolon();
return this.finishNode(node, "ExportDefaultDeclaration");
}
if (this.shouldParseExportStatement()) node.declaration = this.parseStatement(null), 
"VariableDeclaration" === node.declaration.type ? this.checkVariableExport(exports, node.declaration.declarations) : this.checkExport(exports, node.declaration.id, node.declaration.id.start), 
node.specifiers = [], node.source = null; else {
if (node.declaration = null, node.specifiers = this.parseExportSpecifiers(exports), 
this.eatContextual("from")) this.type !== types$1.string && this.unexpected(), node.source = this.parseExprAtom(); else {
for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
var spec = list[i];
this.checkUnreserved(spec.local), this.checkLocalExport(spec.local), "Literal" === spec.local.type && this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
}
node.source = null;
}
this.semicolon();
}
return this.finishNode(node, "ExportNamedDeclaration");
}, pp$8.checkExport = function(exports, name, pos) {
exports && ("string" != typeof name && (name = "Identifier" === name.type ? name.name : name.value), 
hasOwn(exports, name) && this.raiseRecoverable(pos, "Duplicate export '" + name + "'"), 
exports[name] = !0);
}, pp$8.checkPatternExport = function(exports, pat) {
var type = pat.type;
if ("Identifier" === type) this.checkExport(exports, pat, pat.start); else if ("ObjectPattern" === type) for (var i = 0, list = pat.properties; i < list.length; i += 1) {
var prop = list[i];
this.checkPatternExport(exports, prop);
} else if ("ArrayPattern" === type) for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
var elt = list$1[i$1];
elt && this.checkPatternExport(exports, elt);
} else "Property" === type ? this.checkPatternExport(exports, pat.value) : "AssignmentPattern" === type ? this.checkPatternExport(exports, pat.left) : "RestElement" === type ? this.checkPatternExport(exports, pat.argument) : "ParenthesizedExpression" === type && this.checkPatternExport(exports, pat.expression);
}, pp$8.checkVariableExport = function(exports, decls) {
if (exports) for (var i = 0, list = decls; i < list.length; i += 1) {
var decl = list[i];
this.checkPatternExport(exports, decl.id);
}
}, pp$8.shouldParseExportStatement = function() {
return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
}, pp$8.parseExportSpecifiers = function(exports) {
var nodes = [], first = !0;
for (this.expect(types$1.braceL); !this.eat(types$1.braceR); ) {
if (first) first = !1; else if (this.expect(types$1.comma), this.afterTrailingComma(types$1.braceR)) break;
var node = this.startNode();
node.local = this.parseModuleExportName(), node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local, 
this.checkExport(exports, node.exported, node.exported.start), nodes.push(this.finishNode(node, "ExportSpecifier"));
}
return nodes;
}, pp$8.parseImport = function(node) {
return this.next(), this.type === types$1.string ? (node.specifiers = empty$1, node.source = this.parseExprAtom()) : (node.specifiers = this.parseImportSpecifiers(), 
this.expectContextual("from"), node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected()), 
this.semicolon(), this.finishNode(node, "ImportDeclaration");
}, pp$8.parseImportSpecifiers = function() {
var nodes = [], first = !0;
if (this.type === types$1.name) {
var node = this.startNode();
if (node.local = this.parseIdent(), this.checkLValSimple(node.local, BIND_LEXICAL), 
nodes.push(this.finishNode(node, "ImportDefaultSpecifier")), !this.eat(types$1.comma)) return nodes;
}
if (this.type === types$1.star) {
var node$1 = this.startNode();
return this.next(), this.expectContextual("as"), node$1.local = this.parseIdent(), 
this.checkLValSimple(node$1.local, BIND_LEXICAL), nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier")), 
nodes;
}
for (this.expect(types$1.braceL); !this.eat(types$1.braceR); ) {
if (first) first = !1; else if (this.expect(types$1.comma), this.afterTrailingComma(types$1.braceR)) break;
var node$2 = this.startNode();
node$2.imported = this.parseModuleExportName(), this.eatContextual("as") ? node$2.local = this.parseIdent() : (this.checkUnreserved(node$2.imported), 
node$2.local = node$2.imported), this.checkLValSimple(node$2.local, BIND_LEXICAL), 
nodes.push(this.finishNode(node$2, "ImportSpecifier"));
}
return nodes;
}, pp$8.parseModuleExportName = function() {
if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
var stringLiteral = this.parseLiteral(this.value);
return loneSurrogate.test(stringLiteral.value) && this.raise(stringLiteral.start, "An export name cannot include a lone surrogate."), 
stringLiteral;
}
return this.parseIdent(!0);
}, pp$8.adaptDirectivePrologue = function(statements) {
for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) statements[i].directive = statements[i].expression.raw.slice(1, -1);
}, pp$8.isDirectiveCandidate = function(statement) {
return "ExpressionStatement" === statement.type && "Literal" === statement.expression.type && "string" == typeof statement.expression.value && ('"' === this.input[statement.start] || "'" === this.input[statement.start]);
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
case "Identifier":
this.inAsync && "await" === node.name && this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
break;

case "ObjectPattern":
case "ArrayPattern":
case "AssignmentPattern":
case "RestElement":
break;

case "ObjectExpression":
node.type = "ObjectPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, !0);
for (var i = 0, list = node.properties; i < list.length; i += 1) {
var prop = list[i];
this.toAssignable(prop, isBinding), "RestElement" !== prop.type || "ArrayPattern" !== prop.argument.type && "ObjectPattern" !== prop.argument.type || this.raise(prop.argument.start, "Unexpected token");
}
break;

case "Property":
"init" !== node.kind && this.raise(node.key.start, "Object pattern can't contain getter or setter"), 
this.toAssignable(node.value, isBinding);
break;

case "ArrayExpression":
node.type = "ArrayPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, !0), 
this.toAssignableList(node.elements, isBinding);
break;

case "SpreadElement":
node.type = "RestElement", this.toAssignable(node.argument, isBinding), "AssignmentPattern" === node.argument.type && this.raise(node.argument.start, "Rest elements cannot have a default value");
break;

case "AssignmentExpression":
"=" !== node.operator && this.raise(node.left.end, "Only '=' operator can be used for specifying default value."), 
node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isBinding);
break;

case "ParenthesizedExpression":
this.toAssignable(node.expression, isBinding, refDestructuringErrors);
break;

case "ChainExpression":
this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
break;

case "MemberExpression":
if (!isBinding) break;

default:
this.raise(node.start, "Assigning to rvalue");
} else refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, !0);
return node;
}, pp$7.toAssignableList = function(exprList, isBinding) {
for (var end = exprList.length, i = 0; i < end; i++) {
var elt = exprList[i];
elt && this.toAssignable(elt, isBinding);
}
if (end) {
var last = exprList[end - 1];
6 === this.options.ecmaVersion && isBinding && last && "RestElement" === last.type && "Identifier" !== last.argument.type && this.unexpected(last.argument.start);
}
return exprList;
}, pp$7.parseSpread = function(refDestructuringErrors) {
var node = this.startNode();
return this.next(), node.argument = this.parseMaybeAssign(!1, refDestructuringErrors), 
this.finishNode(node, "SpreadElement");
}, pp$7.parseRestBinding = function() {
var node = this.startNode();
return this.next(), 6 === this.options.ecmaVersion && this.type !== types$1.name && this.unexpected(), 
node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
}, pp$7.parseBindingAtom = function() {
if (this.options.ecmaVersion >= 6) switch (this.type) {
case types$1.bracketL:
var node = this.startNode();
return this.next(), node.elements = this.parseBindingList(types$1.bracketR, !0, !0), 
this.finishNode(node, "ArrayPattern");

case types$1.braceL:
return this.parseObj(!0);
}
return this.parseIdent();
}, pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
for (var elts = [], first = !0; !this.eat(close); ) if (first ? first = !1 : this.expect(types$1.comma), 
allowEmpty && this.type === types$1.comma) elts.push(null); else {
if (allowTrailingComma && this.afterTrailingComma(close)) break;
if (this.type === types$1.ellipsis) {
var rest = this.parseRestBinding();
this.parseBindingListItem(rest), elts.push(rest), this.type === types$1.comma && this.raise(this.start, "Comma is not permitted after the rest element"), 
this.expect(close);
break;
}
var elem = this.parseMaybeDefault(this.start, this.startLoc);
this.parseBindingListItem(elem), elts.push(elem);
}
return elts;
}, pp$7.parseBindingListItem = function(param) {
return param;
}, pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
if (left = left || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
var node = this.startNodeAt(startPos, startLoc);
return node.left = left, node.right = this.parseMaybeAssign(), this.finishNode(node, "AssignmentPattern");
}, pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
void 0 === bindingType && (bindingType = BIND_NONE);
var isBind = bindingType !== BIND_NONE;
switch (expr.type) {
case "Identifier":
this.strict && this.reservedWordsStrictBind.test(expr.name) && this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"), 
isBind && (bindingType === BIND_LEXICAL && "let" === expr.name && this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"), 
checkClashes && (hasOwn(checkClashes, expr.name) && this.raiseRecoverable(expr.start, "Argument name clash"), 
checkClashes[expr.name] = !0), bindingType !== BIND_OUTSIDE && this.declareName(expr.name, bindingType, expr.start));
break;

case "ChainExpression":
this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
break;

case "MemberExpression":
isBind && this.raiseRecoverable(expr.start, "Binding member expression");
break;

case "ParenthesizedExpression":
return isBind && this.raiseRecoverable(expr.start, "Binding parenthesized expression"), 
this.checkLValSimple(expr.expression, bindingType, checkClashes);

default:
this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
}
}, pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
switch (void 0 === bindingType && (bindingType = BIND_NONE), expr.type) {
case "ObjectPattern":
for (var i = 0, list = expr.properties; i < list.length; i += 1) {
var prop = list[i];
this.checkLValInnerPattern(prop, bindingType, checkClashes);
}
break;

case "ArrayPattern":
for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
var elem = list$1[i$1];
elem && this.checkLValInnerPattern(elem, bindingType, checkClashes);
}
break;

default:
this.checkLValSimple(expr, bindingType, checkClashes);
}
}, pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
switch (void 0 === bindingType && (bindingType = BIND_NONE), expr.type) {
case "Property":
this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
break;

case "AssignmentPattern":
this.checkLValPattern(expr.left, bindingType, checkClashes);
break;

case "RestElement":
this.checkLValPattern(expr.argument, bindingType, checkClashes);
break;

default:
this.checkLValPattern(expr, bindingType, checkClashes);
}
};
var TokContext = function(token, isExpr, preserveSpace, override, generator) {
this.token = token, this.isExpr = !!isExpr, this.preserveSpace = !!preserveSpace, 
this.override = override, this.generator = !!generator;
}, types = {
b_stat: new TokContext("{", !1),
b_expr: new TokContext("{", !0),
b_tmpl: new TokContext("${", !1),
p_stat: new TokContext("(", !1),
p_expr: new TokContext("(", !0),
q_tmpl: new TokContext("`", !0, !0, (function(p) {
return p.tryReadTemplateToken();
})),
f_stat: new TokContext("function", !1),
f_expr: new TokContext("function", !0),
f_expr_gen: new TokContext("function", !0, !1, null, !0),
f_gen: new TokContext("function", !1, !1, null, !0)
}, pp$6 = Parser.prototype;
pp$6.initialContext = function() {
return [ types.b_stat ];
}, pp$6.curContext = function() {
return this.context[this.context.length - 1];
}, pp$6.braceIsBlock = function(prevType) {
var parent = this.curContext();
return parent === types.f_expr || parent === types.f_stat || (prevType !== types$1.colon || parent !== types.b_stat && parent !== types.b_expr ? prevType === types$1._return || prevType === types$1.name && this.exprAllowed ? lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) : prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow || (prevType === types$1.braceL ? parent === types.b_stat : prevType !== types$1._var && prevType !== types$1._const && prevType !== types$1.name && !this.exprAllowed) : !parent.isExpr);
}, pp$6.inGeneratorContext = function() {
for (var i = this.context.length - 1; i >= 1; i--) {
var context = this.context[i];
if ("function" === context.token) return context.generator;
}
return !1;
}, pp$6.updateContext = function(prevType) {
var update, type = this.type;
type.keyword && prevType === types$1.dot ? this.exprAllowed = !1 : (update = type.updateContext) ? update.call(this, prevType) : this.exprAllowed = type.beforeExpr;
}, pp$6.overrideContext = function(tokenCtx) {
this.curContext() !== tokenCtx && (this.context[this.context.length - 1] = tokenCtx);
}, types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
if (1 !== this.context.length) {
var out = this.context.pop();
out === types.b_stat && "function" === this.curContext().token && (out = this.context.pop()), 
this.exprAllowed = !out.isExpr;
} else this.exprAllowed = !0;
}, types$1.braceL.updateContext = function(prevType) {
this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr), this.exprAllowed = !0;
}, types$1.dollarBraceL.updateContext = function() {
this.context.push(types.b_tmpl), this.exprAllowed = !0;
}, types$1.parenL.updateContext = function(prevType) {
var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
this.context.push(statementParens ? types.p_stat : types.p_expr), this.exprAllowed = !0;
}, types$1.incDec.updateContext = function() {}, types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
!prevType.beforeExpr || prevType === types$1._else || prevType === types$1.semi && this.curContext() !== types.p_stat || prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) || (prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat ? this.context.push(types.f_stat) : this.context.push(types.f_expr), 
this.exprAllowed = !1;
}, types$1.backQuote.updateContext = function() {
this.curContext() === types.q_tmpl ? this.context.pop() : this.context.push(types.q_tmpl), 
this.exprAllowed = !1;
}, types$1.star.updateContext = function(prevType) {
if (prevType === types$1._function) {
var index = this.context.length - 1;
this.context[index] === types.f_expr ? this.context[index] = types.f_expr_gen : this.context[index] = types.f_gen;
}
this.exprAllowed = !0;
}, types$1.name.updateContext = function(prevType) {
var allowed = !1;
this.options.ecmaVersion >= 6 && prevType !== types$1.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (allowed = !0), 
this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
function isPrivateFieldAccess(node) {
return "MemberExpression" === node.type && "PrivateIdentifier" === node.property.type || "ChainExpression" === node.type && isPrivateFieldAccess(node.expression);
}
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === prop.type || this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))) {
var name, key = prop.key;
switch (key.type) {
case "Identifier":
name = key.name;
break;

case "Literal":
name = String(key.value);
break;

default:
return;
}
var kind = prop.kind;
if (this.options.ecmaVersion >= 6) "__proto__" === name && "init" === kind && (propHash.proto && (refDestructuringErrors ? refDestructuringErrors.doubleProto < 0 && (refDestructuringErrors.doubleProto = key.start) : this.raiseRecoverable(key.start, "Redefinition of __proto__ property")), 
propHash.proto = !0); else {
var other = propHash[name = "$" + name];
other ? ("init" === kind ? this.strict && other.init || other.get || other.set : other.init || other[kind]) && this.raiseRecoverable(key.start, "Redefinition of property") : other = propHash[name] = {
init: !1,
get: !1,
set: !1
}, other[kind] = !0;
}
}
}, pp$5.parseExpression = function(forInit, refDestructuringErrors) {
var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
if (this.type === types$1.comma) {
var node = this.startNodeAt(startPos, startLoc);
for (node.expressions = [ expr ]; this.eat(types$1.comma); ) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
return this.finishNode(node, "SequenceExpression");
}
return expr;
}, pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
if (this.isContextual("yield")) {
if (this.inGenerator) return this.parseYield(forInit);
this.exprAllowed = !1;
}
var ownDestructuringErrors = !1, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
refDestructuringErrors ? (oldParenAssign = refDestructuringErrors.parenthesizedAssign, 
oldTrailingComma = refDestructuringErrors.trailingComma, oldDoubleProto = refDestructuringErrors.doubleProto, 
refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1) : (refDestructuringErrors = new DestructuringErrors, 
ownDestructuringErrors = !0);
var startPos = this.start, startLoc = this.startLoc;
this.type !== types$1.parenL && this.type !== types$1.name || (this.potentialArrowAt = this.start, 
this.potentialArrowInForAwait = "await" === forInit);
var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), 
this.type.isAssign) {
var node = this.startNodeAt(startPos, startLoc);
return node.operator = this.value, this.type === types$1.eq && (left = this.toAssignable(left, !1, refDestructuringErrors)), 
ownDestructuringErrors || (refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1), 
refDestructuringErrors.shorthandAssign >= left.start && (refDestructuringErrors.shorthandAssign = -1), 
this.type === types$1.eq ? this.checkLValPattern(left) : this.checkLValSimple(left), 
node.left = left, this.next(), node.right = this.parseMaybeAssign(forInit), oldDoubleProto > -1 && (refDestructuringErrors.doubleProto = oldDoubleProto), 
this.finishNode(node, "AssignmentExpression");
}
return ownDestructuringErrors && this.checkExpressionErrors(refDestructuringErrors, !0), 
oldParenAssign > -1 && (refDestructuringErrors.parenthesizedAssign = oldParenAssign), 
oldTrailingComma > -1 && (refDestructuringErrors.trailingComma = oldTrailingComma), 
left;
}, pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprOps(forInit, refDestructuringErrors);
if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
if (this.eat(types$1.question)) {
var node = this.startNodeAt(startPos, startLoc);
return node.test = expr, node.consequent = this.parseMaybeAssign(), this.expect(types$1.colon), 
node.alternate = this.parseMaybeAssign(forInit), this.finishNode(node, "ConditionalExpression");
}
return expr;
}, pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeUnary(refDestructuringErrors, !1, !1, forInit);
return this.checkExpressionErrors(refDestructuringErrors) || expr.start === startPos && "ArrowFunctionExpression" === expr.type ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
}, pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
var prec = this.type.binop;
if (null != prec && (!forInit || this.type !== types$1._in) && prec > minPrec) {
var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND, coalesce = this.type === types$1.coalesce;
coalesce && (prec = types$1.logicalAND.binop);
var op = this.value;
this.next();
var startPos = this.start, startLoc = this.startLoc, right = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, forInit), startPos, startLoc, prec, forInit), node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
return (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), 
this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
}
return left;
}, pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
"PrivateIdentifier" === right.type && this.raise(right.start, "Private identifier can only be left side of binary expression");
var node = this.startNodeAt(startPos, startLoc);
return node.left = left, node.operator = op, node.right = right, this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
}, pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
var expr, startPos = this.start, startLoc = this.startLoc;
if (this.isContextual("await") && this.canAwait) expr = this.parseAwait(forInit), 
sawUnary = !0; else if (this.type.prefix) {
var node = this.startNode(), update = this.type === types$1.incDec;
node.operator = this.value, node.prefix = !0, this.next(), node.argument = this.parseMaybeUnary(null, !0, update, forInit), 
this.checkExpressionErrors(refDestructuringErrors, !0), update ? this.checkLValSimple(node.argument) : this.strict && "delete" === node.operator && "Identifier" === node.argument.type ? this.raiseRecoverable(node.start, "Deleting local variable in strict mode") : "delete" === node.operator && isPrivateFieldAccess(node.argument) ? this.raiseRecoverable(node.start, "Private fields can not be deleted") : sawUnary = !0, 
expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
} else if (sawUnary || this.type !== types$1.privateId) {
if (expr = this.parseExprSubscripts(refDestructuringErrors, forInit), this.checkExpressionErrors(refDestructuringErrors)) return expr;
for (;this.type.postfix && !this.canInsertSemicolon(); ) {
var node$1 = this.startNodeAt(startPos, startLoc);
node$1.operator = this.value, node$1.prefix = !1, node$1.argument = expr, this.checkLValSimple(expr), 
this.next(), expr = this.finishNode(node$1, "UpdateExpression");
}
} else (forInit || 0 === this.privateNameStack.length) && this.unexpected(), expr = this.parsePrivateIdent(), 
this.type !== types$1._in && this.unexpected();
return incDec || !this.eat(types$1.starstar) ? expr : sawUnary ? void this.unexpected(this.lastTokStart) : this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, !1, !1, forInit), "**", !1);
}, pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprAtom(refDestructuringErrors, forInit);
if ("ArrowFunctionExpression" === expr.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return expr;
var result = this.parseSubscripts(expr, startPos, startLoc, !1, forInit);
return refDestructuringErrors && "MemberExpression" === result.type && (refDestructuringErrors.parenthesizedAssign >= result.start && (refDestructuringErrors.parenthesizedAssign = -1), 
refDestructuringErrors.parenthesizedBind >= result.start && (refDestructuringErrors.parenthesizedBind = -1), 
refDestructuringErrors.trailingComma >= result.start && (refDestructuringErrors.trailingComma = -1)), 
result;
}, pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
for (var maybeAsyncArrow = this.options.ecmaVersion >= 8 && "Identifier" === base.type && "async" === base.name && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start == 5 && this.potentialArrowAt === base.start, optionalChained = !1; ;) {
var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
if (element.optional && (optionalChained = !0), element === base || "ArrowFunctionExpression" === element.type) {
if (optionalChained) {
var chainNode = this.startNodeAt(startPos, startLoc);
chainNode.expression = element, element = this.finishNode(chainNode, "ChainExpression");
}
return element;
}
base = element;
}
}, pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
var optionalSupported = this.options.ecmaVersion >= 11, optional = optionalSupported && this.eat(types$1.questionDot);
noCalls && optional && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
var computed = this.eat(types$1.bracketL);
if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
var node = this.startNodeAt(startPos, startLoc);
node.object = base, computed ? (node.property = this.parseExpression(), this.expect(types$1.bracketR)) : this.type === types$1.privateId && "Super" !== base.type ? node.property = this.parsePrivateIdent() : node.property = this.parseIdent("never" !== this.options.allowReserved), 
node.computed = !!computed, optionalSupported && (node.optional = optional), base = this.finishNode(node, "MemberExpression");
} else if (!noCalls && this.eat(types$1.parenL)) {
var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, !1, refDestructuringErrors);
if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) return this.checkPatternErrors(refDestructuringErrors, !1), 
this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), 
this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, !0, forInit);
this.checkExpressionErrors(refDestructuringErrors, !0), this.yieldPos = oldYieldPos || this.yieldPos, 
this.awaitPos = oldAwaitPos || this.awaitPos, this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
var node$1 = this.startNodeAt(startPos, startLoc);
node$1.callee = base, node$1.arguments = exprList, optionalSupported && (node$1.optional = optional), 
base = this.finishNode(node$1, "CallExpression");
} else if (this.type === types$1.backQuote) {
(optional || optionalChained) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
var node$2 = this.startNodeAt(startPos, startLoc);
node$2.tag = base, node$2.quasi = this.parseTemplate({
isTagged: !0
}), base = this.finishNode(node$2, "TaggedTemplateExpression");
}
return base;
}, pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
this.type === types$1.slash && this.readRegexp();
var node, canBeArrow = this.potentialArrowAt === this.start;
switch (this.type) {
case types$1._super:
return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), 
node = this.startNode(), this.next(), this.type !== types$1.parenL || this.allowDirectSuper || this.raise(node.start, "super() call outside constructor of a subclass"), 
this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL && this.unexpected(), 
this.finishNode(node, "Super");

case types$1._this:
return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");

case types$1.name:
var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc, id = this.parseIdent(!1);
if (this.options.ecmaVersion >= 8 && !containsEsc && "async" === id.name && !this.canInsertSemicolon() && this.eat(types$1._function)) return this.overrideContext(types.f_expr), 
this.parseFunction(this.startNodeAt(startPos, startLoc), 0, !1, !0, forInit);
if (canBeArrow && !this.canInsertSemicolon()) {
if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [ id ], !1, forInit);
if (this.options.ecmaVersion >= 8 && "async" === id.name && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return id = this.parseIdent(!1), 
!this.canInsertSemicolon() && this.eat(types$1.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [ id ], !0, forInit);
}
return id;

case types$1.regexp:
var value = this.value;
return (node = this.parseLiteral(value.value)).regex = {
pattern: value.pattern,
flags: value.flags
}, node;

case types$1.num:
case types$1.string:
return this.parseLiteral(this.value);

case types$1._null:
case types$1._true:
case types$1._false:
return (node = this.startNode()).value = this.type === types$1._null ? null : this.type === types$1._true, 
node.raw = this.type.keyword, this.next(), this.finishNode(node, "Literal");

case types$1.parenL:
var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
return refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr) && (refDestructuringErrors.parenthesizedAssign = start), 
refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = start)), 
expr;

case types$1.bracketL:
return node = this.startNode(), this.next(), node.elements = this.parseExprList(types$1.bracketR, !0, !0, refDestructuringErrors), 
this.finishNode(node, "ArrayExpression");

case types$1.braceL:
return this.overrideContext(types.b_expr), this.parseObj(!1, refDestructuringErrors);

case types$1._function:
return node = this.startNode(), this.next(), this.parseFunction(node, 0);

case types$1._class:
return this.parseClass(this.startNode(), !1);

case types$1._new:
return this.parseNew();

case types$1.backQuote:
return this.parseTemplate();

case types$1._import:
return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();

default:
this.unexpected();
}
}, pp$5.parseExprImport = function() {
var node = this.startNode();
this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
var meta = this.parseIdent(!0);
switch (this.type) {
case types$1.parenL:
return this.parseDynamicImport(node);

case types$1.dot:
return node.meta = meta, this.parseImportMeta(node);

default:
this.unexpected();
}
}, pp$5.parseDynamicImport = function(node) {
if (this.next(), node.source = this.parseMaybeAssign(), !this.eat(types$1.parenR)) {
var errorPos = this.start;
this.eat(types$1.comma) && this.eat(types$1.parenR) ? this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()") : this.unexpected(errorPos);
}
return this.finishNode(node, "ImportExpression");
}, pp$5.parseImportMeta = function(node) {
this.next();
var containsEsc = this.containsEsc;
return node.property = this.parseIdent(!0), "meta" !== node.property.name && this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"), 
containsEsc && this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"), 
"module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"), 
this.finishNode(node, "MetaProperty");
}, pp$5.parseLiteral = function(value) {
var node = this.startNode();
return node.value = value, node.raw = this.input.slice(this.start, this.end), 110 === node.raw.charCodeAt(node.raw.length - 1) && (node.bigint = node.raw.slice(0, -1).replace(/_/g, "")), 
this.next(), this.finishNode(node, "Literal");
}, pp$5.parseParenExpression = function() {
this.expect(types$1.parenL);
var val = this.parseExpression();
return this.expect(types$1.parenR), val;
}, pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
var val, startPos = this.start, startLoc = this.startLoc, allowTrailingComma = this.options.ecmaVersion >= 8;
if (this.options.ecmaVersion >= 6) {
this.next();
var spreadStart, innerStartPos = this.start, innerStartLoc = this.startLoc, exprList = [], first = !0, lastIsComma = !1, refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;
for (this.yieldPos = 0, this.awaitPos = 0; this.type !== types$1.parenR; ) {
if (first ? first = !1 : this.expect(types$1.comma), allowTrailingComma && this.afterTrailingComma(types$1.parenR, !0)) {
lastIsComma = !0;
break;
}
if (this.type === types$1.ellipsis) {
spreadStart = this.start, exprList.push(this.parseParenItem(this.parseRestBinding())), 
this.type === types$1.comma && this.raise(this.start, "Comma is not permitted after the rest element");
break;
}
exprList.push(this.parseMaybeAssign(!1, refDestructuringErrors, this.parseParenItem));
}
var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
if (this.expect(types$1.parenR), canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) return this.checkPatternErrors(refDestructuringErrors, !1), 
this.checkYieldAwaitInDefaultParams(), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, 
this.parseParenArrowList(startPos, startLoc, exprList, forInit);
exprList.length && !lastIsComma || this.unexpected(this.lastTokStart), spreadStart && this.unexpected(spreadStart), 
this.checkExpressionErrors(refDestructuringErrors, !0), this.yieldPos = oldYieldPos || this.yieldPos, 
this.awaitPos = oldAwaitPos || this.awaitPos, exprList.length > 1 ? ((val = this.startNodeAt(innerStartPos, innerStartLoc)).expressions = exprList, 
this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)) : val = exprList[0];
} else val = this.parseParenExpression();
if (this.options.preserveParens) {
var par = this.startNodeAt(startPos, startLoc);
return par.expression = val, this.finishNode(par, "ParenthesizedExpression");
}
return val;
}, pp$5.parseParenItem = function(item) {
return item;
}, pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, !1, forInit);
};
var empty = [];
pp$5.parseNew = function() {
this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
var node = this.startNode(), meta = this.parseIdent(!0);
if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
node.meta = meta;
var containsEsc = this.containsEsc;
return node.property = this.parseIdent(!0), "target" !== node.property.name && this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"), 
containsEsc && this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"), 
this.allowNewDotTarget || this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"), 
this.finishNode(node, "MetaProperty");
}
var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
return node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, !0, !1), 
isImport && "ImportExpression" === node.callee.type && this.raise(startPos, "Cannot use new with import()"), 
this.eat(types$1.parenL) ? node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, !1) : node.arguments = empty, 
this.finishNode(node, "NewExpression");
}, pp$5.parseTemplateElement = function(ref) {
var isTagged = ref.isTagged, elem = this.startNode();
return this.type === types$1.invalidTemplate ? (isTagged || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), 
elem.value = {
raw: this.value,
cooked: null
}) : elem.value = {
raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
cooked: this.value
}, this.next(), elem.tail = this.type === types$1.backQuote, this.finishNode(elem, "TemplateElement");
}, pp$5.parseTemplate = function(ref) {
void 0 === ref && (ref = {});
var isTagged = ref.isTagged;
void 0 === isTagged && (isTagged = !1);
var node = this.startNode();
this.next(), node.expressions = [];
var curElt = this.parseTemplateElement({
isTagged
});
for (node.quasis = [ curElt ]; !curElt.tail; ) this.type === types$1.eof && this.raise(this.pos, "Unterminated template literal"), 
this.expect(types$1.dollarBraceL), node.expressions.push(this.parseExpression()), 
this.expect(types$1.braceR), node.quasis.push(curElt = this.parseTemplateElement({
isTagged
}));
return this.next(), this.finishNode(node, "TemplateLiteral");
}, pp$5.isAsyncProp = function(prop) {
return !prop.computed && "Identifier" === prop.key.type && "async" === prop.key.name && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
}, pp$5.parseObj = function(isPattern, refDestructuringErrors) {
var node = this.startNode(), first = !0, propHash = {};
for (node.properties = [], this.next(); !this.eat(types$1.braceR); ) {
if (first) first = !1; else if (this.expect(types$1.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
var prop = this.parseProperty(isPattern, refDestructuringErrors);
isPattern || this.checkPropClash(prop, propHash, refDestructuringErrors), node.properties.push(prop);
}
return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
}, pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
var isGenerator, isAsync, startPos, startLoc, prop = this.startNode();
if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) return isPattern ? (prop.argument = this.parseIdent(!1), 
this.type === types$1.comma && this.raise(this.start, "Comma is not permitted after the rest element"), 
this.finishNode(prop, "RestElement")) : (this.type === types$1.parenL && refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && (refDestructuringErrors.parenthesizedAssign = this.start), 
refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = this.start)), 
prop.argument = this.parseMaybeAssign(!1, refDestructuringErrors), this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start), 
this.finishNode(prop, "SpreadElement"));
this.options.ecmaVersion >= 6 && (prop.method = !1, prop.shorthand = !1, (isPattern || refDestructuringErrors) && (startPos = this.start, 
startLoc = this.startLoc), isPattern || (isGenerator = this.eat(types$1.star)));
var containsEsc = this.containsEsc;
return this.parsePropertyName(prop), !isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop) ? (isAsync = !0, 
isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star), this.parsePropertyName(prop, refDestructuringErrors)) : isAsync = !1, 
this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc), 
this.finishNode(prop, "Property");
}, pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
if ((isGenerator || isAsync) && this.type === types$1.colon && this.unexpected(), 
this.eat(types$1.colon)) prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, refDestructuringErrors), 
prop.kind = "init"; else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) isPattern && this.unexpected(), 
prop.kind = "init", prop.method = !0, prop.value = this.parseMethod(isGenerator, isAsync); else if (isPattern || containsEsc || !(this.options.ecmaVersion >= 5) || prop.computed || "Identifier" !== prop.key.type || "get" !== prop.key.name && "set" !== prop.key.name || this.type === types$1.comma || this.type === types$1.braceR || this.type === types$1.eq) this.options.ecmaVersion >= 6 && !prop.computed && "Identifier" === prop.key.type ? ((isGenerator || isAsync) && this.unexpected(), 
this.checkUnreserved(prop.key), "await" !== prop.key.name || this.awaitIdentPos || (this.awaitIdentPos = startPos), 
prop.kind = "init", isPattern ? prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key)) : this.type === types$1.eq && refDestructuringErrors ? (refDestructuringErrors.shorthandAssign < 0 && (refDestructuringErrors.shorthandAssign = this.start), 
prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key))) : prop.value = this.copyNode(prop.key), 
prop.shorthand = !0) : this.unexpected(); else {
(isGenerator || isAsync) && this.unexpected(), prop.kind = prop.key.name, this.parsePropertyName(prop), 
prop.value = this.parseMethod(!1);
var paramCount = "get" === prop.kind ? 0 : 1;
if (prop.value.params.length !== paramCount) {
var start = prop.value.start;
"get" === prop.kind ? this.raiseRecoverable(start, "getter should have no params") : this.raiseRecoverable(start, "setter should have exactly one param");
} else "set" === prop.kind && "RestElement" === prop.value.params[0].type && this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
}
}, pp$5.parsePropertyName = function(prop) {
if (this.options.ecmaVersion >= 6) {
if (this.eat(types$1.bracketL)) return prop.computed = !0, prop.key = this.parseMaybeAssign(), 
this.expect(types$1.bracketR), prop.key;
prop.computed = !1;
}
return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
}, pp$5.initFunction = function(node) {
node.id = null, this.options.ecmaVersion >= 6 && (node.generator = node.expression = !1), 
this.options.ecmaVersion >= 8 && (node.async = !1);
}, pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
return this.initFunction(node), this.options.ecmaVersion >= 6 && (node.generator = isGenerator), 
this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, 
this.awaitIdentPos = 0, this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0)), 
this.expect(types$1.parenL), node.params = this.parseBindingList(types$1.parenR, !1, this.options.ecmaVersion >= 8), 
this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(node, !1, !0, !1), 
this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
this.finishNode(node, "FunctionExpression");
}, pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
return this.enterScope(functionFlags(isAsync, !1) | SCOPE_ARROW), this.initFunction(node), 
this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, 
this.awaitIdentPos = 0, node.params = this.toAssignableList(params, !0), this.parseFunctionBody(node, !0, !1, forInit), 
this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
this.finishNode(node, "ArrowFunctionExpression");
}, pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
var isExpression = isArrowFunction && this.type !== types$1.braceL, oldStrict = this.strict, useStrict = !1;
if (isExpression) node.body = this.parseMaybeAssign(forInit), node.expression = !0, 
this.checkParams(node, !1); else {
var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
oldStrict && !nonSimple || (useStrict = this.strictDirective(this.end)) && nonSimple && this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
var oldLabels = this.labels;
this.labels = [], useStrict && (this.strict = !0), this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params)), 
this.strict && node.id && this.checkLValSimple(node.id, BIND_OUTSIDE), node.body = this.parseBlock(!1, void 0, useStrict && !oldStrict), 
node.expression = !1, this.adaptDirectivePrologue(node.body.body), this.labels = oldLabels;
}
this.exitScope();
}, pp$5.isSimpleParamList = function(params) {
for (var i = 0, list = params; i < list.length; i += 1) if ("Identifier" !== list[i].type) return !1;
return !0;
}, pp$5.checkParams = function(node, allowDuplicates) {
for (var nameHash = Object.create(null), i = 0, list = node.params; i < list.length; i += 1) {
var param = list[i];
this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
}
}, pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
for (var elts = [], first = !0; !this.eat(close); ) {
if (first) first = !1; else if (this.expect(types$1.comma), allowTrailingComma && this.afterTrailingComma(close)) break;
var elt = void 0;
allowEmpty && this.type === types$1.comma ? elt = null : this.type === types$1.ellipsis ? (elt = this.parseSpread(refDestructuringErrors), 
refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start)) : elt = this.parseMaybeAssign(!1, refDestructuringErrors), 
elts.push(elt);
}
return elts;
}, pp$5.checkUnreserved = function(ref) {
var start = ref.start, end = ref.end, name = ref.name;
this.inGenerator && "yield" === name && this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"), 
this.inAsync && "await" === name && this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"), 
this.currentThisScope().inClassFieldInit && "arguments" === name && this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"), 
!this.inClassStaticBlock || "arguments" !== name && "await" !== name || this.raise(start, "Cannot use " + name + " in class static initialization block"), 
this.keywords.test(name) && this.raise(start, "Unexpected keyword '" + name + "'"), 
this.options.ecmaVersion < 6 && -1 !== this.input.slice(start, end).indexOf("\\") || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(name) && (this.inAsync || "await" !== name || this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"), 
this.raiseRecoverable(start, "The keyword '" + name + "' is reserved"));
}, pp$5.parseIdent = function(liberal, isBinding) {
var node = this.startNode();
return this.type === types$1.name ? node.name = this.value : this.type.keyword ? (node.name = this.type.keyword, 
"class" !== node.name && "function" !== node.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), 
this.next(!!liberal), this.finishNode(node, "Identifier"), liberal || (this.checkUnreserved(node), 
"await" !== node.name || this.awaitIdentPos || (this.awaitIdentPos = node.start)), 
node;
}, pp$5.parsePrivateIdent = function() {
var node = this.startNode();
return this.type === types$1.privateId ? node.name = this.value : this.unexpected(), 
this.next(), this.finishNode(node, "PrivateIdentifier"), 0 === this.privateNameStack.length ? this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(node), 
node;
}, pp$5.parseYield = function(forInit) {
this.yieldPos || (this.yieldPos = this.start);
var node = this.startNode();
return this.next(), this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr ? (node.delegate = !1, 
node.argument = null) : (node.delegate = this.eat(types$1.star), node.argument = this.parseMaybeAssign(forInit)), 
this.finishNode(node, "YieldExpression");
}, pp$5.parseAwait = function(forInit) {
this.awaitPos || (this.awaitPos = this.start);
var node = this.startNode();
return this.next(), node.argument = this.parseMaybeUnary(null, !0, !1, forInit), 
this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
var loc = getLineInfo(this.input, pos);
message += " (" + loc.line + ":" + loc.column + ")";
var err = new SyntaxError(message);
throw err.pos = pos, err.loc = loc, err.raisedAt = this.pos, err;
}, pp$4.raiseRecoverable = pp$4.raise, pp$4.curPosition = function() {
if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser.prototype, Scope = function(flags) {
this.flags = flags, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
};
pp$3.enterScope = function(flags) {
this.scopeStack.push(new Scope(flags));
}, pp$3.exitScope = function() {
this.scopeStack.pop();
}, pp$3.treatFunctionsAsVarInScope = function(scope) {
return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
}, pp$3.declareName = function(name, bindingType, pos) {
var redeclared = !1;
if (bindingType === BIND_LEXICAL) {
var scope = this.currentScope();
redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1, 
scope.lexical.push(name), this.inModule && scope.flags & SCOPE_TOP && delete this.undefinedExports[name];
} else if (bindingType === BIND_SIMPLE_CATCH) this.currentScope().lexical.push(name); else if (bindingType === BIND_FUNCTION) {
var scope$2 = this.currentScope();
redeclared = this.treatFunctionsAsVar ? scope$2.lexical.indexOf(name) > -1 : scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1, 
scope$2.functions.push(name);
} else for (var i = this.scopeStack.length - 1; i >= 0; --i) {
var scope$3 = this.scopeStack[i];
if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
redeclared = !0;
break;
}
if (scope$3.var.push(name), this.inModule && scope$3.flags & SCOPE_TOP && delete this.undefinedExports[name], 
scope$3.flags & SCOPE_VAR) break;
}
redeclared && this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
}, pp$3.checkLocalExport = function(id) {
-1 === this.scopeStack[0].lexical.indexOf(id.name) && -1 === this.scopeStack[0].var.indexOf(id.name) && (this.undefinedExports[id.name] = id);
}, pp$3.currentScope = function() {
return this.scopeStack[this.scopeStack.length - 1];
}, pp$3.currentVarScope = function() {
for (var i = this.scopeStack.length - 1; ;i--) {
var scope = this.scopeStack[i];
if (scope.flags & SCOPE_VAR) return scope;
}
}, pp$3.currentThisScope = function() {
for (var i = this.scopeStack.length - 1; ;i--) {
var scope = this.scopeStack[i];
if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) return scope;
}
};
var Node = function(parser, pos, loc) {
this.type = "", this.start = pos, this.end = 0, parser.options.locations && (this.loc = new SourceLocation(parser, loc)), 
parser.options.directSourceFile && (this.sourceFile = parser.options.directSourceFile), 
parser.options.ranges && (this.range = [ pos, 0 ]);
}, pp$2 = Parser.prototype;
function finishNodeAt(node, type, pos, loc) {
return node.type = type, node.end = pos, this.options.locations && (node.loc.end = loc), 
this.options.ranges && (node.range[1] = pos), node;
}
pp$2.startNode = function() {
return new Node(this, this.start, this.startLoc);
}, pp$2.startNodeAt = function(pos, loc) {
return new Node(this, pos, loc);
}, pp$2.finishNode = function(node, type) {
return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
}, pp$2.finishNodeAt = function(node, type, pos, loc) {
return finishNodeAt.call(this, node, type, pos, loc);
}, pp$2.copyNode = function(node) {
var newNode = new Node(this, node.start, this.startLoc);
for (var prop in node) newNode[prop] = node[prop];
return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic", ecma12BinaryProperties = ecma10BinaryProperties + " EBase EComp EMod EPres ExtPict", unicodeBinaryProperties = {
9: ecma9BinaryProperties,
10: ecma10BinaryProperties,
11: ecma10BinaryProperties,
12: ecma12BinaryProperties,
13: ecma12BinaryProperties
}, unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", unicodeScriptValues = {
9: ecma9ScriptValues,
10: ecma10ScriptValues,
11: ecma11ScriptValues,
12: ecma12ScriptValues,
13: ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith"
}, data = {};
function buildUnicodeData(ecmaVersion) {
var d = data[ecmaVersion] = {
binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
nonBinary: {
General_Category: wordsRegexp(unicodeGeneralCategoryValues),
Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
}
};
d.nonBinary.Script_Extensions = d.nonBinary.Script, d.nonBinary.gc = d.nonBinary.General_Category, 
d.nonBinary.sc = d.nonBinary.Script, d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (var i = 0, list = [ 9, 10, 11, 12, 13 ]; i < list.length; i += 1) buildUnicodeData(list[i]);
var pp$1 = Parser.prototype, RegExpValidationState = function(parser) {
this.parser = parser, this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : ""), 
this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion], 
this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, 
this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, 
this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
function isSyntaxCharacter(ch) {
return 36 === ch || ch >= 40 && ch <= 43 || 46 === ch || 63 === ch || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
function isRegExpIdentifierStart(ch) {
return isIdentifierStart(ch, !0) || 36 === ch || 95 === ch;
}
function isRegExpIdentifierPart(ch) {
return isIdentifierChar(ch, !0) || 36 === ch || 95 === ch || 8204 === ch || 8205 === ch;
}
function isControlLetter(ch) {
return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
function isValidUnicode(ch) {
return ch >= 0 && ch <= 1114111;
}
function isCharacterClassEscape(ch) {
return 100 === ch || 68 === ch || 115 === ch || 83 === ch || 119 === ch || 87 === ch;
}
function isUnicodePropertyNameCharacter(ch) {
return isControlLetter(ch) || 95 === ch;
}
function isUnicodePropertyValueCharacter(ch) {
return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
function isDecimalDigit(ch) {
return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
return ch >= 65 && ch <= 70 ? ch - 65 + 10 : ch >= 97 && ch <= 102 ? ch - 97 + 10 : ch - 48;
}
function isOctalDigit(ch) {
return ch >= 48 && ch <= 55;
}
RegExpValidationState.prototype.reset = function(start, pattern, flags) {
var unicode = -1 !== flags.indexOf("u");
this.start = 0 | start, this.source = pattern + "", this.flags = flags, this.switchU = unicode && this.parser.options.ecmaVersion >= 6, 
this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
}, RegExpValidationState.prototype.raise = function(message) {
this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
}, RegExpValidationState.prototype.at = function(i, forceU) {
void 0 === forceU && (forceU = !1);
var s = this.source, l = s.length;
if (i >= l) return -1;
var c = s.charCodeAt(i);
if (!forceU && !this.switchU || c <= 55295 || c >= 57344 || i + 1 >= l) return c;
var next = s.charCodeAt(i + 1);
return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
}, RegExpValidationState.prototype.nextIndex = function(i, forceU) {
void 0 === forceU && (forceU = !1);
var s = this.source, l = s.length;
if (i >= l) return l;
var next, c = s.charCodeAt(i);
return !forceU && !this.switchU || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343 ? i + 1 : i + 2;
}, RegExpValidationState.prototype.current = function(forceU) {
return void 0 === forceU && (forceU = !1), this.at(this.pos, forceU);
}, RegExpValidationState.prototype.lookahead = function(forceU) {
return void 0 === forceU && (forceU = !1), this.at(this.nextIndex(this.pos, forceU), forceU);
}, RegExpValidationState.prototype.advance = function(forceU) {
void 0 === forceU && (forceU = !1), this.pos = this.nextIndex(this.pos, forceU);
}, RegExpValidationState.prototype.eat = function(ch, forceU) {
return void 0 === forceU && (forceU = !1), this.current(forceU) === ch && (this.advance(forceU), 
!0);
}, pp$1.validateRegExpFlags = function(state) {
for (var validFlags = state.validFlags, flags = state.flags, i = 0; i < flags.length; i++) {
var flag = flags.charAt(i);
-1 === validFlags.indexOf(flag) && this.raise(state.start, "Invalid regular expression flag"), 
flags.indexOf(flag, i + 1) > -1 && this.raise(state.start, "Duplicate regular expression flag");
}
}, pp$1.validateRegExpPattern = function(state) {
this.regexp_pattern(state), !state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0 && (state.switchN = !0, 
this.regexp_pattern(state));
}, pp$1.regexp_pattern = function(state) {
state.pos = 0, state.lastIntValue = 0, state.lastStringValue = "", state.lastAssertionIsQuantifiable = !1, 
state.numCapturingParens = 0, state.maxBackReference = 0, state.groupNames.length = 0, 
state.backReferenceNames.length = 0, this.regexp_disjunction(state), state.pos !== state.source.length && (state.eat(41) && state.raise("Unmatched ')'"), 
(state.eat(93) || state.eat(125)) && state.raise("Lone quantifier brackets")), state.maxBackReference > state.numCapturingParens && state.raise("Invalid escape");
for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
var name = list[i];
-1 === state.groupNames.indexOf(name) && state.raise("Invalid named capture referenced");
}
}, pp$1.regexp_disjunction = function(state) {
for (this.regexp_alternative(state); state.eat(124); ) this.regexp_alternative(state);
this.regexp_eatQuantifier(state, !0) && state.raise("Nothing to repeat"), state.eat(123) && state.raise("Lone quantifier brackets");
}, pp$1.regexp_alternative = function(state) {
for (;state.pos < state.source.length && this.regexp_eatTerm(state); ) ;
}, pp$1.regexp_eatTerm = function(state) {
return this.regexp_eatAssertion(state) ? (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state) && state.switchU && state.raise("Invalid quantifier"), 
!0) : !!(state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) && (this.regexp_eatQuantifier(state), 
!0);
}, pp$1.regexp_eatAssertion = function(state) {
var start = state.pos;
if (state.lastAssertionIsQuantifiable = !1, state.eat(94) || state.eat(36)) return !0;
if (state.eat(92)) {
if (state.eat(66) || state.eat(98)) return !0;
state.pos = start;
}
if (state.eat(40) && state.eat(63)) {
var lookbehind = !1;
if (this.options.ecmaVersion >= 9 && (lookbehind = state.eat(60)), state.eat(61) || state.eat(33)) return this.regexp_disjunction(state), 
state.eat(41) || state.raise("Unterminated group"), state.lastAssertionIsQuantifiable = !lookbehind, 
!0;
}
return state.pos = start, !1;
}, pp$1.regexp_eatQuantifier = function(state, noError) {
return void 0 === noError && (noError = !1), !!this.regexp_eatQuantifierPrefix(state, noError) && (state.eat(63), 
!0);
}, pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
}, pp$1.regexp_eatBracedQuantifier = function(state, noError) {
var start = state.pos;
if (state.eat(123)) {
var min = 0, max = -1;
if (this.regexp_eatDecimalDigits(state) && (min = state.lastIntValue, state.eat(44) && this.regexp_eatDecimalDigits(state) && (max = state.lastIntValue), 
state.eat(125))) return -1 !== max && max < min && !noError && state.raise("numbers out of order in {} quantifier"), 
!0;
state.switchU && !noError && state.raise("Incomplete quantifier"), state.pos = start;
}
return !1;
}, pp$1.regexp_eatAtom = function(state) {
return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
}, pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
var start = state.pos;
if (state.eat(92)) {
if (this.regexp_eatAtomEscape(state)) return !0;
state.pos = start;
}
return !1;
}, pp$1.regexp_eatUncapturingGroup = function(state) {
var start = state.pos;
if (state.eat(40)) {
if (state.eat(63) && state.eat(58)) {
if (this.regexp_disjunction(state), state.eat(41)) return !0;
state.raise("Unterminated group");
}
state.pos = start;
}
return !1;
}, pp$1.regexp_eatCapturingGroup = function(state) {
if (state.eat(40)) {
if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(state) : 63 === state.current() && state.raise("Invalid group"), 
this.regexp_disjunction(state), state.eat(41)) return state.numCapturingParens += 1, 
!0;
state.raise("Unterminated group");
}
return !1;
}, pp$1.regexp_eatExtendedAtom = function(state) {
return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
}, pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
return this.regexp_eatBracedQuantifier(state, !0) && state.raise("Nothing to repeat"), 
!1;
}, pp$1.regexp_eatSyntaxCharacter = function(state) {
var ch = state.current();
return !!isSyntaxCharacter(ch) && (state.lastIntValue = ch, state.advance(), !0);
}, pp$1.regexp_eatPatternCharacters = function(state) {
for (var start = state.pos, ch = 0; -1 !== (ch = state.current()) && !isSyntaxCharacter(ch); ) state.advance();
return state.pos !== start;
}, pp$1.regexp_eatExtendedPatternCharacter = function(state) {
var ch = state.current();
return !(-1 === ch || 36 === ch || ch >= 40 && ch <= 43 || 46 === ch || 63 === ch || 91 === ch || 94 === ch || 124 === ch || (state.advance(), 
0));
}, pp$1.regexp_groupSpecifier = function(state) {
if (state.eat(63)) {
if (this.regexp_eatGroupName(state)) return -1 !== state.groupNames.indexOf(state.lastStringValue) && state.raise("Duplicate capture group name"), 
void state.groupNames.push(state.lastStringValue);
state.raise("Invalid group");
}
}, pp$1.regexp_eatGroupName = function(state) {
if (state.lastStringValue = "", state.eat(60)) {
if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return !0;
state.raise("Invalid capture group name");
}
return !1;
}, pp$1.regexp_eatRegExpIdentifierName = function(state) {
if (state.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(state)) {
for (state.lastStringValue += codePointToString(state.lastIntValue); this.regexp_eatRegExpIdentifierPart(state); ) state.lastStringValue += codePointToString(state.lastIntValue);
return !0;
}
return !1;
}, pp$1.regexp_eatRegExpIdentifierStart = function(state) {
var start = state.pos, forceU = this.options.ecmaVersion >= 11, ch = state.current(forceU);
return state.advance(forceU), 92 === ch && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU) && (ch = state.lastIntValue), 
isRegExpIdentifierStart(ch) ? (state.lastIntValue = ch, !0) : (state.pos = start, 
!1);
}, pp$1.regexp_eatRegExpIdentifierPart = function(state) {
var start = state.pos, forceU = this.options.ecmaVersion >= 11, ch = state.current(forceU);
return state.advance(forceU), 92 === ch && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU) && (ch = state.lastIntValue), 
isRegExpIdentifierPart(ch) ? (state.lastIntValue = ch, !0) : (state.pos = start, 
!1);
}, pp$1.regexp_eatAtomEscape = function(state) {
return !!(this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) || (state.switchU && (99 === state.current() && state.raise("Invalid unicode escape"), 
state.raise("Invalid escape")), !1);
}, pp$1.regexp_eatBackReference = function(state) {
var start = state.pos;
if (this.regexp_eatDecimalEscape(state)) {
var n = state.lastIntValue;
if (state.switchU) return n > state.maxBackReference && (state.maxBackReference = n), 
!0;
if (n <= state.numCapturingParens) return !0;
state.pos = start;
}
return !1;
}, pp$1.regexp_eatKGroupName = function(state) {
if (state.eat(107)) {
if (this.regexp_eatGroupName(state)) return state.backReferenceNames.push(state.lastStringValue), 
!0;
state.raise("Invalid named reference");
}
return !1;
}, pp$1.regexp_eatCharacterEscape = function(state) {
return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, !1) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
}, pp$1.regexp_eatCControlLetter = function(state) {
var start = state.pos;
if (state.eat(99)) {
if (this.regexp_eatControlLetter(state)) return !0;
state.pos = start;
}
return !1;
}, pp$1.regexp_eatZero = function(state) {
return 48 === state.current() && !isDecimalDigit(state.lookahead()) && (state.lastIntValue = 0, 
state.advance(), !0);
}, pp$1.regexp_eatControlEscape = function(state) {
var ch = state.current();
return 116 === ch ? (state.lastIntValue = 9, state.advance(), !0) : 110 === ch ? (state.lastIntValue = 10, 
state.advance(), !0) : 118 === ch ? (state.lastIntValue = 11, state.advance(), !0) : 102 === ch ? (state.lastIntValue = 12, 
state.advance(), !0) : 114 === ch && (state.lastIntValue = 13, state.advance(), 
!0);
}, pp$1.regexp_eatControlLetter = function(state) {
var ch = state.current();
return !!isControlLetter(ch) && (state.lastIntValue = ch % 32, state.advance(), 
!0);
}, pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
void 0 === forceU && (forceU = !1);
var start = state.pos, switchU = forceU || state.switchU;
if (state.eat(117)) {
if (this.regexp_eatFixedHexDigits(state, 4)) {
var lead = state.lastIntValue;
if (switchU && lead >= 55296 && lead <= 56319) {
var leadSurrogateEnd = state.pos;
if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
var trail = state.lastIntValue;
if (trail >= 56320 && trail <= 57343) return state.lastIntValue = 1024 * (lead - 55296) + (trail - 56320) + 65536, 
!0;
}
state.pos = leadSurrogateEnd, state.lastIntValue = lead;
}
return !0;
}
if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) return !0;
switchU && state.raise("Invalid unicode escape"), state.pos = start;
}
return !1;
}, pp$1.regexp_eatIdentityEscape = function(state) {
if (state.switchU) return !!this.regexp_eatSyntaxCharacter(state) || !!state.eat(47) && (state.lastIntValue = 47, 
!0);
var ch = state.current();
return !(99 === ch || state.switchN && 107 === ch || (state.lastIntValue = ch, state.advance(), 
0));
}, pp$1.regexp_eatDecimalEscape = function(state) {
state.lastIntValue = 0;
var ch = state.current();
if (ch >= 49 && ch <= 57) {
do {
state.lastIntValue = 10 * state.lastIntValue + (ch - 48), state.advance();
} while ((ch = state.current()) >= 48 && ch <= 57);
return !0;
}
return !1;
}, pp$1.regexp_eatCharacterClassEscape = function(state) {
var ch = state.current();
if (isCharacterClassEscape(ch)) return state.lastIntValue = -1, state.advance(), 
!0;
if (state.switchU && this.options.ecmaVersion >= 9 && (80 === ch || 112 === ch)) {
if (state.lastIntValue = -1, state.advance(), state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) return !0;
state.raise("Invalid property name");
}
return !1;
}, pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
var start = state.pos;
if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
var name = state.lastStringValue;
if (this.regexp_eatUnicodePropertyValue(state)) {
var value = state.lastStringValue;
return this.regexp_validateUnicodePropertyNameAndValue(state, name, value), !0;
}
}
if (state.pos = start, this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
var nameOrValue = state.lastStringValue;
return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue), !0;
}
return !1;
}, pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
hasOwn(state.unicodeProperties.nonBinary, name) || state.raise("Invalid property name"), 
state.unicodeProperties.nonBinary[name].test(value) || state.raise("Invalid property value");
}, pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
state.unicodeProperties.binary.test(nameOrValue) || state.raise("Invalid property name");
}, pp$1.regexp_eatUnicodePropertyName = function(state) {
var ch = 0;
for (state.lastStringValue = ""; isUnicodePropertyNameCharacter(ch = state.current()); ) state.lastStringValue += codePointToString(ch), 
state.advance();
return "" !== state.lastStringValue;
}, pp$1.regexp_eatUnicodePropertyValue = function(state) {
var ch = 0;
for (state.lastStringValue = ""; isUnicodePropertyValueCharacter(ch = state.current()); ) state.lastStringValue += codePointToString(ch), 
state.advance();
return "" !== state.lastStringValue;
}, pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
return this.regexp_eatUnicodePropertyValue(state);
}, pp$1.regexp_eatCharacterClass = function(state) {
if (state.eat(91)) {
if (state.eat(94), this.regexp_classRanges(state), state.eat(93)) return !0;
state.raise("Unterminated character class");
}
return !1;
}, pp$1.regexp_classRanges = function(state) {
for (;this.regexp_eatClassAtom(state); ) {
var left = state.lastIntValue;
if (state.eat(45) && this.regexp_eatClassAtom(state)) {
var right = state.lastIntValue;
!state.switchU || -1 !== left && -1 !== right || state.raise("Invalid character class"), 
-1 !== left && -1 !== right && left > right && state.raise("Range out of order in character class");
}
}
}, pp$1.regexp_eatClassAtom = function(state) {
var start = state.pos;
if (state.eat(92)) {
if (this.regexp_eatClassEscape(state)) return !0;
if (state.switchU) {
var ch$1 = state.current();
(99 === ch$1 || isOctalDigit(ch$1)) && state.raise("Invalid class escape"), state.raise("Invalid escape");
}
state.pos = start;
}
var ch = state.current();
return 93 !== ch && (state.lastIntValue = ch, state.advance(), !0);
}, pp$1.regexp_eatClassEscape = function(state) {
var start = state.pos;
if (state.eat(98)) return state.lastIntValue = 8, !0;
if (state.switchU && state.eat(45)) return state.lastIntValue = 45, !0;
if (!state.switchU && state.eat(99)) {
if (this.regexp_eatClassControlLetter(state)) return !0;
state.pos = start;
}
return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
}, pp$1.regexp_eatClassControlLetter = function(state) {
var ch = state.current();
return !(!isDecimalDigit(ch) && 95 !== ch || (state.lastIntValue = ch % 32, state.advance(), 
0));
}, pp$1.regexp_eatHexEscapeSequence = function(state) {
var start = state.pos;
if (state.eat(120)) {
if (this.regexp_eatFixedHexDigits(state, 2)) return !0;
state.switchU && state.raise("Invalid escape"), state.pos = start;
}
return !1;
}, pp$1.regexp_eatDecimalDigits = function(state) {
var start = state.pos, ch = 0;
for (state.lastIntValue = 0; isDecimalDigit(ch = state.current()); ) state.lastIntValue = 10 * state.lastIntValue + (ch - 48), 
state.advance();
return state.pos !== start;
}, pp$1.regexp_eatHexDigits = function(state) {
var start = state.pos, ch = 0;
for (state.lastIntValue = 0; isHexDigit(ch = state.current()); ) state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch), 
state.advance();
return state.pos !== start;
}, pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
if (this.regexp_eatOctalDigit(state)) {
var n1 = state.lastIntValue;
if (this.regexp_eatOctalDigit(state)) {
var n2 = state.lastIntValue;
n1 <= 3 && this.regexp_eatOctalDigit(state) ? state.lastIntValue = 64 * n1 + 8 * n2 + state.lastIntValue : state.lastIntValue = 8 * n1 + n2;
} else state.lastIntValue = n1;
return !0;
}
return !1;
}, pp$1.regexp_eatOctalDigit = function(state) {
var ch = state.current();
return isOctalDigit(ch) ? (state.lastIntValue = ch - 48, state.advance(), !0) : (state.lastIntValue = 0, 
!1);
}, pp$1.regexp_eatFixedHexDigits = function(state, length) {
var start = state.pos;
state.lastIntValue = 0;
for (var i = 0; i < length; ++i) {
var ch = state.current();
if (!isHexDigit(ch)) return state.pos = start, !1;
state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch), state.advance();
}
return !0;
};
var Token = function(p) {
this.type = p.type, this.value = p.value, this.start = p.start, this.end = p.end, 
p.options.locations && (this.loc = new SourceLocation(p, p.startLoc, p.endLoc)), 
p.options.ranges && (this.range = [ p.start, p.end ]);
}, pp = Parser.prototype;
function stringToNumber(str, isLegacyOctalNumericLiteral) {
return isLegacyOctalNumericLiteral ? parseInt(str, 8) : parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
return "function" != typeof BigInt ? null : BigInt(str.replace(/_/g, ""));
}
pp.next = function(ignoreEscapeSequenceInKeyword) {
!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), 
this.options.onToken && this.options.onToken(new Token(this)), this.lastTokEnd = this.end, 
this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, 
this.nextToken();
}, pp.getToken = function() {
return this.next(), new Token(this);
}, "undefined" != typeof Symbol && (pp[Symbol.iterator] = function() {
var this$1$1 = this;
return {
next: function() {
var token = this$1$1.getToken();
return {
done: token.type === types$1.eof,
value: token
};
}
};
}), pp.nextToken = function() {
var curContext = this.curContext();
return curContext && curContext.preserveSpace || this.skipSpace(), this.start = this.pos, 
this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(types$1.eof) : curContext.override ? curContext.override(this) : void this.readToken(this.fullCharCodeAtPos());
}, pp.readToken = function(code) {
return isIdentifierStart(code, this.options.ecmaVersion >= 6) || 92 === code ? this.readWord() : this.getTokenFromCode(code);
}, pp.fullCharCodeAtPos = function() {
var code = this.input.charCodeAt(this.pos);
if (code <= 55295 || code >= 56320) return code;
var next = this.input.charCodeAt(this.pos + 1);
return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
}, pp.skipBlockComment = function() {
var startLoc = this.options.onComment && this.curPosition(), start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
if (-1 === end && this.raise(this.pos - 2, "Unterminated comment"), this.pos = end + 2, 
this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) ++this.curLine, 
pos = this.lineStart = nextBreak;
this.options.onComment && this.options.onComment(!0, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
}, pp.skipLineComment = function(startSkip) {
for (var start = this.pos, startLoc = this.options.onComment && this.curPosition(), ch = this.input.charCodeAt(this.pos += startSkip); this.pos < this.input.length && !isNewLine(ch); ) ch = this.input.charCodeAt(++this.pos);
this.options.onComment && this.options.onComment(!1, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
}, pp.skipSpace = function() {
loop: for (;this.pos < this.input.length; ) {
var ch = this.input.charCodeAt(this.pos);
switch (ch) {
case 32:
case 160:
++this.pos;
break;

case 13:
10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;

case 10:
case 8232:
case 8233:
++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
break;

case 47:
switch (this.input.charCodeAt(this.pos + 1)) {
case 42:
this.skipBlockComment();
break;

case 47:
this.skipLineComment(2);
break;

default:
break loop;
}
break;

default:
if (!(ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))) break loop;
++this.pos;
}
}
}, pp.finishToken = function(type, val) {
this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
var prevType = this.type;
this.type = type, this.value = val, this.updateContext(prevType);
}, pp.readToken_dot = function() {
var next = this.input.charCodeAt(this.pos + 1);
if (next >= 48 && next <= 57) return this.readNumber(!0);
var next2 = this.input.charCodeAt(this.pos + 2);
return this.options.ecmaVersion >= 6 && 46 === next && 46 === next2 ? (this.pos += 3, 
this.finishToken(types$1.ellipsis)) : (++this.pos, this.finishToken(types$1.dot));
}, pp.readToken_slash = function() {
var next = this.input.charCodeAt(this.pos + 1);
return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === next ? this.finishOp(types$1.assign, 2) : this.finishOp(types$1.slash, 1);
}, pp.readToken_mult_modulo_exp = function(code) {
var next = this.input.charCodeAt(this.pos + 1), size = 1, tokentype = 42 === code ? types$1.star : types$1.modulo;
return this.options.ecmaVersion >= 7 && 42 === code && 42 === next && (++size, tokentype = types$1.starstar, 
next = this.input.charCodeAt(this.pos + 2)), 61 === next ? this.finishOp(types$1.assign, size + 1) : this.finishOp(tokentype, size);
}, pp.readToken_pipe_amp = function(code) {
var next = this.input.charCodeAt(this.pos + 1);
return next === code ? this.options.ecmaVersion >= 12 && 61 === this.input.charCodeAt(this.pos + 2) ? this.finishOp(types$1.assign, 3) : this.finishOp(124 === code ? types$1.logicalOR : types$1.logicalAND, 2) : 61 === next ? this.finishOp(types$1.assign, 2) : this.finishOp(124 === code ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
}, pp.readToken_caret = function() {
return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(types$1.assign, 2) : this.finishOp(types$1.bitwiseXOR, 1);
}, pp.readToken_plus_min = function(code) {
var next = this.input.charCodeAt(this.pos + 1);
return next === code ? 45 !== next || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(types$1.incDec, 2) : (this.skipLineComment(3), 
this.skipSpace(), this.nextToken()) : 61 === next ? this.finishOp(types$1.assign, 2) : this.finishOp(types$1.plusMin, 1);
}, pp.readToken_lt_gt = function(code) {
var next = this.input.charCodeAt(this.pos + 1), size = 1;
return next === code ? (size = 62 === code && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 
61 === this.input.charCodeAt(this.pos + size) ? this.finishOp(types$1.assign, size + 1) : this.finishOp(types$1.bitShift, size)) : 33 !== next || 60 !== code || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === next && (size = 2), 
this.finishOp(types$1.relational, size)) : (this.skipLineComment(4), this.skipSpace(), 
this.nextToken());
}, pp.readToken_eq_excl = function(code) {
var next = this.input.charCodeAt(this.pos + 1);
return 61 === next ? this.finishOp(types$1.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === code && 62 === next && this.options.ecmaVersion >= 6 ? (this.pos += 2, 
this.finishToken(types$1.arrow)) : this.finishOp(61 === code ? types$1.eq : types$1.prefix, 1);
}, pp.readToken_question = function() {
var ecmaVersion = this.options.ecmaVersion;
if (ecmaVersion >= 11) {
var next = this.input.charCodeAt(this.pos + 1);
if (46 === next) {
var next2 = this.input.charCodeAt(this.pos + 2);
if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
}
if (63 === next) return ecmaVersion >= 12 && 61 === this.input.charCodeAt(this.pos + 2) ? this.finishOp(types$1.assign, 3) : this.finishOp(types$1.coalesce, 2);
}
return this.finishOp(types$1.question, 1);
}, pp.readToken_numberSign = function() {
var code = 35;
if (this.options.ecmaVersion >= 13 && (++this.pos, isIdentifierStart(code = this.fullCharCodeAtPos(), !0) || 92 === code)) return this.finishToken(types$1.privateId, this.readWord1());
this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
}, pp.getTokenFromCode = function(code) {
switch (code) {
case 46:
return this.readToken_dot();

case 40:
return ++this.pos, this.finishToken(types$1.parenL);

case 41:
return ++this.pos, this.finishToken(types$1.parenR);

case 59:
return ++this.pos, this.finishToken(types$1.semi);

case 44:
return ++this.pos, this.finishToken(types$1.comma);

case 91:
return ++this.pos, this.finishToken(types$1.bracketL);

case 93:
return ++this.pos, this.finishToken(types$1.bracketR);

case 123:
return ++this.pos, this.finishToken(types$1.braceL);

case 125:
return ++this.pos, this.finishToken(types$1.braceR);

case 58:
return ++this.pos, this.finishToken(types$1.colon);

case 96:
if (this.options.ecmaVersion < 6) break;
return ++this.pos, this.finishToken(types$1.backQuote);

case 48:
var next = this.input.charCodeAt(this.pos + 1);
if (120 === next || 88 === next) return this.readRadixNumber(16);
if (this.options.ecmaVersion >= 6) {
if (111 === next || 79 === next) return this.readRadixNumber(8);
if (98 === next || 66 === next) return this.readRadixNumber(2);
}

case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
return this.readNumber(!1);

case 34:
case 39:
return this.readString(code);

case 47:
return this.readToken_slash();

case 37:
case 42:
return this.readToken_mult_modulo_exp(code);

case 124:
case 38:
return this.readToken_pipe_amp(code);

case 94:
return this.readToken_caret();

case 43:
case 45:
return this.readToken_plus_min(code);

case 60:
case 62:
return this.readToken_lt_gt(code);

case 61:
case 33:
return this.readToken_eq_excl(code);

case 63:
return this.readToken_question();

case 126:
return this.finishOp(types$1.prefix, 1);

case 35:
return this.readToken_numberSign();
}
this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
}, pp.finishOp = function(type, size) {
var str = this.input.slice(this.pos, this.pos + size);
return this.pos += size, this.finishToken(type, str);
}, pp.readRegexp = function() {
for (var escaped, inClass, start = this.pos; ;) {
this.pos >= this.input.length && this.raise(start, "Unterminated regular expression");
var ch = this.input.charAt(this.pos);
if (lineBreak.test(ch) && this.raise(start, "Unterminated regular expression"), 
escaped) escaped = !1; else {
if ("[" === ch) inClass = !0; else if ("]" === ch && inClass) inClass = !1; else if ("/" === ch && !inClass) break;
escaped = "\\" === ch;
}
++this.pos;
}
var pattern = this.input.slice(start, this.pos);
++this.pos;
var flagsStart = this.pos, flags = this.readWord1();
this.containsEsc && this.unexpected(flagsStart);
var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
state.reset(start, pattern, flags), this.validateRegExpFlags(state), this.validateRegExpPattern(state);
var value = null;
try {
value = new RegExp(pattern, flags);
} catch (e) {}
return this.finishToken(types$1.regexp, {
pattern,
flags,
value
});
}, pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
for (var allowSeparators = this.options.ecmaVersion >= 12 && void 0 === len, isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && 48 === this.input.charCodeAt(this.pos), start = this.pos, total = 0, lastCode = 0, i = 0, e = null == len ? 1 / 0 : len; i < e; ++i, 
++this.pos) {
var code = this.input.charCodeAt(this.pos), val = void 0;
if (allowSeparators && 95 === code) isLegacyOctalNumericLiteral && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 
95 === lastCode && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 
0 === i && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), 
lastCode = code; else {
if ((val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : code >= 48 && code <= 57 ? code - 48 : 1 / 0) >= radix) break;
lastCode = code, total = total * radix + val;
}
}
return allowSeparators && 95 === lastCode && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), 
this.pos === start || null != len && this.pos - start !== len ? null : total;
}, pp.readRadixNumber = function(radix) {
var start = this.pos;
this.pos += 2;
var val = this.readInt(radix);
return null == val && this.raise(this.start + 2, "Expected number in radix " + radix), 
this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (val = stringToBigInt(this.input.slice(start, this.pos)), 
++this.pos) : isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), 
this.finishToken(types$1.num, val);
}, pp.readNumber = function(startsWithDot) {
var start = this.pos;
startsWithDot || null !== this.readInt(10, void 0, !0) || this.raise(start, "Invalid number");
var octal = this.pos - start >= 2 && 48 === this.input.charCodeAt(start);
octal && this.strict && this.raise(start, "Invalid number");
var next = this.input.charCodeAt(this.pos);
if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && 110 === next) {
var val$1 = stringToBigInt(this.input.slice(start, this.pos));
return ++this.pos, isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), 
this.finishToken(types$1.num, val$1);
}
octal && /[89]/.test(this.input.slice(start, this.pos)) && (octal = !1), 46 !== next || octal || (++this.pos, 
this.readInt(10), next = this.input.charCodeAt(this.pos)), 69 !== next && 101 !== next || octal || (43 !== (next = this.input.charCodeAt(++this.pos)) && 45 !== next || ++this.pos, 
null === this.readInt(10) && this.raise(start, "Invalid number")), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
var val = stringToNumber(this.input.slice(start, this.pos), octal);
return this.finishToken(types$1.num, val);
}, pp.readCodePoint = function() {
var code;
if (123 === this.input.charCodeAt(this.pos)) {
this.options.ecmaVersion < 6 && this.unexpected();
var codePos = ++this.pos;
code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, 
code > 1114111 && this.invalidStringToken(codePos, "Code point out of bounds");
} else code = this.readHexChar(4);
return code;
}, pp.readString = function(quote) {
for (var out = "", chunkStart = ++this.pos; ;) {
this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
var ch = this.input.charCodeAt(this.pos);
if (ch === quote) break;
92 === ch ? (out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(!1), 
chunkStart = this.pos) : 8232 === ch || 8233 === ch ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), 
++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (isNewLine(ch) && this.raise(this.start, "Unterminated string constant"), 
++this.pos);
}
return out += this.input.slice(chunkStart, this.pos++), this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
this.inTemplateElement = !0;
try {
this.readTmplToken();
} catch (err) {
if (err !== INVALID_TEMPLATE_ESCAPE_ERROR) throw err;
this.readInvalidTemplateToken();
}
this.inTemplateElement = !1;
}, pp.invalidStringToken = function(position, message) {
if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
this.raise(position, message);
}, pp.readTmplToken = function() {
for (var out = "", chunkStart = this.pos; ;) {
this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
var ch = this.input.charCodeAt(this.pos);
if (96 === ch || 36 === ch && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== types$1.template && this.type !== types$1.invalidTemplate ? (out += this.input.slice(chunkStart, this.pos), 
this.finishToken(types$1.template, out)) : 36 === ch ? (this.pos += 2, this.finishToken(types$1.dollarBraceL)) : (++this.pos, 
this.finishToken(types$1.backQuote));
if (92 === ch) out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(!0), 
chunkStart = this.pos; else if (isNewLine(ch)) {
switch (out += this.input.slice(chunkStart, this.pos), ++this.pos, ch) {
case 13:
10 === this.input.charCodeAt(this.pos) && ++this.pos;

case 10:
out += "\n";
break;

default:
out += String.fromCharCode(ch);
}
this.options.locations && (++this.curLine, this.lineStart = this.pos), chunkStart = this.pos;
} else ++this.pos;
}
}, pp.readInvalidTemplateToken = function() {
for (;this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
case "\\":
++this.pos;
break;

case "$":
if ("{" !== this.input[this.pos + 1]) break;

case "`":
return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
}
this.raise(this.start, "Unterminated template");
}, pp.readEscapedChar = function(inTemplate) {
var ch = this.input.charCodeAt(++this.pos);
switch (++this.pos, ch) {
case 110:
return "\n";

case 114:
return "\r";

case 120:
return String.fromCharCode(this.readHexChar(2));

case 117:
return codePointToString(this.readCodePoint());

case 116:
return "\t";

case 98:
return "\b";

case 118:
return "\v";

case 102:
return "\f";

case 13:
10 === this.input.charCodeAt(this.pos) && ++this.pos;

case 10:
return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";

case 56:
case 57:
if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), 
inTemplate) {
var codePos = this.pos - 1;
return this.invalidStringToken(codePos, "Invalid escape sequence in template string"), 
null;
}

default:
if (ch >= 48 && ch <= 55) {
var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
return octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), 
this.pos += octalStr.length - 1, ch = this.input.charCodeAt(this.pos), "0" === octalStr && 56 !== ch && 57 !== ch || !this.strict && !inTemplate || this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"), 
String.fromCharCode(octal);
}
return isNewLine(ch) ? "" : String.fromCharCode(ch);
}
}, pp.readHexChar = function(len) {
var codePos = this.pos, n = this.readInt(16, len);
return null === n && this.invalidStringToken(codePos, "Bad character escape sequence"), 
n;
}, pp.readWord1 = function() {
this.containsEsc = !1;
for (var word = "", first = !0, chunkStart = this.pos, astral = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
var ch = this.fullCharCodeAtPos();
if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2; else {
if (92 !== ch) break;
this.containsEsc = !0, word += this.input.slice(chunkStart, this.pos);
var escStart = this.pos;
117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), 
++this.pos;
var esc = this.readCodePoint();
(first ? isIdentifierStart : isIdentifierChar)(esc, astral) || this.invalidStringToken(escStart, "Invalid Unicode escape"), 
word += codePointToString(esc), chunkStart = this.pos;
}
first = !1;
}
return word + this.input.slice(chunkStart, this.pos);
}, pp.readWord = function() {
var word = this.readWord1(), type = types$1.name;
return this.keywords.test(word) && (type = keywords[word]), this.finishToken(type, word);
};
var version = "8.7.1";
function parse(input, options) {
return Parser.parse(input, options);
}
function parseExpressionAt(input, pos, options) {
return Parser.parseExpressionAt(input, pos, options);
}
function tokenizer(input, options) {
return Parser.tokenizer(input, options);
}
Parser.acorn = {
Parser,
version,
defaultOptions,
Position,
SourceLocation,
getLineInfo,
Node,
TokenType,
tokTypes: types$1,
keywordTypes: keywords,
TokContext,
tokContexts: types,
isIdentifierChar,
isIdentifierStart,
Token,
isNewLine,
lineBreak,
lineBreakG,
nonASCIIwhitespace
}, exports.Node = Node, exports.Parser = Parser, exports.Position = Position, exports.SourceLocation = SourceLocation, 
exports.TokContext = TokContext, exports.Token = Token, exports.TokenType = TokenType, 
exports.defaultOptions = defaultOptions, exports.getLineInfo = getLineInfo, exports.isIdentifierChar = isIdentifierChar, 
exports.isIdentifierStart = isIdentifierStart, exports.isNewLine = isNewLine, exports.keywordTypes = keywords, 
exports.lineBreak = lineBreak, exports.lineBreakG = lineBreakG, exports.nonASCIIwhitespace = nonASCIIwhitespace, 
exports.parse = parse, exports.parseExpressionAt = parseExpressionAt, exports.tokContexts = types, 
exports.tokTypes = types$1, exports.tokenizer = tokenizer, exports.version = version, 
Object.defineProperty(exports, "__esModule", {
value: !0
});
}(exports);
},
6391: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
Object.defineProperty(exports, "__esModule", {
value: !0
}), exports.Tracer = void 0;
const stream_1 = __webpack_require__(12781);
class Tracer extends stream_1.Readable {
constructor(opts = {}) {
if (super(), this.noStream = !1, this.events = [], "object" != typeof opts) throw new Error("Invalid options passed (must be an object)");
if (null != opts.parent && "object" != typeof opts.parent) throw new Error("Invalid option (parent) passed (must be an object)");
if (null != opts.fields && "object" != typeof opts.fields) throw new Error("Invalid option (fields) passed (must be an object)");
if (null != opts.objectMode && !0 !== opts.objectMode && !1 !== opts.objectMode) throw new Error("Invalid option (objectsMode) passed (must be a boolean)");
if (this.noStream = opts.noStream || !1, this.parent = opts.parent, this.parent ? this.fields = Object.assign({}, opts.parent && opts.parent.fields) : this.fields = {}, 
opts.fields && Object.assign(this.fields, opts.fields), this.fields.cat ? Array.isArray(this.fields.cat) && (this.fields.cat = this.fields.cat.join(",")) : this.fields.cat = "default", 
this.fields.args || (this.fields.args = {}), this.parent) this._push = this.parent._push.bind(this.parent); else {
this._objectMode = Boolean(opts.objectMode);
var streamOpts = {
objectMode: this._objectMode
};
this._objectMode ? this._push = this.push : (this._push = this._pushString, streamOpts.encoding = "utf8"), 
stream_1.Readable.call(this, streamOpts);
}
}
flush() {
if (!0 === this.noStream) {
for (const evt of this.events) this._push(evt);
this._flush();
}
}
_read(_) {}
_pushString(ev) {
var separator = "";
this.firstPush ? separator = ",\n" : (this.push("["), this.firstPush = !0), this.push(separator + JSON.stringify(ev), "utf8");
}
_flush() {
this._objectMode || this.push("]");
}
child(fields) {
return new Tracer({
parent: this,
fields
});
}
begin(fields) {
return this.mkEventFunc("b")(fields);
}
end(fields) {
return this.mkEventFunc("e")(fields);
}
completeEvent(fields) {
return this.mkEventFunc("X")(fields);
}
instantEvent(fields) {
return this.mkEventFunc("I")(fields);
}
mkEventFunc(ph) {
return fields => {
var hrtime, ev = {
ts: 1e6 * (hrtime = process.hrtime())[0] + Math.round(hrtime[1] / 1e3),
pid: process.pid,
tid: process.pid
};
if (ev.ph = ph, fields) if ("string" == typeof fields) ev.name = fields; else for (const k of Object.keys(fields)) "cat" === k ? ev.cat = fields.cat.join(",") : ev[k] = fields[k];
this.noStream ? this.events.push(ev) : this._push(ev);
};
}
}
exports.Tracer = Tracer;
},
77398: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DescriptionFileUtils = __webpack_require__(77401), getInnerRequest = __webpack_require__(25292);
module.exports = class {
constructor(source, field, target) {
this.source = source, this.field = field, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("AliasFieldPlugin", ((request, resolveContext, callback) => {
if (!request.descriptionFileData) return callback();
const innerRequest = getInnerRequest(resolver, request);
if (!innerRequest) return callback();
const fieldData = DescriptionFileUtils.getField(request.descriptionFileData, this.field);
if (null === fieldData || "object" != typeof fieldData) return resolveContext.log && resolveContext.log("Field '" + this.field + "' doesn't contain a valid alias configuration"), 
callback();
const data = Object.prototype.hasOwnProperty.call(fieldData, innerRequest) ? fieldData[innerRequest] : innerRequest.startsWith("./") ? fieldData[innerRequest.slice(2)] : void 0;
if (data === innerRequest) return callback();
if (void 0 === data) return callback();
if (!1 === data) {
const ignoreObj = {
...request,
path: !1
};
return "function" == typeof resolveContext.yield ? (resolveContext.yield(ignoreObj), 
callback(null, null)) : callback(null, ignoreObj);
}
const obj = {
...request,
path: request.descriptionFileRoot,
request: data,
fullySpecified: !1
};
resolver.doResolve(target, obj, "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + data + "'", resolveContext, ((err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result)));
}));
}
};
},
75331: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const forEachBail = __webpack_require__(40836), {PathType, getType} = __webpack_require__(22931);
module.exports = class {
constructor(source, options, target) {
this.source = source, this.options = Array.isArray(options) ? options : [ options ], 
this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target), isSubPath = (path, maybeSubPath) => {
const absolutePath = (maybeAbsolutePath => {
const type = getType(maybeAbsolutePath);
return type === PathType.AbsolutePosix || type === PathType.AbsoluteWin ? resolver.join(maybeAbsolutePath, "_").slice(0, -1) : null;
})(maybeSubPath);
return !!absolutePath && path.startsWith(absolutePath);
};
resolver.getHook(this.source).tapAsync("AliasPlugin", ((request, resolveContext, callback) => {
const innerRequest = request.request || request.path;
if (!innerRequest) return callback();
forEachBail(this.options, ((item, callback) => {
let shouldStop = !1;
if (innerRequest === item.name || !item.onlyModule && (request.request ? innerRequest.startsWith(`${item.name}/`) : isSubPath(innerRequest, item.name))) {
const remainingRequest = innerRequest.substr(item.name.length), resolveWithAlias = (alias, callback) => {
if (!1 === alias) {
const ignoreObj = {
...request,
path: !1
};
return "function" == typeof resolveContext.yield ? (resolveContext.yield(ignoreObj), 
callback(null, null)) : callback(null, ignoreObj);
}
if (innerRequest !== alias && !innerRequest.startsWith(alias + "/")) {
shouldStop = !0;
const newRequestStr = alias + remainingRequest, obj = {
...request,
request: newRequestStr,
fullySpecified: !1
};
return resolver.doResolve(target, obj, "aliased with mapping '" + item.name + "': '" + alias + "' to '" + newRequestStr + "'", resolveContext, ((err, result) => err ? callback(err) : result ? callback(null, result) : callback()));
}
return callback();
}, stoppingCallback = (err, result) => err ? callback(err) : result ? callback(null, result) : shouldStop ? callback(null, null) : callback();
return Array.isArray(item.alias) ? forEachBail(item.alias, resolveWithAlias, stoppingCallback) : resolveWithAlias(item.alias, stoppingCallback);
}
return callback();
}), callback);
}));
}
};
},
73537: module => {
"use strict";
module.exports = class {
constructor(source, appending, target) {
this.source = source, this.appending = appending, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("AppendPlugin", ((request, resolveContext, callback) => {
const obj = {
...request,
path: request.path + this.appending,
relativePath: request.relativePath && request.relativePath + this.appending
};
resolver.doResolve(target, obj, this.appending, resolveContext, callback);
}));
}
};
},
38546: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const nextTick = __webpack_require__(77282).nextTick, dirname = path => {
let idx = path.length - 1;
for (;idx >= 0; ) {
const c = path.charCodeAt(idx);
if (47 === c || 92 === c) break;
idx--;
}
return idx < 0 ? "" : path.slice(0, idx);
}, runCallbacks = (callbacks, err, result) => {
if (1 === callbacks.length) return callbacks[0](err, result), void (callbacks.length = 0);
let error;
for (const callback of callbacks) try {
callback(err, result);
} catch (e) {
error || (error = e);
}
if (callbacks.length = 0, error) throw error;
};
class OperationMergerBackend {
constructor(provider, syncProvider, providerContext) {
this._provider = provider, this._syncProvider = syncProvider, this._providerContext = providerContext, 
this._activeAsyncOperations = new Map, this.provide = this._provider ? (path, options, callback) => {
if ("function" == typeof options && (callback = options, options = void 0), options) return this._provider.call(this._providerContext, path, options, callback);
if ("string" != typeof path) return void callback(new TypeError("path must be a string"));
let callbacks = this._activeAsyncOperations.get(path);
callbacks ? callbacks.push(callback) : (this._activeAsyncOperations.set(path, callbacks = [ callback ]), 
provider(path, ((err, result) => {
this._activeAsyncOperations.delete(path), runCallbacks(callbacks, err, result);
})));
} : null, this.provideSync = this._syncProvider ? (path, options) => this._syncProvider.call(this._providerContext, path, options) : null;
}
purge() {}
purgeParent() {}
}
class CacheBackend {
constructor(duration, provider, syncProvider, providerContext) {
this._duration = duration, this._provider = provider, this._syncProvider = syncProvider, 
this._providerContext = providerContext, this._activeAsyncOperations = new Map, 
this._data = new Map, this._levels = [];
for (let i = 0; i < 10; i++) this._levels.push(new Set);
for (let i = 5e3; i < duration; i += 500) this._levels.push(new Set);
this._currentLevel = 0, this._tickInterval = Math.floor(duration / this._levels.length), 
this._mode = 0, this._timeout = void 0, this._nextDecay = void 0, this.provide = provider ? this.provide.bind(this) : null, 
this.provideSync = syncProvider ? this.provideSync.bind(this) : null;
}
provide(path, options, callback) {
if ("function" == typeof options && (callback = options, options = void 0), "string" != typeof path) return void callback(new TypeError("path must be a string"));
if (options) return this._provider.call(this._providerContext, path, options, callback);
1 === this._mode && this._enterAsyncMode();
let cacheEntry = this._data.get(path);
if (void 0 !== cacheEntry) return cacheEntry.err ? nextTick(callback, cacheEntry.err) : nextTick(callback, null, cacheEntry.result);
let callbacks = this._activeAsyncOperations.get(path);
void 0 === callbacks ? (this._activeAsyncOperations.set(path, callbacks = [ callback ]), 
this._provider.call(this._providerContext, path, ((err, result) => {
this._activeAsyncOperations.delete(path), this._storeResult(path, err, result), 
this._enterAsyncMode(), runCallbacks(callbacks, err, result);
}))) : callbacks.push(callback);
}
provideSync(path, options) {
if ("string" != typeof path) throw new TypeError("path must be a string");
if (options) return this._syncProvider.call(this._providerContext, path, options);
1 === this._mode && this._runDecays();
let cacheEntry = this._data.get(path);
if (void 0 !== cacheEntry) {
if (cacheEntry.err) throw cacheEntry.err;
return cacheEntry.result;
}
const callbacks = this._activeAsyncOperations.get(path);
let result;
this._activeAsyncOperations.delete(path);
try {
result = this._syncProvider.call(this._providerContext, path);
} catch (err) {
throw this._storeResult(path, err, void 0), this._enterSyncModeWhenIdle(), callbacks && runCallbacks(callbacks, err, void 0), 
err;
}
return this._storeResult(path, void 0, result), this._enterSyncModeWhenIdle(), callbacks && runCallbacks(callbacks, void 0, result), 
result;
}
purge(what) {
if (what) if ("string" == typeof what) {
for (let [key, data] of this._data) key.startsWith(what) && (this._data.delete(key), 
data.level.delete(key));
0 === this._data.size && this._enterIdleMode();
} else {
for (let [key, data] of this._data) for (const item of what) if (key.startsWith(item)) {
this._data.delete(key), data.level.delete(key);
break;
}
0 === this._data.size && this._enterIdleMode();
} else if (0 !== this._mode) {
this._data.clear();
for (const level of this._levels) level.clear();
this._enterIdleMode();
}
}
purgeParent(what) {
if (what) if ("string" == typeof what) this.purge(dirname(what)); else {
const set = new Set;
for (const item of what) set.add(dirname(item));
this.purge(set);
} else this.purge();
}
_storeResult(path, err, result) {
if (this._data.has(path)) return;
const level = this._levels[this._currentLevel];
this._data.set(path, {
err,
result,
level
}), level.add(path);
}
_decayLevel() {
const nextLevel = (this._currentLevel + 1) % this._levels.length, decay = this._levels[nextLevel];
this._currentLevel = nextLevel;
for (let item of decay) this._data.delete(item);
decay.clear(), 0 === this._data.size ? this._enterIdleMode() : this._nextDecay += this._tickInterval;
}
_runDecays() {
for (;this._nextDecay <= Date.now() && 0 !== this._mode; ) this._decayLevel();
}
_enterAsyncMode() {
let timeout = 0;
switch (this._mode) {
case 2:
return;

case 0:
this._nextDecay = Date.now() + this._tickInterval, timeout = this._tickInterval;
break;

case 1:
if (this._runDecays(), 0 === this._mode) return;
timeout = Math.max(0, this._nextDecay - Date.now());
}
this._mode = 2;
const ref = setTimeout((() => {
this._mode = 1, this._runDecays();
}), timeout);
ref.unref && ref.unref(), this._timeout = ref;
}
_enterSyncModeWhenIdle() {
0 === this._mode && (this._mode = 1, this._nextDecay = Date.now() + this._tickInterval);
}
_enterIdleMode() {
this._mode = 0, this._nextDecay = void 0, this._timeout && clearTimeout(this._timeout);
}
}
const createBackend = (duration, provider, syncProvider, providerContext) => duration > 0 ? new CacheBackend(duration, provider, syncProvider, providerContext) : new OperationMergerBackend(provider, syncProvider, providerContext);
module.exports = class {
constructor(fileSystem, duration) {
this.fileSystem = fileSystem, this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);
const lstat = this._lstatBackend.provide;
this.lstat = lstat;
const lstatSync = this._lstatBackend.provideSync;
this.lstatSync = lstatSync, this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);
const stat = this._statBackend.provide;
this.stat = stat;
const statSync = this._statBackend.provideSync;
this.statSync = statSync, this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);
const readdir = this._readdirBackend.provide;
this.readdir = readdir;
const readdirSync = this._readdirBackend.provideSync;
this.readdirSync = readdirSync, this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);
const readFile = this._readFileBackend.provide;
this.readFile = readFile;
const readFileSync = this._readFileBackend.provideSync;
this.readFileSync = readFileSync, this._readJsonBackend = createBackend(duration, this.fileSystem.readJson || this.readFile && ((path, callback) => {
this.readFile(path, ((err, buffer) => {
if (err) return callback(err);
if (!buffer || 0 === buffer.length) return callback(new Error("No file content"));
let data;
try {
data = JSON.parse(buffer.toString("utf-8"));
} catch (e) {
return callback(e);
}
callback(null, data);
}));
}), this.fileSystem.readJsonSync || this.readFileSync && (path => {
const buffer = this.readFileSync(path);
return JSON.parse(buffer.toString("utf-8"));
}), this.fileSystem);
const readJson = this._readJsonBackend.provide;
this.readJson = readJson;
const readJsonSync = this._readJsonBackend.provideSync;
this.readJsonSync = readJsonSync, this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);
const readlink = this._readlinkBackend.provide;
this.readlink = readlink;
const readlinkSync = this._readlinkBackend.provideSync;
this.readlinkSync = readlinkSync;
}
purge(what) {
this._statBackend.purge(what), this._lstatBackend.purge(what), this._readdirBackend.purgeParent(what), 
this._readFileBackend.purge(what), this._readlinkBackend.purge(what), this._readJsonBackend.purge(what);
}
};
},
75896: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const basename = __webpack_require__(16637).basename;
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("CloneBasenamePlugin", ((request, resolveContext, callback) => {
const filename = basename(request.path), filePath = resolver.join(request.path, filename), obj = {
...request,
path: filePath,
relativePath: request.relativePath && resolver.join(request.relativePath, filename)
};
resolver.doResolve(target, obj, "using path: " + filePath, resolveContext, callback);
}));
}
};
},
59836: module => {
"use strict";
module.exports = class {
constructor(source, test, message, allowAlternatives, target) {
this.source = source, this.test = test, this.message = message, this.allowAlternatives = allowAlternatives, 
this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target), {test, message, allowAlternatives} = this, keys = Object.keys(test);
resolver.getHook(this.source).tapAsync("ConditionalPlugin", ((request, resolveContext, callback) => {
for (const prop of keys) if (request[prop] !== test[prop]) return callback();
resolver.doResolve(target, request, message, resolveContext, allowAlternatives ? callback : (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
}));
}
};
},
87093: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DescriptionFileUtils = __webpack_require__(77401);
module.exports = class {
constructor(source, filenames, pathIsFile, target) {
this.source = source, this.filenames = filenames, this.pathIsFile = pathIsFile, 
this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("DescriptionFilePlugin", ((request, resolveContext, callback) => {
const path = request.path;
if (!path) return callback();
const directory = this.pathIsFile ? DescriptionFileUtils.cdUp(path) : path;
if (!directory) return callback();
DescriptionFileUtils.loadDescriptionFile(resolver, directory, this.filenames, request.descriptionFilePath ? {
path: request.descriptionFilePath,
content: request.descriptionFileData,
directory: request.descriptionFileRoot
} : void 0, resolveContext, ((err, result) => {
if (err) return callback(err);
if (!result) return resolveContext.log && resolveContext.log(`No description file found in ${directory} or above`), 
callback();
const relativePath = "." + path.substr(result.directory.length).replace(/\\/g, "/"), obj = {
...request,
descriptionFilePath: result.path,
descriptionFileData: result.content,
descriptionFileRoot: result.directory,
relativePath
};
resolver.doResolve(target, obj, "using description file: " + result.path + " (relative path: " + relativePath + ")", resolveContext, ((err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result)));
}));
}));
}
};
},
77401: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const forEachBail = __webpack_require__(40836);
function cdUp(directory) {
if ("/" === directory) return null;
const i = directory.lastIndexOf("/"), j = directory.lastIndexOf("\\"), p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
return p < 0 ? null : directory.substr(0, p || 1);
}
exports.loadDescriptionFile = function(resolver, directory, filenames, oldInfo, resolveContext, callback) {
!function findDescriptionFile() {
if (oldInfo && oldInfo.directory === directory) return callback(null, oldInfo);
forEachBail(filenames, ((filename, callback) => {
const descriptionFilePath = resolver.join(directory, filename);
function onJson(err, content) {
if (err) return resolveContext.log ? resolveContext.log(descriptionFilePath + " (directory description file): " + err) : err.message = descriptionFilePath + " (directory description file): " + err, 
callback(err);
callback(null, {
content,
directory,
path: descriptionFilePath
});
}
resolver.fileSystem.readJson ? resolver.fileSystem.readJson(descriptionFilePath, ((err, content) => {
if (err) return void 0 !== err.code ? (resolveContext.missingDependencies && resolveContext.missingDependencies.add(descriptionFilePath), 
callback()) : (resolveContext.fileDependencies && resolveContext.fileDependencies.add(descriptionFilePath), 
onJson(err));
resolveContext.fileDependencies && resolveContext.fileDependencies.add(descriptionFilePath), 
onJson(null, content);
})) : resolver.fileSystem.readFile(descriptionFilePath, ((err, content) => {
if (err) return resolveContext.missingDependencies && resolveContext.missingDependencies.add(descriptionFilePath), 
callback();
let json;
if (resolveContext.fileDependencies && resolveContext.fileDependencies.add(descriptionFilePath), 
!content) return onJson(new Error("No content in file"));
try {
json = JSON.parse(content.toString());
} catch (e) {
return onJson(e);
}
onJson(null, json);
}));
}), ((err, result) => {
if (err) return callback(err);
if (result) return callback(null, result);
{
const dir = cdUp(directory);
return dir ? (directory = dir, findDescriptionFile()) : callback();
}
}));
}();
}, exports.getField = function(content, field) {
if (content) {
if (Array.isArray(field)) {
let current = content;
for (let j = 0; j < field.length; j++) {
if (null === current || "object" != typeof current) {
current = null;
break;
}
current = current[field[j]];
}
return current;
}
return content[field];
}
}, exports.cdUp = cdUp;
},
98055: module => {
"use strict";
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("DirectoryExistsPlugin", ((request, resolveContext, callback) => {
const fs = resolver.fileSystem, directory = request.path;
if (!directory) return callback();
fs.stat(directory, ((err, stat) => err || !stat ? (resolveContext.missingDependencies && resolveContext.missingDependencies.add(directory), 
resolveContext.log && resolveContext.log(directory + " doesn't exist"), callback()) : stat.isDirectory() ? (resolveContext.fileDependencies && resolveContext.fileDependencies.add(directory), 
void resolver.doResolve(target, request, `existing directory ${directory}`, resolveContext, callback)) : (resolveContext.missingDependencies && resolveContext.missingDependencies.add(directory), 
resolveContext.log && resolveContext.log(directory + " is not a directory"), callback())));
}));
}
};
},
42054: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), DescriptionFileUtils = __webpack_require__(77401), forEachBail = __webpack_require__(40836), {processExportsField} = __webpack_require__(14928), {parseIdentifier} = __webpack_require__(21757), {checkImportsExportsFieldTarget} = __webpack_require__(22931);
module.exports = class {
constructor(source, conditionNames, fieldNamePath, target) {
this.source = source, this.target = target, this.conditionNames = conditionNames, 
this.fieldName = fieldNamePath, this.fieldProcessorCache = new WeakMap;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("ExportsFieldPlugin", ((request, resolveContext, callback) => {
if (!request.descriptionFilePath) return callback();
if ("." !== request.relativePath || void 0 === request.request) return callback();
const remainingRequest = request.query || request.fragment ? ("." === request.request ? "./" : request.request) + request.query + request.fragment : request.request, exportsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
if (!exportsField) return callback();
if (request.directory) return callback(new Error(`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`));
let paths;
try {
let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);
void 0 === fieldProcessor && (fieldProcessor = processExportsField(exportsField), 
this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor)), paths = fieldProcessor(remainingRequest, this.conditionNames);
} catch (err) {
return resolveContext.log && resolveContext.log(`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`), 
callback(err);
}
if (0 === paths.length) return callback(new Error(`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`));
forEachBail(paths, ((p, callback) => {
const parsedIdentifier = parseIdentifier(p);
if (!parsedIdentifier) return callback();
const [relativePath, query, fragment] = parsedIdentifier, error = checkImportsExportsFieldTarget(relativePath);
if (error) return callback(error);
const obj = {
...request,
request: void 0,
path: path.join(request.descriptionFileRoot, relativePath),
relativePath,
query,
fragment
};
resolver.doResolve(target, obj, "using exports field: " + p, resolveContext, callback);
}), ((err, result) => callback(err, result || null)));
}));
}
};
},
38238: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const forEachBail = __webpack_require__(40836);
module.exports = class {
constructor(source, options, target) {
this.source = source, this.options = options, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target), {extension, alias} = this.options;
resolver.getHook(this.source).tapAsync("ExtensionAliasPlugin", ((request, resolveContext, callback) => {
const requestPath = request.request;
if (!requestPath || !requestPath.endsWith(extension)) return callback();
const resolve = (alias, callback) => {
resolver.doResolve(target, {
...request,
request: `${requestPath.slice(0, -extension.length)}${alias}`,
fullySpecified: !0
}, `aliased from extension alias with mapping '${extension}' to '${alias}'`, resolveContext, callback);
}, stoppingCallback = (err, result) => err ? callback(err) : callback(null, result || null);
"string" == typeof alias ? resolve(alias, stoppingCallback) : alias.length > 1 ? forEachBail(alias, resolve, stoppingCallback) : resolve(alias[0], stoppingCallback);
}));
}
};
},
10557: module => {
"use strict";
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target), fs = resolver.fileSystem;
resolver.getHook(this.source).tapAsync("FileExistsPlugin", ((request, resolveContext, callback) => {
const file = request.path;
if (!file) return callback();
fs.stat(file, ((err, stat) => err || !stat ? (resolveContext.missingDependencies && resolveContext.missingDependencies.add(file), 
resolveContext.log && resolveContext.log(file + " doesn't exist"), callback()) : stat.isFile() ? (resolveContext.fileDependencies && resolveContext.fileDependencies.add(file), 
void resolver.doResolve(target, request, "existing file: " + file, resolveContext, callback)) : (resolveContext.missingDependencies && resolveContext.missingDependencies.add(file), 
resolveContext.log && resolveContext.log(file + " is not a file"), callback())));
}));
}
};
},
44924: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), DescriptionFileUtils = __webpack_require__(77401), forEachBail = __webpack_require__(40836), {processImportsField} = __webpack_require__(14928), {parseIdentifier} = __webpack_require__(21757), {checkImportsExportsFieldTarget} = __webpack_require__(22931), dotCode = ".".charCodeAt(0);
module.exports = class {
constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage) {
this.source = source, this.targetFile = targetFile, this.targetPackage = targetPackage, 
this.conditionNames = conditionNames, this.fieldName = fieldNamePath, this.fieldProcessorCache = new WeakMap;
}
apply(resolver) {
const targetFile = resolver.ensureHook(this.targetFile), targetPackage = resolver.ensureHook(this.targetPackage);
resolver.getHook(this.source).tapAsync("ImportsFieldPlugin", ((request, resolveContext, callback) => {
if (!request.descriptionFilePath || void 0 === request.request) return callback();
const remainingRequest = request.request + request.query + request.fragment, importsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
if (!importsField) return callback();
if (request.directory) return callback(new Error(`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`));
let paths;
try {
let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);
void 0 === fieldProcessor && (fieldProcessor = processImportsField(importsField), 
this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor)), paths = fieldProcessor(remainingRequest, this.conditionNames);
} catch (err) {
return resolveContext.log && resolveContext.log(`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`), 
callback(err);
}
if (0 === paths.length) return callback(new Error(`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`));
forEachBail(paths, ((p, callback) => {
const parsedIdentifier = parseIdentifier(p);
if (!parsedIdentifier) return callback();
const [path_, query, fragment] = parsedIdentifier, error = checkImportsExportsFieldTarget(path_);
if (error) return callback(error);
switch (path_.charCodeAt(0)) {
case dotCode:
{
const obj = {
...request,
request: void 0,
path: path.join(request.descriptionFileRoot, path_),
relativePath: path_,
query,
fragment
};
resolver.doResolve(targetFile, obj, "using imports field: " + p, resolveContext, callback);
break;
}

default:
{
const obj = {
...request,
request: path_,
relativePath: path_,
fullySpecified: !0,
query,
fragment
};
resolver.doResolve(targetPackage, obj, "using imports field: " + p, resolveContext, callback);
}
}
}), ((err, result) => callback(err, result || null)));
}));
}
};
},
20327: module => {
"use strict";
const namespaceStartCharCode = "@".charCodeAt(0);
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("JoinRequestPartPlugin", ((request, resolveContext, callback) => {
const req = request.request || "";
let moduleName, remainingRequest, fullySpecified, i = req.indexOf("/", 3);
i >= 0 && req.charCodeAt(2) === namespaceStartCharCode && (i = req.indexOf("/", i + 1)), 
i < 0 ? (moduleName = req, remainingRequest = ".", fullySpecified = !1) : (moduleName = req.slice(0, i), 
remainingRequest = "." + req.slice(i), fullySpecified = request.fullySpecified);
const obj = {
...request,
path: resolver.join(request.path, moduleName),
relativePath: request.relativePath && resolver.join(request.relativePath, moduleName),
request: remainingRequest,
fullySpecified
};
resolver.doResolve(target, obj, null, resolveContext, callback);
}));
}
};
},
2680: module => {
"use strict";
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("JoinRequestPlugin", ((request, resolveContext, callback) => {
const obj = {
...request,
path: resolver.join(request.path, request.request),
relativePath: request.relativePath && resolver.join(request.relativePath, request.request),
request: void 0
};
resolver.doResolve(target, obj, null, resolveContext, callback);
}));
}
};
},
42609: module => {
"use strict";
module.exports = class {
constructor(source) {
this.source = source;
}
apply(resolver) {
const source = this.source;
resolver.getHook(this.source).tapAsync("LogInfoPlugin", ((request, resolveContext, callback) => {
if (!resolveContext.log) return callback();
const log = resolveContext.log, prefix = "[" + source + "] ";
request.path && log(prefix + "Resolving in directory: " + request.path), request.request && log(prefix + "Resolving request: " + request.request), 
request.module && log(prefix + "Request is an module request."), request.directory && log(prefix + "Request is a directory request."), 
request.query && log(prefix + "Resolving request query: " + request.query), request.fragment && log(prefix + "Resolving request fragment: " + request.fragment), 
request.descriptionFilePath && log(prefix + "Has description data from " + request.descriptionFilePath), 
request.relativePath && log(prefix + "Relative path from description file is: " + request.relativePath), 
callback();
}));
}
};
},
58738: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), DescriptionFileUtils = __webpack_require__(77401), alreadyTriedMainField = Symbol("alreadyTriedMainField");
module.exports = class {
constructor(source, options, target) {
this.source = source, this.options = options, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("MainFieldPlugin", ((request, resolveContext, callback) => {
if (request.path !== request.descriptionFileRoot || request[alreadyTriedMainField] === request.descriptionFilePath || !request.descriptionFilePath) return callback();
const filename = path.basename(request.descriptionFilePath);
let mainModule = DescriptionFileUtils.getField(request.descriptionFileData, this.options.name);
if (!mainModule || "string" != typeof mainModule || "." === mainModule || "./" === mainModule) return callback();
this.options.forceRelative && !/^\.\.?\//.test(mainModule) && (mainModule = "./" + mainModule);
const obj = {
...request,
request: mainModule,
module: !1,
directory: mainModule.endsWith("/"),
[alreadyTriedMainField]: request.descriptionFilePath
};
return resolver.doResolve(target, obj, "use " + mainModule + " from " + this.options.name + " in " + filename, resolveContext, callback);
}));
}
};
},
11775: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const forEachBail = __webpack_require__(40836), getPaths = __webpack_require__(16637);
module.exports = class {
constructor(source, directories, target) {
this.source = source, this.directories = [].concat(directories), this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("ModulesInHierarchicalDirectoriesPlugin", ((request, resolveContext, callback) => {
const fs = resolver.fileSystem, addrs = getPaths(request.path).paths.map((p => this.directories.map((d => resolver.join(p, d))))).reduce(((array, p) => (array.push.apply(array, p), 
array)), []);
forEachBail(addrs, ((addr, callback) => {
fs.stat(addr, ((err, stat) => {
if (!err && stat && stat.isDirectory()) {
const obj = {
...request,
path: addr,
request: "./" + request.request,
module: !1
}, message = "looking for modules in " + addr;
return resolver.doResolve(target, obj, message, resolveContext, callback);
}
return resolveContext.log && resolveContext.log(addr + " doesn't exist or is not a directory"), 
resolveContext.missingDependencies && resolveContext.missingDependencies.add(addr), 
callback();
}));
}), callback);
}));
}
};
},
54273: module => {
"use strict";
module.exports = class {
constructor(source, path, target) {
this.source = source, this.path = path, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("ModulesInRootPlugin", ((request, resolveContext, callback) => {
const obj = {
...request,
path: this.path,
request: "./" + request.request,
module: !1
};
resolver.doResolve(target, obj, "looking for modules in " + this.path, resolveContext, callback);
}));
}
};
},
9125: module => {
"use strict";
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("NextPlugin", ((request, resolveContext, callback) => {
resolver.doResolve(target, request, null, resolveContext, callback);
}));
}
};
},
46953: module => {
"use strict";
module.exports = class {
constructor(source, requestOptions, target) {
this.source = source, this.requestOptions = requestOptions, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("ParsePlugin", ((request, resolveContext, callback) => {
const parsed = resolver.parse(request.request), obj = {
...request,
...parsed,
...this.requestOptions
};
if (request.query && !parsed.query && (obj.query = request.query), request.fragment && !parsed.fragment && (obj.fragment = request.fragment), 
parsed && resolveContext.log && (parsed.module && resolveContext.log("Parsed request is a module"), 
parsed.directory && resolveContext.log("Parsed request is a directory")), obj.request && !obj.query && obj.fragment) {
const directory = obj.fragment.endsWith("/"), alternative = {
...obj,
directory,
request: obj.request + (obj.directory ? "/" : "") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),
fragment: ""
};
resolver.doResolve(target, alternative, null, resolveContext, ((err, result) => err ? callback(err) : result ? callback(null, result) : void resolver.doResolve(target, obj, null, resolveContext, callback)));
} else resolver.doResolve(target, obj, null, resolveContext, callback);
}));
}
};
},
2254: module => {
"use strict";
module.exports = class {
constructor(source, pnpApi, target) {
this.source = source, this.pnpApi = pnpApi, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("PnpPlugin", ((request, resolveContext, callback) => {
const req = request.request;
if (!req) return callback();
const issuer = `${request.path}/`, packageMatch = /^(@[^/]+\/)?[^/]+/.exec(req);
if (!packageMatch) return callback();
const packageName = packageMatch[0], innerRequest = `.${req.slice(packageName.length)}`;
let resolution, apiResolution;
try {
resolution = this.pnpApi.resolveToUnqualified(packageName, issuer, {
considerBuiltins: !1
}), resolveContext.fileDependencies && (apiResolution = this.pnpApi.resolveToUnqualified("pnpapi", issuer, {
considerBuiltins: !1
}));
} catch (error) {
if ("MODULE_NOT_FOUND" === error.code && "UNDECLARED_DEPENDENCY" === error.pnpCode) {
if (resolveContext.log) {
resolveContext.log("request is not managed by the pnpapi");
for (const line of error.message.split("\n").filter(Boolean)) resolveContext.log(`  ${line}`);
}
return callback();
}
return callback(error);
}
if (resolution === packageName) return callback();
apiResolution && resolveContext.fileDependencies && resolveContext.fileDependencies.add(apiResolution);
const obj = {
...request,
path: resolution,
request: innerRequest,
ignoreSymlinks: !0,
fullySpecified: request.fullySpecified && "." !== innerRequest
};
resolver.doResolve(target, obj, `resolved by pnp to ${resolution}`, resolveContext, ((err, result) => err ? callback(err) : callback(null, result || null)));
}));
}
};
},
43557: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {AsyncSeriesBailHook, AsyncSeriesHook, SyncHook} = __webpack_require__(89991), createInnerContext = __webpack_require__(58112), {parseIdentifier} = __webpack_require__(21757), {normalize, cachedJoin: join, getType, PathType} = __webpack_require__(22931);
function toCamelCase(str) {
return str.replace(/-([a-z])/g, (str => str.substr(1).toUpperCase()));
}
class Resolver {
static createStackEntry(hook, request) {
return hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.fragment || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
}
constructor(fileSystem, options) {
this.fileSystem = fileSystem, this.options = options, this.hooks = {
resolveStep: new SyncHook([ "hook", "request" ], "resolveStep"),
noResolve: new SyncHook([ "request", "error" ], "noResolve"),
resolve: new AsyncSeriesBailHook([ "request", "resolveContext" ], "resolve"),
result: new AsyncSeriesHook([ "result", "resolveContext" ], "result")
};
}
ensureHook(name) {
if ("string" != typeof name) return name;
if (name = toCamelCase(name), /^before/.test(name)) return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({
stage: -10
});
if (/^after/.test(name)) return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({
stage: 10
});
const hook = this.hooks[name];
return hook || (this.hooks[name] = new AsyncSeriesBailHook([ "request", "resolveContext" ], name));
}
getHook(name) {
if ("string" != typeof name) return name;
if (name = toCamelCase(name), /^before/.test(name)) return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({
stage: -10
});
if (/^after/.test(name)) return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({
stage: 10
});
const hook = this.hooks[name];
if (!hook) throw new Error(`Hook ${name} doesn't exist`);
return hook;
}
resolveSync(context, path, request) {
let err, result, sync = !1;
if (this.resolve(context, path, request, {}, ((e, r) => {
err = e, result = r, sync = !0;
})), !sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
if (err) throw err;
if (void 0 === result) throw new Error("No result");
return result;
}
resolve(context, path, request, resolveContext, callback) {
if (!context || "object" != typeof context) return callback(new Error("context argument is not an object"));
if ("string" != typeof path) return callback(new Error("path argument is not a string"));
if ("string" != typeof request) return callback(new Error("request argument is not a string"));
if (!resolveContext) return callback(new Error("resolveContext argument is not set"));
const obj = {
context,
path,
request
};
let yield_, finishYield, yieldCalled = !1;
if ("function" == typeof resolveContext.yield) {
const old = resolveContext.yield;
yield_ = obj => {
old(obj), yieldCalled = !0;
}, finishYield = result => {
result && yield_(result), callback(null);
};
}
const message = `resolve '${request}' in '${path}'`, finishResolved = result => callback(null, !1 !== result.path && `${result.path.replace(/#/g, "\0#")}${result.query ? result.query.replace(/#/g, "\0#") : ""}${result.fragment || ""}`, result), finishWithoutResolve = log => {
const error = new Error("Can't " + message);
return error.details = log.join("\n"), this.hooks.noResolve.call(obj, error), callback(error);
};
if (resolveContext.log) {
const parentLog = resolveContext.log, log = [];
return this.doResolve(this.hooks.resolve, obj, message, {
log: msg => {
parentLog(msg), log.push(msg);
},
yield: yield_,
fileDependencies: resolveContext.fileDependencies,
contextDependencies: resolveContext.contextDependencies,
missingDependencies: resolveContext.missingDependencies,
stack: resolveContext.stack
}, ((err, result) => err ? callback(err) : yieldCalled || result && yield_ ? finishYield(result) : result ? finishResolved(result) : finishWithoutResolve(log)));
}
return this.doResolve(this.hooks.resolve, obj, message, {
log: void 0,
yield: yield_,
fileDependencies: resolveContext.fileDependencies,
contextDependencies: resolveContext.contextDependencies,
missingDependencies: resolveContext.missingDependencies,
stack: resolveContext.stack
}, ((err, result) => {
if (err) return callback(err);
if (yieldCalled || result && yield_) return finishYield(result);
if (result) return finishResolved(result);
const log = [];
return this.doResolve(this.hooks.resolve, obj, message, {
log: msg => log.push(msg),
yield: yield_,
stack: resolveContext.stack
}, ((err, result) => err ? callback(err) : yieldCalled || result && yield_ ? finishYield(result) : finishWithoutResolve(log)));
}));
}
doResolve(hook, request, message, resolveContext, callback) {
const stackEntry = Resolver.createStackEntry(hook, request);
let newStack;
if (resolveContext.stack) {
if (newStack = new Set(resolveContext.stack), resolveContext.stack.has(stackEntry)) {
const recursionError = new Error("Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  "));
return recursionError.recursion = !0, resolveContext.log && resolveContext.log("abort resolving because of recursion"), 
callback(recursionError);
}
newStack.add(stackEntry);
} else newStack = new Set([ stackEntry ]);
if (this.hooks.resolveStep.call(hook, request), hook.isUsed()) {
const innerContext = createInnerContext({
log: resolveContext.log,
yield: resolveContext.yield,
fileDependencies: resolveContext.fileDependencies,
contextDependencies: resolveContext.contextDependencies,
missingDependencies: resolveContext.missingDependencies,
stack: newStack
}, message);
return hook.callAsync(request, innerContext, ((err, result) => err ? callback(err) : result ? callback(null, result) : void callback()));
}
callback();
}
parse(identifier) {
const part = {
request: "",
query: "",
fragment: "",
module: !1,
directory: !1,
file: !1,
internal: !1
}, parsedIdentifier = parseIdentifier(identifier);
return parsedIdentifier ? ([part.request, part.query, part.fragment] = parsedIdentifier, 
part.request.length > 0 && (part.internal = this.isPrivate(identifier), part.module = this.isModule(part.request), 
part.directory = this.isDirectory(part.request), part.directory && (part.request = part.request.substr(0, part.request.length - 1))), 
part) : part;
}
isModule(path) {
return getType(path) === PathType.Normal;
}
isPrivate(path) {
return getType(path) === PathType.Internal;
}
isDirectory(path) {
return path.endsWith("/");
}
join(path, request) {
return join(path, request);
}
normalize(path) {
return normalize(path);
}
}
module.exports = Resolver;
},
97446: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const versions = __webpack_require__(77282).versions, Resolver = __webpack_require__(43557), {getType, PathType} = __webpack_require__(22931), SyncAsyncFileSystemDecorator = __webpack_require__(90013), AliasFieldPlugin = __webpack_require__(77398), AliasPlugin = __webpack_require__(75331), AppendPlugin = __webpack_require__(73537), ConditionalPlugin = __webpack_require__(59836), DescriptionFilePlugin = __webpack_require__(87093), DirectoryExistsPlugin = __webpack_require__(98055), ExportsFieldPlugin = __webpack_require__(42054), ExtensionAliasPlugin = __webpack_require__(38238), FileExistsPlugin = __webpack_require__(10557), ImportsFieldPlugin = __webpack_require__(44924), JoinRequestPartPlugin = __webpack_require__(20327), JoinRequestPlugin = __webpack_require__(2680), MainFieldPlugin = __webpack_require__(58738), ModulesInHierarchicalDirectoriesPlugin = __webpack_require__(11775), ModulesInRootPlugin = __webpack_require__(54273), NextPlugin = __webpack_require__(9125), ParsePlugin = __webpack_require__(46953), PnpPlugin = __webpack_require__(2254), RestrictionsPlugin = __webpack_require__(73237), ResultPlugin = __webpack_require__(39913), RootsPlugin = __webpack_require__(22769), SelfReferencePlugin = __webpack_require__(12869), SymlinkPlugin = __webpack_require__(93712), TryNextPlugin = __webpack_require__(35345), UnsafeCachePlugin = __webpack_require__(79421), UseFilePlugin = __webpack_require__(3012);
function normalizeAlias(alias) {
return "object" != typeof alias || Array.isArray(alias) || null === alias ? alias || [] : Object.keys(alias).map((key => {
const obj = {
name: key,
onlyModule: !1,
alias: alias[key]
};
return /\$$/.test(key) && (obj.onlyModule = !0, obj.name = key.substr(0, key.length - 1)), 
obj;
}));
}
function mergeFilteredToArray(array, filter) {
const result = [], set = new Set(array);
for (const item of set) if (filter(item)) {
const lastElement = result.length > 0 ? result[result.length - 1] : void 0;
Array.isArray(lastElement) ? lastElement.push(item) : result.push([ item ]);
} else result.push(item);
return result;
}
exports.createResolver = function(options) {
const normalizedOptions = function(options) {
const mainFieldsSet = new Set(options.mainFields || [ "main" ]), mainFields = [];
for (const item of mainFieldsSet) "string" == typeof item ? mainFields.push({
name: [ item ],
forceRelative: !0
}) : Array.isArray(item) ? mainFields.push({
name: item,
forceRelative: !0
}) : mainFields.push({
name: Array.isArray(item.name) ? item.name : [ item.name ],
forceRelative: item.forceRelative
});
return {
alias: normalizeAlias(options.alias),
fallback: normalizeAlias(options.fallback),
aliasFields: new Set(options.aliasFields),
cachePredicate: options.cachePredicate || function() {
return !0;
},
cacheWithContext: void 0 === options.cacheWithContext || options.cacheWithContext,
exportsFields: new Set(options.exportsFields || [ "exports" ]),
importsFields: new Set(options.importsFields || [ "imports" ]),
conditionNames: new Set(options.conditionNames),
descriptionFiles: Array.from(new Set(options.descriptionFiles || [ "package.json" ])),
enforceExtension: void 0 === options.enforceExtension ? !(!options.extensions || !options.extensions.includes("")) : options.enforceExtension,
extensions: new Set(options.extensions || [ ".js", ".json", ".node" ]),
extensionAlias: options.extensionAlias ? Object.keys(options.extensionAlias).map((k => ({
extension: k,
alias: options.extensionAlias[k]
}))) : [],
fileSystem: options.useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(options.fileSystem) : options.fileSystem,
unsafeCache: options.unsafeCache && "object" != typeof options.unsafeCache ? {} : options.unsafeCache || !1,
symlinks: void 0 === options.symlinks || options.symlinks,
resolver: options.resolver,
modules: mergeFilteredToArray(Array.isArray(options.modules) ? options.modules : options.modules ? [ options.modules ] : [ "node_modules" ], (item => {
const type = getType(item);
return type === PathType.Normal || type === PathType.Relative;
})),
mainFields,
mainFiles: new Set(options.mainFiles || [ "index" ]),
plugins: options.plugins || [],
pnpApi: (option = options.pnpApi, void 0 === option && versions.pnp ? __webpack_require__(35125) : option || null),
roots: new Set(options.roots || void 0),
fullySpecified: options.fullySpecified || !1,
resolveToContext: options.resolveToContext || !1,
preferRelative: options.preferRelative || !1,
preferAbsolute: options.preferAbsolute || !1,
restrictions: new Set(options.restrictions)
};
var option;
}(options), {alias, fallback, aliasFields, cachePredicate, cacheWithContext, conditionNames, descriptionFiles, enforceExtension, exportsFields, extensionAlias, importsFields, extensions, fileSystem, fullySpecified, mainFields, mainFiles, modules, plugins: userPlugins, pnpApi, resolveToContext, preferRelative, preferAbsolute, symlinks, unsafeCache, resolver: customResolver, restrictions, roots} = normalizedOptions, plugins = userPlugins.slice(), resolver = customResolver || new Resolver(fileSystem, normalizedOptions);
resolver.ensureHook("resolve"), resolver.ensureHook("internalResolve"), resolver.ensureHook("newInternalResolve"), 
resolver.ensureHook("parsedResolve"), resolver.ensureHook("describedResolve"), resolver.ensureHook("rawResolve"), 
resolver.ensureHook("normalResolve"), resolver.ensureHook("internal"), resolver.ensureHook("rawModule"), 
resolver.ensureHook("module"), resolver.ensureHook("resolveAsModule"), resolver.ensureHook("undescribedResolveInPackage"), 
resolver.ensureHook("resolveInPackage"), resolver.ensureHook("resolveInExistingDirectory"), 
resolver.ensureHook("relative"), resolver.ensureHook("describedRelative"), resolver.ensureHook("directory"), 
resolver.ensureHook("undescribedExistingDirectory"), resolver.ensureHook("existingDirectory"), 
resolver.ensureHook("undescribedRawFile"), resolver.ensureHook("rawFile"), resolver.ensureHook("file"), 
resolver.ensureHook("finalFile"), resolver.ensureHook("existingFile"), resolver.ensureHook("resolved"), 
resolver.hooks.newInteralResolve = resolver.hooks.newInternalResolve;
for (const {source, resolveOptions} of [ {
source: "resolve",
resolveOptions: {
fullySpecified
}
}, {
source: "internal-resolve",
resolveOptions: {
fullySpecified: !1
}
} ]) unsafeCache ? (plugins.push(new UnsafeCachePlugin(source, cachePredicate, unsafeCache, cacheWithContext, `new-${source}`)), 
plugins.push(new ParsePlugin(`new-${source}`, resolveOptions, "parsed-resolve"))) : plugins.push(new ParsePlugin(source, resolveOptions, "parsed-resolve"));
plugins.push(new DescriptionFilePlugin("parsed-resolve", descriptionFiles, !1, "described-resolve")), 
plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve")), plugins.push(new NextPlugin("described-resolve", "raw-resolve")), 
fallback.length > 0 && plugins.push(new AliasPlugin("described-resolve", fallback, "internal-resolve")), 
alias.length > 0 && plugins.push(new AliasPlugin("raw-resolve", alias, "internal-resolve")), 
aliasFields.forEach((item => {
plugins.push(new AliasFieldPlugin("raw-resolve", item, "internal-resolve"));
})), extensionAlias.forEach((item => plugins.push(new ExtensionAliasPlugin("raw-resolve", item, "normal-resolve")))), 
plugins.push(new NextPlugin("raw-resolve", "normal-resolve")), preferRelative && plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative")), 
plugins.push(new ConditionalPlugin("after-normal-resolve", {
module: !0
}, "resolve as module", !1, "raw-module")), plugins.push(new ConditionalPlugin("after-normal-resolve", {
internal: !0
}, "resolve as internal import", !1, "internal")), preferAbsolute && plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative")), 
roots.size > 0 && plugins.push(new RootsPlugin("after-normal-resolve", roots, "relative")), 
preferRelative || preferAbsolute || plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative")), 
importsFields.forEach((importsField => {
plugins.push(new ImportsFieldPlugin("internal", conditionNames, importsField, "relative", "internal-resolve"));
})), exportsFields.forEach((exportsField => {
plugins.push(new SelfReferencePlugin("raw-module", exportsField, "resolve-as-module"));
})), modules.forEach((item => {
Array.isArray(item) ? item.includes("node_modules") && pnpApi ? (plugins.push(new ModulesInHierarchicalDirectoriesPlugin("raw-module", item.filter((i => "node_modules" !== i)), "module")), 
plugins.push(new PnpPlugin("raw-module", pnpApi, "undescribed-resolve-in-package"))) : plugins.push(new ModulesInHierarchicalDirectoriesPlugin("raw-module", item, "module")) : plugins.push(new ModulesInRootPlugin("raw-module", item, "module"));
})), plugins.push(new JoinRequestPartPlugin("module", "resolve-as-module")), resolveToContext || plugins.push(new ConditionalPlugin("resolve-as-module", {
directory: !1,
request: "."
}, "single file module", !0, "undescribed-raw-file")), plugins.push(new DirectoryExistsPlugin("resolve-as-module", "undescribed-resolve-in-package")), 
plugins.push(new DescriptionFilePlugin("undescribed-resolve-in-package", descriptionFiles, !1, "resolve-in-package")), 
plugins.push(new NextPlugin("after-undescribed-resolve-in-package", "resolve-in-package")), 
exportsFields.forEach((exportsField => {
plugins.push(new ExportsFieldPlugin("resolve-in-package", conditionNames, exportsField, "relative"));
})), plugins.push(new NextPlugin("resolve-in-package", "resolve-in-existing-directory")), 
plugins.push(new JoinRequestPlugin("resolve-in-existing-directory", "relative")), 
plugins.push(new DescriptionFilePlugin("relative", descriptionFiles, !0, "described-relative")), 
plugins.push(new NextPlugin("after-relative", "described-relative")), resolveToContext ? plugins.push(new NextPlugin("described-relative", "directory")) : (plugins.push(new ConditionalPlugin("described-relative", {
directory: !1
}, null, !0, "raw-file")), plugins.push(new ConditionalPlugin("described-relative", {
fullySpecified: !1
}, "as directory", !0, "directory"))), plugins.push(new DirectoryExistsPlugin("directory", "undescribed-existing-directory")), 
resolveToContext ? plugins.push(new NextPlugin("undescribed-existing-directory", "resolved")) : (plugins.push(new DescriptionFilePlugin("undescribed-existing-directory", descriptionFiles, !1, "existing-directory")), 
mainFiles.forEach((item => {
plugins.push(new UseFilePlugin("undescribed-existing-directory", item, "undescribed-raw-file"));
})), mainFields.forEach((item => {
plugins.push(new MainFieldPlugin("existing-directory", item, "resolve-in-existing-directory"));
})), mainFiles.forEach((item => {
plugins.push(new UseFilePlugin("existing-directory", item, "undescribed-raw-file"));
})), plugins.push(new DescriptionFilePlugin("undescribed-raw-file", descriptionFiles, !0, "raw-file")), 
plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file")), plugins.push(new ConditionalPlugin("raw-file", {
fullySpecified: !0
}, null, !1, "file")), enforceExtension || plugins.push(new TryNextPlugin("raw-file", "no extension", "file")), 
extensions.forEach((item => {
plugins.push(new AppendPlugin("raw-file", item, "file"));
})), alias.length > 0 && plugins.push(new AliasPlugin("file", alias, "internal-resolve")), 
aliasFields.forEach((item => {
plugins.push(new AliasFieldPlugin("file", item, "internal-resolve"));
})), plugins.push(new NextPlugin("file", "final-file")), plugins.push(new FileExistsPlugin("final-file", "existing-file")), 
symlinks && plugins.push(new SymlinkPlugin("existing-file", "existing-file")), plugins.push(new NextPlugin("existing-file", "resolved"))), 
restrictions.size > 0 && plugins.push(new RestrictionsPlugin(resolver.hooks.resolved, restrictions)), 
plugins.push(new ResultPlugin(resolver.hooks.resolved));
for (const plugin of plugins) "function" == typeof plugin ? plugin.call(resolver, resolver) : plugin.apply(resolver);
return resolver;
};
},
73237: module => {
"use strict";
const slashCode = "/".charCodeAt(0), backslashCode = "\\".charCodeAt(0), isInside = (path, parent) => {
if (!path.startsWith(parent)) return !1;
if (path.length === parent.length) return !0;
const charCode = path.charCodeAt(parent.length);
return charCode === slashCode || charCode === backslashCode;
};
module.exports = class {
constructor(source, restrictions) {
this.source = source, this.restrictions = restrictions;
}
apply(resolver) {
resolver.getHook(this.source).tapAsync("RestrictionsPlugin", ((request, resolveContext, callback) => {
if ("string" == typeof request.path) {
const path = request.path;
for (const rule of this.restrictions) if ("string" == typeof rule) {
if (!isInside(path, rule)) return resolveContext.log && resolveContext.log(`${path} is not inside of the restriction ${rule}`), 
callback(null, null);
} else if (!rule.test(path)) return resolveContext.log && resolveContext.log(`${path} doesn't match the restriction ${rule}`), 
callback(null, null);
}
callback();
}));
}
};
},
39913: module => {
"use strict";
module.exports = class {
constructor(source) {
this.source = source;
}
apply(resolver) {
this.source.tapAsync("ResultPlugin", ((request, resolverContext, callback) => {
const obj = {
...request
};
resolverContext.log && resolverContext.log("reporting result " + obj.path), resolver.hooks.result.callAsync(obj, resolverContext, (err => {
if (err) return callback(err);
"function" == typeof resolverContext.yield ? (resolverContext.yield(obj), callback(null, null)) : callback(null, obj);
}));
}));
}
};
},
22769: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const forEachBail = __webpack_require__(40836);
module.exports = class {
constructor(source, roots, target) {
this.roots = Array.from(roots), this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("RootsPlugin", ((request, resolveContext, callback) => {
const req = request.request;
return req && req.startsWith("/") ? void forEachBail(this.roots, ((root, callback) => {
const path = resolver.join(root, req.slice(1)), obj = {
...request,
path,
relativePath: request.relativePath && path
};
resolver.doResolve(target, obj, `root path ${root}`, resolveContext, callback);
}), callback) : callback();
}));
}
};
},
12869: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DescriptionFileUtils = __webpack_require__(77401), slashCode = "/".charCodeAt(0);
module.exports = class {
constructor(source, fieldNamePath, target) {
this.source = source, this.target = target, this.fieldName = fieldNamePath;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("SelfReferencePlugin", ((request, resolveContext, callback) => {
if (!request.descriptionFilePath) return callback();
const req = request.request;
if (!req) return callback();
if (!DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName)) return callback();
const name = DescriptionFileUtils.getField(request.descriptionFileData, "name");
if ("string" != typeof name) return callback();
if (!req.startsWith(name) || req.length !== name.length && req.charCodeAt(name.length) !== slashCode) return callback();
{
const remainingRequest = `.${req.slice(name.length)}`, obj = {
...request,
request: remainingRequest,
path: request.descriptionFileRoot,
relativePath: "."
};
resolver.doResolve(target, obj, "self reference", resolveContext, callback);
}
}));
}
};
},
93712: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const forEachBail = __webpack_require__(40836), getPaths = __webpack_require__(16637), {getType, PathType} = __webpack_require__(22931);
module.exports = class {
constructor(source, target) {
this.source = source, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target), fs = resolver.fileSystem;
resolver.getHook(this.source).tapAsync("SymlinkPlugin", ((request, resolveContext, callback) => {
if (request.ignoreSymlinks) return callback();
const pathsResult = getPaths(request.path), pathSegments = pathsResult.segments, paths = pathsResult.paths;
let containsSymlink = !1, idx = -1;
forEachBail(paths, ((path, callback) => {
idx++, resolveContext.fileDependencies && resolveContext.fileDependencies.add(path), 
fs.readlink(path, ((err, result) => {
if (!err && result) {
pathSegments[idx] = result, containsSymlink = !0;
const resultType = getType(result.toString());
if (resultType === PathType.AbsoluteWin || resultType === PathType.AbsolutePosix) return callback(null, idx);
}
callback();
}));
}), ((err, idx) => {
if (!containsSymlink) return callback();
const result = ("number" == typeof idx ? pathSegments.slice(0, idx + 1) : pathSegments.slice()).reduceRight(((a, b) => resolver.join(a, b))), obj = {
...request,
path: result
};
resolver.doResolve(target, obj, "resolved symlink to " + result, resolveContext, callback);
}));
}));
}
};
},
90013: module => {
"use strict";
module.exports = function(fs) {
this.fs = fs, this.lstat = void 0, this.lstatSync = void 0;
const lstatSync = fs.lstatSync;
lstatSync && (this.lstat = (arg, options, callback) => {
let result;
try {
result = lstatSync.call(fs, arg);
} catch (e) {
return (callback || options)(e);
}
(callback || options)(null, result);
}, this.lstatSync = (arg, options) => lstatSync.call(fs, arg, options)), this.stat = (arg, options, callback) => {
let result;
try {
result = callback ? fs.statSync(arg, options) : fs.statSync(arg);
} catch (e) {
return (callback || options)(e);
}
(callback || options)(null, result);
}, this.statSync = (arg, options) => fs.statSync(arg, options), this.readdir = (arg, options, callback) => {
let result;
try {
result = fs.readdirSync(arg);
} catch (e) {
return (callback || options)(e);
}
(callback || options)(null, result);
}, this.readdirSync = (arg, options) => fs.readdirSync(arg, options), this.readFile = (arg, options, callback) => {
let result;
try {
result = fs.readFileSync(arg);
} catch (e) {
return (callback || options)(e);
}
(callback || options)(null, result);
}, this.readFileSync = (arg, options) => fs.readFileSync(arg, options), this.readlink = (arg, options, callback) => {
let result;
try {
result = fs.readlinkSync(arg);
} catch (e) {
return (callback || options)(e);
}
(callback || options)(null, result);
}, this.readlinkSync = (arg, options) => fs.readlinkSync(arg, options), this.readJson = void 0, 
this.readJsonSync = void 0;
const readJsonSync = fs.readJsonSync;
readJsonSync && (this.readJson = (arg, options, callback) => {
let result;
try {
result = readJsonSync.call(fs, arg);
} catch (e) {
return (callback || options)(e);
}
(callback || options)(null, result);
}, this.readJsonSync = (arg, options) => readJsonSync.call(fs, arg, options));
};
},
35345: module => {
"use strict";
module.exports = class {
constructor(source, message, target) {
this.source = source, this.message = message, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("TryNextPlugin", ((request, resolveContext, callback) => {
resolver.doResolve(target, request, this.message, resolveContext, callback);
}));
}
};
},
79421: module => {
"use strict";
module.exports = class {
constructor(source, filterPredicate, cache, withContext, target) {
this.source = source, this.filterPredicate = filterPredicate, this.withContext = withContext, 
this.cache = cache, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("UnsafeCachePlugin", ((request, resolveContext, callback) => {
if (!this.filterPredicate(request)) return callback();
const isYield = "function" == typeof resolveContext.yield, cacheId = function(type, request, withContext) {
return JSON.stringify({
type,
context: withContext ? request.context : "",
path: request.path,
query: request.query,
fragment: request.fragment,
request: request.request
});
}(isYield ? "yield" : "default", request, this.withContext), cacheEntry = this.cache[cacheId];
if (cacheEntry) {
if (isYield) {
const yield_ = resolveContext.yield;
if (Array.isArray(cacheEntry)) for (const result of cacheEntry) yield_(result); else yield_(cacheEntry);
return callback(null, null);
}
return callback(null, cacheEntry);
}
let yieldFn, yield_;
const yieldResult = [];
isYield && (yieldFn = resolveContext.yield, yield_ = result => {
yieldResult.push(result);
}), resolver.doResolve(target, request, null, yield_ ? {
...resolveContext,
yield: yield_
} : resolveContext, ((err, result) => {
if (err) return callback(err);
if (isYield) {
result && yieldResult.push(result);
for (const result of yieldResult) yieldFn(result);
return this.cache[cacheId] = yieldResult, callback(null, null);
}
if (result) return callback(null, this.cache[cacheId] = result);
callback();
}));
}));
}
};
},
3012: module => {
"use strict";
module.exports = class {
constructor(source, filename, target) {
this.source = source, this.filename = filename, this.target = target;
}
apply(resolver) {
const target = resolver.ensureHook(this.target);
resolver.getHook(this.source).tapAsync("UseFilePlugin", ((request, resolveContext, callback) => {
const filePath = resolver.join(request.path, this.filename), obj = {
...request,
path: filePath,
relativePath: request.relativePath && resolver.join(request.relativePath, this.filename)
};
resolver.doResolve(target, obj, "using path: " + filePath, resolveContext, callback);
}));
}
};
},
58112: module => {
"use strict";
module.exports = function(options, message, messageOptional) {
let innerLog, messageReported = !1;
options.log && (innerLog = message ? msg => {
messageReported || (options.log(message), messageReported = !0), options.log("  " + msg);
} : options.log);
return {
log: innerLog,
yield: options.yield,
fileDependencies: options.fileDependencies,
contextDependencies: options.contextDependencies,
missingDependencies: options.missingDependencies,
stack: options.stack
};
};
},
40836: module => {
"use strict";
module.exports = function(array, iterator, callback) {
if (0 === array.length) return callback();
let i = 0;
const next = () => {
let loop;
return iterator(array[i++], ((err, result) => {
if (err || void 0 !== result || i >= array.length) return callback(err, result);
if (!1 === loop) for (;next(); ) ;
loop = !0;
})), loop || (loop = !1), loop;
};
for (;next(); ) ;
};
},
25292: module => {
"use strict";
module.exports = function(resolver, request) {
if ("string" == typeof request.__innerRequest && request.__innerRequest_request === request.request && request.__innerRequest_relativePath === request.relativePath) return request.__innerRequest;
let innerRequest;
return request.request ? (innerRequest = request.request, /^\.\.?(?:\/|$)/.test(innerRequest) && request.relativePath && (innerRequest = resolver.join(request.relativePath, innerRequest))) : innerRequest = request.relativePath, 
request.__innerRequest_request = request.request, request.__innerRequest_relativePath = request.relativePath, 
request.__innerRequest = innerRequest;
};
},
16637: module => {
"use strict";
module.exports = function(path) {
if ("/" === path) return {
paths: [ "/" ],
segments: [ "" ]
};
const parts = path.split(/(.*?[\\/]+)/), paths = [ path ], segments = [ parts[parts.length - 1] ];
let part = parts[parts.length - 1];
path = path.substr(0, path.length - part.length - 1);
for (let i = parts.length - 2; i > 2; i -= 2) paths.push(path), part = parts[i], 
path = path.substr(0, path.length - part.length) || "/", segments.push(part.substr(0, part.length - 1));
return part = parts[1], segments.push(part), paths.push(part), {
paths,
segments
};
}, module.exports.basename = function(path) {
const i = path.lastIndexOf("/"), j = path.lastIndexOf("\\"), p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
if (p < 0) return null;
return path.substr(p + 1);
};
},
92672: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const fs = __webpack_require__(20077), CachedInputFileSystem = __webpack_require__(38546), ResolverFactory = __webpack_require__(97446), nodeFileSystem = new CachedInputFileSystem(fs, 4e3), nodeContext = {
environments: [ "node+es3+es5+process+native" ]
}, asyncResolver = ResolverFactory.createResolver({
conditionNames: [ "node" ],
extensions: [ ".js", ".json", ".node" ],
fileSystem: nodeFileSystem
});
const syncResolver = ResolverFactory.createResolver({
conditionNames: [ "node" ],
extensions: [ ".js", ".json", ".node" ],
useSyncFileSystemCalls: !0,
fileSystem: nodeFileSystem
});
function resolveSync(context, path, request) {
return "string" == typeof context && (request = path, path = context, context = nodeContext), 
syncResolver.resolveSync(context, path, request);
}
function createSync(options) {
options = {
useSyncFileSystemCalls: !0,
fileSystem: nodeFileSystem,
...options
};
const resolver = ResolverFactory.createResolver(options);
return function(context, path, request) {
return "string" == typeof context && (request = path, path = context, context = nodeContext), 
resolver.resolveSync(context, path, request);
};
}
const mergeExports = (obj, exports) => {
const descriptors = Object.getOwnPropertyDescriptors(exports);
return Object.defineProperties(obj, descriptors), Object.freeze(obj);
};
module.exports = mergeExports((function(context, path, request, resolveContext, callback) {
"string" == typeof context && (callback = resolveContext, resolveContext = request, 
request = path, path = context, context = nodeContext), "function" != typeof callback && (callback = resolveContext), 
asyncResolver.resolve(context, path, request, resolveContext, callback);
}), {
get sync() {
return resolveSync;
},
create: mergeExports((function(options) {
options = {
fileSystem: nodeFileSystem,
...options
};
const resolver = ResolverFactory.createResolver(options);
return function(context, path, request, resolveContext, callback) {
"string" == typeof context && (callback = resolveContext, resolveContext = request, 
request = path, path = context, context = nodeContext), "function" != typeof callback && (callback = resolveContext), 
resolver.resolve(context, path, request, resolveContext, callback);
};
}), {
get sync() {
return createSync;
}
}),
ResolverFactory,
CachedInputFileSystem,
get CloneBasenamePlugin() {
return __webpack_require__(75896);
},
get LogInfoPlugin() {
return __webpack_require__(42609);
},
get forEachBail() {
return __webpack_require__(40836);
}
});
},
14928: module => {
"use strict";
const slashCode = "/".charCodeAt(0), dotCode = ".".charCodeAt(0), hashCode = "#".charCodeAt(0);
function createFieldProcessor(treeRoot, assertRequest, assertTarget) {
return function(request, conditionNames) {
const match = function(request, treeRoot) {
if (0 === request.length) {
const value = treeRoot.files.get("");
return value ? [ value, 1 ] : null;
}
if (null === treeRoot.children && null === treeRoot.folder && null === treeRoot.wildcards) {
const value = treeRoot.files.get(request);
return value ? [ value, request.length + 1 ] : null;
}
let node = treeRoot, lastNonSlashIndex = 0, slashIndex = request.indexOf("/", 0), lastFolderMatch = null;
const applyFolderMapping = () => {
const folderMapping = node.folder;
folderMapping && (lastFolderMatch ? (lastFolderMatch[0] = folderMapping, lastFolderMatch[1] = -lastNonSlashIndex - 1) : lastFolderMatch = [ folderMapping, -lastNonSlashIndex - 1 ]);
}, applyWildcardMappings = (wildcardMappings, remainingRequest) => {
if (wildcardMappings) for (const [key, target] of wildcardMappings) remainingRequest.startsWith(key) && (lastFolderMatch ? lastFolderMatch[1] < lastNonSlashIndex + key.length && (lastFolderMatch[0] = target, 
lastFolderMatch[1] = lastNonSlashIndex + key.length) : lastFolderMatch = [ target, lastNonSlashIndex + key.length ]);
};
for (;-1 !== slashIndex; ) {
applyFolderMapping();
const wildcardMappings = node.wildcards;
if (!wildcardMappings && null === node.children) return lastFolderMatch;
const folder = request.slice(lastNonSlashIndex, slashIndex);
if (applyWildcardMappings(wildcardMappings, folder), null === node.children) return lastFolderMatch;
const newNode = node.children.get(folder);
if (!newNode) return lastFolderMatch;
node = newNode, lastNonSlashIndex = slashIndex + 1, slashIndex = request.indexOf("/", lastNonSlashIndex);
}
const remainingRequest = lastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request, value = node.files.get(remainingRequest);
if (value) return [ value, request.length + 1 ];
return applyFolderMapping(), applyWildcardMappings(node.wildcards, remainingRequest), 
lastFolderMatch;
}(request = assertRequest(request), treeRoot);
if (null === match) return [];
const [mapping, remainRequestIndex] = match;
let direct = null;
if (isConditionalMapping(mapping)) {
if (direct = conditionalMapping(mapping, conditionNames), null === direct) return [];
} else direct = mapping;
return directMapping(remainRequestIndex === request.length + 1 ? void 0 : remainRequestIndex < 0 ? request.slice(-remainRequestIndex - 1) : request.slice(remainRequestIndex), remainRequestIndex < 0, direct, conditionNames, assertTarget);
};
}
function assertExportsFieldRequest(request) {
if (request.charCodeAt(0) !== dotCode) throw new Error('Request should be relative path and start with "."');
if (1 === request.length) return "";
if (request.charCodeAt(1) !== slashCode) throw new Error('Request should be relative path and start with "./"');
if (request.charCodeAt(request.length - 1) === slashCode) throw new Error("Only requesting file allowed");
return request.slice(2);
}
function assertImportsFieldRequest(request) {
if (request.charCodeAt(0) !== hashCode) throw new Error('Request should start with "#"');
if (1 === request.length) throw new Error("Request should have at least 2 characters");
if (request.charCodeAt(1) === slashCode) throw new Error('Request should not start with "#/"');
if (request.charCodeAt(request.length - 1) === slashCode) throw new Error("Only requesting file allowed");
return request.slice(1);
}
function assertExportTarget(exp, expectFolder) {
if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) throw new Error(`Export should be relative path and start with "./", got ${JSON.stringify(exp)}.`);
if (exp.charCodeAt(exp.length - 1) === slashCode !== expectFolder) throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with "/"`);
}
function assertImportTarget(imp, expectFolder) {
if (imp.charCodeAt(imp.length - 1) === slashCode !== expectFolder) throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with "/"`);
}
function isConditionalMapping(mapping) {
return null !== mapping && "object" == typeof mapping && !Array.isArray(mapping);
}
function directMapping(remainingRequest, subpathMapping, mappingTarget, conditionNames, assert) {
if (null === mappingTarget) return [];
if ("string" == typeof mappingTarget) return [ targetMapping(remainingRequest, subpathMapping, mappingTarget, assert) ];
const targets = [];
for (const exp of mappingTarget) {
if ("string" == typeof exp) {
targets.push(targetMapping(remainingRequest, subpathMapping, exp, assert));
continue;
}
const mapping = conditionalMapping(exp, conditionNames);
if (!mapping) continue;
const innerExports = directMapping(remainingRequest, subpathMapping, mapping, conditionNames, assert);
for (const innerExport of innerExports) targets.push(innerExport);
}
return targets;
}
function targetMapping(remainingRequest, subpathMapping, mappingTarget, assert) {
return void 0 === remainingRequest ? (assert(mappingTarget, !1), mappingTarget) : subpathMapping ? (assert(mappingTarget, !0), 
mappingTarget + remainingRequest) : (assert(mappingTarget, !1), mappingTarget.replace(/\*/g, remainingRequest.replace(/\$/g, "$$")));
}
function conditionalMapping(conditionalMapping_, conditionNames) {
let lookup = [ [ conditionalMapping_, Object.keys(conditionalMapping_), 0 ] ];
loop: for (;lookup.length > 0; ) {
const [mapping, conditions, j] = lookup[lookup.length - 1], last = conditions.length - 1;
for (let i = j; i < conditions.length; i++) {
const condition = conditions[i];
if (i !== last) {
if ("default" === condition) throw new Error("Default condition should be last one");
} else if ("default" === condition) {
const innerMapping = mapping[condition];
if (isConditionalMapping(innerMapping)) {
const conditionalMapping = innerMapping;
lookup[lookup.length - 1][2] = i + 1, lookup.push([ conditionalMapping, Object.keys(conditionalMapping), 0 ]);
continue loop;
}
return innerMapping;
}
if (conditionNames.has(condition)) {
const innerMapping = mapping[condition];
if (isConditionalMapping(innerMapping)) {
const conditionalMapping = innerMapping;
lookup[lookup.length - 1][2] = i + 1, lookup.push([ conditionalMapping, Object.keys(conditionalMapping), 0 ]);
continue loop;
}
return innerMapping;
}
}
lookup.pop();
}
return null;
}
function createNode() {
return {
children: null,
folder: null,
wildcards: null,
files: new Map
};
}
function walkPath(root, path, target) {
if (0 === path.length) return void (root.folder = target);
let node = root, lastNonSlashIndex = 0, slashIndex = path.indexOf("/", 0);
for (;-1 !== slashIndex; ) {
const folder = path.slice(lastNonSlashIndex, slashIndex);
let newNode;
null === node.children ? (newNode = createNode(), node.children = new Map, node.children.set(folder, newNode)) : (newNode = node.children.get(folder), 
newNode || (newNode = createNode(), node.children.set(folder, newNode))), node = newNode, 
lastNonSlashIndex = slashIndex + 1, slashIndex = path.indexOf("/", lastNonSlashIndex);
}
if (lastNonSlashIndex >= path.length) node.folder = target; else {
const file = lastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path;
file.endsWith("*") ? (null === node.wildcards && (node.wildcards = new Map), node.wildcards.set(file.slice(0, -1), target)) : node.files.set(file, target);
}
}
module.exports.processExportsField = function(exportsField) {
return createFieldProcessor(function(field) {
const root = createNode();
if ("string" == typeof field) return root.files.set("", field), root;
if (Array.isArray(field)) return root.files.set("", field.slice()), root;
const keys = Object.keys(field);
for (let i = 0; i < keys.length; i++) {
const key = keys[i];
if (key.charCodeAt(0) !== dotCode) {
if (0 === i) {
for (;i < keys.length; ) {
const charCode = keys[i].charCodeAt(0);
if (charCode === dotCode || charCode === slashCode) throw new Error(`Exports field key should be relative path and start with "." (key: ${JSON.stringify(key)})`);
i++;
}
return root.files.set("", field), root;
}
throw new Error(`Exports field key should be relative path and start with "." (key: ${JSON.stringify(key)})`);
}
if (1 !== key.length) {
if (key.charCodeAt(1) !== slashCode) throw new Error(`Exports field key should be relative path and start with "./" (key: ${JSON.stringify(key)})`);
walkPath(root, key.slice(2), field[key]);
} else root.files.set("", field[key]);
}
return root;
}(exportsField), assertExportsFieldRequest, assertExportTarget);
}, module.exports.processImportsField = function(importsField) {
return createFieldProcessor(function(field) {
const root = createNode(), keys = Object.keys(field);
for (let i = 0; i < keys.length; i++) {
const key = keys[i];
if (key.charCodeAt(0) !== hashCode) throw new Error(`Imports field key should start with "#" (key: ${JSON.stringify(key)})`);
if (1 === key.length) throw new Error(`Imports field key should have at least 2 characters (key: ${JSON.stringify(key)})`);
if (key.charCodeAt(1) === slashCode) throw new Error(`Imports field key should not start with "#/" (key: ${JSON.stringify(key)})`);
walkPath(root, key.slice(1), field[key]);
}
return root;
}(importsField), assertImportsFieldRequest, assertImportTarget);
};
},
21757: module => {
"use strict";
const PATH_QUERY_FRAGMENT_REGEXP = /^(#?(?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
module.exports.parseIdentifier = function(identifier) {
const match = PATH_QUERY_FRAGMENT_REGEXP.exec(identifier);
return match ? [ match[1].replace(/\0(.)/g, "$1"), match[2] ? match[2].replace(/\0(.)/g, "$1") : "", match[3] || "" ] : null;
};
},
22931: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), CHAR_HASH = "#".charCodeAt(0), CHAR_SLASH = "/".charCodeAt(0), CHAR_BACKSLASH = "\\".charCodeAt(0), CHAR_A = "A".charCodeAt(0), CHAR_Z = "Z".charCodeAt(0), CHAR_LOWER_A = "a".charCodeAt(0), CHAR_LOWER_Z = "z".charCodeAt(0), CHAR_DOT = ".".charCodeAt(0), CHAR_COLON = ":".charCodeAt(0), posixNormalize = path.posix.normalize, winNormalize = path.win32.normalize, PathType = Object.freeze({
Empty: 0,
Normal: 1,
Relative: 2,
AbsoluteWin: 3,
AbsolutePosix: 4,
Internal: 5
});
exports.PathType = PathType;
const getType = p => {
switch (p.length) {
case 0:
return PathType.Empty;

case 1:
switch (p.charCodeAt(0)) {
case CHAR_DOT:
return PathType.Relative;

case CHAR_SLASH:
return PathType.AbsolutePosix;

case CHAR_HASH:
return PathType.Internal;
}
return PathType.Normal;

case 2:
{
const c0 = p.charCodeAt(0);
switch (c0) {
case CHAR_DOT:
switch (p.charCodeAt(1)) {
case CHAR_DOT:
case CHAR_SLASH:
return PathType.Relative;
}
return PathType.Normal;

case CHAR_SLASH:
return PathType.AbsolutePosix;

case CHAR_HASH:
return PathType.Internal;
}
return p.charCodeAt(1) === CHAR_COLON && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z) ? PathType.AbsoluteWin : PathType.Normal;
}
}
const c0 = p.charCodeAt(0);
switch (c0) {
case CHAR_DOT:
switch (p.charCodeAt(1)) {
case CHAR_SLASH:
return PathType.Relative;

case CHAR_DOT:
return p.charCodeAt(2) === CHAR_SLASH ? PathType.Relative : PathType.Normal;
}
return PathType.Normal;

case CHAR_SLASH:
return PathType.AbsolutePosix;

case CHAR_HASH:
return PathType.Internal;
}
if (p.charCodeAt(1) === CHAR_COLON) {
const c2 = p.charCodeAt(2);
if ((c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) return PathType.AbsoluteWin;
}
return PathType.Normal;
};
exports.getType = getType;
const normalize = p => {
switch (getType(p)) {
case PathType.Empty:
return p;

case PathType.AbsoluteWin:
return winNormalize(p);

case PathType.Relative:
{
const r = posixNormalize(p);
return getType(r) === PathType.Relative ? r : `./${r}`;
}
}
return posixNormalize(p);
};
exports.normalize = normalize;
const join = (rootPath, request) => {
if (!request) return normalize(rootPath);
const requestType = getType(request);
switch (requestType) {
case PathType.AbsolutePosix:
return posixNormalize(request);

case PathType.AbsoluteWin:
return winNormalize(request);
}
switch (getType(rootPath)) {
case PathType.Normal:
case PathType.Relative:
case PathType.AbsolutePosix:
return posixNormalize(`${rootPath}/${request}`);

case PathType.AbsoluteWin:
return winNormalize(`${rootPath}\\${request}`);
}
switch (requestType) {
case PathType.Empty:
return rootPath;

case PathType.Relative:
{
const r = posixNormalize(rootPath);
return getType(r) === PathType.Relative ? r : `./${r}`;
}
}
return posixNormalize(rootPath);
};
exports.join = join;
const joinCache = new Map;
exports.cachedJoin = (rootPath, request) => {
let cacheEntry, cache = joinCache.get(rootPath);
if (void 0 === cache) joinCache.set(rootPath, cache = new Map); else if (cacheEntry = cache.get(request), 
void 0 !== cacheEntry) return cacheEntry;
return cacheEntry = join(rootPath, request), cache.set(request, cacheEntry), cacheEntry;
};
exports.checkImportsExportsFieldTarget = relativePath => {
let lastNonSlashIndex = 0, slashIndex = relativePath.indexOf("/", 1), cd = 0;
for (;-1 !== slashIndex; ) {
switch (relativePath.slice(lastNonSlashIndex, slashIndex)) {
case "..":
if (cd--, cd < 0) return new Error(`Trying to access out of package scope. Requesting ${relativePath}`);
break;

case ".":
break;

default:
cd++;
}
lastNonSlashIndex = slashIndex + 1, slashIndex = relativePath.indexOf("/", lastNonSlashIndex);
}
};
},
11300: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Variable = __webpack_require__(1509);
class Definition {
constructor(type, name, node, parent, index, kind) {
this.type = type, this.name = name, this.node = node, this.parent = parent, this.index = index, 
this.kind = kind;
}
}
module.exports = {
ParameterDefinition: class extends Definition {
constructor(name, node, index, rest) {
super(Variable.Parameter, name, node, null, index, null), this.rest = rest;
}
},
Definition
};
},
25048: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const assert = __webpack_require__(39491), ScopeManager = __webpack_require__(64140), Referencer = __webpack_require__(1625), Reference = __webpack_require__(16469), Variable = __webpack_require__(1509), Scope = __webpack_require__(65099).Scope, version = __webpack_require__(83196).i8;
function updateDeeply(target, override) {
function isHashObject(value) {
return "object" == typeof value && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
}
for (const key in override) if (Object.prototype.hasOwnProperty.call(override, key)) {
const val = override[key];
isHashObject(val) ? isHashObject(target[key]) ? updateDeeply(target[key], val) : target[key] = updateDeeply({}, val) : target[key] = val;
}
return target;
}
module.exports = {
version,
Reference,
Variable,
Scope,
ScopeManager,
analyze: function(tree, providedOptions) {
const options = updateDeeply({
optimistic: !1,
directive: !1,
nodejsScope: !1,
impliedStrict: !1,
sourceType: "script",
ecmaVersion: 5,
childVisitorKeys: null,
fallback: "iteration"
}, providedOptions), scopeManager = new ScopeManager(options);
return new Referencer(options, scopeManager).visit(tree), assert(null === scopeManager.__currentScope, "currentScope should be null."), 
scopeManager;
}
};
},
78370: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Syntax = __webpack_require__(27085).Syntax, esrecurse = __webpack_require__(98192);
class PatternVisitor extends esrecurse.Visitor {
static isPattern(node) {
const nodeType = node.type;
return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
}
constructor(options, rootPattern, callback) {
super(null, options), this.rootPattern = rootPattern, this.callback = callback, 
this.assignments = [], this.rightHandNodes = [], this.restElements = [];
}
Identifier(pattern) {
const lastRestElement = (xs = this.restElements)[xs.length - 1] || null;
var xs;
this.callback(pattern, {
topLevel: pattern === this.rootPattern,
rest: null != lastRestElement && lastRestElement.argument === pattern,
assignments: this.assignments
});
}
Property(property) {
property.computed && this.rightHandNodes.push(property.key), this.visit(property.value);
}
ArrayPattern(pattern) {
for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
const element = pattern.elements[i];
this.visit(element);
}
}
AssignmentPattern(pattern) {
this.assignments.push(pattern), this.visit(pattern.left), this.rightHandNodes.push(pattern.right), 
this.assignments.pop();
}
RestElement(pattern) {
this.restElements.push(pattern), this.visit(pattern.argument), this.restElements.pop();
}
MemberExpression(node) {
node.computed && this.rightHandNodes.push(node.property), this.rightHandNodes.push(node.object);
}
SpreadElement(node) {
this.visit(node.argument);
}
ArrayExpression(node) {
node.elements.forEach(this.visit, this);
}
AssignmentExpression(node) {
this.assignments.push(node), this.visit(node.left), this.rightHandNodes.push(node.right), 
this.assignments.pop();
}
CallExpression(node) {
node.arguments.forEach((a => {
this.rightHandNodes.push(a);
})), this.visit(node.callee);
}
}
module.exports = PatternVisitor;
},
16469: module => {
"use strict";
class Reference {
constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
this.identifier = ident, this.from = scope, this.tainted = !1, this.resolved = null, 
this.flag = flag, this.isWrite() && (this.writeExpr = writeExpr, this.partial = partial, 
this.init = init), this.__maybeImplicitGlobal = maybeImplicitGlobal;
}
isStatic() {
return !this.tainted && this.resolved && this.resolved.scope.isStatic();
}
isWrite() {
return !!(this.flag & Reference.WRITE);
}
isRead() {
return !!(this.flag & Reference.READ);
}
isReadOnly() {
return this.flag === Reference.READ;
}
isWriteOnly() {
return this.flag === Reference.WRITE;
}
isReadWrite() {
return this.flag === Reference.RW;
}
}
Reference.READ = 1, Reference.WRITE = 2, Reference.RW = 3, module.exports = Reference;
},
1625: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Syntax = __webpack_require__(27085).Syntax, esrecurse = __webpack_require__(98192), Reference = __webpack_require__(16469), Variable = __webpack_require__(1509), PatternVisitor = __webpack_require__(78370), definition = __webpack_require__(11300), assert = __webpack_require__(39491), ParameterDefinition = definition.ParameterDefinition, Definition = definition.Definition;
class Importer extends esrecurse.Visitor {
constructor(declaration, referencer) {
super(null, referencer.options), this.declaration = declaration, this.referencer = referencer;
}
visitImport(id, specifier) {
this.referencer.visitPattern(id, (pattern => {
this.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, this.declaration, null, null));
}));
}
ImportNamespaceSpecifier(node) {
const local = node.local || node.id;
local && this.visitImport(local, node);
}
ImportDefaultSpecifier(node) {
const local = node.local || node.id;
this.visitImport(local, node);
}
ImportSpecifier(node) {
const local = node.local || node.id;
node.name ? this.visitImport(node.name, node) : this.visitImport(local, node);
}
}
class Referencer extends esrecurse.Visitor {
constructor(options, scopeManager) {
super(null, options), this.options = options, this.scopeManager = scopeManager, 
this.parent = null, this.isInnerMethodDefinition = !1;
}
currentScope() {
return this.scopeManager.__currentScope;
}
close(node) {
for (;this.currentScope() && node === this.currentScope().block; ) this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
}
pushInnerMethodDefinition(isInnerMethodDefinition) {
const previous = this.isInnerMethodDefinition;
return this.isInnerMethodDefinition = isInnerMethodDefinition, previous;
}
popInnerMethodDefinition(isInnerMethodDefinition) {
this.isInnerMethodDefinition = isInnerMethodDefinition;
}
referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
const scope = this.currentScope();
assignments.forEach((assignment => {
scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
}));
}
visitPattern(node, options, callback) {
let visitPatternOptions = options, visitPatternCallback = callback;
"function" == typeof options && (visitPatternCallback = options, visitPatternOptions = {
processRightHandNodes: !1
}), function(options, rootPattern, referencer, callback) {
const visitor = new PatternVisitor(options, rootPattern, callback);
visitor.visit(rootPattern), null != referencer && visitor.rightHandNodes.forEach(referencer.visit, referencer);
}(this.options, node, visitPatternOptions.processRightHandNodes ? this : null, visitPatternCallback);
}
visitFunction(node) {
let i, iz;
node.type === Syntax.FunctionDeclaration && this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null)), 
node.type === Syntax.FunctionExpression && node.id && this.scopeManager.__nestFunctionExpressionNameScope(node), 
this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
const that = this;
function visitPatternCallback(pattern, info) {
that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest)), 
that.referencingDefaultValue(pattern, info.assignments, null, !0);
}
for (i = 0, iz = node.params.length; i < iz; ++i) this.visitPattern(node.params[i], {
processRightHandNodes: !0
}, visitPatternCallback);
node.rest && this.visitPattern({
type: "RestElement",
argument: node.rest
}, (pattern => {
this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, !0));
})), node.body && (node.body.type === Syntax.BlockStatement ? this.visitChildren(node.body) : this.visit(node.body)), 
this.close(node);
}
visitClass(node) {
node.type === Syntax.ClassDeclaration && this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null)), 
this.visit(node.superClass), this.scopeManager.__nestClassScope(node), node.id && this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node)), 
this.visit(node.body), this.close(node);
}
visitProperty(node) {
let previous;
node.computed && this.visit(node.key);
const isMethodDefinition = node.type === Syntax.MethodDefinition;
isMethodDefinition && (previous = this.pushInnerMethodDefinition(!0)), this.visit(node.value), 
isMethodDefinition && this.popInnerMethodDefinition(previous);
}
visitForIn(node) {
node.left.type === Syntax.VariableDeclaration && "var" !== node.left.kind && this.scopeManager.__nestForScope(node), 
node.left.type === Syntax.VariableDeclaration ? (this.visit(node.left), this.visitPattern(node.left.declarations[0].id, (pattern => {
this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, !0, !0);
}))) : this.visitPattern(node.left, {
processRightHandNodes: !0
}, ((pattern, info) => {
let maybeImplicitGlobal = null;
this.currentScope().isStrict || (maybeImplicitGlobal = {
pattern,
node
}), this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, !1), 
this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !0, !1);
})), this.visit(node.right), this.visit(node.body), this.close(node);
}
visitVariableDeclaration(variableTargetScope, type, node, index) {
const decl = node.declarations[index], init = decl.init;
this.visitPattern(decl.id, {
processRightHandNodes: !0
}, ((pattern, info) => {
variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind)), 
this.referencingDefaultValue(pattern, info.assignments, null, !0), init && this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, !0);
}));
}
AssignmentExpression(node) {
PatternVisitor.isPattern(node.left) ? "=" === node.operator ? this.visitPattern(node.left, {
processRightHandNodes: !0
}, ((pattern, info) => {
let maybeImplicitGlobal = null;
this.currentScope().isStrict || (maybeImplicitGlobal = {
pattern,
node
}), this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, !1), 
this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, !1);
})) : this.currentScope().__referencing(node.left, Reference.RW, node.right) : this.visit(node.left), 
this.visit(node.right);
}
CatchClause(node) {
this.scopeManager.__nestCatchScope(node), this.visitPattern(node.param, {
processRightHandNodes: !0
}, ((pattern, info) => {
this.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null)), 
this.referencingDefaultValue(pattern, info.assignments, null, !0);
})), this.visit(node.body), this.close(node);
}
Program(node) {
this.scopeManager.__nestGlobalScope(node), this.scopeManager.__isNodejsScope() && (this.currentScope().isStrict = !1, 
this.scopeManager.__nestFunctionScope(node, !1)), this.scopeManager.__isES6() && this.scopeManager.isModule() && this.scopeManager.__nestModuleScope(node), 
this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0), 
this.visitChildren(node), this.close(node);
}
Identifier(node) {
this.currentScope().__referencing(node);
}
UpdateExpression(node) {
PatternVisitor.isPattern(node.argument) ? this.currentScope().__referencing(node.argument, Reference.RW, null) : this.visitChildren(node);
}
MemberExpression(node) {
this.visit(node.object), node.computed && this.visit(node.property);
}
Property(node) {
this.visitProperty(node);
}
MethodDefinition(node) {
this.visitProperty(node);
}
BreakStatement() {}
ContinueStatement() {}
LabeledStatement(node) {
this.visit(node.body);
}
ForStatement(node) {
node.init && node.init.type === Syntax.VariableDeclaration && "var" !== node.init.kind && this.scopeManager.__nestForScope(node), 
this.visitChildren(node), this.close(node);
}
ClassExpression(node) {
this.visitClass(node);
}
ClassDeclaration(node) {
this.visitClass(node);
}
CallExpression(node) {
this.scopeManager.__ignoreEval() || node.callee.type !== Syntax.Identifier || "eval" !== node.callee.name || this.currentScope().variableScope.__detectEval(), 
this.visitChildren(node);
}
BlockStatement(node) {
this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(node), this.visitChildren(node), 
this.close(node);
}
ThisExpression() {
this.currentScope().variableScope.__detectThis();
}
WithStatement(node) {
this.visit(node.object), this.scopeManager.__nestWithScope(node), this.visit(node.body), 
this.close(node);
}
VariableDeclaration(node) {
const variableTargetScope = "var" === node.kind ? this.currentScope().variableScope : this.currentScope();
for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
const decl = node.declarations[i];
this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i), 
decl.init && this.visit(decl.init);
}
}
SwitchStatement(node) {
this.visit(node.discriminant), this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(node);
for (let i = 0, iz = node.cases.length; i < iz; ++i) this.visit(node.cases[i]);
this.close(node);
}
FunctionDeclaration(node) {
this.visitFunction(node);
}
FunctionExpression(node) {
this.visitFunction(node);
}
ForOfStatement(node) {
this.visitForIn(node);
}
ForInStatement(node) {
this.visitForIn(node);
}
ArrowFunctionExpression(node) {
this.visitFunction(node);
}
ImportDeclaration(node) {
assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
new Importer(node, this).visit(node);
}
visitExportDeclaration(node) {
node.source || (node.declaration ? this.visit(node.declaration) : this.visitChildren(node));
}
ExportDeclaration(node) {
this.visitExportDeclaration(node);
}
ExportAllDeclaration(node) {
this.visitExportDeclaration(node);
}
ExportDefaultDeclaration(node) {
this.visitExportDeclaration(node);
}
ExportNamedDeclaration(node) {
this.visitExportDeclaration(node);
}
ExportSpecifier(node) {
const local = node.id || node.local;
this.visit(local);
}
MetaProperty() {}
}
module.exports = Referencer;
},
64140: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Scope = __webpack_require__(65099), assert = __webpack_require__(39491), GlobalScope = Scope.GlobalScope, CatchScope = Scope.CatchScope, WithScope = Scope.WithScope, ModuleScope = Scope.ModuleScope, ClassScope = Scope.ClassScope, SwitchScope = Scope.SwitchScope, FunctionScope = Scope.FunctionScope, ForScope = Scope.ForScope, FunctionExpressionNameScope = Scope.FunctionExpressionNameScope, BlockScope = Scope.BlockScope;
module.exports = class {
constructor(options) {
this.scopes = [], this.globalScope = null, this.__nodeToScope = new WeakMap, this.__currentScope = null, 
this.__options = options, this.__declaredVariables = new WeakMap;
}
__useDirective() {
return this.__options.directive;
}
__isOptimistic() {
return this.__options.optimistic;
}
__ignoreEval() {
return this.__options.ignoreEval;
}
__isNodejsScope() {
return this.__options.nodejsScope;
}
isModule() {
return "module" === this.__options.sourceType;
}
isImpliedStrict() {
return this.__options.impliedStrict;
}
isStrictModeSupported() {
return this.__options.ecmaVersion >= 5;
}
__get(node) {
return this.__nodeToScope.get(node);
}
getDeclaredVariables(node) {
return this.__declaredVariables.get(node) || [];
}
acquire(node, inner) {
function predicate(testScope) {
return "function" !== testScope.type || !testScope.functionExpressionScope;
}
const scopes = this.__get(node);
if (!scopes || 0 === scopes.length) return null;
if (1 === scopes.length) return scopes[0];
if (inner) for (let i = scopes.length - 1; i >= 0; --i) {
const scope = scopes[i];
if (predicate(scope)) return scope;
} else for (let i = 0, iz = scopes.length; i < iz; ++i) {
const scope = scopes[i];
if (predicate(scope)) return scope;
}
return null;
}
acquireAll(node) {
return this.__get(node);
}
release(node, inner) {
const scopes = this.__get(node);
if (scopes && scopes.length) {
const scope = scopes[0].upper;
return scope ? this.acquire(scope.block, inner) : null;
}
return null;
}
attach() {}
detach() {}
__nestScope(scope) {
return scope instanceof GlobalScope && (assert(null === this.__currentScope), this.globalScope = scope), 
this.__currentScope = scope, scope;
}
__nestGlobalScope(node) {
return this.__nestScope(new GlobalScope(this, node));
}
__nestBlockScope(node) {
return this.__nestScope(new BlockScope(this, this.__currentScope, node));
}
__nestFunctionScope(node, isMethodDefinition) {
return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
}
__nestForScope(node) {
return this.__nestScope(new ForScope(this, this.__currentScope, node));
}
__nestCatchScope(node) {
return this.__nestScope(new CatchScope(this, this.__currentScope, node));
}
__nestWithScope(node) {
return this.__nestScope(new WithScope(this, this.__currentScope, node));
}
__nestClassScope(node) {
return this.__nestScope(new ClassScope(this, this.__currentScope, node));
}
__nestSwitchScope(node) {
return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
}
__nestModuleScope(node) {
return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
}
__nestFunctionExpressionNameScope(node) {
return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
}
__isES6() {
return this.__options.ecmaVersion >= 6;
}
};
},
65099: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Syntax = __webpack_require__(27085).Syntax, Reference = __webpack_require__(16469), Variable = __webpack_require__(1509), Definition = __webpack_require__(11300).Definition, assert = __webpack_require__(39491);
function shouldBeStatically(def) {
return def.type === Variable.ClassName || def.type === Variable.Variable && "var" !== def.parent.kind;
}
class Scope {
constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
this.type = type, this.set = new Map, this.taints = new Map, this.dynamic = "global" === this.type || "with" === this.type, 
this.block = block, this.through = [], this.variables = [], this.references = [], 
this.variableScope = "global" === this.type || "function" === this.type || "module" === this.type ? this : upperScope.variableScope, 
this.functionExpressionScope = !1, this.directCallToEvalScope = !1, this.thisFound = !1, 
this.__left = [], this.upper = upperScope, this.isStrict = function(scope, block, isMethodDefinition, useDirective) {
let body;
if (scope.upper && scope.upper.isStrict) return !0;
if (isMethodDefinition) return !0;
if ("class" === scope.type || "module" === scope.type) return !0;
if ("block" === scope.type || "switch" === scope.type) return !1;
if ("function" === scope.type) {
if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) return !1;
if (body = block.type === Syntax.Program ? block : block.body, !body) return !1;
} else {
if ("global" !== scope.type) return !1;
body = block;
}
if (useDirective) for (let i = 0, iz = body.body.length; i < iz; ++i) {
const stmt = body.body[i];
if (stmt.type !== Syntax.DirectiveStatement) break;
if ('"use strict"' === stmt.raw || "'use strict'" === stmt.raw) return !0;
} else for (let i = 0, iz = body.body.length; i < iz; ++i) {
const stmt = body.body[i];
if (stmt.type !== Syntax.ExpressionStatement) break;
const expr = stmt.expression;
if (expr.type !== Syntax.Literal || "string" != typeof expr.value) break;
if (null !== expr.raw && void 0 !== expr.raw) {
if ('"use strict"' === expr.raw || "'use strict'" === expr.raw) return !0;
} else if ("use strict" === expr.value) return !0;
}
return !1;
}(this, block, isMethodDefinition, scopeManager.__useDirective()), this.childScopes = [], 
this.upper && this.upper.childScopes.push(this), this.__declaredVariables = scopeManager.__declaredVariables, 
function(scopeManager, scope) {
scopeManager.scopes.push(scope);
const scopes = scopeManager.__nodeToScope.get(scope.block);
scopes ? scopes.push(scope) : scopeManager.__nodeToScope.set(scope.block, [ scope ]);
}(scopeManager, this);
}
__shouldStaticallyClose(scopeManager) {
return !this.dynamic || scopeManager.__isOptimistic();
}
__shouldStaticallyCloseForGlobal(ref) {
const name = ref.identifier.name;
if (!this.set.has(name)) return !1;
const defs = this.set.get(name).defs;
return defs.length > 0 && defs.every(shouldBeStatically);
}
__staticCloseRef(ref) {
this.__resolve(ref) || this.__delegateToUpperScope(ref);
}
__dynamicCloseRef(ref) {
let current = this;
do {
current.through.push(ref), current = current.upper;
} while (current);
}
__globalCloseRef(ref) {
this.__shouldStaticallyCloseForGlobal(ref) ? this.__staticCloseRef(ref) : this.__dynamicCloseRef(ref);
}
__close(scopeManager) {
let closeRef;
closeRef = this.__shouldStaticallyClose(scopeManager) ? this.__staticCloseRef : "global" !== this.type ? this.__dynamicCloseRef : this.__globalCloseRef;
for (let i = 0, iz = this.__left.length; i < iz; ++i) {
const ref = this.__left[i];
closeRef.call(this, ref);
}
return this.__left = null, this.upper;
}
__isValidResolution(ref, variable) {
return !0;
}
__resolve(ref) {
const name = ref.identifier.name;
if (!this.set.has(name)) return !1;
const variable = this.set.get(name);
return !!this.__isValidResolution(ref, variable) && (variable.references.push(ref), 
variable.stack = variable.stack && ref.from.variableScope === this.variableScope, 
ref.tainted && (variable.tainted = !0, this.taints.set(variable.name, !0)), ref.resolved = variable, 
!0);
}
__delegateToUpperScope(ref) {
this.upper && this.upper.__left.push(ref), this.through.push(ref);
}
__addDeclaredVariablesOfNode(variable, node) {
if (null == node) return;
let variables = this.__declaredVariables.get(node);
null == variables && (variables = [], this.__declaredVariables.set(node, variables)), 
-1 === variables.indexOf(variable) && variables.push(variable);
}
__defineGeneric(name, set, variables, node, def) {
let variable;
variable = set.get(name), variable || (variable = new Variable(name, this), set.set(name, variable), 
variables.push(variable)), def && (variable.defs.push(def), this.__addDeclaredVariablesOfNode(variable, def.node), 
this.__addDeclaredVariablesOfNode(variable, def.parent)), node && variable.identifiers.push(node);
}
__define(node, def) {
node && node.type === Syntax.Identifier && this.__defineGeneric(node.name, this.set, this.variables, node, def);
}
__referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
if (!node || node.type !== Syntax.Identifier) return;
if ("super" === node.name) return;
const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
this.references.push(ref), this.__left.push(ref);
}
__detectEval() {
let current = this;
this.directCallToEvalScope = !0;
do {
current.dynamic = !0, current = current.upper;
} while (current);
}
__detectThis() {
this.thisFound = !0;
}
__isClosed() {
return null === this.__left;
}
resolve(ident) {
let ref, i, iz;
for (assert(this.__isClosed(), "Scope should be closed."), assert(ident.type === Syntax.Identifier, "Target should be identifier."), 
i = 0, iz = this.references.length; i < iz; ++i) if (ref = this.references[i], ref.identifier === ident) return ref;
return null;
}
isStatic() {
return !this.dynamic;
}
isArgumentsMaterialized() {
return !0;
}
isThisMaterialized() {
return !0;
}
isUsedName(name) {
if (this.set.has(name)) return !0;
for (let i = 0, iz = this.through.length; i < iz; ++i) if (this.through[i].identifier.name === name) return !0;
return !1;
}
}
module.exports = {
Scope,
GlobalScope: class extends Scope {
constructor(scopeManager, block) {
super(scopeManager, "global", null, block, !1), this.implicit = {
set: new Map,
variables: [],
left: []
};
}
__close(scopeManager) {
const implicit = [];
for (let i = 0, iz = this.__left.length; i < iz; ++i) {
const ref = this.__left[i];
ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name) && implicit.push(ref.__maybeImplicitGlobal);
}
for (let i = 0, iz = implicit.length; i < iz; ++i) {
const info = implicit[i];
this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
}
return this.implicit.left = this.__left, super.__close(scopeManager);
}
__defineImplicit(node, def) {
node && node.type === Syntax.Identifier && this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
}
},
ModuleScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "module", upperScope, block, !1);
}
},
FunctionExpressionNameScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "function-expression-name", upperScope, block, !1), this.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null)), 
this.functionExpressionScope = !0;
}
},
CatchScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "catch", upperScope, block, !1);
}
},
WithScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "with", upperScope, block, !1);
}
__close(scopeManager) {
if (this.__shouldStaticallyClose(scopeManager)) return super.__close(scopeManager);
for (let i = 0, iz = this.__left.length; i < iz; ++i) {
const ref = this.__left[i];
ref.tainted = !0, this.__delegateToUpperScope(ref);
}
return this.__left = null, this.upper;
}
},
BlockScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "block", upperScope, block, !1);
}
},
SwitchScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "switch", upperScope, block, !1);
}
},
FunctionScope: class extends Scope {
constructor(scopeManager, upperScope, block, isMethodDefinition) {
super(scopeManager, "function", upperScope, block, isMethodDefinition), this.block.type !== Syntax.ArrowFunctionExpression && this.__defineArguments();
}
isArgumentsMaterialized() {
if (this.block.type === Syntax.ArrowFunctionExpression) return !1;
if (!this.isStatic()) return !0;
const variable = this.set.get("arguments");
return assert(variable, "Always have arguments variable."), variable.tainted || 0 !== variable.references.length;
}
isThisMaterialized() {
return !this.isStatic() || this.thisFound;
}
__defineArguments() {
this.__defineGeneric("arguments", this.set, this.variables, null, null), this.taints.set("arguments", !0);
}
__isValidResolution(ref, variable) {
if ("Program" === this.block.type) return !0;
const bodyStart = this.block.body.range[0];
return !(variable.scope === this && ref.identifier.range[0] < bodyStart && variable.defs.every((d => d.name.range[0] >= bodyStart)));
}
},
ForScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "for", upperScope, block, !1);
}
},
ClassScope: class extends Scope {
constructor(scopeManager, upperScope, block) {
super(scopeManager, "class", upperScope, block, !1);
}
}
};
},
1509: module => {
"use strict";
class Variable {
constructor(name, scope) {
this.name = name, this.identifiers = [], this.references = [], this.defs = [], this.tainted = !1, 
this.stack = !0, this.scope = scope;
}
}
Variable.CatchClause = "CatchClause", Variable.Parameter = "Parameter", Variable.FunctionName = "FunctionName", 
Variable.ClassName = "ClassName", Variable.Variable = "Variable", Variable.ImportBinding = "ImportBinding", 
Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable", module.exports = Variable;
},
98192: (__unused_webpack_module, exports, __webpack_require__) => {
!function() {
"use strict";
var estraverse = __webpack_require__(27085);
function isNode(node) {
return null != node && ("object" == typeof node && "string" == typeof node.type);
}
function Visitor(visitor, options) {
options = options || {}, this.__visitor = visitor || this, this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys, 
"iteration" === options.fallback ? this.__fallback = Object.keys : "function" == typeof options.fallback && (this.__fallback = options.fallback);
}
Visitor.prototype.visitChildren = function(node) {
var type, children, i, iz, j, jz, child;
if (null != node) {
if (type = node.type || estraverse.Syntax.Property, !(children = this.__childVisitorKeys[type])) {
if (!this.__fallback) throw new Error("Unknown node type " + type + ".");
children = this.__fallback(node);
}
for (i = 0, iz = children.length; i < iz; ++i) if (child = node[children[i]]) if (Array.isArray(child)) for (j = 0, 
jz = child.length; j < jz; ++j) child[j] && (!isNode(child[j]) && (nodeType = type, 
key = children[i], nodeType !== estraverse.Syntax.ObjectExpression && nodeType !== estraverse.Syntax.ObjectPattern || "properties" !== key) || this.visit(child[j])); else isNode(child) && this.visit(child);
var nodeType, key;
}
}, Visitor.prototype.visit = function(node) {
var type;
null != node && (type = node.type || estraverse.Syntax.Property, this.__visitor[type] ? this.__visitor[type].call(this, node) : this.visitChildren(node));
}, exports.version = __webpack_require__(29389).version, exports.Visitor = Visitor, 
exports.visit = function(node, visitor, options) {
new Visitor(visitor, options).visit(node);
};
}();
},
27085: (__unused_webpack_module, exports) => {
!function clone(exports) {
"use strict";
var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
function deepCopy(obj) {
var key, val, ret = {};
for (key in obj) obj.hasOwnProperty(key) && (val = obj[key], ret[key] = "object" == typeof val && null !== val ? deepCopy(val) : val);
return ret;
}
function Reference(parent, key) {
this.parent = parent, this.key = key;
}
function Element(node, path, wrap, ref) {
this.node = node, this.path = path, this.wrap = wrap, this.ref = ref;
}
function Controller() {}
function isNode(node) {
return null != node && ("object" == typeof node && "string" == typeof node.type);
}
function isProperty(nodeType, key) {
return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
}
function candidateExistsInLeaveList(leavelist, candidate) {
for (var i = leavelist.length - 1; i >= 0; --i) if (leavelist[i].node === candidate) return !0;
return !1;
}
function traverse(root, visitor) {
return (new Controller).traverse(root, visitor);
}
function extendCommentRange(comment, tokens) {
var target;
return target = function(array, func) {
var diff, len, i, current;
for (len = array.length, i = 0; len; ) func(array[current = i + (diff = len >>> 1)]) ? len = diff : (i = current + 1, 
len -= diff + 1);
return i;
}(tokens, (function(token) {
return token.range[0] > comment.range[0];
})), comment.extendedRange = [ comment.range[0], comment.range[1] ], target !== tokens.length && (comment.extendedRange[1] = tokens[target].range[0]), 
(target -= 1) >= 0 && (comment.extendedRange[0] = tokens[target].range[1]), comment;
}
return Syntax = {
AssignmentExpression: "AssignmentExpression",
AssignmentPattern: "AssignmentPattern",
ArrayExpression: "ArrayExpression",
ArrayPattern: "ArrayPattern",
ArrowFunctionExpression: "ArrowFunctionExpression",
AwaitExpression: "AwaitExpression",
BlockStatement: "BlockStatement",
BinaryExpression: "BinaryExpression",
BreakStatement: "BreakStatement",
CallExpression: "CallExpression",
CatchClause: "CatchClause",
ChainExpression: "ChainExpression",
ClassBody: "ClassBody",
ClassDeclaration: "ClassDeclaration",
ClassExpression: "ClassExpression",
ComprehensionBlock: "ComprehensionBlock",
ComprehensionExpression: "ComprehensionExpression",
ConditionalExpression: "ConditionalExpression",
ContinueStatement: "ContinueStatement",
DebuggerStatement: "DebuggerStatement",
DirectiveStatement: "DirectiveStatement",
DoWhileStatement: "DoWhileStatement",
EmptyStatement: "EmptyStatement",
ExportAllDeclaration: "ExportAllDeclaration",
ExportDefaultDeclaration: "ExportDefaultDeclaration",
ExportNamedDeclaration: "ExportNamedDeclaration",
ExportSpecifier: "ExportSpecifier",
ExpressionStatement: "ExpressionStatement",
ForStatement: "ForStatement",
ForInStatement: "ForInStatement",
ForOfStatement: "ForOfStatement",
FunctionDeclaration: "FunctionDeclaration",
FunctionExpression: "FunctionExpression",
GeneratorExpression: "GeneratorExpression",
Identifier: "Identifier",
IfStatement: "IfStatement",
ImportExpression: "ImportExpression",
ImportDeclaration: "ImportDeclaration",
ImportDefaultSpecifier: "ImportDefaultSpecifier",
ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
ImportSpecifier: "ImportSpecifier",
Literal: "Literal",
LabeledStatement: "LabeledStatement",
LogicalExpression: "LogicalExpression",
MemberExpression: "MemberExpression",
MetaProperty: "MetaProperty",
MethodDefinition: "MethodDefinition",
ModuleSpecifier: "ModuleSpecifier",
NewExpression: "NewExpression",
ObjectExpression: "ObjectExpression",
ObjectPattern: "ObjectPattern",
Program: "Program",
Property: "Property",
RestElement: "RestElement",
ReturnStatement: "ReturnStatement",
SequenceExpression: "SequenceExpression",
SpreadElement: "SpreadElement",
Super: "Super",
SwitchStatement: "SwitchStatement",
SwitchCase: "SwitchCase",
TaggedTemplateExpression: "TaggedTemplateExpression",
TemplateElement: "TemplateElement",
TemplateLiteral: "TemplateLiteral",
ThisExpression: "ThisExpression",
ThrowStatement: "ThrowStatement",
TryStatement: "TryStatement",
UnaryExpression: "UnaryExpression",
UpdateExpression: "UpdateExpression",
VariableDeclaration: "VariableDeclaration",
VariableDeclarator: "VariableDeclarator",
WhileStatement: "WhileStatement",
WithStatement: "WithStatement",
YieldExpression: "YieldExpression"
}, VisitorKeys = {
AssignmentExpression: [ "left", "right" ],
AssignmentPattern: [ "left", "right" ],
ArrayExpression: [ "elements" ],
ArrayPattern: [ "elements" ],
ArrowFunctionExpression: [ "params", "body" ],
AwaitExpression: [ "argument" ],
BlockStatement: [ "body" ],
BinaryExpression: [ "left", "right" ],
BreakStatement: [ "label" ],
CallExpression: [ "callee", "arguments" ],
CatchClause: [ "param", "body" ],
ChainExpression: [ "expression" ],
ClassBody: [ "body" ],
ClassDeclaration: [ "id", "superClass", "body" ],
ClassExpression: [ "id", "superClass", "body" ],
ComprehensionBlock: [ "left", "right" ],
ComprehensionExpression: [ "blocks", "filter", "body" ],
ConditionalExpression: [ "test", "consequent", "alternate" ],
ContinueStatement: [ "label" ],
DebuggerStatement: [],
DirectiveStatement: [],
DoWhileStatement: [ "body", "test" ],
EmptyStatement: [],
ExportAllDeclaration: [ "source" ],
ExportDefaultDeclaration: [ "declaration" ],
ExportNamedDeclaration: [ "declaration", "specifiers", "source" ],
ExportSpecifier: [ "exported", "local" ],
ExpressionStatement: [ "expression" ],
ForStatement: [ "init", "test", "update", "body" ],
ForInStatement: [ "left", "right", "body" ],
ForOfStatement: [ "left", "right", "body" ],
FunctionDeclaration: [ "id", "params", "body" ],
FunctionExpression: [ "id", "params", "body" ],
GeneratorExpression: [ "blocks", "filter", "body" ],
Identifier: [],
IfStatement: [ "test", "consequent", "alternate" ],
ImportExpression: [ "source" ],
ImportDeclaration: [ "specifiers", "source" ],
ImportDefaultSpecifier: [ "local" ],
ImportNamespaceSpecifier: [ "local" ],
ImportSpecifier: [ "imported", "local" ],
Literal: [],
LabeledStatement: [ "label", "body" ],
LogicalExpression: [ "left", "right" ],
MemberExpression: [ "object", "property" ],
MetaProperty: [ "meta", "property" ],
MethodDefinition: [ "key", "value" ],
ModuleSpecifier: [],
NewExpression: [ "callee", "arguments" ],
ObjectExpression: [ "properties" ],
ObjectPattern: [ "properties" ],
Program: [ "body" ],
Property: [ "key", "value" ],
RestElement: [ "argument" ],
ReturnStatement: [ "argument" ],
SequenceExpression: [ "expressions" ],
SpreadElement: [ "argument" ],
Super: [],
SwitchStatement: [ "discriminant", "cases" ],
SwitchCase: [ "test", "consequent" ],
TaggedTemplateExpression: [ "tag", "quasi" ],
TemplateElement: [],
TemplateLiteral: [ "quasis", "expressions" ],
ThisExpression: [],
ThrowStatement: [ "argument" ],
TryStatement: [ "block", "handler", "finalizer" ],
UnaryExpression: [ "argument" ],
UpdateExpression: [ "argument" ],
VariableDeclaration: [ "declarations" ],
VariableDeclarator: [ "id", "init" ],
WhileStatement: [ "test", "body" ],
WithStatement: [ "object", "body" ],
YieldExpression: [ "argument" ]
}, VisitorOption = {
Break: BREAK = {},
Skip: SKIP = {},
Remove: REMOVE = {}
}, Reference.prototype.replace = function(node) {
this.parent[this.key] = node;
}, Reference.prototype.remove = function() {
return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), 
!1);
}, Controller.prototype.path = function() {
var i, iz, j, jz, result;
function addToPath(result, path) {
if (Array.isArray(path)) for (j = 0, jz = path.length; j < jz; ++j) result.push(path[j]); else result.push(path);
}
if (!this.__current.path) return null;
for (result = [], i = 2, iz = this.__leavelist.length; i < iz; ++i) addToPath(result, this.__leavelist[i].path);
return addToPath(result, this.__current.path), result;
}, Controller.prototype.type = function() {
return this.current().type || this.__current.wrap;
}, Controller.prototype.parents = function() {
var i, iz, result;
for (result = [], i = 1, iz = this.__leavelist.length; i < iz; ++i) result.push(this.__leavelist[i].node);
return result;
}, Controller.prototype.current = function() {
return this.__current.node;
}, Controller.prototype.__execute = function(callback, element) {
var previous, result;
return result = void 0, previous = this.__current, this.__current = element, this.__state = null, 
callback && (result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node)), 
this.__current = previous, result;
}, Controller.prototype.notify = function(flag) {
this.__state = flag;
}, Controller.prototype.skip = function() {
this.notify(SKIP);
}, Controller.prototype.break = function() {
this.notify(BREAK);
}, Controller.prototype.remove = function() {
this.notify(REMOVE);
}, Controller.prototype.__initialize = function(root, visitor) {
this.visitor = visitor, this.root = root, this.__worklist = [], this.__leavelist = [], 
this.__current = null, this.__state = null, this.__fallback = null, "iteration" === visitor.fallback ? this.__fallback = Object.keys : "function" == typeof visitor.fallback && (this.__fallback = visitor.fallback), 
this.__keys = VisitorKeys, visitor.keys && (this.__keys = Object.assign(Object.create(this.__keys), visitor.keys));
}, Controller.prototype.traverse = function(root, visitor) {
var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
for (this.__initialize(root, visitor), sentinel = {}, worklist = this.__worklist, 
leavelist = this.__leavelist, worklist.push(new Element(root, null, null, null)), 
leavelist.push(new Element(null, null, null, null)); worklist.length; ) if ((element = worklist.pop()) !== sentinel) {
if (element.node) {
if (ret = this.__execute(visitor.enter, element), this.__state === BREAK || ret === BREAK) return;
if (worklist.push(sentinel), leavelist.push(element), this.__state === SKIP || ret === SKIP) continue;
if (nodeType = (node = element.node).type || element.wrap, !(candidates = this.__keys[nodeType])) {
if (!this.__fallback) throw new Error("Unknown node type " + nodeType + ".");
candidates = this.__fallback(node);
}
for (current = candidates.length; (current -= 1) >= 0; ) if (candidate = node[key = candidates[current]]) if (Array.isArray(candidate)) {
for (current2 = candidate.length; (current2 -= 1) >= 0; ) if (candidate[current2] && !candidateExistsInLeaveList(leavelist, candidate[current2])) {
if (isProperty(nodeType, candidates[current])) element = new Element(candidate[current2], [ key, current2 ], "Property", null); else {
if (!isNode(candidate[current2])) continue;
element = new Element(candidate[current2], [ key, current2 ], null, null);
}
worklist.push(element);
}
} else if (isNode(candidate)) {
if (candidateExistsInLeaveList(leavelist, candidate)) continue;
worklist.push(new Element(candidate, key, null, null));
}
}
} else if (element = leavelist.pop(), ret = this.__execute(visitor.leave, element), 
this.__state === BREAK || ret === BREAK) return;
}, Controller.prototype.replace = function(root, visitor) {
var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
function removeElem(element) {
var i, key, nextElem, parent;
if (element.ref.remove()) for (key = element.ref.key, parent = element.ref.parent, 
i = worklist.length; i--; ) if ((nextElem = worklist[i]).ref && nextElem.ref.parent === parent) {
if (nextElem.ref.key < key) break;
--nextElem.ref.key;
}
}
for (this.__initialize(root, visitor), sentinel = {}, worklist = this.__worklist, 
leavelist = this.__leavelist, element = new Element(root, null, null, new Reference(outer = {
root
}, "root")), worklist.push(element), leavelist.push(element); worklist.length; ) if ((element = worklist.pop()) !== sentinel) {
if (void 0 !== (target = this.__execute(visitor.enter, element)) && target !== BREAK && target !== SKIP && target !== REMOVE && (element.ref.replace(target), 
element.node = target), this.__state !== REMOVE && target !== REMOVE || (removeElem(element), 
element.node = null), this.__state === BREAK || target === BREAK) return outer.root;
if ((node = element.node) && (worklist.push(sentinel), leavelist.push(element), 
this.__state !== SKIP && target !== SKIP)) {
if (nodeType = node.type || element.wrap, !(candidates = this.__keys[nodeType])) {
if (!this.__fallback) throw new Error("Unknown node type " + nodeType + ".");
candidates = this.__fallback(node);
}
for (current = candidates.length; (current -= 1) >= 0; ) if (candidate = node[key = candidates[current]]) if (Array.isArray(candidate)) {
for (current2 = candidate.length; (current2 -= 1) >= 0; ) if (candidate[current2]) {
if (isProperty(nodeType, candidates[current])) element = new Element(candidate[current2], [ key, current2 ], "Property", new Reference(candidate, current2)); else {
if (!isNode(candidate[current2])) continue;
element = new Element(candidate[current2], [ key, current2 ], null, new Reference(candidate, current2));
}
worklist.push(element);
}
} else isNode(candidate) && worklist.push(new Element(candidate, key, null, new Reference(node, key)));
}
} else if (element = leavelist.pop(), void 0 !== (target = this.__execute(visitor.leave, element)) && target !== BREAK && target !== SKIP && target !== REMOVE && element.ref.replace(target), 
this.__state !== REMOVE && target !== REMOVE || removeElem(element), this.__state === BREAK || target === BREAK) return outer.root;
return outer.root;
}, exports.Syntax = Syntax, exports.traverse = traverse, exports.replace = function(root, visitor) {
return (new Controller).replace(root, visitor);
}, exports.attachComments = function(tree, providedComments, tokens) {
var comment, len, i, cursor, comments = [];
if (!tree.range) throw new Error("attachComments needs range information");
if (!tokens.length) {
if (providedComments.length) {
for (i = 0, len = providedComments.length; i < len; i += 1) (comment = deepCopy(providedComments[i])).extendedRange = [ 0, tree.range[0] ], 
comments.push(comment);
tree.leadingComments = comments;
}
return tree;
}
for (i = 0, len = providedComments.length; i < len; i += 1) comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
return cursor = 0, traverse(tree, {
enter: function(node) {
for (var comment; cursor < comments.length && !((comment = comments[cursor]).extendedRange[1] > node.range[0]); ) comment.extendedRange[1] === node.range[0] ? (node.leadingComments || (node.leadingComments = []), 
node.leadingComments.push(comment), comments.splice(cursor, 1)) : cursor += 1;
return cursor === comments.length ? VisitorOption.Break : comments[cursor].extendedRange[0] > node.range[1] ? VisitorOption.Skip : void 0;
}
}), cursor = 0, traverse(tree, {
leave: function(node) {
for (var comment; cursor < comments.length && (comment = comments[cursor], !(node.range[1] < comment.extendedRange[0])); ) node.range[1] === comment.extendedRange[0] ? (node.trailingComments || (node.trailingComments = []), 
node.trailingComments.push(comment), comments.splice(cursor, 1)) : cursor += 1;
return cursor === comments.length ? VisitorOption.Break : comments[cursor].extendedRange[0] > node.range[1] ? VisitorOption.Skip : void 0;
}
}), tree;
}, exports.VisitorKeys = VisitorKeys, exports.VisitorOption = VisitorOption, exports.Controller = Controller, 
exports.cloneEnvironment = function() {
return clone({});
}, exports;
}(exports);
},
81700: module => {
module.exports = function(glob, opts) {
if ("string" != typeof glob) throw new TypeError("Expected a string");
for (var c, str = String(glob), reStr = "", extended = !!opts && !!opts.extended, globstar = !!opts && !!opts.globstar, inGroup = !1, flags = opts && "string" == typeof opts.flags ? opts.flags : "", i = 0, len = str.length; i < len; i++) switch (c = str[i]) {
case "/":
case "$":
case "^":
case "+":
case ".":
case "(":
case ")":
case "=":
case "!":
case "|":
reStr += "\\" + c;
break;

case "?":
if (extended) {
reStr += ".";
break;
}

case "[":
case "]":
if (extended) {
reStr += c;
break;
}

case "{":
if (extended) {
inGroup = !0, reStr += "(";
break;
}

case "}":
if (extended) {
inGroup = !1, reStr += ")";
break;
}

case ",":
if (inGroup) {
reStr += "|";
break;
}
reStr += "\\" + c;
break;

case "*":
for (var prevChar = str[i - 1], starCount = 1; "*" === str[i + 1]; ) starCount++, 
i++;
var nextChar = str[i + 1];
if (globstar) starCount > 1 && ("/" === prevChar || void 0 === prevChar) && ("/" === nextChar || void 0 === nextChar) ? (reStr += "((?:[^/]*(?:/|$))*)", 
i++) : reStr += "([^/]*)"; else reStr += ".*";
break;

default:
reStr += c;
}
return flags && ~flags.indexOf("g") || (reStr = "^" + reStr + "$"), new RegExp(reStr, flags);
};
},
66458: module => {
"use strict";
module.exports = function(obj) {
if (null === obj || "object" != typeof obj) return obj;
if (obj instanceof Object) var copy = {
__proto__: getPrototypeOf(obj)
}; else copy = Object.create(null);
return Object.getOwnPropertyNames(obj).forEach((function(key) {
Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
})), copy;
};
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
return obj.__proto__;
};
},
20077: (module, __unused_webpack_exports, __webpack_require__) => {
var gracefulQueue, previousSymbol, fs = __webpack_require__(57147), polyfills = __webpack_require__(72161), legacy = __webpack_require__(78520), clone = __webpack_require__(66458), util = __webpack_require__(73837);
function publishQueue(context, queue) {
Object.defineProperty(context, gracefulQueue, {
get: function() {
return queue;
}
});
}
"function" == typeof Symbol && "function" == typeof Symbol.for ? (gracefulQueue = Symbol.for("graceful-fs.queue"), 
previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", 
previousSymbol = "___graceful-fs.previous");
var retryTimer, debug = function() {};
if (util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
var m = util.format.apply(util, arguments);
m = "GFS4: " + m.split(/\n/).join("\nGFS4: "), console.error(m);
}), !fs[gracefulQueue]) {
var queue = global[gracefulQueue] || [];
publishQueue(fs, queue), fs.close = function(fs$close) {
function close(fd, cb) {
return fs$close.call(fs, fd, (function(err) {
err || resetQueue(), "function" == typeof cb && cb.apply(this, arguments);
}));
}
return Object.defineProperty(close, previousSymbol, {
value: fs$close
}), close;
}(fs.close), fs.closeSync = function(fs$closeSync) {
function closeSync(fd) {
fs$closeSync.apply(fs, arguments), resetQueue();
}
return Object.defineProperty(closeSync, previousSymbol, {
value: fs$closeSync
}), closeSync;
}(fs.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", (function() {
debug(fs[gracefulQueue]), __webpack_require__(39491).equal(fs[gracefulQueue].length, 0);
}));
}
function patch(fs) {
polyfills(fs), fs.gracefulify = patch, fs.createReadStream = function(path, options) {
return new fs.ReadStream(path, options);
}, fs.createWriteStream = function(path, options) {
return new fs.WriteStream(path, options);
};
var fs$readFile = fs.readFile;
fs.readFile = function(path, options, cb) {
"function" == typeof options && (cb = options, options = null);
return function go$readFile(path, options, cb, startTime) {
return fs$readFile(path, options, (function(err) {
!err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$readFile, [ path, options, cb ], err, startTime || Date.now(), Date.now() ]);
}));
}(path, options, cb);
};
var fs$writeFile = fs.writeFile;
fs.writeFile = function(path, data, options, cb) {
"function" == typeof options && (cb = options, options = null);
return function go$writeFile(path, data, options, cb, startTime) {
return fs$writeFile(path, data, options, (function(err) {
!err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$writeFile, [ path, data, options, cb ], err, startTime || Date.now(), Date.now() ]);
}));
}(path, data, options, cb);
};
var fs$appendFile = fs.appendFile;
fs$appendFile && (fs.appendFile = function(path, data, options, cb) {
"function" == typeof options && (cb = options, options = null);
return function go$appendFile(path, data, options, cb, startTime) {
return fs$appendFile(path, data, options, (function(err) {
!err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$appendFile, [ path, data, options, cb ], err, startTime || Date.now(), Date.now() ]);
}));
}(path, data, options, cb);
});
var fs$copyFile = fs.copyFile;
fs$copyFile && (fs.copyFile = function(src, dest, flags, cb) {
"function" == typeof flags && (cb = flags, flags = 0);
return function go$copyFile(src, dest, flags, cb, startTime) {
return fs$copyFile(src, dest, flags, (function(err) {
!err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$copyFile, [ src, dest, flags, cb ], err, startTime || Date.now(), Date.now() ]);
}));
}(src, dest, flags, cb);
});
var fs$readdir = fs.readdir;
fs.readdir = function(path, options, cb) {
"function" == typeof options && (cb = options, options = null);
var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path, options, cb, startTime) {
return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
} : function(path, options, cb, startTime) {
return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
};
return go$readdir(path, options, cb);
function fs$readdirCallback(path, options, cb, startTime) {
return function(err, files) {
!err || "EMFILE" !== err.code && "ENFILE" !== err.code ? (files && files.sort && files.sort(), 
"function" == typeof cb && cb.call(this, err, files)) : enqueue([ go$readdir, [ path, options, cb ], err, startTime || Date.now(), Date.now() ]);
};
}
};
var noReaddirOptionVersions = /^v[0-5]\./;
if ("v0.8" === process.version.substr(0, 4)) {
var legStreams = legacy(fs);
ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
}
var fs$ReadStream = fs.ReadStream;
fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), 
ReadStream.prototype.open = function() {
var that = this;
open(that.path, that.flags, that.mode, (function(err, fd) {
err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, 
that.emit("open", fd), that.read());
}));
});
var fs$WriteStream = fs.WriteStream;
fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), 
WriteStream.prototype.open = function() {
var that = this;
open(that.path, that.flags, that.mode, (function(err, fd) {
err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
}));
}), Object.defineProperty(fs, "ReadStream", {
get: function() {
return ReadStream;
},
set: function(val) {
ReadStream = val;
},
enumerable: !0,
configurable: !0
}), Object.defineProperty(fs, "WriteStream", {
get: function() {
return WriteStream;
},
set: function(val) {
WriteStream = val;
},
enumerable: !0,
configurable: !0
});
var FileReadStream = ReadStream;
Object.defineProperty(fs, "FileReadStream", {
get: function() {
return FileReadStream;
},
set: function(val) {
FileReadStream = val;
},
enumerable: !0,
configurable: !0
});
var FileWriteStream = WriteStream;
function ReadStream(path, options) {
return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
}
function WriteStream(path, options) {
return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
}
Object.defineProperty(fs, "FileWriteStream", {
get: function() {
return FileWriteStream;
},
set: function(val) {
FileWriteStream = val;
},
enumerable: !0,
configurable: !0
});
var fs$open = fs.open;
function open(path, flags, mode, cb) {
return "function" == typeof mode && (cb = mode, mode = null), function go$open(path, flags, mode, cb, startTime) {
return fs$open(path, flags, mode, (function(err, fd) {
!err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$open, [ path, flags, mode, cb ], err, startTime || Date.now(), Date.now() ]);
}));
}(path, flags, mode, cb);
}
return fs.open = open, fs;
}
function enqueue(elem) {
debug("ENQUEUE", elem[0].name, elem[1]), fs[gracefulQueue].push(elem), retry();
}
function resetQueue() {
for (var now = Date.now(), i = 0; i < fs[gracefulQueue].length; ++i) fs[gracefulQueue][i].length > 2 && (fs[gracefulQueue][i][3] = now, 
fs[gracefulQueue][i][4] = now);
retry();
}
function retry() {
if (clearTimeout(retryTimer), retryTimer = void 0, 0 !== fs[gracefulQueue].length) {
var elem = fs[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
if (void 0 === startTime) debug("RETRY", fn.name, args), fn.apply(null, args); else if (Date.now() - startTime >= 6e4) {
debug("TIMEOUT", fn.name, args);
var cb = args.pop();
"function" == typeof cb && cb.call(null, err);
} else {
var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1);
sinceAttempt >= Math.min(1.2 * sinceStart, 100) ? (debug("RETRY", fn.name, args), 
fn.apply(null, args.concat([ startTime ]))) : fs[gracefulQueue].push(elem);
}
void 0 === retryTimer && (retryTimer = setTimeout(retry, 0));
}
}
global[gracefulQueue] || publishQueue(global, fs[gracefulQueue]), module.exports = patch(clone(fs)), 
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched && (module.exports = patch(fs), 
fs.__patched = !0);
},
78520: (module, __unused_webpack_exports, __webpack_require__) => {
var Stream = __webpack_require__(12781).Stream;
module.exports = function(fs) {
return {
ReadStream: function ReadStream(path, options) {
if (!(this instanceof ReadStream)) return new ReadStream(path, options);
Stream.call(this);
var self = this;
this.path = path, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", 
this.mode = 438, this.bufferSize = 65536, options = options || {};
for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
var key = keys[index];
this[key] = options[key];
}
this.encoding && this.setEncoding(this.encoding);
if (void 0 !== this.start) {
if ("number" != typeof this.start) throw TypeError("start must be a Number");
if (void 0 === this.end) this.end = 1 / 0; else if ("number" != typeof this.end) throw TypeError("end must be a Number");
if (this.start > this.end) throw new Error("start must be <= end");
this.pos = this.start;
}
if (null !== this.fd) return void process.nextTick((function() {
self._read();
}));
fs.open(this.path, this.flags, this.mode, (function(err, fd) {
if (err) return self.emit("error", err), void (self.readable = !1);
self.fd = fd, self.emit("open", fd), self._read();
}));
},
WriteStream: function WriteStream(path, options) {
if (!(this instanceof WriteStream)) return new WriteStream(path, options);
Stream.call(this), this.path = path, this.fd = null, this.writable = !0, this.flags = "w", 
this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
var key = keys[index];
this[key] = options[key];
}
if (void 0 !== this.start) {
if ("number" != typeof this.start) throw TypeError("start must be a Number");
if (this.start < 0) throw new Error("start must be >= zero");
this.pos = this.start;
}
this.busy = !1, this._queue = [], null === this.fd && (this._open = fs.open, this._queue.push([ this._open, this.path, this.flags, this.mode, void 0 ]), 
this.flush());
}
};
};
},
72161: (module, __unused_webpack_exports, __webpack_require__) => {
var constants = __webpack_require__(22057), origCwd = process.cwd, cwd = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
return cwd || (cwd = origCwd.call(process)), cwd;
};
try {
process.cwd();
} catch (er) {}
if ("function" == typeof process.chdir) {
var chdir = process.chdir;
process.chdir = function(d) {
cwd = null, chdir.call(process, d);
}, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = function(fs) {
constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && function(fs) {
fs.lchmod = function(path, mode, callback) {
fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, (function(err, fd) {
err ? callback && callback(err) : fs.fchmod(fd, mode, (function(err) {
fs.close(fd, (function(err2) {
callback && callback(err || err2);
}));
}));
}));
}, fs.lchmodSync = function(path, mode) {
var ret, fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0;
try {
ret = fs.fchmodSync(fd, mode), threw = !1;
} finally {
if (threw) try {
fs.closeSync(fd);
} catch (er) {} else fs.closeSync(fd);
}
return ret;
};
}(fs);
fs.lutimes || function(fs) {
constants.hasOwnProperty("O_SYMLINK") && fs.futimes ? (fs.lutimes = function(path, at, mt, cb) {
fs.open(path, constants.O_SYMLINK, (function(er, fd) {
er ? cb && cb(er) : fs.futimes(fd, at, mt, (function(er) {
fs.close(fd, (function(er2) {
cb && cb(er || er2);
}));
}));
}));
}, fs.lutimesSync = function(path, at, mt) {
var ret, fd = fs.openSync(path, constants.O_SYMLINK), threw = !0;
try {
ret = fs.futimesSync(fd, at, mt), threw = !1;
} finally {
if (threw) try {
fs.closeSync(fd);
} catch (er) {} else fs.closeSync(fd);
}
return ret;
}) : fs.futimes && (fs.lutimes = function(_a, _b, _c, cb) {
cb && process.nextTick(cb);
}, fs.lutimesSync = function() {});
}(fs);
fs.chown = chownFix(fs.chown), fs.fchown = chownFix(fs.fchown), fs.lchown = chownFix(fs.lchown), 
fs.chmod = chmodFix(fs.chmod), fs.fchmod = chmodFix(fs.fchmod), fs.lchmod = chmodFix(fs.lchmod), 
fs.chownSync = chownFixSync(fs.chownSync), fs.fchownSync = chownFixSync(fs.fchownSync), 
fs.lchownSync = chownFixSync(fs.lchownSync), fs.chmodSync = chmodFixSync(fs.chmodSync), 
fs.fchmodSync = chmodFixSync(fs.fchmodSync), fs.lchmodSync = chmodFixSync(fs.lchmodSync), 
fs.stat = statFix(fs.stat), fs.fstat = statFix(fs.fstat), fs.lstat = statFix(fs.lstat), 
fs.statSync = statFixSync(fs.statSync), fs.fstatSync = statFixSync(fs.fstatSync), 
fs.lstatSync = statFixSync(fs.lstatSync), fs.chmod && !fs.lchmod && (fs.lchmod = function(path, mode, cb) {
cb && process.nextTick(cb);
}, fs.lchmodSync = function() {});
fs.chown && !fs.lchown && (fs.lchown = function(path, uid, gid, cb) {
cb && process.nextTick(cb);
}, fs.lchownSync = function() {});
"win32" === platform && (fs.rename = "function" != typeof fs.rename ? fs.rename : function(fs$rename) {
function rename(from, to, cb) {
var start = Date.now(), backoff = 0;
fs$rename(from, to, (function CB(er) {
if (er && ("EACCES" === er.code || "EPERM" === er.code) && Date.now() - start < 6e4) return setTimeout((function() {
fs.stat(to, (function(stater, st) {
stater && "ENOENT" === stater.code ? fs$rename(from, to, CB) : cb(er);
}));
}), backoff), void (backoff < 100 && (backoff += 10));
cb && cb(er);
}));
}
return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
}(fs.rename));
function chmodFix(orig) {
return orig ? function(target, mode, cb) {
return orig.call(fs, target, mode, (function(er) {
chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
}));
} : orig;
}
function chmodFixSync(orig) {
return orig ? function(target, mode) {
try {
return orig.call(fs, target, mode);
} catch (er) {
if (!chownErOk(er)) throw er;
}
} : orig;
}
function chownFix(orig) {
return orig ? function(target, uid, gid, cb) {
return orig.call(fs, target, uid, gid, (function(er) {
chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
}));
} : orig;
}
function chownFixSync(orig) {
return orig ? function(target, uid, gid) {
try {
return orig.call(fs, target, uid, gid);
} catch (er) {
if (!chownErOk(er)) throw er;
}
} : orig;
}
function statFix(orig) {
return orig ? function(target, options, cb) {
function callback(er, stats) {
stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), 
cb && cb.apply(this, arguments);
}
return "function" == typeof options && (cb = options, options = null), options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
} : orig;
}
function statFixSync(orig) {
return orig ? function(target, options) {
var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), 
stats;
} : orig;
}
function chownErOk(er) {
return !er || ("ENOSYS" === er.code || !(process.getuid && 0 === process.getuid() || "EINVAL" !== er.code && "EPERM" !== er.code));
}
fs.read = "function" != typeof fs.read ? fs.read : function(fs$read) {
function read(fd, buffer, offset, length, position, callback_) {
var callback;
if (callback_ && "function" == typeof callback_) {
var eagCounter = 0;
callback = function(er, _, __) {
if (er && "EAGAIN" === er.code && eagCounter < 10) return eagCounter++, fs$read.call(fs, fd, buffer, offset, length, position, callback);
callback_.apply(this, arguments);
};
}
return fs$read.call(fs, fd, buffer, offset, length, position, callback);
}
return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
}(fs.read), fs.readSync = "function" != typeof fs.readSync ? fs.readSync : (fs$readSync = fs.readSync, 
function(fd, buffer, offset, length, position) {
for (var eagCounter = 0; ;) try {
return fs$readSync.call(fs, fd, buffer, offset, length, position);
} catch (er) {
if ("EAGAIN" === er.code && eagCounter < 10) {
eagCounter++;
continue;
}
throw er;
}
});
var fs$readSync;
};
},
73153: module => {
"use strict";
class JSONParseError extends SyntaxError {
constructor(er, txt, context, caller) {
const metadata = ((e, txt, context) => {
if (!txt) return {
message: e.message + " while parsing empty string",
position: 0
};
const badToken = e.message.match(/^Unexpected token (.) .*position\s+(\d+)/i), errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null, msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${JSON.stringify(badToken[1])} (${(char => {
const h = char.charCodeAt(0).toString(16).toUpperCase();
return "0x" + (h.length % 2 ? "0" : "") + h;
})(badToken[1])})`) : e.message;
if (null != errIdx) {
const start = errIdx <= context ? 0 : errIdx - context, end = errIdx + context >= txt.length ? txt.length : errIdx + context, slice = (0 === start ? "" : "...") + txt.slice(start, end) + (end === txt.length ? "" : "...");
return {
message: msg + ` while parsing ${txt === slice ? "" : "near "}${JSON.stringify(slice)}`,
position: errIdx
};
}
return {
message: msg + ` while parsing '${txt.slice(0, 2 * context)}'`,
position: 0
};
})(er, txt, context = context || 20);
super(metadata.message), Object.assign(this, metadata), this.code = "EJSONPARSE", 
this.systemError = er, Error.captureStackTrace(this, caller || this.constructor);
}
get name() {
return this.constructor.name;
}
set name(n) {}
get [Symbol.toStringTag]() {
return this.constructor.name;
}
}
const kIndent = Symbol.for("indent"), kNewline = Symbol.for("newline"), formatRE = /^\s*[{\[]((?:\r?\n)+)([\s\t]*)/, emptyRE = /^(?:\{\}|\[\])((?:\r?\n)+)?$/, parseJson = (txt, reviver, context) => {
const parseText = stripBOM(txt);
context = context || 20;
try {
const [, newline = "\n", indent = "  "] = parseText.match(emptyRE) || parseText.match(formatRE) || [ , "", "" ], result = JSON.parse(parseText, reviver);
return result && "object" == typeof result && (result[kNewline] = newline, result[kIndent] = indent), 
result;
} catch (e) {
if ("string" != typeof txt && !Buffer.isBuffer(txt)) {
const isEmptyArray = Array.isArray(txt) && 0 === txt.length;
throw Object.assign(new TypeError(`Cannot parse ${isEmptyArray ? "an empty array" : String(txt)}`), {
code: "EJSONPARSE",
systemError: e
});
}
throw new JSONParseError(e, parseText, context, parseJson);
}
}, stripBOM = txt => String(txt).replace(/^\uFEFF/, "");
module.exports = parseJson, parseJson.JSONParseError = JSONParseError, parseJson.noExceptions = (txt, reviver) => {
try {
return JSON.parse(stripBOM(txt), reviver);
} catch (e) {}
};
},
47843: module => {
"use strict";
class LoadingLoaderError extends Error {
constructor(message) {
super(message), this.name = "LoaderRunnerError", Error.captureStackTrace(this, this.constructor);
}
}
module.exports = LoadingLoaderError;
},
18043: (__unused_webpack_module, exports, __webpack_require__) => {
var fs = __webpack_require__(57147), readFile = fs.readFile.bind(fs), loadLoader = __webpack_require__(92440);
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
function parsePathQueryFragment(str) {
var match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
return {
path: match[1].replace(/\0(.)/g, "$1"),
query: match[2] ? match[2].replace(/\0(.)/g, "$1") : "",
fragment: match[3] || ""
};
}
function dirname(path) {
if ("/" === path) return "/";
var i = path.lastIndexOf("/"), j = path.lastIndexOf("\\"), i2 = path.indexOf("/"), j2 = path.indexOf("\\"), idx = i > j ? i : j;
return idx < 0 ? path : idx === (i > j ? i2 : j2) ? path.substr(0, idx + 1) : path.substr(0, idx);
}
function createLoaderObject(loader) {
var obj = {
path: null,
query: null,
fragment: null,
options: null,
ident: null,
normal: null,
pitch: null,
raw: null,
data: null,
pitchExecuted: !1,
normalExecuted: !1
};
return Object.defineProperty(obj, "request", {
enumerable: !0,
get: function() {
return obj.path.replace(/#/g, "\0#") + obj.query.replace(/#/g, "\0#") + obj.fragment;
},
set: function(value) {
if ("string" == typeof value) {
var splittedRequest = parsePathQueryFragment(value);
obj.path = splittedRequest.path, obj.query = splittedRequest.query, obj.fragment = splittedRequest.fragment, 
obj.options = void 0, obj.ident = void 0;
} else {
if (!value.loader) throw new Error("request should be a string or object with loader and options (" + JSON.stringify(value) + ")");
obj.path = value.loader, obj.fragment = value.fragment || "", obj.type = value.type, 
obj.options = value.options, obj.ident = value.ident, null === obj.options || void 0 === obj.options ? obj.query = "" : "string" == typeof obj.options ? obj.query = "?" + obj.options : obj.ident ? obj.query = "??" + obj.ident : "object" == typeof obj.options && obj.options.ident ? obj.query = "??" + obj.options.ident : obj.query = "?" + JSON.stringify(obj.options);
}
}
}), obj.request = loader, Object.preventExtensions && Object.preventExtensions(obj), 
obj;
}
function runSyncOrAsync(fn, context, args, callback) {
var isSync = !0, isDone = !1, isError = !1, reportedError = !1;
context.async = function() {
if (isDone) {
if (reportedError) return;
throw new Error("async(): The callback was already called.");
}
return isSync = !1, innerCallback;
};
var innerCallback = context.callback = function() {
if (isDone) {
if (reportedError) return;
throw new Error("callback(): The callback was already called.");
}
isDone = !0, isSync = !1;
try {
callback.apply(null, arguments);
} catch (e) {
throw isError = !0, e;
}
};
try {
var result = fn.apply(context, args);
if (isSync) return isDone = !0, void 0 === result ? callback() : result && "object" == typeof result && "function" == typeof result.then ? result.then((function(r) {
callback(null, r);
}), callback) : callback(null, result);
} catch (e) {
if (isError) throw e;
if (isDone) return void ("object" == typeof e && e.stack ? console.error(e.stack) : console.error(e));
isDone = !0, reportedError = !0, callback(e);
}
}
function iteratePitchingLoaders(options, loaderContext, callback) {
if (loaderContext.loaderIndex >= loaderContext.loaders.length) return function(options, loaderContext, callback) {
loaderContext.loaderIndex = loaderContext.loaders.length - 1;
var resourcePath = loaderContext.resourcePath;
resourcePath ? options.processResource(loaderContext, resourcePath, (function(err) {
if (err) return callback(err);
var args = Array.prototype.slice.call(arguments, 1);
options.resourceBuffer = args[0], iterateNormalLoaders(options, loaderContext, args, callback);
})) : iterateNormalLoaders(options, loaderContext, [ null ], callback);
}(options, loaderContext, callback);
var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
if (currentLoaderObject.pitchExecuted) return loaderContext.loaderIndex++, iteratePitchingLoaders(options, loaderContext, callback);
loadLoader(currentLoaderObject, (function(err) {
if (err) return loaderContext.cacheable(!1), callback(err);
var fn = currentLoaderObject.pitch;
if (currentLoaderObject.pitchExecuted = !0, !fn) return iteratePitchingLoaders(options, loaderContext, callback);
runSyncOrAsync(fn, loaderContext, [ loaderContext.remainingRequest, loaderContext.previousRequest, currentLoaderObject.data = {} ], (function(err) {
if (err) return callback(err);
var args = Array.prototype.slice.call(arguments, 1), hasArg = args.some((function(value) {
return void 0 !== value;
}));
hasArg ? (loaderContext.loaderIndex--, iterateNormalLoaders(options, loaderContext, args, callback)) : iteratePitchingLoaders(options, loaderContext, callback);
}));
}));
}
function iterateNormalLoaders(options, loaderContext, args, callback) {
if (loaderContext.loaderIndex < 0) return callback(null, args);
var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
if (currentLoaderObject.normalExecuted) return loaderContext.loaderIndex--, iterateNormalLoaders(options, loaderContext, args, callback);
var fn = currentLoaderObject.normal;
if (currentLoaderObject.normalExecuted = !0, !fn) return iterateNormalLoaders(options, loaderContext, args, callback);
!function(args, raw) {
var buf, str;
!raw && Buffer.isBuffer(args[0]) ? args[0] = (buf = args[0], 65279 === (str = buf.toString("utf-8")).charCodeAt(0) ? str.substr(1) : str) : raw && "string" == typeof args[0] && (args[0] = Buffer.from(args[0], "utf-8"));
}(args, currentLoaderObject.raw), runSyncOrAsync(fn, loaderContext, args, (function(err) {
if (err) return callback(err);
var args = Array.prototype.slice.call(arguments, 1);
iterateNormalLoaders(options, loaderContext, args, callback);
}));
}
exports.getContext = function(resource) {
return dirname(parsePathQueryFragment(resource).path);
}, exports.runLoaders = function(options, callback) {
var resource = options.resource || "", loaders = options.loaders || [], loaderContext = options.context || {}, processResource = options.processResource || ((readResource, context, resource, callback) => {
context.addDependency(resource), readResource(resource, callback);
}).bind(null, options.readResource || readFile), splittedResource = resource && parsePathQueryFragment(resource), resourcePath = splittedResource ? splittedResource.path : void 0, resourceQuery = splittedResource ? splittedResource.query : void 0, resourceFragment = splittedResource ? splittedResource.fragment : void 0, contextDirectory = resourcePath ? dirname(resourcePath) : null, requestCacheable = !0, fileDependencies = [], contextDependencies = [], missingDependencies = [];
loaders = loaders.map(createLoaderObject), loaderContext.context = contextDirectory, 
loaderContext.loaderIndex = 0, loaderContext.loaders = loaders, loaderContext.resourcePath = resourcePath, 
loaderContext.resourceQuery = resourceQuery, loaderContext.resourceFragment = resourceFragment, 
loaderContext.async = null, loaderContext.callback = null, loaderContext.cacheable = function(flag) {
!1 === flag && (requestCacheable = !1);
}, loaderContext.dependency = loaderContext.addDependency = function(file) {
fileDependencies.push(file);
}, loaderContext.addContextDependency = function(context) {
contextDependencies.push(context);
}, loaderContext.addMissingDependency = function(context) {
missingDependencies.push(context);
}, loaderContext.getDependencies = function() {
return fileDependencies.slice();
}, loaderContext.getContextDependencies = function() {
return contextDependencies.slice();
}, loaderContext.getMissingDependencies = function() {
return missingDependencies.slice();
}, loaderContext.clearDependencies = function() {
fileDependencies.length = 0, contextDependencies.length = 0, missingDependencies.length = 0, 
requestCacheable = !0;
}, Object.defineProperty(loaderContext, "resource", {
enumerable: !0,
get: function() {
if (void 0 !== loaderContext.resourcePath) return loaderContext.resourcePath.replace(/#/g, "\0#") + loaderContext.resourceQuery.replace(/#/g, "\0#") + loaderContext.resourceFragment;
},
set: function(value) {
var splittedResource = value && parsePathQueryFragment(value);
loaderContext.resourcePath = splittedResource ? splittedResource.path : void 0, 
loaderContext.resourceQuery = splittedResource ? splittedResource.query : void 0, 
loaderContext.resourceFragment = splittedResource ? splittedResource.fragment : void 0;
}
}), Object.defineProperty(loaderContext, "request", {
enumerable: !0,
get: function() {
return loaderContext.loaders.map((function(o) {
return o.request;
})).concat(loaderContext.resource || "").join("!");
}
}), Object.defineProperty(loaderContext, "remainingRequest", {
enumerable: !0,
get: function() {
return loaderContext.loaderIndex >= loaderContext.loaders.length - 1 && !loaderContext.resource ? "" : loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((function(o) {
return o.request;
})).concat(loaderContext.resource || "").join("!");
}
}), Object.defineProperty(loaderContext, "currentRequest", {
enumerable: !0,
get: function() {
return loaderContext.loaders.slice(loaderContext.loaderIndex).map((function(o) {
return o.request;
})).concat(loaderContext.resource || "").join("!");
}
}), Object.defineProperty(loaderContext, "previousRequest", {
enumerable: !0,
get: function() {
return loaderContext.loaders.slice(0, loaderContext.loaderIndex).map((function(o) {
return o.request;
})).join("!");
}
}), Object.defineProperty(loaderContext, "query", {
enumerable: !0,
get: function() {
var entry = loaderContext.loaders[loaderContext.loaderIndex];
return entry.options && "object" == typeof entry.options ? entry.options : entry.query;
}
}), Object.defineProperty(loaderContext, "data", {
enumerable: !0,
get: function() {
return loaderContext.loaders[loaderContext.loaderIndex].data;
}
}), Object.preventExtensions && Object.preventExtensions(loaderContext);
var processOptions = {
resourceBuffer: null,
processResource
};
iteratePitchingLoaders(processOptions, loaderContext, (function(err, result) {
if (err) return callback(err, {
cacheable: requestCacheable,
fileDependencies,
contextDependencies,
missingDependencies
});
callback(null, {
result,
resourceBuffer: processOptions.resourceBuffer,
cacheable: requestCacheable,
fileDependencies,
contextDependencies,
missingDependencies
});
}));
};
},
55234: (module, __unused_webpack_exports, __webpack_require__) => {
module.exports = __webpack_require__(53765);
},
80983: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
var extensions, types, preference, db = __webpack_require__(55234), extname = __webpack_require__(71017).extname, EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/, TEXT_TYPE_REGEXP = /^text\//i;
function charset(type) {
if (!type || "string" != typeof type) return !1;
var match = EXTRACT_TYPE_REGEXP.exec(type), mime = match && db[match[1].toLowerCase()];
return mime && mime.charset ? mime.charset : !(!match || !TEXT_TYPE_REGEXP.test(match[1])) && "UTF-8";
}
exports.charset = charset, exports.charsets = {
lookup: charset
}, exports.contentType = function(str) {
if (!str || "string" != typeof str) return !1;
var mime = -1 === str.indexOf("/") ? exports.lookup(str) : str;
if (!mime) return !1;
if (-1 === mime.indexOf("charset")) {
var charset = exports.charset(mime);
charset && (mime += "; charset=" + charset.toLowerCase());
}
return mime;
}, exports.extension = function(type) {
if (!type || "string" != typeof type) return !1;
var match = EXTRACT_TYPE_REGEXP.exec(type), exts = match && exports.extensions[match[1].toLowerCase()];
if (!exts || !exts.length) return !1;
return exts[0];
}, exports.extensions = Object.create(null), exports.lookup = function(path) {
if (!path || "string" != typeof path) return !1;
var extension = extname("x." + path).toLowerCase().substr(1);
if (!extension) return !1;
return exports.types[extension] || !1;
}, exports.types = Object.create(null), extensions = exports.extensions, types = exports.types, 
preference = [ "nginx", "apache", void 0, "iana" ], Object.keys(db).forEach((function(type) {
var mime = db[type], exts = mime.extensions;
if (exts && exts.length) {
extensions[type] = exts;
for (var i = 0; i < exts.length; i++) {
var extension = exts[i];
if (types[extension]) {
var from = preference.indexOf(db[types[extension]].source), to = preference.indexOf(mime.source);
if ("application/octet-stream" !== types[extension] && (from > to || from === to && "application/" === types[extension].substr(0, 12))) continue;
}
types[extension] = type;
}
}
}));
},
76947: function(__unused_webpack_module, exports) {
!function(global, factory) {
"use strict";
!function(exports) {
var nextTick, asyncNextTick, asyncSetImmediate, noop = function() {}, throwError = function() {
throw new Error("Callback was already called.");
}, DEFAULT_TIMES = 5, DEFAULT_INTERVAL = 0, obj = "object", func = "function", isArray = Array.isArray, nativeKeys = Object.keys, nativePush = Array.prototype.push, iteratorSymbol = typeof Symbol === func && Symbol.iterator;
createImmediate();
var each = createEach(arrayEach, baseEach, symbolEach), map = createMap(arrayEachIndex, baseEachIndex, symbolEachIndex, !0), mapValues = createMap(arrayEachIndex, baseEachKey, symbolEachKey, !1), filter = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, !0), filterSeries = createFilterSeries(!0), filterLimit = createFilterLimit(!0), reject = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, !1), rejectSeries = createFilterSeries(!1), rejectLimit = createFilterLimit(!1), detect = createDetect(arrayEachValue, baseEachValue, symbolEachValue, !0), detectSeries = createDetectSeries(!0), detectLimit = createDetectLimit(!0), every = createEvery(arrayEachValue, baseEachValue, symbolEachValue), everySeries = createEverySeries(), everyLimit = createEveryLimit(), pick = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, !0), pickSeries = createPickSeries(!0), pickLimit = createPickLimit(!0), omit = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, !1), omitSeries = createPickSeries(!1), omitLimit = createPickLimit(!1), transform = createTransform(arrayEachResult, baseEachResult, symbolEachResult), sortBy = createSortBy(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue), concat = createConcat(arrayEachIndex, baseEachIndex, symbolEachIndex), groupBy = createGroupBy(arrayEachValue, baseEachValue, symbolEachValue), parallel = createParallel(arrayEachFunc, baseEachFunc), applyEach = createApplyEach(map), applyEachSeries = createApplyEach(mapSeries), log = createLogger("log"), dir = createLogger("dir"), index = {
VERSION: "2.6.2",
each,
eachSeries,
eachLimit,
forEach: each,
forEachSeries: eachSeries,
forEachLimit: eachLimit,
eachOf: each,
eachOfSeries: eachSeries,
eachOfLimit: eachLimit,
forEachOf: each,
forEachOfSeries: eachSeries,
forEachOfLimit: eachLimit,
map,
mapSeries,
mapLimit,
mapValues,
mapValuesSeries,
mapValuesLimit,
filter,
filterSeries,
filterLimit,
select: filter,
selectSeries: filterSeries,
selectLimit: filterLimit,
reject,
rejectSeries,
rejectLimit,
detect,
detectSeries,
detectLimit,
find: detect,
findSeries: detectSeries,
findLimit: detectLimit,
pick,
pickSeries,
pickLimit,
omit,
omitSeries,
omitLimit,
reduce,
inject: reduce,
foldl: reduce,
reduceRight,
foldr: reduceRight,
transform,
transformSeries,
transformLimit,
sortBy,
sortBySeries,
sortByLimit,
some,
someSeries,
someLimit,
any: some,
anySeries: someSeries,
anyLimit: someLimit,
every,
everySeries,
everyLimit,
all: every,
allSeries: everySeries,
allLimit: everyLimit,
concat,
concatSeries,
concatLimit,
groupBy,
groupBySeries,
groupByLimit,
parallel,
series,
parallelLimit,
tryEach,
waterfall,
angelFall,
angelfall: angelFall,
whilst,
doWhilst,
until,
doUntil,
during,
doDuring,
forever,
compose,
seq,
applyEach,
applyEachSeries,
queue,
priorityQueue,
cargo,
auto,
autoInject,
retry,
retryable,
iterator,
times,
timesSeries,
timesLimit,
race,
apply,
nextTick: asyncNextTick,
setImmediate: asyncSetImmediate,
memoize,
unmemoize,
ensureAsync,
constant,
asyncify,
wrapSync: asyncify,
log,
dir,
reflect,
reflectAll,
timeout,
createLogger,
safe,
fast
};
function createImmediate(safeMode) {
var delay = function(fn) {
var args = slice(arguments, 1);
setTimeout((function() {
fn.apply(null, args);
}));
};
asyncSetImmediate = typeof setImmediate === func ? setImmediate : delay, typeof process === obj && typeof process.nextTick === func ? (nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick, 
asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick) : asyncNextTick = nextTick = asyncSetImmediate, 
!1 === safeMode && (nextTick = function(cb) {
cb();
});
}
function createArray(array) {
for (var index = -1, size = array.length, result = Array(size); ++index < size; ) result[index] = array[index];
return result;
}
function slice(array, start) {
var index = -1, size = array.length - start;
if (size <= 0) return [];
for (var result = Array(size); ++index < size; ) result[index] = array[index + start];
return result;
}
function objectClone(object) {
for (var keys = nativeKeys(object), size = keys.length, index = -1, result = {}; ++index < size; ) {
var key = keys[index];
result[key] = object[key];
}
return result;
}
function compact(array) {
for (var index = -1, size = array.length, result = []; ++index < size; ) {
var value = array[index];
value && (result[result.length] = value);
}
return result;
}
function reverse(array) {
for (var index = -1, size = array.length, result = Array(size), resIndex = size; ++index < size; ) result[--resIndex] = array[index];
return result;
}
function has(object, key) {
return object.hasOwnProperty(key);
}
function notInclude(array, target) {
for (var index = -1, size = array.length; ++index < size; ) if (array[index] === target) return !1;
return !0;
}
function arrayEachSync(array, iterator) {
for (var index = -1, size = array.length; ++index < size; ) iterator(array[index], index);
return array;
}
function baseEachSync(object, iterator, keys) {
for (var index = -1, size = keys.length; ++index < size; ) {
var key = keys[index];
iterator(object[key], key);
}
return object;
}
function timesSync(n, iterator) {
for (var index = -1; ++index < n; ) iterator(index);
}
function sortByCriteria(array, criteria) {
var i, l = array.length, indices = Array(l);
for (i = 0; i < l; i++) indices[i] = i;
quickSort(criteria, 0, l - 1, indices);
for (var result = Array(l), n = 0; n < l; n++) i = indices[n], result[n] = void 0 === i ? array[n] : array[i];
return result;
}
function partition(array, i, j, mid, indices) {
for (var l = i, r = j; l <= r; ) {
for (i = l; l < r && array[l] < mid; ) l++;
for (;r >= i && array[r] >= mid; ) r--;
if (l > r) break;
swap(array, indices, l++, r--);
}
return l;
}
function swap(array, indices, l, r) {
var n = array[l];
array[l] = array[r], array[r] = n;
var i = indices[l];
indices[l] = indices[r], indices[r] = i;
}
function quickSort(array, i, j, indices) {
if (i !== j) {
for (var k = i; ++k <= j && array[i] === array[k]; ) {
var l = k - 1;
if (indices[l] > indices[k]) {
var index = indices[l];
indices[l] = indices[k], indices[k] = index;
}
}
if (!(k > j)) quickSort(array, i, (k = partition(array, i, j, array[array[i] > array[k] ? i : k], indices)) - 1, indices), 
quickSort(array, k, j, indices);
}
}
function makeConcatResult(array) {
var result = [];
return arrayEachSync(array, (function(value) {
value !== noop && (isArray(value) ? nativePush.apply(result, value) : result.push(value));
})), result;
}
function arrayEach(array, iterator, callback) {
var index = -1, size = array.length;
if (3 === iterator.length) for (;++index < size; ) iterator(array[index], index, onlyOnce(callback)); else for (;++index < size; ) iterator(array[index], onlyOnce(callback));
}
function baseEach(object, iterator, callback, keys) {
var key, index = -1, size = keys.length;
if (3 === iterator.length) for (;++index < size; ) iterator(object[key = keys[index]], key, onlyOnce(callback)); else for (;++index < size; ) iterator(object[keys[index]], onlyOnce(callback));
}
function symbolEach(collection, iterator, callback) {
var item, iter = collection[iteratorSymbol](), index = 0;
if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(item.value, index++, onlyOnce(callback)); else for (;!1 === (item = iter.next()).done; ) index++, 
iterator(item.value, onlyOnce(callback));
return index;
}
function arrayEachResult(array, result, iterator, callback) {
var index = -1, size = array.length;
if (4 === iterator.length) for (;++index < size; ) iterator(result, array[index], index, onlyOnce(callback)); else for (;++index < size; ) iterator(result, array[index], onlyOnce(callback));
}
function baseEachResult(object, result, iterator, callback, keys) {
var key, index = -1, size = keys.length;
if (4 === iterator.length) for (;++index < size; ) iterator(result, object[key = keys[index]], key, onlyOnce(callback)); else for (;++index < size; ) iterator(result, object[keys[index]], onlyOnce(callback));
}
function symbolEachResult(collection, result, iterator, callback) {
var item, index = 0, iter = collection[iteratorSymbol]();
if (4 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(result, item.value, index++, onlyOnce(callback)); else for (;!1 === (item = iter.next()).done; ) index++, 
iterator(result, item.value, onlyOnce(callback));
return index;
}
function arrayEachFunc(array, createCallback) {
for (var index = -1, size = array.length; ++index < size; ) array[index](createCallback(index));
}
function baseEachFunc(object, createCallback, keys) {
for (var key, index = -1, size = keys.length; ++index < size; ) object[key = keys[index]](createCallback(key));
}
function arrayEachIndex(array, iterator, createCallback) {
var index = -1, size = array.length;
if (3 === iterator.length) for (;++index < size; ) iterator(array[index], index, createCallback(index)); else for (;++index < size; ) iterator(array[index], createCallback(index));
}
function baseEachIndex(object, iterator, createCallback, keys) {
var key, index = -1, size = keys.length;
if (3 === iterator.length) for (;++index < size; ) iterator(object[key = keys[index]], key, createCallback(index)); else for (;++index < size; ) iterator(object[keys[index]], createCallback(index));
}
function symbolEachIndex(collection, iterator, createCallback) {
var item, index = 0, iter = collection[iteratorSymbol]();
if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(item.value, index, createCallback(index++)); else for (;!1 === (item = iter.next()).done; ) iterator(item.value, createCallback(index++));
return index;
}
function baseEachKey(object, iterator, createCallback, keys) {
var key, index = -1, size = keys.length;
if (3 === iterator.length) for (;++index < size; ) iterator(object[key = keys[index]], key, createCallback(key)); else for (;++index < size; ) iterator(object[key = keys[index]], createCallback(key));
}
function symbolEachKey(collection, iterator, createCallback) {
var item, index = 0, iter = collection[iteratorSymbol]();
if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(item.value, index, createCallback(index++)); else for (;!1 === (item = iter.next()).done; ) iterator(item.value, createCallback(index++));
return index;
}
function arrayEachValue(array, iterator, createCallback) {
var value, index = -1, size = array.length;
if (3 === iterator.length) for (;++index < size; ) iterator(value = array[index], index, createCallback(value)); else for (;++index < size; ) iterator(value = array[index], createCallback(value));
}
function baseEachValue(object, iterator, createCallback, keys) {
var key, value, index = -1, size = keys.length;
if (3 === iterator.length) for (;++index < size; ) iterator(value = object[key = keys[index]], key, createCallback(value)); else for (;++index < size; ) iterator(value = object[keys[index]], createCallback(value));
}
function symbolEachValue(collection, iterator, createCallback) {
var value, item, index = 0, iter = collection[iteratorSymbol]();
if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, index++, createCallback(value)); else for (;!1 === (item = iter.next()).done; ) index++, 
iterator(value = item.value, createCallback(value));
return index;
}
function arrayEachIndexValue(array, iterator, createCallback) {
var value, index = -1, size = array.length;
if (3 === iterator.length) for (;++index < size; ) iterator(value = array[index], index, createCallback(index, value)); else for (;++index < size; ) iterator(value = array[index], createCallback(index, value));
}
function baseEachIndexValue(object, iterator, createCallback, keys) {
var key, value, index = -1, size = keys.length;
if (3 === iterator.length) for (;++index < size; ) iterator(value = object[key = keys[index]], key, createCallback(index, value)); else for (;++index < size; ) iterator(value = object[keys[index]], createCallback(index, value));
}
function symbolEachIndexValue(collection, iterator, createCallback) {
var value, item, index = 0, iter = collection[iteratorSymbol]();
if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, index, createCallback(index++, value)); else for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, createCallback(index++, value));
return index;
}
function baseEachKeyValue(object, iterator, createCallback, keys) {
var key, value, index = -1, size = keys.length;
if (3 === iterator.length) for (;++index < size; ) iterator(value = object[key = keys[index]], key, createCallback(key, value)); else for (;++index < size; ) iterator(value = object[key = keys[index]], createCallback(key, value));
}
function symbolEachKeyValue(collection, iterator, createCallback) {
var value, item, index = 0, iter = collection[iteratorSymbol]();
if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, index, createCallback(index++, value)); else for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, createCallback(index++, value));
return index;
}
function onlyOnce(func) {
return function(err, res) {
var fn = func;
func = throwError, fn(err, res);
};
}
function once(func) {
return function(err, res) {
var fn = func;
func = noop, fn(err, res);
};
}
function createEach(arrayEach, baseEach, symbolEach) {
return function(collection, iterator, callback) {
var size, keys;
callback = once(callback || noop);
var completed = 0;
function done(err, bool) {
err ? (callback = once(callback))(err) : ++completed === size ? callback(null) : !1 === bool && (callback = once(callback))(null);
}
isArray(collection) ? (size = collection.length, arrayEach(collection, iterator, done)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, iterator, done)) && size === completed && callback(null) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, baseEach(collection, iterator, done, keys))), size || callback(null);
};
}
function createMap(arrayEach, baseEach, symbolEach, useArray) {
var init, clone;
return useArray ? (init = Array, clone = createArray) : (init = function() {
return {};
}, clone = objectClone), function(collection, iterator, callback) {
var size, keys, result;
callback = callback || noop;
var completed = 0;
function createCallback(key) {
return function(err, res) {
if (null === key && throwError(), err) return key = null, void (callback = once(callback))(err, clone(result));
result[key] = res, key = null, ++completed === size && callback(null, result);
};
}
isArray(collection) ? (size = collection.length, result = init(size), arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (result = init(0), 
(size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result)) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, result = init(size), baseEach(collection, iterator, createCallback, keys))), 
size || callback(null, init());
};
}
function createFilter(arrayEach, baseEach, symbolEach, bool) {
return function(collection, iterator, callback) {
var size, keys, result;
callback = callback || noop;
var completed = 0;
if (isArray(collection) ? (size = collection.length, result = Array(size), arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (result = [], 
(size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, compact(result))) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, result = Array(size), baseEach(collection, iterator, createCallback, keys))), 
!size) return callback(null, []);
function createCallback(index, value) {
return function(err, res) {
if (null === index && throwError(), err) return index = null, void (callback = once(callback))(err);
!!res === bool && (result[index] = value), index = null, ++completed === size && callback(null, compact(result));
};
}
};
}
function createFilterSeries(bool) {
return function(collection, iterator, callback) {
var size, key, value, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0, result = [];
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, []);
function arrayIterator() {
value = collection[completed], iterator(value, done);
}
function arrayIteratorWithIndex() {
value = collection[completed], iterator(value, completed, done);
}
function symbolIterator() {
item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, done);
}
function symbolIteratorWithKey() {
item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, completed, done);
}
function objectIterator() {
key = keys[completed], value = collection[key], iterator(value, done);
}
function objectIteratorWithKey() {
key = keys[completed], value = collection[key], iterator(value, key, done);
}
function done(err, res) {
err ? callback(err) : (!!res === bool && (result[result.length] = value), ++completed === size ? (iterate = throwError, 
callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1);
}
iterate();
};
}
function createFilterLimit(bool) {
return function(collection, limit, iterator, callback) {
var size, index, key, value, keys, iter, item, iterate, result;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
result = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, []);
function arrayIterator() {
(index = started++) < size && (value = collection[index], iterator(value, createCallback(value, index)));
}
function arrayIteratorWithIndex() {
(index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value, index)));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (value = item.value, iterator(value, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, compact(result)));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? (value = item.value, iterator(value, started, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, compact(result)));
}
function objectIterator() {
(index = started++) < size && (value = collection[keys[index]], iterator(value, createCallback(value, index)));
}
function objectIteratorWithKey() {
(index = started++) < size && (key = keys[index], value = collection[key], iterator(value, key, createCallback(value, index)));
}
function createCallback(value, index) {
return function(err, res) {
if (null === index && throwError(), err) return index = null, iterate = noop, void (callback = once(callback))(err);
!!res === bool && (result[index] = value), index = null, ++completed === size ? (callback = onlyOnce(callback))(null, compact(result)) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
result = result || Array(size), timesSync(limit > size ? size : limit, iterate);
};
}
function eachSeries(collection, iterator, callback) {
var size, key, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null);
function arrayIterator() {
iterator(collection[completed], done);
}
function arrayIteratorWithIndex() {
iterator(collection[completed], completed, done);
}
function symbolIterator() {
(item = iter.next()).done ? callback(null) : iterator(item.value, done);
}
function symbolIteratorWithKey() {
(item = iter.next()).done ? callback(null) : iterator(item.value, completed, done);
}
function objectIterator() {
iterator(collection[keys[completed]], done);
}
function objectIteratorWithKey() {
key = keys[completed], iterator(collection[key], key, done);
}
function done(err, bool) {
err ? callback(err) : ++completed === size || !1 === bool ? (iterate = throwError, 
callback(null)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function eachLimit(collection, limit, iterator, callback) {
var size, index, key, keys, iter, item, iterate;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection)) size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator; else if (collection) if (iteratorSymbol && collection[iteratorSymbol]) size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator; else {
if (typeof collection !== obj) return callback(null);
keys = nativeKeys(collection), size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator;
} else ;
if (!size || isNaN(limit) || limit < 1) return callback(null);
function arrayIterator() {
started < size && iterator(collection[started++], done);
}
function arrayIteratorWithIndex() {
(index = started++) < size && iterator(collection[index], index, done);
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (started++, iterator(item.value, done)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? iterator(item.value, started++, done) : completed === started && iterator !== noop && (iterator = noop, 
callback(null));
}
function objectIterator() {
started < size && iterator(collection[keys[started++]], done);
}
function objectIteratorWithKey() {
(index = started++) < size && (key = keys[index], iterator(collection[key], key, done));
}
function done(err, bool) {
err || !1 === bool ? (iterate = noop, (callback = once(callback))(err)) : ++completed === size ? (iterator = noop, 
iterate = throwError, (callback = onlyOnce(callback))(null)) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
}
timesSync(limit > size ? size : limit, iterate);
}
function mapSeries(collection, iterator, callback) {
var size, key, keys, iter, item, result, iterate;
callback = callback || noop;
var sync = !1, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
result = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, []);
function arrayIterator() {
iterator(collection[completed], done);
}
function arrayIteratorWithIndex() {
iterator(collection[completed], completed, done);
}
function symbolIterator() {
(item = iter.next()).done ? callback(null, result) : iterator(item.value, done);
}
function symbolIteratorWithKey() {
(item = iter.next()).done ? callback(null, result) : iterator(item.value, completed, done);
}
function objectIterator() {
iterator(collection[keys[completed]], done);
}
function objectIteratorWithKey() {
key = keys[completed], iterator(collection[key], key, done);
}
function done(err, res) {
if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, createArray(result));
result[completed] = res, ++completed === size ? (iterate = throwError, callback(null, result), 
callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
result = result || Array(size), iterate();
}
function mapLimit(collection, limit, iterator, callback) {
var size, index, key, keys, iter, item, result, iterate;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
result = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, []);
function arrayIterator() {
(index = started++) < size && iterator(collection[index], createCallback(index));
}
function arrayIteratorWithIndex() {
(index = started++) < size && iterator(collection[index], index, createCallback(index));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? iterator(item.value, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? iterator(item.value, started, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function objectIterator() {
(index = started++) < size && iterator(collection[keys[index]], createCallback(index));
}
function objectIteratorWithKey() {
(index = started++) < size && (key = keys[index], iterator(collection[key], key, createCallback(index)));
}
function createCallback(index) {
return function(err, res) {
if (null === index && throwError(), err) return index = null, iterate = noop, void (callback = once(callback))(err, createArray(result));
result[index] = res, index = null, ++completed === size ? (iterate = throwError, 
callback(null, result), callback = throwError) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
result = result || Array(size), timesSync(limit > size ? size : limit, iterate);
}
function mapValuesSeries(collection, iterator, callback) {
var size, key, keys, iter, item, iterate;
callback = callback || noop;
var sync = !1, result = {}, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, result);
function arrayIterator() {
key = completed, iterator(collection[completed], done);
}
function arrayIteratorWithIndex() {
key = completed, iterator(collection[completed], completed, done);
}
function symbolIterator() {
key = completed, (item = iter.next()).done ? callback(null, result) : iterator(item.value, done);
}
function symbolIteratorWithKey() {
key = completed, (item = iter.next()).done ? callback(null, result) : iterator(item.value, completed, done);
}
function objectIterator() {
key = keys[completed], iterator(collection[key], done);
}
function objectIteratorWithKey() {
key = keys[completed], iterator(collection[key], key, done);
}
function done(err, res) {
if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, objectClone(result));
result[key] = res, ++completed === size ? (iterate = throwError, callback(null, result), 
callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function mapValuesLimit(collection, limit, iterator, callback) {
var size, index, key, keys, iter, item, iterate;
callback = callback || noop;
var sync = !1, result = {}, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, result);
function arrayIterator() {
(index = started++) < size && iterator(collection[index], createCallback(index));
}
function arrayIteratorWithIndex() {
(index = started++) < size && iterator(collection[index], index, createCallback(index));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? iterator(item.value, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? iterator(item.value, started, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function objectIterator() {
(index = started++) < size && (key = keys[index], iterator(collection[key], createCallback(key)));
}
function objectIteratorWithKey() {
(index = started++) < size && (key = keys[index], iterator(collection[key], key, createCallback(key)));
}
function createCallback(key) {
return function(err, res) {
if (null === key && throwError(), err) return key = null, iterate = noop, void (callback = once(callback))(err, objectClone(result));
result[key] = res, key = null, ++completed === size ? callback(null, result) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
timesSync(limit > size ? size : limit, iterate);
}
function createDetect(arrayEach, baseEach, symbolEach, bool) {
return function(collection, iterator, callback) {
var size, keys;
callback = callback || noop;
var completed = 0;
function createCallback(value) {
var called = !1;
return function(err, res) {
called && throwError(), called = !0, err ? (callback = once(callback))(err) : !!res === bool ? (callback = once(callback))(null, value) : ++completed === size && callback(null);
};
}
isArray(collection) ? (size = collection.length, arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, baseEach(collection, iterator, createCallback, keys))), size || callback(null);
};
}
function createDetectSeries(bool) {
return function(collection, iterator, callback) {
var size, key, value, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null);
function arrayIterator() {
value = collection[completed], iterator(value, done);
}
function arrayIteratorWithIndex() {
value = collection[completed], iterator(value, completed, done);
}
function symbolIterator() {
item = iter.next(), value = item.value, item.done ? callback(null) : iterator(value, done);
}
function symbolIteratorWithKey() {
item = iter.next(), value = item.value, item.done ? callback(null) : iterator(value, completed, done);
}
function objectIterator() {
value = collection[keys[completed]], iterator(value, done);
}
function objectIteratorWithKey() {
key = keys[completed], value = collection[key], iterator(value, key, done);
}
function done(err, res) {
err ? callback(err) : !!res === bool ? (iterate = throwError, callback(null, value)) : ++completed === size ? (iterate = throwError, 
callback(null)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
};
}
function createDetectLimit(bool) {
return function(collection, limit, iterator, callback) {
var size, index, key, value, keys, iter, item, iterate;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null);
function arrayIterator() {
(index = started++) < size && (value = collection[index], iterator(value, createCallback(value)));
}
function arrayIteratorWithIndex() {
(index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value)));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (started++, value = item.value, iterator(value, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? (value = item.value, iterator(value, started++, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null));
}
function objectIterator() {
(index = started++) < size && (value = collection[keys[index]], iterator(value, createCallback(value)));
}
function objectIteratorWithKey() {
started < size && (key = keys[started++], value = collection[key], iterator(value, key, createCallback(value)));
}
function createCallback(value) {
var called = !1;
return function(err, res) {
called && throwError(), called = !0, err ? (iterate = noop, (callback = once(callback))(err)) : !!res === bool ? (iterate = noop, 
(callback = once(callback))(null, value)) : ++completed === size ? callback(null) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
timesSync(limit > size ? size : limit, iterate);
};
}
function createPick(arrayEach, baseEach, symbolEach, bool) {
return function(collection, iterator, callback) {
var size, keys;
callback = callback || noop;
var completed = 0, result = {};
if (isArray(collection) ? (size = collection.length, arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, baseEach(collection, iterator, createCallback, keys))), !size) return callback(null, {});
function createCallback(key, value) {
return function(err, res) {
if (null === key && throwError(), err) return key = null, void (callback = once(callback))(err, objectClone(result));
!!res === bool && (result[key] = value), key = null, ++completed === size && callback(null, result);
};
}
};
}
function createPickSeries(bool) {
return function(collection, iterator, callback) {
var size, key, value, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, result = {}, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, {});
function arrayIterator() {
key = completed, value = collection[completed], iterator(value, done);
}
function arrayIteratorWithIndex() {
key = completed, value = collection[completed], iterator(value, completed, done);
}
function symbolIterator() {
key = completed, item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, done);
}
function symbolIteratorWithKey() {
key = completed, item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, key, done);
}
function objectIterator() {
key = keys[completed], value = collection[key], iterator(value, done);
}
function objectIteratorWithKey() {
key = keys[completed], value = collection[key], iterator(value, key, done);
}
function done(err, res) {
err ? callback(err, result) : (!!res === bool && (result[key] = value), ++completed === size ? (iterate = throwError, 
callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1);
}
iterate();
};
}
function createPickLimit(bool) {
return function(collection, limit, iterator, callback) {
var size, index, key, value, keys, iter, item, iterate;
callback = callback || noop;
var sync = !1, result = {}, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, {});
function arrayIterator() {
(index = started++) < size && (value = collection[index], iterator(value, createCallback(value, index)));
}
function arrayIteratorWithIndex() {
(index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value, index)));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (value = item.value, iterator(value, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? (value = item.value, iterator(value, started, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function objectIterator() {
started < size && (key = keys[started++], value = collection[key], iterator(value, createCallback(value, key)));
}
function objectIteratorWithKey() {
started < size && (key = keys[started++], value = collection[key], iterator(value, key, createCallback(value, key)));
}
function createCallback(value, key) {
return function(err, res) {
if (null === key && throwError(), err) return key = null, iterate = noop, void (callback = once(callback))(err, objectClone(result));
!!res === bool && (result[key] = value), key = null, ++completed === size ? (iterate = throwError, 
(callback = onlyOnce(callback))(null, result)) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
timesSync(limit > size ? size : limit, iterate);
};
}
function reduce(collection, result, iterator, callback) {
var size, key, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 4 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 4 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, result);
function arrayIterator(result) {
iterator(result, collection[completed], done);
}
function arrayIteratorWithIndex(result) {
iterator(result, collection[completed], completed, done);
}
function symbolIterator(result) {
(item = iter.next()).done ? callback(null, result) : iterator(result, item.value, done);
}
function symbolIteratorWithKey(result) {
(item = iter.next()).done ? callback(null, result) : iterator(result, item.value, completed, done);
}
function objectIterator(result) {
iterator(result, collection[keys[completed]], done);
}
function objectIteratorWithKey(result) {
key = keys[completed], iterator(result, collection[key], key, done);
}
function done(err, result) {
err ? callback(err, result) : ++completed === size ? (iterator = throwError, callback(null, result)) : sync ? nextTick((function() {
iterate(result);
})) : (sync = !0, iterate(result)), sync = !1;
}
iterate(result);
}
function reduceRight(collection, result, iterator, callback) {
var resIndex, index, key, keys, iter, item, col, iterate;
callback = onlyOnce(callback || noop);
var sync = !1;
if (isArray(collection)) resIndex = collection.length, iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator; else if (collection) if (iteratorSymbol && collection[iteratorSymbol]) {
for (col = [], iter = collection[iteratorSymbol](), index = -1; !1 === (item = iter.next()).done; ) col[++index] = item.value;
collection = col, resIndex = col.length, iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator;
} else typeof collection === obj && (keys = nativeKeys(collection), resIndex = keys.length, 
iterate = 4 === iterator.length ? objectIteratorWithKey : objectIterator); else ;
if (!resIndex) return callback(null, result);
function arrayIterator(result) {
iterator(result, collection[--resIndex], done);
}
function arrayIteratorWithIndex(result) {
iterator(result, collection[--resIndex], resIndex, done);
}
function objectIterator(result) {
iterator(result, collection[keys[--resIndex]], done);
}
function objectIteratorWithKey(result) {
key = keys[--resIndex], iterator(result, collection[key], key, done);
}
function done(err, result) {
err ? callback(err, result) : 0 === resIndex ? (iterate = throwError, callback(null, result)) : sync ? nextTick((function() {
iterate(result);
})) : (sync = !0, iterate(result)), sync = !1;
}
iterate(result);
}
function createTransform(arrayEach, baseEach, symbolEach) {
return function(collection, accumulator, iterator, callback) {
var size, keys, result;
3 === arguments.length && (callback = iterator, iterator = accumulator, accumulator = void 0), 
callback = callback || noop;
var completed = 0;
function done(err, bool) {
err ? (callback = once(callback))(err, isArray(result) ? createArray(result) : objectClone(result)) : ++completed === size ? callback(null, result) : !1 === bool && (callback = once(callback))(null, isArray(result) ? createArray(result) : objectClone(result));
}
isArray(collection) ? (size = collection.length, arrayEach(collection, result = void 0 !== accumulator ? accumulator : [], iterator, done)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, result = void 0 !== accumulator ? accumulator : {}, iterator, done)) && size === completed && callback(null, result) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, baseEach(collection, result = void 0 !== accumulator ? accumulator : {}, iterator, done, keys))), 
size || callback(null, void 0 !== accumulator ? accumulator : result || {});
};
}
function transformSeries(collection, accumulator, iterator, callback) {
var size, key, keys, iter, item, iterate, result;
3 === arguments.length && (callback = iterator, iterator = accumulator, accumulator = void 0), 
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0;
if (isArray(collection) ? (size = collection.length, result = void 0 !== accumulator ? accumulator : [], 
iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), result = void 0 !== accumulator ? accumulator : {}, 
iterate = 4 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, result = void 0 !== accumulator ? accumulator : {}, iterate = 4 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, void 0 !== accumulator ? accumulator : result || {});
function arrayIterator() {
iterator(result, collection[completed], done);
}
function arrayIteratorWithIndex() {
iterator(result, collection[completed], completed, done);
}
function symbolIterator() {
(item = iter.next()).done ? callback(null, result) : iterator(result, item.value, done);
}
function symbolIteratorWithKey() {
(item = iter.next()).done ? callback(null, result) : iterator(result, item.value, completed, done);
}
function objectIterator() {
iterator(result, collection[keys[completed]], done);
}
function objectIteratorWithKey() {
key = keys[completed], iterator(result, collection[key], key, done);
}
function done(err, bool) {
err ? callback(err, result) : ++completed === size || !1 === bool ? (iterate = throwError, 
callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function transformLimit(collection, limit, accumulator, iterator, callback) {
var size, index, key, keys, iter, item, iterate, result;
4 === arguments.length && (callback = iterator, iterator = accumulator, accumulator = void 0), 
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, result = void 0 !== accumulator ? accumulator : [], 
iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), result = void 0 !== accumulator ? accumulator : {}, 
iterate = 4 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, result = void 0 !== accumulator ? accumulator : {}, iterate = 4 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, void 0 !== accumulator ? accumulator : result || {});
function arrayIterator() {
(index = started++) < size && iterator(result, collection[index], onlyOnce(done));
}
function arrayIteratorWithIndex() {
(index = started++) < size && iterator(result, collection[index], index, onlyOnce(done));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (started++, iterator(result, item.value, onlyOnce(done))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? iterator(result, item.value, started++, onlyOnce(done)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function objectIterator() {
(index = started++) < size && iterator(result, collection[keys[index]], onlyOnce(done));
}
function objectIteratorWithKey() {
(index = started++) < size && (key = keys[index], iterator(result, collection[key], key, onlyOnce(done)));
}
function done(err, bool) {
err || !1 === bool ? (iterate = noop, callback(err || null, isArray(result) ? createArray(result) : objectClone(result)), 
callback = noop) : ++completed === size ? (iterator = noop, callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
}
timesSync(limit > size ? size : limit, iterate);
}
function createSortBy(arrayEach, baseEach, symbolEach) {
return function(collection, iterator, callback) {
var size, array, criteria;
callback = callback || noop;
var completed = 0;
if (isArray(collection)) size = collection.length, array = Array(size), criteria = Array(size), 
arrayEach(collection, iterator, createCallback); else if (collection) {
if (iteratorSymbol && collection[iteratorSymbol]) array = [], criteria = [], (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, sortByCriteria(array, criteria)); else if (typeof collection === obj) {
var keys = nativeKeys(collection);
size = keys.length, array = Array(size), criteria = Array(size), baseEach(collection, iterator, createCallback, keys);
}
} else ;
function createCallback(index, value) {
var called = !1;
return array[index] = value, function(err, criterion) {
called && throwError(), called = !0, criteria[index] = criterion, err ? (callback = once(callback))(err) : ++completed === size && callback(null, sortByCriteria(array, criteria));
};
}
size || callback(null, []);
};
}
function sortBySeries(collection, iterator, callback) {
var size, key, value, keys, iter, item, array, criteria, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0;
if (isArray(collection) ? (size = collection.length, array = collection, criteria = Array(size), 
iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
array = [], criteria = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, array = Array(size), criteria = Array(size), iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, []);
function arrayIterator() {
value = collection[completed], iterator(value, done);
}
function arrayIteratorWithIndex() {
value = collection[completed], iterator(value, completed, done);
}
function symbolIterator() {
if ((item = iter.next()).done) return callback(null, sortByCriteria(array, criteria));
value = item.value, array[completed] = value, iterator(value, done);
}
function symbolIteratorWithKey() {
if ((item = iter.next()).done) return callback(null, sortByCriteria(array, criteria));
value = item.value, array[completed] = value, iterator(value, completed, done);
}
function objectIterator() {
value = collection[keys[completed]], array[completed] = value, iterator(value, done);
}
function objectIteratorWithKey() {
key = keys[completed], value = collection[key], array[completed] = value, iterator(value, key, done);
}
function done(err, criterion) {
criteria[completed] = criterion, err ? callback(err) : ++completed === size ? (iterate = throwError, 
callback(null, sortByCriteria(array, criteria))) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
}
iterate();
}
function sortByLimit(collection, limit, iterator, callback) {
var size, index, key, value, array, keys, iter, item, criteria, iterate;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection) ? (size = collection.length, array = collection, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), array = [], criteria = [], iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, array = Array(size), iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, []);
function arrayIterator() {
started < size && (value = collection[started], iterator(value, createCallback(value, started++)));
}
function arrayIteratorWithIndex() {
(index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value, index)));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (value = item.value, array[started] = value, 
iterator(value, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, sortByCriteria(array, criteria)));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? (value = item.value, array[started] = value, 
iterator(value, started, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, sortByCriteria(array, criteria)));
}
function objectIterator() {
started < size && (value = collection[keys[started]], array[started] = value, iterator(value, createCallback(value, started++)));
}
function objectIteratorWithKey() {
started < size && (key = keys[started], value = collection[key], array[started] = value, 
iterator(value, key, createCallback(value, started++)));
}
function createCallback(value, index) {
var called = !1;
return function(err, criterion) {
called && throwError(), called = !0, criteria[index] = criterion, err ? (iterate = noop, 
callback(err), callback = noop) : ++completed === size ? callback(null, sortByCriteria(array, criteria)) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
criteria = criteria || Array(size), timesSync(limit > size ? size : limit, iterate);
}
function some(collection, iterator, callback) {
function done(err, res) {
if (err) return callback(err);
callback(null, !!res);
}
callback = callback || noop, detect(collection, iterator, done);
}
function someSeries(collection, iterator, callback) {
function done(err, res) {
if (err) return callback(err);
callback(null, !!res);
}
callback = callback || noop, detectSeries(collection, iterator, done);
}
function someLimit(collection, limit, iterator, callback) {
function done(err, res) {
if (err) return callback(err);
callback(null, !!res);
}
callback = callback || noop, detectLimit(collection, limit, iterator, done);
}
function createEvery(arrayEach, baseEach, symbolEach) {
var deny = createDetect(arrayEach, baseEach, symbolEach, !1);
return function(collection, iterator, callback) {
function done(err, res) {
if (err) return callback(err);
callback(null, !res);
}
callback = callback || noop, deny(collection, iterator, done);
};
}
function createEverySeries() {
var denySeries = createDetectSeries(!1);
return function(collection, iterator, callback) {
function done(err, res) {
if (err) return callback(err);
callback(null, !res);
}
callback = callback || noop, denySeries(collection, iterator, done);
};
}
function createEveryLimit() {
var denyLimit = createDetectLimit(!1);
return function(collection, limit, iterator, callback) {
function done(err, res) {
if (err) return callback(err);
callback(null, !res);
}
callback = callback || noop, denyLimit(collection, limit, iterator, done);
};
}
function createConcat(arrayEach, baseEach, symbolEach) {
return function(collection, iterator, callback) {
var size, result;
callback = callback || noop;
var completed = 0;
if (isArray(collection)) size = collection.length, result = Array(size), arrayEach(collection, iterator, createCallback); else if (collection) {
if (iteratorSymbol && collection[iteratorSymbol]) result = [], (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result); else if (typeof collection === obj) {
var keys = nativeKeys(collection);
size = keys.length, result = Array(size), baseEach(collection, iterator, createCallback, keys);
}
} else ;
function createCallback(index) {
return function(err, res) {
if (null === index && throwError(), err) return index = null, callback = once(callback), 
arrayEachSync(result, (function(array, index) {
void 0 === array && (result[index] = noop);
})), void callback(err, makeConcatResult(result));
switch (arguments.length) {
case 0:
case 1:
result[index] = noop;
break;

case 2:
result[index] = res;
break;

default:
result[index] = slice(arguments, 1);
}
index = null, ++completed === size && callback(null, makeConcatResult(result));
};
}
size || callback(null, []);
};
}
function concatSeries(collection, iterator, callback) {
var size, key, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, result = [], completed = 0;
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, result);
function arrayIterator() {
iterator(collection[completed], done);
}
function arrayIteratorWithIndex() {
iterator(collection[completed], completed, done);
}
function symbolIterator() {
(item = iter.next()).done ? callback(null, result) : iterator(item.value, done);
}
function symbolIteratorWithKey() {
(item = iter.next()).done ? callback(null, result) : iterator(item.value, completed, done);
}
function objectIterator() {
iterator(collection[keys[completed]], done);
}
function objectIteratorWithKey() {
key = keys[completed], iterator(collection[key], key, done);
}
function done(err, array) {
isArray(array) ? nativePush.apply(result, array) : arguments.length >= 2 && nativePush.apply(result, slice(arguments, 1)), 
err ? callback(err, result) : ++completed === size ? (iterate = throwError, callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
}
iterate();
}
function concatLimit(collection, limit, iterator, callback) {
var size, key, iter, item, iterate, result;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(collection)) size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator; else if (collection) {
if (iteratorSymbol && collection[iteratorSymbol]) size = 1 / 0, result = [], iter = collection[iteratorSymbol](), 
iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator; else if (typeof collection === obj) {
var keys = nativeKeys(collection);
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator;
}
} else ;
if (!size || isNaN(limit) || limit < 1) return callback(null, []);
function arrayIterator() {
started < size && iterator(collection[started], createCallback(started++));
}
function arrayIteratorWithIndex() {
started < size && iterator(collection[started], started, createCallback(started++));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? iterator(item.value, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, makeConcatResult(result)));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? iterator(item.value, started, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, makeConcatResult(result)));
}
function objectIterator() {
started < size && iterator(collection[keys[started]], createCallback(started++));
}
function objectIteratorWithKey() {
started < size && (key = keys[started], iterator(collection[key], key, createCallback(started++)));
}
function createCallback(index) {
return function(err, res) {
if (null === index && throwError(), err) return index = null, iterate = noop, callback = once(callback), 
arrayEachSync(result, (function(array, index) {
void 0 === array && (result[index] = noop);
})), void callback(err, makeConcatResult(result));
switch (arguments.length) {
case 0:
case 1:
result[index] = noop;
break;

case 2:
result[index] = res;
break;

default:
result[index] = slice(arguments, 1);
}
index = null, ++completed === size ? (iterate = throwError, callback(null, makeConcatResult(result)), 
callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
};
}
result = result || Array(size), timesSync(limit > size ? size : limit, iterate);
}
function createGroupBy(arrayEach, baseEach, symbolEach) {
return function(collection, iterator, callback) {
var size;
callback = callback || noop;
var completed = 0, result = {};
if (isArray(collection)) size = collection.length, arrayEach(collection, iterator, createCallback); else if (collection) {
if (iteratorSymbol && collection[iteratorSymbol]) (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result); else if (typeof collection === obj) {
var keys = nativeKeys(collection);
size = keys.length, baseEach(collection, iterator, createCallback, keys);
}
} else ;
function createCallback(value) {
var called = !1;
return function(err, key) {
if (called && throwError(), called = !0, err) (callback = once(callback))(err, objectClone(result)); else {
var array = result[key];
array ? array.push(value) : result[key] = [ value ], ++completed === size && callback(null, result);
}
};
}
size || callback(null, {});
};
}
function groupBySeries(collection, iterator, callback) {
var size, key, value, keys, iter, item, iterate;
callback = onlyOnce(callback || noop);
var sync = !1, completed = 0, result = {};
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size) return callback(null, result);
function arrayIterator() {
value = collection[completed], iterator(value, done);
}
function arrayIteratorWithIndex() {
value = collection[completed], iterator(value, completed, done);
}
function symbolIterator() {
item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, done);
}
function symbolIteratorWithKey() {
item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, completed, done);
}
function objectIterator() {
value = collection[keys[completed]], iterator(value, done);
}
function objectIteratorWithKey() {
key = keys[completed], value = collection[key], iterator(value, key, done);
}
function done(err, key) {
if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, objectClone(result));
var array = result[key];
array ? array.push(value) : result[key] = [ value ], ++completed === size ? (iterate = throwError, 
callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function groupByLimit(collection, limit, iterator, callback) {
var size, index, key, value, keys, iter, item, iterate;
callback = callback || noop;
var sync = !1, started = 0, completed = 0, result = {};
if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
size = keys.length, iterate = 3 === iterator.length ? objectIteratorWithKey : objectIterator)), 
!size || isNaN(limit) || limit < 1) return callback(null, result);
function arrayIterator() {
started < size && (value = collection[started++], iterator(value, createCallback(value)));
}
function arrayIteratorWithIndex() {
(index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value)));
}
function symbolIterator() {
!1 === (item = iter.next()).done ? (started++, value = item.value, iterator(value, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function symbolIteratorWithKey() {
!1 === (item = iter.next()).done ? (value = item.value, iterator(value, started++, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
callback(null, result));
}
function objectIterator() {
started < size && (value = collection[keys[started++]], iterator(value, createCallback(value)));
}
function objectIteratorWithKey() {
started < size && (key = keys[started++], value = collection[key], iterator(value, key, createCallback(value)));
}
function createCallback(value) {
var called = !1;
return function(err, key) {
if (called && throwError(), called = !0, err) return iterate = noop, void (callback = once(callback))(err, objectClone(result));
var array = result[key];
array ? array.push(value) : result[key] = [ value ], ++completed === size ? callback(null, result) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
timesSync(limit > size ? size : limit, iterate);
}
function createParallel(arrayEach, baseEach) {
return function(tasks, callback) {
var size, keys, result;
callback = callback || noop;
var completed = 0;
function createCallback(key) {
return function(err, res) {
if (null === key && throwError(), err) return key = null, void (callback = once(callback))(err, result);
result[key] = arguments.length <= 2 ? res : slice(arguments, 1), key = null, ++completed === size && callback(null, result);
};
}
isArray(tasks) ? (size = tasks.length, result = Array(size), arrayEach(tasks, createCallback)) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), 
size = keys.length, result = {}, baseEach(tasks, createCallback, keys)), size || callback(null, result);
};
}
function series(tasks, callback) {
var size, key, keys, result, iterate;
callback = callback || noop;
var sync = !1, completed = 0;
if (isArray(tasks)) size = tasks.length, result = Array(size), iterate = arrayIterator; else {
if (!tasks || typeof tasks !== obj) return callback(null);
keys = nativeKeys(tasks), size = keys.length, result = {}, iterate = objectIterator;
}
if (!size) return callback(null, result);
function arrayIterator() {
key = completed, tasks[completed](done);
}
function objectIterator() {
key = keys[completed], tasks[key](done);
}
function done(err, res) {
if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, result);
result[key] = arguments.length <= 2 ? res : slice(arguments, 1), ++completed === size ? (iterate = throwError, 
callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function parallelLimit(tasks, limit, callback) {
var size, index, key, keys, result, iterate;
callback = callback || noop;
var sync = !1, started = 0, completed = 0;
if (isArray(tasks) ? (size = tasks.length, result = Array(size), iterate = arrayIterator) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), 
size = keys.length, result = {}, iterate = objectIterator), !size || isNaN(limit) || limit < 1) return callback(null, result);
function arrayIterator() {
(index = started++) < size && tasks[index](createCallback(index));
}
function objectIterator() {
started < size && (key = keys[started++], tasks[key](createCallback(key)));
}
function createCallback(key) {
return function(err, res) {
if (null === key && throwError(), err) return key = null, iterate = noop, void (callback = once(callback))(err, result);
result[key] = arguments.length <= 2 ? res : slice(arguments, 1), key = null, ++completed === size ? callback(null, result) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
timesSync(limit > size ? size : limit, iterate);
}
function tryEach(tasks, callback) {
var size, keys, iterate;
callback = callback || noop;
var completed = 0;
if (isArray(tasks) ? (size = tasks.length, iterate = arrayIterator) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), 
size = keys.length, iterate = objectIterator), !size) return callback(null);
function arrayIterator() {
tasks[completed](done);
}
function objectIterator() {
tasks[keys[completed]](done);
}
function done(err, res) {
err ? ++completed === size ? callback(err) : (!0, iterate()) : callback(null, arguments.length <= 2 ? res : slice(arguments, 1)), 
!1;
}
iterate();
}
function checkWaterfallTasks(tasks, callback) {
return isArray(tasks) ? 0 !== tasks.length || (callback(null), !1) : (callback(new Error("First argument to waterfall must be an array of functions")), 
!1);
}
function waterfallIterator(func, args, next) {
switch (args.length) {
case 0:
case 1:
return func(next);

case 2:
return func(args[1], next);

case 3:
return func(args[1], args[2], next);

case 4:
return func(args[1], args[2], args[3], next);

case 5:
return func(args[1], args[2], args[3], args[4], next);

case 6:
return func(args[1], args[2], args[3], args[4], args[5], next);

default:
return (args = slice(args, 1)).push(next), func.apply(null, args);
}
}
function waterfall(tasks, callback) {
if (checkWaterfallTasks(tasks, callback = callback || noop)) {
var func, args, done, sync, completed = 0, size = tasks.length;
waterfallIterator(tasks[0], [], createCallback(0));
}
function iterate() {
waterfallIterator(func, args, createCallback(func));
}
function createCallback(index) {
return function(err, res) {
return void 0 === index && (callback = noop, throwError()), index = void 0, err ? (done = callback, 
callback = throwError, void done(err)) : ++completed === size ? (done = callback, 
callback = throwError, void (arguments.length <= 2 ? done(err, res) : done.apply(null, createArray(arguments)))) : (sync ? (args = arguments, 
func = tasks[completed] || throwError, nextTick(iterate)) : (sync = !0, waterfallIterator(tasks[completed] || throwError, arguments, createCallback(completed))), 
void (sync = !1));
};
}
}
function angelFall(tasks, callback) {
if (checkWaterfallTasks(tasks, callback = callback || noop)) {
var completed = 0, sync = !1, size = tasks.length, func = tasks[completed], args = [], iterate = function() {
switch (func.length) {
case 0:
try {
next(null, func());
} catch (e) {
next(e);
}
return;

case 1:
return func(next);

case 2:
return func(args[1], next);

case 3:
return func(args[1], args[2], next);

case 4:
return func(args[1], args[2], args[3], next);

case 5:
return func(args[1], args[2], args[3], args[4], next);

default:
return (args = slice(args, 1))[func.length - 1] = next, func.apply(null, args);
}
};
iterate();
}
function next(err, res) {
if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err);
if (++completed === size) {
iterate = throwError;
var done = callback;
return callback = throwError, void (2 === arguments.length ? done(err, res) : done.apply(null, createArray(arguments)));
}
func = tasks[completed], args = arguments, sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
}
}
function whilst(test, iterator, callback) {
callback = callback || noop;
var sync = !1;
function iterate() {
sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
}
function next() {
iterator(done);
}
function done(err, arg) {
if (err) return callback(err);
arguments.length <= 2 ? test(arg) ? iterate() : callback(null, arg) : (arg = slice(arguments, 1), 
test.apply(null, arg) ? iterate() : callback.apply(null, [ null ].concat(arg)));
}
test() ? iterate() : callback(null);
}
function doWhilst(iterator, test, callback) {
callback = callback || noop;
var sync = !1;
function iterate() {
sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
}
function next() {
iterator(done);
}
function done(err, arg) {
if (err) return callback(err);
arguments.length <= 2 ? test(arg) ? iterate() : callback(null, arg) : (arg = slice(arguments, 1), 
test.apply(null, arg) ? iterate() : callback.apply(null, [ null ].concat(arg)));
}
next();
}
function until(test, iterator, callback) {
callback = callback || noop;
var sync = !1;
function iterate() {
sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
}
function next() {
iterator(done);
}
function done(err, arg) {
if (err) return callback(err);
arguments.length <= 2 ? test(arg) ? callback(null, arg) : iterate() : (arg = slice(arguments, 1), 
test.apply(null, arg) ? callback.apply(null, [ null ].concat(arg)) : iterate());
}
test() ? callback(null) : iterate();
}
function doUntil(iterator, test, callback) {
callback = callback || noop;
var sync = !1;
function iterate() {
sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
}
function next() {
iterator(done);
}
function done(err, arg) {
if (err) return callback(err);
arguments.length <= 2 ? test(arg) ? callback(null, arg) : iterate() : (arg = slice(arguments, 1), 
test.apply(null, arg) ? callback.apply(null, [ null ].concat(arg)) : iterate());
}
next();
}
function during(test, iterator, callback) {
function _test() {
test(iterate);
}
function iterate(err, truth) {
if (err) return callback(err);
truth ? iterator(done) : callback(null);
}
function done(err) {
if (err) return callback(err);
_test();
}
callback = callback || noop, _test();
}
function doDuring(iterator, test, callback) {
function iterate(err, truth) {
if (err) return callback(err);
truth ? iterator(done) : callback(null);
}
function done(err, res) {
if (err) return callback(err);
switch (arguments.length) {
case 0:
case 1:
test(iterate);
break;

case 2:
test(res, iterate);
break;

default:
var args = slice(arguments, 1);
args.push(iterate), test.apply(null, args);
}
}
callback = callback || noop, iterate(null, !0);
}
function forever(iterator, callback) {
var sync = !1;
function iterate() {
iterator(next);
}
function next(err) {
if (err) {
if (callback) return callback(err);
throw err;
}
sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function compose() {
return seq.apply(null, reverse(arguments));
}
function seq() {
var fns = createArray(arguments);
return function() {
var self = this, args = createArray(arguments), callback = args[args.length - 1];
function iterator(newargs, fn, callback) {
var func = function(err) {
var nextargs = slice(arguments, 1);
callback(err, nextargs);
};
newargs.push(func), fn.apply(self, newargs);
}
function done(err, res) {
(res = isArray(res) ? res : [ res ]).unshift(err), callback.apply(self, res);
}
typeof callback === func ? args.pop() : callback = noop, reduce(fns, args, iterator, done);
};
}
function createApplyEach(func) {
return function(fns) {
var go = function() {
var self = this, args = createArray(arguments), callback = args.pop() || noop;
return func(fns, iterator, callback);
function iterator(fn, done) {
fn.apply(self, args.concat([ done ]));
}
};
if (arguments.length > 1) {
var args = slice(arguments, 1);
return go.apply(this, args);
}
return go;
};
}
function DLL() {
this.head = null, this.tail = null, this.length = 0;
}
function baseQueue(isQueue, worker, concurrency, payload) {
if (void 0 === concurrency) concurrency = 1; else if (isNaN(concurrency) || concurrency < 1) throw new Error("Concurrency must not be zero");
var _callback, _unshift, workers = 0, workersList = [], q = {
_tasks: new DLL,
concurrency,
payload,
saturated: noop,
unsaturated: noop,
buffer: concurrency / 4,
empty: noop,
drain: noop,
error: noop,
started: !1,
paused: !1,
push,
kill,
unshift,
remove,
process: isQueue ? runQueue : runCargo,
length: getLength,
running,
workersList: getWorkersList,
idle,
pause,
resume,
_worker: worker
};
return q;
function push(tasks, callback) {
_insert(tasks, callback);
}
function unshift(tasks, callback) {
_insert(tasks, callback, !0);
}
function _exec(task) {
var item = {
data: task,
callback: _callback
};
_unshift ? q._tasks.unshift(item) : q._tasks.push(item), nextTick(q.process);
}
function _insert(tasks, callback, unshift) {
if (null == callback) callback = noop; else if ("function" != typeof callback) throw new Error("task callback must be a function");
q.started = !0;
var _tasks = isArray(tasks) ? tasks : [ tasks ];
void 0 !== tasks && _tasks.length ? (_unshift = unshift, _callback = callback, arrayEachSync(_tasks, _exec), 
_callback = void 0) : q.idle() && nextTick(q.drain);
}
function kill() {
q.drain = noop, q._tasks.empty();
}
function _next(q, tasks) {
var called = !1;
return function(err, res) {
var task;
called && throwError(), called = !0, workers--;
for (var index = -1, size = workersList.length, taskIndex = -1, taskSize = tasks.length, useApply = arguments.length > 2, args = useApply && createArray(arguments); ++taskIndex < taskSize; ) {
for (task = tasks[taskIndex]; ++index < size; ) workersList[index] === task && (0 === index ? workersList.shift() : workersList.splice(index, 1), 
index = size, size--);
index = -1, useApply ? task.callback.apply(task, args) : task.callback(err, res), 
err && q.error(err, task.data);
}
workers <= q.concurrency - q.buffer && q.unsaturated(), q._tasks.length + workers === 0 && q.drain(), 
q.process();
};
}
function runQueue() {
for (;!q.paused && workers < q.concurrency && q._tasks.length; ) {
var task = q._tasks.shift();
workers++, workersList.push(task), 0 === q._tasks.length && q.empty(), workers === q.concurrency && q.saturated();
var done = _next(q, [ task ]);
worker(task.data, done);
}
}
function runCargo() {
for (;!q.paused && workers < q.concurrency && q._tasks.length; ) {
for (var tasks = q._tasks.splice(q.payload || q._tasks.length), index = -1, size = tasks.length, data = Array(size); ++index < size; ) data[index] = tasks[index].data;
workers++, nativePush.apply(workersList, tasks), 0 === q._tasks.length && q.empty(), 
workers === q.concurrency && q.saturated();
var done = _next(q, tasks);
worker(data, done);
}
}
function getLength() {
return q._tasks.length;
}
function running() {
return workers;
}
function getWorkersList() {
return workersList;
}
function idle() {
return q.length() + workers === 0;
}
function pause() {
q.paused = !0;
}
function _resume() {
nextTick(q.process);
}
function resume() {
!1 !== q.paused && (q.paused = !1, timesSync(q.concurrency < q._tasks.length ? q.concurrency : q._tasks.length, _resume));
}
function remove(test) {
q._tasks.remove(test);
}
}
function queue(worker, concurrency) {
return baseQueue(!0, worker, concurrency);
}
function priorityQueue(worker, concurrency) {
var q = baseQueue(!0, worker, concurrency);
return q.push = push, delete q.unshift, q;
function push(tasks, priority, callback) {
q.started = !0, priority = priority || 0;
var _tasks = isArray(tasks) ? tasks : [ tasks ], taskSize = _tasks.length;
if (void 0 !== tasks && 0 !== taskSize) {
callback = typeof callback === func ? callback : noop;
for (var nextNode = q._tasks.head; nextNode && priority >= nextNode.priority; ) nextNode = nextNode.next;
for (;taskSize--; ) {
var item = {
data: _tasks[taskSize],
priority,
callback
};
nextNode ? q._tasks.insertBefore(nextNode, item) : q._tasks.push(item), nextTick(q.process);
}
} else q.idle() && nextTick(q.drain);
}
}
function cargo(worker, payload) {
return baseQueue(!1, worker, 1, payload);
}
function auto(tasks, concurrency, callback) {
typeof concurrency === func && (callback = concurrency, concurrency = null);
var keys = nativeKeys(tasks), rest = keys.length, results = {};
if (0 === rest) return callback(null, results);
var runningTasks = 0, readyTasks = new DLL, listeners = Object.create(null);
function iterator(task, key) {
var _task, _taskSize;
if (!isArray(task)) return _task = task, _taskSize = 0, void readyTasks.push([ _task, _taskSize, done ]);
var dependencySize = task.length - 1;
if (_task = task[dependencySize], _taskSize = dependencySize, 0 !== dependencySize) for (var index = -1; ++index < dependencySize; ) {
var dependencyName = task[index];
if (notInclude(keys, dependencyName)) {
var msg = "async.auto task `" + key + "` has non-existent dependency `" + dependencyName + "` in " + task.join(", ");
throw new Error(msg);
}
var taskListeners = listeners[dependencyName];
taskListeners || (taskListeners = listeners[dependencyName] = []), taskListeners.push(taskListener);
} else readyTasks.push([ _task, _taskSize, done ]);
function done(err, arg) {
if (null === key && throwError(), arg = arguments.length <= 2 ? arg : slice(arguments, 1), 
err) {
rest = 0, runningTasks = 0, readyTasks.length = 0;
var safeResults = objectClone(results);
safeResults[key] = arg, key = null;
var _callback = callback;
return callback = noop, void _callback(err, safeResults);
}
runningTasks--, rest--, results[key] = arg, taskComplete(key), key = null;
}
function taskListener() {
0 == --dependencySize && readyTasks.push([ _task, _taskSize, done ]);
}
}
function proceedQueue() {
if (0 === readyTasks.length && 0 === runningTasks) {
if (0 !== rest) throw new Error("async.auto task has cyclic dependencies");
return callback(null, results);
}
for (;readyTasks.length && runningTasks < concurrency && callback !== noop; ) {
runningTasks++;
var array = readyTasks.shift();
0 === array[1] ? array[0](array[2]) : array[0](results, array[2]);
}
}
function taskComplete(key) {
arrayEachSync(listeners[key] || [], (function(task) {
task();
})), proceedQueue();
}
callback = onlyOnce(callback || noop), concurrency = concurrency || rest, baseEachSync(tasks, iterator, keys), 
proceedQueue();
}
exports.default = index, baseEachSync(index, (function(func, key) {
exports[key] = func;
}), nativeKeys(index)), DLL.prototype._removeLink = function(node) {
var prev = node.prev, next = node.next;
return prev ? prev.next = next : this.head = next, next ? next.prev = prev : this.tail = prev, 
node.prev = null, node.next = null, this.length--, node;
}, DLL.prototype.empty = DLL, DLL.prototype._setInitial = function(node) {
this.length = 1, this.head = this.tail = node;
}, DLL.prototype.insertBefore = function(node, newNode) {
newNode.prev = node.prev, newNode.next = node, node.prev ? node.prev.next = newNode : this.head = newNode, 
node.prev = newNode, this.length++;
}, DLL.prototype.unshift = function(node) {
this.head ? this.insertBefore(this.head, node) : this._setInitial(node);
}, DLL.prototype.push = function(node) {
var tail = this.tail;
tail ? (node.prev = tail, node.next = tail.next, this.tail = node, tail.next = node, 
this.length++) : this._setInitial(node);
}, DLL.prototype.shift = function() {
return this.head && this._removeLink(this.head);
}, DLL.prototype.splice = function(end) {
for (var task, tasks = []; end-- && (task = this.shift()); ) tasks.push(task);
return tasks;
}, DLL.prototype.remove = function(test) {
for (var node = this.head; node; ) test(node) && this._removeLink(node), node = node.next;
return this;
};
var FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /(=.+)?(\s*)$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
function parseParams(func) {
return func = (func = (func = (func = func.toString().replace(STRIP_COMMENTS, "")).match(FN_ARGS)[2].replace(" ", "")) ? func.split(FN_ARG_SPLIT) : []).map((function(arg) {
return arg.replace(FN_ARG, "").trim();
}));
}
function autoInject(tasks, concurrency, callback) {
var newTasks = {};
function iterator(task, key) {
var params, taskLength = task.length;
if (isArray(task)) {
if (0 === taskLength) throw new Error("autoInject task functions require explicit parameters.");
if (params = createArray(task), taskLength = params.length - 1, task = params[taskLength], 
0 === taskLength) return void (newTasks[key] = task);
} else {
if (1 === taskLength) return void (newTasks[key] = task);
if (params = parseParams(task), 0 === taskLength && 0 === params.length) throw new Error("autoInject task functions require explicit parameters.");
taskLength = params.length - 1;
}
function newTask(results, done) {
switch (taskLength) {
case 1:
task(results[params[0]], done);
break;

case 2:
task(results[params[0]], results[params[1]], done);
break;

case 3:
task(results[params[0]], results[params[1]], results[params[2]], done);
break;

default:
for (var i = -1; ++i < taskLength; ) params[i] = results[params[i]];
params[i] = done, task.apply(null, params);
}
}
params[taskLength] = newTask, newTasks[key] = params;
}
baseEachSync(tasks, iterator, nativeKeys(tasks)), auto(newTasks, concurrency, callback);
}
function retry(opts, task, callback) {
var times, intervalFunc, errorFilter, count = 0;
if (arguments.length < 3 && typeof opts === func) callback = task || noop, task = opts, 
opts = null, times = DEFAULT_TIMES; else switch (callback = callback || noop, typeof opts) {
case "object":
typeof opts.errorFilter === func && (errorFilter = opts.errorFilter);
var interval = opts.interval;
switch (typeof interval) {
case func:
intervalFunc = interval;
break;

case "string":
case "number":
intervalFunc = (interval = +interval) ? function() {
return interval;
} : function() {
return DEFAULT_INTERVAL;
};
}
times = +opts.times || DEFAULT_TIMES;
break;

case "number":
times = opts || DEFAULT_TIMES;
break;

case "string":
times = +opts || DEFAULT_TIMES;
break;

default:
throw new Error("Invalid arguments for async.retry");
}
if ("function" != typeof task) throw new Error("Invalid arguments for async.retry");
function simpleIterator() {
task(simpleCallback);
}
function simpleCallback(err, res) {
if (++count === times || !err || errorFilter && !errorFilter(err)) {
if (arguments.length <= 2) return callback(err, res);
var args = createArray(arguments);
return callback.apply(null, args);
}
simpleIterator();
}
function intervalIterator() {
task(intervalCallback);
}
function intervalCallback(err, res) {
if (++count === times || !err || errorFilter && !errorFilter(err)) {
if (arguments.length <= 2) return callback(err, res);
var args = createArray(arguments);
return callback.apply(null, args);
}
setTimeout(intervalIterator, intervalFunc(count));
}
task(intervalFunc ? intervalCallback : simpleCallback);
}
function retryable(opts, task) {
return task || (task = opts, opts = null), done;
function done() {
var taskFn, args = createArray(arguments), lastIndex = args.length - 1, callback = args[lastIndex];
switch (task.length) {
case 1:
taskFn = task1;
break;

case 2:
taskFn = task2;
break;

case 3:
taskFn = task3;
break;

default:
taskFn = task4;
}
function task1(done) {
task(done);
}
function task2(done) {
task(args[0], done);
}
function task3(done) {
task(args[0], args[1], done);
}
function task4(callback) {
args[lastIndex] = callback, task.apply(null, args);
}
opts ? retry(opts, taskFn, callback) : retry(taskFn, callback);
}
}
function iterator(tasks) {
var size = 0, keys = [];
return isArray(tasks) ? size = tasks.length : (keys = nativeKeys(tasks), size = keys.length), 
makeCallback(0);
function makeCallback(index) {
var fn = function() {
if (size) {
var key = keys[index] || index;
tasks[key].apply(null, createArray(arguments));
}
return fn.next();
};
return fn.next = function() {
return index < size - 1 ? makeCallback(index + 1) : null;
}, fn;
}
}
function apply(func) {
switch (arguments.length) {
case 0:
case 1:
return func;

case 2:
return func.bind(null, arguments[1]);

case 3:
return func.bind(null, arguments[1], arguments[2]);

case 4:
return func.bind(null, arguments[1], arguments[2], arguments[3]);

case 5:
return func.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);

default:
var size = arguments.length, index = 0, args = Array(size);
for (args[index] = null; ++index < size; ) args[index] = arguments[index];
return func.bind.apply(func, args);
}
}
function timeout(func, millisec, info) {
var callback, timer;
return wrappedFunc;
function wrappedFunc() {
timer = setTimeout(timeoutCallback, millisec);
var args = createArray(arguments), lastIndex = args.length - 1;
callback = args[lastIndex], args[lastIndex] = injectedCallback, simpleApply(func, args);
}
function timeoutCallback() {
var name = func.name || "anonymous", err = new Error('Callback function "' + name + '" timed out.');
err.code = "ETIMEDOUT", info && (err.info = info), timer = null, callback(err);
}
function injectedCallback() {
null !== timer && (simpleApply(callback, createArray(arguments)), clearTimeout(timer));
}
function simpleApply(func, args) {
switch (args.length) {
case 0:
func();
break;

case 1:
func(args[0]);
break;

case 2:
func(args[0], args[1]);
break;

default:
func.apply(null, args);
}
}
}
function times(n, iterator, callback) {
if (callback = callback || noop, n = +n, isNaN(n) || n < 1) return callback(null, []);
var result = Array(n);
function iterate(num) {
iterator(num, createCallback(num));
}
function createCallback(index) {
return function(err, res) {
null === index && throwError(), result[index] = res, index = null, err ? (callback(err), 
callback = noop) : 0 == --n && callback(null, result);
};
}
timesSync(n, iterate);
}
function timesSeries(n, iterator, callback) {
if (callback = callback || noop, n = +n, isNaN(n) || n < 1) return callback(null, []);
var result = Array(n), sync = !1, completed = 0;
function iterate() {
iterator(completed, done);
}
function done(err, res) {
result[completed] = res, err ? (callback(err), callback = throwError) : ++completed >= n ? (callback(null, result), 
callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
}
iterate();
}
function timesLimit(n, limit, iterator, callback) {
if (callback = callback || noop, n = +n, isNaN(n) || n < 1 || isNaN(limit) || limit < 1) return callback(null, []);
var result = Array(n), sync = !1, started = 0, completed = 0;
function iterate() {
var index = started++;
index < n && iterator(index, createCallback(index));
}
function createCallback(index) {
return function(err, res) {
null === index && throwError(), result[index] = res, index = null, err ? (callback(err), 
callback = noop) : ++completed >= n ? (callback(null, result), callback = throwError) : sync ? nextTick(iterate) : (sync = !0, 
iterate()), sync = !1;
};
}
timesSync(limit > n ? n : limit, iterate);
}
function race(tasks, callback) {
var size, keys;
callback = once(callback || noop);
var index = -1;
if (isArray(tasks)) for (size = tasks.length; ++index < size; ) tasks[index](callback); else {
if (!tasks || typeof tasks !== obj) return callback(new TypeError("First argument to race must be a collection of functions"));
for (size = (keys = nativeKeys(tasks)).length; ++index < size; ) tasks[keys[index]](callback);
}
size || callback(null);
}
function memoize(fn, hasher) {
hasher = hasher || function(hash) {
return hash;
};
var memo = {}, queues = {}, memoized = function() {
var args = createArray(arguments), callback = args.pop(), key = hasher.apply(null, args);
if (has(memo, key)) nextTick((function() {
callback.apply(null, memo[key]);
})); else {
if (has(queues, key)) return queues[key].push(callback);
queues[key] = [ callback ], args.push(done), fn.apply(null, args);
}
function done(err) {
var args = createArray(arguments);
err || (memo[key] = args);
var q = queues[key];
delete queues[key];
for (var i = -1, size = q.length; ++i < size; ) q[i].apply(null, args);
}
};
return memoized.memo = memo, memoized.unmemoized = fn, memoized;
}
function unmemoize(fn) {
return function() {
return (fn.unmemoized || fn).apply(null, arguments);
};
}
function ensureAsync(fn) {
return function() {
var args = createArray(arguments), lastIndex = args.length - 1, callback = args[lastIndex], sync = !0;
function done() {
var innerArgs = createArray(arguments);
sync ? nextTick((function() {
callback.apply(null, innerArgs);
})) : callback.apply(null, innerArgs);
}
args[lastIndex] = done, fn.apply(this, args), sync = !1;
};
}
function constant() {
var args = [ null ].concat(createArray(arguments));
return function(callback) {
(callback = arguments[arguments.length - 1]).apply(this, args);
};
}
function asyncify(fn) {
return function() {
var result, args = createArray(arguments), callback = args.pop();
try {
result = fn.apply(this, args);
} catch (e) {
return callback(e);
}
result && typeof result.then === func ? result.then((function(value) {
invokeCallback(callback, null, value);
}), (function(err) {
invokeCallback(callback, err && err.message ? err : new Error(err));
})) : callback(null, result);
};
}
function invokeCallback(callback, err, value) {
try {
callback(err, value);
} catch (e) {
nextTick(rethrow, e);
}
}
function rethrow(error) {
throw error;
}
function reflect(func) {
return function() {
var callback;
switch (arguments.length) {
case 1:
return callback = arguments[0], func(done);

case 2:
return callback = arguments[1], func(arguments[0], done);

default:
var args = createArray(arguments), lastIndex = args.length - 1;
callback = args[lastIndex], args[lastIndex] = done, func.apply(this, args);
}
function done(err, res) {
if (err) return callback(null, {
error: err
});
arguments.length > 2 && (res = slice(arguments, 1)), callback(null, {
value: res
});
}
};
}
function reflectAll(tasks) {
var newTasks, keys;
return isArray(tasks) ? (newTasks = Array(tasks.length), arrayEachSync(tasks, iterate)) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), 
newTasks = {}, baseEachSync(tasks, iterate, keys)), newTasks;
function iterate(func, key) {
newTasks[key] = reflect(func);
}
}
function createLogger(name) {
return function(fn) {
var args = slice(arguments, 1);
args.push(done), fn.apply(null, args);
};
function done(err) {
if (typeof console === obj) {
if (err) return void (console.error && console.error(err));
if (console[name]) arrayEachSync(slice(arguments, 1), (function(arg) {
console[name](arg);
}));
}
}
}
function safe() {
return createImmediate(), exports;
}
function fast() {
return createImmediate(!1), exports;
}
}(exports);
}();
},
40537: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
exports.Z = void 0;
const {stringHints, numberHints} = __webpack_require__(12377), SPECIFICITY = {
type: 1,
not: 1,
oneOf: 1,
anyOf: 1,
if: 1,
enum: 1,
const: 1,
instanceof: 1,
required: 2,
pattern: 2,
patternRequired: 2,
format: 2,
formatMinimum: 2,
formatMaximum: 2,
minimum: 2,
exclusiveMinimum: 2,
maximum: 2,
exclusiveMaximum: 2,
multipleOf: 2,
uniqueItems: 2,
contains: 2,
minLength: 2,
maxLength: 2,
minItems: 2,
maxItems: 2,
minProperties: 2,
maxProperties: 2,
dependencies: 2,
propertyNames: 2,
additionalItems: 2,
additionalProperties: 2,
absolutePath: 2
};
function filterMax(array, fn) {
const evaluatedMax = array.reduce(((max, item) => Math.max(max, fn(item))), 0);
return array.filter((item => fn(item) === evaluatedMax));
}
function findAllChildren(children, schemaPaths) {
let i = children.length - 1;
const predicate = schemaPath => 0 !== children[i].schemaPath.indexOf(schemaPath);
for (;i > -1 && !schemaPaths.every(predicate); ) if ("anyOf" === children[i].keyword || "oneOf" === children[i].keyword) {
const refs = extractRefs(children[i]), childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));
i = childrenStart - 1;
} else i -= 1;
return i + 1;
}
function extractRefs(error) {
const {schema} = error;
return Array.isArray(schema) ? schema.map((({$ref}) => $ref)).filter((s => s)) : [];
}
function indent(str, prefix) {
return str.replace(/\n(?!$)/g, `\n${prefix}`);
}
function hasNotInSchema(schema) {
return !!schema.not;
}
function findFirstTypedSchema(schema) {
return hasNotInSchema(schema) ? findFirstTypedSchema(schema.not) : schema;
}
function canApplyNot(schema) {
const typedSchema = findFirstTypedSchema(schema);
return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);
}
function isObject(maybeObj) {
return "object" == typeof maybeObj && null !== maybeObj;
}
function likeNumber(schema) {
return "number" === schema.type || void 0 !== schema.minimum || void 0 !== schema.exclusiveMinimum || void 0 !== schema.maximum || void 0 !== schema.exclusiveMaximum || void 0 !== schema.multipleOf;
}
function likeInteger(schema) {
return "integer" === schema.type || void 0 !== schema.minimum || void 0 !== schema.exclusiveMinimum || void 0 !== schema.maximum || void 0 !== schema.exclusiveMaximum || void 0 !== schema.multipleOf;
}
function likeString(schema) {
return "string" === schema.type || void 0 !== schema.minLength || void 0 !== schema.maxLength || void 0 !== schema.pattern || void 0 !== schema.format || void 0 !== schema.formatMinimum || void 0 !== schema.formatMaximum;
}
function likeBoolean(schema) {
return "boolean" === schema.type;
}
function likeArray(schema) {
return "array" === schema.type || "number" == typeof schema.minItems || "number" == typeof schema.maxItems || void 0 !== schema.uniqueItems || void 0 !== schema.items || void 0 !== schema.additionalItems || void 0 !== schema.contains;
}
function likeObject(schema) {
return "object" === schema.type || void 0 !== schema.minProperties || void 0 !== schema.maxProperties || void 0 !== schema.required || void 0 !== schema.properties || void 0 !== schema.patternProperties || void 0 !== schema.additionalProperties || void 0 !== schema.dependencies || void 0 !== schema.propertyNames || void 0 !== schema.patternRequired;
}
function likeNull(schema) {
return "null" === schema.type;
}
function getSchemaNonTypes(schema) {
if (!schema) return "";
if (!schema.type) {
if (likeNumber(schema) || likeInteger(schema)) return " | should be any non-number";
if (likeString(schema)) return " | should be any non-string";
if (likeArray(schema)) return " | should be any non-array";
if (likeObject(schema)) return " | should be any non-object";
}
return "";
}
function formatHints(hints) {
return hints.length > 0 ? `(${hints.join(", ")})` : "";
}
function getHints(schema, logic) {
return likeNumber(schema) || likeInteger(schema) ? numberHints(schema, logic) : likeString(schema) ? stringHints(schema, logic) : [];
}
class ValidationError extends Error {
constructor(errors, schema, configuration = {}) {
let headerNameFromSchema, baseDataPathFromSchema;
if (super(), this.name = "ValidationError", this.errors = errors, this.schema = schema, 
schema.title && (!configuration.name || !configuration.baseDataPath)) {
const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);
splittedTitleFromSchema && (configuration.name || ([, headerNameFromSchema] = splittedTitleFromSchema), 
configuration.baseDataPath || ([, , baseDataPathFromSchema] = splittedTitleFromSchema));
}
this.headerName = configuration.name || headerNameFromSchema || "Object", this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || "configuration", 
this.postFormatter = configuration.postFormatter || null;
const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${type = this.baseDataPath, 
/^[aeiou]/i.test(type) ? "an" : "a"} ${this.baseDataPath} object that does not match the API schema.\n`;
var type;
this.message = `${header}${this.formatValidationErrors(errors)}`, Error.captureStackTrace(this, this.constructor);
}
getSchemaPart(path) {
const newPath = path.split("/");
let schemaPart = this.schema;
for (let i = 1; i < newPath.length; i++) {
const inner = schemaPart[newPath[i]];
if (!inner) break;
schemaPart = inner;
}
return schemaPart;
}
formatSchema(schema, logic = !0, prevSchemas = []) {
let newLogic = logic;
const formatInnerSchema = (innerSchema, addSelf) => addSelf ? prevSchemas.includes(innerSchema) ? "(recursive)" : this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema)) : this.formatSchema(innerSchema, newLogic, prevSchemas);
if (hasNotInSchema(schema) && !likeObject(schema)) {
if (canApplyNot(schema.not)) return newLogic = !logic, formatInnerSchema(schema.not);
const needApplyLogicHere = !schema.not.not, prefix = logic ? "" : "non ";
return newLogic = !logic, needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);
}
if (schema.instanceof) {
const {instanceof: value} = schema;
return (Array.isArray(value) ? value : [ value ]).map((item => "Function" === item ? "function" : item)).join(" | ");
}
if (schema.enum) return schema.enum.map((item => JSON.stringify(item))).join(" | ");
if (void 0 !== schema.const) return JSON.stringify(schema.const);
if (schema.oneOf) return schema.oneOf.map((item => formatInnerSchema(item, !0))).join(" | ");
if (schema.anyOf) return schema.anyOf.map((item => formatInnerSchema(item, !0))).join(" | ");
if (schema.allOf) return schema.allOf.map((item => formatInnerSchema(item, !0))).join(" & ");
if (schema.if) {
const {if: ifValue, then: thenValue, else: elseValue} = schema;
return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : ""}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : ""}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : ""}`;
}
if (schema.$ref) return formatInnerSchema(this.getSchemaPart(schema.$ref), !0);
if (likeNumber(schema) || likeInteger(schema)) {
const [type, ...hints] = getHints(schema, logic), str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ""}`;
return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;
}
if (likeString(schema)) {
const [type, ...hints] = getHints(schema, logic), str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ""}`;
return logic ? str : "string" === str ? "non-string" : `non-string | ${str}`;
}
if (likeBoolean(schema)) return (logic ? "" : "non-") + "boolean";
if (likeArray(schema)) {
newLogic = !0;
const hints = [];
"number" == typeof schema.minItems && hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? "s" : ""}`), 
"number" == typeof schema.maxItems && hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? "s" : ""}`), 
schema.uniqueItems && hints.push("should not have duplicate items");
const hasAdditionalItems = void 0 === schema.additionalItems || Boolean(schema.additionalItems);
let items = "";
return schema.items ? Array.isArray(schema.items) && schema.items.length > 0 ? (items = `${schema.items.map((item => formatInnerSchema(item))).join(", ")}`, 
hasAdditionalItems && schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0 && hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`)) : items = schema.items && Object.keys(schema.items).length > 0 ? `${formatInnerSchema(schema.items)}` : "any" : items = "any", 
schema.contains && Object.keys(schema.contains).length > 0 && hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`), 
`[${items}${hasAdditionalItems ? ", ..." : ""}]${hints.length > 0 ? ` (${hints.join(", ")})` : ""}`;
}
if (likeObject(schema)) {
newLogic = !0;
const hints = [];
if ("number" == typeof schema.minProperties && hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? "properties" : "property"}`), 
"number" == typeof schema.maxProperties && hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? "properties" : "property"}`), 
schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {
const patternProperties = Object.keys(schema.patternProperties);
hints.push(`additional property names should match pattern${patternProperties.length > 1 ? "s" : ""} ${patternProperties.map((pattern => JSON.stringify(pattern))).join(" | ")}`);
}
const properties = schema.properties ? Object.keys(schema.properties) : [], required = schema.required ? schema.required : [], objectStructure = [ ...new Set([].concat(required).concat(properties)) ].map((property => `${property}${required.includes(property) ? "" : "?"}`)).concat(void 0 === schema.additionalProperties || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [ `<key>: ${formatInnerSchema(schema.additionalProperties)}` ] : [ "…" ] : []).join(", "), {dependencies, propertyNames, patternRequired} = schema;
return dependencies && Object.keys(dependencies).forEach((dependencyName => {
const dependency = dependencies[dependencyName];
Array.isArray(dependency) ? hints.push(`should have ${dependency.length > 1 ? "properties" : "property"} ${dependency.map((dep => `'${dep}'`)).join(", ")} when property '${dependencyName}' is present`) : hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);
})), propertyNames && Object.keys(propertyNames).length > 0 && hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`), 
patternRequired && patternRequired.length > 0 && hints.push(`should have property matching pattern ${patternRequired.map((item => JSON.stringify(item)))}`), 
`object {${objectStructure ? ` ${objectStructure} ` : ""}}${hints.length > 0 ? ` (${hints.join(", ")})` : ""}`;
}
return likeNull(schema) ? (logic ? "" : "non-") + "null" : Array.isArray(schema.type) ? `${schema.type.join(" | ")}` : JSON.stringify(schema, null, 2);
}
getSchemaPartText(schemaPart, additionalPath, needDot = !1, logic = !0) {
if (!schemaPart) return "";
if (Array.isArray(additionalPath)) for (let i = 0; i < additionalPath.length; i++) {
const inner = schemaPart[additionalPath[i]];
if (!inner) break;
schemaPart = inner;
}
for (;schemaPart.$ref; ) schemaPart = this.getSchemaPart(schemaPart.$ref);
let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? "." : ""}`;
return schemaPart.description && (schemaText += `\n-> ${schemaPart.description}`), 
schemaPart.link && (schemaText += `\n-> Read more at ${schemaPart.link}`), schemaText;
}
getSchemaPartDescription(schemaPart) {
if (!schemaPart) return "";
for (;schemaPart.$ref; ) schemaPart = this.getSchemaPart(schemaPart.$ref);
let schemaText = "";
return schemaPart.description && (schemaText += `\n-> ${schemaPart.description}`), 
schemaPart.link && (schemaText += `\n-> Read more at ${schemaPart.link}`), schemaText;
}
formatValidationError(error) {
const {keyword, dataPath: errorDataPath} = error, dataPath = `${this.baseDataPath}${errorDataPath}`;
switch (keyword) {
case "type":
{
const {parentSchema, params} = error;
switch (params.type) {
case "number":
case "string":
case "boolean":
case "null":
return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, !1, !0)}`;

case "integer":
return `${dataPath} should be an ${this.getSchemaPartText(parentSchema, !1, !0)}`;

case "array":
return `${dataPath} should be an array:\n${this.getSchemaPartText(parentSchema)}`;

case "object":
return `${dataPath} should be an object:\n${this.getSchemaPartText(parentSchema)}`;

default:
return `${dataPath} should be:\n${this.getSchemaPartText(parentSchema)}`;
}
}

case "instanceof":
{
const {parentSchema} = error;
return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, !1, !0)}`;
}

case "pattern":
{
const {params, parentSchema} = error, {pattern} = params;
return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "format":
{
const {params, parentSchema} = error, {format} = params;
return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "formatMinimum":
case "formatMaximum":
{
const {params, parentSchema} = error, {comparison, limit} = params;
return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "minimum":
case "maximum":
case "exclusiveMinimum":
case "exclusiveMaximum":
{
const {parentSchema, params} = error, {comparison, limit} = params, [, ...hints] = getHints(parentSchema, !0);
return 0 === hints.length && hints.push(`should be ${comparison} ${limit}`), `${dataPath} ${hints.join(" ")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "multipleOf":
{
const {params, parentSchema} = error, {multipleOf} = params;
return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "patternRequired":
{
const {params, parentSchema} = error, {missingPattern} = params;
return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "minLength":
{
const {params, parentSchema} = error, {limit} = params;
if (1 === limit) return `${dataPath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
const length = limit - 1;
return `${dataPath} should be longer than ${length} character${length > 1 ? "s" : ""}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "minItems":
{
const {params, parentSchema} = error, {limit} = params;
return 1 === limit ? `${dataPath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}` : `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "minProperties":
{
const {params, parentSchema} = error, {limit} = params;
return 1 === limit ? `${dataPath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}` : `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "maxLength":
{
const {params, parentSchema} = error, {limit} = params, max = limit + 1;
return `${dataPath} should be shorter than ${max} character${max > 1 ? "s" : ""}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "maxItems":
{
const {params, parentSchema} = error, {limit} = params;
return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "maxProperties":
{
const {params, parentSchema} = error, {limit} = params;
return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "uniqueItems":
{
const {params, parentSchema} = error, {i} = params;
return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "additionalItems":
{
const {params, parentSchema} = error, {limit} = params;
return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\n${this.getSchemaPartText(parentSchema)}`;
}

case "contains":
{
const {parentSchema} = error;
return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, [ "contains" ])} item${getSchemaNonTypes(parentSchema)}.`;
}

case "required":
{
const {parentSchema, params} = error, missingProperty = params.missingProperty.replace(/^\./, ""), hasProperty = parentSchema && Boolean(parentSchema.properties && parentSchema.properties[missingProperty]);
return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\n${this.getSchemaPartText(parentSchema, [ "properties", missingProperty ])}` : this.getSchemaPartDescription(parentSchema)}`;
}

case "additionalProperties":
{
const {params, parentSchema} = error, {additionalProperty} = params;
return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\n${this.getSchemaPartText(parentSchema)}`;
}

case "dependencies":
{
const {params, parentSchema} = error, {property, deps} = params;
return `${dataPath} should have properties ${deps.split(",").map((dep => `'${dep.trim()}'`)).join(", ")} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "propertyNames":
{
const {params, parentSchema, schema} = error, {propertyName} = params;
return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;
}

case "enum":
{
const {parentSchema} = error;
return parentSchema && parentSchema.enum && 1 === parentSchema.enum.length ? `${dataPath} should be ${this.getSchemaPartText(parentSchema, !1, !0)}` : `${dataPath} should be one of these:\n${this.getSchemaPartText(parentSchema)}`;
}

case "const":
{
const {parentSchema} = error;
return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, !1, !0)}`;
}

case "not":
{
const postfix = likeObject(error.parentSchema) ? `\n${this.getSchemaPartText(error.parentSchema)}` : "", schemaOutput = this.getSchemaPartText(error.schema, !1, !1, !1);
if (canApplyNot(error.schema)) return `${dataPath} should be any ${schemaOutput}${postfix}.`;
const {schema, parentSchema} = error;
return `${dataPath} should not be ${this.getSchemaPartText(schema, !1, !0)}${parentSchema && likeObject(parentSchema) ? `\n${this.getSchemaPartText(parentSchema)}` : ""}`;
}

case "oneOf":
case "anyOf":
{
const {parentSchema, children} = error;
if (children && children.length > 0) {
if (1 === error.schema.length) {
const lastChild = children[children.length - 1], remainingChildren = children.slice(0, children.length - 1);
return this.formatValidationError(Object.assign({}, lastChild, {
children: remainingChildren,
parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)
}));
}
let filteredChildren = function(children) {
let newChildren = children;
return newChildren = filterMax(newChildren, (error => error.dataPath ? error.dataPath.length : 0)), 
newChildren = filterMax(newChildren, (error => SPECIFICITY[error.keyword] || 2)), 
newChildren;
}(children);
return 1 === filteredChildren.length ? this.formatValidationError(filteredChildren[0]) : (filteredChildren = function(children) {
const result = [];
let i = children.length - 1;
for (;i > 0; ) {
const child = children[i];
if ("anyOf" === child.keyword || "oneOf" === child.keyword) {
const refs = extractRefs(child), childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));
childrenStart !== i ? (result.push(Object.assign({}, child, {
children: children.slice(childrenStart, i)
})), i = childrenStart) : result.push(child);
} else result.push(child);
i -= 1;
}
return 0 === i && result.push(children[i]), result.reverse();
}(filteredChildren), `${dataPath} should be one of these:\n${this.getSchemaPartText(parentSchema)}\nDetails:\n${filteredChildren.map((nestedError => ` * ${indent(this.formatValidationError(nestedError), "   ")}`)).join("\n")}`);
}
return `${dataPath} should be one of these:\n${this.getSchemaPartText(parentSchema)}`;
}

case "if":
{
const {params, parentSchema} = error, {failingKeyword} = params;
return `${dataPath} should match "${failingKeyword}" schema:\n${this.getSchemaPartText(parentSchema, [ failingKeyword ])}`;
}

case "absolutePath":
{
const {message, parentSchema} = error;
return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;
}

default:
{
const {message, parentSchema} = error;
return `${dataPath} ${message} (${JSON.stringify(error, null, 2)}).\n${this.getSchemaPartText(parentSchema, !1)}`;
}
}
}
formatValidationErrors(errors) {
return errors.map((error => {
let formattedError = this.formatValidationError(error);
return this.postFormatter && (formattedError = this.postFormatter(formattedError, error)), 
` - ${indent(formattedError, "   ")}`;
})).join("\n");
}
}
var _default = ValidationError;
exports.Z = _default;
},
97496: module => {
"use strict";
class Range {
static getOperator(side, exclusive) {
return "left" === side ? exclusive ? ">" : ">=" : exclusive ? "<" : "<=";
}
static formatRight(value, logic, exclusive) {
return !1 === logic ? Range.formatLeft(value, !logic, !exclusive) : `should be ${Range.getOperator("right", exclusive)} ${value}`;
}
static formatLeft(value, logic, exclusive) {
return !1 === logic ? Range.formatRight(value, !logic, !exclusive) : `should be ${Range.getOperator("left", exclusive)} ${value}`;
}
static formatRange(start, end, startExclusive, endExclusive, logic) {
let result = "should be";
return result += ` ${Range.getOperator(logic ? "left" : "right", logic ? startExclusive : !startExclusive)} ${start} `, 
result += logic ? "and" : "or", result += ` ${Range.getOperator(logic ? "right" : "left", logic ? endExclusive : !endExclusive)} ${end}`, 
result;
}
static getRangeValue(values, logic) {
let minMax = logic ? 1 / 0 : -1 / 0, j = -1;
const predicate = logic ? ([value]) => value <= minMax : ([value]) => value >= minMax;
for (let i = 0; i < values.length; i++) predicate(values[i]) && ([minMax] = values[i], 
j = i);
return j > -1 ? values[j] : [ 1 / 0, !0 ];
}
constructor() {
this._left = [], this._right = [];
}
left(value, exclusive = !1) {
this._left.push([ value, exclusive ]);
}
right(value, exclusive = !1) {
this._right.push([ value, exclusive ]);
}
format(logic = !0) {
const [start, leftExclusive] = Range.getRangeValue(this._left, logic), [end, rightExclusive] = Range.getRangeValue(this._right, !logic);
if (!Number.isFinite(start) && !Number.isFinite(end)) return "";
const realStart = leftExclusive ? start + 1 : start;
return realStart === (rightExclusive ? end - 1 : end) ? `should be ${logic ? "" : "!"}= ${realStart}` : Number.isFinite(start) && !Number.isFinite(end) ? Range.formatLeft(start, logic, leftExclusive) : !Number.isFinite(start) && Number.isFinite(end) ? Range.formatRight(end, logic, rightExclusive) : Range.formatRange(start, end, leftExclusive, rightExclusive, logic);
}
}
module.exports = Range;
},
12377: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Range = __webpack_require__(97496);
module.exports.stringHints = function(schema, logic) {
const hints = [];
let type = "string";
const currentSchema = {
...schema
};
if (!logic) {
const tmpLength = currentSchema.minLength, tmpFormat = currentSchema.formatMinimum, tmpExclusive = currentSchema.formatExclusiveMaximum;
currentSchema.minLength = currentSchema.maxLength, currentSchema.maxLength = tmpLength, 
currentSchema.formatMinimum = currentSchema.formatMaximum, currentSchema.formatMaximum = tmpFormat, 
currentSchema.formatExclusiveMaximum = !currentSchema.formatExclusiveMinimum, currentSchema.formatExclusiveMinimum = !tmpExclusive;
}
if ("number" == typeof currentSchema.minLength) if (1 === currentSchema.minLength) type = "non-empty string"; else {
const length = Math.max(currentSchema.minLength - 1, 0);
hints.push(`should be longer than ${length} character${length > 1 ? "s" : ""}`);
}
if ("number" == typeof currentSchema.maxLength) if (0 === currentSchema.maxLength) type = "empty string"; else {
const length = currentSchema.maxLength + 1;
hints.push(`should be shorter than ${length} character${length > 1 ? "s" : ""}`);
}
return currentSchema.pattern && hints.push(`should${logic ? "" : " not"} match pattern ${JSON.stringify(currentSchema.pattern)}`), 
currentSchema.format && hints.push(`should${logic ? "" : " not"} match format ${JSON.stringify(currentSchema.format)}`), 
currentSchema.formatMinimum && hints.push(`should be ${currentSchema.formatExclusiveMinimum ? ">" : ">="} ${JSON.stringify(currentSchema.formatMinimum)}`), 
currentSchema.formatMaximum && hints.push(`should be ${currentSchema.formatExclusiveMaximum ? "<" : "<="} ${JSON.stringify(currentSchema.formatMaximum)}`), 
[ type ].concat(hints);
}, module.exports.numberHints = function(schema, logic) {
const hints = [ "integer" === schema.type ? "integer" : "number" ], range = new Range;
"number" == typeof schema.minimum && range.left(schema.minimum), "number" == typeof schema.exclusiveMinimum && range.left(schema.exclusiveMinimum, !0), 
"number" == typeof schema.maximum && range.right(schema.maximum), "number" == typeof schema.exclusiveMaximum && range.right(schema.exclusiveMaximum, !0);
const rangeFormat = range.format(logic);
return rangeFormat && hints.push(rangeFormat), "number" == typeof schema.multipleOf && hints.push(`should${logic ? "" : " not"} be multiple of ${schema.multipleOf}`), 
hints;
};
},
91459: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), memoize = __webpack_require__(98216), mergeExports = (obj, exports) => {
const descriptors = Object.getOwnPropertyDescriptors(exports);
for (const name of Object.keys(descriptors)) {
const descriptor = descriptors[name];
if (descriptor.get) {
const fn = descriptor.get;
Object.defineProperty(obj, name, {
configurable: !1,
enumerable: !0,
get: memoize(fn)
});
} else {
if ("object" != typeof descriptor.value) throw new Error("Exposed values must be either a getter or an nested object");
Object.defineProperty(obj, name, {
configurable: !1,
enumerable: !0,
writable: !1,
value: mergeExports({}, descriptor.value)
});
}
}
return Object.freeze(obj);
}, fn = (factory => {
const fac = memoize(factory);
return (...args) => fac()(...args);
})((() => __webpack_require__(27142)));
module.exports = mergeExports(fn, {
get webpack() {
return __webpack_require__(27142);
},
get validate() {
const webpackOptionsSchemaCheck = __webpack_require__(51825), getRealValidate = memoize((() => {
const validateSchema = __webpack_require__(69353), webpackOptionsSchema = __webpack_require__(46312);
return options => validateSchema(webpackOptionsSchema, options);
}));
return options => {
webpackOptionsSchemaCheck(options) || getRealValidate()(options);
};
},
get validateSchema() {
return __webpack_require__(69353);
},
get version() {
return __webpack_require__(37589).i8;
},
get cli() {
return __webpack_require__(59705);
},
get AutomaticPrefetchPlugin() {
return __webpack_require__(18572);
},
get AsyncDependenciesBlock() {
return __webpack_require__(89353);
},
get BannerPlugin() {
return __webpack_require__(50073);
},
get Cache() {
return __webpack_require__(54499);
},
get Chunk() {
return __webpack_require__(76034);
},
get ChunkGraph() {
return __webpack_require__(15888);
},
get CleanPlugin() {
return __webpack_require__(32003);
},
get Compilation() {
return __webpack_require__(62843);
},
get Compiler() {
return __webpack_require__(88799);
},
get ConcatenationScope() {
return __webpack_require__(87291);
},
get ContextExclusionPlugin() {
return __webpack_require__(62793);
},
get ContextReplacementPlugin() {
return __webpack_require__(20646);
},
get DefinePlugin() {
return __webpack_require__(98665);
},
get DelegatedPlugin() {
return __webpack_require__(44337);
},
get Dependency() {
return __webpack_require__(14926);
},
get DllPlugin() {
return __webpack_require__(19443);
},
get DllReferencePlugin() {
return __webpack_require__(2835);
},
get DynamicEntryPlugin() {
return __webpack_require__(39088);
},
get EntryOptionPlugin() {
return __webpack_require__(51199);
},
get EntryPlugin() {
return __webpack_require__(27683);
},
get EnvironmentPlugin() {
return __webpack_require__(66987);
},
get EvalDevToolModulePlugin() {
return __webpack_require__(47499);
},
get EvalSourceMapDevToolPlugin() {
return __webpack_require__(49695);
},
get ExternalModule() {
return __webpack_require__(97056);
},
get ExternalsPlugin() {
return __webpack_require__(29301);
},
get Generator() {
return __webpack_require__(70607);
},
get HotUpdateChunk() {
return __webpack_require__(6902);
},
get HotModuleReplacementPlugin() {
return __webpack_require__(17049);
},
get IgnorePlugin() {
return __webpack_require__(6506);
},
get JavascriptModulesPlugin() {
return util.deprecate((() => __webpack_require__(18362)), "webpack.JavascriptModulesPlugin has moved to webpack.javascript.JavascriptModulesPlugin", "DEP_WEBPACK_JAVASCRIPT_MODULES_PLUGIN")();
},
get LibManifestPlugin() {
return __webpack_require__(13745);
},
get LibraryTemplatePlugin() {
return util.deprecate((() => __webpack_require__(80934)), "webpack.LibraryTemplatePlugin is deprecated and has been replaced by compilation.outputOptions.library or compilation.addEntry + passing a library option", "DEP_WEBPACK_LIBRARY_TEMPLATE_PLUGIN")();
},
get LoaderOptionsPlugin() {
return __webpack_require__(74245);
},
get LoaderTargetPlugin() {
return __webpack_require__(63626);
},
get Module() {
return __webpack_require__(36797);
},
get ModuleFilenameHelpers() {
return __webpack_require__(23833);
},
get ModuleGraph() {
return __webpack_require__(2197);
},
get ModuleGraphConnection() {
return __webpack_require__(63867);
},
get NoEmitOnErrorsPlugin() {
return __webpack_require__(18810);
},
get NormalModule() {
return __webpack_require__(3213);
},
get NormalModuleReplacementPlugin() {
return __webpack_require__(36524);
},
get MultiCompiler() {
return __webpack_require__(95400);
},
get Parser() {
return __webpack_require__(21475);
},
get PrefetchPlugin() {
return __webpack_require__(39649);
},
get ProgressPlugin() {
return __webpack_require__(17331);
},
get ProvidePlugin() {
return __webpack_require__(8822);
},
get RuntimeGlobals() {
return __webpack_require__(50980);
},
get RuntimeModule() {
return __webpack_require__(30823);
},
get SingleEntryPlugin() {
return util.deprecate((() => __webpack_require__(27683)), "SingleEntryPlugin was renamed to EntryPlugin", "DEP_WEBPACK_SINGLE_ENTRY_PLUGIN")();
},
get SourceMapDevToolPlugin() {
return __webpack_require__(26131);
},
get Stats() {
return __webpack_require__(16523);
},
get Template() {
return __webpack_require__(88370);
},
get UsageState() {
return __webpack_require__(74603).UsageState;
},
get TerserPlugin() {
return __webpack_require__(2357);
},
get CopyPlugin() {
return __webpack_require__(27720);
},
get ReplaceCodePlugin() {
return __webpack_require__(35551);
},
get WatchIgnorePlugin() {
return __webpack_require__(91158);
},
get WebpackError() {
return __webpack_require__(64326);
},
get WebpackOptionsApply() {
return __webpack_require__(94890);
},
get WebpackOptionsDefaulter() {
return util.deprecate((() => __webpack_require__(93614)), "webpack.WebpackOptionsDefaulter is deprecated and has been replaced by webpack.config.getNormalizedWebpackOptions and webpack.config.applyWebpackOptionsDefaults", "DEP_WEBPACK_OPTIONS_DEFAULTER")();
},
get WebpackOptionsValidationError() {
return __webpack_require__(33842).ValidationError;
},
get ValidationError() {
return __webpack_require__(33842).ValidationError;
},
cache: {
get MemoryCachePlugin() {
return __webpack_require__(62472);
}
},
config: {
get getNormalizedWebpackOptions() {
return __webpack_require__(70884).getNormalizedWebpackOptions;
},
get applyWebpackOptionsDefaults() {
return __webpack_require__(73054).applyWebpackOptionsDefaults;
}
},
dependencies: {
get ModuleDependency() {
return __webpack_require__(15216);
},
get HarmonyImportDependency() {
return __webpack_require__(75015);
},
get ConstDependency() {
return __webpack_require__(30339);
},
get NullDependency() {
return __webpack_require__(52649);
}
},
ids: {
get ChunkModuleIdRangePlugin() {
return __webpack_require__(83690);
},
get NaturalModuleIdsPlugin() {
return __webpack_require__(59940);
},
get OccurrenceModuleIdsPlugin() {
return __webpack_require__(36669);
},
get NamedModuleIdsPlugin() {
return __webpack_require__(13924);
},
get DeterministicChunkIdsPlugin() {
return __webpack_require__(34512);
},
get DeterministicModuleIdsPlugin() {
return __webpack_require__(84967);
},
get NamedChunkIdsPlugin() {
return __webpack_require__(55127);
},
get OccurrenceChunkIdsPlugin() {
return __webpack_require__(4705);
},
get HashedModuleIdsPlugin() {
return __webpack_require__(5429);
}
},
javascript: {
get EnableChunkLoadingPlugin() {
return __webpack_require__(64027);
},
get JavascriptModulesPlugin() {
return __webpack_require__(18362);
},
get JavascriptParser() {
return __webpack_require__(36793);
}
},
optimize: {
get AggressiveMergingPlugin() {
return __webpack_require__(66922);
},
get AggressiveSplittingPlugin() {
return util.deprecate((() => __webpack_require__(10085)), "AggressiveSplittingPlugin is deprecated in favor of SplitChunksPlugin", "DEP_WEBPACK_AGGRESSIVE_SPLITTING_PLUGIN")();
},
get InnerGraph() {
return __webpack_require__(93639);
},
get LimitChunkCountPlugin() {
return __webpack_require__(48646);
},
get MinChunkSizePlugin() {
return __webpack_require__(32020);
},
get ModuleConcatenationPlugin() {
return __webpack_require__(13682);
},
get RealContentHashPlugin() {
return __webpack_require__(83582);
},
get RuntimeChunkPlugin() {
return __webpack_require__(1058);
},
get SideEffectsFlagPlugin() {
return __webpack_require__(72708);
},
get SplitChunksPlugin() {
return __webpack_require__(222);
}
},
runtime: {
get GetChunkFilenameRuntimeModule() {
return __webpack_require__(34429);
},
get LoadScriptRuntimeModule() {
return __webpack_require__(84914);
}
},
prefetch: {
get ChunkPrefetchPreloadPlugin() {
return __webpack_require__(42770);
}
},
web: {
get FetchCompileAsyncWasmPlugin() {
return __webpack_require__(75679);
},
get FetchCompileWasmPlugin() {
return __webpack_require__(17903);
},
get JsonpChunkLoadingRuntimeModule() {
return __webpack_require__(68431);
},
get JsonpTemplatePlugin() {
return __webpack_require__(2025);
}
},
webworker: {
get WebWorkerTemplatePlugin() {
return __webpack_require__(87263);
}
},
node: {
get NodeEnvironmentPlugin() {
return __webpack_require__(25418);
},
get NodeSourcePlugin() {
return __webpack_require__(425);
},
get NodeTargetPlugin() {
return __webpack_require__(81350);
},
get NodeTemplatePlugin() {
return __webpack_require__(62016);
},
get ReadFileCompileWasmPlugin() {
return __webpack_require__(83410);
}
},
electron: {
get ElectronTargetPlugin() {
return __webpack_require__(84755);
}
},
wasm: {
get AsyncWebAssemblyModulesPlugin() {
return __webpack_require__(61986);
}
},
library: {
get AbstractLibraryPlugin() {
return __webpack_require__(69503);
},
get EnableLibraryPlugin() {
return __webpack_require__(30001);
}
},
container: {
get ContainerPlugin() {
return __webpack_require__(6870);
},
get ContainerReferencePlugin() {
return __webpack_require__(37033);
},
get ModuleFederationPlugin() {
return __webpack_require__(91509);
},
get scope() {
return __webpack_require__(20912).scope;
}
},
sharing: {
get ConsumeSharedPlugin() {
return __webpack_require__(86075);
},
get ProvideSharedPlugin() {
return __webpack_require__(83685);
},
get SharePlugin() {
return __webpack_require__(5979);
},
get scope() {
return __webpack_require__(20912).scope;
}
},
debug: {
get ProfilingPlugin() {
return __webpack_require__(17678);
}
},
util: {
get createHash() {
return __webpack_require__(27466);
},
get comparators() {
return __webpack_require__(40028);
},
get runtime() {
return __webpack_require__(14372);
},
get serialization() {
return __webpack_require__(86601);
},
get cleverMerge() {
return __webpack_require__(8639).cachedCleverMerge;
},
get LazySet() {
return __webpack_require__(92585);
}
},
get sources() {
return __webpack_require__(37946);
},
experiments: {
schemes: {
get HttpUriPlugin() {
return __webpack_require__(9420);
}
},
ids: {
get SyncModuleIdsPlugin() {
return __webpack_require__(12686);
}
}
}
});
},
92440: (module, __unused_webpack_exports, __webpack_require__) => {
var LoaderLoadingError = __webpack_require__(47843), url;
function handleResult(loader, module, callback) {
return "function" != typeof module && "object" != typeof module ? callback(new LoaderLoadingError("Module '" + loader.path + "' is not a loader (export function or es6 module)")) : (loader.normal = "function" == typeof module ? module : module.default, 
loader.pitch = module.pitch, loader.raw = module.raw, "function" != typeof loader.normal && "function" != typeof loader.pitch ? callback(new LoaderLoadingError("Module '" + loader.path + "' is not a loader (must have normal or pitch function)")) : void callback());
}
module.exports = function loadLoader(loader, callback) {
if ("module" !== loader.type) {
try {
var module = __webpack_require__(35965)(loader.path);
} catch (e) {
if (e instanceof Error && "EMFILE" === e.code) {
var retry = loadLoader.bind(null, loader, callback);
return "function" == typeof setImmediate ? setImmediate(retry) : process.nextTick(retry);
}
return callback(e);
}
return handleResult(loader, module, callback);
}
try {
void 0 === url && (url = __webpack_require__(57310));
var loaderUrl = url.pathToFileURL(loader.path), modulePromise = eval("import(" + JSON.stringify(loaderUrl.toString()) + ")");
return void modulePromise.then((function(module) {
handleResult(loader, module, callback);
}), callback);
} catch (e) {
callback(e);
}
};
},
80763: (module, exports, __webpack_require__) => {
"use strict";
const createHash = __webpack_require__(27466), ArraySerializer = __webpack_require__(75790), DateObjectSerializer = __webpack_require__(91196), ErrorObjectSerializer = __webpack_require__(82475), MapObjectSerializer = __webpack_require__(99368), NullPrototypeObjectSerializer = __webpack_require__(13294), PlainObjectSerializer = __webpack_require__(40744), RegExpObjectSerializer = __webpack_require__(27005), SerializerMiddleware = __webpack_require__(66852), SetObjectSerializer = __webpack_require__(55432), setMapSize = (map, size) => {
let i = 0;
for (const item of map.keys()) i++ >= size && map.delete(item);
}, toHash = (buffer, hashFunction) => {
const hash = createHash(hashFunction);
return hash.update(buffer), hash.digest("latin1");
}, serializers = new Map, serializerInversed = new Map, loadedRequests = new Set, NOT_SERIALIZABLE = {}, jsTypes = new Map;
if (jsTypes.set(Object, new PlainObjectSerializer), jsTypes.set(Array, new ArraySerializer), 
jsTypes.set(null, new NullPrototypeObjectSerializer), jsTypes.set(Map, new MapObjectSerializer), 
jsTypes.set(Set, new SetObjectSerializer), jsTypes.set(Date, new DateObjectSerializer), 
jsTypes.set(RegExp, new RegExpObjectSerializer), jsTypes.set(Error, new ErrorObjectSerializer(Error)), 
jsTypes.set(EvalError, new ErrorObjectSerializer(EvalError)), jsTypes.set(RangeError, new ErrorObjectSerializer(RangeError)), 
jsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError)), jsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError)), 
jsTypes.set(TypeError, new ErrorObjectSerializer(TypeError)), exports.constructor !== Object) {
const Fn = exports.constructor.constructor;
for (const [type, config] of Array.from(jsTypes)) if (type) {
const Type = new Fn(`return ${type.name};`)();
jsTypes.set(Type, config);
}
}
{
let i = 1;
for (const [type, serializer] of jsTypes) serializers.set(type, {
request: "",
name: i++,
serializer
});
}
for (const {request, name, serializer} of serializers.values()) serializerInversed.set(`${request}/${name}`, serializer);
const loaders = new Map;
class ObjectMiddleware extends SerializerMiddleware {
constructor(extendContext, hashFunction = "md4") {
super(), this.extendContext = extendContext, this._hashFunction = hashFunction;
}
static registerLoader(regExp, loader) {
loaders.set(regExp, loader);
}
static register(Constructor, request, name, serializer) {
const key = request + "/" + name;
if (serializers.has(Constructor)) throw new Error(`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`);
if (serializerInversed.has(key)) throw new Error(`ObjectMiddleware.register: serializer for ${key} is already registered`);
serializers.set(Constructor, {
request,
name,
serializer
}), serializerInversed.set(key, serializer);
}
static registerNotSerializable(Constructor) {
if (serializers.has(Constructor)) throw new Error(`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`);
serializers.set(Constructor, NOT_SERIALIZABLE);
}
static getSerializerFor(object) {
const proto = Object.getPrototypeOf(object);
let c;
if (null === proto) c = null; else if (c = proto.constructor, !c) throw new Error("Serialization of objects with prototype without valid constructor property not possible");
const config = serializers.get(c);
if (!config) throw new Error(`No serializer registered for ${c.name}`);
if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;
return config;
}
static getDeserializerFor(request, name) {
const key = request + "/" + name, serializer = serializerInversed.get(key);
if (void 0 === serializer) throw new Error(`No deserializer registered for ${key}`);
return serializer;
}
static _getDeserializerForWithoutError(request, name) {
const key = request + "/" + name;
return serializerInversed.get(key);
}
serialize(data, context) {
let result = [ 2 ], currentPos = 0, referenceable = new Map;
const addReferenceable = item => {
referenceable.set(item, currentPos++);
};
let bufferDedupeMap = new Map;
const dedupeBuffer = buf => {
const len = buf.length, entry = bufferDedupeMap.get(len);
if (void 0 === entry) return bufferDedupeMap.set(len, buf), buf;
if (Buffer.isBuffer(entry)) {
if (len < 32) return buf.equals(entry) ? entry : (bufferDedupeMap.set(len, [ entry, buf ]), 
buf);
{
const hash = toHash(entry, this._hashFunction), newMap = new Map;
newMap.set(hash, entry), bufferDedupeMap.set(len, newMap);
return hash === toHash(buf, this._hashFunction) ? entry : buf;
}
}
if (Array.isArray(entry)) {
if (entry.length < 16) {
for (const item of entry) if (buf.equals(item)) return item;
return entry.push(buf), buf;
}
{
const newMap = new Map, hash = toHash(buf, this._hashFunction);
let found;
for (const item of entry) {
const itemHash = toHash(item, this._hashFunction);
newMap.set(itemHash, item), void 0 === found && itemHash === hash && (found = item);
}
return bufferDedupeMap.set(len, newMap), void 0 === found ? (newMap.set(hash, buf), 
buf) : found;
}
}
{
const hash = toHash(buf, this._hashFunction), item = entry.get(hash);
return void 0 !== item ? item : (entry.set(hash, buf), buf);
}
};
let currentPosTypeLookup = 0, objectTypeLookup = new Map;
const cycleStack = new Set;
let hasDebugInfoAttached, ctx = {
write(value, key) {
try {
process(value);
} catch (e) {
throw e !== NOT_SERIALIZABLE && (void 0 === hasDebugInfoAttached && (hasDebugInfoAttached = new WeakSet), 
hasDebugInfoAttached.has(e) || (e.message += `\nwhile serializing ${(item => {
const arr = Array.from(cycleStack);
return arr.push(item), arr.map((item => {
if ("string" == typeof item) return item.length > 100 ? `String ${JSON.stringify(item.slice(0, 100)).slice(0, -1)}..."` : `String ${JSON.stringify(item)}`;
try {
const {request, name} = ObjectMiddleware.getSerializerFor(item);
if (request) return `${request}${name ? `.${name}` : ""}`;
} catch (e) {}
if ("object" == typeof item && null !== item) return item.constructor ? item.constructor === Object ? `Object { ${Object.keys(item).join(", ")} }` : item.constructor === Map ? `Map { ${item.size} items }` : item.constructor === Array ? `Array { ${item.length} items }` : item.constructor === Set ? `Set { ${item.size} items }` : item.constructor === RegExp ? item.toString() : `${item.constructor.name}` : `Object [null prototype] { ${Object.keys(item).join(", ")} }`;
try {
return `${item}`;
} catch (e) {
return `(${e.message})`;
}
})).join(" -> ");
})(value)}`, hasDebugInfoAttached.add(e))), e;
}
},
setCircularReference(ref) {
addReferenceable(ref);
},
snapshot: () => ({
length: result.length,
cycleStackSize: cycleStack.size,
referenceableSize: referenceable.size,
currentPos,
objectTypeLookupSize: objectTypeLookup.size,
currentPosTypeLookup
}),
rollback(snapshot) {
result.length = snapshot.length, ((set, size) => {
let i = 0;
for (const item of set) i++ >= size && set.delete(item);
})(cycleStack, snapshot.cycleStackSize), setMapSize(referenceable, snapshot.referenceableSize), 
currentPos = snapshot.currentPos, setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize), 
currentPosTypeLookup = snapshot.currentPosTypeLookup;
},
...context
};
this.extendContext(ctx);
const process = item => {
if (Buffer.isBuffer(item)) {
const ref = referenceable.get(item);
if (void 0 !== ref) return void result.push(null, ref - currentPos);
const alreadyUsedBuffer = dedupeBuffer(item);
if (alreadyUsedBuffer !== item) {
const ref = referenceable.get(alreadyUsedBuffer);
if (void 0 !== ref) return referenceable.set(item, ref), void result.push(null, ref - currentPos);
item = alreadyUsedBuffer;
}
addReferenceable(item), result.push(item);
} else if (null === item) result.push(null, null); else if ("object" == typeof item) {
const ref = referenceable.get(item);
if (void 0 !== ref) return void result.push(null, ref - currentPos);
if (cycleStack.has(item)) throw new Error("This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.");
const {request, name, serializer} = ObjectMiddleware.getSerializerFor(item), key = `${request}/${name}`, lastIndex = objectTypeLookup.get(key);
void 0 === lastIndex ? (objectTypeLookup.set(key, currentPosTypeLookup++), result.push(null, request, name)) : result.push(null, currentPosTypeLookup - lastIndex), 
cycleStack.add(item);
try {
serializer.serialize(item, ctx);
} finally {
cycleStack.delete(item);
}
result.push(null, true), addReferenceable(item);
} else if ("string" == typeof item) {
if (item.length > 1) {
const ref = referenceable.get(item);
if (void 0 !== ref) return void result.push(null, ref - currentPos);
addReferenceable(item);
}
item.length > 102400 && context.logger && context.logger.warn(`Serializing big strings (${Math.round(item.length / 1024)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`), 
result.push(item);
} else if ("function" == typeof item) {
if (!SerializerMiddleware.isLazy(item)) throw new Error("Unexpected function " + item);
const serializedData = SerializerMiddleware.getLazySerializedValue(item);
if (void 0 !== serializedData) {
if ("function" != typeof serializedData) throw new Error("Not implemented");
result.push(serializedData);
} else {
if (SerializerMiddleware.isLazy(item, this)) throw new Error("Not implemented");
{
const data = SerializerMiddleware.serializeLazy(item, (data => this.serialize([ data ], context)));
SerializerMiddleware.setLazySerializedValue(item, data), result.push(data);
}
}
} else void 0 === item ? result.push(null, false) : result.push(item);
};
try {
for (const item of data) process(item);
return result;
} catch (e) {
if (e === NOT_SERIALIZABLE) return null;
throw e;
} finally {
data = result = referenceable = bufferDedupeMap = objectTypeLookup = ctx = void 0;
}
}
deserialize(data, context) {
let currentDataPos = 0;
const read = () => {
if (currentDataPos >= data.length) throw new Error("Unexpected end of stream");
return data[currentDataPos++];
};
if (2 !== read()) throw new Error("Version mismatch, serializer changed");
let currentPos = 0, referenceable = [];
const addReferenceable = item => {
referenceable.push(item), currentPos++;
};
let currentPosTypeLookup = 0, objectTypeLookup = [], result = [], ctx = {
read: () => decodeValue(),
setCircularReference(ref) {
addReferenceable(ref);
},
...context
};
this.extendContext(ctx);
const decodeValue = () => {
const item = read();
if (null !== item) return "string" == typeof item ? (item.length > 1 && addReferenceable(item), 
item) : Buffer.isBuffer(item) ? (addReferenceable(item), item) : "function" == typeof item ? SerializerMiddleware.deserializeLazy(item, (data => this.deserialize(data, context)[0])) : item;
{
const nextItem = read();
if (null === nextItem) return null;
if (false === nextItem) return;
if (true === nextItem) throw new Error("Unexpected end of object at position " + (currentDataPos - 1));
{
const request = nextItem;
let serializer;
if ("number" == typeof request) {
if (request < 0) return referenceable[currentPos + request];
serializer = objectTypeLookup[currentPosTypeLookup - request];
} else {
if ("string" != typeof request) throw new Error(`Unexpected type (${typeof request}) of request at position ` + (currentDataPos - 1));
const name = read();
if (serializer = ObjectMiddleware._getDeserializerForWithoutError(request, name), 
void 0 === serializer) {
if (request && !loadedRequests.has(request)) {
let loaded = !1;
for (const [regExp, loader] of loaders) if (regExp.test(request) && loader(request)) {
loaded = !0;
break;
}
loaded || __webpack_require__(35965)(request), loadedRequests.add(request);
}
serializer = ObjectMiddleware.getDeserializerFor(request, name);
}
objectTypeLookup.push(serializer), currentPosTypeLookup++;
}
try {
const item = serializer.deserialize(ctx);
if (null !== read()) throw new Error("Expected end of object");
if (true !== read()) throw new Error("Expected end of object");
return addReferenceable(item), item;
} catch (err) {
let serializerEntry;
for (const entry of serializers) if (entry[1].serializer === serializer) {
serializerEntry = entry;
break;
}
const name = serializerEntry ? serializerEntry[1].request ? serializerEntry[1].name ? `${serializerEntry[1].request} ${serializerEntry[1].name}` : serializerEntry[1].request : serializerEntry[0].name : "unknown";
throw err.message += `\n(during deserialization of ${name})`, err;
}
}
}
};
try {
for (;currentDataPos < data.length; ) result.push(decodeValue());
return result;
} finally {
result = referenceable = data = objectTypeLookup = ctx = void 0;
}
}
}
module.exports = ObjectMiddleware, module.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;
},
87247: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onResult, onDone}) {
let code = "";
return code += `var _results = new Array(${this.options.taps.length});\n`, code += "var _checkDone = function() {\n", 
code += "for(var i = 0; i < _results.length; i++) {\n", code += "var item = _results[i];\n", 
code += "if(item === undefined) return false;\n", code += "if(item.result !== undefined) {\n", 
code += onResult("item.result"), code += "return true;\n", code += "}\n", code += "if(item.error) {\n", 
code += onError("item.error"), code += "return true;\n", code += "}\n", code += "}\n", 
code += "return false;\n", code += "}\n", code += this.callTapsParallel({
onError: (i, err, done, doneBreak) => {
let code = "";
return code += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`, 
code += doneBreak(!0), code += "} else {\n", code += done(), code += "}\n", code;
},
onResult: (i, result, done, doneBreak) => {
let code = "";
return code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`, 
code += doneBreak(!0), code += "} else {\n", code += done(), code += "}\n", code;
},
onTap: (i, run, done, doneBreak) => {
let code = "";
return i > 0 && (code += `if(${i} >= _results.length) {\n`, code += done(), code += "} else {\n"), 
code += run(), i > 0 && (code += "}\n"), code;
},
onDone
}), code;
}
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function AsyncParallelBailHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = AsyncParallelBailHook, hook.compile = COMPILE, hook._call = void 0, 
hook.call = void 0, hook;
}
AsyncParallelBailHook.prototype = null, module.exports = AsyncParallelBailHook;
},
26714: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onDone}) {
return this.callTapsParallel({
onError: (i, err, done, doneBreak) => onError(err) + doneBreak(!0),
onDone
});
}
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function AsyncParallelHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = AsyncParallelHook, hook.compile = COMPILE, hook._call = void 0, 
hook.call = void 0, hook;
}
AsyncParallelHook.prototype = null, module.exports = AsyncParallelHook;
},
21293: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onResult, resultReturns, onDone}) {
return this.callTapsSeries({
onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
onResult: (i, result, next) => `if(${result} !== undefined) {\n${onResult(result)}\n} else {\n${next()}}\n`,
resultReturns,
onDone
});
}
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function AsyncSeriesBailHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = AsyncSeriesBailHook, hook.compile = COMPILE, hook._call = void 0, 
hook.call = void 0, hook;
}
AsyncSeriesBailHook.prototype = null, module.exports = AsyncSeriesBailHook;
},
21617: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onDone}) {
return this.callTapsSeries({
onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
onDone
});
}
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function AsyncSeriesHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = AsyncSeriesHook, hook.compile = COMPILE, hook._call = void 0, 
hook.call = void 0, hook;
}
AsyncSeriesHook.prototype = null, module.exports = AsyncSeriesHook;
},
40996: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onDone}) {
return this.callTapsLooping({
onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
onDone
});
}
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function AsyncSeriesLoopHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = AsyncSeriesLoopHook, hook.compile = COMPILE, hook._call = void 0, 
hook.call = void 0, hook;
}
AsyncSeriesLoopHook.prototype = null, module.exports = AsyncSeriesLoopHook;
},
17178: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onResult, onDone}) {
return this.callTapsSeries({
onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
onResult: (i, result, next) => {
let code = "";
return code += `if(${result} !== undefined) {\n`, code += `${this._args[0]} = ${result};\n`, 
code += "}\n", code += next(), code;
},
onDone: () => onResult(this._args[0])
});
}
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function AsyncSeriesWaterfallHook(args = [], name) {
if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
const hook = new Hook(args, name);
return hook.constructor = AsyncSeriesWaterfallHook, hook.compile = COMPILE, hook._call = void 0, 
hook.call = void 0, hook;
}
AsyncSeriesWaterfallHook.prototype = null, module.exports = AsyncSeriesWaterfallHook;
},
56534: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const deprecateContext = __webpack_require__(73837).deprecate((() => {}), "Hook.context is deprecated and will be removed"), CALL_DELEGATE = function(...args) {
return this.call = this._createCall("sync"), this.call(...args);
}, CALL_ASYNC_DELEGATE = function(...args) {
return this.callAsync = this._createCall("async"), this.callAsync(...args);
}, PROMISE_DELEGATE = function(...args) {
return this.promise = this._createCall("promise"), this.promise(...args);
};
class Hook {
constructor(args = [], name) {
this._args = args, this.name = name, this.taps = [], this.interceptors = [], this._call = CALL_DELEGATE, 
this.call = CALL_DELEGATE, this._callAsync = CALL_ASYNC_DELEGATE, this.callAsync = CALL_ASYNC_DELEGATE, 
this._promise = PROMISE_DELEGATE, this.promise = PROMISE_DELEGATE, this._x = void 0, 
this.compile = this.compile, this.tap = this.tap, this.tapAsync = this.tapAsync, 
this.tapPromise = this.tapPromise;
}
compile(options) {
throw new Error("Abstract: should be overridden");
}
_createCall(type) {
return this.compile({
taps: this.taps,
interceptors: this.interceptors,
args: this._args,
type
});
}
_tap(type, options, fn) {
if ("string" == typeof options) options = {
name: options.trim()
}; else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
if ("string" != typeof options.name || "" === options.name) throw new Error("Missing name for tap");
void 0 !== options.context && deprecateContext(), options = Object.assign({
type,
fn
}, options), options = this._runRegisterInterceptors(options), this._insert(options);
}
tap(options, fn) {
this._tap("sync", options, fn);
}
tapAsync(options, fn) {
this._tap("async", options, fn);
}
tapPromise(options, fn) {
this._tap("promise", options, fn);
}
_runRegisterInterceptors(options) {
for (const interceptor of this.interceptors) if (interceptor.register) {
const newOptions = interceptor.register(options);
void 0 !== newOptions && (options = newOptions);
}
return options;
}
withOptions(options) {
const mergeOptions = opt => Object.assign({}, options, "string" == typeof opt ? {
name: opt
} : opt);
return {
name: this.name,
tap: (opt, fn) => this.tap(mergeOptions(opt), fn),
tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),
tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),
intercept: interceptor => this.intercept(interceptor),
isUsed: () => this.isUsed(),
withOptions: opt => this.withOptions(mergeOptions(opt))
};
}
isUsed() {
return this.taps.length > 0 || this.interceptors.length > 0;
}
intercept(interceptor) {
if (this._resetCompilation(), this.interceptors.push(Object.assign({}, interceptor)), 
interceptor.register) for (let i = 0; i < this.taps.length; i++) this.taps[i] = interceptor.register(this.taps[i]);
}
_resetCompilation() {
this.call = this._call, this.callAsync = this._callAsync, this.promise = this._promise;
}
_insert(item) {
let before;
this._resetCompilation(), "string" == typeof item.before ? before = new Set([ item.before ]) : Array.isArray(item.before) && (before = new Set(item.before));
let stage = 0;
"number" == typeof item.stage && (stage = item.stage);
let i = this.taps.length;
for (;i > 0; ) {
i--;
const x = this.taps[i];
this.taps[i + 1] = x;
const xStage = x.stage || 0;
if (before) {
if (before.has(x.name)) {
before.delete(x.name);
continue;
}
if (before.size > 0) continue;
}
if (!(xStage > stage)) {
i++;
break;
}
}
this.taps[i] = item;
}
}
Object.setPrototypeOf(Hook.prototype, null), module.exports = Hook;
},
12275: module => {
"use strict";
module.exports = class {
constructor(config) {
this.config = config, this.options = void 0, this._args = void 0;
}
create(options) {
let fn;
switch (this.init(options), this.options.type) {
case "sync":
fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
onError: err => `throw ${err};\n`,
onResult: result => `return ${result};\n`,
resultReturns: !0,
onDone: () => "",
rethrowIfPossible: !0
}));
break;

case "async":
fn = new Function(this.args({
after: "_callback"
}), '"use strict";\n' + this.header() + this.contentWithInterceptors({
onError: err => `_callback(${err});\n`,
onResult: result => `_callback(null, ${result});\n`,
onDone: () => "_callback();\n"
}));
break;

case "promise":
let errorHelperUsed = !1;
const content = this.contentWithInterceptors({
onError: err => (errorHelperUsed = !0, `_error(${err});\n`),
onResult: result => `_resolve(${result});\n`,
onDone: () => "_resolve();\n"
});
let code = "";
code += '"use strict";\n', code += this.header(), code += "return new Promise((function(_resolve, _reject) {\n", 
errorHelperUsed && (code += "var _sync = true;\n", code += "function _error(_err) {\n", 
code += "if(_sync)\n", code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n", 
code += "else\n", code += "_reject(_err);\n", code += "};\n"), code += content, 
errorHelperUsed && (code += "_sync = false;\n"), code += "}));\n", fn = new Function(this.args(), code);
}
return this.deinit(), fn;
}
setup(instance, options) {
instance._x = options.taps.map((t => t.fn));
}
init(options) {
this.options = options, this._args = options.args.slice();
}
deinit() {
this.options = void 0, this._args = void 0;
}
contentWithInterceptors(options) {
if (this.options.interceptors.length > 0) {
const onError = options.onError, onResult = options.onResult, onDone = options.onDone;
let code = "";
for (let i = 0; i < this.options.interceptors.length; i++) {
const interceptor = this.options.interceptors[i];
interceptor.call && (code += `${this.getInterceptor(i)}.call(${this.args({
before: interceptor.context ? "_context" : void 0
})});\n`);
}
return code += this.content(Object.assign(options, {
onError: onError && (err => {
let code = "";
for (let i = 0; i < this.options.interceptors.length; i++) {
this.options.interceptors[i].error && (code += `${this.getInterceptor(i)}.error(${err});\n`);
}
return code += onError(err), code;
}),
onResult: onResult && (result => {
let code = "";
for (let i = 0; i < this.options.interceptors.length; i++) {
this.options.interceptors[i].result && (code += `${this.getInterceptor(i)}.result(${result});\n`);
}
return code += onResult(result), code;
}),
onDone: onDone && (() => {
let code = "";
for (let i = 0; i < this.options.interceptors.length; i++) {
this.options.interceptors[i].done && (code += `${this.getInterceptor(i)}.done();\n`);
}
return code += onDone(), code;
})
})), code;
}
return this.content(options);
}
header() {
let code = "";
return this.needContext() ? code += "var _context = {};\n" : code += "var _context;\n", 
code += "var _x = this._x;\n", this.options.interceptors.length > 0 && (code += "var _taps = this.taps;\n", 
code += "var _interceptors = this.interceptors;\n"), code;
}
needContext() {
for (const tap of this.options.taps) if (tap.context) return !0;
return !1;
}
callTap(tapIndex, {onError, onResult, onDone, rethrowIfPossible}) {
let code = "", hasTapCached = !1;
for (let i = 0; i < this.options.interceptors.length; i++) {
const interceptor = this.options.interceptors[i];
interceptor.tap && (hasTapCached || (code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`, 
hasTapCached = !0), code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});\n`);
}
code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
const tap = this.options.taps[tapIndex];
switch (tap.type) {
case "sync":
rethrowIfPossible || (code += `var _hasError${tapIndex} = false;\n`, code += "try {\n"), 
code += onResult ? `var _result${tapIndex} = _fn${tapIndex}(${this.args({
before: tap.context ? "_context" : void 0
})});\n` : `_fn${tapIndex}(${this.args({
before: tap.context ? "_context" : void 0
})});\n`, rethrowIfPossible || (code += "} catch(_err) {\n", code += `_hasError${tapIndex} = true;\n`, 
code += onError("_err"), code += "}\n", code += `if(!_hasError${tapIndex}) {\n`), 
onResult && (code += onResult(`_result${tapIndex}`)), onDone && (code += onDone()), 
rethrowIfPossible || (code += "}\n");
break;

case "async":
let cbCode = "";
cbCode += onResult ? `(function(_err${tapIndex}, _result${tapIndex}) {\n` : `(function(_err${tapIndex}) {\n`, 
cbCode += `if(_err${tapIndex}) {\n`, cbCode += onError(`_err${tapIndex}`), cbCode += "} else {\n", 
onResult && (cbCode += onResult(`_result${tapIndex}`)), onDone && (cbCode += onDone()), 
cbCode += "}\n", cbCode += "})", code += `_fn${tapIndex}(${this.args({
before: tap.context ? "_context" : void 0,
after: cbCode
})});\n`;
break;

case "promise":
code += `var _hasResult${tapIndex} = false;\n`, code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
before: tap.context ? "_context" : void 0
})});\n`, code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`, code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`, 
code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`, code += `_hasResult${tapIndex} = true;\n`, 
onResult && (code += onResult(`_result${tapIndex}`)), onDone && (code += onDone()), 
code += `}), function(_err${tapIndex}) {\n`, code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`, 
code += onError(`_err${tapIndex}`), code += "});\n";
}
return code;
}
callTapsSeries({onError, onResult, resultReturns, onDone, doneReturns, rethrowIfPossible}) {
if (0 === this.options.taps.length) return onDone();
const firstAsync = this.options.taps.findIndex((t => "sync" !== t.type)), somethingReturns = resultReturns || doneReturns;
let code = "", current = onDone, unrollCounter = 0;
for (let j = this.options.taps.length - 1; j >= 0; j--) {
const i = j;
current !== onDone && ("sync" !== this.options.taps[i].type || unrollCounter++ > 20) && (unrollCounter = 0, 
code += `function _next${i}() {\n`, code += current(), code += "}\n", current = () => `${somethingReturns ? "return " : ""}_next${i}();\n`);
const done = current, doneBreak = skipDone => skipDone ? "" : onDone(), content = this.callTap(i, {
onError: error => onError(i, error, done, doneBreak),
onResult: onResult && (result => onResult(i, result, done, doneBreak)),
onDone: !onResult && done,
rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
});
current = () => content;
}
return code += current(), code;
}
callTapsLooping({onError, onDone, rethrowIfPossible}) {
if (0 === this.options.taps.length) return onDone();
const syncOnly = this.options.taps.every((t => "sync" === t.type));
let code = "";
syncOnly || (code += "var _looper = (function() {\n", code += "var _loopAsync = false;\n"), 
code += "var _loop;\n", code += "do {\n", code += "_loop = false;\n";
for (let i = 0; i < this.options.interceptors.length; i++) {
const interceptor = this.options.interceptors[i];
interceptor.loop && (code += `${this.getInterceptor(i)}.loop(${this.args({
before: interceptor.context ? "_context" : void 0
})});\n`);
}
return code += this.callTapsSeries({
onError,
onResult: (i, result, next, doneBreak) => {
let code = "";
return code += `if(${result} !== undefined) {\n`, code += "_loop = true;\n", syncOnly || (code += "if(_loopAsync) _looper();\n"), 
code += doneBreak(!0), code += "} else {\n", code += next(), code += "}\n", code;
},
onDone: onDone && (() => {
let code = "";
return code += "if(!_loop) {\n", code += onDone(), code += "}\n", code;
}),
rethrowIfPossible: rethrowIfPossible && syncOnly
}), code += "} while(_loop);\n", syncOnly || (code += "_loopAsync = true;\n", code += "});\n", 
code += "_looper();\n"), code;
}
callTapsParallel({onError, onResult, onDone, rethrowIfPossible, onTap = (i, run) => run()}) {
if (this.options.taps.length <= 1) return this.callTapsSeries({
onError,
onResult,
onDone,
rethrowIfPossible
});
let code = "";
code += "do {\n", code += `var _counter = ${this.options.taps.length};\n`, onDone && (code += "var _done = (function() {\n", 
code += onDone(), code += "});\n");
for (let i = 0; i < this.options.taps.length; i++) {
const done = () => onDone ? "if(--_counter === 0) _done();\n" : "--_counter;", doneBreak = skipDone => skipDone || !onDone ? "_counter = 0;\n" : "_counter = 0;\n_done();\n";
code += "if(_counter <= 0) break;\n", code += onTap(i, (() => this.callTap(i, {
onError: error => {
let code = "";
return code += "if(_counter > 0) {\n", code += onError(i, error, done, doneBreak), 
code += "}\n", code;
},
onResult: onResult && (result => {
let code = "";
return code += "if(_counter > 0) {\n", code += onResult(i, result, done, doneBreak), 
code += "}\n", code;
}),
onDone: !onResult && (() => done()),
rethrowIfPossible
})), done, doneBreak);
}
return code += "} while(false);\n", code;
}
args({before, after} = {}) {
let allArgs = this._args;
return before && (allArgs = [ before ].concat(allArgs)), after && (allArgs = allArgs.concat(after)), 
0 === allArgs.length ? "" : allArgs.join(", ");
}
getTapFn(idx) {
return `_x[${idx}]`;
}
getTap(idx) {
return `_taps[${idx}]`;
}
getInterceptor(idx) {
return `_interceptors[${idx}]`;
}
};
},
12459: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), defaultFactory = (key, hook) => hook;
class HookMap {
constructor(factory, name) {
this._map = new Map, this.name = name, this._factory = factory, this._interceptors = [];
}
get(key) {
return this._map.get(key);
}
for(key) {
const hook = this.get(key);
if (void 0 !== hook) return hook;
let newHook = this._factory(key);
const interceptors = this._interceptors;
for (let i = 0; i < interceptors.length; i++) newHook = interceptors[i].factory(key, newHook);
return this._map.set(key, newHook), newHook;
}
intercept(interceptor) {
this._interceptors.push(Object.assign({
factory: defaultFactory
}, interceptor));
}
}
HookMap.prototype.tap = util.deprecate((function(key, options, fn) {
return this.for(key).tap(options, fn);
}), "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead."), HookMap.prototype.tapAsync = util.deprecate((function(key, options, fn) {
return this.for(key).tapAsync(options, fn);
}), "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead."), 
HookMap.prototype.tapPromise = util.deprecate((function(key, options, fn) {
return this.for(key).tapPromise(options, fn);
}), "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead."), 
module.exports = HookMap;
},
70942: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
__webpack_require__(56534);
class MultiHook {
constructor(hooks, name) {
this.hooks = hooks, this.name = name;
}
tap(options, fn) {
for (const hook of this.hooks) hook.tap(options, fn);
}
tapAsync(options, fn) {
for (const hook of this.hooks) hook.tapAsync(options, fn);
}
tapPromise(options, fn) {
for (const hook of this.hooks) hook.tapPromise(options, fn);
}
isUsed() {
for (const hook of this.hooks) if (hook.isUsed()) return !0;
return !1;
}
intercept(interceptor) {
for (const hook of this.hooks) hook.intercept(interceptor);
}
withOptions(options) {
return new MultiHook(this.hooks.map((h => h.withOptions(options))), this.name);
}
}
module.exports = MultiHook;
},
13922: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onResult, resultReturns, onDone, rethrowIfPossible}) {
return this.callTapsSeries({
onError: (i, err) => onError(err),
onResult: (i, result, next) => `if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
resultReturns,
onDone,
rethrowIfPossible
});
}
}, TAP_ASYNC = () => {
throw new Error("tapAsync is not supported on a SyncBailHook");
}, TAP_PROMISE = () => {
throw new Error("tapPromise is not supported on a SyncBailHook");
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function SyncBailHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = SyncBailHook, hook.tapAsync = TAP_ASYNC, hook.tapPromise = TAP_PROMISE, 
hook.compile = COMPILE, hook;
}
SyncBailHook.prototype = null, module.exports = SyncBailHook;
},
90537: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onDone, rethrowIfPossible}) {
return this.callTapsSeries({
onError: (i, err) => onError(err),
onDone,
rethrowIfPossible
});
}
}, TAP_ASYNC = () => {
throw new Error("tapAsync is not supported on a SyncHook");
}, TAP_PROMISE = () => {
throw new Error("tapPromise is not supported on a SyncHook");
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function SyncHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = SyncHook, hook.tapAsync = TAP_ASYNC, hook.tapPromise = TAP_PROMISE, 
hook.compile = COMPILE, hook;
}
SyncHook.prototype = null, module.exports = SyncHook;
},
43074: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onDone, rethrowIfPossible}) {
return this.callTapsLooping({
onError: (i, err) => onError(err),
onDone,
rethrowIfPossible
});
}
}, TAP_ASYNC = () => {
throw new Error("tapAsync is not supported on a SyncLoopHook");
}, TAP_PROMISE = () => {
throw new Error("tapPromise is not supported on a SyncLoopHook");
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function SyncLoopHook(args = [], name) {
const hook = new Hook(args, name);
return hook.constructor = SyncLoopHook, hook.tapAsync = TAP_ASYNC, hook.tapPromise = TAP_PROMISE, 
hook.compile = COMPILE, hook;
}
SyncLoopHook.prototype = null, module.exports = SyncLoopHook;
},
62076: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hook = __webpack_require__(56534), HookCodeFactory = __webpack_require__(12275);
const factory = new class extends HookCodeFactory {
content({onError, onResult, resultReturns, rethrowIfPossible}) {
return this.callTapsSeries({
onError: (i, err) => onError(err),
onResult: (i, result, next) => {
let code = "";
return code += `if(${result} !== undefined) {\n`, code += `${this._args[0]} = ${result};\n`, 
code += "}\n", code += next(), code;
},
onDone: () => onResult(this._args[0]),
doneReturns: resultReturns,
rethrowIfPossible
});
}
}, TAP_ASYNC = () => {
throw new Error("tapAsync is not supported on a SyncWaterfallHook");
}, TAP_PROMISE = () => {
throw new Error("tapPromise is not supported on a SyncWaterfallHook");
}, COMPILE = function(options) {
return factory.setup(this, options), factory.create(options);
};
function SyncWaterfallHook(args = [], name) {
if (args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
const hook = new Hook(args, name);
return hook.constructor = SyncWaterfallHook, hook.tapAsync = TAP_ASYNC, hook.tapPromise = TAP_PROMISE, 
hook.compile = COMPILE, hook;
}
SyncWaterfallHook.prototype = null, module.exports = SyncWaterfallHook;
},
89991: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
exports.__esModule = !0, exports.SyncHook = __webpack_require__(90537), exports.SyncBailHook = __webpack_require__(13922), 
exports.SyncWaterfallHook = __webpack_require__(62076), exports.SyncLoopHook = __webpack_require__(43074), 
exports.AsyncParallelHook = __webpack_require__(26714), exports.AsyncParallelBailHook = __webpack_require__(87247), 
exports.AsyncSeriesHook = __webpack_require__(21617), exports.AsyncSeriesBailHook = __webpack_require__(21293), 
exports.AsyncSeriesLoopHook = __webpack_require__(40996), exports.AsyncSeriesWaterfallHook = __webpack_require__(17178), 
exports.HookMap = __webpack_require__(12459), exports.MultiHook = __webpack_require__(70942);
},
26899: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const EventEmitter = __webpack_require__(82361).EventEmitter, fs = __webpack_require__(20077), path = __webpack_require__(71017), watchEventSource = __webpack_require__(6197), EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});
let FS_ACCURACY = 2e3;
const IS_OSX = "darwin" === __webpack_require__(22037).platform(), WATCHPACK_POLLING = process.env.WATCHPACK_POLLING, FORCE_POLLING = "" + +WATCHPACK_POLLING === WATCHPACK_POLLING ? +WATCHPACK_POLLING : !!WATCHPACK_POLLING && "false" !== WATCHPACK_POLLING;
function withoutCase(str) {
return str.toLowerCase();
}
class Watcher extends EventEmitter {
constructor(directoryWatcher, filePath, startTime) {
super(), this.directoryWatcher = directoryWatcher, this.path = filePath, this.startTime = startTime && +startTime;
}
checkStartTime(mtime, initial) {
const startTime = this.startTime;
return "number" != typeof startTime ? !initial : startTime <= mtime;
}
close() {
this.emit("closed");
}
}
function fixupEntryAccuracy(entry) {
entry.accuracy > FS_ACCURACY && (entry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY, 
entry.accuracy = FS_ACCURACY);
}
function ensureFsAccuracy(mtime) {
mtime && (FS_ACCURACY > 1 && mtime % 1 != 0 ? FS_ACCURACY = 1 : FS_ACCURACY > 10 && mtime % 10 != 0 ? FS_ACCURACY = 10 : FS_ACCURACY > 100 && mtime % 100 != 0 ? FS_ACCURACY = 100 : FS_ACCURACY > 1e3 && mtime % 1e3 != 0 && (FS_ACCURACY = 1e3));
}
module.exports = class extends EventEmitter {
constructor(watcherManager, directoryPath, options) {
super(), FORCE_POLLING && (options.poll = FORCE_POLLING), this.watcherManager = watcherManager, 
this.options = options, this.path = directoryPath, this.files = new Map, this.filesWithoutCase = new Map, 
this.directories = new Map, this.lastWatchEvent = 0, this.initialScan = !0, this.ignored = options.ignored || (() => !1), 
this.nestedWatching = !1, this.polledWatching = "number" == typeof options.poll ? options.poll : !!options.poll && 5007, 
this.timeout = void 0, this.initialScanRemoved = new Set, this.initialScanFinished = void 0, 
this.watchers = new Map, this.parentWatcher = null, this.refs = 0, this._activeEvents = new Map, 
this.closed = !1, this.scanning = !1, this.scanAgain = !1, this.scanAgainInitial = !1, 
this.createWatcher(), this.doScan(!0);
}
createWatcher() {
try {
this.polledWatching ? this.watcher = {
close: () => {
this.timeout && (clearTimeout(this.timeout), this.timeout = void 0);
}
} : (IS_OSX && this.watchInParentDirectory(), this.watcher = watchEventSource.watch(this.path), 
this.watcher.on("change", this.onWatchEvent.bind(this)), this.watcher.on("error", this.onWatcherError.bind(this)));
} catch (err) {
this.onWatcherError(err);
}
}
forEachWatcher(path, fn) {
const watchers = this.watchers.get(withoutCase(path));
if (void 0 !== watchers) for (const w of watchers) fn(w);
}
setMissing(itemPath, initial, type) {
this.initialScan && this.initialScanRemoved.add(itemPath);
const oldDirectory = this.directories.get(itemPath);
oldDirectory && (this.nestedWatching && oldDirectory.close(), this.directories.delete(itemPath), 
this.forEachWatcher(itemPath, (w => w.emit("remove", type))), initial || this.forEachWatcher(this.path, (w => w.emit("change", itemPath, null, type, initial))));
if (this.files.get(itemPath)) {
this.files.delete(itemPath);
const key = withoutCase(itemPath), count = this.filesWithoutCase.get(key) - 1;
count <= 0 ? (this.filesWithoutCase.delete(key), this.forEachWatcher(itemPath, (w => w.emit("remove", type)))) : this.filesWithoutCase.set(key, count), 
initial || this.forEachWatcher(this.path, (w => w.emit("change", itemPath, null, type, initial)));
}
}
setFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {
const now = Date.now();
if (this.ignored(filePath)) return;
const old = this.files.get(filePath);
let safeTime, accuracy;
if (initial) safeTime = Math.min(now, mtime) + FS_ACCURACY, accuracy = FS_ACCURACY; else if (safeTime = now, 
accuracy = 0, old && old.timestamp === mtime && mtime + FS_ACCURACY < now) return;
if (!ignoreWhenEqual || !old || old.timestamp !== mtime) {
if (this.files.set(filePath, {
safeTime,
accuracy,
timestamp: mtime
}), old) initial || this.forEachWatcher(filePath, (w => w.emit("change", mtime, type))); else {
const key = withoutCase(filePath), count = this.filesWithoutCase.get(key);
this.filesWithoutCase.set(key, (count || 0) + 1), void 0 !== count && this.doScan(!1), 
this.forEachWatcher(filePath, (w => {
initial && !w.checkStartTime(safeTime, initial) || w.emit("change", mtime, type);
}));
}
this.forEachWatcher(this.path, (w => {
initial && !w.checkStartTime(safeTime, initial) || w.emit("change", filePath, safeTime, type, initial);
}));
}
}
setDirectory(directoryPath, birthtime, initial, type) {
if (!this.ignored(directoryPath)) if (directoryPath === this.path) initial || this.forEachWatcher(this.path, (w => w.emit("change", directoryPath, birthtime, type, initial))); else {
if (!this.directories.get(directoryPath)) {
const now = Date.now();
let safeTime;
this.nestedWatching ? this.createNestedWatcher(directoryPath) : this.directories.set(directoryPath, !0), 
safeTime = initial ? Math.min(now, birthtime) + FS_ACCURACY : now, this.forEachWatcher(directoryPath, (w => {
initial && !w.checkStartTime(safeTime, !1) || w.emit("change", birthtime, type);
})), this.forEachWatcher(this.path, (w => {
initial && !w.checkStartTime(safeTime, initial) || w.emit("change", directoryPath, safeTime, type, initial);
}));
}
}
}
createNestedWatcher(directoryPath) {
const watcher = this.watcherManager.watchDirectory(directoryPath, 1);
watcher.on("change", ((filePath, mtime, type, initial) => {
this.forEachWatcher(this.path, (w => {
initial && !w.checkStartTime(mtime, initial) || w.emit("change", filePath, mtime, type, initial);
}));
})), this.directories.set(directoryPath, watcher);
}
setNestedWatching(flag) {
if (this.nestedWatching !== !!flag) if (this.nestedWatching = !!flag, this.nestedWatching) for (const directory of this.directories.keys()) this.createNestedWatcher(directory); else for (const [directory, watcher] of this.directories) watcher.close(), 
this.directories.set(directory, !0);
}
watch(filePath, startTime) {
const key = withoutCase(filePath);
let watchers = this.watchers.get(key);
void 0 === watchers && (watchers = new Set, this.watchers.set(key, watchers)), this.refs++;
const watcher = new Watcher(this, filePath, startTime);
let safeTime;
if (watcher.on("closed", (() => {
--this.refs <= 0 ? this.close() : (watchers.delete(watcher), 0 === watchers.size && (this.watchers.delete(key), 
this.path === filePath && this.setNestedWatching(!1)));
})), watchers.add(watcher), filePath === this.path) {
this.setNestedWatching(!0), safeTime = this.lastWatchEvent;
for (const entry of this.files.values()) fixupEntryAccuracy(entry), safeTime = Math.max(safeTime, entry.safeTime);
} else {
const entry = this.files.get(filePath);
entry ? (fixupEntryAccuracy(entry), safeTime = entry.safeTime) : safeTime = 0;
}
return safeTime ? safeTime >= startTime && process.nextTick((() => {
this.closed || (filePath === this.path ? watcher.emit("change", filePath, safeTime, "watch (outdated on attach)", !0) : watcher.emit("change", safeTime, "watch (outdated on attach)", !0));
})) : this.initialScan ? this.initialScanRemoved.has(filePath) && process.nextTick((() => {
this.closed || watcher.emit("remove");
})) : !this.directories.has(filePath) && watcher.checkStartTime(this.initialScanFinished, !1) && process.nextTick((() => {
this.closed || watcher.emit("initial-missing", "watch (missing on attach)");
})), watcher;
}
onWatchEvent(eventType, filename) {
if (this.closed) return;
if (!filename) return void this.doScan(!1);
const filePath = path.join(this.path, filename);
if (!this.ignored(filePath)) if (void 0 === this._activeEvents.get(filename)) {
this._activeEvents.set(filename, !1);
const checkStats = () => {
this.closed || (this._activeEvents.set(filename, !1), fs.lstat(filePath, ((err, stats) => {
this.closed || (!0 !== this._activeEvents.get(filename) ? (this._activeEvents.delete(filename), 
err && ("ENOENT" !== err.code && "EPERM" !== err.code && "EBUSY" !== err.code ? this.onStatsError(err) : filename === path.basename(this.path) && (fs.existsSync(this.path) || this.onDirectoryRemoved("stat failed"))), 
this.lastWatchEvent = Date.now(), stats ? stats.isDirectory() ? this.setDirectory(filePath, +stats.birthtime || 1, !1, eventType) : (stats.isFile() || stats.isSymbolicLink()) && (stats.mtime && ensureFsAccuracy(stats.mtime), 
this.setFileTime(filePath, +stats.mtime || +stats.ctime || 1, !1, !1, eventType)) : this.setMissing(filePath, !1, eventType)) : process.nextTick(checkStats));
})));
};
process.nextTick(checkStats);
} else this._activeEvents.set(filename, !0);
}
onWatcherError(err) {
this.closed || err && ("EPERM" !== err.code && "ENOENT" !== err.code && console.error("Watchpack Error (watcher): " + err), 
this.onDirectoryRemoved("watch error"));
}
onStatsError(err) {
err && console.error("Watchpack Error (stats): " + err);
}
onScanError(err) {
err && console.error("Watchpack Error (initial scan): " + err), this.onScanFinished();
}
onScanFinished() {
this.polledWatching && (this.timeout = setTimeout((() => {
this.closed || this.doScan(!1);
}), this.polledWatching));
}
onDirectoryRemoved(reason) {
this.watcher && (this.watcher.close(), this.watcher = null), this.watchInParentDirectory();
const type = `directory-removed (${reason})`;
for (const directory of this.directories.keys()) this.setMissing(directory, null, type);
for (const file of this.files.keys()) this.setMissing(file, null, type);
}
watchInParentDirectory() {
if (!this.parentWatcher) {
const parentDir = path.dirname(this.path);
if (path.dirname(parentDir) === parentDir) return;
this.parentWatcher = this.watcherManager.watchFile(this.path, 1), this.parentWatcher.on("change", ((mtime, type) => {
this.closed || (IS_OSX && !this.polledWatching || !this.parentWatcher || (this.parentWatcher.close(), 
this.parentWatcher = null), this.watcher || (this.createWatcher(), this.doScan(!1), 
this.forEachWatcher(this.path, (w => w.emit("change", this.path, mtime, type, !1)))));
})), this.parentWatcher.on("remove", (() => {
this.onDirectoryRemoved("parent directory removed");
}));
}
}
doScan(initial) {
this.scanning ? this.scanAgain ? initial || (this.scanAgainInitial = !1) : (this.scanAgain = !0, 
this.scanAgainInitial = initial) : (this.scanning = !0, this.timeout && (clearTimeout(this.timeout), 
this.timeout = void 0), process.nextTick((() => {
this.closed || fs.readdir(this.path, ((err, items) => {
if (this.closed) return;
if (err) {
if ("ENOENT" === err.code || "EPERM" === err.code ? this.onDirectoryRemoved("scan readdir failed") : this.onScanError(err), 
this.initialScan = !1, this.initialScanFinished = Date.now(), initial) for (const watchers of this.watchers.values()) for (const watcher of watchers) watcher.checkStartTime(this.initialScanFinished, !1) && watcher.emit("initial-missing", "scan (parent directory missing in initial scan)");
return void (this.scanAgain ? (this.scanAgain = !1, this.doScan(this.scanAgainInitial)) : this.scanning = !1);
}
const itemPaths = new Set(items.map((item => path.join(this.path, item.normalize("NFC")))));
for (const file of this.files.keys()) itemPaths.has(file) || this.setMissing(file, initial, "scan (missing)");
for (const directory of this.directories.keys()) itemPaths.has(directory) || this.setMissing(directory, initial, "scan (missing)");
if (this.scanAgain) return this.scanAgain = !1, void this.doScan(initial);
const itemFinished = (times = itemPaths.size + 1, callback = () => {
if (!this.closed) {
if (this.initialScan = !1, this.initialScanRemoved = null, this.initialScanFinished = Date.now(), 
initial) {
const missingWatchers = new Map(this.watchers);
missingWatchers.delete(withoutCase(this.path));
for (const item of itemPaths) missingWatchers.delete(withoutCase(item));
for (const watchers of missingWatchers.values()) for (const watcher of watchers) watcher.checkStartTime(this.initialScanFinished, !1) && watcher.emit("initial-missing", "scan (missing in initial scan)");
}
this.scanAgain ? (this.scanAgain = !1, this.doScan(this.scanAgainInitial)) : (this.scanning = !1, 
this.onScanFinished());
}
}, function() {
if (0 == --times) return callback();
});
var times, callback;
for (const itemPath of itemPaths) fs.lstat(itemPath, ((err2, stats) => {
if (!this.closed) {
if (err2) return "ENOENT" === err2.code || "EPERM" === err2.code || "EACCES" === err2.code || "EBUSY" === err2.code ? this.setMissing(itemPath, initial, "scan (" + err2.code + ")") : this.onScanError(err2), 
void itemFinished();
stats.isFile() || stats.isSymbolicLink() ? (stats.mtime && ensureFsAccuracy(stats.mtime), 
this.setFileTime(itemPath, +stats.mtime || +stats.ctime || 1, initial, !0, "scan (file)")) : stats.isDirectory() && (initial && this.directories.has(itemPath) || this.setDirectory(itemPath, +stats.birthtime || 1, initial, "scan (dir)")), 
itemFinished();
}
}));
itemFinished();
}));
})));
}
getTimes() {
const obj = Object.create(null);
let safeTime = this.lastWatchEvent;
for (const [file, entry] of this.files) fixupEntryAccuracy(entry), safeTime = Math.max(safeTime, entry.safeTime), 
obj[file] = Math.max(entry.safeTime, entry.timestamp);
if (this.nestedWatching) {
for (const w of this.directories.values()) {
const times = w.directoryWatcher.getTimes();
for (const file of Object.keys(times)) {
const time = times[file];
safeTime = Math.max(safeTime, time), obj[file] = time;
}
}
obj[this.path] = safeTime;
}
if (!this.initialScan) for (const watchers of this.watchers.values()) for (const watcher of watchers) {
const path = watcher.path;
Object.prototype.hasOwnProperty.call(obj, path) || (obj[path] = null);
}
return obj;
}
collectTimeInfoEntries(fileTimestamps, directoryTimestamps) {
let safeTime = this.lastWatchEvent;
for (const [file, entry] of this.files) fixupEntryAccuracy(entry), safeTime = Math.max(safeTime, entry.safeTime), 
fileTimestamps.set(file, entry);
if (this.nestedWatching) {
for (const w of this.directories.values()) safeTime = Math.max(safeTime, w.directoryWatcher.collectTimeInfoEntries(fileTimestamps, directoryTimestamps));
fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY), directoryTimestamps.set(this.path, {
safeTime
});
} else {
for (const dir of this.directories.keys()) fileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY), 
directoryTimestamps.has(dir) || directoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);
fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY), directoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);
}
if (!this.initialScan) for (const watchers of this.watchers.values()) for (const watcher of watchers) {
const path = watcher.path;
fileTimestamps.has(path) || fileTimestamps.set(path, null);
}
return safeTime;
}
close() {
if (this.closed = !0, this.initialScan = !1, this.watcher && (this.watcher.close(), 
this.watcher = null), this.nestedWatching) {
for (const w of this.directories.values()) w.close();
this.directories.clear();
}
this.parentWatcher && (this.parentWatcher.close(), this.parentWatcher = null), this.emit("closed");
}
}, module.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;
},
1913: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const fs = __webpack_require__(57147), path = __webpack_require__(71017), EXPECTED_ERRORS = new Set([ "EINVAL", "ENOENT" ]);
"win32" === process.platform && EXPECTED_ERRORS.add("UNKNOWN");
module.exports = class {
constructor() {
this.cache = new Map;
}
resolve(file) {
const cacheEntry = this.cache.get(file);
if (void 0 !== cacheEntry) return cacheEntry;
const parent = path.dirname(file);
if (parent === file) {
const result = Object.freeze([ file ]);
return this.cache.set(file, result), result;
}
const parentResolved = this.resolve(parent);
let realFile = file;
if (parentResolved[0] !== parent) {
const basename = path.basename(file);
realFile = path.resolve(parentResolved[0], basename);
}
try {
const linkContent = fs.readlinkSync(realFile), resolvedLink = path.resolve(parentResolved[0], linkContent), linkResolved = this.resolve(resolvedLink);
let result;
if (linkResolved.length > 1 && parentResolved.length > 1) {
const resultSet = new Set(linkResolved);
resultSet.add(realFile);
for (let i = 1; i < parentResolved.length; i++) resultSet.add(parentResolved[i]);
result = Object.freeze(Array.from(resultSet));
} else parentResolved.length > 1 ? (result = parentResolved.slice(), result[0] = linkResolved[0], 
result.push(realFile), Object.freeze(result)) : linkResolved.length > 1 ? (result = linkResolved.slice(), 
result.push(realFile), Object.freeze(result)) : result = Object.freeze([ linkResolved[0], realFile ]);
return this.cache.set(file, result), result;
} catch (e) {
if (!EXPECTED_ERRORS.has(e.code)) throw e;
const result = parentResolved.slice();
return result[0] = realFile, Object.freeze(result), this.cache.set(file, result), 
result;
}
}
};
},
91114: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), DirectoryWatcher = __webpack_require__(26899);
class WatcherManager {
constructor(options) {
this.options = options, this.directoryWatchers = new Map;
}
getDirectoryWatcher(directory) {
const watcher = this.directoryWatchers.get(directory);
if (void 0 === watcher) {
const newWatcher = new DirectoryWatcher(this, directory, this.options);
return this.directoryWatchers.set(directory, newWatcher), newWatcher.on("closed", (() => {
this.directoryWatchers.delete(directory);
})), newWatcher;
}
return watcher;
}
watchFile(p, startTime) {
const directory = path.dirname(p);
return directory === p ? null : this.getDirectoryWatcher(directory).watch(p, startTime);
}
watchDirectory(directory, startTime) {
return this.getDirectoryWatcher(directory).watch(directory, startTime);
}
}
const watcherManagers = new WeakMap;
module.exports = options => {
const watcherManager = watcherManagers.get(options);
if (void 0 !== watcherManager) return watcherManager;
const newWatcherManager = new WatcherManager(options);
return watcherManagers.set(options, newWatcherManager), newWatcherManager;
}, module.exports.WatcherManager = WatcherManager;
},
29295: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017);
module.exports = (plan, limit) => {
const treeMap = new Map;
for (const [filePath, value] of plan) treeMap.set(filePath, {
filePath,
parent: void 0,
children: void 0,
entries: 1,
active: !0,
value
});
let currentCount = treeMap.size;
for (const node of treeMap.values()) {
const parentPath = path.dirname(node.filePath);
if (parentPath !== node.filePath) {
let parent = treeMap.get(parentPath);
if (void 0 === parent) parent = {
filePath: parentPath,
parent: void 0,
children: [ node ],
entries: node.entries,
active: !1,
value: void 0
}, treeMap.set(parentPath, parent), node.parent = parent; else {
node.parent = parent, void 0 === parent.children ? parent.children = [ node ] : parent.children.push(node);
do {
parent.entries += node.entries, parent = parent.parent;
} while (parent);
}
}
}
for (;currentCount > limit; ) {
const overLimit = currentCount - limit;
let bestNode, bestCost = 1 / 0;
for (const node of treeMap.values()) {
if (node.entries <= 1 || !node.children || !node.parent) continue;
if (0 === node.children.length) continue;
if (1 === node.children.length && !node.value) continue;
const cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + .3 * limit;
cost < bestCost && (bestNode = node, bestCost = cost);
}
if (!bestNode) break;
const reduction = bestNode.entries - 1;
bestNode.active = !0, bestNode.entries = 1, currentCount -= reduction;
let parent = bestNode.parent;
for (;parent; ) parent.entries -= reduction, parent = parent.parent;
const queue = new Set(bestNode.children);
for (const node of queue) if (node.active = !1, node.entries = 0, node.children) for (const child of node.children) queue.add(child);
}
const newPlan = new Map;
for (const rootNode of treeMap.values()) {
if (!rootNode.active) continue;
const map = new Map, queue = new Set([ rootNode ]);
for (const node of queue) if (!node.active || node === rootNode) {
if (node.value) if (Array.isArray(node.value)) for (const item of node.value) map.set(item, node.filePath); else map.set(node.value, node.filePath);
if (node.children) for (const child of node.children) queue.add(child);
}
newPlan.set(rootNode.filePath, map);
}
return newPlan;
};
},
6197: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const fs = __webpack_require__(57147), path = __webpack_require__(71017), {EventEmitter} = __webpack_require__(82361), reducePlan = __webpack_require__(29295), IS_OSX = "darwin" === __webpack_require__(22037).platform(), IS_WIN = "win32" === __webpack_require__(22037).platform(), SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN, watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2e3 : 1e4), recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;
let isBatch = !1, watcherCount = 0;
const pendingWatchers = new Map, recursiveWatchers = new Map, directWatchers = new Map, underlyingWatcher = new Map;
class DirectWatcher {
constructor(filePath) {
this.filePath = filePath, this.watchers = new Set, this.watcher = void 0;
try {
const watcher = fs.watch(filePath);
this.watcher = watcher, watcher.on("change", ((type, filename) => {
for (const w of this.watchers) w.emit("change", type, filename);
})), watcher.on("error", (error => {
for (const w of this.watchers) w.emit("error", error);
}));
} catch (err) {
process.nextTick((() => {
for (const w of this.watchers) w.emit("error", err);
}));
}
watcherCount++;
}
add(watcher) {
underlyingWatcher.set(watcher, this), this.watchers.add(watcher);
}
remove(watcher) {
this.watchers.delete(watcher), 0 === this.watchers.size && (directWatchers.delete(this.filePath), 
watcherCount--, this.watcher && this.watcher.close());
}
getWatchers() {
return this.watchers;
}
}
class RecursiveWatcher {
constructor(rootPath) {
this.rootPath = rootPath, this.mapWatcherToPath = new Map, this.mapPathToWatchers = new Map, 
this.watcher = void 0;
try {
const watcher = fs.watch(rootPath, {
recursive: !0
});
this.watcher = watcher, watcher.on("change", ((type, filename) => {
if (filename) {
const dir = path.dirname(filename), watchers = this.mapPathToWatchers.get(dir);
if (recursiveWatcherLogging && process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) for '${filename}' to ${watchers ? watchers.size : 0} watchers\n`), 
void 0 === watchers) return;
for (const w of watchers) w.emit("change", type, path.basename(filename));
} else {
recursiveWatcherLogging && process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) to all watchers\n`);
for (const w of this.mapWatcherToPath.keys()) w.emit("change", type);
}
})), watcher.on("error", (error => {
for (const w of this.mapWatcherToPath.keys()) w.emit("error", error);
}));
} catch (err) {
process.nextTick((() => {
for (const w of this.mapWatcherToPath.keys()) w.emit("error", err);
}));
}
watcherCount++, recursiveWatcherLogging && process.stderr.write(`[watchpack] created recursive watcher at ${rootPath}\n`);
}
add(filePath, watcher) {
underlyingWatcher.set(watcher, this);
const subpath = filePath.slice(this.rootPath.length + 1) || ".";
this.mapWatcherToPath.set(watcher, subpath);
const set = this.mapPathToWatchers.get(subpath);
if (void 0 === set) {
const newSet = new Set;
newSet.add(watcher), this.mapPathToWatchers.set(subpath, newSet);
} else set.add(watcher);
}
remove(watcher) {
const subpath = this.mapWatcherToPath.get(watcher);
if (!subpath) return;
this.mapWatcherToPath.delete(watcher);
const set = this.mapPathToWatchers.get(subpath);
set.delete(watcher), 0 === set.size && this.mapPathToWatchers.delete(subpath), 0 === this.mapWatcherToPath.size && (recursiveWatchers.delete(this.rootPath), 
watcherCount--, this.watcher && this.watcher.close(), recursiveWatcherLogging && process.stderr.write(`[watchpack] closed recursive watcher at ${this.rootPath}\n`));
}
getWatchers() {
return this.mapWatcherToPath;
}
}
class Watcher extends EventEmitter {
close() {
if (pendingWatchers.has(this)) return void pendingWatchers.delete(this);
underlyingWatcher.get(this).remove(this), underlyingWatcher.delete(this);
}
}
const createDirectWatcher = filePath => {
const existing = directWatchers.get(filePath);
if (void 0 !== existing) return existing;
const w = new DirectWatcher(filePath);
return directWatchers.set(filePath, w), w;
}, createRecursiveWatcher = rootPath => {
const existing = recursiveWatchers.get(rootPath);
if (void 0 !== existing) return existing;
const w = new RecursiveWatcher(rootPath);
return recursiveWatchers.set(rootPath, w), w;
}, execute = () => {
const map = new Map, addWatcher = (watcher, filePath) => {
const entry = map.get(filePath);
void 0 === entry ? map.set(filePath, watcher) : Array.isArray(entry) ? entry.push(watcher) : map.set(filePath, [ entry, watcher ]);
};
for (const [watcher, filePath] of pendingWatchers) addWatcher(watcher, filePath);
if (pendingWatchers.clear(), !SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {
for (const [filePath, entry] of map) {
const w = createDirectWatcher(filePath);
if (Array.isArray(entry)) for (const item of entry) w.add(item); else w.add(entry);
}
return;
}
for (const watcher of recursiveWatchers.values()) for (const [w, subpath] of watcher.getWatchers()) addWatcher(w, path.join(watcher.rootPath, subpath));
for (const watcher of directWatchers.values()) for (const w of watcher.getWatchers()) addWatcher(w, watcher.filePath);
const plan = reducePlan(map, .9 * watcherLimit);
for (const [filePath, entry] of plan) if (1 === entry.size) for (const [watcher, filePath] of entry) {
const w = createDirectWatcher(filePath), old = underlyingWatcher.get(watcher);
old !== w && (w.add(watcher), void 0 !== old && old.remove(watcher));
} else {
const filePaths = new Set(entry.values());
if (filePaths.size > 1) {
const w = createRecursiveWatcher(filePath);
for (const [watcher, watcherPath] of entry) {
const old = underlyingWatcher.get(watcher);
old !== w && (w.add(watcherPath, watcher), void 0 !== old && old.remove(watcher));
}
} else for (const filePath of filePaths) {
const w = createDirectWatcher(filePath);
for (const watcher of entry.keys()) {
const old = underlyingWatcher.get(watcher);
old !== w && (w.add(watcher), void 0 !== old && old.remove(watcher));
}
}
}
};
exports.watch = filePath => {
const watcher = new Watcher, directWatcher = directWatchers.get(filePath);
if (void 0 !== directWatcher) return directWatcher.add(watcher), watcher;
let current = filePath;
for (;;) {
const recursiveWatcher = recursiveWatchers.get(current);
if (void 0 !== recursiveWatcher) return recursiveWatcher.add(filePath, watcher), 
watcher;
const parent = path.dirname(current);
if (parent === current) break;
current = parent;
}
return pendingWatchers.set(watcher, filePath), isBatch || execute(), watcher;
}, exports.batch = fn => {
isBatch = !0;
try {
fn();
} finally {
isBatch = !1, execute();
}
}, exports.getNumberOfWatchers = () => watcherCount;
},
15722: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const getWatcherManager = __webpack_require__(91114), LinkResolver = __webpack_require__(1913), EventEmitter = __webpack_require__(82361).EventEmitter, globToRegExp = __webpack_require__(81700), watchEventSource = __webpack_require__(6197), EMPTY_ARRAY = [], EMPTY_OPTIONS = {};
function addWatchersToSet(watchers, set) {
for (const ww of watchers) {
const w = ww.watcher;
set.has(w.directoryWatcher) || set.add(w.directoryWatcher);
}
}
const stringToRegexp = ignored => {
const source = globToRegExp(ignored, {
globstar: !0,
extended: !0
}).source;
return source.slice(0, source.length - 1) + "(?:$|\\/)";
}, ignoredToFunction = ignored => {
if (Array.isArray(ignored)) {
const regexp = new RegExp(ignored.map((i => stringToRegexp(i))).join("|"));
return x => regexp.test(x.replace(/\\/g, "/"));
}
if ("string" == typeof ignored) {
const regexp = new RegExp(stringToRegexp(ignored));
return x => regexp.test(x.replace(/\\/g, "/"));
}
if (ignored instanceof RegExp) return x => ignored.test(x.replace(/\\/g, "/"));
if (ignored instanceof Function) return ignored;
if (ignored) throw new Error(`Invalid option for 'ignored': ${ignored}`);
return () => !1;
}, normalizeCache = new WeakMap, cachedNormalizeOptions = options => {
const cacheEntry = normalizeCache.get(options);
if (void 0 !== cacheEntry) return cacheEntry;
const normalized = (options => ({
followSymlinks: !!options.followSymlinks,
ignored: ignoredToFunction(options.ignored),
poll: options.poll
}))(options);
return normalizeCache.set(options, normalized), normalized;
};
class WatchpackFileWatcher {
constructor(watchpack, watcher, files) {
this.files = Array.isArray(files) ? files : [ files ], this.watcher = watcher, watcher.on("initial-missing", (type => {
for (const file of this.files) watchpack._missing.has(file) || watchpack._onRemove(file, file, type);
})), watcher.on("change", ((mtime, type) => {
for (const file of this.files) watchpack._onChange(file, mtime, file, type);
})), watcher.on("remove", (type => {
for (const file of this.files) watchpack._onRemove(file, file, type);
}));
}
update(files) {
Array.isArray(files) ? this.files = files : 1 !== this.files.length ? this.files = [ files ] : this.files[0] !== files && (this.files[0] = files);
}
close() {
this.watcher.close();
}
}
class WatchpackDirectoryWatcher {
constructor(watchpack, watcher, directories) {
this.directories = Array.isArray(directories) ? directories : [ directories ], this.watcher = watcher, 
watcher.on("initial-missing", (type => {
for (const item of this.directories) watchpack._onRemove(item, item, type);
})), watcher.on("change", ((file, mtime, type) => {
for (const item of this.directories) watchpack._onChange(item, mtime, file, type);
})), watcher.on("remove", (type => {
for (const item of this.directories) watchpack._onRemove(item, item, type);
}));
}
update(directories) {
Array.isArray(directories) ? this.directories = directories : 1 !== this.directories.length ? this.directories = [ directories ] : this.directories[0] !== directories && (this.directories[0] = directories);
}
close() {
this.watcher.close();
}
}
module.exports = class extends EventEmitter {
constructor(options) {
super(), options || (options = EMPTY_OPTIONS), this.options = options, this.aggregateTimeout = "number" == typeof options.aggregateTimeout ? options.aggregateTimeout : 200, 
this.watcherOptions = cachedNormalizeOptions(options), this.watcherManager = getWatcherManager(this.watcherOptions), 
this.fileWatchers = new Map, this.directoryWatchers = new Map, this._missing = new Set, 
this.startTime = void 0, this.paused = !1, this.aggregatedChanges = new Set, this.aggregatedRemovals = new Set, 
this.aggregateTimer = void 0, this._onTimeout = this._onTimeout.bind(this);
}
watch(arg1, arg2, arg3) {
let files, directories, missing, startTime;
arg2 ? (files = arg1, directories = arg2, missing = EMPTY_ARRAY, startTime = arg3) : ({files = EMPTY_ARRAY, directories = EMPTY_ARRAY, missing = EMPTY_ARRAY, startTime} = arg1), 
this.paused = !1;
const fileWatchers = this.fileWatchers, directoryWatchers = this.directoryWatchers, ignored = this.watcherOptions.ignored, filter = path => !ignored(path), addToMap = (map, key, item) => {
const list = map.get(key);
void 0 === list ? map.set(key, item) : Array.isArray(list) ? list.push(item) : map.set(key, [ list, item ]);
}, fileWatchersNeeded = new Map, directoryWatchersNeeded = new Map, missingFiles = new Set;
if (this.watcherOptions.followSymlinks) {
const resolver = new LinkResolver;
for (const file of files) if (filter(file)) for (const innerFile of resolver.resolve(file)) (file === innerFile || filter(innerFile)) && addToMap(fileWatchersNeeded, innerFile, file);
for (const file of missing) if (filter(file)) for (const innerFile of resolver.resolve(file)) (file === innerFile || filter(innerFile)) && (missingFiles.add(file), 
addToMap(fileWatchersNeeded, innerFile, file));
for (const dir of directories) if (filter(dir)) {
let first = !0;
for (const innerItem of resolver.resolve(dir)) filter(innerItem) && addToMap(first ? directoryWatchersNeeded : fileWatchersNeeded, innerItem, dir), 
first = !1;
}
} else {
for (const file of files) filter(file) && addToMap(fileWatchersNeeded, file, file);
for (const file of missing) filter(file) && (missingFiles.add(file), addToMap(fileWatchersNeeded, file, file));
for (const dir of directories) filter(dir) && addToMap(directoryWatchersNeeded, dir, dir);
}
for (const [key, w] of fileWatchers) {
const needed = fileWatchersNeeded.get(key);
void 0 === needed ? (w.close(), fileWatchers.delete(key)) : (w.update(needed), fileWatchersNeeded.delete(key));
}
for (const [key, w] of directoryWatchers) {
const needed = directoryWatchersNeeded.get(key);
void 0 === needed ? (w.close(), directoryWatchers.delete(key)) : (w.update(needed), 
directoryWatchersNeeded.delete(key));
}
watchEventSource.batch((() => {
for (const [key, files] of fileWatchersNeeded) {
const watcher = this.watcherManager.watchFile(key, startTime);
watcher && fileWatchers.set(key, new WatchpackFileWatcher(this, watcher, files));
}
for (const [key, directories] of directoryWatchersNeeded) {
const watcher = this.watcherManager.watchDirectory(key, startTime);
watcher && directoryWatchers.set(key, new WatchpackDirectoryWatcher(this, watcher, directories));
}
})), this._missing = missingFiles, this.startTime = startTime;
}
close() {
this.paused = !0, this.aggregateTimer && clearTimeout(this.aggregateTimer);
for (const w of this.fileWatchers.values()) w.close();
for (const w of this.directoryWatchers.values()) w.close();
this.fileWatchers.clear(), this.directoryWatchers.clear();
}
pause() {
this.paused = !0, this.aggregateTimer && clearTimeout(this.aggregateTimer);
}
getTimes() {
const directoryWatchers = new Set;
addWatchersToSet(this.fileWatchers.values(), directoryWatchers), addWatchersToSet(this.directoryWatchers.values(), directoryWatchers);
const obj = Object.create(null);
for (const w of directoryWatchers) {
const times = w.getTimes();
for (const file of Object.keys(times)) obj[file] = times[file];
}
return obj;
}
getTimeInfoEntries() {
const map = new Map;
return this.collectTimeInfoEntries(map, map), map;
}
collectTimeInfoEntries(fileTimestamps, directoryTimestamps) {
const allWatchers = new Set;
addWatchersToSet(this.fileWatchers.values(), allWatchers), addWatchersToSet(this.directoryWatchers.values(), allWatchers);
const safeTime = {
value: 0
};
for (const w of allWatchers) w.collectTimeInfoEntries(fileTimestamps, directoryTimestamps, safeTime);
}
getAggregated() {
this.aggregateTimer && (clearTimeout(this.aggregateTimer), this.aggregateTimer = void 0);
const changes = this.aggregatedChanges, removals = this.aggregatedRemovals;
return this.aggregatedChanges = new Set, this.aggregatedRemovals = new Set, {
changes,
removals
};
}
_onChange(item, mtime, file, type) {
file = file || item, this.paused || (this.emit("change", file, mtime, type), this.aggregateTimer && clearTimeout(this.aggregateTimer), 
this.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout)), this.aggregatedRemovals.delete(item), 
this.aggregatedChanges.add(item);
}
_onRemove(item, file, type) {
file = file || item, this.paused || (this.emit("remove", file, type), this.aggregateTimer && clearTimeout(this.aggregateTimer), 
this.aggregateTimer = setTimeout(this._onTimeout, this.aggregateTimeout)), this.aggregatedChanges.delete(item), 
this.aggregatedRemovals.add(item);
}
_onTimeout() {
this.aggregateTimer = void 0;
const changes = this.aggregatedChanges, removals = this.aggregatedRemovals;
this.aggregatedChanges = new Set, this.aggregatedRemovals = new Set, this.emit("aggregated", changes, removals);
}
};
},
78830: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Source = __webpack_require__(91468), streamChunksOfSourceMap = __webpack_require__(92013), streamChunksOfRawSource = __webpack_require__(37893), streamAndGetSourceAndMap = __webpack_require__(25773), mapToBufferedMap = map => {
if ("object" != typeof map || !map) return map;
const bufferedMap = Object.assign({}, map);
return map.mappings && (bufferedMap.mappings = Buffer.from(map.mappings, "utf-8")), 
map.sourcesContent && (bufferedMap.sourcesContent = map.sourcesContent.map((str => str && Buffer.from(str, "utf-8")))), 
bufferedMap;
};
module.exports = class extends Source {
constructor(source, cachedData) {
super(), this._source = source, this._cachedSourceType = cachedData ? cachedData.source : void 0, 
this._cachedSource = void 0, this._cachedBuffer = cachedData ? cachedData.buffer : void 0, 
this._cachedSize = cachedData ? cachedData.size : void 0, this._cachedMaps = cachedData ? cachedData.maps : new Map, 
this._cachedHashUpdate = cachedData ? cachedData.hash : void 0;
}
getCachedData() {
const bufferedMaps = new Map;
for (const pair of this._cachedMaps) {
let cacheEntry = pair[1];
void 0 === cacheEntry.bufferedMap && (cacheEntry.bufferedMap = mapToBufferedMap(this._getMapFromCacheEntry(cacheEntry))), 
bufferedMaps.set(pair[0], {
map: void 0,
bufferedMap: cacheEntry.bufferedMap
});
}
return this._cachedSource && this.buffer(), {
buffer: this._cachedBuffer,
source: void 0 !== this._cachedSourceType ? this._cachedSourceType : "string" == typeof this._cachedSource || !Buffer.isBuffer(this._cachedSource) && void 0,
size: this._cachedSize,
maps: bufferedMaps,
hash: this._cachedHashUpdate
};
}
originalLazy() {
return this._source;
}
original() {
return "function" == typeof this._source && (this._source = this._source()), this._source;
}
source() {
const source = this._getCachedSource();
return void 0 !== source ? source : this._cachedSource = this.original().source();
}
_getMapFromCacheEntry(cacheEntry) {
return void 0 !== cacheEntry.map ? cacheEntry.map : void 0 !== cacheEntry.bufferedMap ? cacheEntry.map = (bufferedMap => {
if ("object" != typeof bufferedMap || !bufferedMap) return bufferedMap;
const map = Object.assign({}, bufferedMap);
return bufferedMap.mappings && (map.mappings = bufferedMap.mappings.toString("utf-8")), 
bufferedMap.sourcesContent && (map.sourcesContent = bufferedMap.sourcesContent.map((buffer => buffer && buffer.toString("utf-8")))), 
map;
})(cacheEntry.bufferedMap) : void 0;
}
_getCachedSource() {
return void 0 !== this._cachedSource ? this._cachedSource : this._cachedBuffer && void 0 !== this._cachedSourceType ? this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString("utf-8") : this._cachedBuffer : void 0;
}
buffer() {
if (void 0 !== this._cachedBuffer) return this._cachedBuffer;
if (void 0 !== this._cachedSource) return Buffer.isBuffer(this._cachedSource) ? this._cachedBuffer = this._cachedSource : this._cachedBuffer = Buffer.from(this._cachedSource, "utf-8");
if ("function" == typeof this.original().buffer) return this._cachedBuffer = this.original().buffer();
const bufferOrString = this.source();
return Buffer.isBuffer(bufferOrString) ? this._cachedBuffer = bufferOrString : this._cachedBuffer = Buffer.from(bufferOrString, "utf-8");
}
size() {
if (void 0 !== this._cachedSize) return this._cachedSize;
if (void 0 !== this._cachedBuffer) return this._cachedSize = this._cachedBuffer.length;
const source = this._getCachedSource();
return this._cachedSize = void 0 !== source ? Buffer.byteLength(source) : this.original().size();
}
sourceAndMap(options) {
const key = options ? JSON.stringify(options) : "{}", cacheEntry = this._cachedMaps.get(key);
if (void 0 !== cacheEntry) {
const map = this._getMapFromCacheEntry(cacheEntry);
return {
source: this.source(),
map
};
}
let map, source = this._getCachedSource();
if (void 0 !== source) map = this.original().map(options); else {
const sourceAndMap = this.original().sourceAndMap(options);
source = sourceAndMap.source, map = sourceAndMap.map, this._cachedSource = source;
}
return this._cachedMaps.set(key, {
map,
bufferedMap: void 0
}), {
source,
map
};
}
streamChunks(options, onChunk, onSource, onName) {
const key = options ? JSON.stringify(options) : "{}";
if (this._cachedMaps.has(key) && (void 0 !== this._cachedBuffer || void 0 !== this._cachedSource)) {
const {source, map} = this.sourceAndMap(options);
return map ? streamChunksOfSourceMap(source, map, onChunk, onSource, onName, !(!options || !options.finalSource), !0) : streamChunksOfRawSource(source, onChunk, onSource, onName, !(!options || !options.finalSource));
}
const {result, source, map} = streamAndGetSourceAndMap(this.original(), options, onChunk, onSource, onName);
return this._cachedSource = source, this._cachedMaps.set(key, {
map,
bufferedMap: void 0
}), result;
}
map(options) {
const key = options ? JSON.stringify(options) : "{}", cacheEntry = this._cachedMaps.get(key);
if (void 0 !== cacheEntry) return this._getMapFromCacheEntry(cacheEntry);
const map = this.original().map(options);
return this._cachedMaps.set(key, {
map,
bufferedMap: void 0
}), map;
}
updateHash(hash) {
if (void 0 !== this._cachedHashUpdate) {
for (const item of this._cachedHashUpdate) hash.update(item);
return;
}
const update = [];
let currentString;
const tracker = {
update: item => {
"string" == typeof item && item.length < 10240 ? void 0 === currentString ? currentString = item : (currentString += item, 
currentString.length > 102400 && (update.push(Buffer.from(currentString)), currentString = void 0)) : (void 0 !== currentString && (update.push(Buffer.from(currentString)), 
currentString = void 0), update.push(item));
}
};
this.original().updateHash(tracker), void 0 !== currentString && update.push(Buffer.from(currentString));
for (const item of update) hash.update(item);
this._cachedHashUpdate = update;
}
};
},
39553: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Source = __webpack_require__(91468);
class CompatSource extends Source {
static from(sourceLike) {
return sourceLike instanceof Source ? sourceLike : new CompatSource(sourceLike);
}
constructor(sourceLike) {
super(), this._sourceLike = sourceLike;
}
source() {
return this._sourceLike.source();
}
buffer() {
return "function" == typeof this._sourceLike.buffer ? this._sourceLike.buffer() : super.buffer();
}
size() {
return "function" == typeof this._sourceLike.size ? this._sourceLike.size() : super.size();
}
map(options) {
return "function" == typeof this._sourceLike.map ? this._sourceLike.map(options) : super.map(options);
}
sourceAndMap(options) {
return "function" == typeof this._sourceLike.sourceAndMap ? this._sourceLike.sourceAndMap(options) : super.sourceAndMap(options);
}
updateHash(hash) {
if ("function" == typeof this._sourceLike.updateHash) return this._sourceLike.updateHash(hash);
if ("function" == typeof this._sourceLike.map) throw new Error("A Source-like object with a 'map' method must also provide an 'updateHash' method");
hash.update(this.buffer());
}
}
module.exports = CompatSource;
},
91344: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Source = __webpack_require__(91468), RawSource = __webpack_require__(56331), streamChunks = __webpack_require__(26870), {getMap, getSourceAndMap} = __webpack_require__(46568), stringsAsRawSources = new WeakSet;
class ConcatSource extends Source {
constructor() {
super(), this._children = [];
for (let i = 0; i < arguments.length; i++) {
const item = arguments[i];
if (item instanceof ConcatSource) for (const child of item._children) this._children.push(child); else this._children.push(item);
}
this._isOptimized = 0 === arguments.length;
}
getChildren() {
return this._isOptimized || this._optimize(), this._children;
}
add(item) {
if (item instanceof ConcatSource) for (const child of item._children) this._children.push(child); else this._children.push(item);
this._isOptimized = !1;
}
addAllSkipOptimizing(items) {
for (const item of items) this._children.push(item);
}
buffer() {
this._isOptimized || this._optimize();
const buffers = [];
for (const child of this._children) if ("function" == typeof child.buffer) buffers.push(child.buffer()); else {
const bufferOrString = child.source();
Buffer.isBuffer(bufferOrString) ? buffers.push(bufferOrString) : buffers.push(Buffer.from(bufferOrString, "utf-8"));
}
return Buffer.concat(buffers);
}
source() {
this._isOptimized || this._optimize();
let source = "";
for (const child of this._children) source += child.source();
return source;
}
size() {
this._isOptimized || this._optimize();
let size = 0;
for (const child of this._children) size += child.size();
return size;
}
map(options) {
return getMap(this, options);
}
sourceAndMap(options) {
return getSourceAndMap(this, options);
}
streamChunks(options, onChunk, onSource, onName) {
if (this._isOptimized || this._optimize(), 1 === this._children.length) return this._children[0].streamChunks(options, onChunk, onSource, onName);
let currentLineOffset = 0, currentColumnOffset = 0, sourceMapping = new Map, nameMapping = new Map;
const finalSource = !(!options || !options.finalSource);
let code = "", needToCloseMapping = !1;
for (const item of this._children) {
const sourceIndexMapping = [], nameIndexMapping = [];
let lastMappingLine = 0;
const {generatedLine, generatedColumn, source} = streamChunks(item, options, ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
const line = generatedLine + currentLineOffset, column = 1 === generatedLine ? generatedColumn + currentColumnOffset : generatedColumn;
needToCloseMapping && (1 === generatedLine && 0 === generatedColumn || onChunk(void 0, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1), 
needToCloseMapping = !1);
const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex], resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];
lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine, finalSource ? (void 0 !== chunk && (code += chunk), 
resultSourceIndex >= 0 && onChunk(void 0, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex)) : resultSourceIndex < 0 ? onChunk(chunk, line, column, -1, -1, -1, -1) : onChunk(chunk, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);
}), ((i, source, sourceContent) => {
let globalIndex = sourceMapping.get(source);
void 0 === globalIndex && (sourceMapping.set(source, globalIndex = sourceMapping.size), 
onSource(globalIndex, source, sourceContent)), sourceIndexMapping[i] = globalIndex;
}), ((i, name) => {
let globalIndex = nameMapping.get(name);
void 0 === globalIndex && (nameMapping.set(name, globalIndex = nameMapping.size), 
onName(globalIndex, name)), nameIndexMapping[i] = globalIndex;
}));
void 0 !== source && (code += source), needToCloseMapping && (1 === generatedLine && 0 === generatedColumn || (onChunk(void 0, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1), 
needToCloseMapping = !1)), generatedLine > 1 ? currentColumnOffset = generatedColumn : currentColumnOffset += generatedColumn, 
needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine, 
currentLineOffset += generatedLine - 1;
}
return {
generatedLine: currentLineOffset + 1,
generatedColumn: currentColumnOffset,
source: finalSource ? code : void 0
};
}
updateHash(hash) {
this._isOptimized || this._optimize(), hash.update("ConcatSource");
for (const item of this._children) item.updateHash(hash);
}
_optimize() {
const newChildren = [];
let currentString, currentRawSources;
const addStringToRawSources = string => {
void 0 === currentRawSources ? currentRawSources = string : Array.isArray(currentRawSources) ? currentRawSources.push(string) : currentRawSources = [ "string" == typeof currentRawSources ? currentRawSources : currentRawSources.source(), string ];
}, mergeRawSources = () => {
if (Array.isArray(currentRawSources)) {
const rawSource = new RawSource(currentRawSources.join(""));
stringsAsRawSources.add(rawSource), newChildren.push(rawSource);
} else if ("string" == typeof currentRawSources) {
const rawSource = new RawSource(currentRawSources);
stringsAsRawSources.add(rawSource), newChildren.push(rawSource);
} else newChildren.push(currentRawSources);
};
for (const child of this._children) "string" == typeof child ? void 0 === currentString ? currentString = child : currentString += child : (void 0 !== currentString && (addStringToRawSources(currentString), 
currentString = void 0), stringsAsRawSources.has(child) ? (source = child, void 0 === currentRawSources ? currentRawSources = source : Array.isArray(currentRawSources) ? currentRawSources.push(source.source()) : currentRawSources = [ "string" == typeof currentRawSources ? currentRawSources : currentRawSources.source(), source.source() ]) : (void 0 !== currentRawSources && (mergeRawSources(), 
currentRawSources = void 0), newChildren.push(child)));
var source;
void 0 !== currentString && addStringToRawSources(currentString), void 0 !== currentRawSources && mergeRawSources(), 
this._children = newChildren, this._isOptimized = !0;
}
}
module.exports = ConcatSource;
},
61906: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {getMap, getSourceAndMap} = __webpack_require__(46568), splitIntoLines = __webpack_require__(53069), getGeneratedSourceInfo = __webpack_require__(78498), Source = __webpack_require__(91468), splitIntoPotentialTokens = __webpack_require__(66342);
module.exports = class extends Source {
constructor(value, name) {
super();
const isBuffer = Buffer.isBuffer(value);
this._value = isBuffer ? void 0 : value, this._valueAsBuffer = isBuffer ? value : void 0, 
this._name = name;
}
getName() {
return this._name;
}
source() {
return void 0 === this._value && (this._value = this._valueAsBuffer.toString("utf-8")), 
this._value;
}
buffer() {
return void 0 === this._valueAsBuffer && (this._valueAsBuffer = Buffer.from(this._value, "utf-8")), 
this._valueAsBuffer;
}
map(options) {
return getMap(this, options);
}
sourceAndMap(options) {
return getSourceAndMap(this, options);
}
streamChunks(options, onChunk, onSource, onName) {
void 0 === this._value && (this._value = this._valueAsBuffer.toString("utf-8")), 
onSource(0, this._name, this._value);
const finalSource = !(!options || !options.finalSource);
if (options && !1 === options.columns) {
if (finalSource) {
const result = getGeneratedSourceInfo(this._value), {generatedLine, generatedColumn} = result;
if (0 === generatedColumn) for (let line = 1; line < generatedLine; line++) onChunk(void 0, line, 0, 0, line, 0, -1); else for (let line = 1; line <= generatedLine; line++) onChunk(void 0, line, 0, 0, line, 0, -1);
return result;
}
{
let line = 1;
const matches = splitIntoLines(this._value);
let match;
for (match of matches) onChunk(finalSource ? void 0 : match, line, 0, 0, line, 0, -1), 
line++;
return 0 === matches.length || match.endsWith("\n") ? {
generatedLine: matches.length + 1,
generatedColumn: 0,
source: finalSource ? this._value : void 0
} : {
generatedLine: matches.length,
generatedColumn: match.length,
source: finalSource ? this._value : void 0
};
}
}
{
const matches = splitIntoPotentialTokens(this._value);
let line = 1, column = 0;
if (null !== matches) for (const match of matches) {
const isEndOfLine = match.endsWith("\n");
if (isEndOfLine && 1 === match.length) finalSource || onChunk(match, line, column, -1, -1, -1, -1); else {
onChunk(finalSource ? void 0 : match, line, column, 0, line, column, -1);
}
isEndOfLine ? (line++, column = 0) : column += match.length;
}
return {
generatedLine: line,
generatedColumn: column,
source: finalSource ? this._value : void 0
};
}
}
updateHash(hash) {
void 0 === this._valueAsBuffer && (this._valueAsBuffer = Buffer.from(this._value, "utf-8")), 
hash.update("OriginalSource"), hash.update(this._valueAsBuffer), hash.update(this._name || "");
}
};
},
91721: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Source = __webpack_require__(91468), RawSource = __webpack_require__(56331), streamChunks = __webpack_require__(26870), {getMap, getSourceAndMap} = __webpack_require__(46568), REPLACE_REGEX = /\n(?=.|\s)/g;
module.exports = class extends Source {
constructor(prefix, source) {
super(), this._source = "string" == typeof source || Buffer.isBuffer(source) ? new RawSource(source, !0) : source, 
this._prefix = prefix;
}
getPrefix() {
return this._prefix;
}
original() {
return this._source;
}
source() {
const node = this._source.source(), prefix = this._prefix;
return prefix + node.replace(REPLACE_REGEX, "\n" + prefix);
}
map(options) {
return getMap(this, options);
}
sourceAndMap(options) {
return getSourceAndMap(this, options);
}
streamChunks(options, onChunk, onSource, onName) {
const prefix = this._prefix, prefixOffset = prefix.length, linesOnly = !(!options || !1 !== options.columns), {generatedLine, generatedColumn, source} = streamChunks(this._source, options, ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
0 !== generatedColumn ? generatedColumn += prefixOffset : void 0 !== chunk ? linesOnly || sourceIndex < 0 ? chunk = prefix + chunk : prefixOffset > 0 && (onChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1), 
generatedColumn += prefixOffset) : linesOnly || (generatedColumn += prefixOffset), 
onChunk(chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);
}), onSource, onName);
return {
generatedLine,
generatedColumn: 0 === generatedColumn ? 0 : prefixOffset + generatedColumn,
source: void 0 !== source ? prefix + source.replace(REPLACE_REGEX, "\n" + prefix) : void 0
};
}
updateHash(hash) {
hash.update("PrefixSource"), this._source.updateHash(hash), hash.update(this._prefix);
}
};
},
56331: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const streamChunksOfRawSource = __webpack_require__(37893), Source = __webpack_require__(91468);
module.exports = class extends Source {
constructor(value, convertToString = !1) {
super();
const isBuffer = Buffer.isBuffer(value);
if (!isBuffer && "string" != typeof value) throw new TypeError("argument 'value' must be either string of Buffer");
this._valueIsBuffer = !convertToString && isBuffer, this._value = convertToString && isBuffer ? void 0 : value, 
this._valueAsBuffer = isBuffer ? value : void 0, this._valueAsString = isBuffer ? void 0 : value;
}
isBuffer() {
return this._valueIsBuffer;
}
source() {
return void 0 === this._value && (this._value = this._valueAsBuffer.toString("utf-8")), 
this._value;
}
buffer() {
return void 0 === this._valueAsBuffer && (this._valueAsBuffer = Buffer.from(this._value, "utf-8")), 
this._valueAsBuffer;
}
map(options) {
return null;
}
streamChunks(options, onChunk, onSource, onName) {
return void 0 === this._value && (this._value = Buffer.from(this._valueAsBuffer, "utf-8")), 
void 0 === this._valueAsString && (this._valueAsString = "string" == typeof this._value ? this._value : this._value.toString("utf-8")), 
streamChunksOfRawSource(this._valueAsString, onChunk, onSource, onName, !(!options || !options.finalSource));
}
updateHash(hash) {
void 0 === this._valueAsBuffer && (this._valueAsBuffer = Buffer.from(this._value, "utf-8")), 
hash.update("RawSource"), hash.update(this._valueAsBuffer);
}
};
},
21846: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {getMap, getSourceAndMap} = __webpack_require__(46568), streamChunks = __webpack_require__(26870), Source = __webpack_require__(91468), splitIntoLines = __webpack_require__(53069), hasStableSort = "object" == typeof process && process.versions && "string" == typeof process.versions.v8 && !/^[0-6]\./.test(process.versions.v8);
class Replacement {
constructor(start, end, content, name) {
this.start = start, this.end = end, this.content = content, this.name = name, hasStableSort || (this.index = -1);
}
}
module.exports = class extends Source {
constructor(source, name) {
super(), this._source = source, this._name = name, this._replacements = [], this._isSorted = !0;
}
getName() {
return this._name;
}
getReplacements() {
return this._sortReplacements(), this._replacements;
}
replace(start, end, newValue, name) {
if ("string" != typeof newValue) throw new Error("insertion must be a string, but is a " + typeof newValue);
this._replacements.push(new Replacement(start, end, newValue, name)), this._isSorted = !1;
}
insert(pos, newValue, name) {
if ("string" != typeof newValue) throw new Error("insertion must be a string, but is a " + typeof newValue + ": " + newValue);
this._replacements.push(new Replacement(pos, pos - 1, newValue, name)), this._isSorted = !1;
}
source() {
if (0 === this._replacements.length) return this._source.source();
let current = this._source.source(), pos = 0;
const result = [];
this._sortReplacements();
for (const replacement of this._replacements) {
const start = Math.floor(replacement.start), end = Math.floor(replacement.end + 1);
if (pos < start) {
const offset = start - pos;
result.push(current.slice(0, offset)), current = current.slice(offset), pos = start;
}
if (result.push(replacement.content), pos < end) {
const offset = end - pos;
current = current.slice(offset), pos = end;
}
}
return result.push(current), result.join("");
}
map(options) {
return 0 === this._replacements.length ? this._source.map(options) : getMap(this, options);
}
sourceAndMap(options) {
return 0 === this._replacements.length ? this._source.sourceAndMap(options) : getSourceAndMap(this, options);
}
original() {
return this._source;
}
_sortReplacements() {
this._isSorted || (hasStableSort ? this._replacements.sort((function(a, b) {
const diff1 = a.start - b.start;
if (0 !== diff1) return diff1;
const diff2 = a.end - b.end;
return 0 !== diff2 ? diff2 : 0;
})) : (this._replacements.forEach(((repl, i) => repl.index = i)), this._replacements.sort((function(a, b) {
const diff1 = a.start - b.start;
if (0 !== diff1) return diff1;
const diff2 = a.end - b.end;
return 0 !== diff2 ? diff2 : a.index - b.index;
}))), this._isSorted = !0);
}
streamChunks(options, onChunk, onSource, onName) {
this._sortReplacements();
const repls = this._replacements;
let pos = 0, i = 0, replacmentEnd = -1, nextReplacement = i < repls.length ? Math.floor(repls[i].start) : 536870912, generatedLineOffset = 0, generatedColumnOffset = 0, generatedColumnOffsetLine = 0;
const sourceContents = [], nameMapping = new Map, nameIndexMapping = [], checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {
let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : void 0;
if (void 0 === content) return !1;
"string" == typeof content && (content = splitIntoLines(content), sourceContents[sourceIndex] = content);
const contentLine = line <= content.length ? content[line - 1] : null;
return null !== contentLine && contentLine.slice(column, column + expectedChunk.length) === expectedChunk;
};
let {generatedLine, generatedColumn} = streamChunks(this._source, Object.assign({}, options, {
finalSource: !1
}), ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
let chunkPos = 0, endPos = pos + chunk.length;
if (replacmentEnd > pos) {
if (replacmentEnd >= endPos) {
const line = generatedLine + generatedLineOffset;
return chunk.endsWith("\n") ? (generatedLineOffset--, generatedColumnOffsetLine === line && (generatedColumnOffset += generatedColumn)) : generatedColumnOffsetLine === line ? generatedColumnOffset -= chunk.length : (generatedColumnOffset = -chunk.length, 
generatedColumnOffsetLine = line), void (pos = endPos);
}
chunkPos = replacmentEnd - pos, checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos)) && (originalColumn += chunkPos), 
pos += chunkPos;
const line = generatedLine + generatedLineOffset;
generatedColumnOffsetLine === line ? generatedColumnOffset -= chunkPos : (generatedColumnOffset = -chunkPos, 
generatedColumnOffsetLine = line), generatedColumn += chunkPos;
}
if (nextReplacement < endPos) do {
let line = generatedLine + generatedLineOffset;
if (nextReplacement > pos) {
const offset = nextReplacement - pos, chunkSlice = chunk.slice(chunkPos, chunkPos + offset);
onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]), 
generatedColumn += offset, chunkPos += offset, pos = nextReplacement, checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice) && (originalColumn += chunkSlice.length);
}
const {content, name} = repls[i];
let matches = splitIntoLines(content), replacementNameIndex = nameIndex;
if (sourceIndex >= 0 && name) {
let globalIndex = nameMapping.get(name);
void 0 === globalIndex && (globalIndex = nameMapping.size, nameMapping.set(name, globalIndex), 
onName(globalIndex, name)), replacementNameIndex = globalIndex;
}
for (let m = 0; m < matches.length; m++) {
const contentLine = matches[m];
onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex), 
replacementNameIndex = -1, m !== matches.length - 1 || contentLine.endsWith("\n") ? (generatedLineOffset++, 
line++, generatedColumnOffset = -generatedColumn, generatedColumnOffsetLine = line) : generatedColumnOffsetLine === line ? generatedColumnOffset += contentLine.length : (generatedColumnOffset = contentLine.length, 
generatedColumnOffsetLine = line);
}
replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1)), i++, nextReplacement = i < repls.length ? Math.floor(repls[i].start) : 536870912;
const offset = chunk.length - endPos + replacmentEnd - chunkPos;
if (offset > 0) {
if (replacmentEnd >= endPos) {
let line = generatedLine + generatedLineOffset;
return chunk.endsWith("\n") ? (generatedLineOffset--, generatedColumnOffsetLine === line && (generatedColumnOffset += generatedColumn)) : generatedColumnOffsetLine === line ? generatedColumnOffset -= chunk.length - chunkPos : (generatedColumnOffset = chunkPos - chunk.length, 
generatedColumnOffsetLine = line), void (pos = endPos);
}
const line = generatedLine + generatedLineOffset;
checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset)) && (originalColumn += offset), 
chunkPos += offset, pos += offset, generatedColumnOffsetLine === line ? generatedColumnOffset -= offset : (generatedColumnOffset = -offset, 
generatedColumnOffsetLine = line), generatedColumn += offset;
}
} while (nextReplacement < endPos);
if (chunkPos < chunk.length) {
const chunkSlice = 0 === chunkPos ? chunk : chunk.slice(chunkPos), line = generatedLine + generatedLineOffset;
onChunk(chunkSlice, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);
}
pos = endPos;
}), ((sourceIndex, source, sourceContent) => {
for (;sourceContents.length < sourceIndex; ) sourceContents.push(void 0);
sourceContents[sourceIndex] = sourceContent, onSource(sourceIndex, source, sourceContent);
}), ((nameIndex, name) => {
let globalIndex = nameMapping.get(name);
void 0 === globalIndex && (globalIndex = nameMapping.size, nameMapping.set(name, globalIndex), 
onName(globalIndex, name)), nameIndexMapping[nameIndex] = globalIndex;
})), remainer = "";
for (;i < repls.length; i++) remainer += repls[i].content;
let line = generatedLine + generatedLineOffset, matches = splitIntoLines(remainer);
for (let m = 0; m < matches.length; m++) {
const contentLine = matches[m];
onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1), 
m !== matches.length - 1 || contentLine.endsWith("\n") ? (generatedLineOffset++, 
line++, generatedColumnOffset = -generatedColumn, generatedColumnOffsetLine = line) : generatedColumnOffsetLine === line ? generatedColumnOffset += contentLine.length : (generatedColumnOffset = contentLine.length, 
generatedColumnOffsetLine = line);
}
return {
generatedLine: line,
generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)
};
}
updateHash(hash) {
this._sortReplacements(), hash.update("ReplaceSource"), this._source.updateHash(hash), 
hash.update(this._name || "");
for (const repl of this._replacements) hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);
}
};
},
11920: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Source = __webpack_require__(91468);
module.exports = class extends Source {
constructor(size) {
super(), this._size = size;
}
_error() {
return new Error("Content and Map of this Source is not available (only size() is supported)");
}
size() {
return this._size;
}
source() {
throw this._error();
}
buffer() {
throw this._error();
}
map(options) {
throw this._error();
}
updateHash() {
throw this._error();
}
};
},
91468: module => {
"use strict";
module.exports = class {
source() {
throw new Error("Abstract");
}
buffer() {
const source = this.source();
return Buffer.isBuffer(source) ? source : Buffer.from(source, "utf-8");
}
size() {
return this.buffer().length;
}
map(options) {
return null;
}
sourceAndMap(options) {
return {
source: this.source(),
map: this.map(options)
};
}
updateHash(hash) {
throw new Error("Abstract");
}
};
},
9972: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Source = __webpack_require__(91468), streamChunksOfSourceMap = __webpack_require__(92013), streamChunksOfCombinedSourceMap = __webpack_require__(82470), {getMap, getSourceAndMap} = __webpack_require__(46568);
module.exports = class extends Source {
constructor(value, name, sourceMap, originalSource, innerSourceMap, removeOriginalSource) {
super();
const valueIsBuffer = Buffer.isBuffer(value);
this._valueAsString = valueIsBuffer ? void 0 : value, this._valueAsBuffer = valueIsBuffer ? value : void 0, 
this._name = name, this._hasSourceMap = !!sourceMap;
const sourceMapIsBuffer = Buffer.isBuffer(sourceMap), sourceMapIsString = "string" == typeof sourceMap;
this._sourceMapAsObject = sourceMapIsBuffer || sourceMapIsString ? void 0 : sourceMap, 
this._sourceMapAsString = sourceMapIsString ? sourceMap : void 0, this._sourceMapAsBuffer = sourceMapIsBuffer ? sourceMap : void 0, 
this._hasOriginalSource = !!originalSource;
const originalSourceIsBuffer = Buffer.isBuffer(originalSource);
this._originalSourceAsString = originalSourceIsBuffer ? void 0 : originalSource, 
this._originalSourceAsBuffer = originalSourceIsBuffer ? originalSource : void 0, 
this._hasInnerSourceMap = !!innerSourceMap;
const innerSourceMapIsBuffer = Buffer.isBuffer(innerSourceMap), innerSourceMapIsString = "string" == typeof innerSourceMap;
this._innerSourceMapAsObject = innerSourceMapIsBuffer || innerSourceMapIsString ? void 0 : innerSourceMap, 
this._innerSourceMapAsString = innerSourceMapIsString ? innerSourceMap : void 0, 
this._innerSourceMapAsBuffer = innerSourceMapIsBuffer ? innerSourceMap : void 0, 
this._removeOriginalSource = removeOriginalSource;
}
_ensureValueBuffer() {
void 0 === this._valueAsBuffer && (this._valueAsBuffer = Buffer.from(this._valueAsString, "utf-8"));
}
_ensureValueString() {
void 0 === this._valueAsString && (this._valueAsString = this._valueAsBuffer.toString("utf-8"));
}
_ensureOriginalSourceBuffer() {
void 0 === this._originalSourceAsBuffer && this._hasOriginalSource && (this._originalSourceAsBuffer = Buffer.from(this._originalSourceAsString, "utf-8"));
}
_ensureOriginalSourceString() {
void 0 === this._originalSourceAsString && this._hasOriginalSource && (this._originalSourceAsString = this._originalSourceAsBuffer.toString("utf-8"));
}
_ensureInnerSourceMapObject() {
void 0 === this._innerSourceMapAsObject && this._hasInnerSourceMap && (this._ensureInnerSourceMapString(), 
this._innerSourceMapAsObject = JSON.parse(this._innerSourceMapAsString));
}
_ensureInnerSourceMapBuffer() {
void 0 === this._innerSourceMapAsBuffer && this._hasInnerSourceMap && (this._ensureInnerSourceMapString(), 
this._innerSourceMapAsBuffer = Buffer.from(this._innerSourceMapAsString, "utf-8"));
}
_ensureInnerSourceMapString() {
void 0 === this._innerSourceMapAsString && this._hasInnerSourceMap && (void 0 !== this._innerSourceMapAsBuffer ? this._innerSourceMapAsString = this._innerSourceMapAsBuffer.toString("utf-8") : this._innerSourceMapAsString = JSON.stringify(this._innerSourceMapAsObject));
}
_ensureSourceMapObject() {
void 0 === this._sourceMapAsObject && (this._ensureSourceMapString(), this._sourceMapAsObject = JSON.parse(this._sourceMapAsString));
}
_ensureSourceMapBuffer() {
void 0 === this._sourceMapAsBuffer && (this._ensureSourceMapString(), this._sourceMapAsBuffer = Buffer.from(this._sourceMapAsString, "utf-8"));
}
_ensureSourceMapString() {
void 0 === this._sourceMapAsString && (void 0 !== this._sourceMapAsBuffer ? this._sourceMapAsString = this._sourceMapAsBuffer.toString("utf-8") : this._sourceMapAsString = JSON.stringify(this._sourceMapAsObject));
}
getArgsAsBuffers() {
return this._ensureValueBuffer(), this._ensureSourceMapBuffer(), this._ensureOriginalSourceBuffer(), 
this._ensureInnerSourceMapBuffer(), [ this._valueAsBuffer, this._name, this._sourceMapAsBuffer, this._originalSourceAsBuffer, this._innerSourceMapAsBuffer, this._removeOriginalSource ];
}
buffer() {
return this._ensureValueBuffer(), this._valueAsBuffer;
}
source() {
return this._ensureValueString(), this._valueAsString;
}
map(options) {
return this._hasInnerSourceMap ? getMap(this, options) : (this._ensureSourceMapObject(), 
this._sourceMapAsObject);
}
sourceAndMap(options) {
return this._hasInnerSourceMap ? getSourceAndMap(this, options) : (this._ensureValueString(), 
this._ensureSourceMapObject(), {
source: this._valueAsString,
map: this._sourceMapAsObject
});
}
streamChunks(options, onChunk, onSource, onName) {
return this._ensureValueString(), this._ensureSourceMapObject(), this._ensureOriginalSourceString(), 
this._hasInnerSourceMap ? (this._ensureInnerSourceMapObject(), streamChunksOfCombinedSourceMap(this._valueAsString, this._sourceMapAsObject, this._name, this._originalSourceAsString, this._innerSourceMapAsObject, this._removeOriginalSource, onChunk, onSource, onName, !(!options || !options.finalSource), !(!options || !1 === options.columns))) : streamChunksOfSourceMap(this._valueAsString, this._sourceMapAsObject, onChunk, onSource, onName, !(!options || !options.finalSource), !(!options || !1 === options.columns));
}
updateHash(hash) {
this._ensureValueBuffer(), this._ensureSourceMapBuffer(), this._ensureOriginalSourceBuffer(), 
this._ensureInnerSourceMapBuffer(), hash.update("SourceMapSource"), hash.update(this._valueAsBuffer), 
hash.update(this._sourceMapAsBuffer), this._hasOriginalSource && hash.update(this._originalSourceAsBuffer), 
this._hasInnerSourceMap && hash.update(this._innerSourceMapAsBuffer), hash.update(this._removeOriginalSource ? "true" : "false");
}
};
},
49287: module => {
"use strict";
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), createFullMappingsSerializer = () => {
let currentLine = 1, currentColumn = 0, currentSourceIndex = 0, currentOriginalLine = 1, currentOriginalColumn = 0, currentNameIndex = 0, activeMapping = !1, activeName = !1, initial = !0;
return (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
if (activeMapping && currentLine === generatedLine) {
if (sourceIndex === currentSourceIndex && originalLine === currentOriginalLine && originalColumn === currentOriginalColumn && !activeName && nameIndex < 0) return "";
} else if (sourceIndex < 0) return "";
let str;
currentLine < generatedLine ? (str = ";".repeat(generatedLine - currentLine), currentLine = generatedLine, 
currentColumn = 0, initial = !1) : initial ? (str = "", initial = !1) : str = ",";
const writeValue = value => {
const mask = value >> 31;
let data = (value + mask ^ mask) << 1 | value >>> 31 & 1;
for (;;) {
const sextet = 31 & data;
if (data >>= 5, 0 === data) {
str += ALPHABET[sextet];
break;
}
str += ALPHABET[32 | sextet];
}
};
return writeValue(generatedColumn - currentColumn), currentColumn = generatedColumn, 
sourceIndex >= 0 ? (activeMapping = !0, sourceIndex === currentSourceIndex ? str += "A" : (writeValue(sourceIndex - currentSourceIndex), 
currentSourceIndex = sourceIndex), writeValue(originalLine - currentOriginalLine), 
currentOriginalLine = originalLine, originalColumn === currentOriginalColumn ? str += "A" : (writeValue(originalColumn - currentOriginalColumn), 
currentOriginalColumn = originalColumn), nameIndex >= 0 ? (writeValue(nameIndex - currentNameIndex), 
currentNameIndex = nameIndex, activeName = !0) : activeName = !1) : activeMapping = !1, 
str;
};
}, createLinesOnlyMappingsSerializer = () => {
let lastWrittenLine = 0, currentLine = 1, currentSourceIndex = 0, currentOriginalLine = 1;
return (generatedLine, _generatedColumn, sourceIndex, originalLine, _originalColumn, _nameIndex) => {
if (sourceIndex < 0) return "";
if (lastWrittenLine === generatedLine) return "";
let str;
const writeValue = value => {
const mask = value >> 31;
let data = (value + mask ^ mask) << 1 | value >>> 31 & 1;
for (;;) {
const sextet = 31 & data;
if (data >>= 5, 0 === data) {
str += ALPHABET[sextet];
break;
}
str += ALPHABET[32 | sextet];
}
};
return lastWrittenLine = generatedLine, generatedLine === currentLine + 1 ? (currentLine = generatedLine, 
sourceIndex === currentSourceIndex ? (currentSourceIndex = sourceIndex, originalLine === currentOriginalLine + 1 ? (currentOriginalLine = originalLine, 
";AACA") : (str = ";AA", writeValue(originalLine - currentOriginalLine), currentOriginalLine = originalLine, 
str + "A")) : (str = ";A", writeValue(sourceIndex - currentSourceIndex), currentSourceIndex = sourceIndex, 
writeValue(originalLine - currentOriginalLine), currentOriginalLine = originalLine, 
str + "A")) : (str = ";".repeat(generatedLine - currentLine), currentLine = generatedLine, 
sourceIndex === currentSourceIndex ? (currentSourceIndex = sourceIndex, originalLine === currentOriginalLine + 1 ? (currentOriginalLine = originalLine, 
str + "AACA") : (str += "AA", writeValue(originalLine - currentOriginalLine), currentOriginalLine = originalLine, 
str + "A")) : (str += "A", writeValue(sourceIndex - currentSourceIndex), currentSourceIndex = sourceIndex, 
writeValue(originalLine - currentOriginalLine), currentOriginalLine = originalLine, 
str + "A"));
};
};
module.exports = options => options && !1 === options.columns ? createLinesOnlyMappingsSerializer() : createFullMappingsSerializer();
},
46568: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const createMappingsSerializer = __webpack_require__(49287);
exports.getSourceAndMap = (inputSource, options) => {
let code = "", mappings = "", sources = [], sourcesContent = [], names = [];
const addMapping = createMappingsSerializer(options), {source} = inputSource.streamChunks(Object.assign({}, options, {
finalSource: !0
}), ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
void 0 !== chunk && (code += chunk), mappings += addMapping(generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);
}), ((sourceIndex, source, sourceContent) => {
for (;sources.length < sourceIndex; ) sources.push(null);
if (sources[sourceIndex] = source, void 0 !== sourceContent) {
for (;sourcesContent.length < sourceIndex; ) sourcesContent.push(null);
sourcesContent[sourceIndex] = sourceContent;
}
}), ((nameIndex, name) => {
for (;names.length < nameIndex; ) names.push(null);
names[nameIndex] = name;
}));
return {
source: void 0 !== source ? source : code,
map: mappings.length > 0 ? {
version: 3,
file: "x",
mappings,
sources,
sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
names
} : null
};
}, exports.getMap = (source, options) => {
let mappings = "", sources = [], sourcesContent = [], names = [];
const addMapping = createMappingsSerializer(options);
return source.streamChunks(Object.assign({}, options, {
source: !1,
finalSource: !0
}), ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
mappings += addMapping(generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);
}), ((sourceIndex, source, sourceContent) => {
for (;sources.length < sourceIndex; ) sources.push(null);
if (sources[sourceIndex] = source, void 0 !== sourceContent) {
for (;sourcesContent.length < sourceIndex; ) sourcesContent.push(null);
sourcesContent[sourceIndex] = sourceContent;
}
}), ((nameIndex, name) => {
for (;names.length < nameIndex; ) names.push(null);
names[nameIndex] = name;
})), mappings.length > 0 ? {
version: 3,
file: "x",
mappings,
sources,
sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
names
} : null;
};
},
78498: module => {
"use strict";
const CHAR_CODE_NEW_LINE = "\n".charCodeAt(0);
module.exports = source => {
if (void 0 === source) return {};
const lastLineStart = source.lastIndexOf("\n");
if (-1 === lastLineStart) return {
generatedLine: 1,
generatedColumn: source.length,
source
};
let generatedLine = 2;
for (let i = 0; i < lastLineStart; i++) source.charCodeAt(i) === CHAR_CODE_NEW_LINE && generatedLine++;
return {
generatedLine,
generatedColumn: source.length - lastLineStart - 1,
source
};
};
},
99988: module => {
"use strict";
module.exports = (sourceMap, index) => {
if (index < 0) return null;
const {sourceRoot, sources} = sourceMap, source = sources[index];
return sourceRoot ? sourceRoot.endsWith("/") ? sourceRoot + source : sourceRoot + "/" + source : source;
};
},
92908: module => {
"use strict";
const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ccToValue = new Uint8Array("z".charCodeAt(0) + 1);
ccToValue.fill(66);
for (let i = 0; i < ALPHABET.length; i++) ccToValue[ALPHABET.charCodeAt(i)] = i;
ccToValue[",".charCodeAt(0)] = 64, ccToValue[";".charCodeAt(0)] = 65;
const ccMax = ccToValue.length - 1;
module.exports = (mappings, onMapping) => {
const currentData = new Uint32Array([ 0, 0, 1, 0, 0 ]);
let currentDataPos = 0, currentValue = 0, currentValuePos = 0, generatedLine = 1, generatedColumn = -1;
for (let i = 0; i < mappings.length; i++) {
const cc = mappings.charCodeAt(i);
if (cc > ccMax) continue;
const value = ccToValue[cc];
if (0 != (64 & value)) currentData[0] > generatedColumn && (1 === currentDataPos ? onMapping(generatedLine, currentData[0], -1, -1, -1, -1) : 4 === currentDataPos ? onMapping(generatedLine, currentData[0], currentData[1], currentData[2], currentData[3], -1) : 5 === currentDataPos && onMapping(generatedLine, currentData[0], currentData[1], currentData[2], currentData[3], currentData[4]), 
generatedColumn = currentData[0]), currentDataPos = 0, 65 === value && (generatedLine++, 
currentData[0] = 0, generatedColumn = -1); else if (0 == (32 & value)) {
currentValue |= value << currentValuePos;
const finalValue = 1 & currentValue ? -(currentValue >> 1) : currentValue >> 1;
currentData[currentDataPos++] += finalValue, currentValuePos = 0, currentValue = 0;
} else currentValue |= (31 & value) << currentValuePos, currentValuePos += 5;
}
1 === currentDataPos ? onMapping(generatedLine, currentData[0], -1, -1, -1, -1) : 4 === currentDataPos ? onMapping(generatedLine, currentData[0], currentData[1], currentData[2], currentData[3], -1) : 5 === currentDataPos && onMapping(generatedLine, currentData[0], currentData[1], currentData[2], currentData[3], currentData[4]);
};
},
53069: module => {
module.exports = str => {
const results = [], len = str.length;
let i = 0;
for (;i < len; ) {
if (10 === str.charCodeAt(i)) results.push("\n"), i++; else {
let j = i + 1;
for (;j < len && 10 !== str.charCodeAt(j); ) j++;
results.push(str.slice(i, j + 1)), i = j + 1;
}
}
return results;
};
},
66342: module => {
module.exports = str => {
const len = str.length;
if (0 === len) return null;
const results = [];
let i = 0;
for (;i < len; ) {
const s = i;
block: {
let cc = str.charCodeAt(i);
for (;10 !== cc && 59 !== cc && 123 !== cc && 125 !== cc; ) {
if (++i >= len) break block;
cc = str.charCodeAt(i);
}
for (;59 === cc || 32 === cc || 123 === cc || 125 === cc || 13 === cc || 9 === cc; ) {
if (++i >= len) break block;
cc = str.charCodeAt(i);
}
10 === cc && i++;
}
results.push(str.slice(s, i));
}
return results;
};
},
25773: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const createMappingsSerializer = __webpack_require__(49287), streamChunks = __webpack_require__(26870);
module.exports = (inputSource, options, onChunk, onSource, onName) => {
let code = "", mappings = "", sources = [], sourcesContent = [], names = [];
const addMapping = createMappingsSerializer(Object.assign({}, options, {
columns: !0
})), finalSource = !(!options || !options.finalSource), {generatedLine, generatedColumn, source} = streamChunks(inputSource, options, ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => (void 0 !== chunk && (code += chunk), 
mappings += addMapping(generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex), 
onChunk(finalSource ? void 0 : chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex))), ((sourceIndex, source, sourceContent) => {
for (;sources.length < sourceIndex; ) sources.push(null);
if (sources[sourceIndex] = source, void 0 !== sourceContent) {
for (;sourcesContent.length < sourceIndex; ) sourcesContent.push(null);
sourcesContent[sourceIndex] = sourceContent;
}
return onSource(sourceIndex, source, sourceContent);
}), ((nameIndex, name) => {
for (;names.length < nameIndex; ) names.push(null);
return names[nameIndex] = name, onName(nameIndex, name);
})), resultSource = void 0 !== source ? source : code;
return {
result: {
generatedLine,
generatedColumn,
source: finalSource ? resultSource : void 0
},
source: resultSource,
map: mappings.length > 0 ? {
version: 3,
file: "x",
mappings,
sources,
sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
names
} : null
};
};
},
26870: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const streamChunksOfRawSource = __webpack_require__(37893), streamChunksOfSourceMap = __webpack_require__(92013);
module.exports = (source, options, onChunk, onSource, onName) => {
if ("function" == typeof source.streamChunks) return source.streamChunks(options, onChunk, onSource, onName);
{
const sourceAndMap = source.sourceAndMap(options);
return sourceAndMap.map ? streamChunksOfSourceMap(sourceAndMap.source, sourceAndMap.map, onChunk, onSource, onName, !(!options || !options.finalSource), !(!options || !1 === options.columns)) : streamChunksOfRawSource(sourceAndMap.source, onChunk, onSource, onName, !(!options || !options.finalSource));
}
};
},
82470: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const streamChunksOfSourceMap = __webpack_require__(92013), splitIntoLines = __webpack_require__(53069);
module.exports = (source, sourceMap, innerSourceName, innerSource, innerSourceMap, removeInnerSource, onChunk, onSource, onName, finalSource, columns) => {
let sourceMapping = new Map, nameMapping = new Map;
const sourceIndexMapping = [], nameIndexMapping = [], nameIndexValueMapping = [];
let innerSourceIndex = -2;
const innerSourceIndexMapping = [], innerSourceIndexValueMapping = [], innerSourceContents = [], innerSourceContentLines = [], innerNameIndexMapping = [], innerNameIndexValueMapping = [], innerSourceMapLineData = [];
return streamChunksOfSourceMap(source, sourceMap, ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
if (sourceIndex === innerSourceIndex) {
const idx = ((line, column) => {
if (line > innerSourceMapLineData.length) return -1;
const {mappingsData} = innerSourceMapLineData[line - 1];
let l = 0, r = mappingsData.length / 5;
for (;l < r; ) {
let m = l + r >> 1;
mappingsData[5 * m] <= column ? l = m + 1 : r = m;
}
return 0 === l ? -1 : l - 1;
})(originalLine, originalColumn);
if (-1 !== idx) {
const {chunks, mappingsData} = innerSourceMapLineData[originalLine - 1], mi = 5 * idx, innerSourceIndex = mappingsData[mi + 1], innerOriginalLine = mappingsData[mi + 2];
let innerOriginalColumn = mappingsData[mi + 3], innerNameIndex = mappingsData[mi + 4];
if (innerSourceIndex >= 0) {
const innerChunk = chunks[idx], locationInChunk = originalColumn - mappingsData[mi];
if (locationInChunk > 0) {
let originalSourceLines = innerSourceIndex < innerSourceContentLines.length ? innerSourceContentLines[innerSourceIndex] : null;
if (void 0 === originalSourceLines) {
const originalSource = innerSourceContents[innerSourceIndex];
originalSourceLines = originalSource ? splitIntoLines(originalSource) : null, innerSourceContentLines[innerSourceIndex] = originalSourceLines;
}
if (null !== originalSourceLines) {
const originalChunk = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(innerOriginalColumn, innerOriginalColumn + locationInChunk) : "";
innerChunk.slice(0, locationInChunk) === originalChunk && (innerOriginalColumn += locationInChunk, 
innerNameIndex = -1);
}
}
let sourceIndex = innerSourceIndex < innerSourceIndexMapping.length ? innerSourceIndexMapping[innerSourceIndex] : -2;
if (-2 === sourceIndex) {
const [source, sourceContent] = innerSourceIndex < innerSourceIndexValueMapping.length ? innerSourceIndexValueMapping[innerSourceIndex] : [ null, void 0 ];
let globalIndex = sourceMapping.get(source);
void 0 === globalIndex && (sourceMapping.set(source, globalIndex = sourceMapping.size), 
onSource(globalIndex, source, sourceContent)), sourceIndex = globalIndex, innerSourceIndexMapping[innerSourceIndex] = sourceIndex;
}
let finalNameIndex = -1;
if (innerNameIndex >= 0) {
if (finalNameIndex = innerNameIndex < innerNameIndexMapping.length ? innerNameIndexMapping[innerNameIndex] : -2, 
-2 === finalNameIndex) {
const name = innerNameIndex < innerNameIndexValueMapping.length ? innerNameIndexValueMapping[innerNameIndex] : void 0;
if (name) {
let globalIndex = nameMapping.get(name);
void 0 === globalIndex && (nameMapping.set(name, globalIndex = nameMapping.size), 
onName(globalIndex, name)), finalNameIndex = globalIndex;
} else finalNameIndex = -1;
innerNameIndexMapping[innerNameIndex] = finalNameIndex;
}
} else if (nameIndex >= 0) {
let originalSourceLines = innerSourceContentLines[innerSourceIndex];
if (void 0 === originalSourceLines) {
const originalSource = innerSourceContents[innerSourceIndex];
originalSourceLines = originalSource ? splitIntoLines(originalSource) : null, innerSourceContentLines[innerSourceIndex] = originalSourceLines;
}
if (null !== originalSourceLines) {
const name = nameIndexValueMapping[nameIndex];
if (name === (innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(innerOriginalColumn, innerOriginalColumn + name.length) : "") && (finalNameIndex = nameIndex < nameIndexMapping.length ? nameIndexMapping[nameIndex] : -2, 
-2 === finalNameIndex)) {
const name = nameIndexValueMapping[nameIndex];
if (name) {
let globalIndex = nameMapping.get(name);
void 0 === globalIndex && (nameMapping.set(name, globalIndex = nameMapping.size), 
onName(globalIndex, name)), finalNameIndex = globalIndex;
} else finalNameIndex = -1;
nameIndexMapping[nameIndex] = finalNameIndex;
}
}
}
return void onChunk(chunk, generatedLine, generatedColumn, sourceIndex, innerOriginalLine, innerOriginalColumn, finalNameIndex);
}
}
if (removeInnerSource) return void onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
if (-2 === sourceIndexMapping[sourceIndex]) {
let globalIndex = sourceMapping.get(innerSourceName);
void 0 === globalIndex && (sourceMapping.set(source, globalIndex = sourceMapping.size), 
onSource(globalIndex, innerSourceName, innerSource)), sourceIndexMapping[sourceIndex] = globalIndex;
}
}
const finalSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
if (finalSourceIndex < 0) onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1); else {
let finalNameIndex = -1;
if (nameIndex >= 0 && nameIndex < nameIndexMapping.length && (finalNameIndex = nameIndexMapping[nameIndex], 
-2 === finalNameIndex)) {
const name = nameIndexValueMapping[nameIndex];
let globalIndex = nameMapping.get(name);
void 0 === globalIndex && (nameMapping.set(name, globalIndex = nameMapping.size), 
onName(globalIndex, name)), finalNameIndex = globalIndex, nameIndexMapping[nameIndex] = finalNameIndex;
}
onChunk(chunk, generatedLine, generatedColumn, finalSourceIndex, originalLine, originalColumn, finalNameIndex);
}
}), ((i, source, sourceContent) => {
if (source === innerSourceName) innerSourceIndex = i, void 0 !== innerSource ? sourceContent = innerSource : innerSource = sourceContent, 
sourceIndexMapping[i] = -2, streamChunksOfSourceMap(sourceContent, innerSourceMap, ((chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
for (;innerSourceMapLineData.length < generatedLine; ) innerSourceMapLineData.push({
mappingsData: [],
chunks: []
});
const data = innerSourceMapLineData[generatedLine - 1];
data.mappingsData.push(generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex), 
data.chunks.push(chunk);
}), ((i, source, sourceContent) => {
innerSourceContents[i] = sourceContent, innerSourceContentLines[i] = void 0, innerSourceIndexMapping[i] = -2, 
innerSourceIndexValueMapping[i] = [ source, sourceContent ];
}), ((i, name) => {
innerNameIndexMapping[i] = -2, innerNameIndexValueMapping[i] = name;
}), !1, columns); else {
let globalIndex = sourceMapping.get(source);
void 0 === globalIndex && (sourceMapping.set(source, globalIndex = sourceMapping.size), 
onSource(globalIndex, source, sourceContent)), sourceIndexMapping[i] = globalIndex;
}
}), ((i, name) => {
nameIndexMapping[i] = -2, nameIndexValueMapping[i] = name;
}), finalSource, columns);
};
},
37893: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const getGeneratedSourceInfo = __webpack_require__(78498), splitIntoLines = __webpack_require__(53069);
module.exports = (source, onChunk, onSource, onName, finalSource) => finalSource ? getGeneratedSourceInfo(source) : ((source, onChunk, onSource, onName) => {
let line = 1;
const matches = splitIntoLines(source);
let match;
for (match of matches) onChunk(match, line, 0, -1, -1, -1, -1), line++;
return 0 === matches.length || match.endsWith("\n") ? {
generatedLine: matches.length + 1,
generatedColumn: 0
} : {
generatedLine: matches.length,
generatedColumn: match.length
};
})(source, onChunk);
},
92013: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const getGeneratedSourceInfo = __webpack_require__(78498), getSource = __webpack_require__(99988), readMappings = __webpack_require__(92908), splitIntoLines = __webpack_require__(53069);
module.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => columns ? finalSource ? ((source, sourceMap, onChunk, onSource, onName) => {
const result = getGeneratedSourceInfo(source), {generatedLine: finalLine, generatedColumn: finalColumn} = result;
if (1 === finalLine && 0 === finalColumn) return result;
const {sources, sourcesContent, names, mappings} = sourceMap;
for (let i = 0; i < sources.length; i++) onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || void 0);
if (names) for (let i = 0; i < names.length; i++) onName(i, names[i]);
let mappingActiveLine = 0;
return readMappings(mappings, ((generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine) || (sourceIndex >= 0 ? (onChunk(void 0, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex), 
mappingActiveLine = generatedLine) : mappingActiveLine === generatedLine && (onChunk(void 0, generatedLine, generatedColumn, -1, -1, -1, -1), 
mappingActiveLine = 0));
})), result;
})(source, sourceMap, onChunk, onSource, onName) : ((source, sourceMap, onChunk, onSource, onName) => {
const lines = splitIntoLines(source);
if (0 === lines.length) return {
generatedLine: 1,
generatedColumn: 0
};
const {sources, sourcesContent, names, mappings} = sourceMap;
for (let i = 0; i < sources.length; i++) onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || void 0);
if (names) for (let i = 0; i < names.length; i++) onName(i, names[i]);
const lastLine = lines[lines.length - 1], lastNewLine = lastLine.endsWith("\n"), finalLine = lastNewLine ? lines.length + 1 : lines.length, finalColumn = lastNewLine ? 0 : lastLine.length;
let currentGeneratedLine = 1, currentGeneratedColumn = 0, mappingActive = !1, activeMappingSourceIndex = -1, activeMappingOriginalLine = -1, activeMappingOriginalColumn = -1, activeMappingNameIndex = -1;
const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
if (mappingActive && currentGeneratedLine <= lines.length) {
let chunk;
const mappingLine = currentGeneratedLine, mappingColumn = currentGeneratedColumn, line = lines[currentGeneratedLine - 1];
generatedLine !== currentGeneratedLine ? (chunk = line.slice(currentGeneratedColumn), 
currentGeneratedLine++, currentGeneratedColumn = 0) : (chunk = line.slice(currentGeneratedColumn, generatedColumn), 
currentGeneratedColumn = generatedColumn), chunk && onChunk(chunk, mappingLine, mappingColumn, activeMappingSourceIndex, activeMappingOriginalLine, activeMappingOriginalColumn, activeMappingNameIndex), 
mappingActive = !1;
}
if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {
if (currentGeneratedLine <= lines.length) {
const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn);
onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);
}
currentGeneratedLine++, currentGeneratedColumn = 0;
}
for (;generatedLine > currentGeneratedLine; ) currentGeneratedLine <= lines.length && onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1), 
currentGeneratedLine++;
if (generatedColumn > currentGeneratedColumn) {
if (currentGeneratedLine <= lines.length) {
const chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn, generatedColumn);
onChunk(chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);
}
currentGeneratedColumn = generatedColumn;
}
sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn) && (mappingActive = !0, 
activeMappingSourceIndex = sourceIndex, activeMappingOriginalLine = originalLine, 
activeMappingOriginalColumn = originalColumn, activeMappingNameIndex = nameIndex);
};
return readMappings(mappings, onMapping), onMapping(finalLine, finalColumn, -1, -1, -1, -1), 
{
generatedLine: finalLine,
generatedColumn: finalColumn
};
})(source, sourceMap, onChunk, onSource, onName) : finalSource ? ((source, sourceMap, onChunk, onSource, _onName) => {
const result = getGeneratedSourceInfo(source), {generatedLine, generatedColumn} = result;
if (1 === generatedLine && 0 === generatedColumn) return {
generatedLine: 1,
generatedColumn: 0
};
const {sources, sourcesContent, mappings} = sourceMap;
for (let i = 0; i < sources.length; i++) onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || void 0);
const finalLine = 0 === generatedColumn ? generatedLine - 1 : generatedLine;
let currentGeneratedLine = 1;
return readMappings(mappings, ((generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
sourceIndex >= 0 && currentGeneratedLine <= generatedLine && generatedLine <= finalLine && (onChunk(void 0, generatedLine, 0, sourceIndex, originalLine, originalColumn, -1), 
currentGeneratedLine = generatedLine + 1);
})), result;
})(source, sourceMap, onChunk, onSource) : ((source, sourceMap, onChunk, onSource, _onName) => {
const lines = splitIntoLines(source);
if (0 === lines.length) return {
generatedLine: 1,
generatedColumn: 0
};
const {sources, sourcesContent, mappings} = sourceMap;
for (let i = 0; i < sources.length; i++) onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || void 0);
let currentGeneratedLine = 1;
for (readMappings(mappings, ((generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
if (!(sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length)) {
for (;generatedLine > currentGeneratedLine; ) currentGeneratedLine <= lines.length && onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1), 
currentGeneratedLine++;
generatedLine <= lines.length && (onChunk(lines[generatedLine - 1], generatedLine, 0, sourceIndex, originalLine, originalColumn, -1), 
currentGeneratedLine++);
}
})); currentGeneratedLine <= lines.length; currentGeneratedLine++) onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);
const lastLine = lines[lines.length - 1], lastNewLine = lastLine.endsWith("\n");
return {
generatedLine: lastNewLine ? lines.length + 1 : lines.length,
generatedColumn: lastNewLine ? 0 : lastLine.length
};
})(source, sourceMap, onChunk, onSource);
},
37946: (__unused_webpack_module, exports, __webpack_require__) => {
const defineExport = (name, fn) => {
let value;
Object.defineProperty(exports, name, {
get: () => (void 0 !== fn && (value = fn(), fn = void 0), value),
configurable: !0
});
};
defineExport("Source", (() => __webpack_require__(91468))), defineExport("RawSource", (() => __webpack_require__(56331))), 
defineExport("OriginalSource", (() => __webpack_require__(61906))), defineExport("SourceMapSource", (() => __webpack_require__(9972))), 
defineExport("CachedSource", (() => __webpack_require__(78830))), defineExport("ConcatSource", (() => __webpack_require__(91344))), 
defineExport("ReplaceSource", (() => __webpack_require__(21846))), defineExport("PrefixSource", (() => __webpack_require__(91721))), 
defineExport("SizeOnlySource", (() => __webpack_require__(11920))), defineExport("CompatSource", (() => __webpack_require__(39553)));
},
26196: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
var urlBase = decodeURIComponent("".slice(1));
exports.keepAlive = function(options) {
var response, data = options.data, onError = options.onError, active = options.active, module = options.module, request = (urlBase.startsWith("https") ? __webpack_require__(95687) : __webpack_require__(13685)).request(urlBase + data, {
agent: !1,
headers: {
accept: "text/event-stream"
}
}, (function(res) {
(response = res).on("error", errorHandler), active || module.hot || console.log("Hot Module Replacement is not enabled. Waiting for process restart...");
}));
function errorHandler(err) {
err.message = "Problem communicating active modules to the server: " + err.message, 
onError(err);
}
return request.on("error", errorHandler), request.end(), function() {
response.destroy();
};
};
},
7217: (__unused_webpack_module, exports) => {
"use strict";
if ("function" != typeof EventSource) throw new Error("Environment doesn't support lazy compilation (requires EventSource)");
var activeEventSource, urlBase = decodeURIComponent("".slice(1)), activeKeys = new Map, errorHandlers = new Set, updateEventSource = function() {
activeEventSource && activeEventSource.close(), activeKeys.size ? (activeEventSource = new EventSource(urlBase + Array.from(activeKeys.keys()).join("@"))).onerror = function(event) {
errorHandlers.forEach((function(onError) {
onError(new Error("Problem communicating active modules to the server: " + event.message + " " + event.filename + ":" + event.lineno + ":" + event.colno + " " + event.error));
}));
} : activeEventSource = void 0;
};
exports.keepAlive = function(options) {
var data = options.data, onError = options.onError, active = options.active, module = options.module;
errorHandlers.add(onError);
var value = activeKeys.get(data) || 0;
return activeKeys.set(data, value + 1), 0 === value && updateEventSource(), active || module.hot || console.log("Hot Module Replacement is not enabled. Waiting for process restart..."), 
function() {
errorHandlers.delete(onError), setTimeout((function() {
var value = activeKeys.get(data);
1 === value ? (activeKeys.delete(data), updateEventSource()) : activeKeys.set(data, value - 1);
}), 1e3);
};
};
},
19117: (module, __unused_webpack_exports, __webpack_require__) => {
var map = {
"./lazy-compilation-node.js": 26196,
"./lazy-compilation-web.js": 7217
};
function webpackContext(req) {
var id = webpackContextResolve(req);
return __webpack_require__(id);
}
function webpackContextResolve(req) {
if (!__webpack_require__.o(map, req)) {
var e = new Error("Cannot find module '" + req + "'");
throw e.code = "MODULE_NOT_FOUND", e;
}
return map[req];
}
webpackContext.keys = function() {
return Object.keys(map);
}, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
webpackContext.id = 19117;
},
25306: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), WebpackError = __webpack_require__(64326), ConstDependency = __webpack_require__(30339), BasicEvaluatedExpression = __webpack_require__(47789), {toConstantDependency, evaluateToString} = __webpack_require__(78802), ChunkNameRuntimeModule = __webpack_require__(74460), GetFullHashRuntimeModule = __webpack_require__(42491), REPLACEMENTS = {
__webpack_require__: {
expr: RuntimeGlobals.require,
req: [ RuntimeGlobals.require ],
type: "function",
assign: !1
},
__webpack_public_path__: {
expr: RuntimeGlobals.publicPath,
req: [ RuntimeGlobals.publicPath ],
type: "string",
assign: !0
},
__webpack_base_uri__: {
expr: RuntimeGlobals.baseURI,
req: [ RuntimeGlobals.baseURI ],
type: "string",
assign: !0
},
__webpack_modules__: {
expr: RuntimeGlobals.moduleFactories,
req: [ RuntimeGlobals.moduleFactories ],
type: "object",
assign: !1
},
__webpack_chunk_load__: {
expr: RuntimeGlobals.ensureChunk,
req: [ RuntimeGlobals.ensureChunk ],
type: "function",
assign: !0
},
__non_webpack_require__: {
expr: "require",
req: null,
type: void 0,
assign: !0
},
__webpack_nonce__: {
expr: RuntimeGlobals.scriptNonce,
req: [ RuntimeGlobals.scriptNonce ],
type: "string",
assign: !0
},
__webpack_hash__: {
expr: `${RuntimeGlobals.getFullHash}()`,
req: [ RuntimeGlobals.getFullHash ],
type: "string",
assign: !1
},
__webpack_chunkname__: {
expr: RuntimeGlobals.chunkName,
req: [ RuntimeGlobals.chunkName ],
type: "string",
assign: !1
},
__webpack_get_script_filename__: {
expr: RuntimeGlobals.getChunkScriptFilename,
req: [ RuntimeGlobals.getChunkScriptFilename ],
type: "function",
assign: !0
},
__webpack_runtime_id__: {
expr: RuntimeGlobals.runtimeId,
req: [ RuntimeGlobals.runtimeId ],
assign: !1
},
"require.onError": {
expr: RuntimeGlobals.uncaughtErrorHandler,
req: [ RuntimeGlobals.uncaughtErrorHandler ],
type: void 0,
assign: !0
},
__system_context__: {
expr: RuntimeGlobals.systemContext,
req: [ RuntimeGlobals.systemContext ],
type: "object",
assign: !1
},
__webpack_share_scopes__: {
expr: RuntimeGlobals.shareScopeMap,
req: [ RuntimeGlobals.shareScopeMap ],
type: "object",
assign: !1
},
__webpack_init_sharing__: {
expr: RuntimeGlobals.initializeSharing,
req: [ RuntimeGlobals.initializeSharing ],
type: "function",
assign: !0
}
};
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("APIPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.chunkName).tap("APIPlugin", (chunk => (compilation.addRuntimeModule(chunk, new ChunkNameRuntimeModule(chunk.name)), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.getFullHash).tap("APIPlugin", ((chunk, set) => (compilation.addRuntimeModule(chunk, new GetFullHashRuntimeModule), 
!0)));
const handler = parser => {
Object.keys(REPLACEMENTS).forEach((key => {
const info = REPLACEMENTS[key];
parser.hooks.expression.for(key).tap("APIPlugin", toConstantDependency(parser, info.expr, info.req)), 
!1 === info.assign && parser.hooks.assign.for(key).tap("APIPlugin", (expr => {
const err = new WebpackError(`${key} must not be assigned`);
throw err.loc = expr.loc, err;
})), info.type && parser.hooks.evaluateTypeof.for(key).tap("APIPlugin", evaluateToString(info.type));
})), parser.hooks.expression.for("__webpack_layer__").tap("APIPlugin", (expr => {
const dep = new ConstDependency(JSON.stringify(parser.state.module.layer), expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluateIdentifier.for("__webpack_layer__").tap("APIPlugin", (expr => (null === parser.state.module.layer ? (new BasicEvaluatedExpression).setNull() : (new BasicEvaluatedExpression).setString(parser.state.module.layer)).setRange(expr.range))), 
parser.hooks.evaluateTypeof.for("__webpack_layer__").tap("APIPlugin", (expr => (new BasicEvaluatedExpression).setString(null === parser.state.module.layer ? "object" : "string").setRange(expr.range))), 
parser.hooks.expression.for("__webpack_module__.id").tap("APIPlugin", (expr => {
parser.state.module.buildInfo.moduleConcatenationBailout = "__webpack_module__.id";
const dep = new ConstDependency(parser.state.module.moduleArgument + ".id", expr.range, [ RuntimeGlobals.moduleId ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.expression.for("__webpack_module__").tap("APIPlugin", (expr => {
parser.state.module.buildInfo.moduleConcatenationBailout = "__webpack_module__";
const dep = new ConstDependency(parser.state.module.moduleArgument, expr.range, [ RuntimeGlobals.module ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluateTypeof.for("__webpack_module__").tap("APIPlugin", evaluateToString("object"));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("APIPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("APIPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("APIPlugin", handler);
}));
}
};
},
91266: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), CURRENT_METHOD_REGEXP = /at ([a-zA-Z0-9_.]*)/;
function createMessage(method) {
return `Abstract method${method ? " " + method : ""}. Must be overridden.`;
}
function Message() {
this.stack = void 0, Error.captureStackTrace(this);
const match = this.stack.split("\n")[3].match(CURRENT_METHOD_REGEXP);
this.message = match && match[1] ? createMessage(match[1]) : createMessage();
}
module.exports = class extends WebpackError {
constructor() {
super((new Message).message), this.name = "AbstractMethodError";
}
};
},
89353: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DependenciesBlock = __webpack_require__(17461), makeSerializable = __webpack_require__(45898);
class AsyncDependenciesBlock extends DependenciesBlock {
constructor(groupOptions, loc, request) {
super(), "string" == typeof groupOptions ? groupOptions = {
name: groupOptions
} : groupOptions || (groupOptions = {
name: void 0
}), this.groupOptions = groupOptions, this.loc = loc, this.request = request, this._stringifiedGroupOptions = void 0;
}
get chunkName() {
return this.groupOptions.name;
}
set chunkName(value) {
this.groupOptions.name !== value && (this.groupOptions.name = value, this._stringifiedGroupOptions = void 0);
}
updateHash(hash, context) {
const {chunkGraph} = context;
void 0 === this._stringifiedGroupOptions && (this._stringifiedGroupOptions = JSON.stringify(this.groupOptions));
const chunkGroup = chunkGraph.getBlockChunkGroup(this);
hash.update(`${this._stringifiedGroupOptions}${chunkGroup ? chunkGroup.id : ""}`), 
super.updateHash(hash, context);
}
serialize(context) {
const {write} = context;
write(this.groupOptions), write(this.loc), write(this.request), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.groupOptions = read(), this.loc = read(), this.request = read(), super.deserialize(context);
}
}
makeSerializable(AsyncDependenciesBlock, "webpack/lib/AsyncDependenciesBlock"), 
Object.defineProperty(AsyncDependenciesBlock.prototype, "module", {
get() {
throw new Error("module property was removed from AsyncDependenciesBlock (it's not needed)");
},
set() {
throw new Error("module property was removed from AsyncDependenciesBlock (it's not needed)");
}
}), module.exports = AsyncDependenciesBlock;
},
94359: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(chunkName, module, loc) {
super(`It's not allowed to load an initial chunk on demand. The chunk name "${chunkName}" is already used by an entrypoint.`), 
this.name = "AsyncDependencyToInitialChunkError", this.module = module, this.loc = loc;
}
};
},
18572: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), NormalModule = __webpack_require__(3213), PrefetchDependency = __webpack_require__(63352);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("AutomaticPrefetchPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
}));
let lastModules = null;
compiler.hooks.afterCompile.tap("AutomaticPrefetchPlugin", (compilation => {
lastModules = [];
for (const m of compilation.modules) m instanceof NormalModule && lastModules.push({
context: m.context,
request: m.request
});
})), compiler.hooks.make.tapAsync("AutomaticPrefetchPlugin", ((compilation, callback) => {
if (!lastModules) return callback();
asyncLib.forEach(lastModules, ((m, callback) => {
compilation.addModuleChain(m.context || compiler.context, new PrefetchDependency(`!!${m.request}`), callback);
}), (err => {
lastModules = null, callback(err);
}));
}));
}
};
},
50073: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), Compilation = __webpack_require__(62843), ModuleFilenameHelpers = __webpack_require__(23833), Template = __webpack_require__(88370), validate = __webpack_require__(59586)(__webpack_require__(89057), (() => __webpack_require__(87298)), {
name: "Banner Plugin",
baseDataPath: "options"
}), wrapComment = str => str.includes("\n") ? `/*!\n * ${str.replace(/\*\//g, "* /").split("\n").join("\n * ").replace(/\s+\n/g, "\n").trimRight()}\n */` : Template.toComment(str);
module.exports = class {
constructor(options) {
"string" != typeof options && "function" != typeof options || (options = {
banner: options
}), validate(options), this.options = options;
const bannerOption = options.banner;
if ("function" == typeof bannerOption) {
const getBanner = bannerOption;
this.banner = this.options.raw ? getBanner : data => wrapComment(getBanner(data));
} else {
const banner = this.options.raw ? bannerOption : wrapComment(bannerOption);
this.banner = () => banner;
}
}
apply(compiler) {
const options = this.options, banner = this.banner, matchObject = ModuleFilenameHelpers.matchObject.bind(void 0, options), cache = new WeakMap;
compiler.hooks.compilation.tap("BannerPlugin", (compilation => {
compilation.hooks.processAssets.tap({
name: "BannerPlugin",
stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
}, (() => {
for (const chunk of compilation.chunks) if (!options.entryOnly || chunk.canBeInitial()) for (const file of chunk.files) {
if (!matchObject(file)) continue;
const data = {
chunk,
filename: file
}, comment = compilation.getPath(banner, data);
compilation.updateAsset(file, (old => {
let cached = cache.get(old);
if (!cached || cached.comment !== comment) {
const source = options.footer ? new ConcatSource(old, "\n", comment) : new ConcatSource(comment, "\n", old);
return cache.set(old, {
source,
comment
}), source;
}
return cached.source;
}));
}
}));
}));
}
};
},
54499: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {AsyncParallelHook, AsyncSeriesBailHook, SyncHook} = __webpack_require__(89991), {makeWebpackError, makeWebpackErrorCallback} = __webpack_require__(44741);
class Cache {
constructor() {
this.hooks = {
get: new AsyncSeriesBailHook([ "identifier", "etag", "gotHandlers" ]),
store: new AsyncParallelHook([ "identifier", "etag", "data" ]),
storeBuildDependencies: new AsyncParallelHook([ "dependencies" ]),
beginIdle: new SyncHook([]),
endIdle: new AsyncParallelHook([]),
shutdown: new AsyncParallelHook([])
};
}
get(identifier, etag, callback) {
const gotHandlers = [];
this.hooks.get.callAsync(identifier, etag, gotHandlers, ((err, result) => {
if (err) callback(makeWebpackError(err, "Cache.hooks.get")); else if (null === result && (result = void 0), 
gotHandlers.length > 1) {
const innerCallback = ((times, callback) => err => 0 == --times ? callback(err) : err && times > 0 ? (times = 0, 
callback(err)) : void 0)(gotHandlers.length, (() => callback(null, result)));
for (const gotHandler of gotHandlers) gotHandler(result, innerCallback);
} else 1 === gotHandlers.length ? gotHandlers[0](result, (() => callback(null, result))) : callback(null, result);
}));
}
store(identifier, etag, data, callback) {
this.hooks.store.callAsync(identifier, etag, data, makeWebpackErrorCallback(callback, "Cache.hooks.store"));
}
storeBuildDependencies(dependencies, callback) {
this.hooks.storeBuildDependencies.callAsync(dependencies, makeWebpackErrorCallback(callback, "Cache.hooks.storeBuildDependencies"));
}
beginIdle() {
this.hooks.beginIdle.call();
}
endIdle(callback) {
this.hooks.endIdle.callAsync(makeWebpackErrorCallback(callback, "Cache.hooks.endIdle"));
}
shutdown(callback) {
this.hooks.shutdown.callAsync(makeWebpackErrorCallback(callback, "Cache.hooks.shutdown"));
}
}
Cache.STAGE_MEMORY = -10, Cache.STAGE_DEFAULT = 0, Cache.STAGE_DISK = 10, Cache.STAGE_NETWORK = 20, 
module.exports = Cache;
},
87251: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {forEachBail} = __webpack_require__(92672), asyncLib = __webpack_require__(76947), getLazyHashedEtag = __webpack_require__(19436), mergeEtags = __webpack_require__(85197);
class ItemCacheFacade {
constructor(cache, name, etag) {
this._cache = cache, this._name = name, this._etag = etag;
}
get(callback) {
this._cache.get(this._name, this._etag, callback);
}
getPromise() {
return new Promise(((resolve, reject) => {
this._cache.get(this._name, this._etag, ((err, data) => {
err ? reject(err) : resolve(data);
}));
}));
}
store(data, callback) {
this._cache.store(this._name, this._etag, data, callback);
}
storePromise(data) {
return new Promise(((resolve, reject) => {
this._cache.store(this._name, this._etag, data, (err => {
err ? reject(err) : resolve();
}));
}));
}
provide(computer, callback) {
this.get(((err, cacheEntry) => err ? callback(err) : void 0 !== cacheEntry ? cacheEntry : void computer(((err, result) => {
if (err) return callback(err);
this.store(result, (err => {
if (err) return callback(err);
callback(null, result);
}));
}))));
}
async providePromise(computer) {
const cacheEntry = await this.getPromise();
if (void 0 !== cacheEntry) return cacheEntry;
const result = await computer();
return await this.storePromise(result), result;
}
}
class CacheFacade {
constructor(cache, name, hashFunction) {
this._cache = cache, this._name = name, this._hashFunction = hashFunction;
}
getChildCache(name) {
return new CacheFacade(this._cache, `${this._name}|${name}`, this._hashFunction);
}
getItemCache(identifier, etag) {
return new ItemCacheFacade(this._cache, `${this._name}|${identifier}`, etag);
}
getLazyHashedEtag(obj) {
return getLazyHashedEtag(obj, this._hashFunction);
}
mergeEtags(a, b) {
return mergeEtags(a, b);
}
get(identifier, etag, callback) {
this._cache.get(`${this._name}|${identifier}`, etag, callback);
}
getPromise(identifier, etag) {
return new Promise(((resolve, reject) => {
this._cache.get(`${this._name}|${identifier}`, etag, ((err, data) => {
err ? reject(err) : resolve(data);
}));
}));
}
store(identifier, etag, data, callback) {
this._cache.store(`${this._name}|${identifier}`, etag, data, callback);
}
storePromise(identifier, etag, data) {
return new Promise(((resolve, reject) => {
this._cache.store(`${this._name}|${identifier}`, etag, data, (err => {
err ? reject(err) : resolve();
}));
}));
}
provide(identifier, etag, computer, callback) {
this.get(identifier, etag, ((err, cacheEntry) => err ? callback(err) : void 0 !== cacheEntry ? cacheEntry : void computer(((err, result) => {
if (err) return callback(err);
this.store(identifier, etag, result, (err => {
if (err) return callback(err);
callback(null, result);
}));
}))));
}
async providePromise(identifier, etag, computer) {
const cacheEntry = await this.getPromise(identifier, etag);
if (void 0 !== cacheEntry) return cacheEntry;
const result = await computer();
return await this.storePromise(identifier, etag, result), result;
}
}
module.exports = CacheFacade, module.exports.ItemCacheFacade = ItemCacheFacade, 
module.exports.MultiItemCache = class {
constructor(items) {
if (this._items = items, 1 === items.length) return items[0];
}
get(callback) {
forEachBail(this._items, ((item, callback) => item.get(callback)), callback);
}
getPromise() {
const next = i => this._items[i].getPromise().then((result => void 0 !== result ? result : ++i < this._items.length ? next(i) : void 0));
return next(0);
}
store(data, callback) {
asyncLib.each(this._items, ((item, callback) => item.store(data, callback)), callback);
}
storePromise(data) {
return Promise.all(this._items.map((item => item.storePromise(data)))).then((() => {}));
}
};
},
64710: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(modules, moduleGraph) {
const sortedModules = (modules => modules.sort(((a, b) => {
const aIdent = a.identifier(), bIdent = b.identifier();
return aIdent < bIdent ? -1 : aIdent > bIdent ? 1 : 0;
})))(Array.from(modules)), modulesList = ((modules, moduleGraph) => modules.map((m => {
let message = `* ${m.identifier()}`;
const validReasons = Array.from(moduleGraph.getIncomingConnectionsByOriginModule(m).keys()).filter((x => x));
return validReasons.length > 0 && (message += `\n    Used by ${validReasons.length} module(s), i. e.`, 
message += `\n    ${validReasons[0].identifier()}`), message;
})).join("\n"))(sortedModules, moduleGraph);
super(`There are multiple modules with names that only differ in casing.\nThis can lead to unexpected behavior when compiling on a filesystem with other case-semantic.\nUse equal casing. Compare these module identifiers:\n${modulesList}`), 
this.name = "CaseSensitiveModulesWarning", this.module = sortedModules[0];
}
};
},
76034: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ChunkGraph = __webpack_require__(15888), Entrypoint = __webpack_require__(7807), {intersect} = __webpack_require__(73974), SortableSet = __webpack_require__(72451), StringXor = __webpack_require__(81664), {compareModulesByIdentifier, compareChunkGroupsByIndex, compareModulesById} = __webpack_require__(40028), {createArrayToSetDeprecationSet} = __webpack_require__(33469), {mergeRuntime} = __webpack_require__(14372), ChunkFilesSet = createArrayToSetDeprecationSet("chunk.files");
let debugId = 1e3;
module.exports = class {
constructor(name, backCompat = !0) {
this.id = null, this.ids = null, this.debugId = debugId++, this.name = name, this.idNameHints = new SortableSet, 
this.preventIntegration = !1, this.filenameTemplate = void 0, this.cssFilenameTemplate = void 0, 
this._groups = new SortableSet(void 0, compareChunkGroupsByIndex), this.runtime = void 0, 
this.files = backCompat ? new ChunkFilesSet : new Set, this.auxiliaryFiles = new Set, 
this.rendered = !1, this.hash = void 0, this.contentHash = Object.create(null), 
this.renderedHash = void 0, this.chunkReason = void 0, this.extraAsync = !1;
}
get entryModule() {
const entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, "Chunk.entryModule", "DEP_WEBPACK_CHUNK_ENTRY_MODULE").getChunkEntryModulesIterable(this));
if (0 !== entryModules.length) {
if (1 === entryModules.length) return entryModules[0];
throw new Error("Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)");
}
}
hasEntryModule() {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.hasEntryModule", "DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE").getNumberOfEntryModules(this) > 0;
}
addModule(module) {
const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, "Chunk.addModule", "DEP_WEBPACK_CHUNK_ADD_MODULE");
return !chunkGraph.isModuleInChunk(module, this) && (chunkGraph.connectChunkAndModule(this, module), 
!0);
}
removeModule(module) {
ChunkGraph.getChunkGraphForChunk(this, "Chunk.removeModule", "DEP_WEBPACK_CHUNK_REMOVE_MODULE").disconnectChunkAndModule(this, module);
}
getNumberOfModules() {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.getNumberOfModules", "DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES").getNumberOfChunkModules(this);
}
get modulesIterable() {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.modulesIterable", "DEP_WEBPACK_CHUNK_MODULES_ITERABLE").getOrderedChunkModulesIterable(this, compareModulesByIdentifier);
}
compareTo(otherChunk) {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.compareTo", "DEP_WEBPACK_CHUNK_COMPARE_TO").compareChunks(this, otherChunk);
}
containsModule(module) {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.containsModule", "DEP_WEBPACK_CHUNK_CONTAINS_MODULE").isModuleInChunk(module, this);
}
getModules() {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.getModules", "DEP_WEBPACK_CHUNK_GET_MODULES").getChunkModules(this);
}
remove() {
ChunkGraph.getChunkGraphForChunk(this, "Chunk.remove", "DEP_WEBPACK_CHUNK_REMOVE").disconnectChunk(this), 
this.disconnectFromGroups();
}
moveModule(module, otherChunk) {
const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, "Chunk.moveModule", "DEP_WEBPACK_CHUNK_MOVE_MODULE");
chunkGraph.disconnectChunkAndModule(this, module), chunkGraph.connectChunkAndModule(otherChunk, module);
}
integrate(otherChunk) {
const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, "Chunk.integrate", "DEP_WEBPACK_CHUNK_INTEGRATE");
return !!chunkGraph.canChunksBeIntegrated(this, otherChunk) && (chunkGraph.integrateChunks(this, otherChunk), 
!0);
}
canBeIntegrated(otherChunk) {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.canBeIntegrated", "DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED").canChunksBeIntegrated(this, otherChunk);
}
isEmpty() {
return 0 === ChunkGraph.getChunkGraphForChunk(this, "Chunk.isEmpty", "DEP_WEBPACK_CHUNK_IS_EMPTY").getNumberOfChunkModules(this);
}
modulesSize() {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.modulesSize", "DEP_WEBPACK_CHUNK_MODULES_SIZE").getChunkModulesSize(this);
}
size(options = {}) {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.size", "DEP_WEBPACK_CHUNK_SIZE").getChunkSize(this, options);
}
integratedSize(otherChunk, options) {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.integratedSize", "DEP_WEBPACK_CHUNK_INTEGRATED_SIZE").getIntegratedChunksSize(this, otherChunk, options);
}
getChunkModuleMaps(filterFn) {
const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, "Chunk.getChunkModuleMaps", "DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS"), chunkModuleIdMap = Object.create(null), chunkModuleHashMap = Object.create(null);
for (const asyncChunk of this.getAllAsyncChunks()) {
let array;
for (const module of chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))) if (filterFn(module)) {
void 0 === array && (array = [], chunkModuleIdMap[asyncChunk.id] = array);
const moduleId = chunkGraph.getModuleId(module);
array.push(moduleId), chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(module, void 0);
}
}
return {
id: chunkModuleIdMap,
hash: chunkModuleHashMap
};
}
hasModuleInGraph(filterFn, filterChunkFn) {
return ChunkGraph.getChunkGraphForChunk(this, "Chunk.hasModuleInGraph", "DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH").hasModuleInGraph(this, filterFn, filterChunkFn);
}
getChunkMaps(realHash) {
const chunkHashMap = Object.create(null), chunkContentHashMap = Object.create(null), chunkNameMap = Object.create(null);
for (const chunk of this.getAllAsyncChunks()) {
chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;
for (const key of Object.keys(chunk.contentHash)) chunkContentHashMap[key] || (chunkContentHashMap[key] = Object.create(null)), 
chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];
chunk.name && (chunkNameMap[chunk.id] = chunk.name);
}
return {
hash: chunkHashMap,
contentHash: chunkContentHashMap,
name: chunkNameMap
};
}
hasRuntime() {
for (const chunkGroup of this._groups) if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) return !0;
return !1;
}
canBeInitial() {
for (const chunkGroup of this._groups) if (chunkGroup.isInitial()) return !0;
return !1;
}
isOnlyInitial() {
if (this._groups.size <= 0) return !1;
for (const chunkGroup of this._groups) if (!chunkGroup.isInitial()) return !1;
return !0;
}
getEntryOptions() {
for (const chunkGroup of this._groups) if (chunkGroup instanceof Entrypoint) return chunkGroup.options;
}
addGroup(chunkGroup) {
this._groups.add(chunkGroup);
}
removeGroup(chunkGroup) {
this._groups.delete(chunkGroup);
}
isInGroup(chunkGroup) {
return this._groups.has(chunkGroup);
}
getNumberOfGroups() {
return this._groups.size;
}
get groupsIterable() {
return this._groups.sort(), this._groups;
}
disconnectFromGroups() {
for (const chunkGroup of this._groups) chunkGroup.removeChunk(this);
}
split(newChunk) {
for (const chunkGroup of this._groups) chunkGroup.insertChunk(newChunk, this), newChunk.addGroup(chunkGroup);
for (const idHint of this.idNameHints) newChunk.idNameHints.add(idHint);
newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);
}
updateHash(hash, chunkGraph) {
hash.update(`${this.id} ${this.ids ? this.ids.join() : ""} ${this.name || ""} `);
const xor = new StringXor;
for (const m of chunkGraph.getChunkModulesIterable(this)) xor.add(chunkGraph.getModuleHash(m, this.runtime));
xor.updateHash(hash);
const entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);
for (const [m, chunkGroup] of entryModules) hash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);
}
getAllAsyncChunks() {
const queue = new Set, chunks = new Set, initialChunks = intersect(Array.from(this.groupsIterable, (g => new Set(g.chunks)))), initialQueue = new Set(this.groupsIterable);
for (const chunkGroup of initialQueue) for (const child of chunkGroup.childrenIterable) child instanceof Entrypoint ? initialQueue.add(child) : queue.add(child);
for (const chunkGroup of queue) {
for (const chunk of chunkGroup.chunks) initialChunks.has(chunk) || chunks.add(chunk);
for (const child of chunkGroup.childrenIterable) queue.add(child);
}
return chunks;
}
getAllInitialChunks() {
const chunks = new Set, queue = new Set(this.groupsIterable);
for (const group of queue) if (group.isInitial()) {
for (const c of group.chunks) chunks.add(c);
for (const g of group.childrenIterable) queue.add(g);
}
return chunks;
}
getAllReferencedChunks() {
const queue = new Set(this.groupsIterable), chunks = new Set;
for (const chunkGroup of queue) {
for (const chunk of chunkGroup.chunks) chunks.add(chunk);
for (const child of chunkGroup.childrenIterable) queue.add(child);
}
return chunks;
}
getAllReferencedAsyncEntrypoints() {
const queue = new Set(this.groupsIterable), entrypoints = new Set;
for (const chunkGroup of queue) {
for (const entrypoint of chunkGroup.asyncEntrypointsIterable) entrypoints.add(entrypoint);
for (const child of chunkGroup.childrenIterable) queue.add(child);
}
return entrypoints;
}
hasAsyncChunks() {
const queue = new Set, initialChunks = intersect(Array.from(this.groupsIterable, (g => new Set(g.chunks))));
for (const chunkGroup of this.groupsIterable) for (const child of chunkGroup.childrenIterable) queue.add(child);
for (const chunkGroup of queue) {
for (const chunk of chunkGroup.chunks) if (!initialChunks.has(chunk)) return !0;
for (const child of chunkGroup.childrenIterable) queue.add(child);
}
return !1;
}
getChildIdsByOrders(chunkGraph, filterFn) {
const lists = new Map;
for (const group of this.groupsIterable) if (group.chunks[group.chunks.length - 1] === this) for (const childGroup of group.childrenIterable) for (const key of Object.keys(childGroup.options)) if (key.endsWith("Order")) {
const name = key.slice(0, key.length - "Order".length);
let list = lists.get(name);
void 0 === list && (list = [], lists.set(name, list)), list.push({
order: childGroup.options[key],
group: childGroup
});
}
const result = Object.create(null);
for (const [name, list] of lists) {
list.sort(((a, b) => {
const cmp = b.order - a.order;
return 0 !== cmp ? cmp : a.group.compareTo(chunkGraph, b.group);
}));
const chunkIdSet = new Set;
for (const item of list) for (const chunk of item.group.chunks) filterFn && !filterFn(chunk, chunkGraph) || chunkIdSet.add(chunk.id);
chunkIdSet.size > 0 && (result[name] = Array.from(chunkIdSet));
}
return result;
}
getChildrenOfTypeInOrder(chunkGraph, type) {
const list = [];
for (const group of this.groupsIterable) for (const childGroup of group.childrenIterable) {
const order = childGroup.options[type];
void 0 !== order && list.push({
order,
group,
childGroup
});
}
if (0 === list.length) return;
list.sort(((a, b) => {
const cmp = b.order - a.order;
return 0 !== cmp ? cmp : a.group.compareTo(chunkGraph, b.group);
}));
const result = [];
let lastEntry;
for (const {group, childGroup} of list) if (lastEntry && lastEntry.onChunks === group.chunks) for (const chunk of childGroup.chunks) lastEntry.chunks.add(chunk); else result.push(lastEntry = {
onChunks: group.chunks,
chunks: new Set(childGroup.chunks)
});
return result;
}
getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {
const chunkMaps = Object.create(null), addChildIdsByOrdersToMap = chunk => {
const data = chunk.getChildIdsByOrders(chunkGraph, filterFn);
for (const key of Object.keys(data)) {
let chunkMap = chunkMaps[key];
void 0 === chunkMap && (chunkMaps[key] = chunkMap = Object.create(null)), chunkMap[chunk.id] = data[key];
}
};
if (includeDirectChildren) {
const chunks = new Set;
for (const chunkGroup of this.groupsIterable) for (const chunk of chunkGroup.chunks) chunks.add(chunk);
for (const chunk of chunks) addChildIdsByOrdersToMap(chunk);
}
for (const chunk of this.getAllAsyncChunks()) addChildIdsByOrdersToMap(chunk);
return chunkMaps;
}
};
},
15888: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), Entrypoint = __webpack_require__(7807), ModuleGraphConnection = __webpack_require__(63867), {first} = __webpack_require__(73974), SortableSet = __webpack_require__(72451), {compareModulesById, compareIterables, compareModulesByIdentifier, concatComparators, compareSelect, compareIds} = __webpack_require__(40028), createHash = __webpack_require__(27466), findGraphRoots = __webpack_require__(78739), {RuntimeSpecMap, RuntimeSpecSet, runtimeToString, mergeRuntime, forEachRuntime} = __webpack_require__(14372), EMPTY_SET = new Set, ZERO_BIG_INT = BigInt(0), compareModuleIterables = compareIterables(compareModulesByIdentifier);
class ModuleHashInfo {
constructor(hash, renderedHash) {
this.hash = hash, this.renderedHash = renderedHash;
}
}
const getArray = set => Array.from(set), getModuleRuntimes = chunks => {
const runtimes = new RuntimeSpecSet;
for (const chunk of chunks) runtimes.add(chunk.runtime);
return runtimes;
}, modulesBySourceType = sourceTypesByModule => set => {
const map = new Map;
for (const module of set) {
const sourceTypes = sourceTypesByModule && sourceTypesByModule.get(module) || module.getSourceTypes();
for (const sourceType of sourceTypes) {
let innerSet = map.get(sourceType);
void 0 === innerSet && (innerSet = new SortableSet, map.set(sourceType, innerSet)), 
innerSet.add(module);
}
}
for (const [key, innerSet] of map) innerSet.size === set.size && map.set(key, set);
return map;
}, defaultModulesBySourceType = modulesBySourceType(void 0), createOrderedArrayFunctionMap = new WeakMap, getModulesSize = modules => {
let size = 0;
for (const module of modules) for (const type of module.getSourceTypes()) size += module.size(type);
return size;
}, getModulesSizes = modules => {
let sizes = Object.create(null);
for (const module of modules) for (const type of module.getSourceTypes()) sizes[type] = (sizes[type] || 0) + module.size(type);
return sizes;
}, isAvailableChunk = (a, b) => {
const queue = new Set(b.groupsIterable);
for (const chunkGroup of queue) if (!a.isInGroup(chunkGroup)) {
if (chunkGroup.isInitial()) return !1;
for (const parent of chunkGroup.parentsIterable) queue.add(parent);
}
return !0;
};
class ChunkGraphModule {
constructor() {
this.chunks = new SortableSet, this.entryInChunks = void 0, this.runtimeInChunks = void 0, 
this.hashes = void 0, this.id = null, this.runtimeRequirements = void 0, this.graphHashes = void 0, 
this.graphHashesWithConnections = void 0;
}
}
class ChunkGraphChunk {
constructor() {
this.modules = new SortableSet, this.sourceTypesByModule = void 0, this.entryModules = new Map, 
this.runtimeModules = new SortableSet, this.fullHashModules = void 0, this.dependentHashModules = void 0, 
this.runtimeRequirements = void 0, this.runtimeRequirementsInTree = new Set, this._modulesBySourceType = defaultModulesBySourceType;
}
}
class ChunkGraph {
constructor(moduleGraph, hashFunction = "md4") {
this._modules = new WeakMap, this._chunks = new WeakMap, this._blockChunkGroups = new WeakMap, 
this._runtimeIds = new Map, this.moduleGraph = moduleGraph, this._hashFunction = hashFunction, 
this._getGraphRoots = this._getGraphRoots.bind(this);
}
_getChunkGraphModule(module) {
let cgm = this._modules.get(module);
return void 0 === cgm && (cgm = new ChunkGraphModule, this._modules.set(module, cgm)), 
cgm;
}
_getChunkGraphChunk(chunk) {
let cgc = this._chunks.get(chunk);
return void 0 === cgc && (cgc = new ChunkGraphChunk, this._chunks.set(chunk, cgc)), 
cgc;
}
_getGraphRoots(set) {
const {moduleGraph} = this;
return Array.from(findGraphRoots(set, (module => {
const set = new Set, addDependencies = module => {
for (const connection of moduleGraph.getOutgoingConnections(module)) {
if (!connection.module) continue;
const activeState = connection.getActiveState(void 0);
!1 !== activeState && (activeState !== ModuleGraphConnection.TRANSITIVE_ONLY ? set.add(connection.module) : addDependencies(connection.module));
}
};
return addDependencies(module), set;
}))).sort(compareModulesByIdentifier);
}
connectChunkAndModule(chunk, module) {
const cgm = this._getChunkGraphModule(module), cgc = this._getChunkGraphChunk(chunk);
cgm.chunks.add(chunk), cgc.modules.add(module);
}
disconnectChunkAndModule(chunk, module) {
const cgm = this._getChunkGraphModule(module), cgc = this._getChunkGraphChunk(chunk);
cgc.modules.delete(module), cgc.sourceTypesByModule && cgc.sourceTypesByModule.delete(module), 
cgm.chunks.delete(chunk);
}
disconnectChunk(chunk) {
const cgc = this._getChunkGraphChunk(chunk);
for (const module of cgc.modules) {
this._getChunkGraphModule(module).chunks.delete(chunk);
}
cgc.modules.clear(), chunk.disconnectFromGroups(), ChunkGraph.clearChunkGraphForChunk(chunk);
}
attachModules(chunk, modules) {
const cgc = this._getChunkGraphChunk(chunk);
for (const module of modules) cgc.modules.add(module);
}
attachRuntimeModules(chunk, modules) {
const cgc = this._getChunkGraphChunk(chunk);
for (const module of modules) cgc.runtimeModules.add(module);
}
attachFullHashModules(chunk, modules) {
const cgc = this._getChunkGraphChunk(chunk);
void 0 === cgc.fullHashModules && (cgc.fullHashModules = new Set);
for (const module of modules) cgc.fullHashModules.add(module);
}
attachDependentHashModules(chunk, modules) {
const cgc = this._getChunkGraphChunk(chunk);
void 0 === cgc.dependentHashModules && (cgc.dependentHashModules = new Set);
for (const module of modules) cgc.dependentHashModules.add(module);
}
replaceModule(oldModule, newModule) {
const oldCgm = this._getChunkGraphModule(oldModule), newCgm = this._getChunkGraphModule(newModule);
for (const chunk of oldCgm.chunks) {
const cgc = this._getChunkGraphChunk(chunk);
cgc.modules.delete(oldModule), cgc.modules.add(newModule), newCgm.chunks.add(chunk);
}
if (oldCgm.chunks.clear(), void 0 !== oldCgm.entryInChunks) {
void 0 === newCgm.entryInChunks && (newCgm.entryInChunks = new Set);
for (const chunk of oldCgm.entryInChunks) {
const cgc = this._getChunkGraphChunk(chunk), old = cgc.entryModules.get(oldModule), newEntryModules = new Map;
for (const [m, cg] of cgc.entryModules) m === oldModule ? newEntryModules.set(newModule, old) : newEntryModules.set(m, cg);
cgc.entryModules = newEntryModules, newCgm.entryInChunks.add(chunk);
}
oldCgm.entryInChunks = void 0;
}
if (void 0 !== oldCgm.runtimeInChunks) {
void 0 === newCgm.runtimeInChunks && (newCgm.runtimeInChunks = new Set);
for (const chunk of oldCgm.runtimeInChunks) {
const cgc = this._getChunkGraphChunk(chunk);
cgc.runtimeModules.delete(oldModule), cgc.runtimeModules.add(newModule), newCgm.runtimeInChunks.add(chunk), 
void 0 !== cgc.fullHashModules && cgc.fullHashModules.has(oldModule) && (cgc.fullHashModules.delete(oldModule), 
cgc.fullHashModules.add(newModule)), void 0 !== cgc.dependentHashModules && cgc.dependentHashModules.has(oldModule) && (cgc.dependentHashModules.delete(oldModule), 
cgc.dependentHashModules.add(newModule));
}
oldCgm.runtimeInChunks = void 0;
}
}
isModuleInChunk(module, chunk) {
return this._getChunkGraphChunk(chunk).modules.has(module);
}
isModuleInChunkGroup(module, chunkGroup) {
for (const chunk of chunkGroup.chunks) if (this.isModuleInChunk(module, chunk)) return !0;
return !1;
}
isEntryModule(module) {
return void 0 !== this._getChunkGraphModule(module).entryInChunks;
}
getModuleChunksIterable(module) {
return this._getChunkGraphModule(module).chunks;
}
getOrderedModuleChunksIterable(module, sortFn) {
const cgm = this._getChunkGraphModule(module);
return cgm.chunks.sortWith(sortFn), cgm.chunks;
}
getModuleChunks(module) {
return this._getChunkGraphModule(module).chunks.getFromCache(getArray);
}
getNumberOfModuleChunks(module) {
return this._getChunkGraphModule(module).chunks.size;
}
getModuleRuntimes(module) {
return this._getChunkGraphModule(module).chunks.getFromUnorderedCache(getModuleRuntimes);
}
getNumberOfChunkModules(chunk) {
return this._getChunkGraphChunk(chunk).modules.size;
}
getNumberOfChunkFullHashModules(chunk) {
const cgc = this._getChunkGraphChunk(chunk);
return void 0 === cgc.fullHashModules ? 0 : cgc.fullHashModules.size;
}
getChunkModulesIterable(chunk) {
return this._getChunkGraphChunk(chunk).modules;
}
getChunkModulesIterableBySourceType(chunk, sourceType) {
const cgc = this._getChunkGraphChunk(chunk);
return cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);
}
setChunkModuleSourceTypes(chunk, module, sourceTypes) {
const cgc = this._getChunkGraphChunk(chunk);
void 0 === cgc.sourceTypesByModule && (cgc.sourceTypesByModule = new WeakMap), cgc.sourceTypesByModule.set(module, sourceTypes), 
cgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);
}
getChunkModuleSourceTypes(chunk, module) {
const cgc = this._getChunkGraphChunk(chunk);
return void 0 === cgc.sourceTypesByModule ? module.getSourceTypes() : cgc.sourceTypesByModule.get(module) || module.getSourceTypes();
}
getModuleSourceTypes(module) {
return this._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes();
}
_getOverwrittenModuleSourceTypes(module) {
let sourceTypes, newSet = !1;
for (const chunk of this.getModuleChunksIterable(module)) {
const cgc = this._getChunkGraphChunk(chunk);
if (void 0 === cgc.sourceTypesByModule) return;
const st = cgc.sourceTypesByModule.get(module);
if (void 0 === st) return;
if (sourceTypes) if (newSet) for (const type of st) sourceTypes.add(type); else for (const type of st) newSet ? sourceTypes.add(type) : sourceTypes.has(type) || (newSet = !0, 
sourceTypes = new Set(sourceTypes), sourceTypes.add(type)); else sourceTypes = st;
}
return sourceTypes;
}
getOrderedChunkModulesIterable(chunk, comparator) {
const cgc = this._getChunkGraphChunk(chunk);
return cgc.modules.sortWith(comparator), cgc.modules;
}
getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {
const cgc = this._getChunkGraphChunk(chunk), modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);
if (void 0 !== modulesWithSourceType) return modulesWithSourceType.sortWith(comparator), 
modulesWithSourceType;
}
getChunkModules(chunk) {
return this._getChunkGraphChunk(chunk).modules.getFromUnorderedCache(getArray);
}
getOrderedChunkModules(chunk, comparator) {
const cgc = this._getChunkGraphChunk(chunk), arrayFunction = (comparator => {
let fn = createOrderedArrayFunctionMap.get(comparator);
return void 0 !== fn || (fn = set => (set.sortWith(comparator), Array.from(set)), 
createOrderedArrayFunctionMap.set(comparator, fn)), fn;
})(comparator);
return cgc.modules.getFromUnorderedCache(arrayFunction);
}
getChunkModuleIdMap(chunk, filterFn, includeAllChunks = !1) {
const chunkModuleIdMap = Object.create(null);
for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {
let array;
for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) if (filterFn(module)) {
void 0 === array && (array = [], chunkModuleIdMap[asyncChunk.id] = array);
const moduleId = this.getModuleId(module);
array.push(moduleId);
}
}
return chunkModuleIdMap;
}
getChunkModuleRenderedHashMap(chunk, filterFn, hashLength = 0, includeAllChunks = !1) {
const chunkModuleHashMap = Object.create(null);
for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {
let idToHashMap;
for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) if (filterFn(module)) {
void 0 === idToHashMap && (idToHashMap = Object.create(null), chunkModuleHashMap[asyncChunk.id] = idToHashMap);
const moduleId = this.getModuleId(module), hash = this.getRenderedModuleHash(module, asyncChunk.runtime);
idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;
}
}
return chunkModuleHashMap;
}
getChunkConditionMap(chunk, filterFn) {
const map = Object.create(null);
for (const c of chunk.getAllReferencedChunks()) map[c.id] = filterFn(c, this);
return map;
}
hasModuleInGraph(chunk, filterFn, filterChunkFn) {
const queue = new Set(chunk.groupsIterable), chunksProcessed = new Set;
for (const chunkGroup of queue) {
for (const innerChunk of chunkGroup.chunks) if (!chunksProcessed.has(innerChunk) && (chunksProcessed.add(innerChunk), 
!filterChunkFn || filterChunkFn(innerChunk, this))) for (const module of this.getChunkModulesIterable(innerChunk)) if (filterFn(module)) return !0;
for (const child of chunkGroup.childrenIterable) queue.add(child);
}
return !1;
}
compareChunks(chunkA, chunkB) {
const cgcA = this._getChunkGraphChunk(chunkA), cgcB = this._getChunkGraphChunk(chunkB);
return cgcA.modules.size > cgcB.modules.size ? -1 : cgcA.modules.size < cgcB.modules.size ? 1 : (cgcA.modules.sortWith(compareModulesByIdentifier), 
cgcB.modules.sortWith(compareModulesByIdentifier), compareModuleIterables(cgcA.modules, cgcB.modules));
}
getChunkModulesSize(chunk) {
return this._getChunkGraphChunk(chunk).modules.getFromUnorderedCache(getModulesSize);
}
getChunkModulesSizes(chunk) {
return this._getChunkGraphChunk(chunk).modules.getFromUnorderedCache(getModulesSizes);
}
getChunkRootModules(chunk) {
return this._getChunkGraphChunk(chunk).modules.getFromUnorderedCache(this._getGraphRoots);
}
getChunkSize(chunk, options = {}) {
const modulesSize = this._getChunkGraphChunk(chunk).modules.getFromUnorderedCache(getModulesSize), chunkOverhead = "number" == typeof options.chunkOverhead ? options.chunkOverhead : 1e4, entryChunkMultiplicator = "number" == typeof options.entryChunkMultiplicator ? options.entryChunkMultiplicator : 10;
return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);
}
getIntegratedChunksSize(chunkA, chunkB, options = {}) {
const cgcA = this._getChunkGraphChunk(chunkA), cgcB = this._getChunkGraphChunk(chunkB), allModules = new Set(cgcA.modules);
for (const m of cgcB.modules) allModules.add(m);
let modulesSize = getModulesSize(allModules);
const chunkOverhead = "number" == typeof options.chunkOverhead ? options.chunkOverhead : 1e4, entryChunkMultiplicator = "number" == typeof options.entryChunkMultiplicator ? options.entryChunkMultiplicator : 10;
return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);
}
canChunksBeIntegrated(chunkA, chunkB) {
if (chunkA.preventIntegration || chunkB.preventIntegration) return !1;
const hasRuntimeA = chunkA.hasRuntime(), hasRuntimeB = chunkB.hasRuntime();
return hasRuntimeA !== hasRuntimeB ? hasRuntimeA ? isAvailableChunk(chunkA, chunkB) : !!hasRuntimeB && isAvailableChunk(chunkB, chunkA) : !(this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0);
}
integrateChunks(chunkA, chunkB) {
chunkA.name && chunkB.name ? this.getNumberOfEntryModules(chunkA) > 0 == this.getNumberOfEntryModules(chunkB) > 0 ? chunkA.name.length !== chunkB.name.length ? chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name : chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name : this.getNumberOfEntryModules(chunkB) > 0 && (chunkA.name = chunkB.name) : chunkB.name && (chunkA.name = chunkB.name);
for (const hint of chunkB.idNameHints) chunkA.idNameHints.add(hint);
chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);
for (const module of this.getChunkModules(chunkB)) this.disconnectChunkAndModule(chunkB, module), 
this.connectChunkAndModule(chunkA, module);
for (const [module, chunkGroup] of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB))) this.disconnectChunkAndEntryModule(chunkB, module), 
this.connectChunkAndEntryModule(chunkA, module, chunkGroup);
for (const chunkGroup of chunkB.groupsIterable) chunkGroup.replaceChunk(chunkB, chunkA), 
chunkA.addGroup(chunkGroup), chunkB.removeGroup(chunkGroup);
ChunkGraph.clearChunkGraphForChunk(chunkB);
}
upgradeDependentToFullHashModules(chunk) {
const cgc = this._getChunkGraphChunk(chunk);
if (void 0 !== cgc.dependentHashModules) if (void 0 === cgc.fullHashModules) cgc.fullHashModules = cgc.dependentHashModules; else {
for (const m of cgc.dependentHashModules) cgc.fullHashModules.add(m);
cgc.dependentHashModules = void 0;
}
}
isEntryModuleInChunk(module, chunk) {
return this._getChunkGraphChunk(chunk).entryModules.has(module);
}
connectChunkAndEntryModule(chunk, module, entrypoint) {
const cgm = this._getChunkGraphModule(module), cgc = this._getChunkGraphChunk(chunk);
void 0 === cgm.entryInChunks && (cgm.entryInChunks = new Set), cgm.entryInChunks.add(chunk), 
cgc.entryModules.set(module, entrypoint);
}
connectChunkAndRuntimeModule(chunk, module) {
const cgm = this._getChunkGraphModule(module), cgc = this._getChunkGraphChunk(chunk);
void 0 === cgm.runtimeInChunks && (cgm.runtimeInChunks = new Set), cgm.runtimeInChunks.add(chunk), 
cgc.runtimeModules.add(module);
}
addFullHashModuleToChunk(chunk, module) {
const cgc = this._getChunkGraphChunk(chunk);
void 0 === cgc.fullHashModules && (cgc.fullHashModules = new Set), cgc.fullHashModules.add(module);
}
addDependentHashModuleToChunk(chunk, module) {
const cgc = this._getChunkGraphChunk(chunk);
void 0 === cgc.dependentHashModules && (cgc.dependentHashModules = new Set), cgc.dependentHashModules.add(module);
}
disconnectChunkAndEntryModule(chunk, module) {
const cgm = this._getChunkGraphModule(module), cgc = this._getChunkGraphChunk(chunk);
cgm.entryInChunks.delete(chunk), 0 === cgm.entryInChunks.size && (cgm.entryInChunks = void 0), 
cgc.entryModules.delete(module);
}
disconnectChunkAndRuntimeModule(chunk, module) {
const cgm = this._getChunkGraphModule(module), cgc = this._getChunkGraphChunk(chunk);
cgm.runtimeInChunks.delete(chunk), 0 === cgm.runtimeInChunks.size && (cgm.runtimeInChunks = void 0), 
cgc.runtimeModules.delete(module);
}
disconnectEntryModule(module) {
const cgm = this._getChunkGraphModule(module);
for (const chunk of cgm.entryInChunks) {
this._getChunkGraphChunk(chunk).entryModules.delete(module);
}
cgm.entryInChunks = void 0;
}
disconnectEntries(chunk) {
const cgc = this._getChunkGraphChunk(chunk);
for (const module of cgc.entryModules.keys()) {
const cgm = this._getChunkGraphModule(module);
cgm.entryInChunks.delete(chunk), 0 === cgm.entryInChunks.size && (cgm.entryInChunks = void 0);
}
cgc.entryModules.clear();
}
getNumberOfEntryModules(chunk) {
return this._getChunkGraphChunk(chunk).entryModules.size;
}
getNumberOfRuntimeModules(chunk) {
return this._getChunkGraphChunk(chunk).runtimeModules.size;
}
getChunkEntryModulesIterable(chunk) {
return this._getChunkGraphChunk(chunk).entryModules.keys();
}
getChunkEntryDependentChunksIterable(chunk) {
const set = new Set;
for (const chunkGroup of chunk.groupsIterable) if (chunkGroup instanceof Entrypoint) {
const entrypointChunk = chunkGroup.getEntrypointChunk(), cgc = this._getChunkGraphChunk(entrypointChunk);
for (const chunkGroup of cgc.entryModules.values()) for (const c of chunkGroup.chunks) c === chunk || c === entrypointChunk || c.hasRuntime() || set.add(c);
}
return set;
}
hasChunkEntryDependentChunks(chunk) {
const cgc = this._getChunkGraphChunk(chunk);
for (const chunkGroup of cgc.entryModules.values()) for (const c of chunkGroup.chunks) if (c !== chunk) return !0;
return !1;
}
getChunkRuntimeModulesIterable(chunk) {
return this._getChunkGraphChunk(chunk).runtimeModules;
}
getChunkRuntimeModulesInOrder(chunk) {
const cgc = this._getChunkGraphChunk(chunk), array = Array.from(cgc.runtimeModules);
return array.sort(concatComparators(compareSelect((r => r.stage), compareIds), compareModulesByIdentifier)), 
array;
}
getChunkFullHashModulesIterable(chunk) {
return this._getChunkGraphChunk(chunk).fullHashModules;
}
getChunkFullHashModulesSet(chunk) {
return this._getChunkGraphChunk(chunk).fullHashModules;
}
getChunkDependentHashModulesIterable(chunk) {
return this._getChunkGraphChunk(chunk).dependentHashModules;
}
getChunkEntryModulesWithChunkGroupIterable(chunk) {
return this._getChunkGraphChunk(chunk).entryModules;
}
getBlockChunkGroup(depBlock) {
return this._blockChunkGroups.get(depBlock);
}
connectBlockAndChunkGroup(depBlock, chunkGroup) {
this._blockChunkGroups.set(depBlock, chunkGroup), chunkGroup.addBlock(depBlock);
}
disconnectChunkGroup(chunkGroup) {
for (const block of chunkGroup.blocksIterable) this._blockChunkGroups.delete(block);
chunkGroup._blocks.clear();
}
getModuleId(module) {
return this._getChunkGraphModule(module).id;
}
setModuleId(module, id) {
this._getChunkGraphModule(module).id = id;
}
getRuntimeId(runtime) {
return this._runtimeIds.get(runtime);
}
setRuntimeId(runtime, id) {
this._runtimeIds.set(runtime, id);
}
_getModuleHashInfo(module, hashes, runtime) {
if (hashes) {
if (void 0 === runtime) {
const hashInfoItems = new Set(hashes.values());
if (1 !== hashInfoItems.size) throw new Error(`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(hashes.keys(), (r => runtimeToString(r))).join(", ")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: "global").`);
return first(hashInfoItems);
}
{
const hashInfo = hashes.get(runtime);
if (!hashInfo) throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (available runtimes ${Array.from(hashes.keys(), runtimeToString).join(", ")})`);
return hashInfo;
}
}
throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (hashes not set at all)`);
}
hasModuleHashes(module, runtime) {
const hashes = this._getChunkGraphModule(module).hashes;
return hashes && hashes.has(runtime);
}
getModuleHash(module, runtime) {
const hashes = this._getChunkGraphModule(module).hashes;
return this._getModuleHashInfo(module, hashes, runtime).hash;
}
getRenderedModuleHash(module, runtime) {
const hashes = this._getChunkGraphModule(module).hashes;
return this._getModuleHashInfo(module, hashes, runtime).renderedHash;
}
setModuleHashes(module, runtime, hash, renderedHash) {
const cgm = this._getChunkGraphModule(module);
void 0 === cgm.hashes && (cgm.hashes = new RuntimeSpecMap), cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));
}
addModuleRuntimeRequirements(module, runtime, items, transferOwnership = !0) {
const cgm = this._getChunkGraphModule(module), runtimeRequirementsMap = cgm.runtimeRequirements;
if (void 0 === runtimeRequirementsMap) {
const map = new RuntimeSpecMap;
return map.set(runtime, transferOwnership ? items : new Set(items)), void (cgm.runtimeRequirements = map);
}
runtimeRequirementsMap.update(runtime, (runtimeRequirements => {
if (void 0 === runtimeRequirements) return transferOwnership ? items : new Set(items);
if (!transferOwnership || runtimeRequirements.size >= items.size) {
for (const item of items) runtimeRequirements.add(item);
return runtimeRequirements;
}
for (const item of runtimeRequirements) items.add(item);
return items;
}));
}
addChunkRuntimeRequirements(chunk, items) {
const cgc = this._getChunkGraphChunk(chunk), runtimeRequirements = cgc.runtimeRequirements;
if (void 0 === runtimeRequirements) cgc.runtimeRequirements = items; else if (runtimeRequirements.size >= items.size) for (const item of items) runtimeRequirements.add(item); else {
for (const item of runtimeRequirements) items.add(item);
cgc.runtimeRequirements = items;
}
}
addTreeRuntimeRequirements(chunk, items) {
const runtimeRequirements = this._getChunkGraphChunk(chunk).runtimeRequirementsInTree;
for (const item of items) runtimeRequirements.add(item);
}
getModuleRuntimeRequirements(module, runtime) {
const cgm = this._getChunkGraphModule(module), runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);
return void 0 === runtimeRequirements ? EMPTY_SET : runtimeRequirements;
}
getChunkRuntimeRequirements(chunk) {
const runtimeRequirements = this._getChunkGraphChunk(chunk).runtimeRequirements;
return void 0 === runtimeRequirements ? EMPTY_SET : runtimeRequirements;
}
getModuleGraphHash(module, runtime, withConnections = !0) {
const cgm = this._getChunkGraphModule(module);
return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);
}
getModuleGraphHashBigInt(module, runtime, withConnections = !0) {
const cgm = this._getChunkGraphModule(module);
return withConnections ? BigInt(`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`) : this._getModuleGraphHashBigInt(cgm, module, runtime);
}
_getModuleGraphHashBigInt(cgm, module, runtime) {
void 0 === cgm.graphHashes && (cgm.graphHashes = new RuntimeSpecMap);
return cgm.graphHashes.provide(runtime, (() => {
const hash = createHash(this._hashFunction);
hash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);
const sourceTypes = this._getOverwrittenModuleSourceTypes(module);
if (void 0 !== sourceTypes) for (const type of sourceTypes) hash.update(type);
return this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime), BigInt(`0x${hash.digest("hex")}`);
}));
}
_getModuleGraphHashWithConnections(cgm, module, runtime) {
void 0 === cgm.graphHashesWithConnections && (cgm.graphHashesWithConnections = new RuntimeSpecMap);
const activeStateToString = state => {
if (!1 === state) return "F";
if (!0 === state) return "T";
if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return "O";
throw new Error("Not implemented active state");
}, strict = module.buildMeta && module.buildMeta.strictHarmonyModule;
return cgm.graphHashesWithConnections.provide(runtime, (() => {
const graphHash = this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16), connections = this.moduleGraph.getOutgoingConnections(module), activeNamespaceModules = new Set, connectedModules = new Map, processConnection = (connection, stateInfo) => {
const module = connection.module;
if ("Tnamespace" === (stateInfo += module.getExportsType(this.moduleGraph, strict))) activeNamespaceModules.add(module); else {
const oldModule = connectedModules.get(stateInfo);
void 0 === oldModule ? connectedModules.set(stateInfo, module) : oldModule instanceof Set ? oldModule.add(module) : oldModule !== module && connectedModules.set(stateInfo, new Set([ oldModule, module ]));
}
};
if (void 0 === runtime || "string" == typeof runtime) for (const connection of connections) {
const state = connection.getActiveState(runtime);
!1 !== state && processConnection(connection, !0 === state ? "T" : "O");
} else for (const connection of connections) {
const states = new Set;
let stateInfo = "";
if (forEachRuntime(runtime, (runtime => {
const state = connection.getActiveState(runtime);
states.add(state), stateInfo += activeStateToString(state) + runtime;
}), !0), 1 === states.size) {
const state = first(states);
if (!1 === state) continue;
stateInfo = activeStateToString(state);
}
processConnection(connection, stateInfo);
}
if (0 === activeNamespaceModules.size && 0 === connectedModules.size) return graphHash;
const connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort((([a], [b]) => a < b ? -1 : 1)) : connectedModules, hash = createHash(this._hashFunction), addModuleToHash = module => {
hash.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(module), module, runtime).toString(16));
}, addModulesToHash = modules => {
let xor = ZERO_BIG_INT;
for (const m of modules) xor ^= this._getModuleGraphHashBigInt(this._getChunkGraphModule(m), m, runtime);
hash.update(xor.toString(16));
};
1 === activeNamespaceModules.size ? addModuleToHash(activeNamespaceModules.values().next().value) : activeNamespaceModules.size > 1 && addModulesToHash(activeNamespaceModules);
for (const [stateInfo, modules] of connectedModulesInOrder) hash.update(stateInfo), 
modules instanceof Set ? addModulesToHash(modules) : addModuleToHash(modules);
return hash.update(graphHash), hash.digest("hex");
}));
}
getTreeRuntimeRequirements(chunk) {
return this._getChunkGraphChunk(chunk).runtimeRequirementsInTree;
}
static getChunkGraphForModule(module, deprecateMessage, deprecationCode) {
const fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);
if (fn) return fn(module);
const newFn = util.deprecate((module => {
const chunkGraph = chunkGraphForModuleMap.get(module);
if (!chunkGraph) throw new Error(deprecateMessage + ": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)");
return chunkGraph;
}), deprecateMessage + ": Use new ChunkGraph API", deprecationCode);
return deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn), newFn(module);
}
static setChunkGraphForModule(module, chunkGraph) {
chunkGraphForModuleMap.set(module, chunkGraph);
}
static clearChunkGraphForModule(module) {
chunkGraphForModuleMap.delete(module);
}
static getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {
const fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);
if (fn) return fn(chunk);
const newFn = util.deprecate((chunk => {
const chunkGraph = chunkGraphForChunkMap.get(chunk);
if (!chunkGraph) throw new Error(deprecateMessage + "There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)");
return chunkGraph;
}), deprecateMessage + ": Use new ChunkGraph API", deprecationCode);
return deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn), newFn(chunk);
}
static setChunkGraphForChunk(chunk, chunkGraph) {
chunkGraphForChunkMap.set(chunk, chunkGraph);
}
static clearChunkGraphForChunk(chunk) {
chunkGraphForChunkMap.delete(chunk);
}
}
const chunkGraphForModuleMap = new WeakMap, chunkGraphForChunkMap = new WeakMap, deprecateGetChunkGraphForModuleMap = new Map, deprecateGetChunkGraphForChunkMap = new Map;
module.exports = ChunkGraph;
},
12956: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), SortableSet = __webpack_require__(72451), {compareLocations, compareChunks, compareIterables} = __webpack_require__(40028);
let debugId = 5e3;
const getArray = set => Array.from(set), sortById = (a, b) => a.id < b.id ? -1 : b.id < a.id ? 1 : 0, sortOrigin = (a, b) => {
const aIdent = a.module ? a.module.identifier() : "", bIdent = b.module ? b.module.identifier() : "";
return aIdent < bIdent ? -1 : aIdent > bIdent ? 1 : compareLocations(a.loc, b.loc);
};
class ChunkGroup {
constructor(options) {
"string" == typeof options ? options = {
name: options
} : options || (options = {
name: void 0
}), this.groupDebugId = debugId++, this.options = options, this._children = new SortableSet(void 0, sortById), 
this._parents = new SortableSet(void 0, sortById), this._asyncEntrypoints = new SortableSet(void 0, sortById), 
this._blocks = new SortableSet, this.chunks = [], this.origins = [], this._modulePreOrderIndices = new Map, 
this._modulePostOrderIndices = new Map, this.index = void 0;
}
addOptions(options) {
for (const key of Object.keys(options)) if (void 0 === this.options[key]) this.options[key] = options[key]; else if (this.options[key] !== options[key]) {
if (!key.endsWith("Order")) throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${key}`);
this.options[key] = Math.max(this.options[key], options[key]);
}
}
get name() {
return this.options.name;
}
set name(value) {
this.options.name = value;
}
get debugId() {
return Array.from(this.chunks, (x => x.debugId)).join("+");
}
get id() {
return Array.from(this.chunks, (x => x.id)).join("+");
}
unshiftChunk(chunk) {
const oldIdx = this.chunks.indexOf(chunk);
if (oldIdx > 0) this.chunks.splice(oldIdx, 1), this.chunks.unshift(chunk); else if (oldIdx < 0) return this.chunks.unshift(chunk), 
!0;
return !1;
}
insertChunk(chunk, before) {
const oldIdx = this.chunks.indexOf(chunk), idx = this.chunks.indexOf(before);
if (idx < 0) throw new Error("before chunk not found");
if (oldIdx >= 0 && oldIdx > idx) this.chunks.splice(oldIdx, 1), this.chunks.splice(idx, 0, chunk); else if (oldIdx < 0) return this.chunks.splice(idx, 0, chunk), 
!0;
return !1;
}
pushChunk(chunk) {
return !(this.chunks.indexOf(chunk) >= 0) && (this.chunks.push(chunk), !0);
}
replaceChunk(oldChunk, newChunk) {
const oldIdx = this.chunks.indexOf(oldChunk);
if (oldIdx < 0) return !1;
const newIdx = this.chunks.indexOf(newChunk);
return newIdx < 0 ? (this.chunks[oldIdx] = newChunk, !0) : newIdx < oldIdx ? (this.chunks.splice(oldIdx, 1), 
!0) : newIdx !== oldIdx ? (this.chunks[oldIdx] = newChunk, this.chunks.splice(newIdx, 1), 
!0) : void 0;
}
removeChunk(chunk) {
const idx = this.chunks.indexOf(chunk);
return idx >= 0 && (this.chunks.splice(idx, 1), !0);
}
isInitial() {
return !1;
}
addChild(group) {
const size = this._children.size;
return this._children.add(group), size !== this._children.size;
}
getChildren() {
return this._children.getFromCache(getArray);
}
getNumberOfChildren() {
return this._children.size;
}
get childrenIterable() {
return this._children;
}
removeChild(group) {
return !!this._children.has(group) && (this._children.delete(group), group.removeParent(this), 
!0);
}
addParent(parentChunk) {
return !this._parents.has(parentChunk) && (this._parents.add(parentChunk), !0);
}
getParents() {
return this._parents.getFromCache(getArray);
}
getNumberOfParents() {
return this._parents.size;
}
hasParent(parent) {
return this._parents.has(parent);
}
get parentsIterable() {
return this._parents;
}
removeParent(chunkGroup) {
return !!this._parents.delete(chunkGroup) && (chunkGroup.removeChild(this), !0);
}
addAsyncEntrypoint(entrypoint) {
const size = this._asyncEntrypoints.size;
return this._asyncEntrypoints.add(entrypoint), size !== this._asyncEntrypoints.size;
}
get asyncEntrypointsIterable() {
return this._asyncEntrypoints;
}
getBlocks() {
return this._blocks.getFromCache(getArray);
}
getNumberOfBlocks() {
return this._blocks.size;
}
hasBlock(block) {
return this._blocks.has(block);
}
get blocksIterable() {
return this._blocks;
}
addBlock(block) {
return !this._blocks.has(block) && (this._blocks.add(block), !0);
}
addOrigin(module, loc, request) {
this.origins.push({
module,
loc,
request
});
}
getFiles() {
const files = new Set;
for (const chunk of this.chunks) for (const file of chunk.files) files.add(file);
return Array.from(files);
}
remove() {
for (const parentChunkGroup of this._parents) {
parentChunkGroup._children.delete(this);
for (const chunkGroup of this._children) chunkGroup.addParent(parentChunkGroup), 
parentChunkGroup.addChild(chunkGroup);
}
for (const chunkGroup of this._children) chunkGroup._parents.delete(this);
for (const chunk of this.chunks) chunk.removeGroup(this);
}
sortItems() {
this.origins.sort(sortOrigin);
}
compareTo(chunkGraph, otherGroup) {
return this.chunks.length > otherGroup.chunks.length ? -1 : this.chunks.length < otherGroup.chunks.length ? 1 : compareIterables(compareChunks(chunkGraph))(this.chunks, otherGroup.chunks);
}
getChildrenByOrders(moduleGraph, chunkGraph) {
const lists = new Map;
for (const childGroup of this._children) for (const key of Object.keys(childGroup.options)) if (key.endsWith("Order")) {
const name = key.slice(0, key.length - "Order".length);
let list = lists.get(name);
void 0 === list && lists.set(name, list = []), list.push({
order: childGroup.options[key],
group: childGroup
});
}
const result = Object.create(null);
for (const [name, list] of lists) list.sort(((a, b) => {
const cmp = b.order - a.order;
return 0 !== cmp ? cmp : a.group.compareTo(chunkGraph, b.group);
})), result[name] = list.map((i => i.group));
return result;
}
setModulePreOrderIndex(module, index) {
this._modulePreOrderIndices.set(module, index);
}
getModulePreOrderIndex(module) {
return this._modulePreOrderIndices.get(module);
}
setModulePostOrderIndex(module, index) {
this._modulePostOrderIndices.set(module, index);
}
getModulePostOrderIndex(module) {
return this._modulePostOrderIndices.get(module);
}
checkConstraints() {
const chunk = this;
for (const child of chunk._children) if (!child._parents.has(chunk)) throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);
for (const parentChunk of chunk._parents) if (!parentChunk._children.has(chunk)) throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);
}
}
ChunkGroup.prototype.getModuleIndex = util.deprecate(ChunkGroup.prototype.getModulePreOrderIndex, "ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex", "DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX"), 
ChunkGroup.prototype.getModuleIndex2 = util.deprecate(ChunkGroup.prototype.getModulePostOrderIndex, "ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex", "DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2"), 
module.exports = ChunkGroup;
},
3174: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(chunk, file, error) {
super(), this.name = "ChunkRenderError", this.error = error, this.message = error.message, 
this.details = error.stack, this.file = file, this.chunk = chunk;
}
};
},
59506: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), getJavascriptModulesPlugin = __webpack_require__(98216)((() => __webpack_require__(18362)));
class ChunkTemplate {
constructor(outputOptions, compilation) {
this._outputOptions = outputOptions || {}, this.hooks = Object.freeze({
renderManifest: {
tap: util.deprecate(((options, fn) => {
compilation.hooks.renderManifest.tap(options, ((entries, options) => options.chunk.hasRuntime() ? entries : fn(entries, options)));
}), "ChunkTemplate.hooks.renderManifest is deprecated (use Compilation.hooks.renderManifest instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_RENDER_MANIFEST")
},
modules: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderChunk.tap(options, ((source, renderContext) => fn(source, compilation.moduleTemplates.javascript, renderContext)));
}), "ChunkTemplate.hooks.modules is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderChunk instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_MODULES")
},
render: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderChunk.tap(options, ((source, renderContext) => fn(source, compilation.moduleTemplates.javascript, renderContext)));
}), "ChunkTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderChunk instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_RENDER")
},
renderWithEntry: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).render.tap(options, ((source, renderContext) => 0 === renderContext.chunkGraph.getNumberOfEntryModules(renderContext.chunk) || renderContext.chunk.hasRuntime() ? source : fn(source, renderContext.chunk)));
}), "ChunkTemplate.hooks.renderWithEntry is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_RENDER_WITH_ENTRY")
},
hash: {
tap: util.deprecate(((options, fn) => {
compilation.hooks.fullHash.tap(options, fn);
}), "ChunkTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_HASH")
},
hashForChunk: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).chunkHash.tap(options, ((chunk, hash, context) => {
chunk.hasRuntime() || fn(hash, chunk, context);
}));
}), "ChunkTemplate.hooks.hashForChunk is deprecated (use JavascriptModulesPlugin.getCompilationHooks().chunkHash instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_HASH_FOR_CHUNK")
}
});
}
}
Object.defineProperty(ChunkTemplate.prototype, "outputOptions", {
get: util.deprecate((function() {
return this._outputOptions;
}), "ChunkTemplate.outputOptions is deprecated (use Compilation.outputOptions instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_OUTPUT_OPTIONS")
}), module.exports = ChunkTemplate;
},
32003: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), {SyncBailHook} = __webpack_require__(89991), Compilation = __webpack_require__(62843), createSchemaValidation = __webpack_require__(59586), {join} = __webpack_require__(57075), processAsyncTree = __webpack_require__(21869), validate = createSchemaValidation(void 0, (() => {
const {definitions} = __webpack_require__(46312);
return {
definitions,
oneOf: [ {
$ref: "#/definitions/CleanOptions"
} ]
};
}), {
name: "Clean Plugin",
baseDataPath: "options"
}), mergeAssets = (as1, as2) => {
for (const [key, value1] of as2) {
const value2 = as1.get(key);
(!value2 || value1 > value2) && as1.set(key, value1);
}
}, compilationHooksMap = new WeakMap;
class CleanPlugin {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
keep: new SyncBailHook([ "ignore" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(options = {}) {
validate(options), this.options = {
dry: !1,
...options
};
}
apply(compiler) {
const {dry, keep} = this.options, keepFn = "function" == typeof keep ? keep : "string" == typeof keep ? path => path.startsWith(keep) : "object" == typeof keep && keep.test ? path => keep.test(path) : () => !1;
let oldAssets;
compiler.hooks.emit.tapAsync({
name: "CleanPlugin",
stage: 100
}, ((compilation, callback) => {
const hooks = CleanPlugin.getCompilationHooks(compilation), logger = compilation.getLogger("webpack.CleanPlugin"), fs = compiler.outputFileSystem;
if (!fs.readdir) return callback(new Error("CleanPlugin: Output filesystem doesn't support listing directories (readdir)"));
const currentAssets = new Map, now = Date.now();
for (const asset of Object.keys(compilation.assets)) {
if (/^[A-Za-z]:\\|^\/|^\\\\/.test(asset)) continue;
let normalizedAsset, newNormalizedAsset = asset.replace(/\\/g, "/");
do {
normalizedAsset = newNormalizedAsset, newNormalizedAsset = normalizedAsset.replace(/(^|\/)(?!\.\.)[^/]+\/\.\.\//g, "$1");
} while (newNormalizedAsset !== normalizedAsset);
if (normalizedAsset.startsWith("../")) continue;
const assetInfo = compilation.assetsInfo.get(asset);
assetInfo && assetInfo.hotModuleReplacement ? currentAssets.set(normalizedAsset, now + 1e4) : currentAssets.set(normalizedAsset, 0);
}
const outputPath = compilation.getPath(compiler.outputPath, {}), isKept = path => {
const result = hooks.keep.call(path);
return void 0 !== result ? result : keepFn(path);
}, diffCallback = (err, diff) => {
if (err) return oldAssets = void 0, void callback(err);
((fs, outputPath, dry, logger, diff, isKept, callback) => {
const log = msg => {
dry ? logger.info(msg) : logger.log(msg);
}, jobs = Array.from(diff.keys(), (filename => ({
type: "check",
filename,
parent: void 0
}))), keptAssets = new Map;
processAsyncTree(jobs, 10, (({type, filename, parent}, push, callback) => {
const handleError = err => "ENOENT" === err.code ? (log(`${filename} was removed during cleaning by something else`), 
handleParent(), callback()) : callback(err), handleParent = () => {
parent && 0 == --parent.remaining && push(parent.job);
}, path = join(fs, outputPath, filename);
switch (type) {
case "check":
if (isKept(filename)) return keptAssets.set(filename, 0), log(`${filename} will be kept`), 
process.nextTick(callback);
((fs, filename, callback) => {
"lstat" in fs ? fs.lstat(filename, callback) : fs.stat(filename, callback);
})(fs, path, ((err, stats) => err ? handleError(err) : stats.isDirectory() ? void fs.readdir(path, ((err, entries) => {
if (err) return handleError(err);
const deleteJob = {
type: "rmdir",
filename,
parent
};
if (0 === entries.length) push(deleteJob); else {
const parentToken = {
remaining: entries.length,
job: deleteJob
};
for (const entry of entries) {
const file = entry;
file.startsWith(".") ? log(`${filename} will be kept (dot-files will never be removed)`) : push({
type: "check",
filename: `${filename}/${file}`,
parent: parentToken
});
}
}
return callback();
})) : (push({
type: "unlink",
filename,
parent
}), callback())));
break;

case "rmdir":
if (log(`${filename} will be removed`), dry) return handleParent(), process.nextTick(callback);
if (!fs.rmdir) return logger.warn(`${filename} can't be removed because output file system doesn't support removing directories (rmdir)`), 
process.nextTick(callback);
fs.rmdir(path, (err => {
if (err) return handleError(err);
handleParent(), callback();
}));
break;

case "unlink":
if (log(`${filename} will be removed`), dry) return handleParent(), process.nextTick(callback);
if (!fs.unlink) return logger.warn(`${filename} can't be removed because output file system doesn't support removing files (rmdir)`), 
process.nextTick(callback);
fs.unlink(path, (err => {
if (err) return handleError(err);
handleParent(), callback();
}));
}
}), (err => {
if (err) return callback(err);
callback(void 0, keptAssets);
}));
})(fs, outputPath, dry, logger, diff, isKept, ((err, keptAssets) => {
err ? oldAssets = void 0 : (oldAssets && mergeAssets(currentAssets, oldAssets), 
oldAssets = currentAssets, keptAssets && mergeAssets(oldAssets, keptAssets)), callback(err);
}));
};
oldAssets ? diffCallback(null, ((currentAssets, oldAssets) => {
const diff = new Set, now = Date.now();
for (const [asset, ts] of oldAssets) ts >= now || currentAssets.has(asset) || diff.add(asset);
return diff;
})(currentAssets, oldAssets)) : ((fs, outputPath, currentAssets, callback) => {
const directories = new Set;
for (const [asset] of currentAssets) directories.add(asset.replace(/(^|\/)[^/]*$/, ""));
for (const directory of directories) directories.add(directory.replace(/(^|\/)[^/]*$/, ""));
const diff = new Set;
asyncLib.forEachLimit(directories, 10, ((directory, callback) => {
fs.readdir(join(fs, outputPath, directory), ((err, entries) => {
if (err) return "ENOENT" === err.code ? callback() : "ENOTDIR" === err.code ? (diff.add(directory), 
callback()) : callback(err);
for (const entry of entries) {
const file = entry, filename = directory ? `${directory}/${file}` : file;
directories.has(filename) || currentAssets.has(filename) || diff.add(filename);
}
callback();
}));
}), (err => {
if (err) return callback(err);
callback(null, diff);
}));
})(fs, outputPath, currentAssets, diffCallback);
}));
}
}
module.exports = CleanPlugin;
},
49349: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module, error) {
super(), this.name = "CodeGenerationError", this.error = error, this.message = error.message, 
this.details = error.stack, this.module = module;
}
};
},
59546: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {provide} = __webpack_require__(65783), {first} = __webpack_require__(73974), createHash = __webpack_require__(27466), {runtimeToString, RuntimeSpecMap} = __webpack_require__(14372);
module.exports = class {
constructor(hashFunction = "md4") {
this.map = new Map, this._hashFunction = hashFunction;
}
get(module, runtime) {
const entry = this.map.get(module);
if (void 0 === entry) throw new Error(`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(this.map.keys(), (m => m.identifier())).join(", ")})`);
if (void 0 === runtime) {
if (entry.size > 1) {
const results = new Set(entry.values());
if (1 !== results.size) throw new Error(`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), (r => runtimeToString(r))).join(", ")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: "global").`);
return first(results);
}
return entry.values().next().value;
}
const result = entry.get(runtime);
if (void 0 === result) throw new Error(`No code generation entry for runtime ${runtimeToString(runtime)} for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), (r => runtimeToString(r))).join(", ")})`);
return result;
}
has(module, runtime) {
const entry = this.map.get(module);
if (void 0 === entry) return !1;
if (void 0 !== runtime) return entry.has(runtime);
if (entry.size > 1) {
return 1 === new Set(entry.values()).size;
}
return 1 === entry.size;
}
getSource(module, runtime, sourceType) {
return this.get(module, runtime).sources.get(sourceType);
}
getRuntimeRequirements(module, runtime) {
return this.get(module, runtime).runtimeRequirements;
}
getData(module, runtime, key) {
const data = this.get(module, runtime).data;
return void 0 === data ? void 0 : data.get(key);
}
getHash(module, runtime) {
const info = this.get(module, runtime);
if (void 0 !== info.hash) return info.hash;
const hash = createHash(this._hashFunction);
for (const [type, source] of info.sources) hash.update(type), source.updateHash(hash);
if (info.runtimeRequirements) for (const rr of info.runtimeRequirements) hash.update(rr);
return info.hash = hash.digest("hex");
}
add(module, runtime, result) {
provide(this.map, module, (() => new RuntimeSpecMap)).set(runtime, result);
}
};
},
35931: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class CommentCompilationWarning extends WebpackError {
constructor(message, loc) {
super(message), this.name = "CommentCompilationWarning", this.loc = loc;
}
}
makeSerializable(CommentCompilationWarning, "webpack/lib/CommentCompilationWarning"), 
module.exports = CommentCompilationWarning;
},
97613: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConstDependency = __webpack_require__(30339), nestedWebpackRequireTag = Symbol("nested __webpack_require__");
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("CompatibilityPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template), 
normalModuleFactory.hooks.parser.for("javascript/auto").tap("CompatibilityPlugin", ((parser, parserOptions) => {
(void 0 === parserOptions.browserify || parserOptions.browserify) && parser.hooks.call.for("require").tap("CompatibilityPlugin", (expr => {
if (2 !== expr.arguments.length) return;
const second = parser.evaluateExpression(expr.arguments[1]);
if (!second.isBoolean()) return;
if (!0 !== second.asBool()) return;
const dep = new ConstDependency("require", expr.callee.range);
if (dep.loc = expr.loc, parser.state.current.dependencies.length > 0) {
const last = parser.state.current.dependencies[parser.state.current.dependencies.length - 1];
last.critical && last.options && "." === last.options.request && "." === last.userRequest && last.options.recursive && parser.state.current.dependencies.pop();
}
return parser.state.module.addPresentationalDependency(dep), !0;
}));
}));
const handler = parser => {
parser.hooks.preStatement.tap("CompatibilityPlugin", (statement => {
if ("FunctionDeclaration" === statement.type && statement.id && "__webpack_require__" === statement.id.name) {
const newName = `__nested_webpack_require_${statement.range[0]}__`;
return parser.tagVariable(statement.id.name, nestedWebpackRequireTag, {
name: newName,
declaration: {
updated: !1,
loc: statement.id.loc,
range: statement.id.range
}
}), !0;
}
})), parser.hooks.pattern.for("__webpack_require__").tap("CompatibilityPlugin", (pattern => {
const newName = `__nested_webpack_require_${pattern.range[0]}__`;
return parser.tagVariable(pattern.name, nestedWebpackRequireTag, {
name: newName,
declaration: {
updated: !1,
loc: pattern.loc,
range: pattern.range
}
}), !0;
})), parser.hooks.expression.for(nestedWebpackRequireTag).tap("CompatibilityPlugin", (expr => {
const {name, declaration} = parser.currentTagData;
if (!declaration.updated) {
const dep = new ConstDependency(name, declaration.range);
dep.loc = declaration.loc, parser.state.module.addPresentationalDependency(dep), 
declaration.updated = !0;
}
const dep = new ConstDependency(name, expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.program.tap("CompatibilityPlugin", ((program, comments) => {
if (0 === comments.length) return;
const c = comments[0];
if ("Line" === c.type && 0 === c.range[0]) {
if ("#!" !== parser.state.source.slice(0, 2).toString()) return;
const dep = new ConstDependency("//", 0);
dep.loc = c.loc, parser.state.module.addPresentationalDependency(dep);
}
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("CompatibilityPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("CompatibilityPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("CompatibilityPlugin", handler);
}));
}
};
},
62843: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), {HookMap, SyncHook, SyncBailHook, SyncWaterfallHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncParallelHook} = __webpack_require__(89991), util = __webpack_require__(73837), {CachedSource} = __webpack_require__(37946), {MultiItemCache} = __webpack_require__(87251), Chunk = __webpack_require__(76034), ChunkGraph = __webpack_require__(15888), ChunkGroup = __webpack_require__(12956), ChunkRenderError = __webpack_require__(3174), ChunkTemplate = __webpack_require__(59506), CodeGenerationError = __webpack_require__(49349), CodeGenerationResults = __webpack_require__(59546), Dependency = __webpack_require__(14926), DependencyTemplates = __webpack_require__(92311), Entrypoint = __webpack_require__(7807), ErrorHelpers = __webpack_require__(23516), FileSystemInfo = __webpack_require__(91664), {connectChunkGroupAndChunk, connectChunkGroupParentAndChild} = __webpack_require__(19402), {makeWebpackError, tryRunOrWebpackError} = __webpack_require__(44741), MainTemplate = __webpack_require__(33883), Module = __webpack_require__(36797), ModuleDependencyError = __webpack_require__(760), ModuleDependencyWarning = __webpack_require__(50020), ModuleGraph = __webpack_require__(2197), ModuleHashingError = __webpack_require__(45959), ModuleNotFoundError = __webpack_require__(98674), ModuleProfile = __webpack_require__(40493), ModuleRestoreError = __webpack_require__(47809), ModuleStoreError = __webpack_require__(86193), ModuleTemplate = __webpack_require__(98043), RuntimeGlobals = __webpack_require__(50980), RuntimeTemplate = __webpack_require__(52188), Stats = __webpack_require__(16523), WebpackError = __webpack_require__(64326), buildChunkGraph = __webpack_require__(70383), BuildCycleError = __webpack_require__(24401), {Logger, LogType} = __webpack_require__(20097), StatsFactory = __webpack_require__(98119), StatsPrinter = __webpack_require__(43e3), {equals: arrayEquals} = __webpack_require__(8579), AsyncQueue = __webpack_require__(90756), LazySet = __webpack_require__(92585), {provide} = __webpack_require__(65783), WeakTupleMap = __webpack_require__(39132), {cachedCleverMerge} = __webpack_require__(8639), {compareLocations, concatComparators, compareSelect, compareIds, compareStringsNumeric, compareModulesByIdentifier} = __webpack_require__(40028), createHash = __webpack_require__(27466), {arrayToSetDeprecation, soonFrozenObjectDeprecation, createFakeHook} = __webpack_require__(33469), processAsyncTree = __webpack_require__(21869), {getRuntimeKey} = __webpack_require__(14372), {isSourceEqual} = __webpack_require__(7519), EMPTY_ASSET_INFO = Object.freeze({}), deprecatedNormalModuleLoaderHook = util.deprecate((compilation => __webpack_require__(3213).getCompilationHooks(compilation).loader), "Compilation.hooks.normalModuleLoader was moved to NormalModule.getCompilationHooks(compilation).loader", "DEP_WEBPACK_COMPILATION_NORMAL_MODULE_LOADER_HOOK"), byId = compareSelect((c => c.id), compareIds), byNameOrHash = concatComparators(compareSelect((c => c.name), compareIds), compareSelect((c => c.fullHash), compareIds)), byMessage = compareSelect((err => `${err.message}`), compareStringsNumeric), compareErrors = concatComparators(compareSelect((err => err.module && err.module.identifier() || ""), compareStringsNumeric), compareSelect((err => err.loc), compareLocations), byMessage), unsafeCacheDependencies = new WeakMap, unsafeCacheData = new WeakMap;
class Compilation {
constructor(compiler, params) {
this._backCompat = compiler._backCompat;
const getNormalModuleLoader = () => deprecatedNormalModuleLoaderHook(this), processAssetsHook = new AsyncSeriesHook([ "assets" ]);
let savedAssets = new Set;
const popNewAssets = assets => {
let newAssets;
for (const file of Object.keys(assets)) savedAssets.has(file) || (void 0 === newAssets && (newAssets = Object.create(null)), 
newAssets[file] = assets[file], savedAssets.add(file));
return newAssets;
};
processAssetsHook.intercept({
name: "Compilation",
call: () => {
savedAssets = new Set(Object.keys(this.assets));
},
register: tap => {
const {type, name} = tap, {fn, additionalAssets, ...remainingTap} = tap, additionalAssetsFn = !0 === additionalAssets ? fn : additionalAssets, processedAssets = additionalAssetsFn ? new WeakSet : void 0;
switch (type) {
case "sync":
return additionalAssetsFn && this.hooks.processAdditionalAssets.tap(name, (assets => {
processedAssets.has(this.assets) && additionalAssetsFn(assets);
})), {
...remainingTap,
type: "async",
fn: (assets, callback) => {
try {
fn(assets);
} catch (e) {
return callback(e);
}
void 0 !== processedAssets && processedAssets.add(this.assets);
const newAssets = popNewAssets(assets);
void 0 === newAssets ? callback() : this.hooks.processAdditionalAssets.callAsync(newAssets, callback);
}
};

case "async":
return additionalAssetsFn && this.hooks.processAdditionalAssets.tapAsync(name, ((assets, callback) => {
if (processedAssets.has(this.assets)) return additionalAssetsFn(assets, callback);
callback();
})), {
...remainingTap,
fn: (assets, callback) => {
fn(assets, (err => {
if (err) return callback(err);
void 0 !== processedAssets && processedAssets.add(this.assets);
const newAssets = popNewAssets(assets);
void 0 === newAssets ? callback() : this.hooks.processAdditionalAssets.callAsync(newAssets, callback);
}));
}
};

case "promise":
return additionalAssetsFn && this.hooks.processAdditionalAssets.tapPromise(name, (assets => processedAssets.has(this.assets) ? additionalAssetsFn(assets) : Promise.resolve())), 
{
...remainingTap,
fn: assets => {
const p = fn(assets);
return p && p.then ? p.then((() => {
void 0 !== processedAssets && processedAssets.add(this.assets);
const newAssets = popNewAssets(assets);
if (void 0 !== newAssets) return this.hooks.processAdditionalAssets.promise(newAssets);
})) : p;
}
};
}
}
});
const afterProcessAssetsHook = new SyncHook([ "assets" ]), createProcessAssetsHook = (name, stage, getArgs, code) => {
if (!this._backCompat && code) return;
const errorMessage = reason => `Can't automatically convert plugin using Compilation.hooks.${name} to Compilation.hooks.processAssets because ${reason}.\nBREAKING CHANGE: Asset processing hooks in Compilation has been merged into a single Compilation.hooks.processAssets hook.`, getOptions = options => {
if ("string" == typeof options && (options = {
name: options
}), options.stage) throw new Error(errorMessage("it's using the 'stage' option"));
return {
...options,
stage
};
};
return createFakeHook({
name,
intercept(interceptor) {
throw new Error(errorMessage("it's using 'intercept'"));
},
tap: (options, fn) => {
processAssetsHook.tap(getOptions(options), (() => fn(...getArgs())));
},
tapAsync: (options, fn) => {
processAssetsHook.tapAsync(getOptions(options), ((assets, callback) => fn(...getArgs(), callback)));
},
tapPromise: (options, fn) => {
processAssetsHook.tapPromise(getOptions(options), (() => fn(...getArgs())));
}
}, `${name} is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS_ASSETS_STAGE_* as stage option)`, code);
};
this.hooks = Object.freeze({
buildModule: new SyncHook([ "module" ]),
rebuildModule: new SyncHook([ "module" ]),
failedModule: new SyncHook([ "module", "error" ]),
succeedModule: new SyncHook([ "module" ]),
stillValidModule: new SyncHook([ "module" ]),
addEntry: new SyncHook([ "entry", "options" ]),
failedEntry: new SyncHook([ "entry", "options", "error" ]),
succeedEntry: new SyncHook([ "entry", "options", "module" ]),
dependencyReferencedExports: new SyncWaterfallHook([ "referencedExports", "dependency", "runtime" ]),
executeModule: new SyncHook([ "options", "context" ]),
prepareModuleExecution: new AsyncParallelHook([ "options", "context" ]),
finishModules: new AsyncSeriesHook([ "modules" ]),
finishRebuildingModule: new AsyncSeriesHook([ "module" ]),
unseal: new SyncHook([]),
seal: new SyncHook([]),
beforeChunks: new SyncHook([]),
afterChunks: new SyncHook([ "chunks" ]),
optimizeDependencies: new SyncBailHook([ "modules" ]),
afterOptimizeDependencies: new SyncHook([ "modules" ]),
optimize: new SyncHook([]),
optimizeModules: new SyncBailHook([ "modules" ]),
afterOptimizeModules: new SyncHook([ "modules" ]),
optimizeChunks: new SyncBailHook([ "chunks", "chunkGroups" ]),
afterOptimizeChunks: new SyncHook([ "chunks", "chunkGroups" ]),
optimizeTree: new AsyncSeriesHook([ "chunks", "modules" ]),
afterOptimizeTree: new SyncHook([ "chunks", "modules" ]),
optimizeChunkModules: new AsyncSeriesBailHook([ "chunks", "modules" ]),
afterOptimizeChunkModules: new SyncHook([ "chunks", "modules" ]),
shouldRecord: new SyncBailHook([]),
additionalChunkRuntimeRequirements: new SyncHook([ "chunk", "runtimeRequirements", "context" ]),
runtimeRequirementInChunk: new HookMap((() => new SyncBailHook([ "chunk", "runtimeRequirements", "context" ]))),
additionalModuleRuntimeRequirements: new SyncHook([ "module", "runtimeRequirements", "context" ]),
runtimeRequirementInModule: new HookMap((() => new SyncBailHook([ "module", "runtimeRequirements", "context" ]))),
additionalTreeRuntimeRequirements: new SyncHook([ "chunk", "runtimeRequirements", "context" ]),
runtimeRequirementInTree: new HookMap((() => new SyncBailHook([ "chunk", "runtimeRequirements", "context" ]))),
runtimeModule: new SyncHook([ "module", "chunk" ]),
reviveModules: new SyncHook([ "modules", "records" ]),
beforeModuleIds: new SyncHook([ "modules" ]),
moduleIds: new SyncHook([ "modules" ]),
optimizeModuleIds: new SyncHook([ "modules" ]),
afterOptimizeModuleIds: new SyncHook([ "modules" ]),
reviveChunks: new SyncHook([ "chunks", "records" ]),
beforeChunkIds: new SyncHook([ "chunks" ]),
chunkIds: new SyncHook([ "chunks" ]),
optimizeChunkIds: new SyncHook([ "chunks" ]),
afterOptimizeChunkIds: new SyncHook([ "chunks" ]),
recordModules: new SyncHook([ "modules", "records" ]),
recordChunks: new SyncHook([ "chunks", "records" ]),
optimizeCodeGeneration: new SyncHook([ "modules" ]),
beforeModuleHash: new SyncHook([]),
afterModuleHash: new SyncHook([]),
beforeCodeGeneration: new SyncHook([]),
afterCodeGeneration: new SyncHook([]),
beforeRuntimeRequirements: new SyncHook([]),
afterRuntimeRequirements: new SyncHook([]),
beforeHash: new SyncHook([]),
contentHash: new SyncHook([ "chunk" ]),
afterHash: new SyncHook([]),
recordHash: new SyncHook([ "records" ]),
record: new SyncHook([ "compilation", "records" ]),
beforeModuleAssets: new SyncHook([]),
shouldGenerateChunkAssets: new SyncBailHook([]),
beforeChunkAssets: new SyncHook([]),
additionalChunkAssets: createProcessAssetsHook("additionalChunkAssets", Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL, (() => [ this.chunks ]), "DEP_WEBPACK_COMPILATION_ADDITIONAL_CHUNK_ASSETS"),
additionalAssets: createProcessAssetsHook("additionalAssets", Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL, (() => [])),
optimizeChunkAssets: createProcessAssetsHook("optimizeChunkAssets", Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE, (() => [ this.chunks ]), "DEP_WEBPACK_COMPILATION_OPTIMIZE_CHUNK_ASSETS"),
afterOptimizeChunkAssets: createProcessAssetsHook("afterOptimizeChunkAssets", Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE + 1, (() => [ this.chunks ]), "DEP_WEBPACK_COMPILATION_AFTER_OPTIMIZE_CHUNK_ASSETS"),
optimizeAssets: processAssetsHook,
afterOptimizeAssets: afterProcessAssetsHook,
processAssets: processAssetsHook,
afterProcessAssets: afterProcessAssetsHook,
processAdditionalAssets: new AsyncSeriesHook([ "assets" ]),
needAdditionalSeal: new SyncBailHook([]),
afterSeal: new AsyncSeriesHook([]),
renderManifest: new SyncWaterfallHook([ "result", "options" ]),
fullHash: new SyncHook([ "hash" ]),
chunkHash: new SyncHook([ "chunk", "chunkHash", "ChunkHashContext" ]),
moduleAsset: new SyncHook([ "module", "filename" ]),
chunkAsset: new SyncHook([ "chunk", "filename" ]),
assetPath: new SyncWaterfallHook([ "path", "options", "assetInfo" ]),
needAdditionalPass: new SyncBailHook([]),
childCompiler: new SyncHook([ "childCompiler", "compilerName", "compilerIndex" ]),
log: new SyncBailHook([ "origin", "logEntry" ]),
processWarnings: new SyncWaterfallHook([ "warnings" ]),
processErrors: new SyncWaterfallHook([ "errors" ]),
statsPreset: new HookMap((() => new SyncHook([ "options", "context" ]))),
statsNormalize: new SyncHook([ "options", "context" ]),
statsFactory: new SyncHook([ "statsFactory", "options" ]),
statsPrinter: new SyncHook([ "statsPrinter", "options" ]),
get normalModuleLoader() {
return getNormalModuleLoader();
}
}), this.name = void 0, this.startTime = void 0, this.endTime = void 0, this.compiler = compiler, 
this.resolverFactory = compiler.resolverFactory, this.inputFileSystem = compiler.inputFileSystem, 
this.fileSystemInfo = new FileSystemInfo(this.inputFileSystem, {
managedPaths: compiler.managedPaths,
immutablePaths: compiler.immutablePaths,
logger: this.getLogger("webpack.FileSystemInfo"),
hashFunction: compiler.options.output.hashFunction
}), compiler.fileTimestamps && this.fileSystemInfo.addFileTimestamps(compiler.fileTimestamps, !0), 
compiler.contextTimestamps && this.fileSystemInfo.addContextTimestamps(compiler.contextTimestamps, !0), 
this.valueCacheVersions = new Map, this.requestShortener = compiler.requestShortener, 
this.compilerPath = compiler.compilerPath, this.logger = this.getLogger("webpack.Compilation");
const options = compiler.options;
var moduleTemplates;
this.options = options, this.outputOptions = options && options.output, this.bail = options && options.bail || !1, 
this.profile = options && options.profile || !1, this.params = params, this.mainTemplate = new MainTemplate(this.outputOptions, this), 
this.chunkTemplate = new ChunkTemplate(this.outputOptions, this), this.runtimeTemplate = new RuntimeTemplate(this, this.outputOptions, this.requestShortener), 
this.moduleTemplates = {
javascript: new ModuleTemplate(this.runtimeTemplate, this)
}, moduleTemplates = this.moduleTemplates, Object.defineProperties(moduleTemplates, {
asset: {
enumerable: !1,
configurable: !1,
get: () => {
throw new WebpackError("Compilation.moduleTemplates.asset has been removed");
}
},
webassembly: {
enumerable: !1,
configurable: !1,
get: () => {
throw new WebpackError("Compilation.moduleTemplates.webassembly has been removed");
}
}
}), moduleTemplates = void 0, this.moduleMemCaches = void 0, this.moduleMemCaches2 = void 0, 
this.moduleGraph = new ModuleGraph, this.chunkGraph = void 0, this.codeGenerationResults = void 0, 
this.processDependenciesQueue = new AsyncQueue({
name: "processDependencies",
parallelism: options.parallelism || 100,
processor: this._processModuleDependencies.bind(this)
}), this.addModuleQueue = new AsyncQueue({
name: "addModule",
parent: this.processDependenciesQueue,
getKey: module => module.identifier(),
processor: this._addModule.bind(this)
}), this.factorizeQueue = new AsyncQueue({
name: "factorize",
parent: this.addModuleQueue,
processor: this._factorizeModule.bind(this)
}), this.buildQueue = new AsyncQueue({
name: "build",
parent: this.factorizeQueue,
processor: this._buildModule.bind(this)
}), this.rebuildQueue = new AsyncQueue({
name: "rebuild",
parallelism: options.parallelism || 100,
processor: this._rebuildModule.bind(this)
}), this.creatingModuleDuringBuild = new WeakMap, this.entries = new Map, this.globalEntry = {
dependencies: [],
includeDependencies: [],
options: {
name: void 0
}
}, this.entrypoints = new Map, this.asyncEntrypoints = [], this.chunks = new Set, 
this.chunkGroups = [], this.namedChunkGroups = new Map, this.namedChunks = new Map, 
this.modules = new Set, this._backCompat && (arrayToSetDeprecation(this.chunks, "Compilation.chunks"), 
arrayToSetDeprecation(this.modules, "Compilation.modules")), this._modules = new Map, 
this.records = null, this.additionalChunkAssets = [], this.assets = {}, this.assetsInfo = new Map, 
this._assetsRelatedIn = new Map, this.errors = [], this.warnings = [], this.children = [], 
this.logging = new Map, this.dependencyFactories = new Map, this.dependencyTemplates = new DependencyTemplates(this.outputOptions.hashFunction), 
this.childrenCounters = {}, this.usedChunkIds = null, this.usedModuleIds = null, 
this.needAdditionalPass = !1, this._restoredUnsafeCacheModuleEntries = new Set, 
this._restoredUnsafeCacheEntries = new Map, this.builtModules = new WeakSet, this.codeGeneratedModules = new WeakSet, 
this.buildTimeExecutedModules = new WeakSet, this._rebuildingModules = new Map, 
this.emittedAssets = new Set, this.comparedForEmitAssets = new Set, this.fileDependencies = new LazySet, 
this.contextDependencies = new LazySet, this.missingDependencies = new LazySet, 
this.buildDependencies = new LazySet, this.compilationDependencies = {
add: util.deprecate((item => this.fileDependencies.add(item)), "Compilation.compilationDependencies is deprecated (used Compilation.fileDependencies instead)", "DEP_WEBPACK_COMPILATION_COMPILATION_DEPENDENCIES")
}, this._modulesCache = this.getCache("Compilation/modules"), this._assetsCache = this.getCache("Compilation/assets"), 
this._codeGenerationCache = this.getCache("Compilation/codeGeneration");
const unsafeCache = options.module.unsafeCache;
this._unsafeCache = !!unsafeCache, this._unsafeCachePredicate = "function" == typeof unsafeCache ? unsafeCache : () => !0;
}
getStats() {
return new Stats(this);
}
createStatsOptions(optionsOrPreset, context = {}) {
if ("boolean" != typeof optionsOrPreset && "string" != typeof optionsOrPreset || (optionsOrPreset = {
preset: optionsOrPreset
}), "object" == typeof optionsOrPreset && null !== optionsOrPreset) {
const options = {};
for (const key in optionsOrPreset) options[key] = optionsOrPreset[key];
return void 0 !== options.preset && this.hooks.statsPreset.for(options.preset).call(options, context), 
this.hooks.statsNormalize.call(options, context), options;
}
{
const options = {};
return this.hooks.statsNormalize.call(options, context), options;
}
}
createStatsFactory(options) {
const statsFactory = new StatsFactory;
return this.hooks.statsFactory.call(statsFactory, options), statsFactory;
}
createStatsPrinter(options) {
const statsPrinter = new StatsPrinter;
return this.hooks.statsPrinter.call(statsPrinter, options), statsPrinter;
}
getCache(name) {
return this.compiler.getCache(name);
}
getLogger(name) {
if (!name) throw new TypeError("Compilation.getLogger(name) called without a name");
let logEntries;
return new Logger(((type, args) => {
if ("function" == typeof name && !(name = name())) throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
let trace;
switch (type) {
case LogType.warn:
case LogType.error:
case LogType.trace:
trace = ErrorHelpers.cutOffLoaderExecution(new Error("Trace").stack).split("\n").slice(3);
}
const logEntry = {
time: Date.now(),
type,
args,
trace
};
void 0 === this.hooks.log.call(name, logEntry) && (logEntry.type === LogType.profileEnd && "function" == typeof console.profileEnd && console.profileEnd(`[${name}] ${logEntry.args[0]}`), 
void 0 === logEntries && (logEntries = this.logging.get(name), void 0 === logEntries && (logEntries = [], 
this.logging.set(name, logEntries))), logEntries.push(logEntry), logEntry.type === LogType.profile && "function" == typeof console.profile && console.profile(`[${name}] ${logEntry.args[0]}`));
}), (childName => "function" == typeof name ? "function" == typeof childName ? this.getLogger((() => {
if ("function" == typeof name && !(name = name())) throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
if ("function" == typeof childName && !(childName = childName())) throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
return `${name}/${childName}`;
})) : this.getLogger((() => {
if ("function" == typeof name && !(name = name())) throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
return `${name}/${childName}`;
})) : "function" == typeof childName ? this.getLogger((() => {
if ("function" == typeof childName && !(childName = childName())) throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
return `${name}/${childName}`;
})) : this.getLogger(`${name}/${childName}`)));
}
addModule(module, callback) {
this.addModuleQueue.add(module, callback);
}
_addModule(module, callback) {
const identifier = module.identifier(), alreadyAddedModule = this._modules.get(identifier);
if (alreadyAddedModule) return callback(null, alreadyAddedModule);
const currentProfile = this.profile ? this.moduleGraph.getProfile(module) : void 0;
void 0 !== currentProfile && currentProfile.markRestoringStart(), this._modulesCache.get(identifier, null, ((err, cacheModule) => {
if (err) return callback(new ModuleRestoreError(module, err));
void 0 !== currentProfile && (currentProfile.markRestoringEnd(), currentProfile.markIntegrationStart()), 
cacheModule && (cacheModule.updateCacheModule(module), module = cacheModule), this._modules.set(identifier, module), 
this.modules.add(module), this._backCompat && ModuleGraph.setModuleGraphForModule(module, this.moduleGraph), 
void 0 !== currentProfile && currentProfile.markIntegrationEnd(), callback(null, module);
}));
}
getModule(module) {
const identifier = module.identifier();
return this._modules.get(identifier);
}
findModule(identifier) {
return this._modules.get(identifier);
}
buildModule(module, callback) {
this.buildQueue.add(module, callback);
}
_buildModule(module, callback) {
const currentProfile = this.profile ? this.moduleGraph.getProfile(module) : void 0;
void 0 !== currentProfile && currentProfile.markBuildingStart(), module.needBuild({
compilation: this,
fileSystemInfo: this.fileSystemInfo,
valueCacheVersions: this.valueCacheVersions
}, ((err, needBuild) => err ? callback(err) : needBuild ? (this.hooks.buildModule.call(module), 
this.builtModules.add(module), void module.build(this.options, this, this.resolverFactory.get("normal", module.resolveOptions), this.inputFileSystem, (err => {
if (void 0 !== currentProfile && currentProfile.markBuildingEnd(), err) return this.hooks.failedModule.call(module, err), 
callback(err);
void 0 !== currentProfile && currentProfile.markStoringStart(), this._modulesCache.store(module.identifier(), null, module, (err => (void 0 !== currentProfile && currentProfile.markStoringEnd(), 
err ? (this.hooks.failedModule.call(module, err), callback(new ModuleStoreError(module, err))) : (this.hooks.succeedModule.call(module), 
callback()))));
}))) : (void 0 !== currentProfile && currentProfile.markBuildingEnd(), this.hooks.stillValidModule.call(module), 
callback())));
}
processModuleDependencies(module, callback) {
this.processDependenciesQueue.add(module, callback);
}
processModuleDependenciesNonRecursive(module) {
const processDependenciesBlock = block => {
if (block.dependencies) {
let i = 0;
for (const dep of block.dependencies) this.moduleGraph.setParents(dep, block, module, i++);
}
if (block.blocks) for (const b of block.blocks) processDependenciesBlock(b);
};
processDependenciesBlock(module);
}
_processModuleDependencies(module, callback) {
const sortedDependencies = [];
let currentBlock, dependencies, factoryCacheKey, factoryCacheKey2, factoryCacheValue, listCacheKey1, listCacheKey2, listCacheValue, inProgressSorting = 1, inProgressTransitive = 1;
const onDependenciesSorted = err => {
if (err) return callback(err);
if (0 === sortedDependencies.length && 1 === inProgressTransitive) return callback();
this.processDependenciesQueue.increaseParallelism();
for (const item of sortedDependencies) inProgressTransitive++, this.handleModuleCreation(item, (err => {
if (err && this.bail) {
if (inProgressTransitive <= 0) return;
return inProgressTransitive = -1, err.stack = err.stack, void onTransitiveTasksFinished(err);
}
0 == --inProgressTransitive && onTransitiveTasksFinished();
}));
0 == --inProgressTransitive && onTransitiveTasksFinished();
}, onTransitiveTasksFinished = err => err ? callback(err) : (this.processDependenciesQueue.decreaseParallelism(), 
callback()), processDependency = (dep, index) => {
if (this.moduleGraph.setParents(dep, currentBlock, module, index), this._unsafeCache) try {
const unsafeCachedModule = unsafeCacheDependencies.get(dep);
if (null === unsafeCachedModule) return;
if (void 0 !== unsafeCachedModule) {
if (this._restoredUnsafeCacheModuleEntries.has(unsafeCachedModule)) return void this._handleExistingModuleFromUnsafeCache(module, dep, unsafeCachedModule);
const identifier = unsafeCachedModule.identifier(), cachedModule = this._restoredUnsafeCacheEntries.get(identifier);
return void 0 !== cachedModule ? (unsafeCacheDependencies.set(dep, cachedModule), 
void this._handleExistingModuleFromUnsafeCache(module, dep, cachedModule)) : (inProgressSorting++, 
void this._modulesCache.get(identifier, null, ((err, cachedModule) => {
if (err) {
if (inProgressSorting <= 0) return;
return inProgressSorting = -1, void onDependenciesSorted(err);
}
try {
if (!this._restoredUnsafeCacheEntries.has(identifier)) {
const data = unsafeCacheData.get(cachedModule);
if (void 0 === data) return processDependencyForResolving(dep), void (0 == --inProgressSorting && onDependenciesSorted());
if (cachedModule !== unsafeCachedModule && unsafeCacheDependencies.set(dep, cachedModule), 
cachedModule.restoreFromUnsafeCache(data, this.params.normalModuleFactory, this.params), 
this._restoredUnsafeCacheEntries.set(identifier, cachedModule), this._restoredUnsafeCacheModuleEntries.add(cachedModule), 
!this.modules.has(cachedModule)) return inProgressTransitive++, this._handleNewModuleFromUnsafeCache(module, dep, cachedModule, (err => {
if (err) {
if (inProgressTransitive <= 0) return;
inProgressTransitive = -1, onTransitiveTasksFinished(err);
}
if (0 == --inProgressTransitive) return onTransitiveTasksFinished();
})), void (0 == --inProgressSorting && onDependenciesSorted());
}
unsafeCachedModule !== cachedModule && unsafeCacheDependencies.set(dep, cachedModule), 
this._handleExistingModuleFromUnsafeCache(module, dep, cachedModule);
} catch (err) {
if (inProgressSorting <= 0) return;
return inProgressSorting = -1, void onDependenciesSorted(err);
}
0 == --inProgressSorting && onDependenciesSorted();
})));
}
} catch (e) {
console.error(e);
}
processDependencyForResolving(dep);
}, processDependencyForResolving = dep => {
const resourceIdent = dep.getResourceIdentifier();
if (null != resourceIdent) {
const category = dep.category, constructor = dep.constructor;
if (factoryCacheKey === constructor) {
if (listCacheKey1 === category && listCacheKey2 === resourceIdent) return void listCacheValue.push(dep);
} else {
const factory = this.dependencyFactories.get(constructor);
if (void 0 === factory) throw new Error(`No module factory available for dependency type: ${constructor.name}`);
if (factoryCacheKey2 === factory) {
if (factoryCacheKey = constructor, listCacheKey1 === category && listCacheKey2 === resourceIdent) return void listCacheValue.push(dep);
} else void 0 !== factoryCacheKey2 ? (void 0 === dependencies && (dependencies = new Map), 
dependencies.set(factoryCacheKey2, factoryCacheValue), factoryCacheValue = dependencies.get(factory), 
void 0 === factoryCacheValue && (factoryCacheValue = new Map)) : factoryCacheValue = new Map, 
factoryCacheKey = constructor, factoryCacheKey2 = factory;
}
const cacheKey = "esm" === category ? resourceIdent : `${category}${resourceIdent}`;
let list = factoryCacheValue.get(cacheKey);
void 0 === list && (factoryCacheValue.set(cacheKey, list = []), sortedDependencies.push({
factory: factoryCacheKey2,
dependencies: list,
context: dep.getContext(),
originModule: module
})), list.push(dep), listCacheKey1 = category, listCacheKey2 = resourceIdent, listCacheValue = list;
}
};
try {
const queue = [ module ];
do {
const block = queue.pop();
if (block.dependencies) {
currentBlock = block;
let i = 0;
for (const dep of block.dependencies) processDependency(dep, i++);
}
if (block.blocks) for (const b of block.blocks) queue.push(b);
} while (0 !== queue.length);
} catch (e) {
return callback(e);
}
0 == --inProgressSorting && onDependenciesSorted();
}
_handleNewModuleFromUnsafeCache(originModule, dependency, module, callback) {
const moduleGraph = this.moduleGraph;
moduleGraph.setResolvedModule(originModule, dependency, module), moduleGraph.setIssuerIfUnset(module, void 0 !== originModule ? originModule : null), 
this._modules.set(module.identifier(), module), this.modules.add(module), this._backCompat && ModuleGraph.setModuleGraphForModule(module, this.moduleGraph), 
this._handleModuleBuildAndDependencies(originModule, module, !0, callback);
}
_handleExistingModuleFromUnsafeCache(originModule, dependency, module) {
this.moduleGraph.setResolvedModule(originModule, dependency, module);
}
handleModuleCreation({factory, dependencies, originModule, contextInfo, context, recursive = !0, connectOrigin = recursive}, callback) {
const moduleGraph = this.moduleGraph, currentProfile = this.profile ? new ModuleProfile : void 0;
this.factorizeModule({
currentProfile,
factory,
dependencies,
factoryResult: !0,
originModule,
contextInfo,
context
}, ((err, factoryResult) => {
const applyFactoryResultDependencies = () => {
const {fileDependencies, contextDependencies, missingDependencies} = factoryResult;
fileDependencies && this.fileDependencies.addAll(fileDependencies), contextDependencies && this.contextDependencies.addAll(contextDependencies), 
missingDependencies && this.missingDependencies.addAll(missingDependencies);
};
if (err) return factoryResult && applyFactoryResultDependencies(), dependencies.every((d => d.optional)) ? (this.warnings.push(err), 
callback()) : (this.errors.push(err), callback(err));
const newModule = factoryResult.module;
if (!newModule) return applyFactoryResultDependencies(), callback();
void 0 !== currentProfile && moduleGraph.setProfile(newModule, currentProfile), 
this.addModule(newModule, ((err, module) => {
if (err) return applyFactoryResultDependencies(), err.module || (err.module = module), 
this.errors.push(err), callback(err);
if (this._unsafeCache && !1 !== factoryResult.cacheable && module.restoreFromUnsafeCache && this._unsafeCachePredicate(module)) {
const unsafeCacheableModule = module;
for (let i = 0; i < dependencies.length; i++) {
const dependency = dependencies[i];
moduleGraph.setResolvedModule(connectOrigin ? originModule : null, dependency, unsafeCacheableModule), 
unsafeCacheDependencies.set(dependency, unsafeCacheableModule);
}
unsafeCacheData.has(unsafeCacheableModule) || unsafeCacheData.set(unsafeCacheableModule, unsafeCacheableModule.getUnsafeCacheData());
} else {
applyFactoryResultDependencies();
for (let i = 0; i < dependencies.length; i++) {
const dependency = dependencies[i];
moduleGraph.setResolvedModule(connectOrigin ? originModule : null, dependency, module);
}
}
if (moduleGraph.setIssuerIfUnset(module, void 0 !== originModule ? originModule : null), 
module !== newModule && void 0 !== currentProfile) {
const otherProfile = moduleGraph.getProfile(module);
void 0 !== otherProfile ? currentProfile.mergeInto(otherProfile) : moduleGraph.setProfile(module, currentProfile);
}
this._handleModuleBuildAndDependencies(originModule, module, recursive, callback);
}));
}));
}
_handleModuleBuildAndDependencies(originModule, module, recursive, callback) {
let creatingModuleDuringBuildSet;
if (!recursive && this.buildQueue.isProcessing(originModule)) {
creatingModuleDuringBuildSet = this.creatingModuleDuringBuild.get(originModule), 
void 0 === creatingModuleDuringBuildSet && (creatingModuleDuringBuildSet = new Set, 
this.creatingModuleDuringBuild.set(originModule, creatingModuleDuringBuildSet)), 
creatingModuleDuringBuildSet.add(module);
const blockReasons = this.creatingModuleDuringBuild.get(module);
if (void 0 !== blockReasons) {
const set = new Set(blockReasons);
for (const item of set) {
const blockReasons = this.creatingModuleDuringBuild.get(item);
if (void 0 !== blockReasons) for (const m of blockReasons) {
if (m === module) return callback(new BuildCycleError(module));
set.add(m);
}
}
}
}
this.buildModule(module, (err => (void 0 !== creatingModuleDuringBuildSet && creatingModuleDuringBuildSet.delete(module), 
err ? (err.module || (err.module = module), this.errors.push(err), callback(err)) : recursive ? this.processDependenciesQueue.isProcessing(module) ? callback() : void this.processModuleDependencies(module, (err => {
if (err) return callback(err);
callback(null, module);
})) : (this.processModuleDependenciesNonRecursive(module), void callback(null, module)))));
}
_factorizeModule({currentProfile, factory, dependencies, originModule, factoryResult, contextInfo, context}, callback) {
void 0 !== currentProfile && currentProfile.markFactoryStart(), factory.create({
contextInfo: {
issuer: originModule ? originModule.nameForCondition() : "",
issuerLayer: originModule ? originModule.layer : null,
compiler: this.compiler.name,
...contextInfo
},
resolveOptions: originModule ? originModule.resolveOptions : void 0,
context: context || (originModule ? originModule.context : this.compiler.context),
dependencies
}, ((err, result) => {
if (result && (void 0 === result.module && result instanceof Module && (result = {
module: result
}), !factoryResult)) {
const {fileDependencies, contextDependencies, missingDependencies} = result;
fileDependencies && this.fileDependencies.addAll(fileDependencies), contextDependencies && this.contextDependencies.addAll(contextDependencies), 
missingDependencies && this.missingDependencies.addAll(missingDependencies);
}
if (err) {
const notFoundError = new ModuleNotFoundError(originModule, err, dependencies.map((d => d.loc)).filter(Boolean)[0]);
return callback(notFoundError, factoryResult ? result : void 0);
}
if (!result) return callback();
void 0 !== currentProfile && currentProfile.markFactoryEnd(), callback(null, factoryResult ? result : result.module);
}));
}
addModuleChain(context, dependency, callback) {
return this.addModuleTree({
context,
dependency
}, callback);
}
addModuleTree({context, dependency, contextInfo}, callback) {
if ("object" != typeof dependency || null === dependency || !dependency.constructor) return callback(new WebpackError("Parameter 'dependency' must be a Dependency"));
const Dep = dependency.constructor, moduleFactory = this.dependencyFactories.get(Dep);
if (!moduleFactory) return callback(new WebpackError(`No dependency factory available for this dependency type: ${dependency.constructor.name}`));
this.handleModuleCreation({
factory: moduleFactory,
dependencies: [ dependency ],
originModule: null,
contextInfo,
context
}, ((err, result) => {
err && this.bail ? (callback(err), this.buildQueue.stop(), this.rebuildQueue.stop(), 
this.processDependenciesQueue.stop(), this.factorizeQueue.stop()) : !err && result ? callback(null, result) : callback();
}));
}
addEntry(context, entry, optionsOrName, callback) {
const options = "object" == typeof optionsOrName ? optionsOrName : {
name: optionsOrName
};
this._addEntryItem(context, entry, "dependencies", options, callback);
}
addInclude(context, dependency, options, callback) {
this._addEntryItem(context, dependency, "includeDependencies", options, callback);
}
_addEntryItem(context, entry, target, options, callback) {
const {name} = options;
let entryData = void 0 !== name ? this.entries.get(name) : this.globalEntry;
if (void 0 === entryData) entryData = {
dependencies: [],
includeDependencies: [],
options: {
name: void 0,
...options
}
}, entryData[target].push(entry), this.entries.set(name, entryData); else {
entryData[target].push(entry);
for (const key of Object.keys(options)) if (void 0 !== options[key] && entryData.options[key] !== options[key] && !(Array.isArray(entryData.options[key]) && Array.isArray(options[key]) && arrayEquals(entryData.options[key], options[key]))) {
if (void 0 !== entryData.options[key]) return callback(new WebpackError(`Conflicting entry option ${key} = ${entryData.options[key]} vs ${options[key]}`));
entryData.options[key] = options[key];
}
}
this.hooks.addEntry.call(entry, options), this.addModuleTree({
context,
dependency: entry,
contextInfo: entryData.options.layer ? {
issuerLayer: entryData.options.layer
} : void 0
}, ((err, module) => err ? (this.hooks.failedEntry.call(entry, options, err), callback(err)) : (this.hooks.succeedEntry.call(entry, options, module), 
callback(null, module))));
}
rebuildModule(module, callback) {
this.rebuildQueue.add(module, callback);
}
_rebuildModule(module, callback) {
this.hooks.rebuildModule.call(module);
const oldDependencies = module.dependencies.slice(), oldBlocks = module.blocks.slice();
module.invalidateBuild(), this.buildQueue.invalidate(module), this.buildModule(module, (err => {
if (err) return this.hooks.finishRebuildingModule.callAsync(module, (err2 => {
callback(err2 ? makeWebpackError(err2, "Compilation.hooks.finishRebuildingModule") : err);
}));
this.processDependenciesQueue.invalidate(module), this.moduleGraph.unfreeze(), this.processModuleDependencies(module, (err => {
if (err) return callback(err);
this.removeReasonsOfDependencyBlock(module, {
dependencies: oldDependencies,
blocks: oldBlocks
}), this.hooks.finishRebuildingModule.callAsync(module, (err2 => {
err2 ? callback(makeWebpackError(err2, "Compilation.hooks.finishRebuildingModule")) : callback(null, module);
}));
}));
}));
}
_computeAffectedModules(modules) {
const moduleMemCacheCache = this.compiler.moduleMemCaches;
if (!moduleMemCacheCache) return;
this.moduleMemCaches || (this.moduleMemCaches = new Map, this.moduleGraph.setModuleMemCaches(this.moduleMemCaches));
const {moduleGraph, moduleMemCaches} = this, affectedModules = new Set, infectedModules = new Set;
let statNew = 0, statChanged = 0, statUnchanged = 0, statReferencesChanged = 0, statWithoutBuild = 0;
const computeReferences = module => {
let references;
for (const connection of moduleGraph.getOutgoingConnections(module)) {
const d = connection.dependency, m = connection.module;
d && m && !unsafeCacheDependencies.has(d) && (void 0 === references && (references = new WeakMap), 
references.set(d, m));
}
return references;
}, compareReferences = (module, references) => {
if (void 0 === references) return !0;
for (const connection of moduleGraph.getOutgoingConnections(module)) {
const d = connection.dependency;
if (!d) continue;
const entry = references.get(d);
if (void 0 !== entry && entry !== connection.module) return !1;
}
return !0;
}, modulesWithoutCache = new Set(modules);
for (const [module, cachedMemCache] of moduleMemCacheCache) if (modulesWithoutCache.has(module)) {
const buildInfo = module.buildInfo;
if (buildInfo) if (cachedMemCache.buildInfo !== buildInfo) {
const memCache = new WeakTupleMap;
moduleMemCaches.set(module, memCache), affectedModules.add(module), cachedMemCache.buildInfo = buildInfo, 
cachedMemCache.references = computeReferences(module), cachedMemCache.memCache = memCache, 
statChanged++;
} else if (compareReferences(module, cachedMemCache.references)) moduleMemCaches.set(module, cachedMemCache.memCache), 
statUnchanged++; else {
const memCache = new WeakTupleMap;
moduleMemCaches.set(module, memCache), affectedModules.add(module), cachedMemCache.references = computeReferences(module), 
cachedMemCache.memCache = memCache, statReferencesChanged++;
} else infectedModules.add(module), moduleMemCacheCache.delete(module), statWithoutBuild++;
modulesWithoutCache.delete(module);
} else moduleMemCacheCache.delete(module);
for (const module of modulesWithoutCache) {
const buildInfo = module.buildInfo;
if (buildInfo) {
const memCache = new WeakTupleMap;
moduleMemCacheCache.set(module, {
buildInfo,
references: computeReferences(module),
memCache
}), moduleMemCaches.set(module, memCache), affectedModules.add(module), statNew++;
} else infectedModules.add(module), statWithoutBuild++;
}
const reduceAffectType = connections => {
let affected = !1;
for (const {dependency} of connections) {
if (!dependency) continue;
const type = dependency.couldAffectReferencingModule();
if (type === Dependency.TRANSITIVE) return Dependency.TRANSITIVE;
!1 !== type && (affected = !0);
}
return affected;
}, directOnlyInfectedModules = new Set;
for (const module of infectedModules) for (const [referencingModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {
if (!referencingModule) continue;
if (infectedModules.has(referencingModule)) continue;
const type = reduceAffectType(connections);
type && (!0 === type ? directOnlyInfectedModules.add(referencingModule) : infectedModules.add(referencingModule));
}
for (const module of directOnlyInfectedModules) infectedModules.add(module);
const directOnlyAffectModules = new Set;
for (const module of affectedModules) for (const [referencingModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {
if (!referencingModule) continue;
if (infectedModules.has(referencingModule)) continue;
if (affectedModules.has(referencingModule)) continue;
const type = reduceAffectType(connections);
if (!type) continue;
!0 === type ? directOnlyAffectModules.add(referencingModule) : affectedModules.add(referencingModule);
const memCache = new WeakTupleMap;
moduleMemCacheCache.get(referencingModule).memCache = memCache, moduleMemCaches.set(referencingModule, memCache);
}
for (const module of directOnlyAffectModules) affectedModules.add(module);
this.logger.log(`${Math.round(100 * (affectedModules.size + infectedModules.size) / this.modules.size)}% (${affectedModules.size} affected + ${infectedModules.size} infected of ${this.modules.size}) modules flagged as affected (${statNew} new modules, ${statChanged} changed, ${statReferencesChanged} references changed, ${statUnchanged} unchanged, ${statWithoutBuild} were not built)`);
}
_computeAffectedModulesWithChunkGraph() {
const {moduleMemCaches} = this;
if (!moduleMemCaches) return;
const moduleMemCaches2 = this.moduleMemCaches2 = new Map, {moduleGraph, chunkGraph} = this;
let statUnchanged = 0, statChanged = 0, statNew = 0;
const computeReferences = module => {
const id = chunkGraph.getModuleId(module);
let modules, blocks;
const outgoing = moduleGraph.getOutgoingConnectionsByModule(module);
if (void 0 !== outgoing) for (const m of outgoing.keys()) m && (void 0 === modules && (modules = new Map), 
modules.set(m, chunkGraph.getModuleId(m)));
if (module.blocks.length > 0) {
blocks = [];
const queue = Array.from(module.blocks);
for (const block of queue) {
const chunkGroup = chunkGraph.getBlockChunkGroup(block);
if (chunkGroup) for (const chunk of chunkGroup.chunks) blocks.push(chunk.id); else blocks.push(null);
queue.push.apply(queue, block.blocks);
}
}
return {
id,
modules,
blocks
};
}, compareReferences = (module, {id, modules, blocks}) => {
if (id !== chunkGraph.getModuleId(module)) return !1;
if (void 0 !== modules) for (const [module, id] of modules) if (chunkGraph.getModuleId(module) !== id) return !1;
if (void 0 !== blocks) {
const queue = Array.from(module.blocks);
let i = 0;
for (const block of queue) {
const chunkGroup = chunkGraph.getBlockChunkGroup(block);
if (chunkGroup) {
for (const chunk of chunkGroup.chunks) if (i >= blocks.length || blocks[i++] !== chunk.id) return !1;
} else if (i >= blocks.length || null !== blocks[i++]) return !1;
queue.push.apply(queue, block.blocks);
}
if (i !== blocks.length) return !1;
}
return !0;
};
for (const [module, memCache] of moduleMemCaches) {
const cache = memCache.get("memCache2");
if (void 0 === cache) {
const memCache2 = new WeakTupleMap;
memCache.set("memCache2", {
references: computeReferences(module),
memCache: memCache2
}), moduleMemCaches2.set(module, memCache2), statNew++;
} else if (compareReferences(module, cache.references)) moduleMemCaches2.set(module, cache.memCache), 
statUnchanged++; else {
const memCache = new WeakTupleMap;
cache.references = computeReferences(module), cache.memCache = memCache, moduleMemCaches2.set(module, memCache), 
statChanged++;
}
}
this.logger.log(`${Math.round(100 * statChanged / (statNew + statChanged + statUnchanged))}% modules flagged as affected by chunk graph (${statNew} new modules, ${statChanged} changed, ${statUnchanged} unchanged)`);
}
finish(callback) {
if (this.factorizeQueue.clear(), this.profile) {
this.logger.time("finish module profiles");
const p = new (__webpack_require__(51252)), moduleGraph = this.moduleGraph, modulesWithProfiles = new Map;
for (const module of this.modules) {
const profile = moduleGraph.getProfile(module);
if (profile && (modulesWithProfiles.set(module, profile), p.range(profile.buildingStartTime, profile.buildingEndTime, (f => profile.buildingParallelismFactor = f)), 
p.range(profile.factoryStartTime, profile.factoryEndTime, (f => profile.factoryParallelismFactor = f)), 
p.range(profile.integrationStartTime, profile.integrationEndTime, (f => profile.integrationParallelismFactor = f)), 
p.range(profile.storingStartTime, profile.storingEndTime, (f => profile.storingParallelismFactor = f)), 
p.range(profile.restoringStartTime, profile.restoringEndTime, (f => profile.restoringParallelismFactor = f)), 
profile.additionalFactoryTimes)) for (const {start, end} of profile.additionalFactoryTimes) {
const influence = (end - start) / profile.additionalFactories;
p.range(start, end, (f => profile.additionalFactoriesParallelismFactor += f * influence));
}
}
p.calculate();
const logger = this.getLogger("webpack.Compilation.ModuleProfile"), logByValue = (value, msg) => {
value > 1e3 ? logger.error(msg) : value > 500 ? logger.warn(msg) : value > 200 ? logger.info(msg) : value > 30 ? logger.log(msg) : logger.debug(msg);
}, logNormalSummary = (category, getDuration, getParallelism) => {
let sum = 0, max = 0;
for (const [module, profile] of modulesWithProfiles) {
const p = getParallelism(profile), d = getDuration(profile);
if (0 === d || 0 === p) continue;
const t = d / p;
sum += t, t <= 10 || (logByValue(t, ` | ${Math.round(t)} ms${p >= 1.1 ? ` (parallelism ${Math.round(10 * p) / 10})` : ""} ${category} > ${module.readableIdentifier(this.requestShortener)}`), 
max = Math.max(max, t));
}
sum <= 10 || logByValue(Math.max(sum / 10, max), `${Math.round(sum)} ms ${category}`);
}, logByLoadersSummary = (category, getDuration, getParallelism) => {
const map = new Map;
for (const [module, profile] of modulesWithProfiles) {
provide(map, module.type + "!" + module.identifier().replace(/(!|^)[^!]*$/, ""), (() => [])).push({
module,
profile
});
}
let sum = 0, max = 0;
for (const [key, modules] of map) {
let innerSum = 0, innerMax = 0;
for (const {module, profile} of modules) {
const p = getParallelism(profile), d = getDuration(profile);
if (0 === d || 0 === p) continue;
const t = d / p;
innerSum += t, t <= 10 || (logByValue(t, ` |  | ${Math.round(t)} ms${p >= 1.1 ? ` (parallelism ${Math.round(10 * p) / 10})` : ""} ${category} > ${module.readableIdentifier(this.requestShortener)}`), 
innerMax = Math.max(innerMax, t));
}
if (sum += innerSum, innerSum <= 10) continue;
const idx = key.indexOf("!"), loaders = key.slice(idx + 1), moduleType = key.slice(0, idx), t = Math.max(innerSum / 10, innerMax);
logByValue(t, ` | ${Math.round(innerSum)} ms ${category} > ${loaders ? `${modules.length} x ${moduleType} with ${this.requestShortener.shorten(loaders)}` : `${modules.length} x ${moduleType}`}`), 
max = Math.max(max, t);
}
sum <= 10 || logByValue(Math.max(sum / 10, max), `${Math.round(sum)} ms ${category}`);
};
logNormalSummary("resolve to new modules", (p => p.factory), (p => p.factoryParallelismFactor)), 
logNormalSummary("resolve to existing modules", (p => p.additionalFactories), (p => p.additionalFactoriesParallelismFactor)), 
logNormalSummary("integrate modules", (p => p.restoring), (p => p.restoringParallelismFactor)), 
logByLoadersSummary("build modules", (p => p.building), (p => p.buildingParallelismFactor)), 
logNormalSummary("store modules", (p => p.storing), (p => p.storingParallelismFactor)), 
logNormalSummary("restore modules", (p => p.restoring), (p => p.restoringParallelismFactor)), 
this.logger.timeEnd("finish module profiles");
}
this.logger.time("compute affected modules"), this._computeAffectedModules(this.modules), 
this.logger.timeEnd("compute affected modules"), this.logger.time("finish modules");
const {modules, moduleMemCaches} = this;
this.hooks.finishModules.callAsync(modules, (err => {
if (this.logger.timeEnd("finish modules"), err) return callback(err);
this.moduleGraph.freeze("dependency errors"), this.logger.time("report dependency errors and warnings");
for (const module of modules) {
const memCache = moduleMemCaches && moduleMemCaches.get(module);
if (memCache && memCache.get("noWarningsOrErrors")) continue;
let hasProblems = this.reportDependencyErrorsAndWarnings(module, [ module ]);
const errors = module.getErrors();
if (void 0 !== errors) for (const error of errors) error.module || (error.module = module), 
this.errors.push(error), hasProblems = !0;
const warnings = module.getWarnings();
if (void 0 !== warnings) for (const warning of warnings) warning.module || (warning.module = module), 
this.warnings.push(warning), hasProblems = !0;
!hasProblems && memCache && memCache.set("noWarningsOrErrors", !0);
}
this.moduleGraph.unfreeze(), this.logger.timeEnd("report dependency errors and warnings"), 
callback();
}));
}
unseal() {
this.hooks.unseal.call(), this.chunks.clear(), this.chunkGroups.length = 0, this.namedChunks.clear(), 
this.namedChunkGroups.clear(), this.entrypoints.clear(), this.additionalChunkAssets.length = 0, 
this.assets = {}, this.assetsInfo.clear(), this.moduleGraph.removeAllModuleAttributes(), 
this.moduleGraph.unfreeze(), this.moduleMemCaches2 = void 0;
}
seal(callback) {
const finalCallback = err => (this.factorizeQueue.clear(), this.buildQueue.clear(), 
this.rebuildQueue.clear(), this.processDependenciesQueue.clear(), this.addModuleQueue.clear(), 
callback(err)), chunkGraph = new ChunkGraph(this.moduleGraph, this.outputOptions.hashFunction);
if (this.chunkGraph = chunkGraph, this._backCompat) for (const module of this.modules) ChunkGraph.setChunkGraphForModule(module, chunkGraph);
for (this.hooks.seal.call(), this.logger.time("optimize dependencies"); this.hooks.optimizeDependencies.call(this.modules); ) ;
this.hooks.afterOptimizeDependencies.call(this.modules), this.logger.timeEnd("optimize dependencies"), 
this.logger.time("create chunks"), this.hooks.beforeChunks.call(), this.moduleGraph.freeze("seal");
const chunkGraphInit = new Map;
for (const [name, {dependencies, includeDependencies, options}] of this.entries) {
const chunk = this.addChunk(name);
options.filename && (chunk.filenameTemplate = options.filename);
const entrypoint = new Entrypoint(options);
options.dependOn || options.runtime || entrypoint.setRuntimeChunk(chunk), entrypoint.setEntrypointChunk(chunk), 
this.namedChunkGroups.set(name, entrypoint), this.entrypoints.set(name, entrypoint), 
this.chunkGroups.push(entrypoint), connectChunkGroupAndChunk(entrypoint, chunk);
const entryModules = new Set;
for (const dep of [ ...this.globalEntry.dependencies, ...dependencies ]) {
entrypoint.addOrigin(null, {
name
}, dep.request);
const module = this.moduleGraph.getModule(dep);
if (module) {
chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint), entryModules.add(module);
const modulesList = chunkGraphInit.get(entrypoint);
void 0 === modulesList ? chunkGraphInit.set(entrypoint, [ module ]) : modulesList.push(module);
}
}
this.assignDepths(entryModules);
const mapAndSort = deps => deps.map((dep => this.moduleGraph.getModule(dep))).filter(Boolean).sort(compareModulesByIdentifier), includedModules = [ ...mapAndSort(this.globalEntry.includeDependencies), ...mapAndSort(includeDependencies) ];
let modulesList = chunkGraphInit.get(entrypoint);
void 0 === modulesList && chunkGraphInit.set(entrypoint, modulesList = []);
for (const module of includedModules) this.assignDepth(module), modulesList.push(module);
}
const runtimeChunks = new Set;
outer: for (const [name, {options: {dependOn, runtime}}] of this.entries) {
if (dependOn && runtime) {
const err = new WebpackError(`Entrypoint '${name}' has 'dependOn' and 'runtime' specified. This is not valid.\nEntrypoints that depend on other entrypoints do not have their own runtime.\nThey will use the runtime(s) from referenced entrypoints instead.\nRemove the 'runtime' option from the entrypoint.`), entry = this.entrypoints.get(name);
err.chunk = entry.getEntrypointChunk(), this.errors.push(err);
}
if (dependOn) {
const entry = this.entrypoints.get(name), referencedChunks = entry.getEntrypointChunk().getAllReferencedChunks(), dependOnEntries = [];
for (const dep of dependOn) {
const dependency = this.entrypoints.get(dep);
if (!dependency) throw new Error(`Entry ${name} depends on ${dep}, but this entry was not found`);
if (referencedChunks.has(dependency.getEntrypointChunk())) {
const err = new WebpackError(`Entrypoints '${name}' and '${dep}' use 'dependOn' to depend on each other in a circular way.`), entryChunk = entry.getEntrypointChunk();
err.chunk = entryChunk, this.errors.push(err), entry.setRuntimeChunk(entryChunk);
continue outer;
}
dependOnEntries.push(dependency);
}
for (const dependency of dependOnEntries) connectChunkGroupParentAndChild(dependency, entry);
} else if (runtime) {
const entry = this.entrypoints.get(name);
let chunk = this.namedChunks.get(runtime);
if (chunk) {
if (!runtimeChunks.has(chunk)) {
const err = new WebpackError(`Entrypoint '${name}' has a 'runtime' option which points to another entrypoint named '${runtime}'.\nIt's not valid to use other entrypoints as runtime chunk.\nDid you mean to use 'dependOn: ${JSON.stringify(runtime)}' instead to allow using entrypoint '${name}' within the runtime of entrypoint '${runtime}'? For this '${runtime}' must always be loaded when '${name}' is used.\nOr do you want to use the entrypoints '${name}' and '${runtime}' independently on the same page with a shared runtime? In this case give them both the same value for the 'runtime' option. It must be a name not already used by an entrypoint.`), entryChunk = entry.getEntrypointChunk();
err.chunk = entryChunk, this.errors.push(err), entry.setRuntimeChunk(entryChunk);
continue;
}
} else chunk = this.addChunk(runtime), chunk.preventIntegration = !0, runtimeChunks.add(chunk);
entry.unshiftChunk(chunk), chunk.addGroup(entry), entry.setRuntimeChunk(chunk);
}
}
for (buildChunkGraph(this, chunkGraphInit), this.hooks.afterChunks.call(this.chunks), 
this.logger.timeEnd("create chunks"), this.logger.time("optimize"), this.hooks.optimize.call(); this.hooks.optimizeModules.call(this.modules); ) ;
for (this.hooks.afterOptimizeModules.call(this.modules); this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups); ) ;
this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups), this.hooks.optimizeTree.callAsync(this.chunks, this.modules, (err => {
if (err) return finalCallback(makeWebpackError(err, "Compilation.hooks.optimizeTree"));
this.hooks.afterOptimizeTree.call(this.chunks, this.modules), this.hooks.optimizeChunkModules.callAsync(this.chunks, this.modules, (err => {
if (err) return finalCallback(makeWebpackError(err, "Compilation.hooks.optimizeChunkModules"));
this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);
const shouldRecord = !1 !== this.hooks.shouldRecord.call();
this.hooks.reviveModules.call(this.modules, this.records), this.hooks.beforeModuleIds.call(this.modules), 
this.hooks.moduleIds.call(this.modules), this.hooks.optimizeModuleIds.call(this.modules), 
this.hooks.afterOptimizeModuleIds.call(this.modules), this.hooks.reviveChunks.call(this.chunks, this.records), 
this.hooks.beforeChunkIds.call(this.chunks), this.hooks.chunkIds.call(this.chunks), 
this.hooks.optimizeChunkIds.call(this.chunks), this.hooks.afterOptimizeChunkIds.call(this.chunks), 
this.assignRuntimeIds(), this.logger.time("compute affected modules with chunk graph"), 
this._computeAffectedModulesWithChunkGraph(), this.logger.timeEnd("compute affected modules with chunk graph"), 
this.sortItemsWithChunkIds(), shouldRecord && (this.hooks.recordModules.call(this.modules, this.records), 
this.hooks.recordChunks.call(this.chunks, this.records)), this.hooks.optimizeCodeGeneration.call(this.modules), 
this.logger.timeEnd("optimize"), this.logger.time("module hashing"), this.hooks.beforeModuleHash.call(), 
this.createModuleHashes(), this.hooks.afterModuleHash.call(), this.logger.timeEnd("module hashing"), 
this.logger.time("code generation"), this.hooks.beforeCodeGeneration.call(), this.codeGeneration((err => {
if (err) return finalCallback(err);
this.hooks.afterCodeGeneration.call(), this.logger.timeEnd("code generation"), this.logger.time("runtime requirements"), 
this.hooks.beforeRuntimeRequirements.call(), this.processRuntimeRequirements(), 
this.hooks.afterRuntimeRequirements.call(), this.logger.timeEnd("runtime requirements"), 
this.logger.time("hashing"), this.hooks.beforeHash.call();
const codeGenerationJobs = this.createHash();
this.hooks.afterHash.call(), this.logger.timeEnd("hashing"), this._runCodeGenerationJobs(codeGenerationJobs, (err => {
if (err) return finalCallback(err);
shouldRecord && (this.logger.time("record hash"), this.hooks.recordHash.call(this.records), 
this.logger.timeEnd("record hash")), this.logger.time("module assets"), this.clearAssets(), 
this.hooks.beforeModuleAssets.call(), this.createModuleAssets(), this.logger.timeEnd("module assets");
const cont = () => {
this.logger.time("process assets"), this.hooks.processAssets.callAsync(this.assets, (err => err ? finalCallback(makeWebpackError(err, "Compilation.hooks.processAssets")) : (this.hooks.afterProcessAssets.call(this.assets), 
this.logger.timeEnd("process assets"), this.assets = this._backCompat ? soonFrozenObjectDeprecation(this.assets, "Compilation.assets", "DEP_WEBPACK_COMPILATION_ASSETS", "BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.\n\tDo changes to assets earlier, e. g. in Compilation.hooks.processAssets.\n\tMake sure to select an appropriate stage from Compilation.PROCESS_ASSETS_STAGE_*.") : Object.freeze(this.assets), 
this.summarizeDependencies(), shouldRecord && this.hooks.record.call(this, this.records), 
this.hooks.needAdditionalSeal.call() ? (this.unseal(), this.seal(callback)) : this.hooks.afterSeal.callAsync((err => {
if (err) return finalCallback(makeWebpackError(err, "Compilation.hooks.afterSeal"));
this.fileSystemInfo.logStatistics(), finalCallback();
})))));
};
this.logger.time("create chunk assets"), !1 !== this.hooks.shouldGenerateChunkAssets.call() ? (this.hooks.beforeChunkAssets.call(), 
this.createChunkAssets((err => {
if (this.logger.timeEnd("create chunk assets"), err) return finalCallback(err);
cont();
}))) : (this.logger.timeEnd("create chunk assets"), cont());
}));
}));
}));
}));
}
reportDependencyErrorsAndWarnings(module, blocks) {
let hasProblems = !1;
for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
const block = blocks[indexBlock], dependencies = block.dependencies;
for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {
const d = dependencies[indexDep], warnings = d.getWarnings(this.moduleGraph);
if (warnings) for (let indexWar = 0; indexWar < warnings.length; indexWar++) {
const w = warnings[indexWar], warning = new ModuleDependencyWarning(module, w, d.loc);
this.warnings.push(warning), hasProblems = !0;
}
const errors = d.getErrors(this.moduleGraph);
if (errors) for (let indexErr = 0; indexErr < errors.length; indexErr++) {
const e = errors[indexErr], error = new ModuleDependencyError(module, e, d.loc);
this.errors.push(error), hasProblems = !0;
}
}
this.reportDependencyErrorsAndWarnings(module, block.blocks) && (hasProblems = !0);
}
return hasProblems;
}
codeGeneration(callback) {
const {chunkGraph} = this;
this.codeGenerationResults = new CodeGenerationResults(this.outputOptions.hashFunction);
const jobs = [];
for (const module of this.modules) {
const runtimes = chunkGraph.getModuleRuntimes(module);
if (1 === runtimes.size) for (const runtime of runtimes) {
const hash = chunkGraph.getModuleHash(module, runtime);
jobs.push({
module,
hash,
runtime,
runtimes: [ runtime ]
});
} else if (runtimes.size > 1) {
const map = new Map;
for (const runtime of runtimes) {
const hash = chunkGraph.getModuleHash(module, runtime), job = map.get(hash);
if (void 0 === job) {
const newJob = {
module,
hash,
runtime,
runtimes: [ runtime ]
};
jobs.push(newJob), map.set(hash, newJob);
} else job.runtimes.push(runtime);
}
}
}
this._runCodeGenerationJobs(jobs, callback);
}
_runCodeGenerationJobs(jobs, callback) {
let statModulesFromCache = 0, statModulesGenerated = 0;
const {chunkGraph, moduleGraph, dependencyTemplates, runtimeTemplate} = this, results = this.codeGenerationResults, errors = [];
let notCodeGeneratedModules;
const runIteration = () => {
let delayedJobs = [], delayedModules = new Set;
asyncLib.eachLimit(jobs, this.options.parallelism, ((job, callback) => {
const {module} = job, {codeGenerationDependencies} = module;
if (void 0 !== codeGenerationDependencies && (void 0 === notCodeGeneratedModules || codeGenerationDependencies.some((dep => {
const referencedModule = moduleGraph.getModule(dep);
return notCodeGeneratedModules.has(referencedModule);
})))) return delayedJobs.push(job), delayedModules.add(module), callback();
const {hash, runtime, runtimes} = job;
this._codeGenerationModule(module, runtime, runtimes, hash, dependencyTemplates, chunkGraph, moduleGraph, runtimeTemplate, errors, results, ((err, codeGenerated) => {
codeGenerated ? statModulesGenerated++ : statModulesFromCache++, callback(err);
}));
}), (err => {
if (err) return callback(err);
if (delayedJobs.length > 0) return delayedJobs.length === jobs.length ? callback(new Error(`Unable to make progress during code generation because of circular code generation dependency: ${Array.from(delayedModules, (m => m.identifier())).join(", ")}`)) : (jobs = delayedJobs, 
delayedJobs = [], notCodeGeneratedModules = delayedModules, delayedModules = new Set, 
runIteration());
if (errors.length > 0) {
errors.sort(compareSelect((err => err.module), compareModulesByIdentifier));
for (const error of errors) this.errors.push(error);
}
this.logger.log(`${Math.round(100 * statModulesGenerated / (statModulesGenerated + statModulesFromCache))}% code generated (${statModulesGenerated} generated, ${statModulesFromCache} from cache)`), 
callback();
}));
};
runIteration();
}
_codeGenerationModule(module, runtime, runtimes, hash, dependencyTemplates, chunkGraph, moduleGraph, runtimeTemplate, errors, results, callback) {
let codeGenerated = !1;
const cache = new MultiItemCache(runtimes.map((runtime => this._codeGenerationCache.getItemCache(`${module.identifier()}|${getRuntimeKey(runtime)}`, `${hash}|${dependencyTemplates.getHash()}`))));
cache.get(((err, cachedResult) => {
if (err) return callback(err);
let result;
if (cachedResult) result = cachedResult; else try {
codeGenerated = !0, this.codeGeneratedModules.add(module), result = module.codeGeneration({
chunkGraph,
moduleGraph,
dependencyTemplates,
runtimeTemplate,
runtime,
codeGenerationResults: results,
compilation: this
});
} catch (err) {
errors.push(new CodeGenerationError(module, err)), result = cachedResult = {
sources: new Map,
runtimeRequirements: null
};
}
for (const runtime of runtimes) results.add(module, runtime, result);
cachedResult ? callback(null, codeGenerated) : cache.store(result, (err => callback(err, codeGenerated)));
}));
}
_getChunkGraphEntries() {
const treeEntries = new Set;
for (const ep of this.entrypoints.values()) {
const chunk = ep.getRuntimeChunk();
chunk && treeEntries.add(chunk);
}
for (const ep of this.asyncEntrypoints) {
const chunk = ep.getRuntimeChunk();
chunk && treeEntries.add(chunk);
}
return treeEntries;
}
processRuntimeRequirements({chunkGraph = this.chunkGraph, modules = this.modules, chunks = this.chunks, codeGenerationResults = this.codeGenerationResults, chunkGraphEntries = this._getChunkGraphEntries()} = {}) {
const context = {
chunkGraph,
codeGenerationResults
}, {moduleMemCaches2} = this;
this.logger.time("runtime requirements.modules");
const additionalModuleRuntimeRequirements = this.hooks.additionalModuleRuntimeRequirements, runtimeRequirementInModule = this.hooks.runtimeRequirementInModule;
for (const module of modules) if (chunkGraph.getNumberOfModuleChunks(module) > 0) {
const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
for (const runtime of chunkGraph.getModuleRuntimes(module)) {
if (memCache) {
const cached = memCache.get(`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`);
if (void 0 !== cached) {
null !== cached && chunkGraph.addModuleRuntimeRequirements(module, runtime, cached, !1);
continue;
}
}
let set;
const runtimeRequirements = codeGenerationResults.getRuntimeRequirements(module, runtime);
if (runtimeRequirements && runtimeRequirements.size > 0) set = new Set(runtimeRequirements); else {
if (!additionalModuleRuntimeRequirements.isUsed()) {
memCache && memCache.set(`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`, null);
continue;
}
set = new Set;
}
additionalModuleRuntimeRequirements.call(module, set, context);
for (const r of set) {
const hook = runtimeRequirementInModule.get(r);
void 0 !== hook && hook.call(module, set, context);
}
0 === set.size ? memCache && memCache.set(`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`, null) : memCache ? (memCache.set(`moduleRuntimeRequirements-${getRuntimeKey(runtime)}`, set), 
chunkGraph.addModuleRuntimeRequirements(module, runtime, set, !1)) : chunkGraph.addModuleRuntimeRequirements(module, runtime, set);
}
}
this.logger.timeEnd("runtime requirements.modules"), this.logger.time("runtime requirements.chunks");
for (const chunk of chunks) {
const set = new Set;
for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(module, chunk.runtime);
for (const r of runtimeRequirements) set.add(r);
}
this.hooks.additionalChunkRuntimeRequirements.call(chunk, set, context);
for (const r of set) this.hooks.runtimeRequirementInChunk.for(r).call(chunk, set, context);
chunkGraph.addChunkRuntimeRequirements(chunk, set);
}
this.logger.timeEnd("runtime requirements.chunks"), this.logger.time("runtime requirements.entries");
for (const treeEntry of chunkGraphEntries) {
const set = new Set;
for (const chunk of treeEntry.getAllReferencedChunks()) {
const runtimeRequirements = chunkGraph.getChunkRuntimeRequirements(chunk);
for (const r of runtimeRequirements) set.add(r);
}
this.hooks.additionalTreeRuntimeRequirements.call(treeEntry, set, context);
for (const r of set) this.hooks.runtimeRequirementInTree.for(r).call(treeEntry, set, context);
chunkGraph.addTreeRuntimeRequirements(treeEntry, set);
}
this.logger.timeEnd("runtime requirements.entries");
}
addRuntimeModule(chunk, module, chunkGraph = this.chunkGraph) {
this._backCompat && ModuleGraph.setModuleGraphForModule(module, this.moduleGraph), 
this.modules.add(module), this._modules.set(module.identifier(), module), chunkGraph.connectChunkAndModule(chunk, module), 
chunkGraph.connectChunkAndRuntimeModule(chunk, module), module.fullHash ? chunkGraph.addFullHashModuleToChunk(chunk, module) : module.dependentHash && chunkGraph.addDependentHashModuleToChunk(chunk, module), 
module.attach(this, chunk, chunkGraph);
const exportsInfo = this.moduleGraph.getExportsInfo(module);
if (exportsInfo.setHasProvideInfo(), "string" == typeof chunk.runtime) exportsInfo.setUsedForSideEffectsOnly(chunk.runtime); else if (void 0 === chunk.runtime) exportsInfo.setUsedForSideEffectsOnly(void 0); else for (const runtime of chunk.runtime) exportsInfo.setUsedForSideEffectsOnly(runtime);
chunkGraph.addModuleRuntimeRequirements(module, chunk.runtime, new Set([ RuntimeGlobals.requireScope ])), 
chunkGraph.setModuleId(module, ""), this.hooks.runtimeModule.call(module, chunk);
}
addChunkInGroup(groupOptions, module, loc, request) {
"string" == typeof groupOptions && (groupOptions = {
name: groupOptions
});
const name = groupOptions.name;
if (name) {
const chunkGroup = this.namedChunkGroups.get(name);
if (void 0 !== chunkGroup) return chunkGroup.addOptions(groupOptions), module && chunkGroup.addOrigin(module, loc, request), 
chunkGroup;
}
const chunkGroup = new ChunkGroup(groupOptions);
module && chunkGroup.addOrigin(module, loc, request);
const chunk = this.addChunk(name);
return connectChunkGroupAndChunk(chunkGroup, chunk), this.chunkGroups.push(chunkGroup), 
name && this.namedChunkGroups.set(name, chunkGroup), chunkGroup;
}
addAsyncEntrypoint(options, module, loc, request) {
const name = options.name;
if (name) {
const entrypoint = this.namedChunkGroups.get(name);
if (entrypoint instanceof Entrypoint) {
if (void 0 !== entrypoint) return module && entrypoint.addOrigin(module, loc, request), 
entrypoint;
} else if (entrypoint) throw new Error(`Cannot add an async entrypoint with the name '${name}', because there is already an chunk group with this name`);
}
const chunk = this.addChunk(name);
options.filename && (chunk.filenameTemplate = options.filename);
const entrypoint = new Entrypoint(options, !1);
return entrypoint.setRuntimeChunk(chunk), entrypoint.setEntrypointChunk(chunk), 
name && this.namedChunkGroups.set(name, entrypoint), this.chunkGroups.push(entrypoint), 
this.asyncEntrypoints.push(entrypoint), connectChunkGroupAndChunk(entrypoint, chunk), 
module && entrypoint.addOrigin(module, loc, request), entrypoint;
}
addChunk(name) {
if (name) {
const chunk = this.namedChunks.get(name);
if (void 0 !== chunk) return chunk;
}
const chunk = new Chunk(name, this._backCompat);
return this.chunks.add(chunk), this._backCompat && ChunkGraph.setChunkGraphForChunk(chunk, this.chunkGraph), 
name && this.namedChunks.set(name, chunk), chunk;
}
assignDepth(module) {
const moduleGraph = this.moduleGraph, queue = new Set([ module ]);
let depth;
moduleGraph.setDepth(module, 0);
const processModule = module => {
moduleGraph.setDepthIfLower(module, depth) && queue.add(module);
};
for (module of queue) {
queue.delete(module), depth = moduleGraph.getDepth(module) + 1;
for (const connection of moduleGraph.getOutgoingConnections(module)) {
const refModule = connection.module;
refModule && processModule(refModule);
}
}
}
assignDepths(modules) {
const moduleGraph = this.moduleGraph, queue = new Set(modules);
queue.add(1);
let depth = 0, i = 0;
for (const module of queue) if (i++, "number" == typeof module) {
if (depth = module, queue.size === i) return;
queue.add(depth + 1);
} else {
moduleGraph.setDepth(module, depth);
for (const {module: refModule} of moduleGraph.getOutgoingConnections(module)) refModule && queue.add(refModule);
}
}
getDependencyReferencedExports(dependency, runtime) {
const referencedExports = dependency.getReferencedExports(this.moduleGraph, runtime);
return this.hooks.dependencyReferencedExports.call(referencedExports, dependency, runtime);
}
removeReasonsOfDependencyBlock(module, block) {
if (block.blocks) for (const b of block.blocks) this.removeReasonsOfDependencyBlock(module, b);
if (block.dependencies) for (const dep of block.dependencies) {
const originalModule = this.moduleGraph.getModule(dep);
if (originalModule && (this.moduleGraph.removeConnection(dep), this.chunkGraph)) for (const chunk of this.chunkGraph.getModuleChunks(originalModule)) this.patchChunksAfterReasonRemoval(originalModule, chunk);
}
}
patchChunksAfterReasonRemoval(module, chunk) {
module.hasReasons(this.moduleGraph, chunk.runtime) || this.removeReasonsOfDependencyBlock(module, module), 
module.hasReasonForChunk(chunk, this.moduleGraph, this.chunkGraph) || this.chunkGraph.isModuleInChunk(module, chunk) && (this.chunkGraph.disconnectChunkAndModule(chunk, module), 
this.removeChunkFromDependencies(module, chunk));
}
removeChunkFromDependencies(block, chunk) {
const iteratorDependency = d => {
const depModule = this.moduleGraph.getModule(d);
depModule && this.patchChunksAfterReasonRemoval(depModule, chunk);
}, blocks = block.blocks;
for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
const asyncBlock = blocks[indexBlock], chunkGroup = this.chunkGraph.getBlockChunkGroup(asyncBlock), chunks = chunkGroup.chunks;
for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
const iteratedChunk = chunks[indexChunk];
chunkGroup.removeChunk(iteratedChunk), this.removeChunkFromDependencies(block, iteratedChunk);
}
}
if (block.dependencies) for (const dep of block.dependencies) iteratorDependency(dep);
}
assignRuntimeIds() {
const {chunkGraph} = this, processEntrypoint = ep => {
const runtime = ep.options.runtime || ep.name, chunk = ep.getRuntimeChunk();
chunkGraph.setRuntimeId(runtime, chunk.id);
};
for (const ep of this.entrypoints.values()) processEntrypoint(ep);
for (const ep of this.asyncEntrypoints) processEntrypoint(ep);
}
sortItemsWithChunkIds() {
for (const chunkGroup of this.chunkGroups) chunkGroup.sortItems();
this.errors.sort(compareErrors), this.warnings.sort(compareErrors), this.children.sort(byNameOrHash);
}
summarizeDependencies() {
for (let indexChildren = 0; indexChildren < this.children.length; indexChildren++) {
const child = this.children[indexChildren];
this.fileDependencies.addAll(child.fileDependencies), this.contextDependencies.addAll(child.contextDependencies), 
this.missingDependencies.addAll(child.missingDependencies), this.buildDependencies.addAll(child.buildDependencies);
}
for (const module of this.modules) module.addCacheDependencies(this.fileDependencies, this.contextDependencies, this.missingDependencies, this.buildDependencies);
}
createModuleHashes() {
let statModulesHashed = 0, statModulesFromCache = 0;
const {chunkGraph, runtimeTemplate, moduleMemCaches2} = this, {hashFunction, hashDigest, hashDigestLength} = this.outputOptions, errors = [];
for (const module of this.modules) {
const memCache = moduleMemCaches2 && moduleMemCaches2.get(module);
for (const runtime of chunkGraph.getModuleRuntimes(module)) {
if (memCache) {
const digest = memCache.get(`moduleHash-${getRuntimeKey(runtime)}`);
if (void 0 !== digest) {
chunkGraph.setModuleHashes(module, runtime, digest, digest.slice(0, hashDigestLength)), 
statModulesFromCache++;
continue;
}
}
statModulesHashed++;
const digest = this._createModuleHash(module, chunkGraph, runtime, hashFunction, runtimeTemplate, hashDigest, hashDigestLength, errors);
memCache && memCache.set(`moduleHash-${getRuntimeKey(runtime)}`, digest);
}
}
if (errors.length > 0) {
errors.sort(compareSelect((err => err.module), compareModulesByIdentifier));
for (const error of errors) this.errors.push(error);
}
this.logger.log(`${statModulesHashed} modules hashed, ${statModulesFromCache} from cache (${Math.round(100 * (statModulesHashed + statModulesFromCache) / this.modules.size) / 100} variants per module in average)`);
}
_createModuleHash(module, chunkGraph, runtime, hashFunction, runtimeTemplate, hashDigest, hashDigestLength, errors) {
let moduleHashDigest;
try {
const moduleHash = createHash(hashFunction);
module.updateHash(moduleHash, {
chunkGraph,
runtime,
runtimeTemplate
}), moduleHashDigest = moduleHash.digest(hashDigest);
} catch (err) {
errors.push(new ModuleHashingError(module, err)), moduleHashDigest = "XXXXXX";
}
return chunkGraph.setModuleHashes(module, runtime, moduleHashDigest, moduleHashDigest.slice(0, hashDigestLength)), 
moduleHashDigest;
}
createHash() {
this.logger.time("hashing: initialize hash");
const chunkGraph = this.chunkGraph, runtimeTemplate = this.runtimeTemplate, outputOptions = this.outputOptions, hashFunction = outputOptions.hashFunction, hashDigest = outputOptions.hashDigest, hashDigestLength = outputOptions.hashDigestLength, hash = createHash(hashFunction);
if (outputOptions.hashSalt && hash.update(outputOptions.hashSalt), this.logger.timeEnd("hashing: initialize hash"), 
this.children.length > 0) {
this.logger.time("hashing: hash child compilations");
for (const child of this.children) hash.update(child.hash);
this.logger.timeEnd("hashing: hash child compilations");
}
if (this.warnings.length > 0) {
this.logger.time("hashing: hash warnings");
for (const warning of this.warnings) hash.update(`${warning.message}`);
this.logger.timeEnd("hashing: hash warnings");
}
if (this.errors.length > 0) {
this.logger.time("hashing: hash errors");
for (const error of this.errors) hash.update(`${error.message}`);
this.logger.timeEnd("hashing: hash errors");
}
this.logger.time("hashing: sort chunks");
const unorderedRuntimeChunks = [], otherChunks = [];
for (const c of this.chunks) c.hasRuntime() ? unorderedRuntimeChunks.push(c) : otherChunks.push(c);
unorderedRuntimeChunks.sort(byId), otherChunks.sort(byId);
const runtimeChunksMap = new Map;
for (const chunk of unorderedRuntimeChunks) runtimeChunksMap.set(chunk, {
chunk,
referencedBy: [],
remaining: 0
});
let remaining = 0;
for (const info of runtimeChunksMap.values()) for (const other of new Set(Array.from(info.chunk.getAllReferencedAsyncEntrypoints()).map((e => e.chunks[e.chunks.length - 1])))) {
runtimeChunksMap.get(other).referencedBy.push(info), info.remaining++, remaining++;
}
const runtimeChunks = [];
for (const info of runtimeChunksMap.values()) 0 === info.remaining && runtimeChunks.push(info.chunk);
if (remaining > 0) {
const readyChunks = [];
for (const chunk of runtimeChunks) {
const hasFullHashModules = 0 !== chunkGraph.getNumberOfChunkFullHashModules(chunk), info = runtimeChunksMap.get(chunk);
for (const otherInfo of info.referencedBy) hasFullHashModules && chunkGraph.upgradeDependentToFullHashModules(otherInfo.chunk), 
remaining--, 0 == --otherInfo.remaining && readyChunks.push(otherInfo.chunk);
if (readyChunks.length > 0) {
readyChunks.sort(byId);
for (const c of readyChunks) runtimeChunks.push(c);
readyChunks.length = 0;
}
}
}
if (remaining > 0) {
let circularRuntimeChunkInfo = [];
for (const info of runtimeChunksMap.values()) 0 !== info.remaining && circularRuntimeChunkInfo.push(info);
circularRuntimeChunkInfo.sort(compareSelect((i => i.chunk), byId));
const err = new WebpackError(`Circular dependency between chunks with runtime (${Array.from(circularRuntimeChunkInfo, (c => c.chunk.name || c.chunk.id)).join(", ")})\nThis prevents using hashes of each other and should be avoided.`);
err.chunk = circularRuntimeChunkInfo[0].chunk, this.warnings.push(err);
for (const i of circularRuntimeChunkInfo) runtimeChunks.push(i.chunk);
}
this.logger.timeEnd("hashing: sort chunks");
const fullHashChunks = new Set, codeGenerationJobs = [], codeGenerationJobsMap = new Map, errors = [], processChunk = chunk => {
this.logger.time("hashing: hash runtime modules");
const runtime = chunk.runtime;
for (const module of chunkGraph.getChunkModulesIterable(chunk)) if (!chunkGraph.hasModuleHashes(module, runtime)) {
const hash = this._createModuleHash(module, chunkGraph, runtime, hashFunction, runtimeTemplate, hashDigest, hashDigestLength, errors);
let hashMap = codeGenerationJobsMap.get(hash);
if (hashMap) {
const moduleJob = hashMap.get(module);
if (moduleJob) {
moduleJob.runtimes.push(runtime);
continue;
}
} else hashMap = new Map, codeGenerationJobsMap.set(hash, hashMap);
const job = {
module,
hash,
runtime,
runtimes: [ runtime ]
};
hashMap.set(module, job), codeGenerationJobs.push(job);
}
this.logger.timeAggregate("hashing: hash runtime modules");
try {
this.logger.time("hashing: hash chunks");
const chunkHash = createHash(hashFunction);
outputOptions.hashSalt && chunkHash.update(outputOptions.hashSalt), chunk.updateHash(chunkHash, chunkGraph), 
this.hooks.chunkHash.call(chunk, chunkHash, {
chunkGraph,
codeGenerationResults: this.codeGenerationResults,
moduleGraph: this.moduleGraph,
runtimeTemplate: this.runtimeTemplate
});
const chunkHashDigest = chunkHash.digest(hashDigest);
hash.update(chunkHashDigest), chunk.hash = chunkHashDigest, chunk.renderedHash = chunk.hash.slice(0, hashDigestLength);
chunkGraph.getChunkFullHashModulesIterable(chunk) ? fullHashChunks.add(chunk) : this.hooks.contentHash.call(chunk);
} catch (err) {
this.errors.push(new ChunkRenderError(chunk, "", err));
}
this.logger.timeAggregate("hashing: hash chunks");
};
otherChunks.forEach(processChunk);
for (const chunk of runtimeChunks) processChunk(chunk);
if (errors.length > 0) {
errors.sort(compareSelect((err => err.module), compareModulesByIdentifier));
for (const error of errors) this.errors.push(error);
}
this.logger.timeAggregateEnd("hashing: hash runtime modules"), this.logger.timeAggregateEnd("hashing: hash chunks"), 
this.logger.time("hashing: hash digest"), this.hooks.fullHash.call(hash), this.fullHash = hash.digest(hashDigest), 
this.hash = this.fullHash.slice(0, hashDigestLength), this.logger.timeEnd("hashing: hash digest"), 
this.logger.time("hashing: process full hash modules");
for (const chunk of fullHashChunks) {
for (const module of chunkGraph.getChunkFullHashModulesIterable(chunk)) {
const moduleHash = createHash(hashFunction);
module.updateHash(moduleHash, {
chunkGraph,
runtime: chunk.runtime,
runtimeTemplate
});
const moduleHashDigest = moduleHash.digest(hashDigest), oldHash = chunkGraph.getModuleHash(module, chunk.runtime);
chunkGraph.setModuleHashes(module, chunk.runtime, moduleHashDigest, moduleHashDigest.slice(0, hashDigestLength)), 
codeGenerationJobsMap.get(oldHash).get(module).hash = moduleHashDigest;
}
const chunkHash = createHash(hashFunction);
chunkHash.update(chunk.hash), chunkHash.update(this.hash);
const chunkHashDigest = chunkHash.digest(hashDigest);
chunk.hash = chunkHashDigest, chunk.renderedHash = chunk.hash.slice(0, hashDigestLength), 
this.hooks.contentHash.call(chunk);
}
return this.logger.timeEnd("hashing: process full hash modules"), codeGenerationJobs;
}
emitAsset(file, source, assetInfo = {}) {
if (this.assets[file]) {
if (!isSourceEqual(this.assets[file], source)) return this.errors.push(new WebpackError(`Conflict: Multiple assets emit different content to the same filename ${file}${assetInfo.sourceFilename ? `. Original source ${assetInfo.sourceFilename}` : ""}`)), 
this.assets[file] = source, void this._setAssetInfo(file, assetInfo);
const oldInfo = this.assetsInfo.get(file), newInfo = Object.assign({}, oldInfo, assetInfo);
this._setAssetInfo(file, newInfo, oldInfo);
} else this.assets[file] = source, this._setAssetInfo(file, assetInfo, void 0);
}
_setAssetInfo(file, newInfo, oldInfo = this.assetsInfo.get(file)) {
void 0 === newInfo ? this.assetsInfo.delete(file) : this.assetsInfo.set(file, newInfo);
const oldRelated = oldInfo && oldInfo.related, newRelated = newInfo && newInfo.related;
if (oldRelated) for (const key of Object.keys(oldRelated)) {
const remove = name => {
const relatedIn = this._assetsRelatedIn.get(name);
if (void 0 === relatedIn) return;
const entry = relatedIn.get(key);
void 0 !== entry && (entry.delete(file), 0 === entry.size && (relatedIn.delete(key), 
0 === relatedIn.size && this._assetsRelatedIn.delete(name)));
}, entry = oldRelated[key];
Array.isArray(entry) ? entry.forEach(remove) : entry && remove(entry);
}
if (newRelated) for (const key of Object.keys(newRelated)) {
const add = name => {
let relatedIn = this._assetsRelatedIn.get(name);
void 0 === relatedIn && this._assetsRelatedIn.set(name, relatedIn = new Map);
let entry = relatedIn.get(key);
void 0 === entry && relatedIn.set(key, entry = new Set), entry.add(file);
}, entry = newRelated[key];
Array.isArray(entry) ? entry.forEach(add) : entry && add(entry);
}
}
updateAsset(file, newSourceOrFunction, assetInfoUpdateOrFunction) {
if (!this.assets[file]) throw new Error(`Called Compilation.updateAsset for not existing filename ${file}`);
if (this.assets[file] = "function" == typeof newSourceOrFunction ? newSourceOrFunction(this.assets[file]) : newSourceOrFunction, 
void 0 !== assetInfoUpdateOrFunction) {
const oldInfo = this.assetsInfo.get(file) || EMPTY_ASSET_INFO;
"function" == typeof assetInfoUpdateOrFunction ? this._setAssetInfo(file, assetInfoUpdateOrFunction(oldInfo), oldInfo) : this._setAssetInfo(file, cachedCleverMerge(oldInfo, assetInfoUpdateOrFunction), oldInfo);
}
}
renameAsset(file, newFile) {
const source = this.assets[file];
if (!source) throw new Error(`Called Compilation.renameAsset for not existing filename ${file}`);
this.assets[newFile] && (isSourceEqual(this.assets[file], source) || this.errors.push(new WebpackError(`Conflict: Called Compilation.renameAsset for already existing filename ${newFile} with different content`)));
const assetInfo = this.assetsInfo.get(file), relatedInInfo = this._assetsRelatedIn.get(file);
if (relatedInInfo) for (const [key, assets] of relatedInInfo) for (const name of assets) {
const info = this.assetsInfo.get(name);
if (!info) continue;
const related = info.related;
if (!related) continue;
const entry = related[key];
let newEntry;
if (Array.isArray(entry)) newEntry = entry.map((x => x === file ? newFile : x)); else {
if (entry !== file) continue;
newEntry = newFile;
}
this.assetsInfo.set(name, {
...info,
related: {
...related,
[key]: newEntry
}
});
}
this._setAssetInfo(file, void 0, assetInfo), this._setAssetInfo(newFile, assetInfo), 
delete this.assets[file], this.assets[newFile] = source;
for (const chunk of this.chunks) {
{
const size = chunk.files.size;
chunk.files.delete(file), size !== chunk.files.size && chunk.files.add(newFile);
}
{
const size = chunk.auxiliaryFiles.size;
chunk.auxiliaryFiles.delete(file), size !== chunk.auxiliaryFiles.size && chunk.auxiliaryFiles.add(newFile);
}
}
}
deleteAsset(file) {
if (!this.assets[file]) return;
delete this.assets[file];
const assetInfo = this.assetsInfo.get(file);
this._setAssetInfo(file, void 0, assetInfo);
const related = assetInfo && assetInfo.related;
if (related) for (const key of Object.keys(related)) {
const checkUsedAndDelete = file => {
this._assetsRelatedIn.has(file) || this.deleteAsset(file);
}, items = related[key];
Array.isArray(items) ? items.forEach(checkUsedAndDelete) : items && checkUsedAndDelete(items);
}
for (const chunk of this.chunks) chunk.files.delete(file), chunk.auxiliaryFiles.delete(file);
}
getAssets() {
const array = [];
for (const assetName of Object.keys(this.assets)) Object.prototype.hasOwnProperty.call(this.assets, assetName) && array.push({
name: assetName,
source: this.assets[assetName],
info: this.assetsInfo.get(assetName) || EMPTY_ASSET_INFO
});
return array;
}
getAsset(name) {
if (Object.prototype.hasOwnProperty.call(this.assets, name)) return {
name,
source: this.assets[name],
info: this.assetsInfo.get(name) || EMPTY_ASSET_INFO
};
}
clearAssets() {
for (const chunk of this.chunks) chunk.files.clear(), chunk.auxiliaryFiles.clear();
}
createModuleAssets() {
const {chunkGraph} = this;
for (const module of this.modules) if (module.buildInfo.assets) {
const assetsInfo = module.buildInfo.assetsInfo;
for (const assetName of Object.keys(module.buildInfo.assets)) {
const fileName = this.getPath(assetName, {
chunkGraph: this.chunkGraph,
module
});
for (const chunk of chunkGraph.getModuleChunksIterable(module)) chunk.auxiliaryFiles.add(fileName);
this.emitAsset(fileName, module.buildInfo.assets[assetName], assetsInfo ? assetsInfo.get(assetName) : void 0), 
this.hooks.moduleAsset.call(module, fileName);
}
}
}
getRenderManifest(options) {
return this.hooks.renderManifest.call([], options);
}
createChunkAssets(callback) {
const outputOptions = this.outputOptions, cachedSourceMap = new WeakMap, alreadyWrittenFiles = new Map;
asyncLib.forEachLimit(this.chunks, 15, ((chunk, callback) => {
let manifest;
try {
manifest = this.getRenderManifest({
chunk,
hash: this.hash,
fullHash: this.fullHash,
outputOptions,
codeGenerationResults: this.codeGenerationResults,
moduleTemplates: this.moduleTemplates,
dependencyTemplates: this.dependencyTemplates,
chunkGraph: this.chunkGraph,
moduleGraph: this.moduleGraph,
runtimeTemplate: this.runtimeTemplate
});
} catch (err) {
return this.errors.push(new ChunkRenderError(chunk, "", err)), callback();
}
asyncLib.forEach(manifest, ((fileManifest, callback) => {
const ident = fileManifest.identifier, usedHash = fileManifest.hash, assetCacheItem = this._assetsCache.getItemCache(ident, usedHash);
assetCacheItem.get(((err, sourceFromCache) => {
let filenameTemplate, file, assetInfo, inTry = !0;
const errorAndCallback = err => {
const filename = file || ("string" == typeof file ? file : "string" == typeof filenameTemplate ? filenameTemplate : "");
return this.errors.push(new ChunkRenderError(chunk, filename, err)), inTry = !1, 
callback();
};
try {
if ("filename" in fileManifest) file = fileManifest.filename, assetInfo = fileManifest.info; else {
filenameTemplate = fileManifest.filenameTemplate;
const pathAndInfo = this.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);
file = pathAndInfo.path, assetInfo = fileManifest.info ? {
...pathAndInfo.info,
...fileManifest.info
} : pathAndInfo.info;
}
if (err) return errorAndCallback(err);
let source = sourceFromCache;
const alreadyWritten = alreadyWrittenFiles.get(file);
if (void 0 !== alreadyWritten) {
if (alreadyWritten.hash !== usedHash) return inTry = !1, callback(new WebpackError(`Conflict: Multiple chunks emit assets to the same filename ${file} (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`));
source = alreadyWritten.source;
} else if (!(source || (source = fileManifest.render(), source instanceof CachedSource))) {
const cacheEntry = cachedSourceMap.get(source);
if (cacheEntry) source = cacheEntry; else {
const cachedSource = new CachedSource(source);
cachedSourceMap.set(source, cachedSource), source = cachedSource;
}
}
this.emitAsset(file, source, assetInfo), fileManifest.auxiliary ? chunk.auxiliaryFiles.add(file) : chunk.files.add(file), 
this.hooks.chunkAsset.call(chunk, file), alreadyWrittenFiles.set(file, {
hash: usedHash,
source,
chunk
}), source !== sourceFromCache ? assetCacheItem.store(source, (err => err ? errorAndCallback(err) : (inTry = !1, 
callback()))) : (inTry = !1, callback());
} catch (err) {
if (!inTry) throw err;
errorAndCallback(err);
}
}));
}), callback);
}), callback);
}
getPath(filename, data = {}) {
return data.hash || (data = {
hash: this.hash,
...data
}), this.getAssetPath(filename, data);
}
getPathWithInfo(filename, data = {}) {
return data.hash || (data = {
hash: this.hash,
...data
}), this.getAssetPathWithInfo(filename, data);
}
getAssetPath(filename, data) {
return this.hooks.assetPath.call("function" == typeof filename ? filename(data) : filename, data, void 0);
}
getAssetPathWithInfo(filename, data) {
const assetInfo = {};
return {
path: this.hooks.assetPath.call("function" == typeof filename ? filename(data, assetInfo) : filename, data, assetInfo),
info: assetInfo
};
}
getWarnings() {
return this.hooks.processWarnings.call(this.warnings);
}
getErrors() {
return this.hooks.processErrors.call(this.errors);
}
createChildCompiler(name, outputOptions, plugins) {
const idx = this.childrenCounters[name] || 0;
return this.childrenCounters[name] = idx + 1, this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);
}
executeModule(module, options, callback) {
const modules = new Set([ module ]);
processAsyncTree(modules, 10, ((module, push, callback) => {
this.buildQueue.waitFor(module, (err => {
if (err) return callback(err);
this.processDependenciesQueue.waitFor(module, (err => {
if (err) return callback(err);
for (const {module: m} of this.moduleGraph.getOutgoingConnections(module)) {
const size = modules.size;
modules.add(m), modules.size !== size && push(m);
}
callback();
}));
}));
}), (err => {
if (err) return callback(err);
const chunkGraph = new ChunkGraph(this.moduleGraph, this.outputOptions.hashFunction), runtime = "build time", {hashFunction, hashDigest, hashDigestLength} = this.outputOptions, runtimeTemplate = this.runtimeTemplate, chunk = new Chunk("build time chunk", this._backCompat);
chunk.id = chunk.name, chunk.ids = [ chunk.id ], chunk.runtime = runtime;
const entrypoint = new Entrypoint({
runtime,
chunkLoading: !1,
...options.entryOptions
});
chunkGraph.connectChunkAndEntryModule(chunk, module, entrypoint), connectChunkGroupAndChunk(entrypoint, chunk), 
entrypoint.setRuntimeChunk(chunk), entrypoint.setEntrypointChunk(chunk);
const chunks = new Set([ chunk ]);
for (const module of modules) {
const id = module.identifier();
chunkGraph.setModuleId(module, id), chunkGraph.connectChunkAndModule(chunk, module);
}
const errors = [];
for (const module of modules) this._createModuleHash(module, chunkGraph, runtime, hashFunction, runtimeTemplate, hashDigest, hashDigestLength, errors);
const codeGenerationResults = new CodeGenerationResults(this.outputOptions.hashFunction), codeGen = (module, callback) => {
this._codeGenerationModule(module, runtime, [ runtime ], chunkGraph.getModuleHash(module, runtime), this.dependencyTemplates, chunkGraph, this.moduleGraph, runtimeTemplate, errors, codeGenerationResults, ((err, codeGenerated) => {
callback(err);
}));
}, reportErrors = () => {
if (errors.length > 0) {
errors.sort(compareSelect((err => err.module), compareModulesByIdentifier));
for (const error of errors) this.errors.push(error);
errors.length = 0;
}
};
asyncLib.eachLimit(modules, 10, codeGen, (err => {
if (err) return callback(err);
reportErrors();
const old = this.chunkGraph;
this.chunkGraph = chunkGraph, this.processRuntimeRequirements({
chunkGraph,
modules,
chunks,
codeGenerationResults,
chunkGraphEntries: chunks
}), this.chunkGraph = old;
const runtimeModules = chunkGraph.getChunkRuntimeModulesIterable(chunk);
for (const module of runtimeModules) modules.add(module), this._createModuleHash(module, chunkGraph, runtime, hashFunction, runtimeTemplate, hashDigest, hashDigestLength);
asyncLib.eachLimit(runtimeModules, 10, codeGen, (err => {
if (err) return callback(err);
reportErrors();
const moduleArgumentsMap = new Map, moduleArgumentsById = new Map, fileDependencies = new LazySet, contextDependencies = new LazySet, missingDependencies = new LazySet, buildDependencies = new LazySet, assets = new Map;
let cacheable = !0;
const context = {
assets,
__webpack_require__: void 0,
chunk,
chunkGraph
};
asyncLib.eachLimit(modules, 10, ((module, callback) => {
const moduleArgument = {
module,
codeGenerationResult: codeGenerationResults.get(module, runtime),
preparedInfo: void 0,
moduleObject: void 0
};
if (moduleArgumentsMap.set(module, moduleArgument), moduleArgumentsById.set(module.identifier(), moduleArgument), 
module.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies), 
!1 === module.buildInfo.cacheable && (cacheable = !1), module.buildInfo && module.buildInfo.assets) {
const {assets: moduleAssets, assetsInfo} = module.buildInfo;
for (const assetName of Object.keys(moduleAssets)) assets.set(assetName, {
source: moduleAssets[assetName],
info: assetsInfo ? assetsInfo.get(assetName) : void 0
});
}
this.hooks.prepareModuleExecution.callAsync(moduleArgument, context, callback);
}), (err => {
if (err) return callback(err);
let exports;
try {
const {strictModuleErrorHandling, strictModuleExceptionHandling} = this.outputOptions, __nested_webpack_require_153265__ = id => {
const cached = moduleCache[id];
if (void 0 !== cached) {
if (cached.error) throw cached.error;
return cached.exports;
}
const moduleArgument = moduleArgumentsById.get(id);
return __webpack_require_module__(moduleArgument, id);
}, interceptModuleExecution = __nested_webpack_require_153265__[RuntimeGlobals.interceptModuleExecution.replace("__webpack_require__.", "")] = [], moduleCache = __nested_webpack_require_153265__[RuntimeGlobals.moduleCache.replace("__webpack_require__.", "")] = {};
context.__webpack_require__ = __nested_webpack_require_153265__;
const __webpack_require_module__ = (moduleArgument, id) => {
var execOptions = {
id,
module: {
id,
exports: {},
loaded: !1,
error: void 0
},
require: __nested_webpack_require_153265__
};
interceptModuleExecution.forEach((handler => handler(execOptions)));
const module = moduleArgument.module;
this.buildTimeExecutedModules.add(module);
const moduleObject = execOptions.module;
moduleArgument.moduleObject = moduleObject;
try {
return id && (moduleCache[id] = moduleObject), tryRunOrWebpackError((() => this.hooks.executeModule.call(moduleArgument, context)), "Compilation.hooks.executeModule"), 
moduleObject.loaded = !0, moduleObject.exports;
} catch (e) {
throw strictModuleExceptionHandling ? id && delete moduleCache[id] : strictModuleErrorHandling && (moduleObject.error = e), 
e.module || (e.module = module), e;
}
};
for (const runtimeModule of chunkGraph.getChunkRuntimeModulesInOrder(chunk)) __webpack_require_module__(moduleArgumentsMap.get(runtimeModule));
exports = __nested_webpack_require_153265__(module.identifier());
} catch (e) {
const err = new WebpackError(`Execution of module code from module graph (${module.readableIdentifier(this.requestShortener)}) failed: ${e.message}`);
return err.stack = e.stack, err.module = e.module, callback(err);
}
callback(null, {
exports,
assets,
cacheable,
fileDependencies,
contextDependencies,
missingDependencies,
buildDependencies
});
}));
}));
}));
}));
}
checkConstraints() {
const chunkGraph = this.chunkGraph, usedIds = new Set;
for (const module of this.modules) {
if ("runtime" === module.type) continue;
const moduleId = chunkGraph.getModuleId(module);
if (null !== moduleId) {
if (usedIds.has(moduleId)) throw new Error(`checkConstraints: duplicate module id ${moduleId}`);
usedIds.add(moduleId);
}
}
for (const chunk of this.chunks) {
for (const module of chunkGraph.getChunkModulesIterable(chunk)) if (!this.modules.has(module)) throw new Error(`checkConstraints: module in chunk but not in compilation  ${chunk.debugId} ${module.debugId}`);
for (const module of chunkGraph.getChunkEntryModulesIterable(chunk)) if (!this.modules.has(module)) throw new Error(`checkConstraints: entry module in chunk but not in compilation  ${chunk.debugId} ${module.debugId}`);
}
for (const chunkGroup of this.chunkGroups) chunkGroup.checkConstraints();
}
}
Compilation.prototype.factorizeModule = function(options, callback) {
this.factorizeQueue.add(options, callback);
};
const compilationPrototype = Compilation.prototype;
Object.defineProperty(compilationPrototype, "modifyHash", {
writable: !1,
enumerable: !1,
configurable: !1,
value: () => {
throw new Error("Compilation.modifyHash was removed in favor of Compilation.hooks.fullHash");
}
}), Object.defineProperty(compilationPrototype, "cache", {
enumerable: !1,
configurable: !1,
get: util.deprecate((function() {
return this.compiler.cache;
}), "Compilation.cache was removed in favor of Compilation.getCache()", "DEP_WEBPACK_COMPILATION_CACHE"),
set: util.deprecate((v => {}), "Compilation.cache was removed in favor of Compilation.getCache()", "DEP_WEBPACK_COMPILATION_CACHE")
}), Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL = -2e3, Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS = -1e3, 
Compilation.PROCESS_ASSETS_STAGE_DERIVED = -200, Compilation.PROCESS_ASSETS_STAGE_ADDITIONS = -100, 
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE = 100, Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT = 200, 
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY = 300, Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE = 400, 
Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING = 500, Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE = 700, 
Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE = 1e3, Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH = 2500, 
Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER = 3e3, Compilation.PROCESS_ASSETS_STAGE_ANALYSE = 4e3, 
Compilation.PROCESS_ASSETS_STAGE_REPORT = 5e3, module.exports = Compilation;
},
88799: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const parseJson = __webpack_require__(73153), asyncLib = __webpack_require__(76947), {SyncHook, SyncBailHook, AsyncParallelHook, AsyncSeriesHook} = __webpack_require__(89991), {SizeOnlySource} = __webpack_require__(37946), webpack = __webpack_require__(91459), Cache = __webpack_require__(54499), CacheFacade = __webpack_require__(87251), ChunkGraph = __webpack_require__(15888), Compilation = __webpack_require__(62843), ConcurrentCompilationError = __webpack_require__(49109), ContextModuleFactory = __webpack_require__(41875), ModuleGraph = __webpack_require__(2197), NormalModuleFactory = __webpack_require__(48131), RequestShortener = __webpack_require__(91190), ResolverFactory = __webpack_require__(91628), Stats = __webpack_require__(16523), Watching = __webpack_require__(69747), WebpackError = __webpack_require__(64326), {Logger} = __webpack_require__(20097), {join, dirname, mkdirp} = __webpack_require__(57075), {makePathsRelative} = __webpack_require__(63264), {isSourceEqual} = __webpack_require__(7519), includesHash = (filename, hashes) => !!hashes && (Array.isArray(hashes) ? hashes.some((hash => filename.includes(hash))) : filename.includes(hashes));
class Compiler {
constructor(context, options = {}) {
this.hooks = Object.freeze({
initialize: new SyncHook([]),
shouldEmit: new SyncBailHook([ "compilation" ]),
done: new AsyncSeriesHook([ "stats" ]),
afterDone: new SyncHook([ "stats" ]),
additionalPass: new AsyncSeriesHook([]),
beforeRun: new AsyncSeriesHook([ "compiler" ]),
run: new AsyncSeriesHook([ "compiler" ]),
emit: new AsyncSeriesHook([ "compilation" ]),
assetEmitted: new AsyncSeriesHook([ "file", "info" ]),
afterEmit: new AsyncSeriesHook([ "compilation" ]),
thisCompilation: new SyncHook([ "compilation", "params" ]),
compilation: new SyncHook([ "compilation", "params" ]),
normalModuleFactory: new SyncHook([ "normalModuleFactory" ]),
contextModuleFactory: new SyncHook([ "contextModuleFactory" ]),
beforeCompile: new AsyncSeriesHook([ "params" ]),
compile: new SyncHook([ "params" ]),
make: new AsyncParallelHook([ "compilation" ]),
finishMake: new AsyncSeriesHook([ "compilation" ]),
afterCompile: new AsyncSeriesHook([ "compilation" ]),
readRecords: new AsyncSeriesHook([]),
emitRecords: new AsyncSeriesHook([]),
watchRun: new AsyncSeriesHook([ "compiler" ]),
failed: new SyncHook([ "error" ]),
invalid: new SyncHook([ "filename", "changeTime" ]),
watchClose: new SyncHook([]),
shutdown: new AsyncSeriesHook([]),
infrastructureLog: new SyncBailHook([ "origin", "type", "args" ]),
environment: new SyncHook([]),
afterEnvironment: new SyncHook([]),
afterPlugins: new SyncHook([ "compiler" ]),
afterResolvers: new SyncHook([ "compiler" ]),
entryOption: new SyncBailHook([ "context", "entry" ])
}), this.webpack = webpack, this.name = void 0, this.parentCompilation = void 0, 
this.root = this, this.outputPath = "", this.watching = void 0, this.outputFileSystem = null, 
this.intermediateFileSystem = null, this.inputFileSystem = null, this.watchFileSystem = null, 
this.recordsInputPath = null, this.recordsOutputPath = null, this.records = {}, 
this.managedPaths = new Set, this.immutablePaths = new Set, this.modifiedFiles = void 0, 
this.removedFiles = void 0, this.fileTimestamps = void 0, this.contextTimestamps = void 0, 
this.fsStartTime = void 0, this.resolverFactory = new ResolverFactory, this.infrastructureLogger = void 0, 
this.options = options, this.context = context, this.requestShortener = new RequestShortener(context, this.root), 
this.cache = new Cache, this.moduleMemCaches = void 0, this.compilerPath = "", this.running = !1, 
this.idle = !1, this.watchMode = !1, this._backCompat = !1 !== this.options.experiments.backCompat, 
this._lastCompilation = void 0, this._lastNormalModuleFactory = void 0, this._assetEmittingSourceCache = new WeakMap, 
this._assetEmittingWrittenFiles = new Map, this._assetEmittingPreviousFiles = new Set;
}
getCache(name) {
return new CacheFacade(this.cache, `${this.compilerPath}${name}`, this.options.output.hashFunction);
}
getInfrastructureLogger(name) {
if (!name) throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name");
return new Logger(((type, args) => {
if ("function" == typeof name && !(name = name())) throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
void 0 === this.hooks.infrastructureLog.call(name, type, args) && void 0 !== this.infrastructureLogger && this.infrastructureLogger(name, type, args);
}), (childName => "function" == typeof name ? "function" == typeof childName ? this.getInfrastructureLogger((() => {
if ("function" == typeof name && !(name = name())) throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
if ("function" == typeof childName && !(childName = childName())) throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
return `${name}/${childName}`;
})) : this.getInfrastructureLogger((() => {
if ("function" == typeof name && !(name = name())) throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
return `${name}/${childName}`;
})) : "function" == typeof childName ? this.getInfrastructureLogger((() => {
if ("function" == typeof childName && !(childName = childName())) throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
return `${name}/${childName}`;
})) : this.getInfrastructureLogger(`${name}/${childName}`)));
}
_cleanupLastCompilation() {
if (void 0 !== this._lastCompilation) {
for (const module of this._lastCompilation.modules) ChunkGraph.clearChunkGraphForModule(module), 
ModuleGraph.clearModuleGraphForModule(module), module.cleanupForCache();
for (const chunk of this._lastCompilation.chunks) ChunkGraph.clearChunkGraphForChunk(chunk);
this._lastCompilation = void 0;
}
}
_cleanupLastNormalModuleFactory() {
void 0 !== this._lastNormalModuleFactory && (this._lastNormalModuleFactory.cleanupForCache(), 
this._lastNormalModuleFactory = void 0);
}
watch(watchOptions, handler) {
return this.running ? handler(new ConcurrentCompilationError) : (this.running = !0, 
this.watchMode = !0, this.watching = new Watching(this, watchOptions, handler), 
this.watching);
}
run(callback) {
if (this.running) return callback(new ConcurrentCompilationError);
let logger;
const finalCallback = (err, stats) => {
logger && logger.time("beginIdle"), this.idle = !0, this.cache.beginIdle(), this.idle = !0, 
logger && logger.timeEnd("beginIdle"), this.running = !1, err && this.hooks.failed.call(err), 
void 0 !== callback && callback(err, stats), this.hooks.afterDone.call(stats);
}, startTime = Date.now();
this.running = !0;
const onCompiled = (err, compilation) => {
if (err) return finalCallback(err);
if (!1 !== this.hooks.shouldEmit.call(compilation)) process.nextTick((() => {
logger = compilation.getLogger("webpack.Compiler"), logger.time("emitAssets"), this.emitAssets(compilation, (err => {
if (logger.timeEnd("emitAssets"), err) return finalCallback(err);
if (compilation.hooks.needAdditionalPass.call()) {
compilation.needAdditionalPass = !0, compilation.startTime = startTime, compilation.endTime = Date.now(), 
logger.time("done hook");
const stats = new Stats(compilation);
this.hooks.done.callAsync(stats, (err => {
if (logger.timeEnd("done hook"), err) return finalCallback(err);
this.hooks.additionalPass.callAsync((err => {
if (err) return finalCallback(err);
this.compile(onCompiled);
}));
}));
} else logger.time("emitRecords"), this.emitRecords((err => {
if (logger.timeEnd("emitRecords"), err) return finalCallback(err);
compilation.startTime = startTime, compilation.endTime = Date.now(), logger.time("done hook");
const stats = new Stats(compilation);
this.hooks.done.callAsync(stats, (err => {
if (logger.timeEnd("done hook"), err) return finalCallback(err);
this.cache.storeBuildDependencies(compilation.buildDependencies, (err => err ? finalCallback(err) : finalCallback(null, stats)));
}));
}));
}));
})); else {
compilation.startTime = startTime, compilation.endTime = Date.now();
const stats = new Stats(compilation);
this.hooks.done.callAsync(stats, (err => err ? finalCallback(err) : finalCallback(null, stats)));
}
}, run = () => {
this.hooks.beforeRun.callAsync(this, (err => {
if (err) return finalCallback(err);
this.hooks.run.callAsync(this, (err => {
if (err) return finalCallback(err);
this.readRecords((err => {
if (err) return finalCallback(err);
this.compile(onCompiled);
}));
}));
}));
};
this.idle ? this.cache.endIdle((err => {
if (err) return finalCallback(err);
this.idle = !1, run();
})) : run();
}
runAsChild(callback) {
const startTime = Date.now(), finalCallback = (err, entries, compilation) => {
try {
callback(err, entries, compilation);
} catch (e) {
const err = new WebpackError(`compiler.runAsChild callback error: ${e}`);
err.details = e.stack, this.parentCompilation.errors.push(err);
}
};
this.compile(((err, compilation) => {
if (err) return finalCallback(err);
this.parentCompilation.children.push(compilation);
for (const {name, source, info} of compilation.getAssets()) this.parentCompilation.emitAsset(name, source, info);
const entries = [];
for (const ep of compilation.entrypoints.values()) entries.push(...ep.chunks);
return compilation.startTime = startTime, compilation.endTime = Date.now(), finalCallback(null, entries, compilation);
}));
}
purgeInputFileSystem() {
this.inputFileSystem && this.inputFileSystem.purge && this.inputFileSystem.purge();
}
emitAssets(compilation, callback) {
let outputPath;
const emitFiles = err => {
if (err) return callback(err);
const assets = compilation.getAssets();
compilation.assets = {
...compilation.assets
};
const caseInsensitiveMap = new Map, allTargetPaths = new Set;
asyncLib.forEachLimit(assets, 15, (({name: file, source, info}, callback) => {
let targetFile = file, immutable = info.immutable;
const queryStringIdx = targetFile.indexOf("?");
queryStringIdx >= 0 && (targetFile = targetFile.slice(0, queryStringIdx), immutable = immutable && (includesHash(targetFile, info.contenthash) || includesHash(targetFile, info.chunkhash) || includesHash(targetFile, info.modulehash) || includesHash(targetFile, info.fullhash)));
const writeOut = err => {
if (err) return callback(err);
const targetPath = join(this.outputFileSystem, outputPath, targetFile);
allTargetPaths.add(targetPath);
const targetFileGeneration = this._assetEmittingWrittenFiles.get(targetPath);
let similarEntry, cacheEntry = this._assetEmittingSourceCache.get(source);
void 0 === cacheEntry && (cacheEntry = {
sizeOnlySource: void 0,
writtenTo: new Map
}, this._assetEmittingSourceCache.set(source, cacheEntry));
const checkSimilarFile = () => {
const caseInsensitiveTargetPath = targetPath.toLowerCase();
if (similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath), void 0 !== similarEntry) {
const {path: other, source: otherSource} = similarEntry;
if (isSourceEqual(otherSource, source)) void 0 !== similarEntry.size ? updateWithReplacementSource(similarEntry.size) : (similarEntry.waiting || (similarEntry.waiting = []), 
similarEntry.waiting.push({
file,
cacheEntry
})), alreadyWritten(); else {
const err = new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);
err.file = file, callback(err);
}
return !0;
}
return caseInsensitiveMap.set(caseInsensitiveTargetPath, similarEntry = {
path: targetPath,
source,
size: void 0,
waiting: void 0
}), !1;
}, getContent = () => {
if ("function" == typeof source.buffer) return source.buffer();
{
const bufferOrString = source.source();
return Buffer.isBuffer(bufferOrString) ? bufferOrString : Buffer.from(bufferOrString, "utf8");
}
}, alreadyWritten = () => {
if (void 0 === targetFileGeneration) {
const newGeneration = 1;
this._assetEmittingWrittenFiles.set(targetPath, newGeneration), cacheEntry.writtenTo.set(targetPath, newGeneration);
} else cacheEntry.writtenTo.set(targetPath, targetFileGeneration);
callback();
}, doWrite = content => {
this.outputFileSystem.writeFile(targetPath, content, (err => {
if (err) return callback(err);
compilation.emittedAssets.add(file);
const newGeneration = void 0 === targetFileGeneration ? 1 : targetFileGeneration + 1;
cacheEntry.writtenTo.set(targetPath, newGeneration), this._assetEmittingWrittenFiles.set(targetPath, newGeneration), 
this.hooks.assetEmitted.callAsync(file, {
content,
source,
outputPath,
compilation,
targetPath
}, callback);
}));
}, updateWithReplacementSource = size => {
if (updateFileWithReplacementSource(file, cacheEntry, size), similarEntry.size = size, 
void 0 !== similarEntry.waiting) for (const {file, cacheEntry} of similarEntry.waiting) updateFileWithReplacementSource(file, cacheEntry, size);
}, updateFileWithReplacementSource = (file, cacheEntry, size) => {
cacheEntry.sizeOnlySource || (cacheEntry.sizeOnlySource = new SizeOnlySource(size)), 
compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
size
});
}, processExistingFile = stats => {
if (immutable) return updateWithReplacementSource(stats.size), alreadyWritten();
const content = getContent();
return updateWithReplacementSource(content.length), content.length === stats.size ? (compilation.comparedForEmitAssets.add(file), 
this.outputFileSystem.readFile(targetPath, ((err, existingContent) => err || !content.equals(existingContent) ? doWrite(content) : alreadyWritten()))) : doWrite(content);
}, processMissingFile = () => {
const content = getContent();
return updateWithReplacementSource(content.length), doWrite(content);
};
if (void 0 !== targetFileGeneration) {
if (cacheEntry.writtenTo.get(targetPath) === targetFileGeneration) {
if (this._assetEmittingPreviousFiles.has(targetPath)) return compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
size: cacheEntry.sizeOnlySource.size()
}), callback();
immutable = !0;
} else if (!immutable) {
if (checkSimilarFile()) return;
return processMissingFile();
}
}
checkSimilarFile() || (this.options.output.compareBeforeEmit ? this.outputFileSystem.stat(targetPath, ((err, stats) => {
!err && stats.isFile() ? processExistingFile(stats) : processMissingFile();
})) : processMissingFile());
};
if (targetFile.match(/\/|\\/)) {
const fs = this.outputFileSystem, dir = dirname(fs, join(fs, outputPath, targetFile));
mkdirp(fs, dir, writeOut);
} else writeOut();
}), (err => {
if (caseInsensitiveMap.clear(), err) return this._assetEmittingPreviousFiles.clear(), 
callback(err);
this._assetEmittingPreviousFiles = allTargetPaths, this.hooks.afterEmit.callAsync(compilation, (err => err ? callback(err) : callback()));
}));
};
this.hooks.emit.callAsync(compilation, (err => {
if (err) return callback(err);
outputPath = compilation.getPath(this.outputPath, {}), mkdirp(this.outputFileSystem, outputPath, emitFiles);
}));
}
emitRecords(callback) {
this.hooks.emitRecords.isUsed() ? this.recordsOutputPath ? asyncLib.parallel([ cb => this.hooks.emitRecords.callAsync(cb), this._emitRecords.bind(this) ], (err => callback(err))) : this.hooks.emitRecords.callAsync(callback) : this.recordsOutputPath ? this._emitRecords(callback) : callback();
}
_emitRecords(callback) {
const writeFile = () => {
this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, ((n, value) => {
if ("object" == typeof value && null !== value && !Array.isArray(value)) {
const keys = Object.keys(value);
if (!(array => {
for (let i = 1; i < array.length; i++) if (array[i - 1] > array[i]) return !1;
return !0;
})(keys)) return ((obj, keys) => {
const o = {};
for (const k of keys.sort()) o[k] = obj[k];
return o;
})(value, keys);
}
return value;
}), 2), callback);
}, recordsOutputPathDirectory = dirname(this.outputFileSystem, this.recordsOutputPath);
if (!recordsOutputPathDirectory) return writeFile();
mkdirp(this.outputFileSystem, recordsOutputPathDirectory, (err => {
if (err) return callback(err);
writeFile();
}));
}
readRecords(callback) {
this.hooks.readRecords.isUsed() ? this.recordsInputPath ? asyncLib.parallel([ cb => this.hooks.readRecords.callAsync(cb), this._readRecords.bind(this) ]) : (this.records = {}, 
this.hooks.readRecords.callAsync(callback)) : this.recordsInputPath ? this._readRecords(callback) : (this.records = {}, 
callback());
}
_readRecords(callback) {
if (!this.recordsInputPath) return this.records = {}, callback();
this.inputFileSystem.stat(this.recordsInputPath, (err => {
if (err) return callback();
this.inputFileSystem.readFile(this.recordsInputPath, ((err, content) => {
if (err) return callback(err);
try {
this.records = parseJson(content.toString("utf-8"));
} catch (e) {
return e.message = "Cannot parse records: " + e.message, callback(e);
}
return callback();
}));
}));
}
createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {
const childCompiler = new Compiler(this.context, {
...this.options,
output: {
...this.options.output,
...outputOptions
}
});
childCompiler.name = compilerName, childCompiler.outputPath = this.outputPath, childCompiler.inputFileSystem = this.inputFileSystem, 
childCompiler.outputFileSystem = null, childCompiler.resolverFactory = this.resolverFactory, 
childCompiler.modifiedFiles = this.modifiedFiles, childCompiler.removedFiles = this.removedFiles, 
childCompiler.fileTimestamps = this.fileTimestamps, childCompiler.contextTimestamps = this.contextTimestamps, 
childCompiler.fsStartTime = this.fsStartTime, childCompiler.cache = this.cache, 
childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`, 
childCompiler._backCompat = this._backCompat;
const relativeCompilerName = makePathsRelative(this.context, compilerName, this.root);
if (this.records[relativeCompilerName] || (this.records[relativeCompilerName] = []), 
this.records[relativeCompilerName][compilerIndex] ? childCompiler.records = this.records[relativeCompilerName][compilerIndex] : this.records[relativeCompilerName].push(childCompiler.records = {}), 
childCompiler.parentCompilation = compilation, childCompiler.root = this.root, Array.isArray(plugins)) for (const plugin of plugins) plugin.apply(childCompiler);
for (const name in this.hooks) [ "make", "compile", "emit", "afterEmit", "invalid", "done", "thisCompilation" ].includes(name) || childCompiler.hooks[name] && (childCompiler.hooks[name].taps = this.hooks[name].taps.slice());
return compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex), 
childCompiler;
}
isChild() {
return !!this.parentCompilation;
}
createCompilation(params) {
return this._cleanupLastCompilation(), this._lastCompilation = new Compilation(this, params);
}
newCompilation(params) {
const compilation = this.createCompilation(params);
return compilation.name = this.name, compilation.records = this.records, this.hooks.thisCompilation.call(compilation, params), 
this.hooks.compilation.call(compilation, params), compilation;
}
createNormalModuleFactory() {
this._cleanupLastNormalModuleFactory();
const normalModuleFactory = new NormalModuleFactory({
context: this.options.context,
fs: this.inputFileSystem,
resolverFactory: this.resolverFactory,
options: this.options.module,
associatedObjectForCache: this.root,
layers: this.options.experiments.layers
});
return this._lastNormalModuleFactory = normalModuleFactory, this.hooks.normalModuleFactory.call(normalModuleFactory), 
normalModuleFactory;
}
createContextModuleFactory() {
const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
return this.hooks.contextModuleFactory.call(contextModuleFactory), contextModuleFactory;
}
newCompilationParams() {
return {
normalModuleFactory: this.createNormalModuleFactory(),
contextModuleFactory: this.createContextModuleFactory()
};
}
compile(callback) {
const params = this.newCompilationParams();
this.hooks.beforeCompile.callAsync(params, (err => {
if (err) return callback(err);
this.hooks.compile.call(params);
const compilation = this.newCompilation(params), logger = compilation.getLogger("webpack.Compiler");
logger.time("make hook"), this.hooks.make.callAsync(compilation, (err => {
if (logger.timeEnd("make hook"), err) return callback(err);
logger.time("finish make hook"), this.hooks.finishMake.callAsync(compilation, (err => {
if (logger.timeEnd("finish make hook"), err) return callback(err);
process.nextTick((() => {
logger.time("finish compilation"), compilation.finish((err => {
if (logger.timeEnd("finish compilation"), err) return callback(err);
logger.time("seal compilation"), compilation.seal((err => {
if (logger.timeEnd("seal compilation"), err) return callback(err);
logger.time("afterCompile hook"), this.hooks.afterCompile.callAsync(compilation, (err => (logger.timeEnd("afterCompile hook"), 
err ? callback(err) : callback(null, compilation))));
}));
}));
}));
}));
}));
}));
}
close(callback) {
this.watching ? this.watching.close((err => {
this.close(callback);
})) : this.hooks.shutdown.callAsync((err => {
if (err) return callback(err);
this._lastCompilation = void 0, this._lastNormalModuleFactory = void 0, this.cache.shutdown(callback);
}));
}
}
module.exports = Compiler;
},
87291: module => {
"use strict";
const MODULE_REFERENCE_REGEXP = /^__WEBPACK_MODULE_REFERENCE__(\d+)_([\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\d))?__$/;
class ConcatenationScope {
constructor(modulesMap, currentModule) {
if (this._currentModule = currentModule, Array.isArray(modulesMap)) {
const map = new Map;
for (const info of modulesMap) map.set(info.module, info);
modulesMap = map;
}
this._modulesMap = modulesMap;
}
isModuleInScope(module) {
return this._modulesMap.has(module);
}
registerExport(exportName, symbol) {
this._currentModule.exportMap || (this._currentModule.exportMap = new Map), this._currentModule.exportMap.has(exportName) || this._currentModule.exportMap.set(exportName, symbol);
}
registerRawExport(exportName, expression) {
this._currentModule.rawExportMap || (this._currentModule.rawExportMap = new Map), 
this._currentModule.rawExportMap.has(exportName) || this._currentModule.rawExportMap.set(exportName, expression);
}
registerNamespaceExport(symbol) {
this._currentModule.namespaceExportSymbol = symbol;
}
createModuleReference(module, {ids, call = !1, directImport = !1, asiSafe = !1}) {
const info = this._modulesMap.get(module), callFlag = call ? "_call" : "", directImportFlag = directImport ? "_directImport" : "", asiSafeFlag = asiSafe ? "_asiSafe1" : !1 === asiSafe ? "_asiSafe0" : "", exportData = ids ? Buffer.from(JSON.stringify(ids), "utf-8").toString("hex") : "ns";
return `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${directImportFlag}${asiSafeFlag}__._`;
}
static isModuleReference(name) {
return MODULE_REFERENCE_REGEXP.test(name);
}
static matchModuleReference(name) {
const match = MODULE_REFERENCE_REGEXP.exec(name);
if (!match) return null;
const index = +match[1], asiSafe = match[5];
return {
index,
ids: "ns" === match[2] ? [] : JSON.parse(Buffer.from(match[2], "hex").toString("utf-8")),
call: !!match[3],
directImport: !!match[4],
asiSafe: asiSafe ? "1" === asiSafe : void 0
};
}
}
ConcatenationScope.DEFAULT_EXPORT = "__WEBPACK_DEFAULT_EXPORT__", ConcatenationScope.NAMESPACE_OBJECT_EXPORT = "__WEBPACK_NAMESPACE_OBJECT__", 
module.exports = ConcatenationScope;
},
49109: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor() {
super(), this.name = "ConcurrentCompilationError", this.message = "You ran Webpack twice. Each instance only supports a single concurrent compilation at a time.";
}
};
},
29226: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, PrefixSource} = __webpack_require__(37946), InitFragment = __webpack_require__(95328), Template = __webpack_require__(88370), {mergeRuntime} = __webpack_require__(14372), wrapInCondition = (condition, source) => "string" == typeof source ? Template.asString([ `if (${condition}) {`, Template.indent(source), "}", "" ]) : new ConcatSource(`if (${condition}) {\n`, new PrefixSource("\t", source), "}\n");
class ConditionalInitFragment extends InitFragment {
constructor(content, stage, position, key, runtimeCondition = !0, endContent) {
super(content, stage, position, key, endContent), this.runtimeCondition = runtimeCondition;
}
getContent(context) {
if (!1 === this.runtimeCondition || !this.content) return "";
if (!0 === this.runtimeCondition) return this.content;
const expr = context.runtimeTemplate.runtimeConditionExpression({
chunkGraph: context.chunkGraph,
runtimeRequirements: context.runtimeRequirements,
runtime: context.runtime,
runtimeCondition: this.runtimeCondition
});
return "true" === expr ? this.content : wrapInCondition(expr, this.content);
}
getEndContent(context) {
if (!1 === this.runtimeCondition || !this.endContent) return "";
if (!0 === this.runtimeCondition) return this.endContent;
const expr = context.runtimeTemplate.runtimeConditionExpression({
chunkGraph: context.chunkGraph,
runtimeRequirements: context.runtimeRequirements,
runtime: context.runtime,
runtimeCondition: this.runtimeCondition
});
return "true" === expr ? this.endContent : wrapInCondition(expr, this.endContent);
}
merge(other) {
if (!0 === this.runtimeCondition) return this;
if (!0 === other.runtimeCondition) return other;
if (!1 === this.runtimeCondition) return other;
if (!1 === other.runtimeCondition) return this;
const runtimeCondition = mergeRuntime(this.runtimeCondition, other.runtimeCondition);
return new ConditionalInitFragment(this.content, this.stage, this.position, this.key, runtimeCondition, this.endContent);
}
}
module.exports = ConditionalInitFragment;
},
59973: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const CachedConstDependency = __webpack_require__(26919), ConstDependency = __webpack_require__(30339), {evaluateToString} = __webpack_require__(78802), {parseResource} = __webpack_require__(63264), collectDeclaration = (declarations, pattern) => {
const stack = [ pattern ];
for (;stack.length > 0; ) {
const node = stack.pop();
switch (node.type) {
case "Identifier":
declarations.add(node.name);
break;

case "ArrayPattern":
for (const element of node.elements) element && stack.push(element);
break;

case "AssignmentPattern":
stack.push(node.left);
break;

case "ObjectPattern":
for (const property of node.properties) stack.push(property.value);
break;

case "RestElement":
stack.push(node.argument);
}
}
}, getHoistedDeclarations = (branch, includeFunctionDeclarations) => {
const declarations = new Set, stack = [ branch ];
for (;stack.length > 0; ) {
const node = stack.pop();
if (node) switch (node.type) {
case "BlockStatement":
for (const stmt of node.body) stack.push(stmt);
break;

case "IfStatement":
stack.push(node.consequent), stack.push(node.alternate);
break;

case "ForStatement":
stack.push(node.init), stack.push(node.body);
break;

case "ForInStatement":
case "ForOfStatement":
stack.push(node.left), stack.push(node.body);
break;

case "DoWhileStatement":
case "WhileStatement":
case "LabeledStatement":
stack.push(node.body);
break;

case "SwitchStatement":
for (const cs of node.cases) for (const consequent of cs.consequent) stack.push(consequent);
break;

case "TryStatement":
stack.push(node.block), node.handler && stack.push(node.handler.body), stack.push(node.finalizer);
break;

case "FunctionDeclaration":
includeFunctionDeclarations && collectDeclaration(declarations, node.id);
break;

case "VariableDeclaration":
if ("var" === node.kind) for (const decl of node.declarations) collectDeclaration(declarations, decl.id);
}
}
return Array.from(declarations);
};
module.exports = class {
apply(compiler) {
const cachedParseResource = parseResource.bindCache(compiler.root);
compiler.hooks.compilation.tap("ConstPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template), 
compilation.dependencyTemplates.set(CachedConstDependency, new CachedConstDependency.Template);
const handler = parser => {
parser.hooks.statementIf.tap("ConstPlugin", (statement => {
if (parser.scope.isAsmJs) return;
const param = parser.evaluateExpression(statement.test), bool = param.asBool();
if ("boolean" == typeof bool) {
if (param.couldHaveSideEffects()) parser.walkExpression(statement.test); else {
const dep = new ConstDependency(`${bool}`, param.range);
dep.loc = statement.loc, parser.state.module.addPresentationalDependency(dep);
}
const branchToRemove = bool ? statement.alternate : statement.consequent;
if (branchToRemove) {
let declarations, replacement;
declarations = parser.scope.isStrict ? getHoistedDeclarations(branchToRemove, !1) : getHoistedDeclarations(branchToRemove, !0), 
replacement = declarations.length > 0 ? `{ var ${declarations.join(", ")}; }` : "{}";
const dep = new ConstDependency(replacement, branchToRemove.range);
dep.loc = branchToRemove.loc, parser.state.module.addPresentationalDependency(dep);
}
return bool;
}
})), parser.hooks.expressionConditionalOperator.tap("ConstPlugin", (expression => {
if (parser.scope.isAsmJs) return;
const param = parser.evaluateExpression(expression.test), bool = param.asBool();
if ("boolean" == typeof bool) {
if (param.couldHaveSideEffects()) parser.walkExpression(expression.test); else {
const dep = new ConstDependency(` ${bool}`, param.range);
dep.loc = expression.loc, parser.state.module.addPresentationalDependency(dep);
}
const branchToRemove = bool ? expression.alternate : expression.consequent, dep = new ConstDependency("0", branchToRemove.range);
return dep.loc = branchToRemove.loc, parser.state.module.addPresentationalDependency(dep), 
bool;
}
})), parser.hooks.expressionLogicalOperator.tap("ConstPlugin", (expression => {
if (!parser.scope.isAsmJs) if ("&&" === expression.operator || "||" === expression.operator) {
const param = parser.evaluateExpression(expression.left), bool = param.asBool();
if ("boolean" == typeof bool) {
const keepRight = "&&" === expression.operator && bool || "||" === expression.operator && !bool;
if (param.couldHaveSideEffects() || !param.isBoolean() && !keepRight) parser.walkExpression(expression.left); else {
const dep = new ConstDependency(` ${bool}`, param.range);
dep.loc = expression.loc, parser.state.module.addPresentationalDependency(dep);
}
if (!keepRight) {
const dep = new ConstDependency("0", expression.right.range);
dep.loc = expression.loc, parser.state.module.addPresentationalDependency(dep);
}
return keepRight;
}
} else if ("??" === expression.operator) {
const param = parser.evaluateExpression(expression.left), keepRight = param.asNullish();
if ("boolean" == typeof keepRight) {
if (!param.couldHaveSideEffects() && keepRight) {
const dep = new ConstDependency(" null", param.range);
dep.loc = expression.loc, parser.state.module.addPresentationalDependency(dep);
} else {
const dep = new ConstDependency("0", expression.right.range);
dep.loc = expression.loc, parser.state.module.addPresentationalDependency(dep), 
parser.walkExpression(expression.left);
}
return keepRight;
}
}
})), parser.hooks.optionalChaining.tap("ConstPlugin", (expr => {
const optionalExpressionsStack = [];
let next = expr.expression;
for (;"MemberExpression" === next.type || "CallExpression" === next.type; ) "MemberExpression" === next.type ? (next.optional && optionalExpressionsStack.push(next.object), 
next = next.object) : (next.optional && optionalExpressionsStack.push(next.callee), 
next = next.callee);
for (;optionalExpressionsStack.length; ) {
const expression = optionalExpressionsStack.pop();
if (parser.evaluateExpression(expression).asNullish()) {
const dep = new ConstDependency(" undefined", expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}
})), parser.hooks.evaluateIdentifier.for("__resourceQuery").tap("ConstPlugin", (expr => {
if (!parser.scope.isAsmJs && parser.state.module) return evaluateToString(cachedParseResource(parser.state.module.resource).query)(expr);
})), parser.hooks.expression.for("__resourceQuery").tap("ConstPlugin", (expr => {
if (parser.scope.isAsmJs) return;
if (!parser.state.module) return;
const dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).query), expr.range, "__resourceQuery");
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluateIdentifier.for("__resourceFragment").tap("ConstPlugin", (expr => {
if (!parser.scope.isAsmJs && parser.state.module) return evaluateToString(cachedParseResource(parser.state.module.resource).fragment)(expr);
})), parser.hooks.expression.for("__resourceFragment").tap("ConstPlugin", (expr => {
if (parser.scope.isAsmJs) return;
if (!parser.state.module) return;
const dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).fragment), expr.range, "__resourceFragment");
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("ConstPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ConstPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("ConstPlugin", handler);
}));
}
};
},
62793: module => {
"use strict";
module.exports = class {
constructor(negativeMatcher) {
this.negativeMatcher = negativeMatcher;
}
apply(compiler) {
compiler.hooks.contextModuleFactory.tap("ContextExclusionPlugin", (cmf => {
cmf.hooks.contextModuleFiles.tap("ContextExclusionPlugin", (files => files.filter((filePath => !this.negativeMatcher.test(filePath)))));
}));
}
};
},
11627: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {OriginalSource, RawSource} = __webpack_require__(37946), AsyncDependenciesBlock = __webpack_require__(89353), {makeWebpackError} = __webpack_require__(44741), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), WebpackError = __webpack_require__(64326), {compareLocations, concatComparators, compareSelect, keepOriginalOrder, compareModulesById} = __webpack_require__(40028), {contextify, parseResource, makePathsRelative} = __webpack_require__(63264), makeSerializable = __webpack_require__(45898), SNAPSHOT_OPTIONS = {
timestamp: !0
}, TYPES = new Set([ "javascript" ]);
class ContextModule extends Module {
constructor(resolveDependencies, options) {
if (options && "string" != typeof options.resource) super("javascript/dynamic"), 
this.options = {
...options,
resource: options.resource,
resourceQuery: options.resourceQuery || "",
resourceFragment: options.resourceFragment || ""
}; else {
const parsed = parseResource(options ? options.resource : ""), resource = parsed.path, resourceQuery = options && options.resourceQuery || parsed.query, resourceFragment = options && options.resourceFragment || parsed.fragment;
super("javascript/dynamic", resource), this.options = {
...options,
resource,
resourceQuery,
resourceFragment
};
}
if (this.resolveDependencies = resolveDependencies, options && void 0 !== options.resolveOptions && (this.resolveOptions = options.resolveOptions), 
options && "string" != typeof options.mode) throw new Error("options.mode is a required option");
this._identifier = this._createIdentifier(), this._forceBuild = !0;
}
getSourceTypes() {
return TYPES;
}
updateCacheModule(module) {
const m = module;
this.resolveDependencies = m.resolveDependencies, this.options = m.options;
}
cleanupForCache() {
super.cleanupForCache(), this.resolveDependencies = void 0;
}
_prettyRegExp(regexString, stripSlash = !0) {
const str = (regexString + "").replace(/!/g, "%21").replace(/\|/g, "%7C");
return stripSlash ? str.substring(1, str.length - 1) : str;
}
_createIdentifier() {
let identifier = this.context || ("string" == typeof this.options.resource || !1 === this.options.resource ? `${this.options.resource}` : this.options.resource.join("|"));
return this.options.resourceQuery && (identifier += `|${this.options.resourceQuery}`), 
this.options.resourceFragment && (identifier += `|${this.options.resourceFragment}`), 
this.options.mode && (identifier += `|${this.options.mode}`), this.options.recursive || (identifier += "|nonrecursive"), 
this.options.addon && (identifier += `|${this.options.addon}`), this.options.regExp && (identifier += `|${this._prettyRegExp(this.options.regExp, !1)}`), 
this.options.include && (identifier += `|include: ${this._prettyRegExp(this.options.include, !1)}`), 
this.options.exclude && (identifier += `|exclude: ${this._prettyRegExp(this.options.exclude, !1)}`), 
this.options.referencedExports && (identifier += `|referencedExports: ${JSON.stringify(this.options.referencedExports)}`), 
this.options.chunkName && (identifier += `|chunkName: ${this.options.chunkName}`), 
this.options.groupOptions && (identifier += `|groupOptions: ${JSON.stringify(this.options.groupOptions)}`), 
"strict" === this.options.namespaceObject ? identifier += "|strict namespace object" : this.options.namespaceObject && (identifier += "|namespace object"), 
identifier;
}
identifier() {
return this._identifier;
}
readableIdentifier(requestShortener) {
let identifier;
if (identifier = this.context ? requestShortener.shorten(this.context) + "/" : "string" == typeof this.options.resource || !1 === this.options.resource ? requestShortener.shorten(`${this.options.resource}`) + "/" : this.options.resource.map((r => requestShortener.shorten(r) + "/")).join(" "), 
this.options.resourceQuery && (identifier += ` ${this.options.resourceQuery}`), 
this.options.mode && (identifier += ` ${this.options.mode}`), this.options.recursive || (identifier += " nonrecursive"), 
this.options.addon && (identifier += ` ${requestShortener.shorten(this.options.addon)}`), 
this.options.regExp && (identifier += ` ${this._prettyRegExp(this.options.regExp)}`), 
this.options.include && (identifier += ` include: ${this._prettyRegExp(this.options.include)}`), 
this.options.exclude && (identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)}`), 
this.options.referencedExports && (identifier += ` referencedExports: ${this.options.referencedExports.map((e => e.join("."))).join(", ")}`), 
this.options.chunkName && (identifier += ` chunkName: ${this.options.chunkName}`), 
this.options.groupOptions) {
const groupOptions = this.options.groupOptions;
for (const key of Object.keys(groupOptions)) identifier += ` ${key}: ${groupOptions[key]}`;
}
return "strict" === this.options.namespaceObject ? identifier += " strict namespace object" : this.options.namespaceObject && (identifier += " namespace object"), 
identifier;
}
libIdent(options) {
let identifier;
return identifier = this.context ? contextify(options.context, this.context, options.associatedObjectForCache) : "string" == typeof this.options.resource ? contextify(options.context, this.options.resource, options.associatedObjectForCache) : !1 === this.options.resource ? "false" : this.options.resource.map((res => contextify(options.context, res, options.associatedObjectForCache))).join(" "), 
this.layer && (identifier = `(${this.layer})/${identifier}`), this.options.mode && (identifier += ` ${this.options.mode}`), 
this.options.recursive && (identifier += " recursive"), this.options.addon && (identifier += ` ${contextify(options.context, this.options.addon, options.associatedObjectForCache)}`), 
this.options.regExp && (identifier += ` ${this._prettyRegExp(this.options.regExp)}`), 
this.options.include && (identifier += ` include: ${this._prettyRegExp(this.options.include)}`), 
this.options.exclude && (identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)}`), 
this.options.referencedExports && (identifier += ` referencedExports: ${this.options.referencedExports.map((e => e.join("."))).join(", ")}`), 
identifier;
}
invalidateBuild() {
this._forceBuild = !0;
}
needBuild({fileSystemInfo}, callback) {
return this._forceBuild ? callback(null, !0) : this.buildInfo.snapshot ? void fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, ((err, valid) => {
callback(err, !valid);
})) : callback(null, Boolean(this.context || this.options.resource));
}
build(options, compilation, resolver, fs, callback) {
this._forceBuild = !1, this.buildMeta = {
exportsType: "default",
defaultObject: "redirect-warn"
}, this.buildInfo = {
snapshot: void 0
}, this.dependencies.length = 0, this.blocks.length = 0;
const startTime = Date.now();
this.resolveDependencies(fs, this.options, ((err, dependencies) => {
if (err) return callback(makeWebpackError(err, "ContextModule.resolveDependencies"));
if (dependencies) {
for (const dep of dependencies) dep.loc = {
name: dep.userRequest
}, dep.request = this.options.addon + dep.request;
if (dependencies.sort(concatComparators(compareSelect((a => a.loc), compareLocations), keepOriginalOrder(this.dependencies))), 
"sync" === this.options.mode || "eager" === this.options.mode) this.dependencies = dependencies; else if ("lazy-once" === this.options.mode) {
if (dependencies.length > 0) {
const block = new AsyncDependenciesBlock({
...this.options.groupOptions,
name: this.options.chunkName
});
for (const dep of dependencies) block.addDependency(dep);
this.addBlock(block);
}
} else if ("weak" === this.options.mode || "async-weak" === this.options.mode) {
for (const dep of dependencies) dep.weak = !0;
this.dependencies = dependencies;
} else {
if ("lazy" !== this.options.mode) return void callback(new WebpackError(`Unsupported mode "${this.options.mode}" in context`));
{
let index = 0;
for (const dep of dependencies) {
let chunkName = this.options.chunkName;
chunkName && (/\[(index|request)\]/.test(chunkName) || (chunkName += "[index]"), 
chunkName = chunkName.replace(/\[index\]/g, "" + index++), chunkName = chunkName.replace(/\[request\]/g, Template.toPath(dep.userRequest)));
const block = new AsyncDependenciesBlock({
...this.options.groupOptions,
name: chunkName
}, dep.loc, dep.userRequest);
block.addDependency(dep), this.addBlock(block);
}
}
}
if (!this.context && !this.options.resource) return callback();
compilation.fileSystemInfo.createSnapshot(startTime, null, this.context ? [ this.context ] : "string" == typeof this.options.resource ? [ this.options.resource ] : this.options.resource, null, SNAPSHOT_OPTIONS, ((err, snapshot) => {
if (err) return callback(err);
this.buildInfo.snapshot = snapshot, callback();
}));
} else callback();
}));
}
addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies) {
if (this.context) contextDependencies.add(this.context); else if ("string" == typeof this.options.resource) contextDependencies.add(this.options.resource); else {
if (!1 === this.options.resource) return;
for (const res of this.options.resource) contextDependencies.add(res);
}
}
getUserRequestMap(dependencies, chunkGraph) {
const moduleGraph = chunkGraph.moduleGraph, sortedDependencies = dependencies.filter((dependency => moduleGraph.getModule(dependency))).sort(((a, b) => a.userRequest === b.userRequest ? 0 : a.userRequest < b.userRequest ? -1 : 1)), map = Object.create(null);
for (const dep of sortedDependencies) {
const module = moduleGraph.getModule(dep);
map[dep.userRequest] = chunkGraph.getModuleId(module);
}
return map;
}
getFakeMap(dependencies, chunkGraph) {
if (!this.options.namespaceObject) return 9;
const moduleGraph = chunkGraph.moduleGraph;
let hasType = 0;
const comparator = compareModulesById(chunkGraph), sortedModules = dependencies.map((dependency => moduleGraph.getModule(dependency))).filter(Boolean).sort(comparator), fakeMap = Object.create(null);
for (const module of sortedModules) {
const exportsType = module.getExportsType(moduleGraph, "strict" === this.options.namespaceObject), id = chunkGraph.getModuleId(module);
switch (exportsType) {
case "namespace":
fakeMap[id] = 9, hasType |= 1;
break;

case "dynamic":
fakeMap[id] = 7, hasType |= 2;
break;

case "default-only":
fakeMap[id] = 1, hasType |= 4;
break;

case "default-with-named":
fakeMap[id] = 3, hasType |= 8;
break;

default:
throw new Error(`Unexpected exports type ${exportsType}`);
}
}
return 1 === hasType ? 9 : 2 === hasType ? 7 : 4 === hasType ? 1 : 8 === hasType ? 3 : 0 === hasType ? 9 : fakeMap;
}
getFakeMapInitStatement(fakeMap) {
return "object" == typeof fakeMap ? `var fakeMap = ${JSON.stringify(fakeMap, null, "\t")};` : "";
}
getReturn(type, asyncModule) {
return 9 === type ? "__webpack_require__(id)" : `${RuntimeGlobals.createFakeNamespaceObject}(id, ${type}${asyncModule ? " | 16" : ""})`;
}
getReturnModuleObjectSource(fakeMap, asyncModule, fakeMapDataExpression = "fakeMap[id]") {
return "number" == typeof fakeMap ? `return ${this.getReturn(fakeMap, asyncModule)};` : `return ${RuntimeGlobals.createFakeNamespaceObject}(id, ${fakeMapDataExpression}${asyncModule ? " | 16" : ""})`;
}
getSyncSource(dependencies, id, chunkGraph) {
const map = this.getUserRequestMap(dependencies, chunkGraph), fakeMap = this.getFakeMap(dependencies, chunkGraph), returnModuleObject = this.getReturnModuleObjectSource(fakeMap);
return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\t${returnModuleObject}\n}\nfunction webpackContextResolve(req) {\n\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = ${JSON.stringify(id)};`;
}
getWeakSyncSource(dependencies, id, chunkGraph) {
const map = this.getUserRequestMap(dependencies, chunkGraph), fakeMap = this.getFakeMap(dependencies, chunkGraph), returnModuleObject = this.getReturnModuleObjectSource(fakeMap);
return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\tif(!${RuntimeGlobals.moduleFactories}[id]) {\n\t\tvar e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t${returnModuleObject}\n}\nfunction webpackContextResolve(req) {\n\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nwebpackContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackContext;`;
}
getAsyncWeakSource(dependencies, id, {chunkGraph, runtimeTemplate}) {
const arrow = runtimeTemplate.supportsArrowFunction(), map = this.getUserRequestMap(dependencies, chunkGraph), fakeMap = this.getFakeMap(dependencies, chunkGraph), returnModuleObject = this.getReturnModuleObjectSource(fakeMap, !0);
return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${arrow ? "id =>" : "function(id)"} {\n\t\tif(!${RuntimeGlobals.moduleFactories}[id]) {\n\t\t\tvar e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\t${returnModuleObject}\n\t});\n}\nfunction webpackAsyncContextResolve(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(${arrow ? "() =>" : "function()"} {\n\t\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = ${runtimeTemplate.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
}
getEagerSource(dependencies, id, {chunkGraph, runtimeTemplate}) {
const arrow = runtimeTemplate.supportsArrowFunction(), map = this.getUserRequestMap(dependencies, chunkGraph), fakeMap = this.getFakeMap(dependencies, chunkGraph), thenFunction = 9 !== fakeMap ? `${arrow ? "id =>" : "function(id)"} {\n\t\t${this.getReturnModuleObjectSource(fakeMap)}\n\t}` : "__webpack_require__";
return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${thenFunction});\n}\nfunction webpackAsyncContextResolve(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(${arrow ? "() =>" : "function()"} {\n\t\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = ${runtimeTemplate.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
}
getLazyOnceSource(block, dependencies, id, {runtimeTemplate, chunkGraph}) {
const promise = runtimeTemplate.blockPromise({
chunkGraph,
block,
message: "lazy-once context",
runtimeRequirements: new Set
}), arrow = runtimeTemplate.supportsArrowFunction(), map = this.getUserRequestMap(dependencies, chunkGraph), fakeMap = this.getFakeMap(dependencies, chunkGraph), thenFunction = 9 !== fakeMap ? `${arrow ? "id =>" : "function(id)"} {\n\t\t${this.getReturnModuleObjectSource(fakeMap, !0)};\n\t}` : "__webpack_require__";
return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${thenFunction});\n}\nfunction webpackAsyncContextResolve(req) {\n\treturn ${promise}.then(${arrow ? "() =>" : "function()"} {\n\t\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = ${runtimeTemplate.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
}
getLazySource(blocks, id, {chunkGraph, runtimeTemplate}) {
const moduleGraph = chunkGraph.moduleGraph, arrow = runtimeTemplate.supportsArrowFunction();
let hasMultipleOrNoChunks = !1, hasNoChunk = !0;
const fakeMap = this.getFakeMap(blocks.map((b => b.dependencies[0])), chunkGraph), hasFakeMap = "object" == typeof fakeMap, items = blocks.map((block => {
const dependency = block.dependencies[0];
return {
dependency,
module: moduleGraph.getModule(dependency),
block,
userRequest: dependency.userRequest,
chunks: void 0
};
})).filter((item => item.module));
for (const item of items) {
const chunkGroup = chunkGraph.getBlockChunkGroup(item.block), chunks = chunkGroup && chunkGroup.chunks || [];
item.chunks = chunks, chunks.length > 0 && (hasNoChunk = !1), 1 !== chunks.length && (hasMultipleOrNoChunks = !0);
}
const shortMode = hasNoChunk && !hasFakeMap, sortedItems = items.sort(((a, b) => a.userRequest === b.userRequest ? 0 : a.userRequest < b.userRequest ? -1 : 1)), map = Object.create(null);
for (const item of sortedItems) {
const moduleId = chunkGraph.getModuleId(item.module);
if (shortMode) map[item.userRequest] = moduleId; else {
const arrayStart = [ moduleId ];
hasFakeMap && arrayStart.push(fakeMap[moduleId]), map[item.userRequest] = arrayStart.concat(item.chunks.map((chunk => chunk.id)));
}
}
const chunksStartPosition = hasFakeMap ? 2 : 1, requestPrefix = hasNoChunk ? "Promise.resolve()" : hasMultipleOrNoChunks ? `Promise.all(ids.slice(${chunksStartPosition}).map(${RuntimeGlobals.ensureChunk}))` : `${RuntimeGlobals.ensureChunk}(ids[${chunksStartPosition}])`, returnModuleObject = this.getReturnModuleObjectSource(fakeMap, !0, shortMode ? "invalid" : "ids[1]"), webpackAsyncContext = "Promise.resolve()" === requestPrefix ? `\nfunction webpackAsyncContext(req) {\n\treturn Promise.resolve().then(${arrow ? "() =>" : "function()"} {\n\t\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\n\t\t${shortMode ? "var id = map[req];" : "var ids = map[req], id = ids[0];"}\n\t\t${returnModuleObject}\n\t});\n}` : `function webpackAsyncContext(req) {\n\tif(!${RuntimeGlobals.hasOwnProperty}(map, req)) {\n\t\treturn Promise.resolve().then(${arrow ? "() =>" : "function()"} {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn ${requestPrefix}.then(${arrow ? "() =>" : "function()"} {\n\t\t${returnModuleObject}\n\t});\n}`;
return `var map = ${JSON.stringify(map, null, "\t")};\n${webpackAsyncContext}\nwebpackAsyncContext.keys = ${runtimeTemplate.returningFunction("Object.keys(map)")};\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
}
getSourceForEmptyContext(id, runtimeTemplate) {
return `function webpackEmptyContext(req) {\n\tvar e = new Error("Cannot find module '" + req + "'");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = ${runtimeTemplate.returningFunction("[]")};\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackEmptyContext;`;
}
getSourceForEmptyAsyncContext(id, runtimeTemplate) {
return `function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(${runtimeTemplate.supportsArrowFunction() ? "() =>" : "function()"} {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = ${runtimeTemplate.returningFunction("[]")};\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackEmptyAsyncContext;`;
}
getSourceString(asyncMode, {runtimeTemplate, chunkGraph}) {
const id = chunkGraph.getModuleId(this);
if ("lazy" === asyncMode) return this.blocks && this.blocks.length > 0 ? this.getLazySource(this.blocks, id, {
runtimeTemplate,
chunkGraph
}) : this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
if ("eager" === asyncMode) return this.dependencies && this.dependencies.length > 0 ? this.getEagerSource(this.dependencies, id, {
chunkGraph,
runtimeTemplate
}) : this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
if ("lazy-once" === asyncMode) {
const block = this.blocks[0];
return block ? this.getLazyOnceSource(block, block.dependencies, id, {
runtimeTemplate,
chunkGraph
}) : this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
}
return "async-weak" === asyncMode ? this.dependencies && this.dependencies.length > 0 ? this.getAsyncWeakSource(this.dependencies, id, {
chunkGraph,
runtimeTemplate
}) : this.getSourceForEmptyAsyncContext(id, runtimeTemplate) : "weak" === asyncMode && this.dependencies && this.dependencies.length > 0 ? this.getWeakSyncSource(this.dependencies, id, chunkGraph) : this.dependencies && this.dependencies.length > 0 ? this.getSyncSource(this.dependencies, id, chunkGraph) : this.getSourceForEmptyContext(id, runtimeTemplate);
}
getSource(sourceString, compilation) {
return this.useSourceMap || this.useSimpleSourceMap ? new OriginalSource(sourceString, `webpack://${makePathsRelative(compilation && compilation.compiler.context || "", this.identifier(), compilation && compilation.compiler.root)}`) : new RawSource(sourceString);
}
codeGeneration(context) {
const {chunkGraph, compilation} = context, sources = new Map;
sources.set("javascript", this.getSource(this.getSourceString(this.options.mode, context), compilation));
const set = new Set, allDeps = this.dependencies.length > 0 ? this.dependencies.slice() : [];
for (const block of this.blocks) for (const dep of block.dependencies) allDeps.push(dep);
if (set.add(RuntimeGlobals.module), set.add(RuntimeGlobals.hasOwnProperty), allDeps.length > 0) {
const asyncMode = this.options.mode;
set.add(RuntimeGlobals.require), "weak" === asyncMode ? set.add(RuntimeGlobals.moduleFactories) : "async-weak" === asyncMode ? (set.add(RuntimeGlobals.moduleFactories), 
set.add(RuntimeGlobals.ensureChunk)) : "lazy" !== asyncMode && "lazy-once" !== asyncMode || set.add(RuntimeGlobals.ensureChunk), 
9 !== this.getFakeMap(allDeps, chunkGraph) && set.add(RuntimeGlobals.createFakeNamespaceObject);
}
return {
sources,
runtimeRequirements: set
};
}
size(type) {
let size = 160;
for (const dependency of this.dependencies) {
size += 5 + dependency.userRequest.length;
}
return size;
}
serialize(context) {
const {write} = context;
write(this._identifier), write(this._forceBuild), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this._identifier = read(), this._forceBuild = read(), super.deserialize(context);
}
}
makeSerializable(ContextModule, "webpack/lib/ContextModule"), module.exports = ContextModule;
},
41875: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), {AsyncSeriesWaterfallHook, SyncWaterfallHook} = __webpack_require__(89991), ContextModule = __webpack_require__(11627), ModuleFactory = __webpack_require__(37019), ContextElementDependency = __webpack_require__(84407), LazySet = __webpack_require__(92585), {cachedSetProperty} = __webpack_require__(8639), {createFakeHook} = __webpack_require__(33469), {join} = __webpack_require__(57075), EMPTY_RESOLVE_OPTIONS = {};
module.exports = class extends ModuleFactory {
constructor(resolverFactory) {
super();
const alternativeRequests = new AsyncSeriesWaterfallHook([ "modules", "options" ]);
this.hooks = Object.freeze({
beforeResolve: new AsyncSeriesWaterfallHook([ "data" ]),
afterResolve: new AsyncSeriesWaterfallHook([ "data" ]),
contextModuleFiles: new SyncWaterfallHook([ "files" ]),
alternatives: createFakeHook({
name: "alternatives",
intercept: interceptor => {
throw new Error("Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead");
},
tap: (options, fn) => {
alternativeRequests.tap(options, fn);
},
tapAsync: (options, fn) => {
alternativeRequests.tapAsync(options, ((items, _options, callback) => fn(items, callback)));
},
tapPromise: (options, fn) => {
alternativeRequests.tapPromise(options, fn);
}
}, "ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.", "DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES"),
alternativeRequests
}), this.resolverFactory = resolverFactory;
}
create(data, callback) {
const context = data.context, dependencies = data.dependencies, resolveOptions = data.resolveOptions, dependency = dependencies[0], fileDependencies = new LazySet, missingDependencies = new LazySet, contextDependencies = new LazySet;
this.hooks.beforeResolve.callAsync({
context,
dependencies,
resolveOptions,
fileDependencies,
missingDependencies,
contextDependencies,
...dependency.options
}, ((err, beforeResolveResult) => {
if (err) return callback(err, {
fileDependencies,
missingDependencies,
contextDependencies
});
if (!beforeResolveResult) return callback(null, {
fileDependencies,
missingDependencies,
contextDependencies
});
const context = beforeResolveResult.context, request = beforeResolveResult.request, resolveOptions = beforeResolveResult.resolveOptions;
let loaders, resource, loadersPrefix = "";
const idx = request.lastIndexOf("!");
if (idx >= 0) {
let i, loadersRequest = request.slice(0, idx + 1);
for (i = 0; i < loadersRequest.length && "!" === loadersRequest[i]; i++) loadersPrefix += "!";
loadersRequest = loadersRequest.slice(i).replace(/!+$/, "").replace(/!!+/g, "!"), 
loaders = "" === loadersRequest ? [] : loadersRequest.split("!"), resource = request.slice(idx + 1);
} else loaders = [], resource = request;
const contextResolver = this.resolverFactory.get("context", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, "dependencyType", dependencies[0].category) : resolveOptions), loaderResolver = this.resolverFactory.get("loader");
asyncLib.parallel([ callback => {
const results = [];
contextResolver.resolve({}, context, resource, {
fileDependencies,
missingDependencies,
contextDependencies,
yield: obj => results.push(obj)
}, (err => {
if (err) return callback(err);
callback(null, results);
}));
}, callback => {
asyncLib.map(loaders, ((loader, callback) => {
loaderResolver.resolve({}, context, loader, {
fileDependencies,
missingDependencies,
contextDependencies
}, ((err, result) => {
if (err) return callback(err);
callback(null, result);
}));
}), callback);
} ], ((err, result) => {
if (err) return callback(err, {
fileDependencies,
missingDependencies,
contextDependencies
});
let [contextResult, loaderResult] = result;
if (contextResult.length > 1) {
const first = contextResult[0];
contextResult = contextResult.filter((r => r.path)), 0 === contextResult.length && contextResult.push(first);
}
this.hooks.afterResolve.callAsync({
addon: loadersPrefix + loaderResult.join("!") + (loaderResult.length > 0 ? "!" : ""),
resource: contextResult.length > 1 ? contextResult.map((r => r.path)) : contextResult[0].path,
resolveDependencies: this.resolveDependencies.bind(this),
resourceQuery: contextResult[0].query,
resourceFragment: contextResult[0].fragment,
...beforeResolveResult
}, ((err, result) => err ? callback(err, {
fileDependencies,
missingDependencies,
contextDependencies
}) : callback(null, result ? {
module: new ContextModule(result.resolveDependencies, result),
fileDependencies,
missingDependencies,
contextDependencies
} : {
fileDependencies,
missingDependencies,
contextDependencies
})));
}));
}));
}
resolveDependencies(fs, options, callback) {
const cmf = this, {resource, resourceQuery, resourceFragment, recursive, regExp, include, exclude, referencedExports, category, typePrefix} = options;
if (!regExp || !resource) return callback(null, []);
const addDirectoryChecked = (ctx, directory, visited, callback) => {
fs.realpath(directory, ((err, realPath) => {
if (err) return callback(err);
if (visited.has(realPath)) return callback(null, []);
let recursionStack;
addDirectory(ctx, directory, ((_, dir, callback) => {
void 0 === recursionStack && (recursionStack = new Set(visited), recursionStack.add(realPath)), 
addDirectoryChecked(ctx, dir, recursionStack, callback);
}), callback);
}));
}, addDirectory = (ctx, directory, addSubDirectory, callback) => {
fs.readdir(directory, ((err, files) => {
if (err) return callback(err);
const processedFiles = cmf.hooks.contextModuleFiles.call(files.map((file => file.normalize("NFC"))));
if (!processedFiles || 0 === processedFiles.length) return callback(null, []);
asyncLib.map(processedFiles.filter((p => 0 !== p.indexOf("."))), ((segment, callback) => {
const subResource = join(fs, directory, segment);
exclude && subResource.match(exclude) ? callback() : fs.stat(subResource, ((err, stat) => {
if (err) return "ENOENT" === err.code ? callback() : callback(err);
if (stat.isDirectory()) {
if (!recursive) return callback();
addSubDirectory(ctx, subResource, callback);
} else if (!stat.isFile() || include && !subResource.match(include)) callback(); else {
const obj = {
context: ctx,
request: "." + subResource.slice(ctx.length).replace(/\\/g, "/")
};
this.hooks.alternativeRequests.callAsync([ obj ], options, ((err, alternatives) => {
if (err) return callback(err);
alternatives = alternatives.filter((obj => regExp.test(obj.request))).map((obj => {
const dep = new ContextElementDependency(`${obj.request}${resourceQuery}${resourceFragment}`, obj.request, typePrefix, category, referencedExports, obj.context);
return dep.optional = !0, dep;
})), callback(null, alternatives);
}));
}
}));
}), ((err, result) => {
if (err) return callback(err);
if (!result) return callback(null, []);
const flattenedResult = [];
for (const item of result) item && flattenedResult.push(...item);
callback(null, flattenedResult);
}));
}));
}, addSubDirectory = (ctx, dir, callback) => addDirectory(ctx, dir, addSubDirectory, callback), visitResource = (resource, callback) => {
"function" == typeof fs.realpath ? addDirectoryChecked(resource, resource, new Set, callback) : addDirectory(resource, resource, addSubDirectory, callback);
};
"string" == typeof resource ? visitResource(resource, callback) : asyncLib.map(resource, visitResource, ((err, result) => {
if (err) return callback(err);
const temp = new Set, res = [];
for (let i = 0; i < result.length; i++) {
const inner = result[i];
for (const el of inner) temp.has(el.userRequest) || (res.push(el), temp.add(el.userRequest));
}
callback(null, res);
}));
}
};
},
20646: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ContextElementDependency = __webpack_require__(84407), {join} = __webpack_require__(57075);
const createResolveDependenciesFromContextMap = createContextMap => (fs, options, callback) => {
createContextMap(fs, ((err, map) => {
if (err) return callback(err);
const dependencies = Object.keys(map).map((key => new ContextElementDependency(map[key] + options.resourceQuery + options.resourceFragment, key, options.category, options.referencedExports)));
callback(null, dependencies);
}));
};
module.exports = class {
constructor(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp) {
this.resourceRegExp = resourceRegExp, "function" == typeof newContentResource ? this.newContentCallback = newContentResource : "string" == typeof newContentResource && "object" == typeof newContentRecursive ? (this.newContentResource = newContentResource, 
this.newContentCreateContextMap = (fs, callback) => {
callback(null, newContentRecursive);
}) : "string" == typeof newContentResource && "function" == typeof newContentRecursive ? (this.newContentResource = newContentResource, 
this.newContentCreateContextMap = newContentRecursive) : ("string" != typeof newContentResource && (newContentRegExp = newContentRecursive, 
newContentRecursive = newContentResource, newContentResource = void 0), "boolean" != typeof newContentRecursive && (newContentRegExp = newContentRecursive, 
newContentRecursive = void 0), this.newContentResource = newContentResource, this.newContentRecursive = newContentRecursive, 
this.newContentRegExp = newContentRegExp);
}
apply(compiler) {
const resourceRegExp = this.resourceRegExp, newContentCallback = this.newContentCallback, newContentResource = this.newContentResource, newContentRecursive = this.newContentRecursive, newContentRegExp = this.newContentRegExp, newContentCreateContextMap = this.newContentCreateContextMap;
compiler.hooks.contextModuleFactory.tap("ContextReplacementPlugin", (cmf => {
cmf.hooks.beforeResolve.tap("ContextReplacementPlugin", (result => {
if (result) {
if (resourceRegExp.test(result.request)) if (void 0 !== newContentResource && (result.request = newContentResource), 
void 0 !== newContentRecursive && (result.recursive = newContentRecursive), void 0 !== newContentRegExp && (result.regExp = newContentRegExp), 
"function" == typeof newContentCallback) newContentCallback(result); else for (const d of result.dependencies) d.critical && (d.critical = !1);
return result;
}
})), cmf.hooks.afterResolve.tap("ContextReplacementPlugin", (result => {
if (result) {
if (resourceRegExp.test(result.resource)) if (void 0 !== newContentResource && (newContentResource.startsWith("/") || newContentResource.length > 1 && ":" === newContentResource[1] ? result.resource = newContentResource : result.resource = join(compiler.inputFileSystem, result.resource, newContentResource)), 
void 0 !== newContentRecursive && (result.recursive = newContentRecursive), void 0 !== newContentRegExp && (result.regExp = newContentRegExp), 
"function" == typeof newContentCreateContextMap && (result.resolveDependencies = createResolveDependenciesFromContextMap(newContentCreateContextMap)), 
"function" == typeof newContentCallback) {
const origResource = result.resource;
newContentCallback(result), result.resource !== origResource && !result.resource.startsWith("/") && (result.resource.length <= 1 || ":" !== result.resource[1]) && (result.resource = join(compiler.inputFileSystem, origResource, result.resource));
} else for (const d of result.dependencies) d.critical && (d.critical = !1);
return result;
}
}));
}));
}
};
},
98665: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), WebpackError = __webpack_require__(64326), ConstDependency = __webpack_require__(30339), BasicEvaluatedExpression = __webpack_require__(47789), {evaluateToString, toConstantDependency} = __webpack_require__(78802), createHash = __webpack_require__(27466);
class RuntimeValue {
constructor(fn, options) {
this.fn = fn, Array.isArray(options) && (options = {
fileDependencies: options
}), this.options = options || {};
}
get fileDependencies() {
return !0 === this.options || this.options.fileDependencies;
}
exec(parser, valueCacheVersions, key) {
const buildInfo = parser.state.module.buildInfo;
if (!0 === this.options) buildInfo.cacheable = !1; else {
if (this.options.fileDependencies) for (const dep of this.options.fileDependencies) buildInfo.fileDependencies.add(dep);
if (this.options.contextDependencies) for (const dep of this.options.contextDependencies) buildInfo.contextDependencies.add(dep);
if (this.options.missingDependencies) for (const dep of this.options.missingDependencies) buildInfo.missingDependencies.add(dep);
if (this.options.buildDependencies) for (const dep of this.options.buildDependencies) buildInfo.buildDependencies.add(dep);
}
return this.fn({
module: parser.state.module,
key,
get version() {
return valueCacheVersions.get(VALUE_DEP_PREFIX + key);
}
});
}
getCacheVersion() {
return !0 === this.options ? void 0 : ("function" == typeof this.options.version ? this.options.version() : this.options.version) || "unset";
}
}
const stringifyObj = (obj, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) => {
let code, arr = Array.isArray(obj);
switch (code = arr ? `[${obj.map((code => toCode(code, parser, valueCacheVersions, key, runtimeTemplate, null))).join(",")}]` : `{${Object.keys(obj).map((key => {
const code = obj[key];
return JSON.stringify(key) + ":" + toCode(code, parser, valueCacheVersions, key, runtimeTemplate, null);
})).join(",")}}`, asiSafe) {
case null:
return code;

case !0:
return arr ? code : `(${code})`;

case !1:
return arr ? `;${code}` : `;(${code})`;

default:
return `/*#__PURE__*/Object(${code})`;
}
}, toCode = (code, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) => null === code ? "null" : void 0 === code ? "undefined" : Object.is(code, -0) ? "-0" : code instanceof RuntimeValue ? toCode(code.exec(parser, valueCacheVersions, key), parser, valueCacheVersions, key, runtimeTemplate, asiSafe) : code instanceof RegExp && code.toString ? code.toString() : "function" == typeof code && code.toString ? "(" + code.toString() + ")" : "object" == typeof code ? stringifyObj(code, parser, valueCacheVersions, key, runtimeTemplate, asiSafe) : "bigint" == typeof code ? runtimeTemplate.supportsBigIntLiteral() ? `${code}n` : `BigInt("${code}")` : code + "", toCacheVersion = code => {
if (null === code) return "null";
if (void 0 === code) return "undefined";
if (Object.is(code, -0)) return "-0";
if (code instanceof RuntimeValue) return code.getCacheVersion();
if (code instanceof RegExp && code.toString) return code.toString();
if ("function" == typeof code && code.toString) return "(" + code.toString() + ")";
if ("object" == typeof code) {
const items = Object.keys(code).map((key => ({
key,
value: toCacheVersion(code[key])
})));
if (items.some((({value}) => void 0 === value))) return;
return `{${items.map((({key, value}) => `${key}: ${value}`)).join(", ")}}`;
}
return "bigint" == typeof code ? `${code}n` : code + "";
}, VALUE_DEP_PREFIX = "webpack/DefinePlugin ", VALUE_DEP_MAIN = "webpack/DefinePlugin_hash";
module.exports = class {
constructor(definitions) {
this.definitions = definitions;
}
static runtimeValue(fn, options) {
return new RuntimeValue(fn, options);
}
apply(compiler) {
const definitions = this.definitions;
compiler.hooks.compilation.tap("DefinePlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
const {runtimeTemplate} = compilation, mainHash = createHash(compilation.outputOptions.hashFunction);
mainHash.update(compilation.valueCacheVersions.get(VALUE_DEP_MAIN) || "");
const handler = parser => {
const mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);
parser.hooks.program.tap("DefinePlugin", (() => {
const {buildInfo} = parser.state.module;
buildInfo.valueDependencies || (buildInfo.valueDependencies = new Map), buildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);
}));
const addValueDependency = key => {
const {buildInfo} = parser.state.module;
buildInfo.valueDependencies.set(VALUE_DEP_PREFIX + key, compilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key));
}, withValueDependency = (key, fn) => (...args) => (addValueDependency(key), fn(...args)), walkDefinitions = (definitions, prefix) => {
Object.keys(definitions).forEach((key => {
const code = definitions[key];
if (code && "object" == typeof code && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) return walkDefinitions(code, prefix + key + "."), 
void applyObjectDefine(prefix + key, code);
applyDefineKey(prefix, key), applyDefine(prefix + key, code);
}));
}, applyDefineKey = (prefix, key) => {
const splittedKey = key.split(".");
splittedKey.slice(1).forEach(((_, i) => {
const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
parser.hooks.canRename.for(fullKey).tap("DefinePlugin", (() => (addValueDependency(key), 
!0)));
}));
}, applyDefine = (key, code) => {
const originalKey = key, isTypeof = /^typeof\s+/.test(key);
isTypeof && (key = key.replace(/^typeof\s+/, ""));
let recurse = !1, recurseTypeof = !1;
isTypeof || (parser.hooks.canRename.for(key).tap("DefinePlugin", (() => (addValueDependency(originalKey), 
!0))), parser.hooks.evaluateIdentifier.for(key).tap("DefinePlugin", (expr => {
if (recurse) return;
addValueDependency(originalKey), recurse = !0;
const res = parser.evaluate(toCode(code, parser, compilation.valueCacheVersions, key, runtimeTemplate, null));
return recurse = !1, res.setRange(expr.range), res;
})), parser.hooks.expression.for(key).tap("DefinePlugin", (expr => {
addValueDependency(originalKey);
const strCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, !parser.isAsiPosition(expr.range[0]));
return /__webpack_require__\s*(!?\.)/.test(strCode) ? toConstantDependency(parser, strCode, [ RuntimeGlobals.require ])(expr) : /__webpack_require__/.test(strCode) ? toConstantDependency(parser, strCode, [ RuntimeGlobals.requireScope ])(expr) : toConstantDependency(parser, strCode)(expr);
}))), parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", (expr => {
if (recurseTypeof) return;
recurseTypeof = !0, addValueDependency(originalKey);
const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, null), typeofCode = isTypeof ? codeCode : "typeof (" + codeCode + ")", res = parser.evaluate(typeofCode);
return recurseTypeof = !1, res.setRange(expr.range), res;
})), parser.hooks.typeof.for(key).tap("DefinePlugin", (expr => {
addValueDependency(originalKey);
const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, null), typeofCode = isTypeof ? codeCode : "typeof (" + codeCode + ")", res = parser.evaluate(typeofCode);
if (res.isString()) return toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);
}));
}, applyObjectDefine = (key, obj) => {
parser.hooks.canRename.for(key).tap("DefinePlugin", (() => (addValueDependency(key), 
!0))), parser.hooks.evaluateIdentifier.for(key).tap("DefinePlugin", (expr => (addValueDependency(key), 
(new BasicEvaluatedExpression).setTruthy().setSideEffects(!1).setRange(expr.range)))), 
parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", withValueDependency(key, evaluateToString("object"))), 
parser.hooks.expression.for(key).tap("DefinePlugin", (expr => {
addValueDependency(key);
const strCode = stringifyObj(obj, parser, compilation.valueCacheVersions, key, runtimeTemplate, !parser.isAsiPosition(expr.range[0]));
return /__webpack_require__\s*(!?\.)/.test(strCode) ? toConstantDependency(parser, strCode, [ RuntimeGlobals.require ])(expr) : /__webpack_require__/.test(strCode) ? toConstantDependency(parser, strCode, [ RuntimeGlobals.requireScope ])(expr) : toConstantDependency(parser, strCode)(expr);
})), parser.hooks.typeof.for(key).tap("DefinePlugin", withValueDependency(key, toConstantDependency(parser, JSON.stringify("object"))));
};
walkDefinitions(definitions, "");
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("DefinePlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("DefinePlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("DefinePlugin", handler);
const walkDefinitionsForValues = (definitions, prefix) => {
Object.keys(definitions).forEach((key => {
const code = definitions[key], version = toCacheVersion(code), name = VALUE_DEP_PREFIX + prefix + key;
mainHash.update("|" + prefix + key);
const oldVersion = compilation.valueCacheVersions.get(name);
if (void 0 === oldVersion) compilation.valueCacheVersions.set(name, version); else if (oldVersion !== version) {
const warning = new WebpackError(`DefinePlugin\nConflicting values for '${prefix + key}'`);
warning.details = `'${oldVersion}' !== '${version}'`, warning.hideStack = !0, compilation.warnings.push(warning);
}
!code || "object" != typeof code || code instanceof RuntimeValue || code instanceof RegExp || walkDefinitionsForValues(code, prefix + key + ".");
}));
};
walkDefinitionsForValues(definitions, ""), compilation.valueCacheVersions.set(VALUE_DEP_MAIN, mainHash.digest("hex").slice(0, 8));
}));
}
};
},
98943: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {OriginalSource, RawSource} = __webpack_require__(37946), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), DelegatedSourceDependency = __webpack_require__(10307), StaticExportsDependency = __webpack_require__(21776), makeSerializable = __webpack_require__(45898), TYPES = new Set([ "javascript" ]), RUNTIME_REQUIREMENTS = new Set([ RuntimeGlobals.module, RuntimeGlobals.require ]);
class DelegatedModule extends Module {
constructor(sourceRequest, data, type, userRequest, originalRequest) {
super("javascript/dynamic", null), this.sourceRequest = sourceRequest, this.request = data.id, 
this.delegationType = type, this.userRequest = userRequest, this.originalRequest = originalRequest, 
this.delegateData = data, this.delegatedSourceDependency = void 0;
}
getSourceTypes() {
return TYPES;
}
libIdent(options) {
return "string" == typeof this.originalRequest ? this.originalRequest : this.originalRequest.libIdent(options);
}
identifier() {
return `delegated ${JSON.stringify(this.request)} from ${this.sourceRequest}`;
}
readableIdentifier(requestShortener) {
return `delegated ${this.userRequest} from ${this.sourceRequest}`;
}
needBuild(context, callback) {
return callback(null, !this.buildMeta);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {
...this.delegateData.buildMeta
}, this.buildInfo = {}, this.dependencies.length = 0, this.delegatedSourceDependency = new DelegatedSourceDependency(this.sourceRequest), 
this.addDependency(this.delegatedSourceDependency), this.addDependency(new StaticExportsDependency(this.delegateData.exports || !0, !1)), 
callback();
}
codeGeneration({runtimeTemplate, moduleGraph, chunkGraph}) {
const dep = this.dependencies[0], sourceModule = moduleGraph.getModule(dep);
let str;
if (sourceModule) {
switch (str = `module.exports = (${runtimeTemplate.moduleExports({
module: sourceModule,
chunkGraph,
request: dep.request,
runtimeRequirements: new Set
})})`, this.delegationType) {
case "require":
str += `(${JSON.stringify(this.request)})`;
break;

case "object":
str += `[${JSON.stringify(this.request)}]`;
}
str += ";";
} else str = runtimeTemplate.throwMissingModuleErrorBlock({
request: this.sourceRequest
});
const sources = new Map;
return this.useSourceMap || this.useSimpleSourceMap ? sources.set("javascript", new OriginalSource(str, this.identifier())) : sources.set("javascript", new RawSource(str)), 
{
sources,
runtimeRequirements: RUNTIME_REQUIREMENTS
};
}
size(type) {
return 42;
}
updateHash(hash, context) {
hash.update(this.delegationType), hash.update(JSON.stringify(this.request)), super.updateHash(hash, context);
}
serialize(context) {
const {write} = context;
write(this.sourceRequest), write(this.delegateData), write(this.delegationType), 
write(this.userRequest), write(this.originalRequest), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new DelegatedModule(read(), read(), read(), read(), read());
return obj.deserialize(context), obj;
}
updateCacheModule(module) {
super.updateCacheModule(module);
const m = module;
this.delegationType = m.delegationType, this.userRequest = m.userRequest, this.originalRequest = m.originalRequest, 
this.delegateData = m.delegateData;
}
cleanupForCache() {
super.cleanupForCache(), this.delegateData = void 0;
}
}
makeSerializable(DelegatedModule, "webpack/lib/DelegatedModule"), module.exports = DelegatedModule;
},
14441: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DelegatedModule = __webpack_require__(98943);
module.exports = class {
constructor(options) {
this.options = options, options.type = options.type || "require", options.extensions = options.extensions || [ "", ".js", ".json", ".wasm" ];
}
apply(normalModuleFactory) {
const scope = this.options.scope;
scope ? normalModuleFactory.hooks.factorize.tapAsync("DelegatedModuleFactoryPlugin", ((data, callback) => {
const [dependency] = data.dependencies, {request} = dependency;
if (request && request.startsWith(`${scope}/`)) {
const innerRequest = "." + request.slice(scope.length);
let resolved;
if (innerRequest in this.options.content) return resolved = this.options.content[innerRequest], 
callback(null, new DelegatedModule(this.options.source, resolved, this.options.type, innerRequest, request));
for (let i = 0; i < this.options.extensions.length; i++) {
const extension = this.options.extensions[i], requestPlusExt = innerRequest + extension;
if (requestPlusExt in this.options.content) return resolved = this.options.content[requestPlusExt], 
callback(null, new DelegatedModule(this.options.source, resolved, this.options.type, requestPlusExt, request + extension));
}
}
return callback();
})) : normalModuleFactory.hooks.module.tap("DelegatedModuleFactoryPlugin", (module => {
const request = module.libIdent(this.options);
if (request && request in this.options.content) {
const resolved = this.options.content[request];
return new DelegatedModule(this.options.source, resolved, this.options.type, request, module);
}
return module;
}));
}
};
},
44337: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DelegatedModuleFactoryPlugin = __webpack_require__(14441), DelegatedSourceDependency = __webpack_require__(10307);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
compiler.hooks.compilation.tap("DelegatedPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory);
})), compiler.hooks.compile.tap("DelegatedPlugin", (({normalModuleFactory}) => {
new DelegatedModuleFactoryPlugin({
associatedObjectForCache: compiler.root,
...this.options
}).apply(normalModuleFactory);
}));
}
};
},
17461: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898);
class DependenciesBlock {
constructor() {
this.dependencies = [], this.blocks = [], this.parent = void 0;
}
getRootBlock() {
let current = this;
for (;current.parent; ) current = current.parent;
return current;
}
addBlock(block) {
this.blocks.push(block), block.parent = this;
}
addDependency(dependency) {
this.dependencies.push(dependency);
}
removeDependency(dependency) {
const idx = this.dependencies.indexOf(dependency);
idx >= 0 && this.dependencies.splice(idx, 1);
}
clearDependenciesAndBlocks() {
this.dependencies.length = 0, this.blocks.length = 0;
}
updateHash(hash, context) {
for (const dep of this.dependencies) dep.updateHash(hash, context);
for (const block of this.blocks) block.updateHash(hash, context);
}
serialize({write}) {
write(this.dependencies), write(this.blocks);
}
deserialize({read}) {
this.dependencies = read(), this.blocks = read();
for (const block of this.blocks) block.parent = this;
}
}
makeSerializable(DependenciesBlock, "webpack/lib/DependenciesBlock"), module.exports = DependenciesBlock;
},
14926: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const memoize = __webpack_require__(98216), TRANSITIVE = Symbol("transitive"), getIgnoredModule = memoize((() => new (__webpack_require__(85315))("/* (ignored) */", "ignored", "(ignored)")));
class Dependency {
constructor() {
this._parentModule = void 0, this._parentDependenciesBlock = void 0, this._parentDependenciesBlockIndex = -1, 
this.weak = !1, this.optional = !1, this._locSL = 0, this._locSC = 0, this._locEL = 0, 
this._locEC = 0, this._locI = void 0, this._locN = void 0, this._loc = void 0;
}
get type() {
return "unknown";
}
get category() {
return "unknown";
}
get loc() {
if (void 0 !== this._loc) return this._loc;
const loc = {};
return this._locSL > 0 && (loc.start = {
line: this._locSL,
column: this._locSC
}), this._locEL > 0 && (loc.end = {
line: this._locEL,
column: this._locEC
}), void 0 !== this._locN && (loc.name = this._locN), void 0 !== this._locI && (loc.index = this._locI), 
this._loc = loc;
}
set loc(loc) {
"start" in loc && "object" == typeof loc.start ? (this._locSL = loc.start.line || 0, 
this._locSC = loc.start.column || 0) : (this._locSL = 0, this._locSC = 0), "end" in loc && "object" == typeof loc.end ? (this._locEL = loc.end.line || 0, 
this._locEC = loc.end.column || 0) : (this._locEL = 0, this._locEC = 0), this._locI = "index" in loc ? loc.index : void 0, 
this._locN = "name" in loc ? loc.name : void 0, this._loc = loc;
}
setLoc(startLine, startColumn, endLine, endColumn) {
this._locSL = startLine, this._locSC = startColumn, this._locEL = endLine, this._locEC = endColumn, 
this._locI = void 0, this._locN = void 0, this._loc = void 0;
}
getContext() {}
getResourceIdentifier() {
return null;
}
couldAffectReferencingModule() {
return TRANSITIVE;
}
getReference(moduleGraph) {
throw new Error("Dependency.getReference was removed in favor of Dependency.getReferencedExports, ModuleGraph.getModule and ModuleGraph.getConnection().active");
}
getReferencedExports(moduleGraph, runtime) {
return Dependency.EXPORTS_OBJECT_REFERENCED;
}
getCondition(moduleGraph) {
return null;
}
getExports(moduleGraph) {}
getWarnings(moduleGraph) {
return null;
}
getErrors(moduleGraph) {
return null;
}
updateHash(hash, context) {}
getNumberOfIdOccurrences() {
return 1;
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !0;
}
createIgnoredModule(context) {
return getIgnoredModule();
}
serialize({write}) {
write(this.weak), write(this.optional), write(this._locSL), write(this._locSC), 
write(this._locEL), write(this._locEC), write(this._locI), write(this._locN);
}
deserialize({read}) {
this.weak = read(), this.optional = read(), this._locSL = read(), this._locSC = read(), 
this._locEL = read(), this._locEC = read(), this._locI = read(), this._locN = read();
}
}
Dependency.NO_EXPORTS_REFERENCED = [], Dependency.EXPORTS_OBJECT_REFERENCED = [ [] ], 
Object.defineProperty(Dependency.prototype, "module", {
get() {
throw new Error("module property was removed from Dependency (use compilation.moduleGraph.getModule(dependency) instead)");
},
set() {
throw new Error("module property was removed from Dependency (use compilation.moduleGraph.updateModule(dependency, module) instead)");
}
}), Object.defineProperty(Dependency.prototype, "disconnect", {
get() {
throw new Error("disconnect was removed from Dependency (Dependency no longer carries graph specific information)");
}
}), Dependency.TRANSITIVE = TRANSITIVE, module.exports = Dependency;
},
44515: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
module.exports = class {
apply(dependency, source, templateContext) {
throw new (__webpack_require__(91266));
}
};
},
92311: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const createHash = __webpack_require__(27466);
class DependencyTemplates {
constructor(hashFunction = "md4") {
this._map = new Map, this._hash = "31d6cfe0d16ae931b73c59d7e0c089c0", this._hashFunction = hashFunction;
}
get(dependency) {
return this._map.get(dependency);
}
set(dependency, dependencyTemplate) {
this._map.set(dependency, dependencyTemplate);
}
updateHash(part) {
const hash = createHash(this._hashFunction);
hash.update(`${this._hash}${part}`), this._hash = hash.digest("hex");
}
getHash() {
return this._hash;
}
clone() {
const newInstance = new DependencyTemplates(this._hashFunction);
return newInstance._map = new Map(this._map), newInstance._hash = this._hash, newInstance;
}
}
module.exports = DependencyTemplates;
},
73692: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DllModuleFactory = __webpack_require__(21104), DllEntryDependency = __webpack_require__(59968), EntryDependency = __webpack_require__(74989);
module.exports = class {
constructor(context, entries, options) {
this.context = context, this.entries = entries, this.options = options;
}
apply(compiler) {
compiler.hooks.compilation.tap("DllEntryPlugin", ((compilation, {normalModuleFactory}) => {
const dllModuleFactory = new DllModuleFactory;
compilation.dependencyFactories.set(DllEntryDependency, dllModuleFactory), compilation.dependencyFactories.set(EntryDependency, normalModuleFactory);
})), compiler.hooks.make.tapAsync("DllEntryPlugin", ((compilation, callback) => {
compilation.addEntry(this.context, new DllEntryDependency(this.entries.map(((e, idx) => {
const dep = new EntryDependency(e);
return dep.loc = {
name: this.options.name,
index: idx
}, dep;
})), this.options.name), this.options, callback);
}));
}
};
},
46469: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), TYPES = new Set([ "javascript" ]), RUNTIME_REQUIREMENTS = new Set([ RuntimeGlobals.require, RuntimeGlobals.module ]);
class DllModule extends Module {
constructor(context, dependencies, name) {
super("javascript/dynamic", context), this.dependencies = dependencies, this.name = name;
}
getSourceTypes() {
return TYPES;
}
identifier() {
return `dll ${this.name}`;
}
readableIdentifier(requestShortener) {
return `dll ${this.name}`;
}
build(options, compilation, resolver, fs, callback) {
return this.buildMeta = {}, this.buildInfo = {}, callback();
}
codeGeneration(context) {
const sources = new Map;
return sources.set("javascript", new RawSource("module.exports = __webpack_require__;")), 
{
sources,
runtimeRequirements: RUNTIME_REQUIREMENTS
};
}
needBuild(context, callback) {
return callback(null, !this.buildMeta);
}
size(type) {
return 12;
}
updateHash(hash, context) {
hash.update(`dll module${this.name || ""}`), super.updateHash(hash, context);
}
serialize(context) {
context.write(this.name), super.serialize(context);
}
deserialize(context) {
this.name = context.read(), super.deserialize(context);
}
updateCacheModule(module) {
super.updateCacheModule(module), this.dependencies = module.dependencies;
}
cleanupForCache() {
super.cleanupForCache(), this.dependencies = void 0;
}
}
makeSerializable(DllModule, "webpack/lib/DllModule"), module.exports = DllModule;
},
21104: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DllModule = __webpack_require__(46469), ModuleFactory = __webpack_require__(37019);
module.exports = class extends ModuleFactory {
constructor() {
super(), this.hooks = Object.freeze({});
}
create(data, callback) {
const dependency = data.dependencies[0];
callback(null, {
module: new DllModule(data.context, dependency.dependencies, dependency.name)
});
}
};
},
19443: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DllEntryPlugin = __webpack_require__(73692), FlagAllModulesAsUsedPlugin = __webpack_require__(37899), LibManifestPlugin = __webpack_require__(13745), validate = __webpack_require__(59586)(__webpack_require__(65662), (() => __webpack_require__(28991)), {
name: "Dll Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options) {
validate(options), this.options = {
...options,
entryOnly: !1 !== options.entryOnly
};
}
apply(compiler) {
compiler.hooks.entryOption.tap("DllPlugin", ((context, entry) => {
if ("function" == typeof entry) throw new Error("DllPlugin doesn't support dynamic entry (function) yet");
for (const name of Object.keys(entry)) {
const options = {
name,
filename: entry.filename
};
new DllEntryPlugin(context, entry[name].import, options).apply(compiler);
}
return !0;
})), new LibManifestPlugin(this.options).apply(compiler), this.options.entryOnly || new FlagAllModulesAsUsedPlugin("DllPlugin").apply(compiler);
}
};
},
2835: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const parseJson = __webpack_require__(73153), DelegatedModuleFactoryPlugin = __webpack_require__(14441), ExternalModuleFactoryPlugin = __webpack_require__(30229), WebpackError = __webpack_require__(64326), DelegatedSourceDependency = __webpack_require__(10307), createSchemaValidation = __webpack_require__(59586), makePathsRelative = __webpack_require__(63264).makePathsRelative, validate = createSchemaValidation(__webpack_require__(7178), (() => __webpack_require__(67138)), {
name: "Dll Reference Plugin",
baseDataPath: "options"
});
class DllManifestError extends WebpackError {
constructor(filename, message) {
super(), this.name = "DllManifestError", this.message = `Dll manifest ${filename}\n${message}`;
}
}
module.exports = class {
constructor(options) {
validate(options), this.options = options, this._compilationData = new WeakMap;
}
apply(compiler) {
compiler.hooks.compilation.tap("DllReferencePlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory);
})), compiler.hooks.beforeCompile.tapAsync("DllReferencePlugin", ((params, callback) => {
if ("manifest" in this.options) {
const manifest = this.options.manifest;
if ("string" == typeof manifest) return void compiler.inputFileSystem.readFile(manifest, ((err, result) => {
if (err) return callback(err);
const data = {
path: manifest,
data: void 0,
error: void 0
};
try {
data.data = parseJson(result.toString("utf-8"));
} catch (e) {
const manifestPath = makePathsRelative(compiler.options.context, manifest, compiler.root);
data.error = new DllManifestError(manifestPath, e.message);
}
return this._compilationData.set(params, data), callback();
}));
}
return callback();
})), compiler.hooks.compile.tap("DllReferencePlugin", (params => {
let name = this.options.name, sourceType = this.options.sourceType, content = "content" in this.options ? this.options.content : void 0;
if ("manifest" in this.options) {
let manifest, manifestParameter = this.options.manifest;
if ("string" == typeof manifestParameter) {
const data = this._compilationData.get(params);
if (data.error) return;
manifest = data.data;
} else manifest = manifestParameter;
manifest && (name || (name = manifest.name), sourceType || (sourceType = manifest.type), 
content || (content = manifest.content));
}
const externals = {}, source = "dll-reference " + name;
externals[source] = name;
const normalModuleFactory = params.normalModuleFactory;
new ExternalModuleFactoryPlugin(sourceType || "var", externals).apply(normalModuleFactory), 
new DelegatedModuleFactoryPlugin({
source,
type: this.options.type,
scope: this.options.scope,
context: this.options.context || compiler.options.context,
content,
extensions: this.options.extensions,
associatedObjectForCache: compiler.root
}).apply(normalModuleFactory);
})), compiler.hooks.compilation.tap("DllReferencePlugin", ((compilation, params) => {
if ("manifest" in this.options) {
let manifest = this.options.manifest;
if ("string" == typeof manifest) {
const data = this._compilationData.get(params);
data.error && compilation.errors.push(data.error), compilation.fileDependencies.add(manifest);
}
}
}));
}
};
},
39088: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const EntryOptionPlugin = __webpack_require__(51199), EntryPlugin = __webpack_require__(27683), EntryDependency = __webpack_require__(74989);
module.exports = class {
constructor(context, entry) {
this.context = context, this.entry = entry;
}
apply(compiler) {
compiler.hooks.compilation.tap("DynamicEntryPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(EntryDependency, normalModuleFactory);
})), compiler.hooks.make.tapPromise("DynamicEntryPlugin", ((compilation, callback) => Promise.resolve(this.entry()).then((entry => {
const promises = [];
for (const name of Object.keys(entry)) {
const desc = entry[name], options = EntryOptionPlugin.entryDescriptionToOptions(compiler, name, desc);
for (const entry of desc.import) promises.push(new Promise(((resolve, reject) => {
compilation.addEntry(this.context, EntryPlugin.createDependency(entry, options), options, (err => {
if (err) return reject(err);
resolve();
}));
})));
}
return Promise.all(promises);
})).then((x => {}))));
}
};
},
51199: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
class EntryOptionPlugin {
apply(compiler) {
compiler.hooks.entryOption.tap("EntryOptionPlugin", ((context, entry) => (EntryOptionPlugin.applyEntryOption(compiler, context, entry), 
!0)));
}
static applyEntryOption(compiler, context, entry) {
if ("function" == typeof entry) {
new (__webpack_require__(39088))(context, entry).apply(compiler);
} else {
const EntryPlugin = __webpack_require__(27683);
for (const name of Object.keys(entry)) {
const desc = entry[name], options = EntryOptionPlugin.entryDescriptionToOptions(compiler, name, desc);
for (const entry of desc.import) new EntryPlugin(context, entry, options).apply(compiler);
}
}
}
static entryDescriptionToOptions(compiler, name, desc) {
const options = {
name,
filename: desc.filename,
runtime: desc.runtime,
layer: desc.layer,
dependOn: desc.dependOn,
baseUri: desc.baseUri,
publicPath: desc.publicPath,
chunkLoading: desc.chunkLoading,
asyncChunks: desc.asyncChunks,
wasmLoading: desc.wasmLoading,
library: desc.library
};
if (void 0 !== desc.layer && !compiler.options.experiments.layers) throw new Error("'entryOptions.layer' is only allowed when 'experiments.layers' is enabled");
if (desc.chunkLoading) {
__webpack_require__(64027).checkEnabled(compiler, desc.chunkLoading);
}
if (desc.wasmLoading) {
__webpack_require__(44362).checkEnabled(compiler, desc.wasmLoading);
}
if (desc.library) {
__webpack_require__(30001).checkEnabled(compiler, desc.library.type);
}
return options;
}
}
module.exports = EntryOptionPlugin;
},
27683: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const EntryDependency = __webpack_require__(74989);
class EntryPlugin {
constructor(context, entry, options) {
this.context = context, this.entry = entry, this.options = options || "";
}
apply(compiler) {
compiler.hooks.compilation.tap("EntryPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(EntryDependency, normalModuleFactory);
}));
const {entry, options, context} = this, dep = EntryPlugin.createDependency(entry, options);
compiler.hooks.make.tapAsync("EntryPlugin", ((compilation, callback) => {
compilation.addEntry(context, dep, options, (err => {
callback(err);
}));
}));
}
static createDependency(entry, options) {
const dep = new EntryDependency(entry);
return dep.loc = {
name: "object" == typeof options ? options.name : options
}, dep;
}
}
module.exports = EntryPlugin;
},
7807: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ChunkGroup = __webpack_require__(12956);
class Entrypoint extends ChunkGroup {
constructor(entryOptions, initial = !0) {
"string" == typeof entryOptions && (entryOptions = {
name: entryOptions
}), super({
name: entryOptions.name
}), this.options = entryOptions, this._runtimeChunk = void 0, this._entrypointChunk = void 0, 
this._initial = initial;
}
isInitial() {
return this._initial;
}
setRuntimeChunk(chunk) {
this._runtimeChunk = chunk;
}
getRuntimeChunk() {
if (this._runtimeChunk) return this._runtimeChunk;
for (const parent of this.parentsIterable) if (parent instanceof Entrypoint) return parent.getRuntimeChunk();
return null;
}
setEntrypointChunk(chunk) {
this._entrypointChunk = chunk;
}
getEntrypointChunk() {
return this._entrypointChunk;
}
replaceChunk(oldChunk, newChunk) {
return this._runtimeChunk === oldChunk && (this._runtimeChunk = newChunk), this._entrypointChunk === oldChunk && (this._entrypointChunk = newChunk), 
super.replaceChunk(oldChunk, newChunk);
}
}
module.exports = Entrypoint;
},
66987: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DefinePlugin = __webpack_require__(98665), WebpackError = __webpack_require__(64326);
module.exports = class {
constructor(...keys) {
1 === keys.length && Array.isArray(keys[0]) ? (this.keys = keys[0], this.defaultValues = {}) : 1 === keys.length && keys[0] && "object" == typeof keys[0] ? (this.keys = Object.keys(keys[0]), 
this.defaultValues = keys[0]) : (this.keys = keys, this.defaultValues = {});
}
apply(compiler) {
const definitions = {};
for (const key of this.keys) {
const value = void 0 !== process.env[key] ? process.env[key] : this.defaultValues[key];
void 0 === value && compiler.hooks.thisCompilation.tap("EnvironmentPlugin", (compilation => {
const error = new WebpackError(`EnvironmentPlugin - ${key} environment variable is undefined.\n\nYou can pass an object with default values to suppress this warning.\nSee https://webpack.js.org/plugins/environment-plugin for example.`);
error.name = "EnvVariableNotDefinedError", compilation.errors.push(error);
})), definitions[`process.env.${key}`] = void 0 === value ? "undefined" : JSON.stringify(value);
}
new DefinePlugin(definitions).apply(compiler);
}
};
},
23516: (__unused_webpack_module, exports) => {
"use strict";
exports.cutOffByFlag = (stack, flag) => {
stack = stack.split("\n");
for (let i = 0; i < stack.length; i++) stack[i].includes(flag) && (stack.length = i);
return stack.join("\n");
}, exports.cutOffLoaderExecution = stack => exports.cutOffByFlag(stack, "LOADER_EXECUTION"), 
exports.cutOffWebpackOptions = stack => exports.cutOffByFlag(stack, "WEBPACK_OPTIONS"), 
exports.cutOffMultilineMessage = (stack, message) => {
stack = stack.split("\n"), message = message.split("\n");
const result = [];
return stack.forEach(((line, idx) => {
line.includes(message[idx]) || result.push(line);
})), result.join("\n");
}, exports.cutOffMessage = (stack, message) => {
const nextLine = stack.indexOf("\n");
if (-1 === nextLine) return stack === message ? "" : stack;
return stack.slice(0, nextLine) === message ? stack.slice(nextLine + 1) : stack;
}, exports.cleanUp = (stack, message) => (stack = exports.cutOffLoaderExecution(stack), 
stack = exports.cutOffMessage(stack, message)), exports.cleanUpWebpackOptions = (stack, message) => (stack = exports.cutOffWebpackOptions(stack), 
stack = exports.cutOffMultilineMessage(stack, message));
},
47499: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, RawSource} = __webpack_require__(37946), ExternalModule = __webpack_require__(97056), ModuleFilenameHelpers = __webpack_require__(23833), RuntimeGlobals = __webpack_require__(50980), JavascriptModulesPlugin = __webpack_require__(18362), cache = new WeakMap, devtoolWarning = new RawSource('/*\n * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").\n * This devtool is neither made for production nor for readable output files.\n * It uses "eval()" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with "devtool: false".\n * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).\n */\n');
module.exports = class {
constructor(options) {
this.namespace = options.namespace || "", this.sourceUrlComment = options.sourceUrlComment || "\n//# sourceURL=[url]", 
this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]?[loaders]";
}
apply(compiler) {
compiler.hooks.compilation.tap("EvalDevToolModulePlugin", (compilation => {
const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
hooks.renderModuleContent.tap("EvalDevToolModulePlugin", ((source, module, {runtimeTemplate, chunkGraph}) => {
const cacheEntry = cache.get(source);
if (void 0 !== cacheEntry) return cacheEntry;
if (module instanceof ExternalModule) return cache.set(source, source), source;
const content = source.source(), str = ModuleFilenameHelpers.createFilename(module, {
moduleFilenameTemplate: this.moduleFilenameTemplate,
namespace: this.namespace
}, {
requestShortener: runtimeTemplate.requestShortener,
chunkGraph,
hashFunction: compilation.outputOptions.hashFunction
}), footer = "\n" + this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, "")), result = new RawSource(`eval(${compilation.outputOptions.trustedTypes ? `${RuntimeGlobals.createScript}(${JSON.stringify(content + footer)})` : JSON.stringify(content + footer)});`);
return cache.set(source, result), result;
})), hooks.inlineInRuntimeBailout.tap("EvalDevToolModulePlugin", (() => "the eval devtool is used.")), 
hooks.render.tap("EvalDevToolModulePlugin", (source => new ConcatSource(devtoolWarning, source))), 
hooks.chunkHash.tap("EvalDevToolModulePlugin", ((chunk, hash) => {
hash.update("EvalDevToolModulePlugin"), hash.update("2");
})), compilation.outputOptions.trustedTypes && compilation.hooks.additionalModuleRuntimeRequirements.tap("EvalDevToolModulePlugin", ((module, set, context) => {
set.add(RuntimeGlobals.createScript);
}));
}));
}
};
},
49695: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, RawSource} = __webpack_require__(37946), ModuleFilenameHelpers = __webpack_require__(23833), NormalModule = __webpack_require__(3213), RuntimeGlobals = __webpack_require__(50980), SourceMapDevToolModuleOptionsPlugin = __webpack_require__(89712), JavascriptModulesPlugin = __webpack_require__(18362), ConcatenatedModule = __webpack_require__(36005), {makePathsAbsolute} = __webpack_require__(63264), cache = new WeakMap, devtoolWarning = new RawSource('/*\n * ATTENTION: An "eval-source-map" devtool has been used.\n * This devtool is neither made for production nor for readable output files.\n * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with "devtool: false".\n * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).\n */\n');
module.exports = class {
constructor(inputOptions) {
let options;
options = "string" == typeof inputOptions ? {
append: inputOptions
} : inputOptions, this.sourceMapComment = options.append || "//# sourceURL=[module]\n//# sourceMappingURL=[url]", 
this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resource-path]?[hash]", 
this.namespace = options.namespace || "", this.options = options;
}
apply(compiler) {
const options = this.options;
compiler.hooks.compilation.tap("EvalSourceMapDevToolPlugin", (compilation => {
const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
const matchModule = ModuleFilenameHelpers.matchObject.bind(ModuleFilenameHelpers, options);
hooks.renderModuleContent.tap("EvalSourceMapDevToolPlugin", ((source, m, {runtimeTemplate, chunkGraph}) => {
const cachedSource = cache.get(source);
if (void 0 !== cachedSource) return cachedSource;
const result = r => (cache.set(source, r), r);
if (m instanceof NormalModule) {
if (!matchModule(m.resource)) return result(source);
} else {
if (!(m instanceof ConcatenatedModule)) return result(source);
{
const concatModule = m;
if (!(concatModule.rootModule instanceof NormalModule)) return result(source);
{
const module = concatModule.rootModule;
if (!matchModule(module.resource)) return result(source);
}
}
}
let sourceMap, content;
if (source.sourceAndMap) {
const sourceAndMap = source.sourceAndMap(options);
sourceMap = sourceAndMap.map, content = sourceAndMap.source;
} else sourceMap = source.map(options), content = source.source();
if (!sourceMap) return result(source);
sourceMap = {
...sourceMap
};
const context = compiler.options.context, root = compiler.root, modules = sourceMap.sources.map((source => {
if (!source.startsWith("webpack://")) return source;
source = makePathsAbsolute(context, source.slice(10), root);
return compilation.findModule(source) || source;
}));
let moduleFilenames = modules.map((module => ModuleFilenameHelpers.createFilename(module, {
moduleFilenameTemplate: this.moduleFilenameTemplate,
namespace: this.namespace
}, {
requestShortener: runtimeTemplate.requestShortener,
chunkGraph,
hashFunction: compilation.outputOptions.hashFunction
})));
moduleFilenames = ModuleFilenameHelpers.replaceDuplicates(moduleFilenames, ((filename, i, n) => {
for (let j = 0; j < n; j++) filename += "*";
return filename;
})), sourceMap.sources = moduleFilenames, sourceMap.sourceRoot = options.sourceRoot || "";
const moduleId = chunkGraph.getModuleId(m);
sourceMap.file = `${moduleId}.js`;
const footer = this.sourceMapComment.replace(/\[url\]/g, `data:application/json;charset=utf-8;base64,${Buffer.from(JSON.stringify(sourceMap), "utf8").toString("base64")}`) + `\n//# sourceURL=webpack-internal:///${moduleId}\n`;
return result(new RawSource(`eval(${compilation.outputOptions.trustedTypes ? `${RuntimeGlobals.createScript}(${JSON.stringify(content + footer)})` : JSON.stringify(content + footer)});`));
})), hooks.inlineInRuntimeBailout.tap("EvalDevToolModulePlugin", (() => "the eval-source-map devtool is used.")), 
hooks.render.tap("EvalSourceMapDevToolPlugin", (source => new ConcatSource(devtoolWarning, source))), 
hooks.chunkHash.tap("EvalSourceMapDevToolPlugin", ((chunk, hash) => {
hash.update("EvalSourceMapDevToolPlugin"), hash.update("2");
})), compilation.outputOptions.trustedTypes && compilation.hooks.additionalModuleRuntimeRequirements.tap("EvalSourceMapDevToolPlugin", ((module, set, context) => {
set.add(RuntimeGlobals.createScript);
}));
}));
}
};
},
74603: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {equals} = __webpack_require__(8579), SortableSet = __webpack_require__(72451), makeSerializable = __webpack_require__(45898), {forEachRuntime} = __webpack_require__(14372), UsageState = Object.freeze({
Unused: 0,
OnlyPropertiesUsed: 1,
NoInfo: 2,
Unknown: 3,
Used: 4
}), RETURNS_TRUE = () => !0, CIRCULAR = Symbol("circular target");
class RestoreProvidedData {
constructor(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding) {
this.exports = exports, this.otherProvided = otherProvided, this.otherCanMangleProvide = otherCanMangleProvide, 
this.otherTerminalBinding = otherTerminalBinding;
}
serialize({write}) {
write(this.exports), write(this.otherProvided), write(this.otherCanMangleProvide), 
write(this.otherTerminalBinding);
}
static deserialize({read}) {
return new RestoreProvidedData(read(), read(), read(), read());
}
}
makeSerializable(RestoreProvidedData, "webpack/lib/ModuleGraph", "RestoreProvidedData");
class ExportsInfo {
constructor() {
this._exports = new Map, this._otherExportsInfo = new ExportInfo(null), this._sideEffectsOnlyInfo = new ExportInfo("*side effects only*"), 
this._exportsAreOrdered = !1, this._redirectTo = void 0;
}
get ownedExports() {
return this._exports.values();
}
get orderedOwnedExports() {
return this._exportsAreOrdered || this._sortExports(), this._exports.values();
}
get exports() {
if (void 0 !== this._redirectTo) {
const map = new Map(this._redirectTo._exports);
for (const [key, value] of this._exports) map.set(key, value);
return map.values();
}
return this._exports.values();
}
get orderedExports() {
if (this._exportsAreOrdered || this._sortExports(), void 0 !== this._redirectTo) {
const map = new Map(Array.from(this._redirectTo.orderedExports, (item => [ item.name, item ])));
for (const [key, value] of this._exports) map.set(key, value);
return this._sortExportsMap(map), map.values();
}
return this._exports.values();
}
get otherExportsInfo() {
return void 0 !== this._redirectTo ? this._redirectTo.otherExportsInfo : this._otherExportsInfo;
}
_sortExportsMap(exports) {
if (exports.size > 1) {
const namesInOrder = [];
for (const entry of exports.values()) namesInOrder.push(entry.name);
namesInOrder.sort();
let i = 0;
for (const entry of exports.values()) {
const name = namesInOrder[i];
if (entry.name !== name) break;
i++;
}
for (;i < namesInOrder.length; i++) {
const name = namesInOrder[i], correctEntry = exports.get(name);
exports.delete(name), exports.set(name, correctEntry);
}
}
}
_sortExports() {
this._sortExportsMap(this._exports), this._exportsAreOrdered = !0;
}
setRedirectNamedTo(exportsInfo) {
return this._redirectTo !== exportsInfo && (this._redirectTo = exportsInfo, !0);
}
setHasProvideInfo() {
for (const exportInfo of this._exports.values()) void 0 === exportInfo.provided && (exportInfo.provided = !1), 
void 0 === exportInfo.canMangleProvide && (exportInfo.canMangleProvide = !0);
void 0 !== this._redirectTo ? this._redirectTo.setHasProvideInfo() : (void 0 === this._otherExportsInfo.provided && (this._otherExportsInfo.provided = !1), 
void 0 === this._otherExportsInfo.canMangleProvide && (this._otherExportsInfo.canMangleProvide = !0));
}
setHasUseInfo() {
for (const exportInfo of this._exports.values()) exportInfo.setHasUseInfo();
this._sideEffectsOnlyInfo.setHasUseInfo(), void 0 !== this._redirectTo ? this._redirectTo.setHasUseInfo() : (this._otherExportsInfo.setHasUseInfo(), 
void 0 === this._otherExportsInfo.canMangleUse && (this._otherExportsInfo.canMangleUse = !0));
}
getOwnExportInfo(name) {
const info = this._exports.get(name);
if (void 0 !== info) return info;
const newInfo = new ExportInfo(name, this._otherExportsInfo);
return this._exports.set(name, newInfo), this._exportsAreOrdered = !1, newInfo;
}
getExportInfo(name) {
const info = this._exports.get(name);
if (void 0 !== info) return info;
if (void 0 !== this._redirectTo) return this._redirectTo.getExportInfo(name);
const newInfo = new ExportInfo(name, this._otherExportsInfo);
return this._exports.set(name, newInfo), this._exportsAreOrdered = !1, newInfo;
}
getReadOnlyExportInfo(name) {
const info = this._exports.get(name);
return void 0 !== info ? info : void 0 !== this._redirectTo ? this._redirectTo.getReadOnlyExportInfo(name) : this._otherExportsInfo;
}
getReadOnlyExportInfoRecursive(name) {
const exportInfo = this.getReadOnlyExportInfo(name[0]);
return 1 === name.length ? exportInfo : exportInfo.exportsInfo ? exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1)) : void 0;
}
getNestedExportsInfo(name) {
if (Array.isArray(name) && name.length > 0) {
const info = this.getReadOnlyExportInfo(name[0]);
if (!info.exportsInfo) return;
return info.exportsInfo.getNestedExportsInfo(name.slice(1));
}
return this;
}
setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority) {
let changed = !1;
if (excludeExports) for (const name of excludeExports) this.getExportInfo(name);
for (const exportInfo of this._exports.values()) canMangle || !1 === exportInfo.canMangleProvide || (exportInfo.canMangleProvide = !1, 
changed = !0), excludeExports && excludeExports.has(exportInfo.name) || (!0 !== exportInfo.provided && null !== exportInfo.provided && (exportInfo.provided = null, 
changed = !0), targetKey && exportInfo.setTarget(targetKey, targetModule, [ exportInfo.name ], -1));
return void 0 !== this._redirectTo ? this._redirectTo.setUnknownExportsProvided(canMangle, excludeExports, targetKey, targetModule, priority) && (changed = !0) : (!0 !== this._otherExportsInfo.provided && null !== this._otherExportsInfo.provided && (this._otherExportsInfo.provided = null, 
changed = !0), canMangle || !1 === this._otherExportsInfo.canMangleProvide || (this._otherExportsInfo.canMangleProvide = !1, 
changed = !0), targetKey && this._otherExportsInfo.setTarget(targetKey, targetModule, void 0, priority)), 
changed;
}
setUsedInUnknownWay(runtime) {
let changed = !1;
for (const exportInfo of this._exports.values()) exportInfo.setUsedInUnknownWay(runtime) && (changed = !0);
return void 0 !== this._redirectTo ? this._redirectTo.setUsedInUnknownWay(runtime) && (changed = !0) : (this._otherExportsInfo.setUsedConditionally((used => used < UsageState.Unknown), UsageState.Unknown, runtime) && (changed = !0), 
!1 !== this._otherExportsInfo.canMangleUse && (this._otherExportsInfo.canMangleUse = !1, 
changed = !0)), changed;
}
setUsedWithoutInfo(runtime) {
let changed = !1;
for (const exportInfo of this._exports.values()) exportInfo.setUsedWithoutInfo(runtime) && (changed = !0);
return void 0 !== this._redirectTo ? this._redirectTo.setUsedWithoutInfo(runtime) && (changed = !0) : (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime) && (changed = !0), 
!1 !== this._otherExportsInfo.canMangleUse && (this._otherExportsInfo.canMangleUse = !1, 
changed = !0)), changed;
}
setAllKnownExportsUsed(runtime) {
let changed = !1;
for (const exportInfo of this._exports.values()) exportInfo.provided && exportInfo.setUsed(UsageState.Used, runtime) && (changed = !0);
return changed;
}
setUsedForSideEffectsOnly(runtime) {
return this._sideEffectsOnlyInfo.setUsedConditionally((used => used === UsageState.Unused), UsageState.Used, runtime);
}
isUsed(runtime) {
if (void 0 !== this._redirectTo) {
if (this._redirectTo.isUsed(runtime)) return !0;
} else if (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) return !0;
for (const exportInfo of this._exports.values()) if (exportInfo.getUsed(runtime) !== UsageState.Unused) return !0;
return !1;
}
isModuleUsed(runtime) {
return !!this.isUsed(runtime) || this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused;
}
getUsedExports(runtime) {
if (void 0 !== !this._redirectTo) switch (this._otherExportsInfo.getUsed(runtime)) {
case UsageState.NoInfo:
return null;

case UsageState.Unknown:
case UsageState.OnlyPropertiesUsed:
case UsageState.Used:
return !0;
}
const array = [];
this._exportsAreOrdered || this._sortExports();
for (const exportInfo of this._exports.values()) switch (exportInfo.getUsed(runtime)) {
case UsageState.NoInfo:
return null;

case UsageState.Unknown:
return !0;

case UsageState.OnlyPropertiesUsed:
case UsageState.Used:
array.push(exportInfo.name);
}
if (void 0 !== this._redirectTo) {
const inner = this._redirectTo.getUsedExports(runtime);
if (null === inner) return null;
if (!0 === inner) return !0;
if (!1 !== inner) for (const item of inner) array.push(item);
}
if (0 === array.length) switch (this._sideEffectsOnlyInfo.getUsed(runtime)) {
case UsageState.NoInfo:
return null;

case UsageState.Unused:
return !1;
}
return new SortableSet(array);
}
getProvidedExports() {
if (void 0 !== !this._redirectTo) switch (this._otherExportsInfo.provided) {
case void 0:
return null;

case null:
case !0:
return !0;
}
const array = [];
this._exportsAreOrdered || this._sortExports();
for (const exportInfo of this._exports.values()) switch (exportInfo.provided) {
case void 0:
return null;

case null:
return !0;

case !0:
array.push(exportInfo.name);
}
if (void 0 !== this._redirectTo) {
const inner = this._redirectTo.getProvidedExports();
if (null === inner) return null;
if (!0 === inner) return !0;
for (const item of inner) array.includes(item) || array.push(item);
}
return array;
}
getRelevantExports(runtime) {
const list = [];
for (const exportInfo of this._exports.values()) {
exportInfo.getUsed(runtime) !== UsageState.Unused && (!1 !== exportInfo.provided && list.push(exportInfo));
}
if (void 0 !== this._redirectTo) for (const exportInfo of this._redirectTo.getRelevantExports(runtime)) this._exports.has(exportInfo.name) || list.push(exportInfo);
return !1 !== this._otherExportsInfo.provided && this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused && list.push(this._otherExportsInfo), 
list;
}
isExportProvided(name) {
if (Array.isArray(name)) {
const info = this.getReadOnlyExportInfo(name[0]);
return info.exportsInfo && name.length > 1 ? info.exportsInfo.isExportProvided(name.slice(1)) : info.provided ? 1 === name.length || void 0 : info.provided;
}
return this.getReadOnlyExportInfo(name).provided;
}
getUsageKey(runtime) {
const key = [];
void 0 !== this._redirectTo ? key.push(this._redirectTo.getUsageKey(runtime)) : key.push(this._otherExportsInfo.getUsed(runtime)), 
key.push(this._sideEffectsOnlyInfo.getUsed(runtime));
for (const exportInfo of this.orderedOwnedExports) key.push(exportInfo.getUsed(runtime));
return key.join("|");
}
isEquallyUsed(runtimeA, runtimeB) {
if (void 0 !== this._redirectTo) {
if (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return !1;
} else if (this._otherExportsInfo.getUsed(runtimeA) !== this._otherExportsInfo.getUsed(runtimeB)) return !1;
if (this._sideEffectsOnlyInfo.getUsed(runtimeA) !== this._sideEffectsOnlyInfo.getUsed(runtimeB)) return !1;
for (const exportInfo of this.ownedExports) if (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB)) return !1;
return !0;
}
getUsed(name, runtime) {
if (Array.isArray(name)) {
if (0 === name.length) return this.otherExportsInfo.getUsed(runtime);
let info = this.getReadOnlyExportInfo(name[0]);
return info.exportsInfo && name.length > 1 ? info.exportsInfo.getUsed(name.slice(1), runtime) : info.getUsed(runtime);
}
return this.getReadOnlyExportInfo(name).getUsed(runtime);
}
getUsedName(name, runtime) {
if (Array.isArray(name)) {
if (0 === name.length) return !!this.isUsed(runtime) && name;
let info = this.getReadOnlyExportInfo(name[0]);
const x = info.getUsedName(name[0], runtime);
if (!1 === x) return !1;
const arr = x === name[0] && 1 === name.length ? name : [ x ];
if (1 === name.length) return arr;
if (info.exportsInfo && info.getUsed(runtime) === UsageState.OnlyPropertiesUsed) {
const nested = info.exportsInfo.getUsedName(name.slice(1), runtime);
return !!nested && arr.concat(nested);
}
return arr.concat(name.slice(1));
}
return this.getReadOnlyExportInfo(name).getUsedName(name, runtime);
}
updateHash(hash, runtime) {
this._updateHash(hash, runtime, new Set);
}
_updateHash(hash, runtime, alreadyVisitedExportsInfo) {
const set = new Set(alreadyVisitedExportsInfo);
set.add(this);
for (const exportInfo of this.orderedExports) exportInfo.hasInfo(this._otherExportsInfo, runtime) && exportInfo._updateHash(hash, runtime, set);
this._sideEffectsOnlyInfo._updateHash(hash, runtime, set), this._otherExportsInfo._updateHash(hash, runtime, set), 
void 0 !== this._redirectTo && this._redirectTo._updateHash(hash, runtime, set);
}
getRestoreProvidedData() {
const otherProvided = this._otherExportsInfo.provided, otherCanMangleProvide = this._otherExportsInfo.canMangleProvide, otherTerminalBinding = this._otherExportsInfo.terminalBinding, exports = [];
for (const exportInfo of this.orderedExports) (exportInfo.provided !== otherProvided || exportInfo.canMangleProvide !== otherCanMangleProvide || exportInfo.terminalBinding !== otherTerminalBinding || exportInfo.exportsInfoOwned) && exports.push({
name: exportInfo.name,
provided: exportInfo.provided,
canMangleProvide: exportInfo.canMangleProvide,
terminalBinding: exportInfo.terminalBinding,
exportsInfo: exportInfo.exportsInfoOwned ? exportInfo.exportsInfo.getRestoreProvidedData() : void 0
});
return new RestoreProvidedData(exports, otherProvided, otherCanMangleProvide, otherTerminalBinding);
}
restoreProvided({otherProvided, otherCanMangleProvide, otherTerminalBinding, exports}) {
let wasEmpty = !0;
for (const exportInfo of this._exports.values()) wasEmpty = !1, exportInfo.provided = otherProvided, 
exportInfo.canMangleProvide = otherCanMangleProvide, exportInfo.terminalBinding = otherTerminalBinding;
this._otherExportsInfo.provided = otherProvided, this._otherExportsInfo.canMangleProvide = otherCanMangleProvide, 
this._otherExportsInfo.terminalBinding = otherTerminalBinding;
for (const exp of exports) {
const exportInfo = this.getExportInfo(exp.name);
if (exportInfo.provided = exp.provided, exportInfo.canMangleProvide = exp.canMangleProvide, 
exportInfo.terminalBinding = exp.terminalBinding, exp.exportsInfo) {
exportInfo.createNestedExportsInfo().restoreProvided(exp.exportsInfo);
}
}
wasEmpty && (this._exportsAreOrdered = !0);
}
}
class ExportInfo {
constructor(name, initFrom) {
if (this.name = name, this._usedName = initFrom ? initFrom._usedName : null, this._globalUsed = initFrom ? initFrom._globalUsed : void 0, 
this._usedInRuntime = initFrom && initFrom._usedInRuntime ? new Map(initFrom._usedInRuntime) : void 0, 
this._hasUseInRuntimeInfo = !!initFrom && initFrom._hasUseInRuntimeInfo, this.provided = initFrom ? initFrom.provided : void 0, 
this.terminalBinding = !!initFrom && initFrom.terminalBinding, this.canMangleProvide = initFrom ? initFrom.canMangleProvide : void 0, 
this.canMangleUse = initFrom ? initFrom.canMangleUse : void 0, this.exportsInfoOwned = !1, 
this.exportsInfo = void 0, this._target = void 0, initFrom && initFrom._target) {
this._target = new Map;
for (const [key, value] of initFrom._target) this._target.set(key, {
connection: value.connection,
export: value.export || [ name ],
priority: value.priority
});
}
this._maxTarget = void 0;
}
get used() {
throw new Error("REMOVED");
}
get usedName() {
throw new Error("REMOVED");
}
set used(v) {
throw new Error("REMOVED");
}
set usedName(v) {
throw new Error("REMOVED");
}
get canMangle() {
switch (this.canMangleProvide) {
case void 0:
return !1 !== this.canMangleUse && void 0;

case !1:
return !1;

case !0:
switch (this.canMangleUse) {
case void 0:
return;

case !1:
return !1;

case !0:
return !0;
}
}
throw new Error(`Unexpected flags for canMangle ${this.canMangleProvide} ${this.canMangleUse}`);
}
setUsedInUnknownWay(runtime) {
let changed = !1;
return this.setUsedConditionally((used => used < UsageState.Unknown), UsageState.Unknown, runtime) && (changed = !0), 
!1 !== this.canMangleUse && (this.canMangleUse = !1, changed = !0), changed;
}
setUsedWithoutInfo(runtime) {
let changed = !1;
return this.setUsed(UsageState.NoInfo, runtime) && (changed = !0), !1 !== this.canMangleUse && (this.canMangleUse = !1, 
changed = !0), changed;
}
setHasUseInfo() {
this._hasUseInRuntimeInfo || (this._hasUseInRuntimeInfo = !0), void 0 === this.canMangleUse && (this.canMangleUse = !0), 
this.exportsInfoOwned && this.exportsInfo.setHasUseInfo();
}
setUsedConditionally(condition, newValue, runtime) {
if (void 0 === runtime) {
if (void 0 === this._globalUsed) return this._globalUsed = newValue, !0;
if (this._globalUsed !== newValue && condition(this._globalUsed)) return this._globalUsed = newValue, 
!0;
} else if (void 0 === this._usedInRuntime) {
if (newValue !== UsageState.Unused && condition(UsageState.Unused)) return this._usedInRuntime = new Map, 
forEachRuntime(runtime, (runtime => this._usedInRuntime.set(runtime, newValue))), 
!0;
} else {
let changed = !1;
if (forEachRuntime(runtime, (runtime => {
let oldValue = this._usedInRuntime.get(runtime);
void 0 === oldValue && (oldValue = UsageState.Unused), newValue !== oldValue && condition(oldValue) && (newValue === UsageState.Unused ? this._usedInRuntime.delete(runtime) : this._usedInRuntime.set(runtime, newValue), 
changed = !0);
})), changed) return 0 === this._usedInRuntime.size && (this._usedInRuntime = void 0), 
!0;
}
return !1;
}
setUsed(newValue, runtime) {
if (void 0 === runtime) {
if (this._globalUsed !== newValue) return this._globalUsed = newValue, !0;
} else if (void 0 === this._usedInRuntime) {
if (newValue !== UsageState.Unused) return this._usedInRuntime = new Map, forEachRuntime(runtime, (runtime => this._usedInRuntime.set(runtime, newValue))), 
!0;
} else {
let changed = !1;
if (forEachRuntime(runtime, (runtime => {
let oldValue = this._usedInRuntime.get(runtime);
void 0 === oldValue && (oldValue = UsageState.Unused), newValue !== oldValue && (newValue === UsageState.Unused ? this._usedInRuntime.delete(runtime) : this._usedInRuntime.set(runtime, newValue), 
changed = !0);
})), changed) return 0 === this._usedInRuntime.size && (this._usedInRuntime = void 0), 
!0;
}
return !1;
}
unsetTarget(key) {
return !!this._target && (!!this._target.delete(key) && (this._maxTarget = void 0, 
!0));
}
setTarget(key, connection, exportName, priority = 0) {
if (exportName && (exportName = [ ...exportName ]), !this._target) return this._target = new Map, 
this._target.set(key, {
connection,
export: exportName,
priority
}), !0;
const oldTarget = this._target.get(key);
return oldTarget ? (oldTarget.connection !== connection || oldTarget.priority !== priority || !(exportName ? oldTarget.export && equals(oldTarget.export, exportName) : !oldTarget.export)) && (oldTarget.connection = connection, 
oldTarget.export = exportName, oldTarget.priority = priority, this._maxTarget = void 0, 
!0) : !(null === oldTarget && !connection) && (this._target.set(key, {
connection,
export: exportName,
priority
}), this._maxTarget = void 0, !0);
}
getUsed(runtime) {
if (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;
if (void 0 !== this._globalUsed) return this._globalUsed;
if (void 0 === this._usedInRuntime) return UsageState.Unused;
if ("string" == typeof runtime) {
const value = this._usedInRuntime.get(runtime);
return void 0 === value ? UsageState.Unused : value;
}
if (void 0 === runtime) {
let max = UsageState.Unused;
for (const value of this._usedInRuntime.values()) {
if (value === UsageState.Used) return UsageState.Used;
max < value && (max = value);
}
return max;
}
{
let max = UsageState.Unused;
for (const item of runtime) {
const value = this._usedInRuntime.get(item);
if (void 0 !== value) {
if (value === UsageState.Used) return UsageState.Used;
max < value && (max = value);
}
}
return max;
}
}
getUsedName(fallbackName, runtime) {
if (this._hasUseInRuntimeInfo) if (void 0 !== this._globalUsed) {
if (this._globalUsed === UsageState.Unused) return !1;
} else {
if (void 0 === this._usedInRuntime) return !1;
if ("string" == typeof runtime) {
if (!this._usedInRuntime.has(runtime)) return !1;
} else if (void 0 !== runtime && Array.from(runtime).every((runtime => !this._usedInRuntime.has(runtime)))) return !1;
}
return null !== this._usedName ? this._usedName : this.name || fallbackName;
}
hasUsedName() {
return null !== this._usedName;
}
setUsedName(name) {
this._usedName = name;
}
getTerminalBinding(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {
if (this.terminalBinding) return this;
const target = this.getTarget(moduleGraph, resolveTargetFilter);
if (!target) return;
const exportsInfo = moduleGraph.getExportsInfo(target.module);
return target.export ? exportsInfo.getReadOnlyExportInfoRecursive(target.export) : exportsInfo;
}
isReexport() {
return !this.terminalBinding && this._target && this._target.size > 0;
}
_getMaxTarget() {
if (void 0 !== this._maxTarget) return this._maxTarget;
if (this._target.size <= 1) return this._maxTarget = this._target;
let maxPriority = -1 / 0, minPriority = 1 / 0;
for (const {priority} of this._target.values()) maxPriority < priority && (maxPriority = priority), 
minPriority > priority && (minPriority = priority);
if (maxPriority === minPriority) return this._maxTarget = this._target;
const map = new Map;
for (const [key, value] of this._target) maxPriority === value.priority && map.set(key, value);
return this._maxTarget = map, map;
}
findTarget(moduleGraph, validTargetModuleFilter) {
return this._findTarget(moduleGraph, validTargetModuleFilter, new Set);
}
_findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {
if (!this._target || 0 === this._target.size) return;
let rawTarget = this._getMaxTarget().values().next().value;
if (!rawTarget) return;
let target = {
module: rawTarget.connection.module,
export: rawTarget.export
};
for (;;) {
if (validTargetModuleFilter(target.module)) return target;
const exportInfo = moduleGraph.getExportsInfo(target.module).getExportInfo(target.export[0]);
if (alreadyVisited.has(exportInfo)) return null;
const newTarget = exportInfo._findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited);
if (!newTarget) return !1;
target = 1 === target.export.length ? newTarget : {
module: newTarget.module,
export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)
};
}
}
getTarget(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {
const result = this._getTarget(moduleGraph, resolveTargetFilter, void 0);
if (result !== CIRCULAR) return result;
}
_getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {
const resolveTarget = (inputTarget, alreadyVisited) => {
if (!inputTarget) return null;
if (!inputTarget.export) return {
module: inputTarget.connection.module,
connection: inputTarget.connection,
export: void 0
};
let target = {
module: inputTarget.connection.module,
connection: inputTarget.connection,
export: inputTarget.export
};
if (!resolveTargetFilter(target)) return target;
let alreadyVisitedOwned = !1;
for (;;) {
const exportInfo = moduleGraph.getExportsInfo(target.module).getExportInfo(target.export[0]);
if (!exportInfo) return target;
if (alreadyVisited.has(exportInfo)) return CIRCULAR;
const newTarget = exportInfo._getTarget(moduleGraph, resolveTargetFilter, alreadyVisited);
if (newTarget === CIRCULAR) return CIRCULAR;
if (!newTarget) return target;
if (1 === target.export.length) {
if (target = newTarget, !target.export) return target;
} else target = {
module: newTarget.module,
connection: newTarget.connection,
export: newTarget.export ? newTarget.export.concat(target.export.slice(1)) : target.export.slice(1)
};
if (!resolveTargetFilter(target)) return target;
alreadyVisitedOwned || (alreadyVisited = new Set(alreadyVisited), alreadyVisitedOwned = !0), 
alreadyVisited.add(exportInfo);
}
};
if (!this._target || 0 === this._target.size) return;
if (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;
const newAlreadyVisited = new Set(alreadyVisited);
newAlreadyVisited.add(this);
const values = this._getMaxTarget().values(), target = resolveTarget(values.next().value, newAlreadyVisited);
if (target === CIRCULAR) return CIRCULAR;
if (null === target) return;
let result = values.next();
for (;!result.done; ) {
const t = resolveTarget(result.value, newAlreadyVisited);
if (t === CIRCULAR) return CIRCULAR;
if (null === t) return;
if (t.module !== target.module) return;
if (!t.export != !target.export) return;
if (target.export && !equals(t.export, target.export)) return;
result = values.next();
}
return target;
}
moveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {
const target = this._getTarget(moduleGraph, resolveTargetFilter, void 0);
if (target === CIRCULAR) return;
if (!target) return;
const originalTarget = this._getMaxTarget().values().next().value;
return originalTarget.connection !== target.connection || originalTarget.export !== target.export ? (this._target.clear(), 
this._target.set(void 0, {
connection: updateOriginalConnection ? updateOriginalConnection(target) : target.connection,
export: target.export,
priority: 0
}), target) : void 0;
}
createNestedExportsInfo() {
if (this.exportsInfoOwned) return this.exportsInfo;
this.exportsInfoOwned = !0;
const oldExportsInfo = this.exportsInfo;
return this.exportsInfo = new ExportsInfo, this.exportsInfo.setHasProvideInfo(), 
oldExportsInfo && this.exportsInfo.setRedirectNamedTo(oldExportsInfo), this.exportsInfo;
}
getNestedExportsInfo() {
return this.exportsInfo;
}
hasInfo(baseInfo, runtime) {
return this._usedName && this._usedName !== this.name || this.provided || this.terminalBinding || this.getUsed(runtime) !== baseInfo.getUsed(runtime);
}
updateHash(hash, runtime) {
this._updateHash(hash, runtime, new Set);
}
_updateHash(hash, runtime, alreadyVisitedExportsInfo) {
hash.update(`${this._usedName || this.name}${this.getUsed(runtime)}${this.provided}${this.terminalBinding}`), 
this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo) && this.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);
}
getUsedInfo() {
if (void 0 !== this._globalUsed) switch (this._globalUsed) {
case UsageState.Unused:
return "unused";

case UsageState.NoInfo:
return "no usage info";

case UsageState.Unknown:
return "maybe used (runtime-defined)";

case UsageState.Used:
return "used";

case UsageState.OnlyPropertiesUsed:
return "only properties used";
} else if (void 0 !== this._usedInRuntime) {
const map = new Map;
for (const [runtime, used] of this._usedInRuntime) {
const list = map.get(used);
void 0 !== list ? list.push(runtime) : map.set(used, [ runtime ]);
}
const specificInfo = Array.from(map, (([used, runtimes]) => {
switch (used) {
case UsageState.NoInfo:
return `no usage info in ${runtimes.join(", ")}`;

case UsageState.Unknown:
return `maybe used in ${runtimes.join(", ")} (runtime-defined)`;

case UsageState.Used:
return `used in ${runtimes.join(", ")}`;

case UsageState.OnlyPropertiesUsed:
return `only properties used in ${runtimes.join(", ")}`;
}
}));
if (specificInfo.length > 0) return specificInfo.join("; ");
}
return this._hasUseInRuntimeInfo ? "unused" : "no usage info";
}
getProvidedInfo() {
switch (this.provided) {
case void 0:
return "no provided info";

case null:
return "maybe provided (runtime-defined)";

case !0:
return "provided";

case !1:
return "not provided";
}
}
getRenameInfo() {
if (null !== this._usedName && this._usedName !== this.name) return `renamed to ${JSON.stringify(this._usedName).slice(1, -1)}`;
switch (this.canMangleProvide) {
case void 0:
switch (this.canMangleUse) {
case void 0:
return "missing provision and use info prevents renaming";

case !1:
return "usage prevents renaming (no provision info)";

case !0:
return "missing provision info prevents renaming";
}
break;

case !0:
switch (this.canMangleUse) {
case void 0:
return "missing usage info prevents renaming";

case !1:
return "usage prevents renaming";

case !0:
return "could be renamed";
}
break;

case !1:
switch (this.canMangleUse) {
case void 0:
return "provision prevents renaming (no use info)";

case !1:
return "usage and provision prevents renaming";

case !0:
return "provision prevents renaming";
}
}
throw new Error(`Unexpected flags for getRenameInfo ${this.canMangleProvide} ${this.canMangleUse}`);
}
}
module.exports = ExportsInfo, module.exports.ExportInfo = ExportInfo, module.exports.UsageState = UsageState;
},
5657: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConstDependency = __webpack_require__(30339), ExportsInfoDependency = __webpack_require__(14525);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("ExportsInfoApiPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ExportsInfoDependency, new ExportsInfoDependency.Template);
const handler = parser => {
parser.hooks.expressionMemberChain.for("__webpack_exports_info__").tap("ExportsInfoApiPlugin", ((expr, members) => {
const dep = members.length >= 2 ? new ExportsInfoDependency(expr.range, members.slice(0, -1), members[members.length - 1]) : new ExportsInfoDependency(expr.range, null, members[0]);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), !0;
})), parser.hooks.expression.for("__webpack_exports_info__").tap("ExportsInfoApiPlugin", (expr => {
const dep = new ConstDependency("true", expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("ExportsInfoApiPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ExportsInfoApiPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("ExportsInfoApiPlugin", handler);
}));
}
};
},
97056: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {OriginalSource, RawSource} = __webpack_require__(37946), ConcatenationScope = __webpack_require__(87291), {UsageState} = __webpack_require__(74603), InitFragment = __webpack_require__(95328), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), StaticExportsDependency = __webpack_require__(21776), createHash = __webpack_require__(27466), extractUrlAndGlobal = __webpack_require__(5599), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), {register} = __webpack_require__(86601), TYPES = new Set([ "javascript" ]), CSS_TYPES = new Set([ "css-import" ]), RUNTIME_REQUIREMENTS = new Set([ RuntimeGlobals.module ]), RUNTIME_REQUIREMENTS_FOR_SCRIPT = new Set([ RuntimeGlobals.loadScript ]), RUNTIME_REQUIREMENTS_FOR_MODULE = new Set([ RuntimeGlobals.definePropertyGetters ]), EMPTY_RUNTIME_REQUIREMENTS = new Set([]), getSourceForGlobalVariableExternal = (variableName, type) => {
Array.isArray(variableName) || (variableName = [ variableName ]);
return {
iife: "this" === type,
expression: `${type}${variableName.map((r => `[${JSON.stringify(r)}]`)).join("")}`
};
}, getSourceForCommonJsExternal = moduleAndSpecifiers => {
if (!Array.isArray(moduleAndSpecifiers)) return {
expression: `require(${JSON.stringify(moduleAndSpecifiers)})`
};
const moduleName = moduleAndSpecifiers[0];
return {
expression: `require(${JSON.stringify(moduleName)})${propertyAccess(moduleAndSpecifiers, 1)}`
};
}, getSourceForImportExternal = (moduleAndSpecifiers, runtimeTemplate) => {
const importName = runtimeTemplate.outputOptions.importFunctionName;
if (!runtimeTemplate.supportsDynamicImport() && "import" === importName) throw new Error("The target environment doesn't support 'import()' so it's not possible to use external type 'import'");
if (!Array.isArray(moduleAndSpecifiers)) return {
expression: `${importName}(${JSON.stringify(moduleAndSpecifiers)});`
};
if (1 === moduleAndSpecifiers.length) return {
expression: `${importName}(${JSON.stringify(moduleAndSpecifiers[0])});`
};
const moduleName = moduleAndSpecifiers[0];
return {
expression: `${importName}(${JSON.stringify(moduleName)}).then(${runtimeTemplate.returningFunction(`module${propertyAccess(moduleAndSpecifiers, 1)}`, "module")});`
};
};
class ModuleExternalInitFragment extends InitFragment {
constructor(request, ident, hashFunction = "md4") {
void 0 === ident && (ident = Template.toIdentifier(request)) !== request && (ident += `_${createHash(hashFunction).update(request).digest("hex").slice(0, 8)}`);
const identifier = `__WEBPACK_EXTERNAL_MODULE_${ident}__`;
super(`import * as ${identifier} from ${JSON.stringify(request)};\n`, InitFragment.STAGE_HARMONY_IMPORTS, 0, `external module import ${ident}`), 
this._ident = ident, this._identifier = identifier, this._request = request;
}
getNamespaceIdentifier() {
return this._identifier;
}
}
register(ModuleExternalInitFragment, "webpack/lib/ExternalModule", "ModuleExternalInitFragment", {
serialize(obj, {write}) {
write(obj._request), write(obj._ident);
},
deserialize: ({read}) => new ModuleExternalInitFragment(read(), read())
});
const generateModuleRemapping = (input, exportsInfo, runtime) => {
if (exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused) {
const properties = [];
for (const exportInfo of exportsInfo.orderedExports) {
const used = exportInfo.getUsedName(exportInfo.name, runtime);
if (!used) continue;
const nestedInfo = exportInfo.getNestedExportsInfo();
if (nestedInfo) {
const nestedExpr = generateModuleRemapping(`${input}${propertyAccess([ exportInfo.name ])}`, nestedInfo);
if (nestedExpr) {
properties.push(`[${JSON.stringify(used)}]: y(${nestedExpr})`);
continue;
}
}
properties.push(`[${JSON.stringify(used)}]: () => ${input}${propertyAccess([ exportInfo.name ])}`);
}
return `x({ ${properties.join(", ")} })`;
}
}, checkExternalVariable = (variableName, request, runtimeTemplate) => `if(typeof ${variableName} === 'undefined') { ${runtimeTemplate.throwMissingModuleErrorBlock({
request
})} }\n`;
class ExternalModule extends Module {
constructor(request, type, userRequest) {
super("javascript/dynamic", null), this.request = request, this.externalType = type, 
this.userRequest = userRequest;
}
getSourceTypes() {
return "css-import" === this.externalType ? CSS_TYPES : TYPES;
}
libIdent(options) {
return this.userRequest;
}
chunkCondition(chunk, {chunkGraph}) {
return "css-import" === this.externalType || chunkGraph.getNumberOfEntryModules(chunk) > 0;
}
identifier() {
return `external ${this.externalType} ${JSON.stringify(this.request)}`;
}
readableIdentifier(requestShortener) {
return "external " + JSON.stringify(this.request);
}
needBuild(context, callback) {
return callback(null, !this.buildMeta);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {
async: !1,
exportsType: void 0
}, this.buildInfo = {
strict: !0,
topLevelDeclarations: new Set,
module: compilation.outputOptions.module
};
const {request, externalType} = this._getRequestAndExternalType();
this.buildMeta.exportsType = "dynamic";
let canMangle = !1;
switch (this.clearDependenciesAndBlocks(), externalType) {
case "this":
this.buildInfo.strict = !1;
break;

case "system":
Array.isArray(request) && 1 !== request.length || (this.buildMeta.exportsType = "namespace", 
canMangle = !0);
break;

case "module":
this.buildInfo.module ? Array.isArray(request) && 1 !== request.length || (this.buildMeta.exportsType = "namespace", 
canMangle = !0) : (this.buildMeta.async = !0, Array.isArray(request) && 1 !== request.length || (this.buildMeta.exportsType = "namespace", 
canMangle = !1));
break;

case "script":
case "promise":
this.buildMeta.async = !0;
break;

case "import":
this.buildMeta.async = !0, Array.isArray(request) && 1 !== request.length || (this.buildMeta.exportsType = "namespace", 
canMangle = !1);
}
this.addDependency(new StaticExportsDependency(!0, canMangle)), callback();
}
restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
this._restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory);
}
getConcatenationBailoutReason({moduleGraph}) {
switch (this.externalType) {
case "amd":
case "amd-require":
case "umd":
case "umd2":
case "system":
case "jsonp":
return `${this.externalType} externals can't be concatenated`;
}
}
_getRequestAndExternalType() {
let {request, externalType} = this;
return "object" != typeof request || Array.isArray(request) || (request = request[externalType]), 
{
request,
externalType
};
}
_getSourceData(request, externalType, runtimeTemplate, moduleGraph, chunkGraph, runtime) {
switch (externalType) {
case "this":
case "window":
case "self":
return getSourceForGlobalVariableExternal(request, this.externalType);

case "global":
return getSourceForGlobalVariableExternal(request, runtimeTemplate.globalObject);

case "commonjs":
case "commonjs2":
case "commonjs-module":
case "commonjs-static":
return getSourceForCommonJsExternal(request);

case "node-commonjs":
return this.buildInfo.module ? (moduleAndSpecifiers => {
const chunkInitFragments = [ new InitFragment('import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "module";\n', InitFragment.STAGE_HARMONY_IMPORTS, 0, "external module node-commonjs") ];
if (!Array.isArray(moduleAndSpecifiers)) return {
expression: `__WEBPACK_EXTERNAL_createRequire(import.meta.url)(${JSON.stringify(moduleAndSpecifiers)})`,
chunkInitFragments
};
const moduleName = moduleAndSpecifiers[0];
return {
expression: `__WEBPACK_EXTERNAL_createRequire(import.meta.url)(${JSON.stringify(moduleName)})${propertyAccess(moduleAndSpecifiers, 1)}`,
chunkInitFragments
};
})(request) : getSourceForCommonJsExternal(request);

case "amd":
case "amd-require":
case "umd":
case "umd2":
case "system":
case "jsonp":
{
const id = chunkGraph.getModuleId(this);
return ((id, optional, request, runtimeTemplate) => {
const externalVariable = `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${id}`)}__`;
return {
init: optional ? checkExternalVariable(externalVariable, Array.isArray(request) ? request.join(".") : request, runtimeTemplate) : void 0,
expression: externalVariable
};
})(null !== id ? id : this.identifier(), this.isOptional(moduleGraph), request, runtimeTemplate);
}

case "import":
return getSourceForImportExternal(request, runtimeTemplate);

case "script":
return ((urlAndGlobal, runtimeTemplate) => {
"string" == typeof urlAndGlobal && (urlAndGlobal = extractUrlAndGlobal(urlAndGlobal));
const url = urlAndGlobal[0], globalName = urlAndGlobal[1];
return {
init: "var __webpack_error__ = new Error();",
expression: `new Promise(${runtimeTemplate.basicFunction("resolve, reject", [ `if(typeof ${globalName} !== "undefined") return resolve();`, `${RuntimeGlobals.loadScript}(${JSON.stringify(url)}, ${runtimeTemplate.basicFunction("event", [ `if(typeof ${globalName} !== "undefined") return resolve();`, "var errorType = event && (event.type === 'load' ? 'missing' : event.type);", "var realSrc = event && event.target && event.target.src;", "__webpack_error__.message = 'Loading script failed.\\n(' + errorType + ': ' + realSrc + ')';", "__webpack_error__.name = 'ScriptExternalLoadError';", "__webpack_error__.type = errorType;", "__webpack_error__.request = realSrc;", "reject(__webpack_error__);" ])}, ${JSON.stringify(globalName)});` ])}).then(${runtimeTemplate.returningFunction(`${globalName}${propertyAccess(urlAndGlobal, 2)}`)})`,
runtimeRequirements: RUNTIME_REQUIREMENTS_FOR_SCRIPT
};
})(request, runtimeTemplate);

case "module":
if (!this.buildInfo.module) {
if (!runtimeTemplate.supportsDynamicImport()) throw new Error("The target environment doesn't support dynamic import() syntax so it's not possible to use external type 'module' within a script" + (runtimeTemplate.supportsEcmaScriptModuleSyntax() ? "\nDid you mean to build a EcmaScript Module ('output.module: true')?" : ""));
return getSourceForImportExternal(request, runtimeTemplate);
}
if (!runtimeTemplate.supportsEcmaScriptModuleSyntax()) throw new Error("The target environment doesn't support EcmaScriptModule syntax so it's not possible to use external type 'module'");
return ((moduleAndSpecifiers, exportsInfo, runtime, hashFunction) => {
Array.isArray(moduleAndSpecifiers) || (moduleAndSpecifiers = [ moduleAndSpecifiers ]);
const initFragment = new ModuleExternalInitFragment(moduleAndSpecifiers[0], void 0, hashFunction), baseAccess = `${initFragment.getNamespaceIdentifier()}${propertyAccess(moduleAndSpecifiers, 1)}`, moduleRemapping = generateModuleRemapping(baseAccess, exportsInfo, runtime);
return {
expression: moduleRemapping || baseAccess,
init: `var x = y => { var x = {}; ${RuntimeGlobals.definePropertyGetters}(x, y); return x; }\nvar y = x => () => x`,
runtimeRequirements: moduleRemapping ? RUNTIME_REQUIREMENTS_FOR_MODULE : void 0,
chunkInitFragments: [ initFragment ]
};
})(request, moduleGraph.getExportsInfo(this), runtime, runtimeTemplate.outputOptions.hashFunction);

default:
return ((optional, request, runtimeTemplate) => {
Array.isArray(request) || (request = [ request ]);
const variableName = request[0], objectLookup = propertyAccess(request, 1);
return {
init: optional ? checkExternalVariable(variableName, request.join("."), runtimeTemplate) : void 0,
expression: `${variableName}${objectLookup}`
};
})(this.isOptional(moduleGraph), request, runtimeTemplate);
}
}
codeGeneration({runtimeTemplate, moduleGraph, chunkGraph, runtime, concatenationScope}) {
const {request, externalType} = this._getRequestAndExternalType();
switch (externalType) {
case "asset":
{
const sources = new Map;
sources.set("javascript", new RawSource(`module.exports = ${JSON.stringify(request)};`));
const data = new Map;
return data.set("url", request), {
sources,
runtimeRequirements: RUNTIME_REQUIREMENTS,
data
};
}

case "css-import":
{
const sources = new Map;
return sources.set("css-import", new RawSource(`@import url(${JSON.stringify(request)});`)), 
{
sources,
runtimeRequirements: EMPTY_RUNTIME_REQUIREMENTS
};
}

default:
{
const sourceData = this._getSourceData(request, externalType, runtimeTemplate, moduleGraph, chunkGraph, runtime);
let data, sourceString = sourceData.expression;
sourceData.iife && (sourceString = `(function() { return ${sourceString}; }())`), 
concatenationScope ? (sourceString = `${runtimeTemplate.supportsConst() ? "const" : "var"} ${ConcatenationScope.NAMESPACE_OBJECT_EXPORT} = ${sourceString};`, 
concatenationScope.registerNamespaceExport(ConcatenationScope.NAMESPACE_OBJECT_EXPORT)) : sourceString = `module.exports = ${sourceString};`, 
sourceData.init && (sourceString = `${sourceData.init}\n${sourceString}`), sourceData.chunkInitFragments && (data = new Map, 
data.set("chunkInitFragments", sourceData.chunkInitFragments));
const sources = new Map;
this.useSourceMap || this.useSimpleSourceMap ? sources.set("javascript", new OriginalSource(sourceString, this.identifier())) : sources.set("javascript", new RawSource(sourceString));
let runtimeRequirements = sourceData.runtimeRequirements;
if (!concatenationScope) if (runtimeRequirements) {
const set = new Set(runtimeRequirements);
set.add(RuntimeGlobals.module), runtimeRequirements = set;
} else runtimeRequirements = RUNTIME_REQUIREMENTS;
return {
sources,
runtimeRequirements: runtimeRequirements || EMPTY_RUNTIME_REQUIREMENTS,
data
};
}
}
}
size(type) {
return 42;
}
updateHash(hash, context) {
const {chunkGraph} = context;
hash.update(`${this.externalType}${JSON.stringify(this.request)}${this.isOptional(chunkGraph.moduleGraph)}`), 
super.updateHash(hash, context);
}
serialize(context) {
const {write} = context;
write(this.request), write(this.externalType), write(this.userRequest), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.request = read(), this.externalType = read(), this.userRequest = read(), super.deserialize(context);
}
}
makeSerializable(ExternalModule, "webpack/lib/ExternalModule"), module.exports = ExternalModule;
},
30229: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), ExternalModule = __webpack_require__(97056), {resolveByProperty, cachedSetProperty} = __webpack_require__(8639), UNSPECIFIED_EXTERNAL_TYPE_REGEXP = /^[a-z0-9-]+ /, EMPTY_RESOLVE_OPTIONS = {}, callDeprecatedExternals = util.deprecate(((externalsFunction, context, request, cb) => {
externalsFunction.call(null, context, request, cb);
}), "The externals-function should be defined like ({context, request}, cb) => { ... }", "DEP_WEBPACK_EXTERNALS_FUNCTION_PARAMETERS"), cache = new WeakMap;
module.exports = class {
constructor(type, externals) {
this.type = type, this.externals = externals;
}
apply(normalModuleFactory) {
const globalType = this.type;
normalModuleFactory.hooks.factorize.tapAsync("ExternalModuleFactoryPlugin", ((data, callback) => {
const context = data.context, contextInfo = data.contextInfo, dependency = data.dependencies[0], dependencyType = data.dependencyType, handleExternal = (value, type, callback) => {
if (!1 === value) return callback();
let externalConfig;
if (externalConfig = !0 === value ? dependency.request : value, void 0 === type) if ("string" == typeof externalConfig && UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig)) {
const idx = externalConfig.indexOf(" ");
type = externalConfig.slice(0, idx), externalConfig = externalConfig.slice(idx + 1);
} else if (Array.isArray(externalConfig) && externalConfig.length > 0 && UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig[0])) {
const firstItem = externalConfig[0], idx = firstItem.indexOf(" ");
type = firstItem.slice(0, idx), externalConfig = [ firstItem.slice(idx + 1), ...externalConfig.slice(1) ];
}
callback(null, new ExternalModule(externalConfig, type || globalType, dependency.request));
}, handleExternals = (externals, callback) => {
if ("string" == typeof externals) {
if (externals === dependency.request) return handleExternal(dependency.request, void 0, callback);
} else {
if (Array.isArray(externals)) {
let i = 0;
const next = () => {
let asyncFlag;
const handleExternalsAndCallback = (err, module) => err ? callback(err) : module ? void callback(null, module) : asyncFlag ? void (asyncFlag = !1) : next();
do {
if (asyncFlag = !0, i >= externals.length) return callback();
handleExternals(externals[i++], handleExternalsAndCallback);
} while (!asyncFlag);
asyncFlag = !1;
};
return void next();
}
if (externals instanceof RegExp) {
if (externals.test(dependency.request)) return handleExternal(dependency.request, void 0, callback);
} else {
if ("function" == typeof externals) {
const cb = (err, value, type) => {
if (err) return callback(err);
void 0 !== value ? handleExternal(value, type, callback) : callback();
};
if (3 === externals.length) callDeprecatedExternals(externals, context, dependency.request, cb); else {
const promise = externals({
context,
request: dependency.request,
dependencyType,
contextInfo,
getResolve: options => (context, request, callback) => {
const resolveContext = {
fileDependencies: data.fileDependencies,
missingDependencies: data.missingDependencies,
contextDependencies: data.contextDependencies
};
let resolver = normalModuleFactory.getResolver("normal", dependencyType ? cachedSetProperty(data.resolveOptions || EMPTY_RESOLVE_OPTIONS, "dependencyType", dependencyType) : data.resolveOptions);
if (options && (resolver = resolver.withOptions(options)), !callback) return new Promise(((resolve, reject) => {
resolver.resolve({}, context, request, resolveContext, ((err, result) => {
err ? reject(err) : resolve(result);
}));
}));
resolver.resolve({}, context, request, resolveContext, callback);
}
}, cb);
promise && promise.then && promise.then((r => cb(null, r)), cb);
}
return;
}
if ("object" == typeof externals) {
const resolvedExternals = ((obj, layer) => {
let map = cache.get(obj);
if (void 0 === map) map = new Map, cache.set(obj, map); else {
const cacheEntry = map.get(layer);
if (void 0 !== cacheEntry) return cacheEntry;
}
const result = resolveByProperty(obj, "byLayer", layer);
return map.set(layer, result), result;
})(externals, contextInfo.issuerLayer);
if (Object.prototype.hasOwnProperty.call(resolvedExternals, dependency.request)) return handleExternal(resolvedExternals[dependency.request], void 0, callback);
}
}
}
callback();
};
handleExternals(this.externals, callback);
}));
}
};
},
29301: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ExternalModuleFactoryPlugin = __webpack_require__(30229);
module.exports = class {
constructor(type, externals) {
this.type = type, this.externals = externals;
}
apply(compiler) {
compiler.hooks.compile.tap("ExternalsPlugin", (({normalModuleFactory}) => {
new ExternalModuleFactoryPlugin(this.type, this.externals).apply(normalModuleFactory);
}));
}
};
},
91664: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {create: createResolver} = __webpack_require__(92672), nodeModule = __webpack_require__(98188), asyncLib = __webpack_require__(76947), {isAbsolute} = __webpack_require__(71017), AsyncQueue = __webpack_require__(90756), StackedCacheMap = __webpack_require__(65929), createHash = __webpack_require__(27466), {join, dirname, relative, lstatReadlinkAbsolute} = __webpack_require__(57075), makeSerializable = __webpack_require__(45898), processAsyncTree = __webpack_require__(21869), supportsEsm = +process.versions.modules >= 83, builtinModules = new Set(nodeModule.builtinModules);
let FS_ACCURACY = 2e3;
const EMPTY_SET = new Set, INVALID = Symbol("invalid"), DONE_ITERATOR_RESULT = (new Set).keys().next();
class SnapshotIterator {
constructor(next) {
this.next = next;
}
}
class SnapshotIterable {
constructor(snapshot, getMaps) {
this.snapshot = snapshot, this.getMaps = getMaps;
}
[Symbol.iterator]() {
let it, getMaps, maps, snapshot, queue, state = 0;
return new SnapshotIterator((() => {
for (;;) switch (state) {
case 0:
snapshot = this.snapshot, getMaps = this.getMaps, maps = getMaps(snapshot), state = 1;

case 1:
if (!(maps.length > 0)) {
state = 3;
break;
}
{
const map = maps.pop();
if (void 0 === map) break;
it = map.keys(), state = 2;
}

case 2:
{
const result = it.next();
if (!result.done) return result;
state = 1;
break;
}

case 3:
{
const children = snapshot.children;
if (void 0 !== children) {
if (1 === children.size) {
for (const child of children) snapshot = child;
maps = getMaps(snapshot), state = 1;
break;
}
void 0 === queue && (queue = []);
for (const child of children) queue.push(child);
}
if (void 0 !== queue && queue.length > 0) {
snapshot = queue.pop(), maps = getMaps(snapshot), state = 1;
break;
}
state = 4;
}

case 4:
return DONE_ITERATOR_RESULT;
}
}));
}
}
class Snapshot {
constructor() {
this._flags = 0, this._cachedFileIterable = void 0, this._cachedContextIterable = void 0, 
this._cachedMissingIterable = void 0, this.startTime = void 0, this.fileTimestamps = void 0, 
this.fileHashes = void 0, this.fileTshs = void 0, this.contextTimestamps = void 0, 
this.contextHashes = void 0, this.contextTshs = void 0, this.missingExistence = void 0, 
this.managedItemInfo = void 0, this.managedFiles = void 0, this.managedContexts = void 0, 
this.managedMissing = void 0, this.children = void 0;
}
hasStartTime() {
return 0 != (1 & this._flags);
}
setStartTime(value) {
this._flags = 1 | this._flags, this.startTime = value;
}
setMergedStartTime(value, snapshot) {
value ? snapshot.hasStartTime() ? this.setStartTime(Math.min(value, snapshot.startTime)) : this.setStartTime(value) : snapshot.hasStartTime() && this.setStartTime(snapshot.startTime);
}
hasFileTimestamps() {
return 0 != (2 & this._flags);
}
setFileTimestamps(value) {
this._flags = 2 | this._flags, this.fileTimestamps = value;
}
hasFileHashes() {
return 0 != (4 & this._flags);
}
setFileHashes(value) {
this._flags = 4 | this._flags, this.fileHashes = value;
}
hasFileTshs() {
return 0 != (8 & this._flags);
}
setFileTshs(value) {
this._flags = 8 | this._flags, this.fileTshs = value;
}
hasContextTimestamps() {
return 0 != (16 & this._flags);
}
setContextTimestamps(value) {
this._flags = 16 | this._flags, this.contextTimestamps = value;
}
hasContextHashes() {
return 0 != (32 & this._flags);
}
setContextHashes(value) {
this._flags = 32 | this._flags, this.contextHashes = value;
}
hasContextTshs() {
return 0 != (64 & this._flags);
}
setContextTshs(value) {
this._flags = 64 | this._flags, this.contextTshs = value;
}
hasMissingExistence() {
return 0 != (128 & this._flags);
}
setMissingExistence(value) {
this._flags = 128 | this._flags, this.missingExistence = value;
}
hasManagedItemInfo() {
return 0 != (256 & this._flags);
}
setManagedItemInfo(value) {
this._flags = 256 | this._flags, this.managedItemInfo = value;
}
hasManagedFiles() {
return 0 != (512 & this._flags);
}
setManagedFiles(value) {
this._flags = 512 | this._flags, this.managedFiles = value;
}
hasManagedContexts() {
return 0 != (1024 & this._flags);
}
setManagedContexts(value) {
this._flags = 1024 | this._flags, this.managedContexts = value;
}
hasManagedMissing() {
return 0 != (2048 & this._flags);
}
setManagedMissing(value) {
this._flags = 2048 | this._flags, this.managedMissing = value;
}
hasChildren() {
return 0 != (4096 & this._flags);
}
setChildren(value) {
this._flags = 4096 | this._flags, this.children = value;
}
addChild(child) {
this.hasChildren() || this.setChildren(new Set), this.children.add(child);
}
serialize({write}) {
write(this._flags), this.hasStartTime() && write(this.startTime), this.hasFileTimestamps() && write(this.fileTimestamps), 
this.hasFileHashes() && write(this.fileHashes), this.hasFileTshs() && write(this.fileTshs), 
this.hasContextTimestamps() && write(this.contextTimestamps), this.hasContextHashes() && write(this.contextHashes), 
this.hasContextTshs() && write(this.contextTshs), this.hasMissingExistence() && write(this.missingExistence), 
this.hasManagedItemInfo() && write(this.managedItemInfo), this.hasManagedFiles() && write(this.managedFiles), 
this.hasManagedContexts() && write(this.managedContexts), this.hasManagedMissing() && write(this.managedMissing), 
this.hasChildren() && write(this.children);
}
deserialize({read}) {
this._flags = read(), this.hasStartTime() && (this.startTime = read()), this.hasFileTimestamps() && (this.fileTimestamps = read()), 
this.hasFileHashes() && (this.fileHashes = read()), this.hasFileTshs() && (this.fileTshs = read()), 
this.hasContextTimestamps() && (this.contextTimestamps = read()), this.hasContextHashes() && (this.contextHashes = read()), 
this.hasContextTshs() && (this.contextTshs = read()), this.hasMissingExistence() && (this.missingExistence = read()), 
this.hasManagedItemInfo() && (this.managedItemInfo = read()), this.hasManagedFiles() && (this.managedFiles = read()), 
this.hasManagedContexts() && (this.managedContexts = read()), this.hasManagedMissing() && (this.managedMissing = read()), 
this.hasChildren() && (this.children = read());
}
_createIterable(getMaps) {
return new SnapshotIterable(this, getMaps);
}
getFileIterable() {
return void 0 === this._cachedFileIterable && (this._cachedFileIterable = this._createIterable((s => [ s.fileTimestamps, s.fileHashes, s.fileTshs, s.managedFiles ]))), 
this._cachedFileIterable;
}
getContextIterable() {
return void 0 === this._cachedContextIterable && (this._cachedContextIterable = this._createIterable((s => [ s.contextTimestamps, s.contextHashes, s.contextTshs, s.managedContexts ]))), 
this._cachedContextIterable;
}
getMissingIterable() {
return void 0 === this._cachedMissingIterable && (this._cachedMissingIterable = this._createIterable((s => [ s.missingExistence, s.managedMissing ]))), 
this._cachedMissingIterable;
}
}
makeSerializable(Snapshot, "webpack/lib/FileSystemInfo", "Snapshot");
class SnapshotOptimization {
constructor(has, get, set, useStartTime = !0, isSet = !1) {
this._has = has, this._get = get, this._set = set, this._useStartTime = useStartTime, 
this._isSet = isSet, this._map = new Map, this._statItemsShared = 0, this._statItemsUnshared = 0, 
this._statSharedSnapshots = 0, this._statReusedSharedSnapshots = 0;
}
getStatisticMessage() {
const total = this._statItemsShared + this._statItemsUnshared;
if (0 !== total) return `${this._statItemsShared && Math.round(100 * this._statItemsShared / total)}% (${this._statItemsShared}/${total}) entries shared via ${this._statSharedSnapshots} shared snapshots (${this._statReusedSharedSnapshots + this._statSharedSnapshots} times referenced)`;
}
clear() {
this._map.clear(), this._statItemsShared = 0, this._statItemsUnshared = 0, this._statSharedSnapshots = 0, 
this._statReusedSharedSnapshots = 0;
}
optimize(newSnapshot, capturedFiles) {
const increaseSharedAndStoreOptimizationEntry = entry => {
void 0 !== entry.children && entry.children.forEach(increaseSharedAndStoreOptimizationEntry), 
entry.shared++, storeOptimizationEntry(entry);
}, storeOptimizationEntry = entry => {
for (const path of entry.snapshotContent) {
this._map.get(path).shared < entry.shared && this._map.set(path, entry), capturedFiles.delete(path);
}
};
let newOptimizationEntry;
const capturedFilesSize = capturedFiles.size, optimizationEntries = new Set;
for (const path of capturedFiles) {
const optimizationEntry = this._map.get(path);
void 0 !== optimizationEntry ? optimizationEntries.add(optimizationEntry) : (void 0 === newOptimizationEntry && (newOptimizationEntry = {
snapshot: newSnapshot,
shared: 0,
snapshotContent: void 0,
children: void 0
}), this._map.set(path, newOptimizationEntry));
}
optimizationEntries: for (const optimizationEntry of optimizationEntries) {
const snapshot = optimizationEntry.snapshot;
if (optimizationEntry.shared > 0) {
if (this._useStartTime && newSnapshot.startTime && (!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)) continue;
const nonSharedFiles = new Set, snapshotContent = optimizationEntry.snapshotContent, snapshotEntries = this._get(snapshot);
for (const path of snapshotContent) if (capturedFiles.has(path)) ; else {
if (!snapshotEntries.has(path)) continue optimizationEntries;
nonSharedFiles.add(path);
}
if (0 === nonSharedFiles.size) newSnapshot.addChild(snapshot), increaseSharedAndStoreOptimizationEntry(optimizationEntry), 
this._statReusedSharedSnapshots++; else {
if (snapshotContent.size - nonSharedFiles.size < 3) continue optimizationEntries;
let commonMap;
if (this._isSet) {
commonMap = new Set;
for (const path of snapshotEntries) nonSharedFiles.has(path) || (commonMap.add(path), 
snapshotEntries.delete(path));
} else {
commonMap = new Map;
const map = snapshotEntries;
for (const [path, value] of map) nonSharedFiles.has(path) || (commonMap.set(path, value), 
snapshotEntries.delete(path));
}
const commonSnapshot = new Snapshot;
this._useStartTime && commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot), 
this._set(commonSnapshot, commonMap), newSnapshot.addChild(commonSnapshot), snapshot.addChild(commonSnapshot);
const newEntry = {
snapshot: commonSnapshot,
shared: optimizationEntry.shared + 1,
snapshotContent: new Set(commonMap.keys()),
children: void 0
};
void 0 === optimizationEntry.children && (optimizationEntry.children = new Set), 
optimizationEntry.children.add(newEntry), storeOptimizationEntry(newEntry), this._statSharedSnapshots++;
}
} else {
const snapshotEntries = this._get(snapshot);
if (void 0 === snapshotEntries) continue optimizationEntries;
let commonMap;
if (this._isSet) {
commonMap = new Set;
const set = snapshotEntries;
if (capturedFiles.size < set.size) for (const path of capturedFiles) set.has(path) && commonMap.add(path); else for (const path of set) capturedFiles.has(path) && commonMap.add(path);
} else {
commonMap = new Map;
const map = snapshotEntries;
for (const path of capturedFiles) {
const ts = map.get(path);
void 0 !== ts && commonMap.set(path, ts);
}
}
if (commonMap.size < 3) continue optimizationEntries;
const commonSnapshot = new Snapshot;
this._useStartTime && commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot), 
this._set(commonSnapshot, commonMap), newSnapshot.addChild(commonSnapshot), snapshot.addChild(commonSnapshot);
for (const path of commonMap.keys()) snapshotEntries.delete(path);
const sharedCount = commonMap.size;
this._statItemsUnshared -= sharedCount, this._statItemsShared += sharedCount, storeOptimizationEntry({
snapshot: commonSnapshot,
shared: 2,
snapshotContent: new Set(commonMap.keys()),
children: void 0
}), this._statSharedSnapshots++;
}
}
const unshared = capturedFiles.size;
this._statItemsUnshared += unshared, this._statItemsShared += capturedFilesSize - unshared;
}
}
const parseString = str => ("'" === str[0] && (str = `"${str.slice(1, -1).replace(/"/g, '\\"')}"`), 
JSON.parse(str)), applyMtime = mtime => {
FS_ACCURACY > 1 && mtime % 2 != 0 ? FS_ACCURACY = 1 : FS_ACCURACY > 10 && mtime % 20 != 0 ? FS_ACCURACY = 10 : FS_ACCURACY > 100 && mtime % 200 != 0 ? FS_ACCURACY = 100 : FS_ACCURACY > 1e3 && mtime % 2e3 != 0 && (FS_ACCURACY = 1e3);
}, mergeMaps = (a, b) => {
if (!b || 0 === b.size) return a;
if (!a || 0 === a.size) return b;
const map = new Map(a);
for (const [key, value] of b) map.set(key, value);
return map;
}, mergeSets = (a, b) => {
if (!b || 0 === b.size) return a;
if (!a || 0 === a.size) return b;
const map = new Set(a);
for (const item of b) map.add(item);
return map;
}, getManagedItem = (managedPath, path) => {
let i = managedPath.length, slashes = 1, startingPosition = !0;
loop: for (;i < path.length; ) {
switch (path.charCodeAt(i)) {
case 47:
case 92:
if (0 == --slashes) break loop;
startingPosition = !0;
break;

case 46:
if (startingPosition) return null;
break;

case 64:
if (!startingPosition) return null;
slashes++;
break;

default:
startingPosition = !1;
}
i++;
}
if (i === path.length && slashes--, 0 !== slashes) return null;
if (path.length >= i + 13 && 110 === path.charCodeAt(i + 1) && 111 === path.charCodeAt(i + 2) && 100 === path.charCodeAt(i + 3) && 101 === path.charCodeAt(i + 4) && 95 === path.charCodeAt(i + 5) && 109 === path.charCodeAt(i + 6) && 111 === path.charCodeAt(i + 7) && 100 === path.charCodeAt(i + 8) && 117 === path.charCodeAt(i + 9) && 108 === path.charCodeAt(i + 10) && 101 === path.charCodeAt(i + 11) && 115 === path.charCodeAt(i + 12)) {
if (path.length === i + 13) return path;
const c = path.charCodeAt(i + 13);
if (47 === c || 92 === c) return getManagedItem(path.slice(0, i + 14), path);
}
return path.slice(0, i);
}, getResolvedTimestamp = entry => null === entry ? null : void 0 !== entry.resolved ? entry.resolved : void 0 === entry.symlinks ? entry : void 0, getResolvedHash = entry => null === entry ? null : void 0 !== entry.resolved ? entry.resolved : void 0 === entry.symlinks ? entry.hash : void 0, addAll = (source, target) => {
for (const key of source) target.add(key);
};
module.exports = class {
constructor(fs, {managedPaths = [], immutablePaths = [], logger, hashFunction = "md4"} = {}) {
this.fs = fs, this.logger = logger, this._remainingLogs = logger ? 40 : 0, this._loggedPaths = logger ? new Set : void 0, 
this._hashFunction = hashFunction, this._snapshotCache = new WeakMap, this._fileTimestampsOptimization = new SnapshotOptimization((s => s.hasFileTimestamps()), (s => s.fileTimestamps), ((s, v) => s.setFileTimestamps(v))), 
this._fileHashesOptimization = new SnapshotOptimization((s => s.hasFileHashes()), (s => s.fileHashes), ((s, v) => s.setFileHashes(v)), !1), 
this._fileTshsOptimization = new SnapshotOptimization((s => s.hasFileTshs()), (s => s.fileTshs), ((s, v) => s.setFileTshs(v))), 
this._contextTimestampsOptimization = new SnapshotOptimization((s => s.hasContextTimestamps()), (s => s.contextTimestamps), ((s, v) => s.setContextTimestamps(v))), 
this._contextHashesOptimization = new SnapshotOptimization((s => s.hasContextHashes()), (s => s.contextHashes), ((s, v) => s.setContextHashes(v)), !1), 
this._contextTshsOptimization = new SnapshotOptimization((s => s.hasContextTshs()), (s => s.contextTshs), ((s, v) => s.setContextTshs(v))), 
this._missingExistenceOptimization = new SnapshotOptimization((s => s.hasMissingExistence()), (s => s.missingExistence), ((s, v) => s.setMissingExistence(v)), !1), 
this._managedItemInfoOptimization = new SnapshotOptimization((s => s.hasManagedItemInfo()), (s => s.managedItemInfo), ((s, v) => s.setManagedItemInfo(v)), !1), 
this._managedFilesOptimization = new SnapshotOptimization((s => s.hasManagedFiles()), (s => s.managedFiles), ((s, v) => s.setManagedFiles(v)), !1, !0), 
this._managedContextsOptimization = new SnapshotOptimization((s => s.hasManagedContexts()), (s => s.managedContexts), ((s, v) => s.setManagedContexts(v)), !1, !0), 
this._managedMissingOptimization = new SnapshotOptimization((s => s.hasManagedMissing()), (s => s.managedMissing), ((s, v) => s.setManagedMissing(v)), !1, !0), 
this._fileTimestamps = new StackedCacheMap, this._fileHashes = new Map, this._fileTshs = new Map, 
this._contextTimestamps = new StackedCacheMap, this._contextHashes = new Map, this._contextTshs = new Map, 
this._managedItems = new Map, this.fileTimestampQueue = new AsyncQueue({
name: "file timestamp",
parallelism: 30,
processor: this._readFileTimestamp.bind(this)
}), this.fileHashQueue = new AsyncQueue({
name: "file hash",
parallelism: 10,
processor: this._readFileHash.bind(this)
}), this.contextTimestampQueue = new AsyncQueue({
name: "context timestamp",
parallelism: 2,
processor: this._readContextTimestamp.bind(this)
}), this.contextHashQueue = new AsyncQueue({
name: "context hash",
parallelism: 2,
processor: this._readContextHash.bind(this)
}), this.contextTshQueue = new AsyncQueue({
name: "context hash and timestamp",
parallelism: 2,
processor: this._readContextTimestampAndHash.bind(this)
}), this.managedItemQueue = new AsyncQueue({
name: "managed item info",
parallelism: 10,
processor: this._getManagedItemInfo.bind(this)
}), this.managedItemDirectoryQueue = new AsyncQueue({
name: "managed item directory info",
parallelism: 10,
processor: this._getManagedItemDirectoryInfo.bind(this)
}), this.managedPaths = Array.from(managedPaths), this.managedPathsWithSlash = this.managedPaths.filter((p => "string" == typeof p)).map((p => join(fs, p, "_").slice(0, -1))), 
this.managedPathsRegExps = this.managedPaths.filter((p => "string" != typeof p)), 
this.immutablePaths = Array.from(immutablePaths), this.immutablePathsWithSlash = this.immutablePaths.filter((p => "string" == typeof p)).map((p => join(fs, p, "_").slice(0, -1))), 
this.immutablePathsRegExps = this.immutablePaths.filter((p => "string" != typeof p)), 
this._cachedDeprecatedFileTimestamps = void 0, this._cachedDeprecatedContextTimestamps = void 0, 
this._warnAboutExperimentalEsmTracking = !1, this._statCreatedSnapshots = 0, this._statTestedSnapshotsCached = 0, 
this._statTestedSnapshotsNotCached = 0, this._statTestedChildrenCached = 0, this._statTestedChildrenNotCached = 0, 
this._statTestedEntries = 0;
}
logStatistics() {
const logWhenMessage = (header, message) => {
message && this.logger.log(`${header}: ${message}`);
};
this.logger.log(`${this._statCreatedSnapshots} new snapshots created`), this.logger.log(`${this._statTestedSnapshotsNotCached && Math.round(100 * this._statTestedSnapshotsNotCached / (this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached))}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached})`), 
this.logger.log(`${this._statTestedChildrenNotCached && Math.round(100 * this._statTestedChildrenNotCached / (this._statTestedChildrenCached + this._statTestedChildrenNotCached))}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${this._statTestedChildrenCached + this._statTestedChildrenNotCached})`), 
this.logger.log(`${this._statTestedEntries} entries tested`), this.logger.log(`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`), 
logWhenMessage("File timestamp snapshot optimization", this._fileTimestampsOptimization.getStatisticMessage()), 
logWhenMessage("File hash snapshot optimization", this._fileHashesOptimization.getStatisticMessage()), 
logWhenMessage("File timestamp hash combination snapshot optimization", this._fileTshsOptimization.getStatisticMessage()), 
this.logger.log(`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`), 
logWhenMessage("Directory timestamp snapshot optimization", this._contextTimestampsOptimization.getStatisticMessage()), 
logWhenMessage("Directory hash snapshot optimization", this._contextHashesOptimization.getStatisticMessage()), 
logWhenMessage("Directory timestamp hash combination snapshot optimization", this._contextTshsOptimization.getStatisticMessage()), 
logWhenMessage("Missing items snapshot optimization", this._missingExistenceOptimization.getStatisticMessage()), 
this.logger.log(`Managed items info in cache: ${this._managedItems.size} items`), 
logWhenMessage("Managed items snapshot optimization", this._managedItemInfoOptimization.getStatisticMessage()), 
logWhenMessage("Managed files snapshot optimization", this._managedFilesOptimization.getStatisticMessage()), 
logWhenMessage("Managed contexts snapshot optimization", this._managedContextsOptimization.getStatisticMessage()), 
logWhenMessage("Managed missing snapshot optimization", this._managedMissingOptimization.getStatisticMessage());
}
_log(path, reason, ...args) {
const key = path + reason;
this._loggedPaths.has(key) || (this._loggedPaths.add(key), this.logger.debug(`${path} invalidated because ${reason}`, ...args), 
0 == --this._remainingLogs && this.logger.debug("Logging limit has been reached and no further logging will be emitted by FileSystemInfo"));
}
clear() {
this._remainingLogs = this.logger ? 40 : 0, void 0 !== this._loggedPaths && this._loggedPaths.clear(), 
this._snapshotCache = new WeakMap, this._fileTimestampsOptimization.clear(), this._fileHashesOptimization.clear(), 
this._fileTshsOptimization.clear(), this._contextTimestampsOptimization.clear(), 
this._contextHashesOptimization.clear(), this._contextTshsOptimization.clear(), 
this._missingExistenceOptimization.clear(), this._managedItemInfoOptimization.clear(), 
this._managedFilesOptimization.clear(), this._managedContextsOptimization.clear(), 
this._managedMissingOptimization.clear(), this._fileTimestamps.clear(), this._fileHashes.clear(), 
this._fileTshs.clear(), this._contextTimestamps.clear(), this._contextHashes.clear(), 
this._contextTshs.clear(), this._managedItems.clear(), this._managedItems.clear(), 
this._cachedDeprecatedFileTimestamps = void 0, this._cachedDeprecatedContextTimestamps = void 0, 
this._statCreatedSnapshots = 0, this._statTestedSnapshotsCached = 0, this._statTestedSnapshotsNotCached = 0, 
this._statTestedChildrenCached = 0, this._statTestedChildrenNotCached = 0, this._statTestedEntries = 0;
}
addFileTimestamps(map, immutable) {
this._fileTimestamps.addAll(map, immutable), this._cachedDeprecatedFileTimestamps = void 0;
}
addContextTimestamps(map, immutable) {
this._contextTimestamps.addAll(map, immutable), this._cachedDeprecatedContextTimestamps = void 0;
}
getFileTimestamp(path, callback) {
const cache = this._fileTimestamps.get(path);
if (void 0 !== cache) return callback(null, cache);
this.fileTimestampQueue.add(path, callback);
}
getContextTimestamp(path, callback) {
const cache = this._contextTimestamps.get(path);
if (void 0 !== cache) {
if ("ignore" === cache) return callback(null, "ignore");
const resolved = getResolvedTimestamp(cache);
return void 0 !== resolved ? callback(null, resolved) : this._resolveContextTimestamp(cache, callback);
}
this.contextTimestampQueue.add(path, ((err, entry) => {
if (err) return callback(err);
const resolved = getResolvedTimestamp(entry);
if (void 0 !== resolved) return callback(null, resolved);
this._resolveContextTimestamp(entry, callback);
}));
}
_getUnresolvedContextTimestamp(path, callback) {
const cache = this._contextTimestamps.get(path);
if (void 0 !== cache) return callback(null, cache);
this.contextTimestampQueue.add(path, callback);
}
getFileHash(path, callback) {
const cache = this._fileHashes.get(path);
if (void 0 !== cache) return callback(null, cache);
this.fileHashQueue.add(path, callback);
}
getContextHash(path, callback) {
const cache = this._contextHashes.get(path);
if (void 0 !== cache) {
const resolved = getResolvedHash(cache);
return void 0 !== resolved ? callback(null, resolved) : this._resolveContextHash(cache, callback);
}
this.contextHashQueue.add(path, ((err, entry) => {
if (err) return callback(err);
const resolved = getResolvedHash(entry);
if (void 0 !== resolved) return callback(null, resolved);
this._resolveContextHash(entry, callback);
}));
}
_getUnresolvedContextHash(path, callback) {
const cache = this._contextHashes.get(path);
if (void 0 !== cache) return callback(null, cache);
this.contextHashQueue.add(path, callback);
}
getContextTsh(path, callback) {
const cache = this._contextTshs.get(path);
if (void 0 !== cache) {
const resolved = getResolvedTimestamp(cache);
return void 0 !== resolved ? callback(null, resolved) : this._resolveContextTsh(cache, callback);
}
this.contextTshQueue.add(path, ((err, entry) => {
if (err) return callback(err);
const resolved = getResolvedTimestamp(entry);
if (void 0 !== resolved) return callback(null, resolved);
this._resolveContextTsh(entry, callback);
}));
}
_getUnresolvedContextTsh(path, callback) {
const cache = this._contextTshs.get(path);
if (void 0 !== cache) return callback(null, cache);
this.contextTshQueue.add(path, callback);
}
_createBuildDependenciesResolvers() {
const resolveContext = createResolver({
resolveToContext: !0,
exportsFields: [],
fileSystem: this.fs
}), resolveCjs = createResolver({
extensions: [ ".js", ".json", ".node" ],
conditionNames: [ "require", "node" ],
exportsFields: [ "exports" ],
fileSystem: this.fs
}), resolveCjsAsChild = createResolver({
extensions: [ ".js", ".json", ".node" ],
conditionNames: [ "require", "node" ],
exportsFields: [],
fileSystem: this.fs
});
return {
resolveContext,
resolveEsm: createResolver({
extensions: [ ".js", ".json", ".node" ],
fullySpecified: !0,
conditionNames: [ "import", "node" ],
exportsFields: [ "exports" ],
fileSystem: this.fs
}),
resolveCjs,
resolveCjsAsChild
};
}
resolveBuildDependencies(context, deps, callback) {
const {resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild} = this._createBuildDependenciesResolvers(), files = new Set, fileSymlinks = new Set, directories = new Set, directorySymlinks = new Set, missing = new Set, resolveFiles = new Set, resolveDirectories = new Set, resolveMissing = new Set, resolveResults = new Map, invalidResolveResults = new Set, resolverContext = {
fileDependencies: resolveFiles,
contextDependencies: resolveDirectories,
missingDependencies: resolveMissing
}, expectedToString = expected => expected ? ` (expected ${expected})` : "", jobToString = job => {
switch (job.type) {
case 0:
return `resolve commonjs ${job.path}${expectedToString(job.expected)}`;

case 1:
return `resolve esm ${job.path}${expectedToString(job.expected)}`;

case 2:
return `resolve directory ${job.path}`;

case 3:
return `resolve commonjs file ${job.path}${expectedToString(job.expected)}`;

case 5:
return `resolve esm file ${job.path}${expectedToString(job.expected)}`;

case 6:
return `directory ${job.path}`;

case 7:
return `file ${job.path}`;

case 8:
return `directory dependencies ${job.path}`;

case 9:
return `file dependencies ${job.path}`;
}
return `unknown ${job.type} ${job.path}`;
}, pathToString = job => {
let result = ` at ${jobToString(job)}`;
for (job = job.issuer; void 0 !== job; ) result += `\n at ${jobToString(job)}`, 
job = job.issuer;
return result;
};
processAsyncTree(Array.from(deps, (dep => ({
type: 0,
context,
path: dep,
expected: void 0,
issuer: void 0
}))), 20, ((job, push, callback) => {
const {type, context, path, expected} = job, resolveDirectory = path => {
const key = `d\n${context}\n${path}`;
if (resolveResults.has(key)) return callback();
resolveResults.set(key, void 0), resolveContext(context, path, resolverContext, ((err, _, result) => {
if (err) return !1 === expected ? (resolveResults.set(key, !1), callback()) : (invalidResolveResults.add(key), 
err.message += `\nwhile resolving '${path}' in ${context} to a directory`, callback(err));
const resultPath = result.path;
resolveResults.set(key, resultPath), push({
type: 6,
context: void 0,
path: resultPath,
expected: void 0,
issuer: job
}), callback();
}));
}, resolveFile = (path, symbol, resolve) => {
const key = `${symbol}\n${context}\n${path}`;
if (resolveResults.has(key)) return callback();
resolveResults.set(key, void 0), resolve(context, path, resolverContext, ((err, _, result) => {
if ("string" == typeof expected) !err && result && result.path === expected ? resolveResults.set(key, result.path) : (invalidResolveResults.add(key), 
this.logger.warn(`Resolving '${path}' in ${context} for build dependencies doesn't lead to expected result '${expected}', but to '${err || result && result.path}' instead. Resolving dependencies are ignored for this path.\n${pathToString(job)}`)); else {
if (err) return !1 === expected ? (resolveResults.set(key, !1), callback()) : (invalidResolveResults.add(key), 
err.message += `\nwhile resolving '${path}' in ${context} as file\n${pathToString(job)}`, 
callback(err));
const resultPath = result.path;
resolveResults.set(key, resultPath), push({
type: 7,
context: void 0,
path: resultPath,
expected: void 0,
issuer: job
});
}
callback();
}));
};
switch (type) {
case 0:
/[\\/]$/.test(path) ? resolveDirectory(path.slice(0, path.length - 1)) : resolveFile(path, "f", resolveCjs);
break;

case 1:
/[\\/]$/.test(path) ? resolveDirectory(path.slice(0, path.length - 1)) : resolveFile(path);
break;

case 2:
resolveDirectory(path);
break;

case 3:
resolveFile(path, "f", resolveCjs);
break;

case 4:
resolveFile(path, "c", resolveCjsAsChild);
break;

case 5:
resolveFile(path, "e", resolveEsm);
break;

case 7:
if (files.has(path)) {
callback();
break;
}
files.add(path), this.fs.realpath(path, ((err, _realPath) => {
if (err) return callback(err);
const realPath = _realPath;
if (realPath !== path) {
if (fileSymlinks.add(path), resolveFiles.add(path), files.has(realPath)) return callback();
files.add(realPath);
}
push({
type: 9,
context: void 0,
path: realPath,
expected: void 0,
issuer: job
}), callback();
}));
break;

case 6:
if (directories.has(path)) {
callback();
break;
}
directories.add(path), this.fs.realpath(path, ((err, _realPath) => {
if (err) return callback(err);
const realPath = _realPath;
if (realPath !== path) {
if (directorySymlinks.add(path), resolveFiles.add(path), directories.has(realPath)) return callback();
directories.add(realPath);
}
push({
type: 8,
context: void 0,
path: realPath,
expected: void 0,
issuer: job
}), callback();
}));
break;

case 9:
{
if (/\.json5?$|\.yarn-integrity$|yarn\.lock$|\.ya?ml/.test(path)) {
process.nextTick(callback);
break;
}
const module = __webpack_require__.c[path];
if (module && Array.isArray(module.children)) children: for (const child of module.children) {
let childPath = child.filename;
if (childPath) {
push({
type: 7,
context: void 0,
path: childPath,
expected: void 0,
issuer: job
});
const context = dirname(this.fs, path);
for (const modulePath of module.paths) if (childPath.startsWith(modulePath)) {
let subPath = childPath.slice(modulePath.length + 1);
const packageMatch = /^(@[^\\/]+[\\/])[^\\/]+/.exec(subPath);
packageMatch && push({
type: 7,
context: void 0,
path: modulePath + childPath[modulePath.length] + packageMatch[0] + childPath[modulePath.length] + "package.json",
expected: !1,
issuer: job
});
let request = subPath.replace(/\\/g, "/");
request.endsWith(".js") && (request = request.slice(0, -3)), push({
type: 4,
context,
path: request,
expected: child.filename,
issuer: job
});
continue children;
}
let request = relative(this.fs, context, childPath);
request.endsWith(".js") && (request = request.slice(0, -3)), request = request.replace(/\\/g, "/"), 
request.startsWith("../") || isAbsolute(request) || (request = `./${request}`), 
push({
type: 3,
context,
path: request,
expected: child.filename,
issuer: job
});
}
} else {
if (supportsEsm && /\.m?js$/.test(path)) {
this._warnAboutExperimentalEsmTracking || (this.logger.log("Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\nUntil a full solution is available webpack uses an experimental ESM tracking based on parsing.\nAs best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking."), 
this._warnAboutExperimentalEsmTracking = !0);
const lexer = __webpack_require__(44813);
lexer.init.then((() => {
this.fs.readFile(path, ((err, content) => {
if (err) return callback(err);
try {
const context = dirname(this.fs, path), source = content.toString(), [imports] = lexer.parse(source);
for (const imp of imports) try {
let dependency;
if (-1 === imp.d) dependency = parseString(source.substring(imp.s - 1, imp.e + 1)); else {
if (!(imp.d > -1)) continue;
{
let expr = source.substring(imp.s, imp.e).trim();
dependency = parseString(expr);
}
}
if (dependency.startsWith("node:")) continue;
if (builtinModules.has(dependency)) continue;
push({
type: 5,
context,
path: dependency,
expected: void 0,
issuer: job
});
} catch (e) {
this.logger.warn(`Parsing of ${path} for build dependencies failed at 'import(${source.substring(imp.s, imp.e)})'.\nBuild dependencies behind this expression are ignored and might cause incorrect cache invalidation.`), 
this.logger.debug(pathToString(job)), this.logger.debug(e.stack);
}
} catch (e) {
this.logger.warn(`Parsing of ${path} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`), 
this.logger.debug(pathToString(job)), this.logger.debug(e.stack);
}
process.nextTick(callback);
}));
}), callback);
break;
}
this.logger.log(`Assuming ${path} has no dependencies as we were unable to assign it to any module system.`), 
this.logger.debug(pathToString(job));
}
process.nextTick(callback);
break;
}

case 8:
{
const match = /(^.+[\\/]node_modules[\\/](?:@[^\\/]+[\\/])?[^\\/]+)/.exec(path), packagePath = match ? match[1] : path, packageJson = join(this.fs, packagePath, "package.json");
this.fs.readFile(packageJson, ((err, content) => {
if (err) {
if ("ENOENT" === err.code) {
resolveMissing.add(packageJson);
const parent = dirname(this.fs, packagePath);
return parent !== packagePath && push({
type: 8,
context: void 0,
path: parent,
expected: void 0,
issuer: job
}), void callback();
}
return callback(err);
}
let packageData;
resolveFiles.add(packageJson);
try {
packageData = JSON.parse(content.toString("utf-8"));
} catch (e) {
return callback(e);
}
const depsObject = packageData.dependencies, optionalDepsObject = packageData.optionalDependencies, allDeps = new Set, optionalDeps = new Set;
if ("object" == typeof depsObject && depsObject) for (const dep of Object.keys(depsObject)) allDeps.add(dep);
if ("object" == typeof optionalDepsObject && optionalDepsObject) for (const dep of Object.keys(optionalDepsObject)) allDeps.add(dep), 
optionalDeps.add(dep);
for (const dep of allDeps) push({
type: 2,
context: packagePath,
path: dep,
expected: !optionalDeps.has(dep),
issuer: job
});
callback();
}));
break;
}
}
}), (err => {
if (err) return callback(err);
for (const l of fileSymlinks) files.delete(l);
for (const l of directorySymlinks) directories.delete(l);
for (const k of invalidResolveResults) resolveResults.delete(k);
callback(null, {
files,
directories,
missing,
resolveResults,
resolveDependencies: {
files: resolveFiles,
directories: resolveDirectories,
missing: resolveMissing
}
});
}));
}
checkResolveResultsValid(resolveResults, callback) {
const {resolveCjs, resolveCjsAsChild, resolveEsm, resolveContext} = this._createBuildDependenciesResolvers();
asyncLib.eachLimit(resolveResults, 20, (([key, expectedResult], callback) => {
const [type, context, path] = key.split("\n");
switch (type) {
case "d":
resolveContext(context, path, {}, ((err, _, result) => {
if (!1 === expectedResult) return callback(err ? void 0 : INVALID);
if (err) return callback(err);
if (result.path !== expectedResult) return callback(INVALID);
callback();
}));
break;

case "f":
resolveCjs(context, path, {}, ((err, _, result) => {
if (!1 === expectedResult) return callback(err ? void 0 : INVALID);
if (err) return callback(err);
if (result.path !== expectedResult) return callback(INVALID);
callback();
}));
break;

case "c":
resolveCjsAsChild(context, path, {}, ((err, _, result) => {
if (!1 === expectedResult) return callback(err ? void 0 : INVALID);
if (err) return callback(err);
if (result.path !== expectedResult) return callback(INVALID);
callback();
}));
break;

case "e":
resolveEsm(context, path, {}, ((err, _, result) => {
if (!1 === expectedResult) return callback(err ? void 0 : INVALID);
if (err) return callback(err);
if (result.path !== expectedResult) return callback(INVALID);
callback();
}));
break;

default:
callback(new Error("Unexpected type in resolve result key"));
}
}), (err => err === INVALID ? callback(null, !1) : err ? callback(err) : callback(null, !0)));
}
createSnapshot(startTime, files, directories, missing, options, callback) {
const fileTimestamps = new Map, fileHashes = new Map, fileTshs = new Map, contextTimestamps = new Map, contextHashes = new Map, contextTshs = new Map, missingExistence = new Map, managedItemInfo = new Map, managedFiles = new Set, managedContexts = new Set, managedMissing = new Set, children = new Set, snapshot = new Snapshot;
startTime && snapshot.setStartTime(startTime);
const managedItems = new Set, mode = options && options.hash ? options.timestamp ? 3 : 2 : 1;
let jobs = 1;
const jobDone = () => {
0 == --jobs && (0 !== fileTimestamps.size && snapshot.setFileTimestamps(fileTimestamps), 
0 !== fileHashes.size && snapshot.setFileHashes(fileHashes), 0 !== fileTshs.size && snapshot.setFileTshs(fileTshs), 
0 !== contextTimestamps.size && snapshot.setContextTimestamps(contextTimestamps), 
0 !== contextHashes.size && snapshot.setContextHashes(contextHashes), 0 !== contextTshs.size && snapshot.setContextTshs(contextTshs), 
0 !== missingExistence.size && snapshot.setMissingExistence(missingExistence), 0 !== managedItemInfo.size && snapshot.setManagedItemInfo(managedItemInfo), 
this._managedFilesOptimization.optimize(snapshot, managedFiles), 0 !== managedFiles.size && snapshot.setManagedFiles(managedFiles), 
this._managedContextsOptimization.optimize(snapshot, managedContexts), 0 !== managedContexts.size && snapshot.setManagedContexts(managedContexts), 
this._managedMissingOptimization.optimize(snapshot, managedMissing), 0 !== managedMissing.size && snapshot.setManagedMissing(managedMissing), 
0 !== children.size && snapshot.setChildren(children), this._snapshotCache.set(snapshot, !0), 
this._statCreatedSnapshots++, callback(null, snapshot));
}, jobError = () => {
jobs > 0 && (jobs = -1e8, callback(null, null));
}, checkManaged = (path, managedSet) => {
for (const immutablePath of this.immutablePathsRegExps) if (immutablePath.test(path)) return managedSet.add(path), 
!0;
for (const immutablePath of this.immutablePathsWithSlash) if (path.startsWith(immutablePath)) return managedSet.add(path), 
!0;
for (const managedPath of this.managedPathsRegExps) {
const match = managedPath.exec(path);
if (match) {
const managedItem = getManagedItem(match[1], path);
if (managedItem) return managedItems.add(managedItem), managedSet.add(path), !0;
}
}
for (const managedPath of this.managedPathsWithSlash) if (path.startsWith(managedPath)) {
const managedItem = getManagedItem(managedPath, path);
if (managedItem) return managedItems.add(managedItem), managedSet.add(path), !0;
}
return !1;
}, captureNonManaged = (items, managedSet) => {
const capturedItems = new Set;
for (const path of items) checkManaged(path, managedSet) || capturedItems.add(path);
return capturedItems;
}, processCapturedFiles = capturedFiles => {
switch (mode) {
case 3:
this._fileTshsOptimization.optimize(snapshot, capturedFiles);
for (const path of capturedFiles) {
const cache = this._fileTshs.get(path);
void 0 !== cache ? fileTshs.set(path, cache) : (jobs++, this._getFileTimestampAndHash(path, ((err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting file timestamp hash combination of ${path}: ${err.stack}`), 
jobError()) : (fileTshs.set(path, entry), jobDone());
})));
}
break;

case 2:
this._fileHashesOptimization.optimize(snapshot, capturedFiles);
for (const path of capturedFiles) {
const cache = this._fileHashes.get(path);
void 0 !== cache ? fileHashes.set(path, cache) : (jobs++, this.fileHashQueue.add(path, ((err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting file hash of ${path}: ${err.stack}`), 
jobError()) : (fileHashes.set(path, entry), jobDone());
})));
}
break;

case 1:
this._fileTimestampsOptimization.optimize(snapshot, capturedFiles);
for (const path of capturedFiles) {
const cache = this._fileTimestamps.get(path);
void 0 !== cache ? "ignore" !== cache && fileTimestamps.set(path, cache) : (jobs++, 
this.fileTimestampQueue.add(path, ((err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting file timestamp of ${path}: ${err.stack}`), 
jobError()) : (fileTimestamps.set(path, entry), jobDone());
})));
}
}
};
files && processCapturedFiles(captureNonManaged(files, managedFiles));
const processCapturedDirectories = capturedDirectories => {
switch (mode) {
case 3:
this._contextTshsOptimization.optimize(snapshot, capturedDirectories);
for (const path of capturedDirectories) {
const cache = this._contextTshs.get(path);
let resolved;
if (void 0 !== cache && void 0 !== (resolved = getResolvedTimestamp(cache))) contextTshs.set(path, resolved); else {
jobs++;
const callback = (err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting context timestamp hash combination of ${path}: ${err.stack}`), 
jobError()) : (contextTshs.set(path, entry), jobDone());
};
void 0 !== cache ? this._resolveContextTsh(cache, callback) : this.getContextTsh(path, callback);
}
}
break;

case 2:
this._contextHashesOptimization.optimize(snapshot, capturedDirectories);
for (const path of capturedDirectories) {
const cache = this._contextHashes.get(path);
let resolved;
if (void 0 !== cache && void 0 !== (resolved = getResolvedHash(cache))) contextHashes.set(path, resolved); else {
jobs++;
const callback = (err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting context hash of ${path}: ${err.stack}`), 
jobError()) : (contextHashes.set(path, entry), jobDone());
};
void 0 !== cache ? this._resolveContextHash(cache, callback) : this.getContextHash(path, callback);
}
}
break;

case 1:
this._contextTimestampsOptimization.optimize(snapshot, capturedDirectories);
for (const path of capturedDirectories) {
const cache = this._contextTimestamps.get(path);
if ("ignore" === cache) continue;
let resolved;
if (void 0 !== cache && void 0 !== (resolved = getResolvedTimestamp(cache))) contextTimestamps.set(path, resolved); else {
jobs++;
const callback = (err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting context timestamp of ${path}: ${err.stack}`), 
jobError()) : (contextTimestamps.set(path, entry), jobDone());
};
void 0 !== cache ? this._resolveContextTimestamp(cache, callback) : this.getContextTimestamp(path, callback);
}
}
}
};
directories && processCapturedDirectories(captureNonManaged(directories, managedContexts));
const processCapturedMissing = capturedMissing => {
this._missingExistenceOptimization.optimize(snapshot, capturedMissing);
for (const path of capturedMissing) {
const cache = this._fileTimestamps.get(path);
void 0 !== cache ? "ignore" !== cache && missingExistence.set(path, Boolean(cache)) : (jobs++, 
this.fileTimestampQueue.add(path, ((err, entry) => {
err ? (this.logger && this.logger.debug(`Error snapshotting missing timestamp of ${path}: ${err.stack}`), 
jobError()) : (missingExistence.set(path, Boolean(entry)), jobDone());
})));
}
};
missing && processCapturedMissing(captureNonManaged(missing, managedMissing)), this._managedItemInfoOptimization.optimize(snapshot, managedItems);
for (const path of managedItems) {
const cache = this._managedItems.get(path);
void 0 !== cache ? (cache.startsWith("*") ? "*nested" === cache && managedMissing.add(join(this.fs, path, "package.json")) : managedFiles.add(join(this.fs, path, "package.json")), 
managedItemInfo.set(path, cache)) : (jobs++, this.managedItemQueue.add(path, ((err, entry) => {
if (err) this.logger && this.logger.debug(`Error snapshotting managed item ${path}: ${err.stack}`), 
jobError(); else if (entry) entry.startsWith("*") ? "*nested" === cache && managedMissing.add(join(this.fs, path, "package.json")) : managedFiles.add(join(this.fs, path, "package.json")), 
managedItemInfo.set(path, entry), jobDone(); else {
const process = (set, fn) => {
if (0 === set.size) return;
const captured = new Set;
for (const file of set) file.startsWith(path) && captured.add(file);
captured.size > 0 && fn(captured);
};
process(managedFiles, processCapturedFiles), process(managedContexts, processCapturedDirectories), 
process(managedMissing, processCapturedMissing), jobDone();
}
})));
}
jobDone();
}
mergeSnapshots(snapshot1, snapshot2) {
const snapshot = new Snapshot;
return snapshot1.hasStartTime() && snapshot2.hasStartTime() ? snapshot.setStartTime(Math.min(snapshot1.startTime, snapshot2.startTime)) : snapshot2.hasStartTime() ? snapshot.startTime = snapshot2.startTime : snapshot1.hasStartTime() && (snapshot.startTime = snapshot1.startTime), 
(snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) && snapshot.setFileTimestamps(mergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps)), 
(snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) && snapshot.setFileHashes(mergeMaps(snapshot1.fileHashes, snapshot2.fileHashes)), 
(snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) && snapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs)), 
(snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) && snapshot.setContextTimestamps(mergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps)), 
(snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) && snapshot.setContextHashes(mergeMaps(snapshot1.contextHashes, snapshot2.contextHashes)), 
(snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) && snapshot.setContextTshs(mergeMaps(snapshot1.contextTshs, snapshot2.contextTshs)), 
(snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) && snapshot.setMissingExistence(mergeMaps(snapshot1.missingExistence, snapshot2.missingExistence)), 
(snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) && snapshot.setManagedItemInfo(mergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo)), 
(snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) && snapshot.setManagedFiles(mergeSets(snapshot1.managedFiles, snapshot2.managedFiles)), 
(snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) && snapshot.setManagedContexts(mergeSets(snapshot1.managedContexts, snapshot2.managedContexts)), 
(snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) && snapshot.setManagedMissing(mergeSets(snapshot1.managedMissing, snapshot2.managedMissing)), 
(snapshot1.hasChildren() || snapshot2.hasChildren()) && snapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children)), 
!0 === this._snapshotCache.get(snapshot1) && !0 === this._snapshotCache.get(snapshot2) && this._snapshotCache.set(snapshot, !0), 
snapshot;
}
checkSnapshotValid(snapshot, callback) {
const cachedResult = this._snapshotCache.get(snapshot);
if (void 0 !== cachedResult) return this._statTestedSnapshotsCached++, void ("boolean" == typeof cachedResult ? callback(null, cachedResult) : cachedResult.push(callback));
this._statTestedSnapshotsNotCached++, this._checkSnapshotValidNoCache(snapshot, callback);
}
_checkSnapshotValidNoCache(snapshot, callback) {
let startTime;
snapshot.hasStartTime() && (startTime = snapshot.startTime);
let jobs = 1;
const jobDone = () => {
0 == --jobs && (this._snapshotCache.set(snapshot, !0), callback(null, !0));
}, invalid = () => {
jobs > 0 && (jobs = -1e8, this._snapshotCache.set(snapshot, !1), callback(null, !1));
}, invalidWithError = (path, err) => {
this._remainingLogs > 0 && this._log(path, "error occurred: %s", err), invalid();
}, checkHash = (path, current, snap) => current === snap || (this._remainingLogs > 0 && this._log(path, "hashes differ (%s != %s)", current, snap), 
!1), checkExistence = (path, current, snap) => !current == !snap || (this._remainingLogs > 0 && this._log(path, current ? "it didn't exist before" : "it does no longer exist"), 
!1), checkFile = (path, current, snap, log = !0) => {
if (current === snap) return !0;
if (!checkExistence(path, Boolean(current), Boolean(snap))) return !1;
if (current) {
if ("number" == typeof startTime && current.safeTime > startTime) return log && this._remainingLogs > 0 && this._log(path, "it may have changed (%d) after the start time of the snapshot (%d)", current.safeTime, startTime), 
!1;
if (void 0 !== snap.timestamp && current.timestamp !== snap.timestamp) return log && this._remainingLogs > 0 && this._log(path, "timestamps differ (%d != %d)", current.timestamp, snap.timestamp), 
!1;
}
return !0;
}, checkContext = (path, current, snap, log = !0) => {
if (current === snap) return !0;
if (!checkExistence(path, Boolean(current), Boolean(snap))) return !1;
if (current) {
if ("number" == typeof startTime && current.safeTime > startTime) return log && this._remainingLogs > 0 && this._log(path, "it may have changed (%d) after the start time of the snapshot (%d)", current.safeTime, startTime), 
!1;
if (void 0 !== snap.timestampHash && current.timestampHash !== snap.timestampHash) return log && this._remainingLogs > 0 && this._log(path, "timestamps hashes differ (%s != %s)", current.timestampHash, snap.timestampHash), 
!1;
}
return !0;
};
if (snapshot.hasChildren()) {
const childCallback = (err, result) => {
if (err || !result) return invalid();
jobDone();
};
for (const child of snapshot.children) {
const cache = this._snapshotCache.get(child);
if (void 0 !== cache) if (this._statTestedChildrenCached++, "boolean" == typeof cache) {
if (!1 === cache) return void invalid();
} else jobs++, cache.push(childCallback); else this._statTestedChildrenNotCached++, 
jobs++, this._checkSnapshotValidNoCache(child, childCallback);
}
}
if (snapshot.hasFileTimestamps()) {
const {fileTimestamps} = snapshot;
this._statTestedEntries += fileTimestamps.size;
for (const [path, ts] of fileTimestamps) {
const cache = this._fileTimestamps.get(path);
if (void 0 !== cache) {
if ("ignore" !== cache && !checkFile(path, cache, ts)) return void invalid();
} else jobs++, this.fileTimestampQueue.add(path, ((err, entry) => {
if (err) return invalidWithError(path, err);
checkFile(path, entry, ts) ? jobDone() : invalid();
}));
}
}
const processFileHashSnapshot = (path, hash) => {
const cache = this._fileHashes.get(path);
if (void 0 !== cache) {
if ("ignore" !== cache && !checkHash(path, cache, hash)) return void invalid();
} else jobs++, this.fileHashQueue.add(path, ((err, entry) => {
if (err) return invalidWithError(path, err);
checkHash(path, entry, hash) ? jobDone() : invalid();
}));
};
if (snapshot.hasFileHashes()) {
const {fileHashes} = snapshot;
this._statTestedEntries += fileHashes.size;
for (const [path, hash] of fileHashes) processFileHashSnapshot(path, hash);
}
if (snapshot.hasFileTshs()) {
const {fileTshs} = snapshot;
this._statTestedEntries += fileTshs.size;
for (const [path, tsh] of fileTshs) if ("string" == typeof tsh) processFileHashSnapshot(path, tsh); else {
const cache = this._fileTimestamps.get(path);
void 0 !== cache ? "ignore" !== cache && checkFile(path, cache, tsh, !1) || processFileHashSnapshot(path, tsh && tsh.hash) : (jobs++, 
this.fileTimestampQueue.add(path, ((err, entry) => {
if (err) return invalidWithError(path, err);
checkFile(path, entry, tsh, !1) || processFileHashSnapshot(path, tsh && tsh.hash), 
jobDone();
})));
}
}
if (snapshot.hasContextTimestamps()) {
const {contextTimestamps} = snapshot;
this._statTestedEntries += contextTimestamps.size;
for (const [path, ts] of contextTimestamps) {
const cache = this._contextTimestamps.get(path);
if ("ignore" === cache) continue;
let resolved;
if (void 0 !== cache && void 0 !== (resolved = getResolvedTimestamp(cache))) {
if (!checkContext(path, resolved, ts)) return void invalid();
} else {
jobs++;
const callback = (err, entry) => {
if (err) return invalidWithError(path, err);
checkContext(path, entry, ts) ? jobDone() : invalid();
};
void 0 !== cache ? this._resolveContextTimestamp(cache, callback) : this.getContextTimestamp(path, callback);
}
}
}
const processContextHashSnapshot = (path, hash) => {
const cache = this._contextHashes.get(path);
let resolved;
if (void 0 !== cache && void 0 !== (resolved = getResolvedHash(cache))) {
if (!checkHash(path, resolved, hash)) return void invalid();
} else {
jobs++;
const callback = (err, entry) => {
if (err) return invalidWithError(path, err);
checkHash(path, entry, hash) ? jobDone() : invalid();
};
void 0 !== cache ? this._resolveContextHash(cache, callback) : this.getContextHash(path, callback);
}
};
if (snapshot.hasContextHashes()) {
const {contextHashes} = snapshot;
this._statTestedEntries += contextHashes.size;
for (const [path, hash] of contextHashes) processContextHashSnapshot(path, hash);
}
if (snapshot.hasContextTshs()) {
const {contextTshs} = snapshot;
this._statTestedEntries += contextTshs.size;
for (const [path, tsh] of contextTshs) if ("string" == typeof tsh) processContextHashSnapshot(path, tsh); else {
const cache = this._contextTimestamps.get(path);
if ("ignore" === cache) continue;
let resolved;
if (void 0 !== cache && void 0 !== (resolved = getResolvedTimestamp(cache))) checkContext(path, resolved, tsh, !1) || processContextHashSnapshot(path, tsh && tsh.hash); else {
jobs++;
const callback = (err, entry) => {
if (err) return invalidWithError(path, err);
checkContext(path, entry, tsh, !1) || processContextHashSnapshot(path, tsh && tsh.hash), 
jobDone();
};
void 0 !== cache ? this._resolveContextTimestamp(cache, callback) : this.getContextTimestamp(path, callback);
}
}
}
if (snapshot.hasMissingExistence()) {
const {missingExistence} = snapshot;
this._statTestedEntries += missingExistence.size;
for (const [path, existence] of missingExistence) {
const cache = this._fileTimestamps.get(path);
if (void 0 !== cache) {
if ("ignore" !== cache && !checkExistence(path, Boolean(cache), Boolean(existence))) return void invalid();
} else jobs++, this.fileTimestampQueue.add(path, ((err, entry) => {
if (err) return invalidWithError(path, err);
checkExistence(path, Boolean(entry), Boolean(existence)) ? jobDone() : invalid();
}));
}
}
if (snapshot.hasManagedItemInfo()) {
const {managedItemInfo} = snapshot;
this._statTestedEntries += managedItemInfo.size;
for (const [path, info] of managedItemInfo) {
const cache = this._managedItems.get(path);
if (void 0 !== cache) {
if (!checkHash(path, cache, info)) return void invalid();
} else jobs++, this.managedItemQueue.add(path, ((err, entry) => {
if (err) return invalidWithError(path, err);
checkHash(path, entry, info) ? jobDone() : invalid();
}));
}
}
if (jobDone(), jobs > 0) {
const callbacks = [ callback ];
callback = (err, result) => {
for (const callback of callbacks) callback(err, result);
}, this._snapshotCache.set(snapshot, callbacks);
}
}
_readFileTimestamp(path, callback) {
this.fs.stat(path, ((err, stat) => {
if (err) return "ENOENT" === err.code ? (this._fileTimestamps.set(path, null), this._cachedDeprecatedFileTimestamps = void 0, 
callback(null, null)) : callback(err);
let ts;
if (stat.isDirectory()) ts = {
safeTime: 0,
timestamp: void 0
}; else {
const mtime = +stat.mtime;
mtime && applyMtime(mtime), ts = {
safeTime: mtime ? mtime + FS_ACCURACY : 1 / 0,
timestamp: mtime
};
}
this._fileTimestamps.set(path, ts), this._cachedDeprecatedFileTimestamps = void 0, 
callback(null, ts);
}));
}
_readFileHash(path, callback) {
this.fs.readFile(path, ((err, content) => {
if (err) return "EISDIR" === err.code ? (this._fileHashes.set(path, "directory"), 
callback(null, "directory")) : "ENOENT" === err.code ? (this._fileHashes.set(path, null), 
callback(null, null)) : "ERR_FS_FILE_TOO_LARGE" === err.code ? (this.logger.warn(`Ignoring ${path} for hashing as it's very large`), 
this._fileHashes.set(path, "too large"), callback(null, "too large")) : callback(err);
const hash = createHash(this._hashFunction);
hash.update(content);
const digest = hash.digest("hex");
this._fileHashes.set(path, digest), callback(null, digest);
}));
}
_getFileTimestampAndHash(path, callback) {
const continueWithHash = hash => {
const cache = this._fileTimestamps.get(path);
if (void 0 !== cache) {
if ("ignore" !== cache) {
const result = {
...cache,
hash
};
return this._fileTshs.set(path, result), callback(null, result);
}
return this._fileTshs.set(path, hash), callback(null, hash);
}
this.fileTimestampQueue.add(path, ((err, entry) => {
if (err) return callback(err);
const result = {
...entry,
hash
};
return this._fileTshs.set(path, result), callback(null, result);
}));
}, cache = this._fileHashes.get(path);
void 0 !== cache ? continueWithHash(cache) : this.fileHashQueue.add(path, ((err, entry) => {
if (err) return callback(err);
continueWithHash(entry);
}));
}
_readContext({path, fromImmutablePath, fromManagedItem, fromSymlink, fromFile, fromDirectory, reduce}, callback) {
this.fs.readdir(path, ((err, _files) => {
if (err) return "ENOENT" === err.code ? callback(null, null) : callback(err);
const files = _files.map((file => file.normalize("NFC"))).filter((file => !/^\./.test(file))).sort();
asyncLib.map(files, ((file, callback) => {
const child = join(this.fs, path, file);
for (const immutablePath of this.immutablePathsRegExps) if (immutablePath.test(path)) return callback(null, fromImmutablePath(path));
for (const immutablePath of this.immutablePathsWithSlash) if (path.startsWith(immutablePath)) return callback(null, fromImmutablePath(path));
for (const managedPath of this.managedPathsRegExps) {
const match = managedPath.exec(path);
if (match) {
const managedItem = getManagedItem(match[1], path);
if (managedItem) return this.managedItemQueue.add(managedItem, ((err, info) => err ? callback(err) : callback(null, fromManagedItem(info))));
}
}
for (const managedPath of this.managedPathsWithSlash) if (path.startsWith(managedPath)) {
const managedItem = getManagedItem(managedPath, child);
if (managedItem) return this.managedItemQueue.add(managedItem, ((err, info) => err ? callback(err) : callback(null, fromManagedItem(info))));
}
lstatReadlinkAbsolute(this.fs, child, ((err, stat) => err ? callback(err) : "string" == typeof stat ? fromSymlink(child, stat, callback) : stat.isFile() ? fromFile(child, stat, callback) : stat.isDirectory() ? fromDirectory(child, stat, callback) : void callback(null, null)));
}), ((err, results) => {
if (err) return callback(err);
const result = reduce(files, results);
callback(null, result);
}));
}));
}
_readContextTimestamp(path, callback) {
this._readContext({
path,
fromImmutablePath: () => null,
fromManagedItem: info => ({
safeTime: 0,
timestampHash: info
}),
fromSymlink: (file, target, callback) => {
callback(null, {
timestampHash: target,
symlinks: new Set([ target ])
});
},
fromFile: (file, stat, callback) => {
const cache = this._fileTimestamps.get(file);
if (void 0 !== cache) return callback(null, "ignore" === cache ? null : cache);
const mtime = +stat.mtime;
mtime && applyMtime(mtime);
const ts = {
safeTime: mtime ? mtime + FS_ACCURACY : 1 / 0,
timestamp: mtime
};
this._fileTimestamps.set(file, ts), this._cachedDeprecatedFileTimestamps = void 0, 
callback(null, ts);
},
fromDirectory: (directory, stat, callback) => {
this.contextTimestampQueue.increaseParallelism(), this._getUnresolvedContextTimestamp(directory, ((err, tsEntry) => {
this.contextTimestampQueue.decreaseParallelism(), callback(err, tsEntry);
}));
},
reduce: (files, tsEntries) => {
let symlinks;
const hash = createHash(this._hashFunction);
for (const file of files) hash.update(file);
let safeTime = 0;
for (const entry of tsEntries) entry ? (entry.timestamp ? (hash.update("f"), hash.update(`${entry.timestamp}`)) : entry.timestampHash && (hash.update("d"), 
hash.update(`${entry.timestampHash}`)), void 0 !== entry.symlinks && (void 0 === symlinks && (symlinks = new Set), 
addAll(entry.symlinks, symlinks)), entry.safeTime && (safeTime = Math.max(safeTime, entry.safeTime))) : hash.update("n");
const result = {
safeTime,
timestampHash: hash.digest("hex")
};
return symlinks && (result.symlinks = symlinks), result;
}
}, ((err, result) => {
if (err) return callback(err);
this._contextTimestamps.set(path, result), this._cachedDeprecatedContextTimestamps = void 0, 
callback(null, result);
}));
}
_resolveContextTimestamp(entry, callback) {
const hashes = [];
let safeTime = 0;
processAsyncTree(entry.symlinks, 10, ((target, push, callback) => {
this._getUnresolvedContextTimestamp(target, ((err, entry) => {
if (err) return callback(err);
if (entry && "ignore" !== entry && (hashes.push(entry.timestampHash), entry.safeTime && (safeTime = Math.max(safeTime, entry.safeTime)), 
void 0 !== entry.symlinks)) for (const target of entry.symlinks) push(target);
callback();
}));
}), (err => {
if (err) return callback(err);
const hash = createHash(this._hashFunction);
hash.update(entry.timestampHash), entry.safeTime && (safeTime = Math.max(safeTime, entry.safeTime)), 
hashes.sort();
for (const h of hashes) hash.update(h);
callback(null, entry.resolved = {
safeTime,
timestampHash: hash.digest("hex")
});
}));
}
_readContextHash(path, callback) {
this._readContext({
path,
fromImmutablePath: () => "",
fromManagedItem: info => info || "",
fromSymlink: (file, target, callback) => {
callback(null, {
hash: target,
symlinks: new Set([ target ])
});
},
fromFile: (file, stat, callback) => this.getFileHash(file, ((err, hash) => {
callback(err, hash || "");
})),
fromDirectory: (directory, stat, callback) => {
this.contextHashQueue.increaseParallelism(), this._getUnresolvedContextHash(directory, ((err, hash) => {
this.contextHashQueue.decreaseParallelism(), callback(err, hash || "");
}));
},
reduce: (files, fileHashes) => {
let symlinks;
const hash = createHash(this._hashFunction);
for (const file of files) hash.update(file);
for (const entry of fileHashes) "string" == typeof entry ? hash.update(entry) : (hash.update(entry.hash), 
entry.symlinks && (void 0 === symlinks && (symlinks = new Set), addAll(entry.symlinks, symlinks)));
const result = {
hash: hash.digest("hex")
};
return symlinks && (result.symlinks = symlinks), result;
}
}, ((err, result) => err ? callback(err) : (this._contextHashes.set(path, result), 
callback(null, result))));
}
_resolveContextHash(entry, callback) {
const hashes = [];
processAsyncTree(entry.symlinks, 10, ((target, push, callback) => {
this._getUnresolvedContextHash(target, ((err, hash) => {
if (err) return callback(err);
if (hash && (hashes.push(hash.hash), void 0 !== hash.symlinks)) for (const target of hash.symlinks) push(target);
callback();
}));
}), (err => {
if (err) return callback(err);
const hash = createHash(this._hashFunction);
hash.update(entry.hash), hashes.sort();
for (const h of hashes) hash.update(h);
callback(null, entry.resolved = hash.digest("hex"));
}));
}
_readContextTimestampAndHash(path, callback) {
const finalize = (timestamp, hash) => {
const result = "ignore" === timestamp ? hash : {
...timestamp,
...hash
};
this._contextTshs.set(path, result), callback(null, result);
}, cachedHash = this._contextHashes.get(path), cachedTimestamp = this._contextTimestamps.get(path);
void 0 !== cachedHash ? void 0 !== cachedTimestamp ? finalize(cachedTimestamp, cachedHash) : this.contextTimestampQueue.add(path, ((err, entry) => {
if (err) return callback(err);
finalize(entry, cachedHash);
})) : void 0 !== cachedTimestamp ? this.contextHashQueue.add(path, ((err, entry) => {
if (err) return callback(err);
finalize(cachedTimestamp, entry);
})) : this._readContext({
path,
fromImmutablePath: () => null,
fromManagedItem: info => ({
safeTime: 0,
timestampHash: info,
hash: info || ""
}),
fromSymlink: (fle, target, callback) => {
callback(null, {
timestampHash: target,
hash: target,
symlinks: new Set([ target ])
});
},
fromFile: (file, stat, callback) => {
this._getFileTimestampAndHash(file, callback);
},
fromDirectory: (directory, stat, callback) => {
this.contextTshQueue.increaseParallelism(), this.contextTshQueue.add(directory, ((err, result) => {
this.contextTshQueue.decreaseParallelism(), callback(err, result);
}));
},
reduce: (files, results) => {
let symlinks;
const tsHash = createHash(this._hashFunction), hash = createHash(this._hashFunction);
for (const file of files) tsHash.update(file), hash.update(file);
let safeTime = 0;
for (const entry of results) entry ? "string" != typeof entry ? (entry.timestamp ? (tsHash.update("f"), 
tsHash.update(`${entry.timestamp}`)) : entry.timestampHash && (tsHash.update("d"), 
tsHash.update(`${entry.timestampHash}`)), void 0 !== entry.symlinks && (void 0 === symlinks && (symlinks = new Set), 
addAll(entry.symlinks, symlinks)), entry.safeTime && (safeTime = Math.max(safeTime, entry.safeTime)), 
hash.update(entry.hash)) : (tsHash.update("n"), hash.update(entry)) : tsHash.update("n");
const result = {
safeTime,
timestampHash: tsHash.digest("hex"),
hash: hash.digest("hex")
};
return symlinks && (result.symlinks = symlinks), result;
}
}, ((err, result) => err ? callback(err) : (this._contextTshs.set(path, result), 
callback(null, result))));
}
_resolveContextTsh(entry, callback) {
const hashes = [], tsHashes = [];
let safeTime = 0;
processAsyncTree(entry.symlinks, 10, ((target, push, callback) => {
this._getUnresolvedContextTsh(target, ((err, entry) => {
if (err) return callback(err);
if (entry && (hashes.push(entry.hash), entry.timestampHash && tsHashes.push(entry.timestampHash), 
entry.safeTime && (safeTime = Math.max(safeTime, entry.safeTime)), void 0 !== entry.symlinks)) for (const target of entry.symlinks) push(target);
callback();
}));
}), (err => {
if (err) return callback(err);
const hash = createHash(this._hashFunction), tsHash = createHash(this._hashFunction);
hash.update(entry.hash), entry.timestampHash && tsHash.update(entry.timestampHash), 
entry.safeTime && (safeTime = Math.max(safeTime, entry.safeTime)), hashes.sort();
for (const h of hashes) hash.update(h);
tsHashes.sort();
for (const h of tsHashes) tsHash.update(h);
callback(null, entry.resolved = {
safeTime,
timestampHash: tsHash.digest("hex"),
hash: hash.digest("hex")
});
}));
}
_getManagedItemDirectoryInfo(path, callback) {
this.fs.readdir(path, ((err, elements) => {
if (err) return "ENOENT" === err.code || "ENOTDIR" === err.code ? callback(null, EMPTY_SET) : callback(err);
const set = new Set(elements.map((element => join(this.fs, path, element))));
callback(null, set);
}));
}
_getManagedItemInfo(path, callback) {
const dir = dirname(this.fs, path);
this.managedItemDirectoryQueue.add(dir, ((err, elements) => {
if (err) return callback(err);
if (!elements.has(path)) return this._managedItems.set(path, "*missing"), callback(null, "*missing");
if (path.endsWith("node_modules") && (path.endsWith("/node_modules") || path.endsWith("\\node_modules"))) return this._managedItems.set(path, "*node_modules"), 
callback(null, "*node_modules");
const packageJsonPath = join(this.fs, path, "package.json");
this.fs.readFile(packageJsonPath, ((err, content) => {
if (err) return "ENOENT" === err.code || "ENOTDIR" === err.code ? void this.fs.readdir(path, ((err, elements) => err || 1 !== elements.length || "node_modules" !== elements[0] ? (this.logger.warn(`Managed item ${path} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`), 
callback()) : (this._managedItems.set(path, "*nested"), callback(null, "*nested")))) : callback(err);
let data;
try {
data = JSON.parse(content.toString("utf-8"));
} catch (e) {
return callback(e);
}
if (!data.name) return this.logger.warn(`${packageJsonPath} doesn't contain a "name" property (see snapshot.managedPaths option)`), 
callback();
const info = `${data.name || ""}@${data.version || ""}`;
this._managedItems.set(path, info), callback(null, info);
}));
}));
}
getDeprecatedFileTimestamps() {
if (void 0 !== this._cachedDeprecatedFileTimestamps) return this._cachedDeprecatedFileTimestamps;
const map = new Map;
for (const [path, info] of this._fileTimestamps) info && map.set(path, "object" == typeof info ? info.safeTime : null);
return this._cachedDeprecatedFileTimestamps = map;
}
getDeprecatedContextTimestamps() {
if (void 0 !== this._cachedDeprecatedContextTimestamps) return this._cachedDeprecatedContextTimestamps;
const map = new Map;
for (const [path, info] of this._contextTimestamps) info && map.set(path, "object" == typeof info ? info.safeTime : null);
return this._cachedDeprecatedContextTimestamps = map;
}
}, module.exports.Snapshot = Snapshot;
},
37899: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {getEntryRuntime, mergeRuntimeOwned} = __webpack_require__(14372);
module.exports = class {
constructor(explanation) {
this.explanation = explanation;
}
apply(compiler) {
compiler.hooks.compilation.tap("FlagAllModulesAsUsedPlugin", (compilation => {
const moduleGraph = compilation.moduleGraph;
compilation.hooks.optimizeDependencies.tap("FlagAllModulesAsUsedPlugin", (modules => {
let runtime;
for (const [name, {options}] of compilation.entries) runtime = mergeRuntimeOwned(runtime, getEntryRuntime(compilation, name, options));
for (const module of modules) {
moduleGraph.getExportsInfo(module).setUsedInUnknownWay(runtime), moduleGraph.addExtraReason(module, this.explanation), 
void 0 === module.factoryMeta && (module.factoryMeta = {}), module.factoryMeta.sideEffectFree = !1;
}
}));
}));
}
};
},
61456: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), Queue = __webpack_require__(77274);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("FlagDependencyExportsPlugin", (compilation => {
const moduleGraph = compilation.moduleGraph, cache = compilation.getCache("FlagDependencyExportsPlugin");
compilation.hooks.finishModules.tapAsync("FlagDependencyExportsPlugin", ((modules, callback) => {
const logger = compilation.getLogger("webpack.FlagDependencyExportsPlugin");
let statRestoredFromMemCache = 0, statRestoredFromCache = 0, statNoExports = 0, statFlaggedUncached = 0, statNotCached = 0, statQueueItemsProcessed = 0;
const {moduleMemCaches} = compilation, queue = new Queue;
logger.time("restore cached provided exports"), asyncLib.each(modules, ((module, callback) => {
const exportsInfo = moduleGraph.getExportsInfo(module);
if (!(module.buildMeta && module.buildMeta.exportsType || null === exportsInfo.otherExportsInfo.provided)) return statNoExports++, 
exportsInfo.setHasProvideInfo(), exportsInfo.setUnknownExportsProvided(), callback();
if ("string" != typeof module.buildInfo.hash) return statFlaggedUncached++, queue.enqueue(module), 
exportsInfo.setHasProvideInfo(), callback();
const memCache = moduleMemCaches && moduleMemCaches.get(module), memCacheValue = memCache && memCache.get(this);
if (void 0 !== memCacheValue) return statRestoredFromMemCache++, exportsInfo.restoreProvided(memCacheValue), 
callback();
cache.get(module.identifier(), module.buildInfo.hash, ((err, result) => {
if (err) return callback(err);
void 0 !== result ? (statRestoredFromCache++, exportsInfo.restoreProvided(result)) : (statNotCached++, 
queue.enqueue(module), exportsInfo.setHasProvideInfo()), callback();
}));
}), (err => {
if (logger.timeEnd("restore cached provided exports"), err) return callback(err);
const modulesToStore = new Set, dependencies = new Map;
let module, exportsInfo;
const exportsSpecsFromDependencies = new Map;
let cacheable = !0, changed = !1;
const processDependenciesBlock = depBlock => {
for (const dep of depBlock.dependencies) processDependency(dep);
for (const block of depBlock.blocks) processDependenciesBlock(block);
}, processDependency = dep => {
const exportDesc = dep.getExports(moduleGraph);
exportDesc && exportsSpecsFromDependencies.set(dep, exportDesc);
}, processExportsSpec = (dep, exportDesc) => {
const exports = exportDesc.exports, globalCanMangle = exportDesc.canMangle, globalFrom = exportDesc.from, globalPriority = exportDesc.priority, globalTerminalBinding = exportDesc.terminalBinding || !1, exportDeps = exportDesc.dependencies;
if (exportDesc.hideExports) for (const name of exportDesc.hideExports) {
exportsInfo.getExportInfo(name).unsetTarget(dep);
}
if (!0 === exports) exportsInfo.setUnknownExportsProvided(globalCanMangle, exportDesc.excludeExports, globalFrom && dep, globalFrom, globalPriority) && (changed = !0); else if (Array.isArray(exports)) {
const mergeExports = (exportsInfo, exports) => {
for (const exportNameOrSpec of exports) {
let name, exports, fromExport, canMangle = globalCanMangle, terminalBinding = globalTerminalBinding, from = globalFrom, priority = globalPriority, hidden = !1;
"string" == typeof exportNameOrSpec ? name = exportNameOrSpec : (name = exportNameOrSpec.name, 
void 0 !== exportNameOrSpec.canMangle && (canMangle = exportNameOrSpec.canMangle), 
void 0 !== exportNameOrSpec.export && (fromExport = exportNameOrSpec.export), void 0 !== exportNameOrSpec.exports && (exports = exportNameOrSpec.exports), 
void 0 !== exportNameOrSpec.from && (from = exportNameOrSpec.from), void 0 !== exportNameOrSpec.priority && (priority = exportNameOrSpec.priority), 
void 0 !== exportNameOrSpec.terminalBinding && (terminalBinding = exportNameOrSpec.terminalBinding), 
void 0 !== exportNameOrSpec.hidden && (hidden = exportNameOrSpec.hidden));
const exportInfo = exportsInfo.getExportInfo(name);
if (!1 !== exportInfo.provided && null !== exportInfo.provided || (exportInfo.provided = !0, 
changed = !0), !1 !== exportInfo.canMangleProvide && !1 === canMangle && (exportInfo.canMangleProvide = !1, 
changed = !0), terminalBinding && !exportInfo.terminalBinding && (exportInfo.terminalBinding = !0, 
changed = !0), exports) {
const nestedExportsInfo = exportInfo.createNestedExportsInfo();
mergeExports(nestedExportsInfo, exports);
}
from && (hidden ? exportInfo.unsetTarget(dep) : exportInfo.setTarget(dep, from, void 0 === fromExport ? [ name ] : fromExport, priority)) && (changed = !0);
const target = exportInfo.getTarget(moduleGraph);
let targetExportsInfo;
if (target) {
targetExportsInfo = moduleGraph.getExportsInfo(target.module).getNestedExportsInfo(target.export);
const set = dependencies.get(target.module);
void 0 === set ? dependencies.set(target.module, new Set([ module ])) : set.add(module);
}
exportInfo.exportsInfoOwned ? exportInfo.exportsInfo.setRedirectNamedTo(targetExportsInfo) && (changed = !0) : exportInfo.exportsInfo !== targetExportsInfo && (exportInfo.exportsInfo = targetExportsInfo, 
changed = !0);
}
};
mergeExports(exportsInfo, exports);
}
if (exportDeps) {
cacheable = !1;
for (const exportDependency of exportDeps) {
const set = dependencies.get(exportDependency);
void 0 === set ? dependencies.set(exportDependency, new Set([ module ])) : set.add(module);
}
}
}, notifyDependencies = () => {
const deps = dependencies.get(module);
if (void 0 !== deps) for (const dep of deps) queue.enqueue(dep);
};
for (logger.time("figure out provided exports"); queue.length > 0; ) {
module = queue.dequeue(), statQueueItemsProcessed++, exportsInfo = moduleGraph.getExportsInfo(module), 
cacheable = !0, changed = !1, exportsSpecsFromDependencies.clear(), moduleGraph.freeze(), 
processDependenciesBlock(module), moduleGraph.unfreeze();
for (const [dep, exportsSpec] of exportsSpecsFromDependencies) processExportsSpec(dep, exportsSpec);
cacheable && modulesToStore.add(module), changed && notifyDependencies();
}
logger.timeEnd("figure out provided exports"), logger.log(`${Math.round(100 * (statFlaggedUncached + statNotCached) / (statRestoredFromMemCache + statRestoredFromCache + statNotCached + statFlaggedUncached + statNoExports))}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${statQueueItemsProcessed - statNotCached - statFlaggedUncached} additional calculations due to dependencies)`), 
logger.time("store provided exports into cache"), asyncLib.each(modulesToStore, ((module, callback) => {
if ("string" != typeof module.buildInfo.hash) return callback();
const cachedData = moduleGraph.getExportsInfo(module).getRestoreProvidedData(), memCache = moduleMemCaches && moduleMemCaches.get(module);
memCache && memCache.set(this, cachedData), cache.store(module.identifier(), module.buildInfo.hash, cachedData, callback);
}), (err => {
logger.timeEnd("store provided exports into cache"), callback(err);
}));
}));
}));
const providedExportsCache = new WeakMap;
compilation.hooks.rebuildModule.tap("FlagDependencyExportsPlugin", (module => {
providedExportsCache.set(module, moduleGraph.getExportsInfo(module).getRestoreProvidedData());
})), compilation.hooks.finishRebuildingModule.tap("FlagDependencyExportsPlugin", (module => {
moduleGraph.getExportsInfo(module).restoreProvided(providedExportsCache.get(module));
}));
}));
}
};
},
34080: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), {UsageState} = __webpack_require__(74603), ModuleGraphConnection = __webpack_require__(63867), {STAGE_DEFAULT} = __webpack_require__(60933), ArrayQueue = __webpack_require__(3216), TupleQueue = __webpack_require__(74368), {getEntryRuntime, mergeRuntimeOwned} = __webpack_require__(14372), {NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED} = Dependency;
module.exports = class {
constructor(global) {
this.global = global;
}
apply(compiler) {
compiler.hooks.compilation.tap("FlagDependencyUsagePlugin", (compilation => {
const moduleGraph = compilation.moduleGraph;
compilation.hooks.optimizeDependencies.tap({
name: "FlagDependencyUsagePlugin",
stage: STAGE_DEFAULT
}, (modules => {
if (compilation.moduleMemCaches) throw new Error("optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect");
const logger = compilation.getLogger("webpack.FlagDependencyUsagePlugin"), exportInfoToModuleMap = new Map, queue = new TupleQueue, processReferencedModule = (module, usedExports, runtime, forceSideEffects) => {
const exportsInfo = moduleGraph.getExportsInfo(module);
if (usedExports.length > 0) {
if (!module.buildMeta || !module.buildMeta.exportsType) return void (exportsInfo.setUsedWithoutInfo(runtime) && queue.enqueue(module, runtime));
for (const usedExportInfo of usedExports) {
let usedExport, canMangle = !0;
if (Array.isArray(usedExportInfo) ? usedExport = usedExportInfo : (usedExport = usedExportInfo.name, 
canMangle = !1 !== usedExportInfo.canMangle), 0 === usedExport.length) exportsInfo.setUsedInUnknownWay(runtime) && queue.enqueue(module, runtime); else {
let currentExportsInfo = exportsInfo;
for (let i = 0; i < usedExport.length; i++) {
const exportInfo = currentExportsInfo.getExportInfo(usedExport[i]);
!1 === canMangle && (exportInfo.canMangleUse = !1);
if (!(i === usedExport.length - 1)) {
const nestedInfo = exportInfo.getNestedExportsInfo();
if (nestedInfo) {
if (exportInfo.setUsedConditionally((used => used === UsageState.Unused), UsageState.OnlyPropertiesUsed, runtime)) {
const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);
currentModule && queue.enqueue(currentModule, runtime);
}
currentExportsInfo = nestedInfo;
continue;
}
}
if (exportInfo.setUsedConditionally((v => v !== UsageState.Used), UsageState.Used, runtime)) {
const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);
currentModule && queue.enqueue(currentModule, runtime);
}
break;
}
}
}
} else {
if (!forceSideEffects && void 0 !== module.factoryMeta && module.factoryMeta.sideEffectFree) return;
exportsInfo.setUsedForSideEffectsOnly(runtime) && queue.enqueue(module, runtime);
}
}, processModule = (module, runtime, forceSideEffects) => {
const map = new Map, queue = new ArrayQueue;
for (queue.enqueue(module); ;) {
const block = queue.dequeue();
if (void 0 === block) break;
for (const b of block.blocks) !this.global && b.groupOptions && b.groupOptions.entryOptions ? processModule(b, b.groupOptions.entryOptions.runtime || void 0, !0) : queue.enqueue(b);
for (const dep of block.dependencies) {
const connection = moduleGraph.getConnection(dep);
if (!connection || !connection.module) continue;
const activeState = connection.getActiveState(runtime);
if (!1 === activeState) continue;
const {module} = connection;
if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {
processModule(module, runtime, !1);
continue;
}
const oldReferencedExports = map.get(module);
if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) continue;
const referencedExports = compilation.getDependencyReferencedExports(dep, runtime);
if (void 0 === oldReferencedExports || oldReferencedExports === NO_EXPORTS_REFERENCED || referencedExports === EXPORTS_OBJECT_REFERENCED) map.set(module, referencedExports); else {
if (void 0 !== oldReferencedExports && referencedExports === NO_EXPORTS_REFERENCED) continue;
{
let exportsMap;
if (Array.isArray(oldReferencedExports)) {
exportsMap = new Map;
for (const item of oldReferencedExports) Array.isArray(item) ? exportsMap.set(item.join("\n"), item) : exportsMap.set(item.name.join("\n"), item);
map.set(module, exportsMap);
} else exportsMap = oldReferencedExports;
for (const item of referencedExports) if (Array.isArray(item)) {
const key = item.join("\n");
void 0 === exportsMap.get(key) && exportsMap.set(key, item);
} else {
const key = item.name.join("\n"), oldItem = exportsMap.get(key);
void 0 === oldItem || Array.isArray(oldItem) ? exportsMap.set(key, item) : exportsMap.set(key, {
name: item.name,
canMangle: item.canMangle && oldItem.canMangle
});
}
}
}
}
}
for (const [module, referencedExports] of map) Array.isArray(referencedExports) ? processReferencedModule(module, referencedExports, runtime, forceSideEffects) : processReferencedModule(module, Array.from(referencedExports.values()), runtime, forceSideEffects);
};
logger.time("initialize exports usage");
for (const module of modules) {
const exportsInfo = moduleGraph.getExportsInfo(module);
exportInfoToModuleMap.set(exportsInfo, module), exportsInfo.setHasUseInfo();
}
logger.timeEnd("initialize exports usage"), logger.time("trace exports usage in graph");
const processEntryDependency = (dep, runtime) => {
const module = moduleGraph.getModule(dep);
module && processReferencedModule(module, NO_EXPORTS_REFERENCED, runtime, !0);
};
let globalRuntime;
for (const [entryName, {dependencies: deps, includeDependencies: includeDeps, options}] of compilation.entries) {
const runtime = this.global ? void 0 : getEntryRuntime(compilation, entryName, options);
for (const dep of deps) processEntryDependency(dep, runtime);
for (const dep of includeDeps) processEntryDependency(dep, runtime);
globalRuntime = mergeRuntimeOwned(globalRuntime, runtime);
}
for (const dep of compilation.globalEntry.dependencies) processEntryDependency(dep, globalRuntime);
for (const dep of compilation.globalEntry.includeDependencies) processEntryDependency(dep, globalRuntime);
for (;queue.length; ) {
const [module, runtime] = queue.dequeue();
processModule(module, runtime, !1);
}
logger.timeEnd("trace exports usage in graph");
}));
}));
}
};
},
70607: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
class Generator {
static byType(map) {
return new ByTypeGenerator(map);
}
getTypes(module) {
throw new (__webpack_require__(91266));
}
getSize(module, type) {
throw new (__webpack_require__(91266));
}
generate(module, {dependencyTemplates, runtimeTemplate, moduleGraph, type}) {
throw new (__webpack_require__(91266));
}
getConcatenationBailoutReason(module, context) {
return `Module Concatenation is not implemented for ${this.constructor.name}`;
}
updateHash(hash, {module, runtime}) {}
}
class ByTypeGenerator extends Generator {
constructor(map) {
super(), this.map = map, this._types = new Set(Object.keys(map));
}
getTypes(module) {
return this._types;
}
getSize(module, type) {
const t = type || "javascript", generator = this.map[t];
return generator ? generator.getSize(module, t) : 0;
}
generate(module, generateContext) {
const type = generateContext.type, generator = this.map[type];
if (!generator) throw new Error(`Generator.byType: no generator specified for ${type}`);
return generator.generate(module, generateContext);
}
}
module.exports = Generator;
},
19402: (__unused_webpack_module, exports) => {
"use strict";
exports.connectChunkGroupAndChunk = (chunkGroup, chunk) => {
chunkGroup.pushChunk(chunk) && chunk.addGroup(chunkGroup);
}, exports.connectChunkGroupParentAndChild = (parent, child) => {
parent.addChild(child) && child.addParent(parent);
};
},
7729: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(message) {
super(message), this.name = "HarmonyLinkingError", this.hideStack = !0;
}
};
},
44741: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
class HookWebpackError extends WebpackError {
constructor(error, hook) {
super(error.message), this.name = "HookWebpackError", this.hook = hook, this.error = error, 
this.hideStack = !0, this.details = `caused by plugins in ${hook}\n${error.stack}`, 
this.stack += `\n-- inner error --\n${error.stack}`;
}
}
module.exports = HookWebpackError;
module.exports.makeWebpackError = (error, hook) => error instanceof WebpackError ? error : new HookWebpackError(error, hook);
module.exports.makeWebpackErrorCallback = (callback, hook) => (err, result) => {
if (err) return err instanceof WebpackError ? void callback(err) : void callback(new HookWebpackError(err, hook));
callback(null, result);
};
module.exports.tryRunOrWebpackError = (fn, hook) => {
let r;
try {
r = fn();
} catch (err) {
if (err instanceof WebpackError) throw err;
throw new HookWebpackError(err, hook);
}
return r;
};
},
17049: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncBailHook} = __webpack_require__(89991), {RawSource} = __webpack_require__(37946), ChunkGraph = __webpack_require__(15888), Compilation = __webpack_require__(62843), HotUpdateChunk = __webpack_require__(6902), NormalModule = __webpack_require__(3213), RuntimeGlobals = __webpack_require__(50980), WebpackError = __webpack_require__(64326), ConstDependency = __webpack_require__(30339), ImportMetaHotAcceptDependency = __webpack_require__(35606), ImportMetaHotDeclineDependency = __webpack_require__(15234), ModuleHotAcceptDependency = __webpack_require__(50994), ModuleHotDeclineDependency = __webpack_require__(60219), HotModuleReplacementRuntimeModule = __webpack_require__(79963), JavascriptParser = __webpack_require__(36793), {evaluateToIdentifier} = __webpack_require__(78802), {find, isSubset} = __webpack_require__(73974), TupleSet = __webpack_require__(99235), {compareModulesById} = __webpack_require__(40028), {getRuntimeKey, keyToRuntime, forEachRuntime, mergeRuntimeOwned, subtractRuntime, intersectRuntime} = __webpack_require__(14372), parserHooksMap = new WeakMap;
class HotModuleReplacementPlugin {
static getParserHooks(parser) {
if (!(parser instanceof JavascriptParser)) throw new TypeError("The 'parser' argument must be an instance of JavascriptParser");
let hooks = parserHooksMap.get(parser);
return void 0 === hooks && (hooks = {
hotAcceptCallback: new SyncBailHook([ "expression", "requests" ]),
hotAcceptWithoutCallback: new SyncBailHook([ "expression", "requests" ])
}, parserHooksMap.set(parser, hooks)), hooks;
}
constructor(options) {
this.options = options || {};
}
apply(compiler) {
const {_backCompat: backCompat} = compiler;
void 0 === compiler.options.output.strictModuleErrorHandling && (compiler.options.output.strictModuleErrorHandling = !0);
const runtimeRequirements = [ RuntimeGlobals.module ], createAcceptHandler = (parser, ParamDependency) => {
const {hotAcceptCallback, hotAcceptWithoutCallback} = HotModuleReplacementPlugin.getParserHooks(parser);
return expr => {
const module = parser.state.module, dep = new ConstDependency(`${module.moduleArgument}.hot.accept`, expr.callee.range, runtimeRequirements);
if (dep.loc = expr.loc, module.addPresentationalDependency(dep), module.buildInfo.moduleConcatenationBailout = "Hot Module Replacement", 
expr.arguments.length >= 1) {
const arg = parser.evaluateExpression(expr.arguments[0]);
let params = [], requests = [];
if (arg.isString() ? params = [ arg ] : arg.isArray() && (params = arg.items.filter((param => param.isString()))), 
params.length > 0) {
if (params.forEach(((param, idx) => {
const request = param.string, dep = new ParamDependency(request, param.range);
dep.optional = !0, dep.loc = Object.create(expr.loc), dep.loc.index = idx, module.addDependency(dep), 
requests.push(request);
})), expr.arguments.length > 1) {
hotAcceptCallback.call(expr.arguments[1], requests);
for (let i = 1; i < expr.arguments.length; i++) parser.walkExpression(expr.arguments[i]);
return !0;
}
return hotAcceptWithoutCallback.call(expr, requests), !0;
}
}
return parser.walkExpressions(expr.arguments), !0;
};
}, createDeclineHandler = (parser, ParamDependency) => expr => {
const module = parser.state.module, dep = new ConstDependency(`${module.moduleArgument}.hot.decline`, expr.callee.range, runtimeRequirements);
if (dep.loc = expr.loc, module.addPresentationalDependency(dep), module.buildInfo.moduleConcatenationBailout = "Hot Module Replacement", 
1 === expr.arguments.length) {
const arg = parser.evaluateExpression(expr.arguments[0]);
let params = [];
arg.isString() ? params = [ arg ] : arg.isArray() && (params = arg.items.filter((param => param.isString()))), 
params.forEach(((param, idx) => {
const dep = new ParamDependency(param.string, param.range);
dep.optional = !0, dep.loc = Object.create(expr.loc), dep.loc.index = idx, module.addDependency(dep);
}));
}
return !0;
}, createHMRExpressionHandler = parser => expr => {
const module = parser.state.module, dep = new ConstDependency(`${module.moduleArgument}.hot`, expr.range, runtimeRequirements);
return dep.loc = expr.loc, module.addPresentationalDependency(dep), module.buildInfo.moduleConcatenationBailout = "Hot Module Replacement", 
!0;
}, applyModuleHot = parser => {
parser.hooks.evaluateIdentifier.for("module.hot").tap({
name: "HotModuleReplacementPlugin",
before: "NodeStuffPlugin"
}, (expr => evaluateToIdentifier("module.hot", "module", (() => [ "hot" ]), !0)(expr))), 
parser.hooks.call.for("module.hot.accept").tap("HotModuleReplacementPlugin", createAcceptHandler(parser, ModuleHotAcceptDependency)), 
parser.hooks.call.for("module.hot.decline").tap("HotModuleReplacementPlugin", createDeclineHandler(parser, ModuleHotDeclineDependency)), 
parser.hooks.expression.for("module.hot").tap("HotModuleReplacementPlugin", createHMRExpressionHandler(parser));
}, applyImportMetaHot = parser => {
parser.hooks.evaluateIdentifier.for("import.meta.webpackHot").tap("HotModuleReplacementPlugin", (expr => evaluateToIdentifier("import.meta.webpackHot", "import.meta", (() => [ "webpackHot" ]), !0)(expr))), 
parser.hooks.call.for("import.meta.webpackHot.accept").tap("HotModuleReplacementPlugin", createAcceptHandler(parser, ImportMetaHotAcceptDependency)), 
parser.hooks.call.for("import.meta.webpackHot.decline").tap("HotModuleReplacementPlugin", createDeclineHandler(parser, ImportMetaHotDeclineDependency)), 
parser.hooks.expression.for("import.meta.webpackHot").tap("HotModuleReplacementPlugin", createHMRExpressionHandler(parser));
};
compiler.hooks.compilation.tap("HotModuleReplacementPlugin", ((compilation, {normalModuleFactory}) => {
if (compilation.compiler !== compiler) return;
compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template), 
compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template), 
compilation.dependencyFactories.set(ImportMetaHotAcceptDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(ImportMetaHotAcceptDependency, new ImportMetaHotAcceptDependency.Template), 
compilation.dependencyFactories.set(ImportMetaHotDeclineDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(ImportMetaHotDeclineDependency, new ImportMetaHotDeclineDependency.Template);
let hotIndex = 0;
const fullHashChunkModuleHashes = {}, chunkModuleHashes = {};
compilation.hooks.record.tap("HotModuleReplacementPlugin", ((compilation, records) => {
if (records.hash === compilation.hash) return;
const chunkGraph = compilation.chunkGraph;
records.hash = compilation.hash, records.hotIndex = hotIndex, records.fullHashChunkModuleHashes = fullHashChunkModuleHashes, 
records.chunkModuleHashes = chunkModuleHashes, records.chunkHashes = {}, records.chunkRuntime = {};
for (const chunk of compilation.chunks) records.chunkHashes[chunk.id] = chunk.hash, 
records.chunkRuntime[chunk.id] = getRuntimeKey(chunk.runtime);
records.chunkModuleIds = {};
for (const chunk of compilation.chunks) records.chunkModuleIds[chunk.id] = Array.from(chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesById(chunkGraph)), (m => chunkGraph.getModuleId(m)));
}));
const updatedModules = new TupleSet, fullHashModules = new TupleSet, nonCodeGeneratedModules = new TupleSet;
compilation.hooks.fullHash.tap("HotModuleReplacementPlugin", (hash => {
const chunkGraph = compilation.chunkGraph, records = compilation.records;
for (const chunk of compilation.chunks) {
const getModuleHash = module => compilation.codeGenerationResults.has(module, chunk.runtime) ? compilation.codeGenerationResults.getHash(module, chunk.runtime) : (nonCodeGeneratedModules.add(module, chunk.runtime), 
chunkGraph.getModuleHash(module, chunk.runtime)), fullHashModulesInThisChunk = chunkGraph.getChunkFullHashModulesSet(chunk);
if (void 0 !== fullHashModulesInThisChunk) for (const module of fullHashModulesInThisChunk) fullHashModules.add(module, chunk);
const modules = chunkGraph.getChunkModulesIterable(chunk);
if (void 0 !== modules) if (records.chunkModuleHashes) if (void 0 !== fullHashModulesInThisChunk) for (const module of modules) {
const key = `${chunk.id}|${module.identifier()}`, hash = getModuleHash(module);
fullHashModulesInThisChunk.has(module) ? (records.fullHashChunkModuleHashes[key] !== hash && updatedModules.add(module, chunk), 
fullHashChunkModuleHashes[key] = hash) : (records.chunkModuleHashes[key] !== hash && updatedModules.add(module, chunk), 
chunkModuleHashes[key] = hash);
} else for (const module of modules) {
const key = `${chunk.id}|${module.identifier()}`, hash = getModuleHash(module);
records.chunkModuleHashes[key] !== hash && updatedModules.add(module, chunk), chunkModuleHashes[key] = hash;
} else if (void 0 !== fullHashModulesInThisChunk) for (const module of modules) {
const key = `${chunk.id}|${module.identifier()}`, hash = getModuleHash(module);
fullHashModulesInThisChunk.has(module) ? fullHashChunkModuleHashes[key] = hash : chunkModuleHashes[key] = hash;
} else for (const module of modules) {
const key = `${chunk.id}|${module.identifier()}`, hash = getModuleHash(module);
chunkModuleHashes[key] = hash;
}
}
hotIndex = records.hotIndex || 0, updatedModules.size > 0 && hotIndex++, hash.update(`${hotIndex}`);
})), compilation.hooks.processAssets.tap({
name: "HotModuleReplacementPlugin",
stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL
}, (() => {
const chunkGraph = compilation.chunkGraph, records = compilation.records;
if (records.hash === compilation.hash) return;
if (!records.chunkModuleHashes || !records.chunkHashes || !records.chunkModuleIds) return;
for (const [module, chunk] of fullHashModules) {
const key = `${chunk.id}|${module.identifier()}`, hash = nonCodeGeneratedModules.has(module, chunk.runtime) ? chunkGraph.getModuleHash(module, chunk.runtime) : compilation.codeGenerationResults.getHash(module, chunk.runtime);
records.chunkModuleHashes[key] !== hash && updatedModules.add(module, chunk), chunkModuleHashes[key] = hash;
}
const hotUpdateMainContentByRuntime = new Map;
let allOldRuntime;
for (const key of Object.keys(records.chunkRuntime)) {
const runtime = keyToRuntime(records.chunkRuntime[key]);
allOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);
}
if (forEachRuntime(allOldRuntime, (runtime => {
const {path: filename, info: assetInfo} = compilation.getPathWithInfo(compilation.outputOptions.hotUpdateMainFilename, {
hash: records.hash,
runtime
});
hotUpdateMainContentByRuntime.set(runtime, {
updatedChunkIds: new Set,
removedChunkIds: new Set,
removedModules: new Set,
filename,
assetInfo
});
})), 0 === hotUpdateMainContentByRuntime.size) return;
const allModules = new Map;
for (const module of compilation.modules) {
const id = chunkGraph.getModuleId(module);
allModules.set(id, module);
}
const completelyRemovedModules = new Set;
for (const key of Object.keys(records.chunkHashes)) {
const oldRuntime = keyToRuntime(records.chunkRuntime[key]), remainingModules = [];
for (const id of records.chunkModuleIds[key]) {
const module = allModules.get(id);
void 0 === module ? completelyRemovedModules.add(id) : remainingModules.push(module);
}
let chunkId, newModules, newRuntimeModules, newFullHashModules, newDependentHashModules, newRuntime, removedFromRuntime;
const currentChunk = find(compilation.chunks, (chunk => `${chunk.id}` === key));
if (currentChunk) {
if (chunkId = currentChunk.id, newRuntime = intersectRuntime(currentChunk.runtime, allOldRuntime), 
void 0 === newRuntime) continue;
newModules = chunkGraph.getChunkModules(currentChunk).filter((module => updatedModules.has(module, currentChunk))), 
newRuntimeModules = Array.from(chunkGraph.getChunkRuntimeModulesIterable(currentChunk)).filter((module => updatedModules.has(module, currentChunk)));
const fullHashModules = chunkGraph.getChunkFullHashModulesIterable(currentChunk);
newFullHashModules = fullHashModules && Array.from(fullHashModules).filter((module => updatedModules.has(module, currentChunk)));
const dependentHashModules = chunkGraph.getChunkDependentHashModulesIterable(currentChunk);
newDependentHashModules = dependentHashModules && Array.from(dependentHashModules).filter((module => updatedModules.has(module, currentChunk))), 
removedFromRuntime = subtractRuntime(oldRuntime, newRuntime);
} else chunkId = "" + +key === key ? +key : key, removedFromRuntime = oldRuntime, 
newRuntime = oldRuntime;
if (removedFromRuntime) {
forEachRuntime(removedFromRuntime, (runtime => {
hotUpdateMainContentByRuntime.get(runtime).removedChunkIds.add(chunkId);
}));
for (const module of remainingModules) {
const moduleKey = `${key}|${module.identifier()}`, oldHash = records.chunkModuleHashes[moduleKey], runtimes = chunkGraph.getModuleRuntimes(module);
if (oldRuntime === newRuntime && runtimes.has(newRuntime)) {
(nonCodeGeneratedModules.has(module, newRuntime) ? chunkGraph.getModuleHash(module, newRuntime) : compilation.codeGenerationResults.getHash(module, newRuntime)) !== oldHash && ("runtime" === module.type ? (newRuntimeModules = newRuntimeModules || [], 
newRuntimeModules.push(module)) : (newModules = newModules || [], newModules.push(module)));
} else forEachRuntime(removedFromRuntime, (runtime => {
for (const moduleRuntime of runtimes) if ("string" == typeof moduleRuntime) {
if (moduleRuntime === runtime) return;
} else if (void 0 !== moduleRuntime && moduleRuntime.has(runtime)) return;
hotUpdateMainContentByRuntime.get(runtime).removedModules.add(module);
}));
}
}
if (newModules && newModules.length > 0 || newRuntimeModules && newRuntimeModules.length > 0) {
const hotUpdateChunk = new HotUpdateChunk;
if (backCompat && ChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph), 
hotUpdateChunk.id = chunkId, hotUpdateChunk.runtime = newRuntime, currentChunk) for (const group of currentChunk.groupsIterable) hotUpdateChunk.addGroup(group);
chunkGraph.attachModules(hotUpdateChunk, newModules || []), chunkGraph.attachRuntimeModules(hotUpdateChunk, newRuntimeModules || []), 
newFullHashModules && chunkGraph.attachFullHashModules(hotUpdateChunk, newFullHashModules), 
newDependentHashModules && chunkGraph.attachDependentHashModules(hotUpdateChunk, newDependentHashModules);
const renderManifest = compilation.getRenderManifest({
chunk: hotUpdateChunk,
hash: records.hash,
fullHash: records.hash,
outputOptions: compilation.outputOptions,
moduleTemplates: compilation.moduleTemplates,
dependencyTemplates: compilation.dependencyTemplates,
codeGenerationResults: compilation.codeGenerationResults,
runtimeTemplate: compilation.runtimeTemplate,
moduleGraph: compilation.moduleGraph,
chunkGraph
});
for (const entry of renderManifest) {
let filename, assetInfo;
"filename" in entry ? (filename = entry.filename, assetInfo = entry.info) : ({path: filename, info: assetInfo} = compilation.getPathWithInfo(entry.filenameTemplate, entry.pathOptions));
const source = entry.render();
compilation.additionalChunkAssets.push(filename), compilation.emitAsset(filename, source, {
hotModuleReplacement: !0,
...assetInfo
}), currentChunk && (currentChunk.files.add(filename), compilation.hooks.chunkAsset.call(currentChunk, filename));
}
forEachRuntime(newRuntime, (runtime => {
hotUpdateMainContentByRuntime.get(runtime).updatedChunkIds.add(chunkId);
}));
}
}
const completelyRemovedModulesArray = Array.from(completelyRemovedModules), hotUpdateMainContentByFilename = new Map;
for (const {removedChunkIds, removedModules, updatedChunkIds, filename, assetInfo} of hotUpdateMainContentByRuntime.values()) {
const old = hotUpdateMainContentByFilename.get(filename);
if (!old || isSubset(old.removedChunkIds, removedChunkIds) && isSubset(old.removedModules, removedModules) && isSubset(old.updatedChunkIds, updatedChunkIds)) hotUpdateMainContentByFilename.set(filename, {
removedChunkIds,
removedModules,
updatedChunkIds,
assetInfo
}); else {
compilation.warnings.push(new WebpackError("HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config."));
for (const chunkId of removedChunkIds) old.removedChunkIds.add(chunkId);
for (const chunkId of removedModules) old.removedModules.add(chunkId);
for (const chunkId of updatedChunkIds) old.updatedChunkIds.add(chunkId);
}
}
for (const [filename, {removedChunkIds, removedModules, updatedChunkIds, assetInfo}] of hotUpdateMainContentByFilename) {
const hotUpdateMainJson = {
c: Array.from(updatedChunkIds),
r: Array.from(removedChunkIds),
m: 0 === removedModules.size ? completelyRemovedModulesArray : completelyRemovedModulesArray.concat(Array.from(removedModules, (m => chunkGraph.getModuleId(m))))
}, source = new RawSource(JSON.stringify(hotUpdateMainJson));
compilation.emitAsset(filename, source, {
hotModuleReplacement: !0,
...assetInfo
});
}
})), compilation.hooks.additionalTreeRuntimeRequirements.tap("HotModuleReplacementPlugin", ((chunk, runtimeRequirements) => {
runtimeRequirements.add(RuntimeGlobals.hmrDownloadManifest), runtimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers), 
runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution), runtimeRequirements.add(RuntimeGlobals.moduleCache), 
compilation.addRuntimeModule(chunk, new HotModuleReplacementRuntimeModule);
})), normalModuleFactory.hooks.parser.for("javascript/auto").tap("HotModuleReplacementPlugin", (parser => {
applyModuleHot(parser), applyImportMetaHot(parser);
})), normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("HotModuleReplacementPlugin", (parser => {
applyModuleHot(parser);
})), normalModuleFactory.hooks.parser.for("javascript/esm").tap("HotModuleReplacementPlugin", (parser => {
applyImportMetaHot(parser);
})), NormalModule.getCompilationHooks(compilation).loader.tap("HotModuleReplacementPlugin", (context => {
context.hot = !0;
}));
}));
}
}
module.exports = HotModuleReplacementPlugin;
},
6902: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Chunk = __webpack_require__(76034);
module.exports = class extends Chunk {
constructor() {
super();
}
};
},
99588: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleFactory = __webpack_require__(37019);
module.exports = class extends ModuleFactory {
constructor(normalModuleFactory) {
super(), this.normalModuleFactory = normalModuleFactory;
}
create(data, callback) {
this.normalModuleFactory.create(data, ((err, result) => callback(null, result)));
}
};
},
6506: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const validate = __webpack_require__(59586)(__webpack_require__(21286), (() => __webpack_require__(8679)), {
name: "Ignore Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options) {
validate(options), this.options = options, this.checkIgnore = this.checkIgnore.bind(this);
}
checkIgnore(resolveData) {
if ("checkResource" in this.options && this.options.checkResource && this.options.checkResource(resolveData.request, resolveData.context)) return !1;
if ("resourceRegExp" in this.options && this.options.resourceRegExp && this.options.resourceRegExp.test(resolveData.request)) {
if (!("contextRegExp" in this.options) || !this.options.contextRegExp) return !1;
if (this.options.contextRegExp.test(resolveData.context)) return !1;
}
}
apply(compiler) {
compiler.hooks.normalModuleFactory.tap("IgnorePlugin", (nmf => {
nmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
})), compiler.hooks.contextModuleFactory.tap("IgnorePlugin", (cmf => {
cmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
}));
}
};
},
52974: module => {
"use strict";
module.exports = class {
constructor(ignoreWarnings) {
this._ignoreWarnings = ignoreWarnings;
}
apply(compiler) {
compiler.hooks.compilation.tap("IgnoreWarningsPlugin", (compilation => {
compilation.hooks.processWarnings.tap("IgnoreWarningsPlugin", (warnings => warnings.filter((warning => !this._ignoreWarnings.some((ignore => ignore(warning, compilation)))))));
}));
}
};
},
95328: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), makeSerializable = __webpack_require__(45898), extractFragmentIndex = (fragment, index) => [ fragment, index ], sortFragmentWithIndex = ([a, i], [b, j]) => {
const stageCmp = a.stage - b.stage;
if (0 !== stageCmp) return stageCmp;
const positionCmp = a.position - b.position;
return 0 !== positionCmp ? positionCmp : i - j;
};
class InitFragment {
constructor(content, stage, position, key, endContent) {
this.content = content, this.stage = stage, this.position = position, this.key = key, 
this.endContent = endContent;
}
getContent(context) {
return this.content;
}
getEndContent(context) {
return this.endContent;
}
static addToSource(source, initFragments, context) {
if (initFragments.length > 0) {
const sortedFragments = initFragments.map(extractFragmentIndex).sort(sortFragmentWithIndex), keyedFragments = new Map;
for (const [fragment] of sortedFragments) if ("function" != typeof fragment.mergeAll) {
if ("function" == typeof fragment.merge) {
const oldValue = keyedFragments.get(fragment.key);
if (void 0 !== oldValue) {
keyedFragments.set(fragment.key, fragment.merge(oldValue));
continue;
}
}
keyedFragments.set(fragment.key || Symbol(), fragment);
} else {
if (!fragment.key) throw new Error(`InitFragment with mergeAll function must have a valid key: ${fragment.constructor.name}`);
const oldValue = keyedFragments.get(fragment.key);
void 0 === oldValue ? keyedFragments.set(fragment.key, fragment) : Array.isArray(oldValue) ? oldValue.push(fragment) : keyedFragments.set(fragment.key, [ oldValue, fragment ]);
}
const concatSource = new ConcatSource, endContents = [];
for (let fragment of keyedFragments.values()) {
Array.isArray(fragment) && (fragment = fragment[0].mergeAll(fragment)), concatSource.add(fragment.getContent(context));
const endContent = fragment.getEndContent(context);
endContent && endContents.push(endContent);
}
concatSource.add(source);
for (const content of endContents.reverse()) concatSource.add(content);
return concatSource;
}
return source;
}
serialize(context) {
const {write} = context;
write(this.content), write(this.stage), write(this.position), write(this.key), write(this.endContent);
}
deserialize(context) {
const {read} = context;
this.content = read(), this.stage = read(), this.position = read(), this.key = read(), 
this.endContent = read();
}
}
makeSerializable(InitFragment, "webpack/lib/InitFragment"), InitFragment.prototype.merge = void 0, 
InitFragment.STAGE_CONSTANTS = 10, InitFragment.STAGE_ASYNC_BOUNDARY = 20, InitFragment.STAGE_HARMONY_EXPORTS = 30, 
InitFragment.STAGE_HARMONY_IMPORTS = 40, InitFragment.STAGE_PROVIDES = 50, InitFragment.STAGE_ASYNC_DEPENDENCIES = 60, 
InitFragment.STAGE_ASYNC_HARMONY_IMPORTS = 70, module.exports = InitFragment;
},
37748: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class InvalidDependenciesModuleWarning extends WebpackError {
constructor(module, deps) {
const depsList = (deps ? Array.from(deps).sort() : []).map((dep => ` * ${JSON.stringify(dep)}`));
super(`Invalid dependencies have been reported by plugins or loaders for this module. All reported dependencies need to be absolute paths.\nInvalid dependencies may lead to broken watching and caching.\nAs best effort we try to convert all invalid values to absolute paths and converting globs into context dependencies, but this is deprecated behavior.\nLoaders: Pass absolute paths to this.addDependency (existing files), this.addMissingDependency (not existing files), and this.addContextDependency (directories).\nPlugins: Pass absolute paths to fileDependencies (existing files), missingDependencies (not existing files), and contextDependencies (directories).\nGlobs: They are not supported. Pass absolute path to the directory as context dependencies.\nThe following invalid values have been reported:\n${depsList.slice(0, 3).join("\n")}${depsList.length > 3 ? "\n * and more ..." : ""}`), 
this.name = "InvalidDependenciesModuleWarning", this.details = depsList.slice(3).join("\n"), 
this.module = module;
}
}
makeSerializable(InvalidDependenciesModuleWarning, "webpack/lib/InvalidDependenciesModuleWarning"), 
module.exports = InvalidDependenciesModuleWarning;
},
84584: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const InnerGraph = __webpack_require__(93639);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("JavascriptMetaInfoPlugin", ((compilation, {normalModuleFactory}) => {
const handler = parser => {
parser.hooks.call.for("eval").tap("JavascriptMetaInfoPlugin", (() => {
parser.state.module.buildInfo.moduleConcatenationBailout = "eval()", parser.state.module.buildInfo.usingEval = !0;
const currentSymbol = InnerGraph.getTopLevelSymbol(parser.state);
currentSymbol ? InnerGraph.addUsage(parser.state, null, currentSymbol) : InnerGraph.bailout(parser.state);
})), parser.hooks.finish.tap("JavascriptMetaInfoPlugin", (() => {
let topLevelDeclarations = parser.state.module.buildInfo.topLevelDeclarations;
void 0 === topLevelDeclarations && (topLevelDeclarations = parser.state.module.buildInfo.topLevelDeclarations = new Set);
for (const name of parser.scope.definitions.asSet()) {
void 0 === parser.getFreeInfoFromVariable(name) && topLevelDeclarations.add(name);
}
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("JavascriptMetaInfoPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("JavascriptMetaInfoPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("JavascriptMetaInfoPlugin", handler);
}));
}
};
},
13745: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), EntryDependency = __webpack_require__(74989), {someInIterable} = __webpack_require__(30416), {compareModulesById} = __webpack_require__(40028), {dirname, mkdirp} = __webpack_require__(57075);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
compiler.hooks.emit.tapAsync("LibManifestPlugin", ((compilation, callback) => {
const moduleGraph = compilation.moduleGraph;
asyncLib.forEach(Array.from(compilation.chunks), ((chunk, callback) => {
if (!chunk.canBeInitial()) return void callback();
const chunkGraph = compilation.chunkGraph, targetPath = compilation.getPath(this.options.path, {
chunk
}), name = this.options.name && compilation.getPath(this.options.name, {
chunk
}), content = Object.create(null);
for (const module of chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesById(chunkGraph))) {
if (this.options.entryOnly && !someInIterable(moduleGraph.getIncomingConnections(module), (c => c.dependency instanceof EntryDependency))) continue;
const ident = module.libIdent({
context: this.options.context || compiler.options.context,
associatedObjectForCache: compiler.root
});
if (ident) {
const providedExports = moduleGraph.getExportsInfo(module).getProvidedExports(), data = {
id: chunkGraph.getModuleId(module),
buildMeta: module.buildMeta,
exports: Array.isArray(providedExports) ? providedExports : void 0
};
content[ident] = data;
}
}
const manifest = {
name,
type: this.options.type,
content
}, manifestContent = this.options.format ? JSON.stringify(manifest, null, 2) : JSON.stringify(manifest), buffer = Buffer.from(manifestContent, "utf8");
mkdirp(compiler.intermediateFileSystem, dirname(compiler.intermediateFileSystem, targetPath), (err => {
if (err) return callback(err);
compiler.intermediateFileSystem.writeFile(targetPath, buffer, callback);
}));
}), callback);
}));
}
};
},
80934: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const EnableLibraryPlugin = __webpack_require__(30001);
module.exports = class {
constructor(name, target, umdNamedDefine, auxiliaryComment, exportProperty) {
this.library = {
type: target || "var",
name,
umdNamedDefine,
auxiliaryComment,
export: exportProperty
};
}
apply(compiler) {
const {output} = compiler.options;
output.library = this.library, new EnableLibraryPlugin(this.library.type).apply(compiler);
}
};
},
74245: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleFilenameHelpers = __webpack_require__(23833), NormalModule = __webpack_require__(3213), validate = __webpack_require__(59586)(__webpack_require__(99422), (() => __webpack_require__(30685)), {
name: "Loader Options Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options = {}) {
validate(options), "object" != typeof options && (options = {}), options.test || (options.test = {
test: () => !0
}), this.options = options;
}
apply(compiler) {
const options = this.options;
compiler.hooks.compilation.tap("LoaderOptionsPlugin", (compilation => {
NormalModule.getCompilationHooks(compilation).loader.tap("LoaderOptionsPlugin", ((context, module) => {
const resource = module.resource;
if (!resource) return;
const i = resource.indexOf("?");
if (ModuleFilenameHelpers.matchObject(options, i < 0 ? resource : resource.slice(0, i))) for (const key of Object.keys(options)) "include" !== key && "exclude" !== key && "test" !== key && (context[key] = options[key]);
}));
}));
}
};
},
63626: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const NormalModule = __webpack_require__(3213);
module.exports = class {
constructor(target) {
this.target = target;
}
apply(compiler) {
compiler.hooks.compilation.tap("LoaderTargetPlugin", (compilation => {
NormalModule.getCompilationHooks(compilation).loader.tap("LoaderTargetPlugin", (loaderContext => {
loaderContext.target = this.target;
}));
}));
}
};
},
33883: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook} = __webpack_require__(89991), util = __webpack_require__(73837), RuntimeGlobals = __webpack_require__(50980), memoize = __webpack_require__(98216), getJavascriptModulesPlugin = memoize((() => __webpack_require__(18362))), getJsonpTemplatePlugin = memoize((() => __webpack_require__(2025))), getLoadScriptRuntimeModule = memoize((() => __webpack_require__(84914)));
class MainTemplate {
constructor(outputOptions, compilation) {
this._outputOptions = outputOptions || {}, this.hooks = Object.freeze({
renderManifest: {
tap: util.deprecate(((options, fn) => {
compilation.hooks.renderManifest.tap(options, ((entries, options) => options.chunk.hasRuntime() ? fn(entries, options) : entries));
}), "MainTemplate.hooks.renderManifest is deprecated (use Compilation.hooks.renderManifest instead)", "DEP_WEBPACK_MAIN_TEMPLATE_RENDER_MANIFEST")
},
modules: {
tap: () => {
throw new Error("MainTemplate.hooks.modules has been removed (there is no replacement, please create an issue to request that)");
}
},
moduleObj: {
tap: () => {
throw new Error("MainTemplate.hooks.moduleObj has been removed (there is no replacement, please create an issue to request that)");
}
},
require: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderRequire.tap(options, fn);
}), "MainTemplate.hooks.require is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderRequire instead)", "DEP_WEBPACK_MAIN_TEMPLATE_REQUIRE")
},
beforeStartup: {
tap: () => {
throw new Error("MainTemplate.hooks.beforeStartup has been removed (use RuntimeGlobals.startupOnlyBefore instead)");
}
},
startup: {
tap: () => {
throw new Error("MainTemplate.hooks.startup has been removed (use RuntimeGlobals.startup instead)");
}
},
afterStartup: {
tap: () => {
throw new Error("MainTemplate.hooks.afterStartup has been removed (use RuntimeGlobals.startupOnlyAfter instead)");
}
},
render: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).render.tap(options, ((source, renderContext) => 0 !== renderContext.chunkGraph.getNumberOfEntryModules(renderContext.chunk) && renderContext.chunk.hasRuntime() ? fn(source, renderContext.chunk, compilation.hash, compilation.moduleTemplates.javascript, compilation.dependencyTemplates) : source));
}), "MainTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)", "DEP_WEBPACK_MAIN_TEMPLATE_RENDER")
},
renderWithEntry: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).render.tap(options, ((source, renderContext) => 0 !== renderContext.chunkGraph.getNumberOfEntryModules(renderContext.chunk) && renderContext.chunk.hasRuntime() ? fn(source, renderContext.chunk, compilation.hash) : source));
}), "MainTemplate.hooks.renderWithEntry is deprecated (use JavascriptModulesPlugin.getCompilationHooks().render instead)", "DEP_WEBPACK_MAIN_TEMPLATE_RENDER_WITH_ENTRY")
},
assetPath: {
tap: util.deprecate(((options, fn) => {
compilation.hooks.assetPath.tap(options, fn);
}), "MainTemplate.hooks.assetPath is deprecated (use Compilation.hooks.assetPath instead)", "DEP_WEBPACK_MAIN_TEMPLATE_ASSET_PATH"),
call: util.deprecate(((filename, options) => compilation.getAssetPath(filename, options)), "MainTemplate.hooks.assetPath is deprecated (use Compilation.hooks.assetPath instead)", "DEP_WEBPACK_MAIN_TEMPLATE_ASSET_PATH")
},
hash: {
tap: util.deprecate(((options, fn) => {
compilation.hooks.fullHash.tap(options, fn);
}), "MainTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)", "DEP_WEBPACK_MAIN_TEMPLATE_HASH")
},
hashForChunk: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).chunkHash.tap(options, ((chunk, hash) => {
if (chunk.hasRuntime()) return fn(hash, chunk);
}));
}), "MainTemplate.hooks.hashForChunk is deprecated (use JavascriptModulesPlugin.getCompilationHooks().chunkHash instead)", "DEP_WEBPACK_MAIN_TEMPLATE_HASH_FOR_CHUNK")
},
globalHashPaths: {
tap: util.deprecate((() => {}), "MainTemplate.hooks.globalHashPaths has been removed (it's no longer needed)", "DEP_WEBPACK_MAIN_TEMPLATE_HASH_FOR_CHUNK")
},
globalHash: {
tap: util.deprecate((() => {}), "MainTemplate.hooks.globalHash has been removed (it's no longer needed)", "DEP_WEBPACK_MAIN_TEMPLATE_HASH_FOR_CHUNK")
},
hotBootstrap: {
tap: () => {
throw new Error("MainTemplate.hooks.hotBootstrap has been removed (use your own RuntimeModule instead)");
}
},
bootstrap: new SyncWaterfallHook([ "source", "chunk", "hash", "moduleTemplate", "dependencyTemplates" ]),
localVars: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
requireExtensions: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
requireEnsure: new SyncWaterfallHook([ "source", "chunk", "hash", "chunkIdExpression" ]),
get jsonpScript() {
return getLoadScriptRuntimeModule().getCompilationHooks(compilation).createScript;
},
get linkPrefetch() {
return getJsonpTemplatePlugin().getCompilationHooks(compilation).linkPrefetch;
},
get linkPreload() {
return getJsonpTemplatePlugin().getCompilationHooks(compilation).linkPreload;
}
}), this.renderCurrentHashCode = util.deprecate(((hash, length) => length ? `${RuntimeGlobals.getFullHash} ? ${RuntimeGlobals.getFullHash}().slice(0, ${length}) : ${hash.slice(0, length)}` : `${RuntimeGlobals.getFullHash} ? ${RuntimeGlobals.getFullHash}() : ${hash}`), "MainTemplate.renderCurrentHashCode is deprecated (use RuntimeGlobals.getFullHash runtime function instead)", "DEP_WEBPACK_MAIN_TEMPLATE_RENDER_CURRENT_HASH_CODE"), 
this.getPublicPath = util.deprecate((options => compilation.getAssetPath(compilation.outputOptions.publicPath, options)), "MainTemplate.getPublicPath is deprecated (use Compilation.getAssetPath(compilation.outputOptions.publicPath, options) instead)", "DEP_WEBPACK_MAIN_TEMPLATE_GET_PUBLIC_PATH"), 
this.getAssetPath = util.deprecate(((path, options) => compilation.getAssetPath(path, options)), "MainTemplate.getAssetPath is deprecated (use Compilation.getAssetPath instead)", "DEP_WEBPACK_MAIN_TEMPLATE_GET_ASSET_PATH"), 
this.getAssetPathWithInfo = util.deprecate(((path, options) => compilation.getAssetPathWithInfo(path, options)), "MainTemplate.getAssetPathWithInfo is deprecated (use Compilation.getAssetPath instead)", "DEP_WEBPACK_MAIN_TEMPLATE_GET_ASSET_PATH_WITH_INFO");
}
}
Object.defineProperty(MainTemplate.prototype, "requireFn", {
get: util.deprecate((() => "__webpack_require__"), 'MainTemplate.requireFn is deprecated (use "__webpack_require__")', "DEP_WEBPACK_MAIN_TEMPLATE_REQUIRE_FN")
}), Object.defineProperty(MainTemplate.prototype, "outputOptions", {
get: util.deprecate((function() {
return this._outputOptions;
}), "MainTemplate.outputOptions is deprecated (use Compilation.outputOptions instead)", "DEP_WEBPACK_MAIN_TEMPLATE_OUTPUT_OPTIONS")
}), module.exports = MainTemplate;
},
36797: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), ChunkGraph = __webpack_require__(15888), DependenciesBlock = __webpack_require__(17461), ModuleGraph = __webpack_require__(2197), RuntimeGlobals = __webpack_require__(50980), {first} = __webpack_require__(73974), {compareChunksById} = __webpack_require__(40028), makeSerializable = __webpack_require__(45898), EMPTY_RESOLVE_OPTIONS = {};
let debugId = 1e3;
const DEFAULT_TYPES_UNKNOWN = new Set([ "unknown" ]), DEFAULT_TYPES_JS = new Set([ "javascript" ]), deprecatedNeedRebuild = util.deprecate(((module, context) => module.needRebuild(context.fileSystemInfo.getDeprecatedFileTimestamps(), context.fileSystemInfo.getDeprecatedContextTimestamps())), "Module.needRebuild is deprecated in favor of Module.needBuild", "DEP_WEBPACK_MODULE_NEED_REBUILD");
class Module extends DependenciesBlock {
constructor(type, context = null, layer = null) {
super(), this.type = type, this.context = context, this.layer = layer, this.needId = !0, 
this.debugId = debugId++, this.resolveOptions = EMPTY_RESOLVE_OPTIONS, this.factoryMeta = void 0, 
this.useSourceMap = !1, this.useSimpleSourceMap = !1, this._warnings = void 0, this._errors = void 0, 
this.buildMeta = void 0, this.buildInfo = void 0, this.presentationalDependencies = void 0, 
this.codeGenerationDependencies = void 0;
}
get id() {
return ChunkGraph.getChunkGraphForModule(this, "Module.id", "DEP_WEBPACK_MODULE_ID").getModuleId(this);
}
set id(value) {
"" !== value ? ChunkGraph.getChunkGraphForModule(this, "Module.id", "DEP_WEBPACK_MODULE_ID").setModuleId(this, value) : this.needId = !1;
}
get hash() {
return ChunkGraph.getChunkGraphForModule(this, "Module.hash", "DEP_WEBPACK_MODULE_HASH").getModuleHash(this, void 0);
}
get renderedHash() {
return ChunkGraph.getChunkGraphForModule(this, "Module.renderedHash", "DEP_WEBPACK_MODULE_RENDERED_HASH").getRenderedModuleHash(this, void 0);
}
get profile() {
return ModuleGraph.getModuleGraphForModule(this, "Module.profile", "DEP_WEBPACK_MODULE_PROFILE").getProfile(this);
}
set profile(value) {
ModuleGraph.getModuleGraphForModule(this, "Module.profile", "DEP_WEBPACK_MODULE_PROFILE").setProfile(this, value);
}
get index() {
return ModuleGraph.getModuleGraphForModule(this, "Module.index", "DEP_WEBPACK_MODULE_INDEX").getPreOrderIndex(this);
}
set index(value) {
ModuleGraph.getModuleGraphForModule(this, "Module.index", "DEP_WEBPACK_MODULE_INDEX").setPreOrderIndex(this, value);
}
get index2() {
return ModuleGraph.getModuleGraphForModule(this, "Module.index2", "DEP_WEBPACK_MODULE_INDEX2").getPostOrderIndex(this);
}
set index2(value) {
ModuleGraph.getModuleGraphForModule(this, "Module.index2", "DEP_WEBPACK_MODULE_INDEX2").setPostOrderIndex(this, value);
}
get depth() {
return ModuleGraph.getModuleGraphForModule(this, "Module.depth", "DEP_WEBPACK_MODULE_DEPTH").getDepth(this);
}
set depth(value) {
ModuleGraph.getModuleGraphForModule(this, "Module.depth", "DEP_WEBPACK_MODULE_DEPTH").setDepth(this, value);
}
get issuer() {
return ModuleGraph.getModuleGraphForModule(this, "Module.issuer", "DEP_WEBPACK_MODULE_ISSUER").getIssuer(this);
}
set issuer(value) {
ModuleGraph.getModuleGraphForModule(this, "Module.issuer", "DEP_WEBPACK_MODULE_ISSUER").setIssuer(this, value);
}
get usedExports() {
return ModuleGraph.getModuleGraphForModule(this, "Module.usedExports", "DEP_WEBPACK_MODULE_USED_EXPORTS").getUsedExports(this, void 0);
}
get optimizationBailout() {
return ModuleGraph.getModuleGraphForModule(this, "Module.optimizationBailout", "DEP_WEBPACK_MODULE_OPTIMIZATION_BAILOUT").getOptimizationBailout(this);
}
get optional() {
return this.isOptional(ModuleGraph.getModuleGraphForModule(this, "Module.optional", "DEP_WEBPACK_MODULE_OPTIONAL"));
}
addChunk(chunk) {
const chunkGraph = ChunkGraph.getChunkGraphForModule(this, "Module.addChunk", "DEP_WEBPACK_MODULE_ADD_CHUNK");
return !chunkGraph.isModuleInChunk(this, chunk) && (chunkGraph.connectChunkAndModule(chunk, this), 
!0);
}
removeChunk(chunk) {
return ChunkGraph.getChunkGraphForModule(this, "Module.removeChunk", "DEP_WEBPACK_MODULE_REMOVE_CHUNK").disconnectChunkAndModule(chunk, this);
}
isInChunk(chunk) {
return ChunkGraph.getChunkGraphForModule(this, "Module.isInChunk", "DEP_WEBPACK_MODULE_IS_IN_CHUNK").isModuleInChunk(this, chunk);
}
isEntryModule() {
return ChunkGraph.getChunkGraphForModule(this, "Module.isEntryModule", "DEP_WEBPACK_MODULE_IS_ENTRY_MODULE").isEntryModule(this);
}
getChunks() {
return ChunkGraph.getChunkGraphForModule(this, "Module.getChunks", "DEP_WEBPACK_MODULE_GET_CHUNKS").getModuleChunks(this);
}
getNumberOfChunks() {
return ChunkGraph.getChunkGraphForModule(this, "Module.getNumberOfChunks", "DEP_WEBPACK_MODULE_GET_NUMBER_OF_CHUNKS").getNumberOfModuleChunks(this);
}
get chunksIterable() {
return ChunkGraph.getChunkGraphForModule(this, "Module.chunksIterable", "DEP_WEBPACK_MODULE_CHUNKS_ITERABLE").getOrderedModuleChunksIterable(this, compareChunksById);
}
isProvided(exportName) {
return ModuleGraph.getModuleGraphForModule(this, "Module.usedExports", "DEP_WEBPACK_MODULE_USED_EXPORTS").isExportProvided(this, exportName);
}
get exportsArgument() {
return this.buildInfo && this.buildInfo.exportsArgument || "exports";
}
get moduleArgument() {
return this.buildInfo && this.buildInfo.moduleArgument || "module";
}
getExportsType(moduleGraph, strict) {
switch (this.buildMeta && this.buildMeta.exportsType) {
case "flagged":
return strict ? "default-with-named" : "namespace";

case "namespace":
return "namespace";

case "default":
switch (this.buildMeta.defaultObject) {
case "redirect":
return "default-with-named";

case "redirect-warn":
return strict ? "default-only" : "default-with-named";

default:
return "default-only";
}

case "dynamic":
{
if (strict) return "default-with-named";
const handleDefault = () => {
switch (this.buildMeta.defaultObject) {
case "redirect":
case "redirect-warn":
return "default-with-named";

default:
return "default-only";
}
}, exportInfo = moduleGraph.getReadOnlyExportInfo(this, "__esModule");
if (!1 === exportInfo.provided) return handleDefault();
const target = exportInfo.getTarget(moduleGraph);
if (!target || !target.export || 1 !== target.export.length || "__esModule" !== target.export[0]) return "dynamic";
switch (target.module.buildMeta && target.module.buildMeta.exportsType) {
case "flagged":
case "namespace":
return "namespace";

case "default":
return handleDefault();

default:
return "dynamic";
}
}

default:
return strict ? "default-with-named" : "dynamic";
}
}
addPresentationalDependency(presentationalDependency) {
void 0 === this.presentationalDependencies && (this.presentationalDependencies = []), 
this.presentationalDependencies.push(presentationalDependency);
}
addCodeGenerationDependency(codeGenerationDependency) {
void 0 === this.codeGenerationDependencies && (this.codeGenerationDependencies = []), 
this.codeGenerationDependencies.push(codeGenerationDependency);
}
clearDependenciesAndBlocks() {
void 0 !== this.presentationalDependencies && (this.presentationalDependencies.length = 0), 
void 0 !== this.codeGenerationDependencies && (this.codeGenerationDependencies.length = 0), 
super.clearDependenciesAndBlocks();
}
addWarning(warning) {
void 0 === this._warnings && (this._warnings = []), this._warnings.push(warning);
}
getWarnings() {
return this._warnings;
}
getNumberOfWarnings() {
return void 0 !== this._warnings ? this._warnings.length : 0;
}
addError(error) {
void 0 === this._errors && (this._errors = []), this._errors.push(error);
}
getErrors() {
return this._errors;
}
getNumberOfErrors() {
return void 0 !== this._errors ? this._errors.length : 0;
}
clearWarningsAndErrors() {
void 0 !== this._warnings && (this._warnings.length = 0), void 0 !== this._errors && (this._errors.length = 0);
}
isOptional(moduleGraph) {
let hasConnections = !1;
for (const r of moduleGraph.getIncomingConnections(this)) {
if (!r.dependency || !r.dependency.optional || !r.isTargetActive(void 0)) return !1;
hasConnections = !0;
}
return hasConnections;
}
isAccessibleInChunk(chunkGraph, chunk, ignoreChunk) {
for (const chunkGroup of chunk.groupsIterable) if (!this.isAccessibleInChunkGroup(chunkGraph, chunkGroup)) return !1;
return !0;
}
isAccessibleInChunkGroup(chunkGraph, chunkGroup, ignoreChunk) {
const queue = new Set([ chunkGroup ]);
queueFor: for (const cg of queue) {
for (const chunk of cg.chunks) if (chunk !== ignoreChunk && chunkGraph.isModuleInChunk(this, chunk)) continue queueFor;
if (chunkGroup.isInitial()) return !1;
for (const parent of chunkGroup.parentsIterable) queue.add(parent);
}
return !0;
}
hasReasonForChunk(chunk, moduleGraph, chunkGraph) {
for (const [fromModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(this)) if (connections.some((c => c.isTargetActive(chunk.runtime)))) for (const originChunk of chunkGraph.getModuleChunksIterable(fromModule)) if (!this.isAccessibleInChunk(chunkGraph, originChunk, chunk)) return !0;
return !1;
}
hasReasons(moduleGraph, runtime) {
for (const c of moduleGraph.getIncomingConnections(this)) if (c.isTargetActive(runtime)) return !0;
return !1;
}
toString() {
return `Module[${this.debugId}: ${this.identifier()}]`;
}
needBuild(context, callback) {
callback(null, !this.buildMeta || this.needRebuild === Module.prototype.needRebuild || deprecatedNeedRebuild(this, context));
}
needRebuild(fileTimestamps, contextTimestamps) {
return !0;
}
updateHash(hash, context = {
chunkGraph: ChunkGraph.getChunkGraphForModule(this, "Module.updateHash", "DEP_WEBPACK_MODULE_UPDATE_HASH"),
runtime: void 0
}) {
const {chunkGraph, runtime} = context;
if (hash.update(chunkGraph.getModuleGraphHash(this, runtime)), void 0 !== this.presentationalDependencies) for (const dep of this.presentationalDependencies) dep.updateHash(hash, context);
super.updateHash(hash, context);
}
invalidateBuild() {}
identifier() {
throw new (__webpack_require__(91266));
}
readableIdentifier(requestShortener) {
throw new (__webpack_require__(91266));
}
build(options, compilation, resolver, fs, callback) {
throw new (__webpack_require__(91266));
}
getSourceTypes() {
return this.source === Module.prototype.source ? DEFAULT_TYPES_UNKNOWN : DEFAULT_TYPES_JS;
}
source(dependencyTemplates, runtimeTemplate, type = "javascript") {
if (this.codeGeneration === Module.prototype.codeGeneration) {
throw new (__webpack_require__(91266));
}
const chunkGraph = ChunkGraph.getChunkGraphForModule(this, "Module.source() is deprecated. Use Compilation.codeGenerationResults.getSource(module, runtime, type) instead", "DEP_WEBPACK_MODULE_SOURCE"), codeGenContext = {
dependencyTemplates,
runtimeTemplate,
moduleGraph: chunkGraph.moduleGraph,
chunkGraph,
runtime: void 0,
codeGenerationResults: void 0
}, sources = this.codeGeneration(codeGenContext).sources;
return type ? sources.get(type) : sources.get(first(this.getSourceTypes()));
}
size(type) {
throw new (__webpack_require__(91266));
}
libIdent(options) {
return null;
}
nameForCondition() {
return null;
}
getConcatenationBailoutReason(context) {
return `Module Concatenation is not implemented for ${this.constructor.name}`;
}
getSideEffectsConnectionState(moduleGraph) {
return !0;
}
codeGeneration(context) {
const sources = new Map;
for (const type of this.getSourceTypes()) "unknown" !== type && sources.set(type, this.source(context.dependencyTemplates, context.runtimeTemplate, type));
return {
sources,
runtimeRequirements: new Set([ RuntimeGlobals.module, RuntimeGlobals.exports, RuntimeGlobals.require ])
};
}
chunkCondition(chunk, compilation) {
return !0;
}
hasChunkCondition() {
return this.chunkCondition !== Module.prototype.chunkCondition;
}
updateCacheModule(module) {
this.type = module.type, this.layer = module.layer, this.context = module.context, 
this.factoryMeta = module.factoryMeta, this.resolveOptions = module.resolveOptions;
}
getUnsafeCacheData() {
return {
factoryMeta: this.factoryMeta,
resolveOptions: this.resolveOptions
};
}
_restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
this.factoryMeta = unsafeCacheData.factoryMeta, this.resolveOptions = unsafeCacheData.resolveOptions;
}
cleanupForCache() {
this.factoryMeta = void 0, this.resolveOptions = void 0;
}
originalSource() {
return null;
}
addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies) {}
serialize(context) {
const {write} = context;
write(this.type), write(this.layer), write(this.context), write(this.resolveOptions), 
write(this.factoryMeta), write(this.useSourceMap), write(this.useSimpleSourceMap), 
write(void 0 !== this._warnings && 0 === this._warnings.length ? void 0 : this._warnings), 
write(void 0 !== this._errors && 0 === this._errors.length ? void 0 : this._errors), 
write(this.buildMeta), write(this.buildInfo), write(this.presentationalDependencies), 
write(this.codeGenerationDependencies), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.type = read(), this.layer = read(), this.context = read(), this.resolveOptions = read(), 
this.factoryMeta = read(), this.useSourceMap = read(), this.useSimpleSourceMap = read(), 
this._warnings = read(), this._errors = read(), this.buildMeta = read(), this.buildInfo = read(), 
this.presentationalDependencies = read(), this.codeGenerationDependencies = read(), 
super.deserialize(context);
}
}
makeSerializable(Module, "webpack/lib/Module"), Object.defineProperty(Module.prototype, "hasEqualsChunks", {
get() {
throw new Error("Module.hasEqualsChunks was renamed (use hasEqualChunks instead)");
}
}), Object.defineProperty(Module.prototype, "isUsed", {
get() {
throw new Error("Module.isUsed was renamed (use getUsedName, isExportUsed or isModuleUsed instead)");
}
}), Object.defineProperty(Module.prototype, "errors", {
get: util.deprecate((function() {
return void 0 === this._errors && (this._errors = []), this._errors;
}), "Module.errors was removed (use getErrors instead)", "DEP_WEBPACK_MODULE_ERRORS")
}), Object.defineProperty(Module.prototype, "warnings", {
get: util.deprecate((function() {
return void 0 === this._warnings && (this._warnings = []), this._warnings;
}), "Module.warnings was removed (use getWarnings instead)", "DEP_WEBPACK_MODULE_WARNINGS")
}), Object.defineProperty(Module.prototype, "used", {
get() {
throw new Error("Module.used was refactored (use ModuleGraph.getUsedExports instead)");
},
set(value) {
throw new Error("Module.used was refactored (use ModuleGraph.setUsedExports instead)");
}
}), module.exports = Module;
},
2386: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {cutOffLoaderExecution} = __webpack_require__(23516), WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class ModuleBuildError extends WebpackError {
constructor(err, {from = null} = {}) {
let details, message = "Module build failed";
if (message += from ? ` (from ${from}):\n` : ": ", null !== err && "object" == typeof err) if ("string" == typeof err.stack && err.stack) {
const stack = cutOffLoaderExecution(err.stack);
err.hideStack ? (details = stack, "string" == typeof err.message && err.message ? message += err.message : message += err) : message += stack;
} else "string" == typeof err.message && err.message ? message += err.message : message += String(err); else message += String(err);
super(message), this.name = "ModuleBuildError", this.details = details, this.error = err;
}
serialize(context) {
const {write} = context;
write(this.error), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.error = read(), super.deserialize(context);
}
}
makeSerializable(ModuleBuildError, "webpack/lib/ModuleBuildError"), module.exports = ModuleBuildError;
},
760: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module, err, loc) {
super(err.message), this.name = "ModuleDependencyError", this.details = err && !err.hideStack ? err.stack.split("\n").slice(1).join("\n") : void 0, 
this.module = module, this.loc = loc, this.error = err, err && err.hideStack && (this.stack = err.stack.split("\n").slice(1).join("\n") + "\n\n" + this.stack);
}
};
},
50020: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class ModuleDependencyWarning extends WebpackError {
constructor(module, err, loc) {
super(err ? err.message : ""), this.name = "ModuleDependencyWarning", this.details = err && !err.hideStack ? err.stack.split("\n").slice(1).join("\n") : void 0, 
this.module = module, this.loc = loc, this.error = err, err && err.hideStack && (this.stack = err.stack.split("\n").slice(1).join("\n") + "\n\n" + this.stack);
}
}
makeSerializable(ModuleDependencyWarning, "webpack/lib/ModuleDependencyWarning"), 
module.exports = ModuleDependencyWarning;
},
96063: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {cleanUp} = __webpack_require__(23516), WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class ModuleError extends WebpackError {
constructor(err, {from = null} = {}) {
let message = "Module Error";
message += from ? ` (from ${from}):\n` : ": ", err && "object" == typeof err && err.message ? message += err.message : err && (message += err), 
super(message), this.name = "ModuleError", this.error = err, this.details = err && "object" == typeof err && err.stack ? cleanUp(err.stack, this.message) : void 0;
}
serialize(context) {
const {write} = context;
write(this.error), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.error = read(), super.deserialize(context);
}
}
makeSerializable(ModuleError, "webpack/lib/ModuleError"), module.exports = ModuleError;
},
37019: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
module.exports = class {
create(data, callback) {
throw new (__webpack_require__(91266));
}
};
},
23833: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const NormalModule = __webpack_require__(3213), createHash = __webpack_require__(27466), memoize = __webpack_require__(98216), ModuleFilenameHelpers = exports;
ModuleFilenameHelpers.ALL_LOADERS_RESOURCE = "[all-loaders][resource]", ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\[all-?loaders\]\[resource\]/gi, 
ModuleFilenameHelpers.LOADERS_RESOURCE = "[loaders][resource]", ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\[loaders\]\[resource\]/gi, 
ModuleFilenameHelpers.RESOURCE = "[resource]", ModuleFilenameHelpers.REGEXP_RESOURCE = /\[resource\]/gi, 
ModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = "[absolute-resource-path]", ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\[abs(olute)?-?resource-?path\]/gi, 
ModuleFilenameHelpers.RESOURCE_PATH = "[resource-path]", ModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\[resource-?path\]/gi, 
ModuleFilenameHelpers.ALL_LOADERS = "[all-loaders]", ModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\[all-?loaders\]/gi, 
ModuleFilenameHelpers.LOADERS = "[loaders]", ModuleFilenameHelpers.REGEXP_LOADERS = /\[loaders\]/gi, 
ModuleFilenameHelpers.QUERY = "[query]", ModuleFilenameHelpers.REGEXP_QUERY = /\[query\]/gi, 
ModuleFilenameHelpers.ID = "[id]", ModuleFilenameHelpers.REGEXP_ID = /\[id\]/gi, 
ModuleFilenameHelpers.HASH = "[hash]", ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi, 
ModuleFilenameHelpers.NAMESPACE = "[namespace]", ModuleFilenameHelpers.REGEXP_NAMESPACE = /\[namespace\]/gi;
const getBefore = (strFn, token) => () => {
const str = strFn(), idx = str.lastIndexOf(token);
return idx < 0 ? "" : str.slice(0, idx);
}, getHash = (strFn, hashFunction) => () => {
const hash = createHash(hashFunction);
hash.update(strFn());
return hash.digest("hex").slice(0, 4);
}, asRegExp = test => ("string" == typeof test && (test = new RegExp("^" + test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"))), 
test), REGEXP = /\[\\*([\w-]+)\\*\]/gi;
ModuleFilenameHelpers.createFilename = (module = "", options, {requestShortener, chunkGraph, hashFunction = "md4"}) => {
const opts = {
namespace: "",
moduleFilenameTemplate: "",
..."object" == typeof options ? options : {
moduleFilenameTemplate: options
}
};
let absoluteResourcePath, hash, identifier, moduleId, shortIdentifier;
"string" == typeof module ? (shortIdentifier = memoize((() => requestShortener.shorten(module))), 
identifier = shortIdentifier, moduleId = () => "", absoluteResourcePath = () => module.split("!").pop(), 
hash = getHash(identifier, hashFunction)) : (shortIdentifier = memoize((() => module.readableIdentifier(requestShortener))), 
identifier = memoize((() => requestShortener.shorten(module.identifier()))), moduleId = () => chunkGraph.getModuleId(module), 
absoluteResourcePath = () => module instanceof NormalModule ? module.resource : module.identifier().split("!").pop(), 
hash = getHash(identifier, hashFunction));
const resource = memoize((() => shortIdentifier().split("!").pop())), loaders = getBefore(shortIdentifier, "!"), allLoaders = getBefore(identifier, "!"), query = (strFn = resource, 
token = "?", () => {
const str = strFn(), idx = str.indexOf(token);
return idx < 0 ? "" : str.slice(idx);
});
var strFn, token;
const resourcePath = () => {
const q = query().length;
return 0 === q ? resource() : resource().slice(0, -q);
};
if ("function" == typeof opts.moduleFilenameTemplate) return opts.moduleFilenameTemplate((obj => {
const newObj = {};
for (const key of Object.keys(obj)) {
const fn = obj[key];
Object.defineProperty(newObj, key, {
get: () => fn(),
set: v => {
Object.defineProperty(newObj, key, {
value: v,
enumerable: !0,
writable: !0
});
},
enumerable: !0,
configurable: !0
});
}
return newObj;
})({
identifier,
shortIdentifier,
resource,
resourcePath: memoize(resourcePath),
absoluteResourcePath: memoize(absoluteResourcePath),
allLoaders: memoize(allLoaders),
query: memoize(query),
moduleId: memoize(moduleId),
hash: memoize(hash),
namespace: () => opts.namespace
}));
const replacements = new Map([ [ "identifier", identifier ], [ "short-identifier", shortIdentifier ], [ "resource", resource ], [ "resource-path", resourcePath ], [ "resourcepath", resourcePath ], [ "absolute-resource-path", absoluteResourcePath ], [ "abs-resource-path", absoluteResourcePath ], [ "absoluteresource-path", absoluteResourcePath ], [ "absresource-path", absoluteResourcePath ], [ "absolute-resourcepath", absoluteResourcePath ], [ "abs-resourcepath", absoluteResourcePath ], [ "absoluteresourcepath", absoluteResourcePath ], [ "absresourcepath", absoluteResourcePath ], [ "all-loaders", allLoaders ], [ "allloaders", allLoaders ], [ "loaders", loaders ], [ "query", query ], [ "id", moduleId ], [ "hash", hash ], [ "namespace", () => opts.namespace ] ]);
return opts.moduleFilenameTemplate.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, "[identifier]").replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, "[short-identifier]").replace(REGEXP, ((match, content) => {
if (content.length + 2 === match.length) {
const replacement = replacements.get(content.toLowerCase());
if (void 0 !== replacement) return replacement();
} else if (match.startsWith("[\\") && match.endsWith("\\]")) return `[${match.slice(2, -2)}]`;
return match;
}));
}, ModuleFilenameHelpers.replaceDuplicates = (array, fn, comparator) => {
const countMap = Object.create(null), posMap = Object.create(null);
return array.forEach(((item, idx) => {
countMap[item] = countMap[item] || [], countMap[item].push(idx), posMap[item] = 0;
})), comparator && Object.keys(countMap).forEach((item => {
countMap[item].sort(comparator);
})), array.map(((item, i) => countMap[item].length > 1 ? comparator && countMap[item][0] === i ? item : fn(item, i, posMap[item]++) : item));
}, ModuleFilenameHelpers.matchPart = (str, test) => !test || (test = asRegExp(test), 
Array.isArray(test) ? test.map(asRegExp).some((regExp => regExp.test(str))) : test.test(str)), 
ModuleFilenameHelpers.matchObject = (obj, str) => !(obj.test && !ModuleFilenameHelpers.matchPart(str, obj.test)) && (!(obj.include && !ModuleFilenameHelpers.matchPart(str, obj.include)) && (!obj.exclude || !ModuleFilenameHelpers.matchPart(str, obj.exclude)));
},
2197: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), ExportsInfo = __webpack_require__(74603), ModuleGraphConnection = __webpack_require__(63867), SortableSet = __webpack_require__(72451), WeakTupleMap = __webpack_require__(39132), EMPTY_SET = new Set, getConnectionsByOriginModule = set => {
const map = new Map;
let lastList, lastModule = 0;
for (const connection of set) {
const {originModule} = connection;
if (lastModule === originModule) lastList.push(connection); else {
lastModule = originModule;
const list = map.get(originModule);
if (void 0 !== list) lastList = list, list.push(connection); else {
const list = [ connection ];
lastList = list, map.set(originModule, list);
}
}
}
return map;
}, getConnectionsByModule = set => {
const map = new Map;
let lastList, lastModule = 0;
for (const connection of set) {
const {module} = connection;
if (lastModule === module) lastList.push(connection); else {
lastModule = module;
const list = map.get(module);
if (void 0 !== list) lastList = list, list.push(connection); else {
const list = [ connection ];
lastList = list, map.set(module, list);
}
}
}
return map;
};
class ModuleGraphModule {
constructor() {
this.incomingConnections = new SortableSet, this.outgoingConnections = void 0, this.issuer = void 0, 
this.optimizationBailout = [], this.exports = new ExportsInfo, this.preOrderIndex = null, 
this.postOrderIndex = null, this.depth = null, this.profile = void 0, this.async = !1, 
this._unassignedConnections = void 0;
}
}
const moduleGraphForModuleMap = new WeakMap, deprecateMap = new Map;
module.exports = class {
constructor() {
this._dependencyMap = new WeakMap, this._moduleMap = new Map, this._metaMap = new WeakMap, 
this._cache = void 0, this._moduleMemCaches = void 0;
}
_getModuleGraphModule(module) {
let mgm = this._moduleMap.get(module);
return void 0 === mgm && (mgm = new ModuleGraphModule, this._moduleMap.set(module, mgm)), 
mgm;
}
setParents(dependency, block, module, indexInBlock = -1) {
dependency._parentDependenciesBlockIndex = indexInBlock, dependency._parentDependenciesBlock = block, 
dependency._parentModule = module;
}
getParentModule(dependency) {
return dependency._parentModule;
}
getParentBlock(dependency) {
return dependency._parentDependenciesBlock;
}
getParentBlockIndex(dependency) {
return dependency._parentDependenciesBlockIndex;
}
setResolvedModule(originModule, dependency, module) {
const connection = new ModuleGraphConnection(originModule, dependency, module, void 0, dependency.weak, dependency.getCondition(this));
if (this._getModuleGraphModule(module).incomingConnections.add(connection), originModule) {
const mgm = this._getModuleGraphModule(originModule);
void 0 === mgm._unassignedConnections && (mgm._unassignedConnections = []), mgm._unassignedConnections.push(connection), 
void 0 === mgm.outgoingConnections && (mgm.outgoingConnections = new SortableSet), 
mgm.outgoingConnections.add(connection);
} else this._dependencyMap.set(dependency, connection);
}
updateModule(dependency, module) {
const connection = this.getConnection(dependency);
if (connection.module === module) return;
const newConnection = connection.clone();
newConnection.module = module, this._dependencyMap.set(dependency, newConnection), 
connection.setActive(!1);
this._getModuleGraphModule(connection.originModule).outgoingConnections.add(newConnection);
this._getModuleGraphModule(module).incomingConnections.add(newConnection);
}
removeConnection(dependency) {
const connection = this.getConnection(dependency);
this._getModuleGraphModule(connection.module).incomingConnections.delete(connection);
this._getModuleGraphModule(connection.originModule).outgoingConnections.delete(connection), 
this._dependencyMap.set(dependency, null);
}
addExplanation(dependency, explanation) {
this.getConnection(dependency).addExplanation(explanation);
}
cloneModuleAttributes(sourceModule, targetModule) {
const oldMgm = this._getModuleGraphModule(sourceModule), newMgm = this._getModuleGraphModule(targetModule);
newMgm.postOrderIndex = oldMgm.postOrderIndex, newMgm.preOrderIndex = oldMgm.preOrderIndex, 
newMgm.depth = oldMgm.depth, newMgm.exports = oldMgm.exports, newMgm.async = oldMgm.async;
}
removeModuleAttributes(module) {
const mgm = this._getModuleGraphModule(module);
mgm.postOrderIndex = null, mgm.preOrderIndex = null, mgm.depth = null, mgm.async = !1;
}
removeAllModuleAttributes() {
for (const mgm of this._moduleMap.values()) mgm.postOrderIndex = null, mgm.preOrderIndex = null, 
mgm.depth = null, mgm.async = !1;
}
moveModuleConnections(oldModule, newModule, filterConnection) {
if (oldModule === newModule) return;
const oldMgm = this._getModuleGraphModule(oldModule), newMgm = this._getModuleGraphModule(newModule), oldConnections = oldMgm.outgoingConnections;
if (void 0 !== oldConnections) {
void 0 === newMgm.outgoingConnections && (newMgm.outgoingConnections = new SortableSet);
const newConnections = newMgm.outgoingConnections;
for (const connection of oldConnections) filterConnection(connection) && (connection.originModule = newModule, 
newConnections.add(connection), oldConnections.delete(connection));
}
const oldConnections2 = oldMgm.incomingConnections, newConnections2 = newMgm.incomingConnections;
for (const connection of oldConnections2) filterConnection(connection) && (connection.module = newModule, 
newConnections2.add(connection), oldConnections2.delete(connection));
}
copyOutgoingModuleConnections(oldModule, newModule, filterConnection) {
if (oldModule === newModule) return;
const oldMgm = this._getModuleGraphModule(oldModule), newMgm = this._getModuleGraphModule(newModule), oldConnections = oldMgm.outgoingConnections;
if (void 0 !== oldConnections) {
void 0 === newMgm.outgoingConnections && (newMgm.outgoingConnections = new SortableSet);
const newConnections = newMgm.outgoingConnections;
for (const connection of oldConnections) if (filterConnection(connection)) {
const newConnection = connection.clone();
if (newConnection.originModule = newModule, newConnections.add(newConnection), void 0 !== newConnection.module) {
this._getModuleGraphModule(newConnection.module).incomingConnections.add(newConnection);
}
}
}
}
addExtraReason(module, explanation) {
this._getModuleGraphModule(module).incomingConnections.add(new ModuleGraphConnection(null, null, module, explanation));
}
getResolvedModule(dependency) {
const connection = this.getConnection(dependency);
return void 0 !== connection ? connection.resolvedModule : null;
}
getConnection(dependency) {
const connection = this._dependencyMap.get(dependency);
if (void 0 !== connection) return null === connection ? void 0 : connection;
{
const module = this.getParentModule(dependency);
if (void 0 !== module) {
const mgm = this._getModuleGraphModule(module);
if (mgm._unassignedConnections && 0 !== mgm._unassignedConnections.length) {
let foundConnection;
for (const connection of mgm._unassignedConnections) this._dependencyMap.set(connection.dependency, connection), 
connection.dependency === dependency && (foundConnection = connection);
if (mgm._unassignedConnections.length = 0, void 0 !== foundConnection) return foundConnection;
}
}
this._dependencyMap.set(dependency, null);
}
}
getModule(dependency) {
const connection = this.getConnection(dependency);
return void 0 !== connection ? connection.module : null;
}
getOrigin(dependency) {
const connection = this.getConnection(dependency);
return void 0 !== connection ? connection.originModule : null;
}
getResolvedOrigin(dependency) {
const connection = this.getConnection(dependency);
return void 0 !== connection ? connection.resolvedOriginModule : null;
}
getIncomingConnections(module) {
return this._getModuleGraphModule(module).incomingConnections;
}
getOutgoingConnections(module) {
const connections = this._getModuleGraphModule(module).outgoingConnections;
return void 0 === connections ? EMPTY_SET : connections;
}
getIncomingConnectionsByOriginModule(module) {
return this._getModuleGraphModule(module).incomingConnections.getFromUnorderedCache(getConnectionsByOriginModule);
}
getOutgoingConnectionsByModule(module) {
const connections = this._getModuleGraphModule(module).outgoingConnections;
return void 0 === connections ? void 0 : connections.getFromUnorderedCache(getConnectionsByModule);
}
getProfile(module) {
return this._getModuleGraphModule(module).profile;
}
setProfile(module, profile) {
this._getModuleGraphModule(module).profile = profile;
}
getIssuer(module) {
return this._getModuleGraphModule(module).issuer;
}
setIssuer(module, issuer) {
this._getModuleGraphModule(module).issuer = issuer;
}
setIssuerIfUnset(module, issuer) {
const mgm = this._getModuleGraphModule(module);
void 0 === mgm.issuer && (mgm.issuer = issuer);
}
getOptimizationBailout(module) {
return this._getModuleGraphModule(module).optimizationBailout;
}
getProvidedExports(module) {
return this._getModuleGraphModule(module).exports.getProvidedExports();
}
isExportProvided(module, exportName) {
const result = this._getModuleGraphModule(module).exports.isExportProvided(exportName);
return void 0 === result ? null : result;
}
getExportsInfo(module) {
return this._getModuleGraphModule(module).exports;
}
getExportInfo(module, exportName) {
return this._getModuleGraphModule(module).exports.getExportInfo(exportName);
}
getReadOnlyExportInfo(module, exportName) {
return this._getModuleGraphModule(module).exports.getReadOnlyExportInfo(exportName);
}
getUsedExports(module, runtime) {
return this._getModuleGraphModule(module).exports.getUsedExports(runtime);
}
getPreOrderIndex(module) {
return this._getModuleGraphModule(module).preOrderIndex;
}
getPostOrderIndex(module) {
return this._getModuleGraphModule(module).postOrderIndex;
}
setPreOrderIndex(module, index) {
this._getModuleGraphModule(module).preOrderIndex = index;
}
setPreOrderIndexIfUnset(module, index) {
const mgm = this._getModuleGraphModule(module);
return null === mgm.preOrderIndex && (mgm.preOrderIndex = index, !0);
}
setPostOrderIndex(module, index) {
this._getModuleGraphModule(module).postOrderIndex = index;
}
setPostOrderIndexIfUnset(module, index) {
const mgm = this._getModuleGraphModule(module);
return null === mgm.postOrderIndex && (mgm.postOrderIndex = index, !0);
}
getDepth(module) {
return this._getModuleGraphModule(module).depth;
}
setDepth(module, depth) {
this._getModuleGraphModule(module).depth = depth;
}
setDepthIfLower(module, depth) {
const mgm = this._getModuleGraphModule(module);
return (null === mgm.depth || mgm.depth > depth) && (mgm.depth = depth, !0);
}
isAsync(module) {
return this._getModuleGraphModule(module).async;
}
setAsync(module) {
this._getModuleGraphModule(module).async = !0;
}
getMeta(thing) {
let meta = this._metaMap.get(thing);
return void 0 === meta && (meta = Object.create(null), this._metaMap.set(thing, meta)), 
meta;
}
getMetaIfExisting(thing) {
return this._metaMap.get(thing);
}
freeze(cacheStage) {
this._cache = new WeakTupleMap, this._cacheStage = cacheStage;
}
unfreeze() {
this._cache = void 0, this._cacheStage = void 0;
}
cached(fn, ...args) {
return void 0 === this._cache ? fn(this, ...args) : this._cache.provide(fn, ...args, (() => fn(this, ...args)));
}
setModuleMemCaches(moduleMemCaches) {
this._moduleMemCaches = moduleMemCaches;
}
dependencyCacheProvide(dependency, ...args) {
const fn = args.pop();
if (this._moduleMemCaches && this._cacheStage) {
const memCache = this._moduleMemCaches.get(this.getParentModule(dependency));
if (void 0 !== memCache) return memCache.provide(dependency, this._cacheStage, ...args, (() => fn(this, dependency, ...args)));
}
return void 0 === this._cache ? fn(this, dependency, ...args) : this._cache.provide(dependency, ...args, (() => fn(this, dependency, ...args)));
}
static getModuleGraphForModule(module, deprecateMessage, deprecationCode) {
const fn = deprecateMap.get(deprecateMessage);
if (fn) return fn(module);
const newFn = util.deprecate((module => {
const moduleGraph = moduleGraphForModuleMap.get(module);
if (!moduleGraph) throw new Error(deprecateMessage + "There was no ModuleGraph assigned to the Module for backward-compat (Use the new API)");
return moduleGraph;
}), deprecateMessage + ": Use new ModuleGraph API", deprecationCode);
return deprecateMap.set(deprecateMessage, newFn), newFn(module);
}
static setModuleGraphForModule(module, moduleGraph) {
moduleGraphForModuleMap.set(module, moduleGraph);
}
static clearModuleGraphForModule(module) {
moduleGraphForModuleMap.delete(module);
}
}, module.exports.ModuleGraphConnection = ModuleGraphConnection;
},
63867: module => {
"use strict";
const TRANSITIVE_ONLY = Symbol("transitive only"), CIRCULAR_CONNECTION = Symbol("circular connection");
class ModuleGraphConnection {
constructor(originModule, dependency, module, explanation, weak = !1, condition) {
this.originModule = originModule, this.resolvedOriginModule = originModule, this.dependency = dependency, 
this.resolvedModule = module, this.module = module, this.weak = weak, this.conditional = !!condition, 
this._active = !1 !== condition, this.condition = condition || void 0, this.explanations = void 0, 
explanation && (this.explanations = new Set, this.explanations.add(explanation));
}
clone() {
const clone = new ModuleGraphConnection(this.resolvedOriginModule, this.dependency, this.resolvedModule, void 0, this.weak, this.condition);
return clone.originModule = this.originModule, clone.module = this.module, clone.conditional = this.conditional, 
clone._active = this._active, this.explanations && (clone.explanations = new Set(this.explanations)), 
clone;
}
addCondition(condition) {
if (this.conditional) {
const old = this.condition;
this.condition = (c, r) => {
return a = old(c, r), b = condition(c, r), !1 !== a && !1 !== b && (!0 === a ? b : !0 === b ? a : a === CIRCULAR_CONNECTION ? b : a);
var a, b;
};
} else this._active && (this.conditional = !0, this.condition = condition);
}
addExplanation(explanation) {
void 0 === this.explanations && (this.explanations = new Set), this.explanations.add(explanation);
}
get explanation() {
return void 0 === this.explanations ? "" : Array.from(this.explanations).join(" ");
}
get active() {
throw new Error("Use getActiveState instead");
}
isActive(runtime) {
return this.conditional ? !1 !== this.condition(this, runtime) : this._active;
}
isTargetActive(runtime) {
return this.conditional ? !0 === this.condition(this, runtime) : this._active;
}
getActiveState(runtime) {
return this.conditional ? this.condition(this, runtime) : this._active;
}
setActive(value) {
this.conditional = !1, this._active = value;
}
set active(value) {
throw new Error("Use setActive instead");
}
}
module.exports = ModuleGraphConnection, module.exports.addConnectionStates = (a, b) => !0 === a || !0 === b || (!1 === a ? b : !1 === b ? a : a === TRANSITIVE_ONLY ? b : a), 
module.exports.TRANSITIVE_ONLY = TRANSITIVE_ONLY, module.exports.CIRCULAR_CONNECTION = CIRCULAR_CONNECTION;
},
45959: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module, error) {
super(), this.name = "ModuleHashingError", this.error = error, this.message = error.message, 
this.details = error.stack, this.module = module;
}
};
},
69240: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, RawSource, CachedSource} = __webpack_require__(37946), {UsageState} = __webpack_require__(74603), Template = __webpack_require__(88370), JavascriptModulesPlugin = __webpack_require__(18362), printExportsInfoToSource = (source, indent, exportsInfo, moduleGraph, requestShortener, alreadyPrinted = new Set) => {
const otherExportsInfo = exportsInfo.otherExportsInfo;
let alreadyPrintedExports = 0;
const printedExports = [];
for (const exportInfo of exportsInfo.orderedExports) alreadyPrinted.has(exportInfo) ? alreadyPrintedExports++ : (alreadyPrinted.add(exportInfo), 
printedExports.push(exportInfo));
let showOtherExports = !1;
alreadyPrinted.has(otherExportsInfo) ? alreadyPrintedExports++ : (alreadyPrinted.add(otherExportsInfo), 
showOtherExports = !0);
for (const exportInfo of printedExports) {
const target = exportInfo.getTarget(moduleGraph);
source.add(Template.toComment(`${indent}export ${JSON.stringify(exportInfo.name).slice(1, -1)} [${exportInfo.getProvidedInfo()}] [${exportInfo.getUsedInfo()}] [${exportInfo.getRenameInfo()}]${target ? ` -> ${target.module.readableIdentifier(requestShortener)}${target.export ? ` .${target.export.map((e => JSON.stringify(e).slice(1, -1))).join(".")}` : ""}` : ""}`) + "\n"), 
exportInfo.exportsInfo && printExportsInfoToSource(source, indent + "  ", exportInfo.exportsInfo, moduleGraph, requestShortener, alreadyPrinted);
}
if (alreadyPrintedExports && source.add(Template.toComment(`${indent}... (${alreadyPrintedExports} already listed exports)`) + "\n"), 
showOtherExports) {
const target = otherExportsInfo.getTarget(moduleGraph);
if (target || !1 !== otherExportsInfo.provided || otherExportsInfo.getUsed(void 0) !== UsageState.Unused) {
const title = printedExports.length > 0 || alreadyPrintedExports > 0 ? "other exports" : "exports";
source.add(Template.toComment(`${indent}${title} [${otherExportsInfo.getProvidedInfo()}] [${otherExportsInfo.getUsedInfo()}]${target ? ` -> ${target.module.readableIdentifier(requestShortener)}` : ""}`) + "\n");
}
}
}, caches = new WeakMap;
module.exports = class {
constructor(verbose = !0) {
this._verbose = verbose;
}
apply(compiler) {
const {_verbose: verbose} = this;
compiler.hooks.compilation.tap("ModuleInfoHeaderPlugin", (compilation => {
const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
hooks.renderModulePackage.tap("ModuleInfoHeaderPlugin", ((moduleSource, module, {chunk, chunkGraph, moduleGraph, runtimeTemplate}) => {
const {requestShortener} = runtimeTemplate;
let cacheEntry, cache = caches.get(requestShortener);
if (void 0 === cache) caches.set(requestShortener, cache = new WeakMap), cache.set(module, cacheEntry = {
header: void 0,
full: new WeakMap
}); else if (cacheEntry = cache.get(module), void 0 === cacheEntry) cache.set(module, cacheEntry = {
header: void 0,
full: new WeakMap
}); else if (!verbose) {
const cachedSource = cacheEntry.full.get(moduleSource);
if (void 0 !== cachedSource) return cachedSource;
}
const source = new ConcatSource;
let header = cacheEntry.header;
if (void 0 === header) {
const reqStr = module.readableIdentifier(requestShortener).replace(/\*\//g, "*_/"), reqStrStar = "*".repeat(reqStr.length);
header = new RawSource(`/*!****${reqStrStar}****!*\\\n  !*** ${reqStr} ***!\n  \\****${reqStrStar}****/\n`), 
cacheEntry.header = header;
}
if (source.add(header), verbose) {
const exportsType = module.buildMeta.exportsType;
if (source.add(Template.toComment(exportsType ? `${exportsType} exports` : "unknown exports (runtime-defined)") + "\n"), 
exportsType) {
const exportsInfo = moduleGraph.getExportsInfo(module);
printExportsInfoToSource(source, "", exportsInfo, moduleGraph, requestShortener);
}
source.add(Template.toComment(`runtime requirements: ${(iterable => {
let str = "", first = !0;
for (const item of iterable) first ? first = !1 : str += ", ", str += item;
return str;
})(chunkGraph.getModuleRuntimeRequirements(module, chunk.runtime))}`) + "\n");
const optimizationBailout = moduleGraph.getOptimizationBailout(module);
if (optimizationBailout) for (const text of optimizationBailout) {
let code;
code = "function" == typeof text ? text(requestShortener) : text, source.add(Template.toComment(`${code}`) + "\n");
}
return source.add(moduleSource), source;
}
{
source.add(moduleSource);
const cachedSource = new CachedSource(source);
return cacheEntry.full.set(moduleSource, cachedSource), cachedSource;
}
})), hooks.chunkHash.tap("ModuleInfoHeaderPlugin", ((chunk, hash) => {
hash.update("ModuleInfoHeaderPlugin"), hash.update("1");
}));
}));
}
};
},
98674: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), previouslyPolyfilledBuiltinModules = {
assert: "assert/",
buffer: "buffer/",
console: "console-browserify",
constants: "constants-browserify",
crypto: "crypto-browserify",
domain: "domain-browser",
events: "events/",
http: "stream-http",
https: "https-browserify",
os: "os-browserify/browser",
path: "path-browserify",
punycode: "punycode/",
process: "process/browser",
querystring: "querystring-es3",
stream: "stream-browserify",
_stream_duplex: "readable-stream/duplex",
_stream_passthrough: "readable-stream/passthrough",
_stream_readable: "readable-stream/readable",
_stream_transform: "readable-stream/transform",
_stream_writable: "readable-stream/writable",
string_decoder: "string_decoder/",
sys: "util/",
timers: "timers-browserify",
tty: "tty-browserify",
url: "url/",
util: "util/",
vm: "vm-browserify",
zlib: "browserify-zlib"
};
module.exports = class extends WebpackError {
constructor(module, err, loc) {
let message = `Module not found: ${err.toString()}`;
const match = err.message.match(/Can't resolve '([^']+)'/);
if (match) {
const request = match[1], alias = previouslyPolyfilledBuiltinModules[request];
if (alias) {
const pathIndex = alias.indexOf("/"), dependency = pathIndex > 0 ? alias.slice(0, pathIndex) : alias;
message += "\n\nBREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.\nThis is no longer the case. Verify if you need this module and configure a polyfill for it.\n\n", 
message += `If you want to include a polyfill, you need to:\n\t- add a fallback 'resolve.fallback: { "${request}": require.resolve("${alias}") }'\n\t- install '${dependency}'\n`, 
message += `If you don't want to include a polyfill, you can use an empty module like this:\n\tresolve.fallback: { "${request}": false }`;
}
}
super(message), this.name = "ModuleNotFoundError", this.details = err.details, this.module = module, 
this.error = err, this.loc = loc;
}
};
},
35452: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898), WASM_HEADER = Buffer.from([ 0, 97, 115, 109 ]);
class ModuleParseError extends WebpackError {
constructor(source, err, loaders, type) {
let loc, message = "Module parse failed: " + (err && err.message);
if ((Buffer.isBuffer(source) && source.slice(0, 4).equals(WASM_HEADER) || "string" == typeof source && /^\0asm/.test(source)) && !type.startsWith("webassembly") ? (message += "\nThe module seem to be a WebAssembly module, but module is not flagged as WebAssembly module for webpack.", 
message += "\nBREAKING CHANGE: Since webpack 5 WebAssembly is not enabled by default and flagged as experimental feature.", 
message += "\nYou need to enable one of the WebAssembly experiments via 'experiments.asyncWebAssembly: true' (based on async modules) or 'experiments.syncWebAssembly: true' (like webpack 4, deprecated).", 
message += "\nFor files that transpile to WebAssembly, make sure to set the module type in the 'module.rules' section of the config (e. g. 'type: \"webassembly/async\"').") : loaders ? loaders.length >= 1 ? (message += `\nFile was processed with these loaders:${loaders.map((loader => `\n * ${loader}`)).join("")}`, 
message += "\nYou may need an additional loader to handle the result of these loaders.") : message += "\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders" : message += "\nYou may need an appropriate loader to handle this file type.", 
err && err.loc && "object" == typeof err.loc && "number" == typeof err.loc.line) {
var lineNumber = err.loc.line;
if (Buffer.isBuffer(source) || /[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(source)) message += "\n(Source code omitted for this binary file)"; else {
const sourceLines = source.split(/\r?\n/), start = Math.max(0, lineNumber - 3), linesBefore = sourceLines.slice(start, lineNumber - 1), theLine = sourceLines[lineNumber - 1], linesAfter = sourceLines.slice(lineNumber, lineNumber + 2);
message += linesBefore.map((l => `\n| ${l}`)).join("") + `\n> ${theLine}` + linesAfter.map((l => `\n| ${l}`)).join("");
}
loc = {
start: err.loc
};
} else err && err.stack && (message += "\n" + err.stack);
super(message), this.name = "ModuleParseError", this.loc = loc, this.error = err;
}
serialize(context) {
const {write} = context;
write(this.error), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.error = read(), super.deserialize(context);
}
}
makeSerializable(ModuleParseError, "webpack/lib/ModuleParseError"), module.exports = ModuleParseError;
},
40493: module => {
"use strict";
module.exports = class {
constructor() {
this.startTime = Date.now(), this.factoryStartTime = 0, this.factoryEndTime = 0, 
this.factory = 0, this.factoryParallelismFactor = 0, this.restoringStartTime = 0, 
this.restoringEndTime = 0, this.restoring = 0, this.restoringParallelismFactor = 0, 
this.integrationStartTime = 0, this.integrationEndTime = 0, this.integration = 0, 
this.integrationParallelismFactor = 0, this.buildingStartTime = 0, this.buildingEndTime = 0, 
this.building = 0, this.buildingParallelismFactor = 0, this.storingStartTime = 0, 
this.storingEndTime = 0, this.storing = 0, this.storingParallelismFactor = 0, this.additionalFactoryTimes = void 0, 
this.additionalFactories = 0, this.additionalFactoriesParallelismFactor = 0, this.additionalIntegration = 0;
}
markFactoryStart() {
this.factoryStartTime = Date.now();
}
markFactoryEnd() {
this.factoryEndTime = Date.now(), this.factory = this.factoryEndTime - this.factoryStartTime;
}
markRestoringStart() {
this.restoringStartTime = Date.now();
}
markRestoringEnd() {
this.restoringEndTime = Date.now(), this.restoring = this.restoringEndTime - this.restoringStartTime;
}
markIntegrationStart() {
this.integrationStartTime = Date.now();
}
markIntegrationEnd() {
this.integrationEndTime = Date.now(), this.integration = this.integrationEndTime - this.integrationStartTime;
}
markBuildingStart() {
this.buildingStartTime = Date.now();
}
markBuildingEnd() {
this.buildingEndTime = Date.now(), this.building = this.buildingEndTime - this.buildingStartTime;
}
markStoringStart() {
this.storingStartTime = Date.now();
}
markStoringEnd() {
this.storingEndTime = Date.now(), this.storing = this.storingEndTime - this.storingStartTime;
}
mergeInto(realProfile) {
realProfile.additionalFactories = this.factory, (realProfile.additionalFactoryTimes = realProfile.additionalFactoryTimes || []).push({
start: this.factoryStartTime,
end: this.factoryEndTime
});
}
};
},
47809: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module, err) {
let details, message = "Module restore failed: ";
if (null !== err && "object" == typeof err) if ("string" == typeof err.stack && err.stack) {
message += err.stack;
} else "string" == typeof err.message && err.message ? message += err.message : message += err; else message += String(err);
super(message), this.name = "ModuleRestoreError", this.details = details, this.module = module, 
this.error = err;
}
};
},
86193: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module, err) {
let details, message = "Module storing failed: ";
if (null !== err && "object" == typeof err) if ("string" == typeof err.stack && err.stack) {
message += err.stack;
} else "string" == typeof err.message && err.message ? message += err.message : message += err; else message += String(err);
super(message), this.name = "ModuleStoreError", this.details = details, this.module = module, 
this.error = err;
}
};
},
98043: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), getJavascriptModulesPlugin = __webpack_require__(98216)((() => __webpack_require__(18362)));
class ModuleTemplate {
constructor(runtimeTemplate, compilation) {
this._runtimeTemplate = runtimeTemplate, this.type = "javascript", this.hooks = Object.freeze({
content: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderModuleContent.tap(options, ((source, module, renderContext) => fn(source, module, renderContext, renderContext.dependencyTemplates)));
}), "ModuleTemplate.hooks.content is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModuleContent instead)", "DEP_MODULE_TEMPLATE_CONTENT")
},
module: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderModuleContent.tap(options, ((source, module, renderContext) => fn(source, module, renderContext, renderContext.dependencyTemplates)));
}), "ModuleTemplate.hooks.module is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModuleContent instead)", "DEP_MODULE_TEMPLATE_MODULE")
},
render: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderModuleContainer.tap(options, ((source, module, renderContext) => fn(source, module, renderContext, renderContext.dependencyTemplates)));
}), "ModuleTemplate.hooks.render is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer instead)", "DEP_MODULE_TEMPLATE_RENDER")
},
package: {
tap: util.deprecate(((options, fn) => {
getJavascriptModulesPlugin().getCompilationHooks(compilation).renderModulePackage.tap(options, ((source, module, renderContext) => fn(source, module, renderContext, renderContext.dependencyTemplates)));
}), "ModuleTemplate.hooks.package is deprecated (use JavascriptModulesPlugin.getCompilationHooks().renderModulePackage instead)", "DEP_MODULE_TEMPLATE_PACKAGE")
},
hash: {
tap: util.deprecate(((options, fn) => {
compilation.hooks.fullHash.tap(options, fn);
}), "ModuleTemplate.hooks.hash is deprecated (use Compilation.hooks.fullHash instead)", "DEP_MODULE_TEMPLATE_HASH")
}
});
}
}
Object.defineProperty(ModuleTemplate.prototype, "runtimeTemplate", {
get: util.deprecate((function() {
return this._runtimeTemplate;
}), "ModuleTemplate.runtimeTemplate is deprecated (use Compilation.runtimeTemplate instead)", "DEP_WEBPACK_CHUNK_TEMPLATE_OUTPUT_OPTIONS")
}), module.exports = ModuleTemplate;
},
99622: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {cleanUp} = __webpack_require__(23516), WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class ModuleWarning extends WebpackError {
constructor(warning, {from = null} = {}) {
let message = "Module Warning";
message += from ? ` (from ${from}):\n` : ": ", warning && "object" == typeof warning && warning.message ? message += warning.message : warning && (message += String(warning)), 
super(message), this.name = "ModuleWarning", this.warning = warning, this.details = warning && "object" == typeof warning && warning.stack ? cleanUp(warning.stack, this.message) : void 0;
}
serialize(context) {
const {write} = context;
write(this.warning), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.warning = read(), super.deserialize(context);
}
}
makeSerializable(ModuleWarning, "webpack/lib/ModuleWarning"), module.exports = ModuleWarning;
},
95400: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), {SyncHook, MultiHook} = __webpack_require__(89991), ConcurrentCompilationError = __webpack_require__(49109), MultiStats = __webpack_require__(89545), MultiWatching = __webpack_require__(99714), ArrayQueue = __webpack_require__(3216);
module.exports = class {
constructor(compilers, options) {
Array.isArray(compilers) || (compilers = Object.keys(compilers).map((name => (compilers[name].name = name, 
compilers[name])))), this.hooks = Object.freeze({
done: new SyncHook([ "stats" ]),
invalid: new MultiHook(compilers.map((c => c.hooks.invalid))),
run: new MultiHook(compilers.map((c => c.hooks.run))),
watchClose: new SyncHook([]),
watchRun: new MultiHook(compilers.map((c => c.hooks.watchRun))),
infrastructureLog: new MultiHook(compilers.map((c => c.hooks.infrastructureLog)))
}), this.compilers = compilers, this._options = {
parallelism: options.parallelism || 1 / 0
}, this.dependencies = new WeakMap, this.running = !1;
const compilerStats = this.compilers.map((() => null));
let doneCompilers = 0;
for (let index = 0; index < this.compilers.length; index++) {
const compiler = this.compilers[index], compilerIndex = index;
let compilerDone = !1;
compiler.hooks.done.tap("MultiCompiler", (stats => {
compilerDone || (compilerDone = !0, doneCompilers++), compilerStats[compilerIndex] = stats, 
doneCompilers === this.compilers.length && this.hooks.done.call(new MultiStats(compilerStats));
})), compiler.hooks.invalid.tap("MultiCompiler", (() => {
compilerDone && (compilerDone = !1, doneCompilers--);
}));
}
}
get options() {
return Object.assign(this.compilers.map((c => c.options)), this._options);
}
get outputPath() {
let commonPath = this.compilers[0].outputPath;
for (const compiler of this.compilers) for (;0 !== compiler.outputPath.indexOf(commonPath) && /[/\\]/.test(commonPath); ) commonPath = commonPath.replace(/[/\\][^/\\]*$/, "");
return commonPath || "/" !== this.compilers[0].outputPath[0] ? commonPath : "/";
}
get inputFileSystem() {
throw new Error("Cannot read inputFileSystem of a MultiCompiler");
}
get outputFileSystem() {
throw new Error("Cannot read outputFileSystem of a MultiCompiler");
}
get watchFileSystem() {
throw new Error("Cannot read watchFileSystem of a MultiCompiler");
}
get intermediateFileSystem() {
throw new Error("Cannot read outputFileSystem of a MultiCompiler");
}
set inputFileSystem(value) {
for (const compiler of this.compilers) compiler.inputFileSystem = value;
}
set outputFileSystem(value) {
for (const compiler of this.compilers) compiler.outputFileSystem = value;
}
set watchFileSystem(value) {
for (const compiler of this.compilers) compiler.watchFileSystem = value;
}
set intermediateFileSystem(value) {
for (const compiler of this.compilers) compiler.intermediateFileSystem = value;
}
getInfrastructureLogger(name) {
return this.compilers[0].getInfrastructureLogger(name);
}
setDependencies(compiler, dependencies) {
this.dependencies.set(compiler, dependencies);
}
validateDependencies(callback) {
const edges = new Set, missing = [], targetFound = compiler => {
for (const edge of edges) if (edge.target === compiler) return !0;
return !1;
}, sortEdges = (e1, e2) => e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);
for (const source of this.compilers) {
const dependencies = this.dependencies.get(source);
if (dependencies) for (const dep of dependencies) {
const target = this.compilers.find((c => c.name === dep));
target ? edges.add({
source,
target
}) : missing.push(dep);
}
}
const errors = missing.map((m => `Compiler dependency \`${m}\` not found.`)), stack = this.compilers.filter((c => !targetFound(c)));
for (;stack.length > 0; ) {
const current = stack.pop();
for (const edge of edges) if (edge.source === current) {
edges.delete(edge);
const target = edge.target;
targetFound(target) || stack.push(target);
}
}
if (edges.size > 0) {
const lines = Array.from(edges).sort(sortEdges).map((edge => `${edge.source.name} -> ${edge.target.name}`));
lines.unshift("Circular dependency found in compiler dependencies."), errors.unshift(lines.join("\n"));
}
if (errors.length > 0) {
const message = errors.join("\n");
return callback(new Error(message)), !1;
}
return !0;
}
runWithDependencies(compilers, fn, callback) {
const fulfilledNames = new Set;
let remainingCompilers = compilers;
const isDependencyFulfilled = d => fulfilledNames.has(d), getReadyCompilers = () => {
let readyCompilers = [], list = remainingCompilers;
remainingCompilers = [];
for (const c of list) {
const dependencies = this.dependencies.get(c);
!dependencies || dependencies.every(isDependencyFulfilled) ? readyCompilers.push(c) : remainingCompilers.push(c);
}
return readyCompilers;
}, runCompilers = callback => {
if (0 === remainingCompilers.length) return callback();
asyncLib.map(getReadyCompilers(), ((compiler, callback) => {
fn(compiler, (err => {
if (err) return callback(err);
fulfilledNames.add(compiler.name), runCompilers(callback);
}));
}), callback);
};
runCompilers(callback);
}
_runGraph(setup, run, callback) {
const nodes = this.compilers.map((compiler => ({
compiler,
setupResult: void 0,
result: void 0,
state: "blocked",
children: [],
parents: []
}))), compilerToNode = new Map;
for (const node of nodes) compilerToNode.set(node.compiler.name, node);
for (const node of nodes) {
const dependencies = this.dependencies.get(node.compiler);
if (dependencies) for (const dep of dependencies) {
const parent = compilerToNode.get(dep);
node.parents.push(parent), parent.children.push(node);
}
}
const queue = new ArrayQueue;
for (const node of nodes) 0 === node.parents.length && (node.state = "queued", queue.enqueue(node));
let errored = !1, running = 0;
const parallelism = this._options.parallelism, nodeDone = (node, err, stats) => {
if (!errored) {
if (err) return errored = !0, asyncLib.each(nodes, ((node, callback) => {
node.compiler.watching ? node.compiler.watching.close(callback) : callback();
}), (() => callback(err)));
if (node.result = stats, running--, "running" === node.state) {
node.state = "done";
for (const child of node.children) "blocked" === child.state && queue.enqueue(child);
} else "running-outdated" === node.state && (node.state = "blocked", queue.enqueue(node));
processQueue();
}
}, nodeInvalidFromParent = node => {
"done" === node.state ? node.state = "blocked" : "running" === node.state && (node.state = "running-outdated");
for (const child of node.children) nodeInvalidFromParent(child);
}, nodeInvalid = node => {
"done" === node.state ? node.state = "pending" : "running" === node.state && (node.state = "running-outdated");
for (const child of node.children) nodeInvalidFromParent(child);
}, setupResults = [];
nodes.forEach(((node, i) => {
setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), (() => "starting" !== node.state && "running" !== node.state), (() => (node => {
nodeInvalid(node), "pending" === node.state && (node.state = "blocked"), "blocked" === node.state && (queue.enqueue(node), 
processQueue());
})(node)), (() => nodeInvalid(node))));
}));
let processing = !0;
const processQueue = () => {
processing || (processing = !0, process.nextTick(processQueueWorker));
}, processQueueWorker = () => {
for (;running < parallelism && queue.length > 0 && !errored; ) {
const node = queue.dequeue();
("queued" === node.state || "blocked" === node.state && node.parents.every((p => "done" === p.state))) && (running++, 
node.state = "starting", run(node.compiler, node.setupResult, nodeDone.bind(null, node)), 
node.state = "running");
}
if (processing = !1, !errored && 0 === running && nodes.every((node => "done" === node.state))) {
const stats = [];
for (const node of nodes) {
const result = node.result;
result && (node.result = void 0, stats.push(result));
}
stats.length > 0 && callback(null, new MultiStats(stats));
}
};
return processQueueWorker(), setupResults;
}
watch(watchOptions, handler) {
if (this.running) return handler(new ConcurrentCompilationError);
if (this.running = !0, this.validateDependencies(handler)) {
const watchings = this._runGraph(((compiler, idx, callback, isBlocked, setChanged, setInvalid) => {
const watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);
return watching && (watching._onInvalid = setInvalid, watching._onChange = setChanged, 
watching._isBlocked = isBlocked), watching;
}), ((compiler, watching, callback) => {
compiler.watching === watching && (watching.running || watching.invalidate());
}), handler);
return new MultiWatching(watchings, this);
}
return new MultiWatching([], this);
}
run(callback) {
if (this.running) return callback(new ConcurrentCompilationError);
this.running = !0, this.validateDependencies(callback) && this._runGraph((() => {}), ((compiler, setupResult, callback) => compiler.run(callback)), ((err, stats) => {
if (this.running = !1, void 0 !== callback) return callback(err, stats);
}));
}
purgeInputFileSystem() {
for (const compiler of this.compilers) compiler.inputFileSystem && compiler.inputFileSystem.purge && compiler.inputFileSystem.purge();
}
close(callback) {
asyncLib.each(this.compilers, ((compiler, callback) => {
compiler.close(callback);
}), callback);
}
};
},
89545: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const identifierUtils = __webpack_require__(63264);
module.exports = class {
constructor(stats) {
this.stats = stats;
}
get hash() {
return this.stats.map((stat => stat.hash)).join("");
}
hasErrors() {
return this.stats.some((stat => stat.hasErrors()));
}
hasWarnings() {
return this.stats.some((stat => stat.hasWarnings()));
}
_createChildOptions(options, context) {
options || (options = {});
const {children: childrenOptions, ...baseOptions} = "string" == typeof options ? {
preset: options
} : options, children = this.stats.map(((stat, idx) => {
const childOptions = Array.isArray(childrenOptions) ? childrenOptions[idx] : childrenOptions;
return stat.compilation.createStatsOptions({
...baseOptions,
..."string" == typeof childOptions ? {
preset: childOptions
} : childOptions && "object" == typeof childOptions ? childOptions : void 0
}, context);
}));
return {
version: children.every((o => o.version)),
hash: children.every((o => o.hash)),
errorsCount: children.every((o => o.errorsCount)),
warningsCount: children.every((o => o.warningsCount)),
errors: children.every((o => o.errors)),
warnings: children.every((o => o.warnings)),
children
};
}
toJson(options) {
options = this._createChildOptions(options, {
forToString: !1
});
const obj = {};
obj.children = this.stats.map(((stat, idx) => {
const obj = stat.toJson(options.children[idx]), compilationName = stat.compilation.name, name = compilationName && identifierUtils.makePathsRelative(options.context, compilationName, stat.compilation.compiler.root);
return obj.name = name, obj;
})), options.version && (obj.version = obj.children[0].version), options.hash && (obj.hash = obj.children.map((j => j.hash)).join(""));
const mapError = (j, obj) => ({
...obj,
compilerPath: obj.compilerPath ? `${j.name}.${obj.compilerPath}` : j.name
});
if (options.errors) {
obj.errors = [];
for (const j of obj.children) for (const i of j.errors) obj.errors.push(mapError(j, i));
}
if (options.warnings) {
obj.warnings = [];
for (const j of obj.children) for (const i of j.warnings) obj.warnings.push(mapError(j, i));
}
if (options.errorsCount) {
obj.errorsCount = 0;
for (const j of obj.children) obj.errorsCount += j.errorsCount;
}
if (options.warningsCount) {
obj.warningsCount = 0;
for (const j of obj.children) obj.warningsCount += j.warningsCount;
}
return obj;
}
toString(options) {
options = this._createChildOptions(options, {
forToString: !0
});
return this.stats.map(((stat, idx) => {
const str = stat.toString(options.children[idx]), compilationName = stat.compilation.name, name = compilationName && identifierUtils.makePathsRelative(options.context, compilationName, stat.compilation.compiler.root).replace(/\|/g, " ");
return str && name ? `${name}:\n${((str, prefix) => prefix + str.replace(/\n([^\n])/g, "\n" + prefix + "$1"))(str, "  ")}` : str;
})).filter(Boolean).join("\n\n");
}
};
},
99714: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947);
module.exports = class {
constructor(watchings, compiler) {
this.watchings = watchings, this.compiler = compiler;
}
invalidate(callback) {
if (callback) asyncLib.each(this.watchings, ((watching, callback) => watching.invalidate(callback)), callback); else for (const watching of this.watchings) watching.invalidate();
}
suspend() {
for (const watching of this.watchings) watching.suspend();
}
resume() {
for (const watching of this.watchings) watching.resume();
}
close(callback) {
asyncLib.forEach(this.watchings, ((watching, finishedCallback) => {
watching.close(finishedCallback);
}), (err => {
this.compiler.hooks.watchClose.call(), "function" == typeof callback && (this.compiler.running = !1, 
callback(err));
}));
}
};
},
18810: module => {
"use strict";
module.exports = class {
apply(compiler) {
compiler.hooks.shouldEmit.tap("NoEmitOnErrorsPlugin", (compilation => {
if (compilation.getStats().hasErrors()) return !1;
})), compiler.hooks.compilation.tap("NoEmitOnErrorsPlugin", (compilation => {
compilation.hooks.shouldRecord.tap("NoEmitOnErrorsPlugin", (() => {
if (compilation.getStats().hasErrors()) return !1;
}));
}));
}
};
},
24575: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor() {
super(), this.name = "NoModeWarning", this.message = "configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value.\nSet 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/";
}
};
},
78160: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class NodeStuffInWebError extends WebpackError {
constructor(loc, expression, description) {
super(`${JSON.stringify(expression)} has been used, it will be undefined in next major version.\n${description}`), 
this.name = "NodeStuffInWebError", this.loc = loc;
}
}
makeSerializable(NodeStuffInWebError, "webpack/lib/NodeStuffInWebError"), module.exports = NodeStuffInWebError;
},
79441: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const NodeStuffInWebError = __webpack_require__(78160), RuntimeGlobals = __webpack_require__(50980), CachedConstDependency = __webpack_require__(26919), ConstDependency = __webpack_require__(30339), {evaluateToString, expressionIsUnsupported} = __webpack_require__(78802), {relative} = __webpack_require__(57075), {parseResource} = __webpack_require__(63264);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
const options = this.options;
compiler.hooks.compilation.tap("NodeStuffPlugin", ((compilation, {normalModuleFactory}) => {
const handler = (parser, parserOptions) => {
if (!1 === parserOptions.node) return;
let localOptions = options;
if (parserOptions.node && (localOptions = {
...localOptions,
...parserOptions.node
}), !1 !== localOptions.global) {
const withWarning = "warn" === localOptions.global;
parser.hooks.expression.for("global").tap("NodeStuffPlugin", (expr => {
const dep = new ConstDependency(RuntimeGlobals.global, expr.range, [ RuntimeGlobals.global ]);
dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), withWarning && parser.state.module.addWarning(new NodeStuffInWebError(dep.loc, "global", "The global namespace object is a Node.js feature and isn't available in browsers."));
})), parser.hooks.rename.for("global").tap("NodeStuffPlugin", (expr => {
const dep = new ConstDependency(RuntimeGlobals.global, expr.range, [ RuntimeGlobals.global ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!1;
}));
}
const setModuleConstant = (expressionName, fn, warning) => {
parser.hooks.expression.for(expressionName).tap("NodeStuffPlugin", (expr => {
const dep = new CachedConstDependency(JSON.stringify(fn(parser.state.module)), expr.range, expressionName);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
warning && parser.state.module.addWarning(new NodeStuffInWebError(dep.loc, expressionName, warning)), 
!0;
}));
}, setConstant = (expressionName, value, warning) => setModuleConstant(expressionName, (() => value), warning), context = compiler.context;
if (localOptions.__filename) {
switch (localOptions.__filename) {
case "mock":
setConstant("__filename", "/index.js");
break;

case "warn-mock":
setConstant("__filename", "/index.js", "__filename is a Node.js feature and isn't available in browsers.");
break;

case !0:
setModuleConstant("__filename", (module => relative(compiler.inputFileSystem, context, module.resource)));
}
parser.hooks.evaluateIdentifier.for("__filename").tap("NodeStuffPlugin", (expr => {
if (!parser.state.module) return;
const resource = parseResource(parser.state.module.resource);
return evaluateToString(resource.path)(expr);
}));
}
if (localOptions.__dirname) {
switch (localOptions.__dirname) {
case "mock":
setConstant("__dirname", "/");
break;

case "warn-mock":
setConstant("__dirname", "/", "__dirname is a Node.js feature and isn't available in browsers.");
break;

case !0:
setModuleConstant("__dirname", (module => relative(compiler.inputFileSystem, context, module.context)));
}
parser.hooks.evaluateIdentifier.for("__dirname").tap("NodeStuffPlugin", (expr => {
if (parser.state.module) return evaluateToString(parser.state.module.context)(expr);
}));
}
parser.hooks.expression.for("require.extensions").tap("NodeStuffPlugin", expressionIsUnsupported(parser, "require.extensions is not supported by webpack. Use a loader instead."));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("NodeStuffPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("NodeStuffPlugin", handler);
}));
}
};
},
3213: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const parseJson = __webpack_require__(73153), {getContext, runLoaders} = __webpack_require__(18043), querystring = __webpack_require__(63477), {HookMap, SyncHook, AsyncSeriesBailHook} = __webpack_require__(89991), {CachedSource, OriginalSource, RawSource, SourceMapSource} = __webpack_require__(37946), Compilation = __webpack_require__(62843), HookWebpackError = __webpack_require__(44741), Module = __webpack_require__(36797), ModuleBuildError = __webpack_require__(2386), ModuleError = __webpack_require__(96063), ModuleGraphConnection = __webpack_require__(63867), ModuleParseError = __webpack_require__(35452), ModuleWarning = __webpack_require__(99622), RuntimeGlobals = __webpack_require__(50980), UnhandledSchemeError = __webpack_require__(48590), WebpackError = __webpack_require__(64326), formatLocation = __webpack_require__(78509), LazySet = __webpack_require__(92585), {isSubset} = __webpack_require__(73974), {getScheme} = __webpack_require__(15686), {compareLocations, concatComparators, compareSelect, keepOriginalOrder} = __webpack_require__(40028), createHash = __webpack_require__(27466), {createFakeHook} = __webpack_require__(33469), {join} = __webpack_require__(57075), {contextify, absolutify, makePathsRelative} = __webpack_require__(63264), makeSerializable = __webpack_require__(45898), memoize = __webpack_require__(98216), getInvalidDependenciesModuleWarning = memoize((() => __webpack_require__(37748))), getValidate = memoize((() => __webpack_require__(33842).validate)), ABSOLUTE_PATH_REGEX = /^([a-zA-Z]:\\|\\\\|\/)/, contextifySourceUrl = (context, source, associatedObjectForCache) => source.startsWith("webpack://") ? source : `webpack://${makePathsRelative(context, source, associatedObjectForCache)}`, contextifySourceMap = (context, sourceMap, associatedObjectForCache) => {
if (!Array.isArray(sourceMap.sources)) return sourceMap;
const {sourceRoot} = sourceMap, mapper = sourceRoot ? sourceRoot.endsWith("/") ? source => source.startsWith("/") ? `${sourceRoot.slice(0, -1)}${source}` : `${sourceRoot}${source}` : source => source.startsWith("/") ? `${sourceRoot}${source}` : `${sourceRoot}/${source}` : source => source, newSources = sourceMap.sources.map((source => contextifySourceUrl(context, mapper(source), associatedObjectForCache)));
return {
...sourceMap,
file: "x",
sourceRoot: void 0,
sources: newSources
};
};
class NonErrorEmittedError extends WebpackError {
constructor(error) {
super(), this.name = "NonErrorEmittedError", this.message = "(Emitted value instead of an instance of Error) " + error;
}
}
makeSerializable(NonErrorEmittedError, "webpack/lib/NormalModule", "NonErrorEmittedError");
const compilationHooksMap = new WeakMap;
class NormalModule extends Module {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
loader: new SyncHook([ "loaderContext", "module" ]),
beforeLoaders: new SyncHook([ "loaders", "module", "loaderContext" ]),
beforeParse: new SyncHook([ "module" ]),
beforeSnapshot: new SyncHook([ "module" ]),
readResourceForScheme: new HookMap((scheme => {
const hook = hooks.readResource.for(scheme);
return createFakeHook({
tap: (options, fn) => hook.tap(options, (loaderContext => fn(loaderContext.resource, loaderContext._module))),
tapAsync: (options, fn) => hook.tapAsync(options, ((loaderContext, callback) => fn(loaderContext.resource, loaderContext._module, callback))),
tapPromise: (options, fn) => hook.tapPromise(options, (loaderContext => fn(loaderContext.resource, loaderContext._module)))
});
})),
readResource: new HookMap((() => new AsyncSeriesBailHook([ "loaderContext" ]))),
needBuild: new AsyncSeriesBailHook([ "module", "context" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor({layer, type, request, userRequest, rawRequest, loaders, resource, resourceResolveData, context, matchResource, parser, parserOptions, generator, generatorOptions, resolveOptions}) {
super(type, context || getContext(resource), layer), this.request = request, this.userRequest = userRequest, 
this.rawRequest = rawRequest, this.binary = /^(asset|webassembly)\b/.test(type), 
this.parser = parser, this.parserOptions = parserOptions, this.generator = generator, 
this.generatorOptions = generatorOptions, this.resource = resource, this.resourceResolveData = resourceResolveData, 
this.matchResource = matchResource, this.loaders = loaders, void 0 !== resolveOptions && (this.resolveOptions = resolveOptions), 
this.error = null, this._source = null, this._sourceSizes = void 0, this._sourceTypes = void 0, 
this._lastSuccessfulBuildMeta = {}, this._forceBuild = !0, this._isEvaluatingSideEffects = !1, 
this._addedSideEffectsBailout = void 0;
}
identifier() {
return null === this.layer ? "javascript/auto" === this.type ? this.request : `${this.type}|${this.request}` : `${this.type}|${this.request}|${this.layer}`;
}
readableIdentifier(requestShortener) {
return requestShortener.shorten(this.userRequest);
}
libIdent(options) {
let ident = contextify(options.context, this.userRequest, options.associatedObjectForCache);
return this.layer && (ident = `(${this.layer})/${ident}`), ident;
}
nameForCondition() {
const resource = this.matchResource || this.resource, idx = resource.indexOf("?");
return idx >= 0 ? resource.slice(0, idx) : resource;
}
updateCacheModule(module) {
super.updateCacheModule(module);
const m = module;
this.binary = m.binary, this.request = m.request, this.userRequest = m.userRequest, 
this.rawRequest = m.rawRequest, this.parser = m.parser, this.parserOptions = m.parserOptions, 
this.generator = m.generator, this.generatorOptions = m.generatorOptions, this.resource = m.resource, 
this.resourceResolveData = m.resourceResolveData, this.context = m.context, this.matchResource = m.matchResource, 
this.loaders = m.loaders;
}
cleanupForCache() {
if (this.buildInfo) {
void 0 === this._sourceTypes && this.getSourceTypes();
for (const type of this._sourceTypes) this.size(type);
}
super.cleanupForCache(), this.parser = void 0, this.parserOptions = void 0, this.generator = void 0, 
this.generatorOptions = void 0;
}
getUnsafeCacheData() {
const data = super.getUnsafeCacheData();
return data.parserOptions = this.parserOptions, data.generatorOptions = this.generatorOptions, 
data;
}
restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
this._restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory);
}
_restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
super._restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory), this.parserOptions = unsafeCacheData.parserOptions, 
this.parser = normalModuleFactory.getParser(this.type, this.parserOptions), this.generatorOptions = unsafeCacheData.generatorOptions, 
this.generator = normalModuleFactory.getGenerator(this.type, this.generatorOptions);
}
createSourceForAsset(context, name, content, sourceMap, associatedObjectForCache) {
if (sourceMap) {
if ("string" == typeof sourceMap && (this.useSourceMap || this.useSimpleSourceMap)) return new OriginalSource(content, contextifySourceUrl(context, sourceMap, associatedObjectForCache));
if (this.useSourceMap) return new SourceMapSource(content, name, contextifySourceMap(context, sourceMap, associatedObjectForCache));
}
return new RawSource(content);
}
_createLoaderContext(resolver, options, compilation, fs, hooks) {
const {requestShortener} = compilation.runtimeTemplate, getCurrentLoaderName = () => {
const currentLoader = this.getCurrentLoader(loaderContext);
return currentLoader ? requestShortener.shorten(currentLoader.loader) : "(not in loader scope)";
}, getResolveContext = () => ({
fileDependencies: {
add: d => loaderContext.addDependency(d)
},
contextDependencies: {
add: d => loaderContext.addContextDependency(d)
},
missingDependencies: {
add: d => loaderContext.addMissingDependency(d)
}
}), getAbsolutify = memoize((() => absolutify.bindCache(compilation.compiler.root))), getAbsolutifyInContext = memoize((() => absolutify.bindContextCache(this.context, compilation.compiler.root))), getContextify = memoize((() => contextify.bindCache(compilation.compiler.root))), getContextifyInContext = memoize((() => contextify.bindContextCache(this.context, compilation.compiler.root))), loaderContext = {
version: 2,
getOptions: schema => {
const loader = this.getCurrentLoader(loaderContext);
let {options} = loader;
if ("string" == typeof options) if (options.startsWith("{") && options.endsWith("}")) try {
options = parseJson(options);
} catch (e) {
throw new Error(`Cannot parse string options: ${e.message}`);
} else options = querystring.parse(options, "&", "=", {
maxKeys: 0
});
if (null == options && (options = {}), schema) {
let match, name = "Loader", baseDataPath = "options";
schema.title && (match = /^(.+) (.+)$/.exec(schema.title)) && ([, name, baseDataPath] = match), 
getValidate()(schema, options, {
name,
baseDataPath
});
}
return options;
},
emitWarning: warning => {
warning instanceof Error || (warning = new NonErrorEmittedError(warning)), this.addWarning(new ModuleWarning(warning, {
from: getCurrentLoaderName()
}));
},
emitError: error => {
error instanceof Error || (error = new NonErrorEmittedError(error)), this.addError(new ModuleError(error, {
from: getCurrentLoaderName()
}));
},
getLogger: name => {
const currentLoader = this.getCurrentLoader(loaderContext);
return compilation.getLogger((() => [ currentLoader && currentLoader.loader, name, this.identifier() ].filter(Boolean).join("|")));
},
resolve(context, request, callback) {
resolver.resolve({}, context, request, getResolveContext(), callback);
},
getResolve(options) {
const child = options ? resolver.withOptions(options) : resolver;
return (context, request, callback) => {
if (!callback) return new Promise(((resolve, reject) => {
child.resolve({}, context, request, getResolveContext(), ((err, result) => {
err ? reject(err) : resolve(result);
}));
}));
child.resolve({}, context, request, getResolveContext(), callback);
};
},
emitFile: (name, content, sourceMap, assetInfo) => {
this.buildInfo.assets || (this.buildInfo.assets = Object.create(null), this.buildInfo.assetsInfo = new Map), 
this.buildInfo.assets[name] = this.createSourceForAsset(options.context, name, content, sourceMap, compilation.compiler.root), 
this.buildInfo.assetsInfo.set(name, assetInfo);
},
addBuildDependency: dep => {
void 0 === this.buildInfo.buildDependencies && (this.buildInfo.buildDependencies = new LazySet), 
this.buildInfo.buildDependencies.add(dep);
},
utils: {
absolutify: (context, request) => context === this.context ? getAbsolutifyInContext()(request) : getAbsolutify()(context, request),
contextify: (context, request) => context === this.context ? getContextifyInContext()(request) : getContextify()(context, request),
createHash: type => createHash(type || compilation.outputOptions.hashFunction)
},
rootContext: options.context,
webpack: !0,
sourceMap: !!this.useSourceMap,
mode: options.mode || "production",
_module: this,
_compilation: compilation,
_compiler: compilation.compiler,
fs
};
return Object.assign(loaderContext, options.loader), hooks.loader.call(loaderContext, this), 
loaderContext;
}
getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
return this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index] ? this.loaders[index] : null;
}
createSource(context, content, sourceMap, associatedObjectForCache) {
if (Buffer.isBuffer(content)) return new RawSource(content);
if (!this.identifier) return new RawSource(content);
const identifier = this.identifier();
return this.useSourceMap && sourceMap ? new SourceMapSource(content, contextifySourceUrl(context, identifier, associatedObjectForCache), contextifySourceMap(context, sourceMap, associatedObjectForCache)) : this.useSourceMap || this.useSimpleSourceMap ? new OriginalSource(content, contextifySourceUrl(context, identifier, associatedObjectForCache)) : new RawSource(content);
}
_doBuild(options, compilation, resolver, fs, hooks, callback) {
const loaderContext = this._createLoaderContext(resolver, options, compilation, fs, hooks), processResult = (err, result) => {
if (err) {
err instanceof Error || (err = new NonErrorEmittedError(err));
const currentLoader = this.getCurrentLoader(loaderContext), error = new ModuleBuildError(err, {
from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)
});
return callback(error);
}
const source = result[0], sourceMap = result.length >= 1 ? result[1] : null, extraInfo = result.length >= 2 ? result[2] : null;
if (!Buffer.isBuffer(source) && "string" != typeof source) {
const currentLoader = this.getCurrentLoader(loaderContext, 0), err = new Error(`Final loader (${currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader) : "unknown"}) didn't return a Buffer or String`), error = new ModuleBuildError(err);
return callback(error);
}
var input;
return this._source = this.createSource(options.context, this.binary ? (input = source, 
Buffer.isBuffer(input) ? input : Buffer.from(input, "utf-8")) : (input => Buffer.isBuffer(input) ? input.toString("utf-8") : input)(source), sourceMap, compilation.compiler.root), 
void 0 !== this._sourceSizes && this._sourceSizes.clear(), this._ast = "object" == typeof extraInfo && null !== extraInfo && void 0 !== extraInfo.webpackAST ? extraInfo.webpackAST : null, 
callback();
};
this.buildInfo.fileDependencies = new LazySet, this.buildInfo.contextDependencies = new LazySet, 
this.buildInfo.missingDependencies = new LazySet, this.buildInfo.cacheable = !0;
try {
hooks.beforeLoaders.call(this.loaders, this, loaderContext);
} catch (err) {
return void processResult(err);
}
this.loaders.length > 0 && (this.buildInfo.buildDependencies = new LazySet), runLoaders({
resource: this.resource,
loaders: this.loaders,
context: loaderContext,
processResource: (loaderContext, resourcePath, callback) => {
const resource = loaderContext.resource, scheme = getScheme(resource);
hooks.readResource.for(scheme).callAsync(loaderContext, ((err, result) => err ? callback(err) : "string" == typeof result || result ? callback(null, result) : callback(new UnhandledSchemeError(scheme, resource))));
}
}, ((err, result) => {
if (loaderContext._compilation = loaderContext._compiler = loaderContext._module = loaderContext.fs = void 0, 
!result) return this.buildInfo.cacheable = !1, processResult(err || new Error("No result from loader-runner processing"), null);
this.buildInfo.fileDependencies.addAll(result.fileDependencies), this.buildInfo.contextDependencies.addAll(result.contextDependencies), 
this.buildInfo.missingDependencies.addAll(result.missingDependencies);
for (const loader of this.loaders) this.buildInfo.buildDependencies.add(loader.loader);
this.buildInfo.cacheable = this.buildInfo.cacheable && result.cacheable, processResult(err, result.result);
}));
}
markModuleAsErrored(error) {
this.buildMeta = {
...this._lastSuccessfulBuildMeta
}, this.error = error, this.addError(error);
}
applyNoParseRule(rule, content) {
return "string" == typeof rule ? content.startsWith(rule) : "function" == typeof rule ? rule(content) : rule.test(content);
}
shouldPreventParsing(noParseRule, request) {
if (!noParseRule) return !1;
if (!Array.isArray(noParseRule)) return this.applyNoParseRule(noParseRule, request);
for (let i = 0; i < noParseRule.length; i++) {
const rule = noParseRule[i];
if (this.applyNoParseRule(rule, request)) return !0;
}
return !1;
}
_initBuildHash(compilation) {
const hash = createHash(compilation.outputOptions.hashFunction);
this._source && (hash.update("source"), this._source.updateHash(hash)), hash.update("meta"), 
hash.update(JSON.stringify(this.buildMeta)), this.buildInfo.hash = hash.digest("hex");
}
build(options, compilation, resolver, fs, callback) {
this._forceBuild = !1, this._source = null, void 0 !== this._sourceSizes && this._sourceSizes.clear(), 
this._sourceTypes = void 0, this._ast = null, this.error = null, this.clearWarningsAndErrors(), 
this.clearDependenciesAndBlocks(), this.buildMeta = {}, this.buildInfo = {
cacheable: !1,
parsed: !0,
fileDependencies: void 0,
contextDependencies: void 0,
missingDependencies: void 0,
buildDependencies: void 0,
valueDependencies: void 0,
hash: void 0,
assets: void 0,
assetsInfo: void 0
};
const startTime = compilation.compiler.fsStartTime || Date.now(), hooks = NormalModule.getCompilationHooks(compilation);
return this._doBuild(options, compilation, resolver, fs, hooks, (err => {
if (err) return this.markModuleAsErrored(err), this._initBuildHash(compilation), 
callback();
const handleParseError = e => {
const source = this._source.source(), loaders = this.loaders.map((item => contextify(options.context, item.loader, compilation.compiler.root))), error = new ModuleParseError(source, e, loaders, this.type);
return this.markModuleAsErrored(error), this._initBuildHash(compilation), callback();
}, handleBuildDone = () => {
try {
hooks.beforeSnapshot.call(this);
} catch (err) {
return this.markModuleAsErrored(err), callback();
}
const snapshotOptions = compilation.options.snapshot.module;
if (!this.buildInfo.cacheable || !snapshotOptions) return callback();
let nonAbsoluteDependencies;
const checkDependencies = deps => {
for (const dep of deps) if (!ABSOLUTE_PATH_REGEX.test(dep)) {
void 0 === nonAbsoluteDependencies && (nonAbsoluteDependencies = new Set), nonAbsoluteDependencies.add(dep), 
deps.delete(dep);
try {
const depWithoutGlob = dep.replace(/[\\/]?\*.*$/, ""), absolute = join(compilation.fileSystemInfo.fs, this.context, depWithoutGlob);
absolute !== dep && ABSOLUTE_PATH_REGEX.test(absolute) && (depWithoutGlob !== dep ? this.buildInfo.contextDependencies : deps).add(absolute);
} catch (e) {}
}
};
if (checkDependencies(this.buildInfo.fileDependencies), checkDependencies(this.buildInfo.missingDependencies), 
checkDependencies(this.buildInfo.contextDependencies), void 0 !== nonAbsoluteDependencies) {
const InvalidDependenciesModuleWarning = getInvalidDependenciesModuleWarning();
this.addWarning(new InvalidDependenciesModuleWarning(this, nonAbsoluteDependencies));
}
compilation.fileSystemInfo.createSnapshot(startTime, this.buildInfo.fileDependencies, this.buildInfo.contextDependencies, this.buildInfo.missingDependencies, snapshotOptions, ((err, snapshot) => {
if (!err) return this.buildInfo.fileDependencies = void 0, this.buildInfo.contextDependencies = void 0, 
this.buildInfo.missingDependencies = void 0, this.buildInfo.snapshot = snapshot, 
callback();
this.markModuleAsErrored(err);
}));
};
try {
hooks.beforeParse.call(this);
} catch (err) {
return this.markModuleAsErrored(err), this._initBuildHash(compilation), callback();
}
const noParseRule = options.module && options.module.noParse;
if (this.shouldPreventParsing(noParseRule, this.request)) return this.buildInfo.parsed = !1, 
this._initBuildHash(compilation), handleBuildDone();
let result;
try {
const source = this._source.source();
result = this.parser.parse(this._ast || source, {
source,
current: this,
module: this,
compilation,
options
});
} catch (e) {
return void handleParseError(e);
}
(result => {
this.dependencies.sort(concatComparators(compareSelect((a => a.loc), compareLocations), keepOriginalOrder(this.dependencies))), 
this._initBuildHash(compilation), this._lastSuccessfulBuildMeta = this.buildMeta, 
handleBuildDone();
})();
}));
}
getConcatenationBailoutReason(context) {
return this.generator.getConcatenationBailoutReason(this, context);
}
getSideEffectsConnectionState(moduleGraph) {
if (void 0 !== this.factoryMeta) {
if (this.factoryMeta.sideEffectFree) return !1;
if (!1 === this.factoryMeta.sideEffectFree) return !0;
}
if (void 0 !== this.buildMeta && this.buildMeta.sideEffectFree) {
if (this._isEvaluatingSideEffects) return ModuleGraphConnection.CIRCULAR_CONNECTION;
this._isEvaluatingSideEffects = !0;
let current = !1;
for (const dep of this.dependencies) {
const state = dep.getModuleEvaluationSideEffectsState(moduleGraph);
if (!0 === state) return (void 0 === this._addedSideEffectsBailout ? (this._addedSideEffectsBailout = new WeakSet, 
1) : !this._addedSideEffectsBailout.has(moduleGraph)) && (this._addedSideEffectsBailout.add(moduleGraph), 
moduleGraph.getOptimizationBailout(this).push((() => `Dependency (${dep.type}) with side effects at ${formatLocation(dep.loc)}`))), 
this._isEvaluatingSideEffects = !1, !0;
state !== ModuleGraphConnection.CIRCULAR_CONNECTION && (current = ModuleGraphConnection.addConnectionStates(current, state));
}
return this._isEvaluatingSideEffects = !1, current;
}
return !0;
}
getSourceTypes() {
return void 0 === this._sourceTypes && (this._sourceTypes = this.generator.getTypes(this)), 
this._sourceTypes;
}
codeGeneration({dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, concatenationScope, codeGenerationResults, sourceTypes}) {
const runtimeRequirements = new Set;
let data;
this.buildInfo.parsed || (runtimeRequirements.add(RuntimeGlobals.module), runtimeRequirements.add(RuntimeGlobals.exports), 
runtimeRequirements.add(RuntimeGlobals.thisAsExports));
const getData = () => (void 0 === data && (data = new Map), data), sources = new Map;
for (const type of sourceTypes || chunkGraph.getModuleSourceTypes(this)) {
const source = this.error ? new RawSource("throw new Error(" + JSON.stringify(this.error.message) + ");") : this.generator.generate(this, {
dependencyTemplates,
runtimeTemplate,
moduleGraph,
chunkGraph,
runtimeRequirements,
runtime,
concatenationScope,
codeGenerationResults,
getData,
type
});
source && sources.set(type, new CachedSource(source));
}
return {
sources,
runtimeRequirements,
data
};
}
originalSource() {
return this._source;
}
invalidateBuild() {
this._forceBuild = !0;
}
needBuild(context, callback) {
const {fileSystemInfo, compilation, valueCacheVersions} = context;
if (this._forceBuild) return callback(null, !0);
if (this.error) return callback(null, !0);
if (!this.buildInfo.cacheable) return callback(null, !0);
if (!this.buildInfo.snapshot) return callback(null, !0);
const valueDependencies = this.buildInfo.valueDependencies;
if (valueDependencies) {
if (!valueCacheVersions) return callback(null, !0);
for (const [key, value] of valueDependencies) {
if (void 0 === value) return callback(null, !0);
const current = valueCacheVersions.get(key);
if (value !== current && ("string" == typeof value || "string" == typeof current || void 0 === current || !isSubset(value, current))) return callback(null, !0);
}
}
fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, ((err, valid) => {
if (err) return callback(err);
if (!valid) return callback(null, !0);
NormalModule.getCompilationHooks(compilation).needBuild.callAsync(this, context, ((err, needBuild) => {
if (err) return callback(HookWebpackError.makeWebpackError(err, "NormalModule.getCompilationHooks().needBuild"));
callback(null, !!needBuild);
}));
}));
}
size(type) {
const cachedSize = void 0 === this._sourceSizes ? void 0 : this._sourceSizes.get(type);
if (void 0 !== cachedSize) return cachedSize;
const size = Math.max(1, this.generator.getSize(this, type));
return void 0 === this._sourceSizes && (this._sourceSizes = new Map), this._sourceSizes.set(type, size), 
size;
}
addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies) {
const {snapshot, buildDependencies: buildDeps} = this.buildInfo;
if (snapshot) fileDependencies.addAll(snapshot.getFileIterable()), contextDependencies.addAll(snapshot.getContextIterable()), 
missingDependencies.addAll(snapshot.getMissingIterable()); else {
const {fileDependencies: fileDeps, contextDependencies: contextDeps, missingDependencies: missingDeps} = this.buildInfo;
void 0 !== fileDeps && fileDependencies.addAll(fileDeps), void 0 !== contextDeps && contextDependencies.addAll(contextDeps), 
void 0 !== missingDeps && missingDependencies.addAll(missingDeps);
}
void 0 !== buildDeps && buildDependencies.addAll(buildDeps);
}
updateHash(hash, context) {
hash.update(this.buildInfo.hash), this.generator.updateHash(hash, {
module: this,
...context
}), super.updateHash(hash, context);
}
serialize(context) {
const {write} = context;
write(this._source), write(this.error), write(this._lastSuccessfulBuildMeta), write(this._forceBuild), 
super.serialize(context);
}
static deserialize(context) {
const obj = new NormalModule({
layer: null,
type: "",
resource: "",
context: "",
request: null,
userRequest: null,
rawRequest: null,
loaders: null,
matchResource: null,
parser: null,
parserOptions: null,
generator: null,
generatorOptions: null,
resolveOptions: null
});
return obj.deserialize(context), obj;
}
deserialize(context) {
const {read} = context;
this._source = read(), this.error = read(), this._lastSuccessfulBuildMeta = read(), 
this._forceBuild = read(), super.deserialize(context);
}
}
makeSerializable(NormalModule, "webpack/lib/NormalModule"), module.exports = NormalModule;
},
48131: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {getContext} = __webpack_require__(18043), asyncLib = __webpack_require__(76947), {AsyncSeriesBailHook, SyncWaterfallHook, SyncBailHook, SyncHook, HookMap} = __webpack_require__(89991), ChunkGraph = __webpack_require__(15888), Module = __webpack_require__(36797), ModuleFactory = __webpack_require__(37019), ModuleGraph = __webpack_require__(2197), NormalModule = __webpack_require__(3213), BasicEffectRulePlugin = __webpack_require__(94743), BasicMatcherRulePlugin = __webpack_require__(30581), ObjectMatcherRulePlugin = __webpack_require__(75540), RuleSetCompiler = __webpack_require__(42530), UseEffectRulePlugin = __webpack_require__(51942), LazySet = __webpack_require__(92585), {getScheme} = __webpack_require__(15686), {cachedCleverMerge, cachedSetProperty} = __webpack_require__(8639), {join} = __webpack_require__(57075), {parseResource, parseResourceWithoutFragment} = __webpack_require__(63264), EMPTY_RESOLVE_OPTIONS = {}, EMPTY_PARSER_OPTIONS = {}, EMPTY_GENERATOR_OPTIONS = {}, EMPTY_ELEMENTS = [], MATCH_RESOURCE_REGEX = /^([^!]+)!=!/, loaderToIdent = data => {
if (!data.options) return data.loader;
if ("string" == typeof data.options) return data.loader + "?" + data.options;
if ("object" != typeof data.options) throw new Error("loader options must be string or object");
return data.ident ? data.loader + "??" + data.ident : data.loader + "?" + JSON.stringify(data.options);
}, stringifyLoadersAndResource = (loaders, resource) => {
let str = "";
for (const loader of loaders) str += loaderToIdent(loader) + "!";
return str + resource;
}, needCalls = (times, callback) => err => 0 == --times ? callback(err) : err && times > 0 ? (times = NaN, 
callback(err)) : void 0, mergeGlobalOptions = (globalOptions, type, localOptions) => {
const parts = type.split("/");
let result, current = "";
for (const part of parts) {
current = current ? `${current}/${part}` : part;
const options = globalOptions[current];
"object" == typeof options && (result = void 0 === result ? options : cachedCleverMerge(result, options));
}
return void 0 === result ? localOptions : cachedCleverMerge(result, localOptions);
}, deprecationChangedHookMessage = (name, hook) => `NormalModuleFactory.${name} (${hook.taps.map((tapped => tapped.name)).join(", ")}) is no longer a waterfall hook, but a bailing hook instead. Do not return the passed object, but modify it instead. Returning false will ignore the request and results in no module created.`, ruleSetCompiler = new RuleSetCompiler([ new BasicMatcherRulePlugin("test", "resource"), new BasicMatcherRulePlugin("scheme"), new BasicMatcherRulePlugin("mimetype"), new BasicMatcherRulePlugin("dependency"), new BasicMatcherRulePlugin("include", "resource"), new BasicMatcherRulePlugin("exclude", "resource", !0), new BasicMatcherRulePlugin("resource"), new BasicMatcherRulePlugin("resourceQuery"), new BasicMatcherRulePlugin("resourceFragment"), new BasicMatcherRulePlugin("realResource"), new BasicMatcherRulePlugin("issuer"), new BasicMatcherRulePlugin("compiler"), new BasicMatcherRulePlugin("issuerLayer"), new ObjectMatcherRulePlugin("assert", "assertions"), new ObjectMatcherRulePlugin("descriptionData"), new BasicEffectRulePlugin("type"), new BasicEffectRulePlugin("sideEffects"), new BasicEffectRulePlugin("parser"), new BasicEffectRulePlugin("resolve"), new BasicEffectRulePlugin("generator"), new BasicEffectRulePlugin("layer"), new UseEffectRulePlugin ]);
module.exports = class extends ModuleFactory {
constructor({context, fs, resolverFactory, options, associatedObjectForCache, layers = !1}) {
super(), this.hooks = Object.freeze({
resolve: new AsyncSeriesBailHook([ "resolveData" ]),
resolveForScheme: new HookMap((() => new AsyncSeriesBailHook([ "resourceData", "resolveData" ]))),
resolveInScheme: new HookMap((() => new AsyncSeriesBailHook([ "resourceData", "resolveData" ]))),
factorize: new AsyncSeriesBailHook([ "resolveData" ]),
beforeResolve: new AsyncSeriesBailHook([ "resolveData" ]),
afterResolve: new AsyncSeriesBailHook([ "resolveData" ]),
createModule: new AsyncSeriesBailHook([ "createData", "resolveData" ]),
module: new SyncWaterfallHook([ "module", "createData", "resolveData" ]),
createParser: new HookMap((() => new SyncBailHook([ "parserOptions" ]))),
parser: new HookMap((() => new SyncHook([ "parser", "parserOptions" ]))),
createGenerator: new HookMap((() => new SyncBailHook([ "generatorOptions" ]))),
generator: new HookMap((() => new SyncHook([ "generator", "generatorOptions" ])))
}), this.resolverFactory = resolverFactory, this.ruleSet = ruleSetCompiler.compile([ {
rules: options.defaultRules
}, {
rules: options.rules
} ]), this.context = context || "", this.fs = fs, this._globalParserOptions = options.parser, 
this._globalGeneratorOptions = options.generator, this.parserCache = new Map, this.generatorCache = new Map, 
this._restoredUnsafeCacheEntries = new Set;
const cacheParseResource = parseResource.bindCache(associatedObjectForCache), cachedParseResourceWithoutFragment = parseResourceWithoutFragment.bindCache(associatedObjectForCache);
this._parseResourceWithoutFragment = cachedParseResourceWithoutFragment, this.hooks.factorize.tapAsync({
name: "NormalModuleFactory",
stage: 100
}, ((resolveData, callback) => {
this.hooks.resolve.callAsync(resolveData, ((err, result) => {
if (err) return callback(err);
if (!1 === result) return callback();
if (result instanceof Module) return callback(null, result);
if ("object" == typeof result) throw new Error(deprecationChangedHookMessage("resolve", this.hooks.resolve) + " Returning a Module object will result in this module used as result.");
this.hooks.afterResolve.callAsync(resolveData, ((err, result) => {
if (err) return callback(err);
if ("object" == typeof result) throw new Error(deprecationChangedHookMessage("afterResolve", this.hooks.afterResolve));
if (!1 === result) return callback();
const createData = resolveData.createData;
this.hooks.createModule.callAsync(createData, resolveData, ((err, createdModule) => {
if (!createdModule) {
if (!resolveData.request) return callback(new Error("Empty dependency (no request)"));
createdModule = new NormalModule(createData);
}
return createdModule = this.hooks.module.call(createdModule, createData, resolveData), 
callback(null, createdModule);
}));
}));
}));
})), this.hooks.resolve.tapAsync({
name: "NormalModuleFactory",
stage: 100
}, ((data, callback) => {
const {contextInfo, context, dependencies, dependencyType, request, assertions, resolveOptions, fileDependencies, missingDependencies, contextDependencies} = data, loaderResolver = this.getResolver("loader");
let matchResourceData, unresolvedResource, elements, noPreAutoLoaders = !1, noAutoLoaders = !1, noPrePostAutoLoaders = !1;
const contextScheme = getScheme(context);
let scheme = getScheme(request);
if (scheme) unresolvedResource = request, elements = EMPTY_ELEMENTS; else {
let requestWithoutMatchResource = request;
const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
if (matchResourceMatch) {
let matchResource = matchResourceMatch[1];
if (46 === matchResource.charCodeAt(0)) {
const secondChar = matchResource.charCodeAt(1);
(47 === secondChar || 46 === secondChar && 47 === matchResource.charCodeAt(2)) && (matchResource = join(this.fs, context, matchResource));
}
matchResourceData = {
resource: matchResource,
...cacheParseResource(matchResource)
}, requestWithoutMatchResource = request.slice(matchResourceMatch[0].length);
}
if (scheme = getScheme(requestWithoutMatchResource), scheme || contextScheme) unresolvedResource = requestWithoutMatchResource, 
elements = EMPTY_ELEMENTS; else {
const firstChar = requestWithoutMatchResource.charCodeAt(0), secondChar = requestWithoutMatchResource.charCodeAt(1);
noPreAutoLoaders = 45 === firstChar && 33 === secondChar, noAutoLoaders = noPreAutoLoaders || 33 === firstChar, 
noPrePostAutoLoaders = 33 === firstChar && 33 === secondChar;
const rawElements = requestWithoutMatchResource.slice(noPreAutoLoaders || noPrePostAutoLoaders ? 2 : noAutoLoaders ? 1 : 0).split(/!+/);
unresolvedResource = rawElements.pop(), elements = rawElements.map((el => {
const {path, query} = cachedParseResourceWithoutFragment(el);
return {
loader: path,
options: query ? query.slice(1) : void 0
};
})), scheme = getScheme(unresolvedResource);
}
}
const resolveContext = {
fileDependencies,
missingDependencies,
contextDependencies
};
let resourceData, loaders;
const continueCallback = needCalls(2, (err => {
if (err) return callback(err);
try {
for (const item of loaders) if ("string" == typeof item.options && "?" === item.options[0]) {
const ident = item.options.slice(1);
if ("[[missing ident]]" === ident) throw new Error("No ident is provided by referenced loader. When using a function for Rule.use in config you need to provide an 'ident' property for referenced loader options.");
if (item.options = this.ruleSet.references.get(ident), void 0 === item.options) throw new Error("Invalid ident is provided by referenced loader");
item.ident = ident;
}
} catch (e) {
return callback(e);
}
if (!resourceData) return callback(null, dependencies[0].createIgnoredModule(context));
const userRequest = (void 0 !== matchResourceData ? `${matchResourceData.resource}!=!` : "") + stringifyLoadersAndResource(loaders, resourceData.resource), settings = {}, useLoadersPost = [], useLoaders = [], useLoadersPre = [];
let resource, match, postLoaders, normalLoaders, preLoaders;
if (matchResourceData && "string" == typeof (resource = matchResourceData.resource) && (match = /\.webpack\[([^\]]+)\]$/.exec(resource))) settings.type = match[1], 
matchResourceData.resource = matchResourceData.resource.slice(0, -settings.type.length - 10); else {
settings.type = "javascript/auto";
const resourceDataForRules = matchResourceData || resourceData, result = this.ruleSet.exec({
resource: resourceDataForRules.path,
realResource: resourceData.path,
resourceQuery: resourceDataForRules.query,
resourceFragment: resourceDataForRules.fragment,
scheme,
assertions,
mimetype: matchResourceData ? "" : resourceData.data.mimetype || "",
dependency: dependencyType,
descriptionData: matchResourceData ? void 0 : resourceData.data.descriptionFileData,
issuer: contextInfo.issuer,
compiler: contextInfo.compiler,
issuerLayer: contextInfo.issuerLayer || ""
});
for (const r of result) "use" === r.type ? noAutoLoaders || noPrePostAutoLoaders || useLoaders.push(r.value) : "use-post" === r.type ? noPrePostAutoLoaders || useLoadersPost.push(r.value) : "use-pre" === r.type ? noPreAutoLoaders || noPrePostAutoLoaders || useLoadersPre.push(r.value) : "object" == typeof r.value && null !== r.value && "object" == typeof settings[r.type] && null !== settings[r.type] ? settings[r.type] = cachedCleverMerge(settings[r.type], r.value) : settings[r.type] = r.value;
}
const continueCallback = needCalls(3, (err => {
if (err) return callback(err);
const allLoaders = postLoaders;
if (void 0 === matchResourceData) {
for (const loader of loaders) allLoaders.push(loader);
for (const loader of normalLoaders) allLoaders.push(loader);
} else {
for (const loader of normalLoaders) allLoaders.push(loader);
for (const loader of loaders) allLoaders.push(loader);
}
for (const loader of preLoaders) allLoaders.push(loader);
let type = settings.type;
const resolveOptions = settings.resolve, layer = settings.layer;
if (void 0 !== layer && !layers) return callback(new Error("'Rule.layer' is only allowed when 'experiments.layers' is enabled"));
try {
Object.assign(data.createData, {
layer: void 0 === layer ? contextInfo.issuerLayer || null : layer,
request: stringifyLoadersAndResource(allLoaders, resourceData.resource),
userRequest,
rawRequest: request,
loaders: allLoaders,
resource: resourceData.resource,
context: resourceData.context || getContext(resourceData.resource),
matchResource: matchResourceData ? matchResourceData.resource : void 0,
resourceResolveData: resourceData.data,
settings,
type,
parser: this.getParser(type, settings.parser),
parserOptions: settings.parser,
generator: this.getGenerator(type, settings.generator),
generatorOptions: settings.generator,
resolveOptions
});
} catch (e) {
return callback(e);
}
callback();
}));
this.resolveRequestArray(contextInfo, this.context, useLoadersPost, loaderResolver, resolveContext, ((err, result) => {
postLoaders = result, continueCallback(err);
})), this.resolveRequestArray(contextInfo, this.context, useLoaders, loaderResolver, resolveContext, ((err, result) => {
normalLoaders = result, continueCallback(err);
})), this.resolveRequestArray(contextInfo, this.context, useLoadersPre, loaderResolver, resolveContext, ((err, result) => {
preLoaders = result, continueCallback(err);
}));
}));
this.resolveRequestArray(contextInfo, contextScheme ? this.context : context, elements, loaderResolver, resolveContext, ((err, result) => {
if (err) return continueCallback(err);
loaders = result, continueCallback();
}));
const defaultResolve = context => {
if (/^($|\?)/.test(unresolvedResource)) resourceData = {
resource: unresolvedResource,
data: {},
...cacheParseResource(unresolvedResource)
}, continueCallback(); else {
const normalResolver = this.getResolver("normal", dependencyType ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, "dependencyType", dependencyType) : resolveOptions);
this.resolveResource(contextInfo, context, unresolvedResource, normalResolver, resolveContext, ((err, resolvedResource, resolvedResourceResolveData) => {
if (err) return continueCallback(err);
!1 !== resolvedResource && (resourceData = {
resource: resolvedResource,
data: resolvedResourceResolveData,
...cacheParseResource(resolvedResource)
}), continueCallback();
}));
}
};
scheme ? (resourceData = {
resource: unresolvedResource,
data: {},
path: void 0,
query: void 0,
fragment: void 0,
context: void 0
}, this.hooks.resolveForScheme.for(scheme).callAsync(resourceData, data, (err => {
if (err) return continueCallback(err);
continueCallback();
}))) : contextScheme ? (resourceData = {
resource: unresolvedResource,
data: {},
path: void 0,
query: void 0,
fragment: void 0,
context: void 0
}, this.hooks.resolveInScheme.for(contextScheme).callAsync(resourceData, data, ((err, handled) => err ? continueCallback(err) : handled ? void continueCallback() : defaultResolve(this.context)))) : defaultResolve(context);
}));
}
cleanupForCache() {
for (const module of this._restoredUnsafeCacheEntries) ChunkGraph.clearChunkGraphForModule(module), 
ModuleGraph.clearModuleGraphForModule(module), module.cleanupForCache();
}
create(data, callback) {
const dependencies = data.dependencies, context = data.context || this.context, resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS, dependency = dependencies[0], request = dependency.request, assertions = dependency.assertions, contextInfo = data.contextInfo, fileDependencies = new LazySet, missingDependencies = new LazySet, contextDependencies = new LazySet, resolveData = {
contextInfo,
resolveOptions,
context,
request,
assertions,
dependencies,
dependencyType: dependencies.length > 0 && dependencies[0].category || "",
fileDependencies,
missingDependencies,
contextDependencies,
createData: {},
cacheable: !0
};
this.hooks.beforeResolve.callAsync(resolveData, ((err, result) => {
if (err) return callback(err, {
fileDependencies,
missingDependencies,
contextDependencies,
cacheable: !1
});
if (!1 === result) return callback(null, {
fileDependencies,
missingDependencies,
contextDependencies,
cacheable: resolveData.cacheable
});
if ("object" == typeof result) throw new Error(deprecationChangedHookMessage("beforeResolve", this.hooks.beforeResolve));
this.hooks.factorize.callAsync(resolveData, ((err, module) => {
if (err) return callback(err, {
fileDependencies,
missingDependencies,
contextDependencies,
cacheable: !1
});
callback(null, {
module,
fileDependencies,
missingDependencies,
contextDependencies,
cacheable: resolveData.cacheable
});
}));
}));
}
resolveResource(contextInfo, context, unresolvedResource, resolver, resolveContext, callback) {
resolver.resolve(contextInfo, context, unresolvedResource, resolveContext, ((err, resolvedResource, resolvedResourceResolveData) => {
if (err) return this._resolveResourceErrorHints(err, contextInfo, context, unresolvedResource, resolver, resolveContext, ((err2, hints) => {
if (err2) return err.message += `\nAn fatal error happened during resolving additional hints for this error: ${err2.message}`, 
err.stack += `\n\nAn fatal error happened during resolving additional hints for this error:\n${err2.stack}`, 
callback(err);
hints && hints.length > 0 && (err.message += `\n${hints.join("\n\n")}`), callback(err);
}));
callback(err, resolvedResource, resolvedResourceResolveData);
}));
}
_resolveResourceErrorHints(error, contextInfo, context, unresolvedResource, resolver, resolveContext, callback) {
asyncLib.parallel([ callback => {
if (!resolver.options.fullySpecified) return callback();
resolver.withOptions({
fullySpecified: !1
}).resolve(contextInfo, context, unresolvedResource, resolveContext, ((err, resolvedResource) => {
if (!err && resolvedResource) {
const resource = parseResource(resolvedResource).path.replace(/^.*[\\/]/, "");
return callback(null, `Did you mean '${resource}'?\nBREAKING CHANGE: The request '${unresolvedResource}' failed to resolve only because it was resolved as fully specified\n(probably because the origin is strict EcmaScript Module, e. g. a module with javascript mimetype, a '*.mjs' file, or a '*.js' file where the package.json contains '"type": "module"').\nThe extension in the request is mandatory for it to be fully specified.\nAdd the extension to the request.`);
}
callback();
}));
}, callback => {
if (!resolver.options.enforceExtension) return callback();
resolver.withOptions({
enforceExtension: !1,
extensions: []
}).resolve(contextInfo, context, unresolvedResource, resolveContext, ((err, resolvedResource) => {
if (!err && resolvedResource) {
let hint = "";
const match = /(\.[^.]+)(\?|$)/.exec(unresolvedResource);
if (match) {
const fixedRequest = unresolvedResource.replace(/(\.[^.]+)(\?|$)/, "$2");
hint = resolver.options.extensions.has(match[1]) ? `Did you mean '${fixedRequest}'?` : `Did you mean '${fixedRequest}'? Also note that '${match[1]}' is not in 'resolve.extensions' yet and need to be added for this to work?`;
} else hint = "Did you mean to omit the extension or to remove 'resolve.enforceExtension'?";
return callback(null, `The request '${unresolvedResource}' failed to resolve only because 'resolve.enforceExtension' was specified.\n${hint}\nIncluding the extension in the request is no longer possible. Did you mean to enforce including the extension in requests with 'resolve.extensions: []' instead?`);
}
callback();
}));
}, callback => {
if (/^\.\.?\//.test(unresolvedResource) || resolver.options.preferRelative) return callback();
resolver.resolve(contextInfo, context, `./${unresolvedResource}`, resolveContext, ((err, resolvedResource) => {
if (err || !resolvedResource) return callback();
const moduleDirectories = resolver.options.modules.map((m => Array.isArray(m) ? m.join(", ") : m)).join(", ");
callback(null, `Did you mean './${unresolvedResource}'?\nRequests that should resolve in the current directory need to start with './'.\nRequests that start with a name are treated as module requests and resolve within module directories (${moduleDirectories}).\nIf changing the source code is not an option there is also a resolve options called 'preferRelative' which tries to resolve these kind of requests in the current directory too.`);
}));
} ], ((err, hints) => {
if (err) return callback(err);
callback(null, hints.filter(Boolean));
}));
}
resolveRequestArray(contextInfo, context, array, resolver, resolveContext, callback) {
if (0 === array.length) return callback(null, array);
asyncLib.map(array, ((item, callback) => {
resolver.resolve(contextInfo, context, item.loader, resolveContext, ((err, result) => {
if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) return resolver.resolve(contextInfo, context, item.loader + "-loader", resolveContext, (err2 => {
err2 || (err.message = err.message + "\nBREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" + `                 You need to specify '${item.loader}-loader' instead of '${item.loader}',\n                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed`), 
callback(err);
}));
if (err) return callback(err);
const parsedResult = this._parseResourceWithoutFragment(result), resolved = {
loader: parsedResult.path,
options: void 0 === item.options ? parsedResult.query ? parsedResult.query.slice(1) : void 0 : item.options,
ident: void 0 === item.options ? void 0 : item.ident
};
return callback(null, resolved);
}));
}), callback);
}
getParser(type, parserOptions = EMPTY_PARSER_OPTIONS) {
let cache = this.parserCache.get(type);
void 0 === cache && (cache = new WeakMap, this.parserCache.set(type, cache));
let parser = cache.get(parserOptions);
return void 0 === parser && (parser = this.createParser(type, parserOptions), cache.set(parserOptions, parser)), 
parser;
}
createParser(type, parserOptions = {}) {
parserOptions = mergeGlobalOptions(this._globalParserOptions, type, parserOptions);
const parser = this.hooks.createParser.for(type).call(parserOptions);
if (!parser) throw new Error(`No parser registered for ${type}`);
return this.hooks.parser.for(type).call(parser, parserOptions), parser;
}
getGenerator(type, generatorOptions = EMPTY_GENERATOR_OPTIONS) {
let cache = this.generatorCache.get(type);
void 0 === cache && (cache = new WeakMap, this.generatorCache.set(type, cache));
let generator = cache.get(generatorOptions);
return void 0 === generator && (generator = this.createGenerator(type, generatorOptions), 
cache.set(generatorOptions, generator)), generator;
}
createGenerator(type, generatorOptions = {}) {
generatorOptions = mergeGlobalOptions(this._globalGeneratorOptions, type, generatorOptions);
const generator = this.hooks.createGenerator.for(type).call(generatorOptions);
if (!generator) throw new Error(`No generator registered for ${type}`);
return this.hooks.generator.for(type).call(generator, generatorOptions), generator;
}
getResolver(type, resolveOptions) {
return this.resolverFactory.get(type, resolveOptions);
}
};
},
36524: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {join, dirname} = __webpack_require__(57075);
module.exports = class {
constructor(resourceRegExp, newResource) {
this.resourceRegExp = resourceRegExp, this.newResource = newResource;
}
apply(compiler) {
const resourceRegExp = this.resourceRegExp, newResource = this.newResource;
compiler.hooks.normalModuleFactory.tap("NormalModuleReplacementPlugin", (nmf => {
nmf.hooks.beforeResolve.tap("NormalModuleReplacementPlugin", (result => {
resourceRegExp.test(result.request) && ("function" == typeof newResource ? newResource(result) : result.request = newResource);
})), nmf.hooks.afterResolve.tap("NormalModuleReplacementPlugin", (result => {
const createData = result.createData;
if (resourceRegExp.test(createData.resource)) if ("function" == typeof newResource) newResource(result); else {
const fs = compiler.inputFileSystem;
newResource.startsWith("/") || newResource.length > 1 && ":" === newResource[1] ? createData.resource = newResource : createData.resource = join(fs, dirname(fs, createData.resource), newResource);
}
}));
}));
}
};
},
60933: (__unused_webpack_module, exports) => {
"use strict";
exports.STAGE_BASIC = -10, exports.STAGE_DEFAULT = 0, exports.STAGE_ADVANCED = 10;
},
1114: module => {
"use strict";
module.exports = class {
process(options, compiler) {}
};
},
21475: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
module.exports = class {
parse(source, state) {
throw new (__webpack_require__(91266));
}
};
},
39649: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const PrefetchDependency = __webpack_require__(63352);
module.exports = class {
constructor(context, request) {
request ? (this.context = context, this.request = request) : (this.context = null, 
this.request = context);
}
apply(compiler) {
compiler.hooks.compilation.tap("PrefetchPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
})), compiler.hooks.make.tapAsync("PrefetchPlugin", ((compilation, callback) => {
compilation.addModuleChain(this.context || compiler.context, new PrefetchDependency(this.request), (err => {
callback(err);
}));
}));
}
};
},
17331: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Compiler = __webpack_require__(88799), MultiCompiler = __webpack_require__(95400), createSchemaValidation = (__webpack_require__(3213), 
__webpack_require__(59586)), {contextify} = __webpack_require__(63264), validate = createSchemaValidation(__webpack_require__(11116), (() => __webpack_require__(43691)), {
name: "Progress Plugin",
baseDataPath: "options"
}), progressReporters = new WeakMap;
class ProgressPlugin {
static getReporter(compiler) {
return progressReporters.get(compiler);
}
constructor(options = {}) {
"function" == typeof options && (options = {
handler: options
}), validate(options), options = {
...ProgressPlugin.defaultOptions,
...options
}, this.profile = options.profile, this.handler = options.handler, this.modulesCount = options.modulesCount, 
this.dependenciesCount = options.dependenciesCount, this.showEntries = options.entries, 
this.showModules = options.modules, this.showDependencies = options.dependencies, 
this.showActiveModules = options.activeModules, this.percentBy = options.percentBy;
}
apply(compiler) {
const handler = this.handler || ((profile, logger) => {
const lastStateInfo = [];
return (percentage, msg, ...args) => {
if (profile) {
0 === percentage && (lastStateInfo.length = 0);
const state = [ msg, ...args ].map((s => s.replace(/\d+\/\d+ /g, ""))), now = Date.now();
for (let i = Math.max(state.length, lastStateInfo.length); i >= 0; i--) {
const stateItem = i < state.length ? state[i] : void 0, lastStateItem = i < lastStateInfo.length ? lastStateInfo[i] : void 0;
if (lastStateItem) {
if (stateItem !== lastStateItem.value) {
const diff = now - lastStateItem.time;
if (lastStateItem.value) {
let reportState = lastStateItem.value;
i > 0 && (reportState = lastStateInfo[i - 1].value + " > " + reportState);
const stateMsg = `${" | ".repeat(i)}${diff} ms ${reportState}`, d = diff;
d > 1e4 ? logger.error(stateMsg) : d > 1e3 ? logger.warn(stateMsg) : d > 10 ? logger.info(stateMsg) : d > 5 ? logger.log(stateMsg) : logger.debug(stateMsg);
}
void 0 === stateItem ? lastStateInfo.length = i : (lastStateItem.value = stateItem, 
lastStateItem.time = now, lastStateInfo.length = i + 1);
}
} else lastStateInfo[i] = {
value: stateItem,
time: now
};
}
}
logger.status(`${Math.floor(100 * percentage)}%`, msg, ...args), (1 === percentage || !msg && 0 === args.length) && logger.status();
};
})(this.profile, compiler.getInfrastructureLogger("webpack.Progress"));
compiler instanceof MultiCompiler ? this._applyOnMultiCompiler(compiler, handler) : compiler instanceof Compiler && this._applyOnCompiler(compiler, handler);
}
_applyOnMultiCompiler(compiler, handler) {
const states = compiler.compilers.map((() => [ 0 ]));
compiler.compilers.forEach(((compiler, idx) => {
new ProgressPlugin(((p, msg, ...args) => {
states[idx] = [ p, msg, ...args ];
let sum = 0;
for (const [p] of states) sum += p;
handler(sum / states.length, `[${idx}] ${msg}`, ...args);
})).apply(compiler);
}));
}
_applyOnCompiler(compiler, handler) {
const showEntries = this.showEntries, showModules = this.showModules, showDependencies = this.showDependencies, showActiveModules = this.showActiveModules;
let lastActiveModule = "", lastModulesCount = 0, lastDependenciesCount = 0, lastEntriesCount = 0, modulesCount = 0, dependenciesCount = 0, entriesCount = 1, doneModules = 0, doneDependencies = 0, doneEntries = 0;
const activeModules = new Set;
let lastUpdate = 0;
const updateThrottled = () => {
lastUpdate + 500 < Date.now() && update();
}, update = () => {
const items = [], percentByModules = doneModules / Math.max(lastModulesCount || this.modulesCount || 1, modulesCount), percentByEntries = doneEntries / Math.max(lastEntriesCount || this.dependenciesCount || 1, entriesCount), percentByDependencies = doneDependencies / Math.max(lastDependenciesCount || 1, dependenciesCount);
let percentageFactor;
switch (this.percentBy) {
case "entries":
percentageFactor = percentByEntries;
break;

case "dependencies":
percentageFactor = percentByDependencies;
break;

case "modules":
percentageFactor = percentByModules;
break;

default:
percentageFactor = (a = percentByModules) + (b = percentByEntries) + (c = percentByDependencies) - Math.max(a, b, c) - Math.min(a, b, c);
}
var a, b, c;
const percentage = .1 + .55 * percentageFactor;
{
const statItems = [];
showEntries && statItems.push(`${doneEntries}/${entriesCount} entries`), showDependencies && statItems.push(`${doneDependencies}/${dependenciesCount} dependencies`), 
showModules && statItems.push(`${doneModules}/${modulesCount} modules`), showActiveModules && statItems.push(`${activeModules.size} active`), 
statItems.length > 0 && items.push(statItems.join(" ")), showActiveModules && items.push(lastActiveModule);
}
handler(percentage, "building", ...items), lastUpdate = Date.now();
}, factorizeAdd = () => {
dependenciesCount++, (dependenciesCount < 50 || dependenciesCount % 100 == 0) && updateThrottled();
}, factorizeDone = () => {
doneDependencies++, (doneDependencies < 50 || doneDependencies % 100 == 0) && updateThrottled();
}, moduleAdd = () => {
modulesCount++, (modulesCount < 50 || modulesCount % 100 == 0) && updateThrottled();
}, moduleBuild = module => {
const ident = module.identifier();
ident && (activeModules.add(ident), lastActiveModule = ident, update());
}, entryAdd = (entry, options) => {
entriesCount++, (entriesCount < 5 || entriesCount % 10 == 0) && updateThrottled();
}, moduleDone = module => {
if (doneModules++, showActiveModules) {
const ident = module.identifier();
if (ident && (activeModules.delete(ident), lastActiveModule === ident)) {
lastActiveModule = "";
for (const m of activeModules) lastActiveModule = m;
return void update();
}
}
(doneModules < 50 || doneModules % 100 == 0) && updateThrottled();
}, entryDone = (entry, options) => {
doneEntries++, update();
}, cache = compiler.getCache("ProgressPlugin").getItemCache("counts", null);
let cacheGetPromise;
compiler.hooks.beforeCompile.tap("ProgressPlugin", (() => {
cacheGetPromise || (cacheGetPromise = cache.getPromise().then((data => (data && (lastModulesCount = lastModulesCount || data.modulesCount, 
lastDependenciesCount = lastDependenciesCount || data.dependenciesCount), data)), (err => {})));
})), compiler.hooks.afterCompile.tapPromise("ProgressPlugin", (compilation => compilation.compiler.isChild() ? Promise.resolve() : cacheGetPromise.then((async oldData => {
oldData && oldData.modulesCount === modulesCount && oldData.dependenciesCount === dependenciesCount || await cache.storePromise({
modulesCount,
dependenciesCount
});
})))), compiler.hooks.compilation.tap("ProgressPlugin", (compilation => {
if (compilation.compiler.isChild()) return;
lastModulesCount = modulesCount, lastEntriesCount = entriesCount, lastDependenciesCount = dependenciesCount, 
modulesCount = dependenciesCount = entriesCount = 0, doneModules = doneDependencies = doneEntries = 0, 
compilation.factorizeQueue.hooks.added.tap("ProgressPlugin", factorizeAdd), compilation.factorizeQueue.hooks.result.tap("ProgressPlugin", factorizeDone), 
compilation.addModuleQueue.hooks.added.tap("ProgressPlugin", moduleAdd), compilation.processDependenciesQueue.hooks.result.tap("ProgressPlugin", moduleDone), 
showActiveModules && compilation.hooks.buildModule.tap("ProgressPlugin", moduleBuild), 
compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd), compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone), 
compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);
const hooks = {
finishModules: "finish module graph",
seal: "plugins",
optimizeDependencies: "dependencies optimization",
afterOptimizeDependencies: "after dependencies optimization",
beforeChunks: "chunk graph",
afterChunks: "after chunk graph",
optimize: "optimizing",
optimizeModules: "module optimization",
afterOptimizeModules: "after module optimization",
optimizeChunks: "chunk optimization",
afterOptimizeChunks: "after chunk optimization",
optimizeTree: "module and chunk tree optimization",
afterOptimizeTree: "after module and chunk tree optimization",
optimizeChunkModules: "chunk modules optimization",
afterOptimizeChunkModules: "after chunk modules optimization",
reviveModules: "module reviving",
beforeModuleIds: "before module ids",
moduleIds: "module ids",
optimizeModuleIds: "module id optimization",
afterOptimizeModuleIds: "module id optimization",
reviveChunks: "chunk reviving",
beforeChunkIds: "before chunk ids",
chunkIds: "chunk ids",
optimizeChunkIds: "chunk id optimization",
afterOptimizeChunkIds: "after chunk id optimization",
recordModules: "record modules",
recordChunks: "record chunks",
beforeModuleHash: "module hashing",
beforeCodeGeneration: "code generation",
beforeRuntimeRequirements: "runtime requirements",
beforeHash: "hashing",
afterHash: "after hashing",
recordHash: "record hash",
beforeModuleAssets: "module assets processing",
beforeChunkAssets: "chunk assets processing",
processAssets: "asset processing",
afterProcessAssets: "after asset optimization",
record: "recording",
afterSeal: "after seal"
}, numberOfHooks = Object.keys(hooks).length;
Object.keys(hooks).forEach(((name, idx) => {
const title = hooks[name], percentage = idx / numberOfHooks * .25 + .7;
compilation.hooks[name].intercept({
name: "ProgressPlugin",
call() {
handler(percentage, "sealing", title);
},
done() {
progressReporters.set(compiler, void 0), handler(percentage, "sealing", title);
},
result() {
handler(percentage, "sealing", title);
},
error() {
handler(percentage, "sealing", title);
},
tap(tap) {
progressReporters.set(compilation.compiler, ((p, ...args) => {
handler(percentage, "sealing", title, tap.name, ...args);
})), handler(percentage, "sealing", title, tap.name);
}
});
}));
})), compiler.hooks.make.intercept({
name: "ProgressPlugin",
call() {
handler(.1, "building");
},
done() {
handler(.65, "building");
}
});
const interceptHook = (hook, progress, category, name) => {
hook.intercept({
name: "ProgressPlugin",
call() {
handler(progress, category, name);
},
done() {
progressReporters.set(compiler, void 0), handler(progress, category, name);
},
result() {
handler(progress, category, name);
},
error() {
handler(progress, category, name);
},
tap(tap) {
progressReporters.set(compiler, ((p, ...args) => {
handler(progress, category, name, tap.name, ...args);
})), handler(progress, category, name, tap.name);
}
});
};
compiler.cache.hooks.endIdle.intercept({
name: "ProgressPlugin",
call() {
handler(0, "");
}
}), interceptHook(compiler.cache.hooks.endIdle, .01, "cache", "end idle"), compiler.hooks.beforeRun.intercept({
name: "ProgressPlugin",
call() {
handler(0, "");
}
}), interceptHook(compiler.hooks.beforeRun, .01, "setup", "before run"), interceptHook(compiler.hooks.run, .02, "setup", "run"), 
interceptHook(compiler.hooks.watchRun, .03, "setup", "watch run"), interceptHook(compiler.hooks.normalModuleFactory, .04, "setup", "normal module factory"), 
interceptHook(compiler.hooks.contextModuleFactory, .05, "setup", "context module factory"), 
interceptHook(compiler.hooks.beforeCompile, .06, "setup", "before compile"), interceptHook(compiler.hooks.compile, .07, "setup", "compile"), 
interceptHook(compiler.hooks.thisCompilation, .08, "setup", "compilation"), interceptHook(compiler.hooks.compilation, .09, "setup", "compilation"), 
interceptHook(compiler.hooks.finishMake, .69, "building", "finish"), interceptHook(compiler.hooks.emit, .95, "emitting", "emit"), 
interceptHook(compiler.hooks.afterEmit, .98, "emitting", "after emit"), interceptHook(compiler.hooks.done, .99, "done", "plugins"), 
compiler.hooks.done.intercept({
name: "ProgressPlugin",
done() {
handler(.99, "");
}
}), interceptHook(compiler.cache.hooks.storeBuildDependencies, .99, "cache", "store build dependencies"), 
interceptHook(compiler.cache.hooks.shutdown, .99, "cache", "shutdown"), interceptHook(compiler.cache.hooks.beginIdle, .99, "cache", "begin idle"), 
interceptHook(compiler.hooks.watchClose, .99, "end", "closing watch compilation"), 
compiler.cache.hooks.beginIdle.intercept({
name: "ProgressPlugin",
done() {
handler(1, "");
}
}), compiler.cache.hooks.shutdown.intercept({
name: "ProgressPlugin",
done() {
handler(1, "");
}
});
}
}
ProgressPlugin.defaultOptions = {
profile: !1,
modulesCount: 5e3,
dependenciesCount: 1e4,
modules: !0,
dependencies: !0,
activeModules: !1,
entries: !0
}, module.exports = ProgressPlugin;
},
8822: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConstDependency = __webpack_require__(30339), ProvidedDependency = __webpack_require__(37386), {approve} = __webpack_require__(78802);
module.exports = class {
constructor(definitions) {
this.definitions = definitions;
}
apply(compiler) {
const definitions = this.definitions;
compiler.hooks.compilation.tap("ProvidePlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template), 
compilation.dependencyFactories.set(ProvidedDependency, normalModuleFactory), compilation.dependencyTemplates.set(ProvidedDependency, new ProvidedDependency.Template);
const handler = (parser, parserOptions) => {
Object.keys(definitions).forEach((name => {
const request = [].concat(definitions[name]), splittedName = name.split(".");
splittedName.length > 0 && splittedName.slice(1).forEach(((_, i) => {
const name = splittedName.slice(0, i + 1).join(".");
parser.hooks.canRename.for(name).tap("ProvidePlugin", approve);
})), parser.hooks.expression.for(name).tap("ProvidePlugin", (expr => {
const nameIdentifier = name.includes(".") ? `__webpack_provided_${name.replace(/\./g, "_dot_")}` : name, dep = new ProvidedDependency(request[0], nameIdentifier, request.slice(1), expr.range);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), !0;
})), parser.hooks.call.for(name).tap("ProvidePlugin", (expr => {
const nameIdentifier = name.includes(".") ? `__webpack_provided_${name.replace(/\./g, "_dot_")}` : name, dep = new ProvidedDependency(request[0], nameIdentifier, request.slice(1), expr.callee.range);
return dep.loc = expr.callee.loc, parser.state.module.addDependency(dep), parser.walkExpressions(expr.arguments), 
!0;
}));
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("ProvidePlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ProvidePlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("ProvidePlugin", handler);
}));
}
};
},
85315: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {OriginalSource, RawSource} = __webpack_require__(37946), Module = __webpack_require__(36797), makeSerializable = __webpack_require__(45898), TYPES = new Set([ "javascript" ]);
class RawModule extends Module {
constructor(source, identifier, readableIdentifier, runtimeRequirements) {
super("javascript/dynamic", null), this.sourceStr = source, this.identifierStr = identifier || this.sourceStr, 
this.readableIdentifierStr = readableIdentifier || this.identifierStr, this.runtimeRequirements = runtimeRequirements || null;
}
getSourceTypes() {
return TYPES;
}
identifier() {
return this.identifierStr;
}
size(type) {
return Math.max(1, this.sourceStr.length);
}
readableIdentifier(requestShortener) {
return requestShortener.shorten(this.readableIdentifierStr);
}
needBuild(context, callback) {
return callback(null, !this.buildMeta);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {}, this.buildInfo = {
cacheable: !0
}, callback();
}
codeGeneration(context) {
const sources = new Map;
return this.useSourceMap || this.useSimpleSourceMap ? sources.set("javascript", new OriginalSource(this.sourceStr, this.identifier())) : sources.set("javascript", new RawSource(this.sourceStr)), 
{
sources,
runtimeRequirements: this.runtimeRequirements
};
}
updateHash(hash, context) {
hash.update(this.sourceStr), super.updateHash(hash, context);
}
serialize(context) {
const {write} = context;
write(this.sourceStr), write(this.identifierStr), write(this.readableIdentifierStr), 
write(this.runtimeRequirements), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.sourceStr = read(), this.identifierStr = read(), this.readableIdentifierStr = read(), 
this.runtimeRequirements = read(), super.deserialize(context);
}
}
makeSerializable(RawModule, "webpack/lib/RawModule"), module.exports = RawModule;
},
9236: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareNumbers} = __webpack_require__(40028), identifierUtils = __webpack_require__(63264);
module.exports = class {
constructor(options) {
this.options = options || {};
}
apply(compiler) {
const portableIds = this.options.portableIds, makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root), getModuleIdentifier = module => portableIds ? makePathsRelative(module.identifier()) : module.identifier();
compiler.hooks.compilation.tap("RecordIdsPlugin", (compilation => {
compilation.hooks.recordModules.tap("RecordIdsPlugin", ((modules, records) => {
const chunkGraph = compilation.chunkGraph;
records.modules || (records.modules = {}), records.modules.byIdentifier || (records.modules.byIdentifier = {});
const usedIds = new Set;
for (const module of modules) {
const moduleId = chunkGraph.getModuleId(module);
if ("number" != typeof moduleId) continue;
const identifier = getModuleIdentifier(module);
records.modules.byIdentifier[identifier] = moduleId, usedIds.add(moduleId);
}
records.modules.usedIds = Array.from(usedIds).sort(compareNumbers);
})), compilation.hooks.reviveModules.tap("RecordIdsPlugin", ((modules, records) => {
if (records.modules) {
if (records.modules.byIdentifier) {
const chunkGraph = compilation.chunkGraph, usedIds = new Set;
for (const module of modules) {
if (null !== chunkGraph.getModuleId(module)) continue;
const identifier = getModuleIdentifier(module), id = records.modules.byIdentifier[identifier];
void 0 !== id && (usedIds.has(id) || (usedIds.add(id), chunkGraph.setModuleId(module, id)));
}
}
Array.isArray(records.modules.usedIds) && (compilation.usedModuleIds = new Set(records.modules.usedIds));
}
}));
const getChunkSources = chunk => {
const sources = [];
for (const chunkGroup of chunk.groupsIterable) {
const index = chunkGroup.chunks.indexOf(chunk);
if (chunkGroup.name) sources.push(`${index} ${chunkGroup.name}`); else for (const origin of chunkGroup.origins) origin.module && (origin.request ? sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.request}`) : "string" == typeof origin.loc ? sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`) : origin.loc && "object" == typeof origin.loc && "start" in origin.loc && sources.push(`${index} ${getModuleIdentifier(origin.module)} ${JSON.stringify(origin.loc.start)}`));
}
return sources;
};
compilation.hooks.recordChunks.tap("RecordIdsPlugin", ((chunks, records) => {
records.chunks || (records.chunks = {}), records.chunks.byName || (records.chunks.byName = {}), 
records.chunks.bySource || (records.chunks.bySource = {});
const usedIds = new Set;
for (const chunk of chunks) {
if ("number" != typeof chunk.id) continue;
const name = chunk.name;
name && (records.chunks.byName[name] = chunk.id);
const sources = getChunkSources(chunk);
for (const source of sources) records.chunks.bySource[source] = chunk.id;
usedIds.add(chunk.id);
}
records.chunks.usedIds = Array.from(usedIds).sort(compareNumbers);
})), compilation.hooks.reviveChunks.tap("RecordIdsPlugin", ((chunks, records) => {
if (!records.chunks) return;
const usedIds = new Set;
if (records.chunks.byName) for (const chunk of chunks) {
if (null !== chunk.id) continue;
if (!chunk.name) continue;
const id = records.chunks.byName[chunk.name];
void 0 !== id && (usedIds.has(id) || (usedIds.add(id), chunk.id = id, chunk.ids = [ id ]));
}
if (records.chunks.bySource) for (const chunk of chunks) {
if (null !== chunk.id) continue;
const sources = getChunkSources(chunk);
for (const source of sources) {
const id = records.chunks.bySource[source];
if (void 0 !== id && !usedIds.has(id)) {
usedIds.add(id), chunk.id = id, chunk.ids = [ id ];
break;
}
}
}
Array.isArray(records.chunks.usedIds) && (compilation.usedChunkIds = new Set(records.chunks.usedIds));
}));
}));
}
};
},
91190: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {contextify} = __webpack_require__(63264);
module.exports = class {
constructor(dir, associatedObjectForCache) {
this.contextify = contextify.bindContextCache(dir, associatedObjectForCache);
}
shorten(request) {
return request ? this.contextify(request) : request;
}
};
},
86834: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), ConstDependency = __webpack_require__(30339), {toConstantDependency} = __webpack_require__(78802);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RequireJsStuffPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
const handler = (parser, parserOptions) => {
void 0 !== parserOptions.requireJs && parserOptions.requireJs && (parser.hooks.call.for("require.config").tap("RequireJsStuffPlugin", toConstantDependency(parser, "undefined")), 
parser.hooks.call.for("requirejs.config").tap("RequireJsStuffPlugin", toConstantDependency(parser, "undefined")), 
parser.hooks.expression.for("require.version").tap("RequireJsStuffPlugin", toConstantDependency(parser, JSON.stringify("0.0.0"))), 
parser.hooks.expression.for("requirejs.onError").tap("RequireJsStuffPlugin", toConstantDependency(parser, RuntimeGlobals.uncaughtErrorHandler, [ RuntimeGlobals.uncaughtErrorHandler ])));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireJsStuffPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireJsStuffPlugin", handler);
}));
}
};
},
91628: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Factory = __webpack_require__(92672).ResolverFactory, {HookMap, SyncHook, SyncWaterfallHook} = __webpack_require__(89991), {cachedCleverMerge, removeOperations, resolveByProperty} = __webpack_require__(8639), EMPTY_RESOLVE_OPTIONS = {};
module.exports = class {
constructor() {
this.hooks = Object.freeze({
resolveOptions: new HookMap((() => new SyncWaterfallHook([ "resolveOptions" ]))),
resolver: new HookMap((() => new SyncHook([ "resolver", "resolveOptions", "userResolveOptions" ])))
}), this.cache = new Map;
}
get(type, resolveOptions = EMPTY_RESOLVE_OPTIONS) {
let typedCaches = this.cache.get(type);
typedCaches || (typedCaches = {
direct: new WeakMap,
stringified: new Map
}, this.cache.set(type, typedCaches));
const cachedResolver = typedCaches.direct.get(resolveOptions);
if (cachedResolver) return cachedResolver;
const ident = JSON.stringify(resolveOptions), resolver = typedCaches.stringified.get(ident);
if (resolver) return typedCaches.direct.set(resolveOptions, resolver), resolver;
const newResolver = this._create(type, resolveOptions);
return typedCaches.direct.set(resolveOptions, newResolver), typedCaches.stringified.set(ident, newResolver), 
newResolver;
}
_create(type, resolveOptionsWithDepType) {
const originalResolveOptions = {
...resolveOptionsWithDepType
}, resolveOptions = (resolveOptionsWithDepType => {
const {dependencyType, plugins, ...remaining} = resolveOptionsWithDepType, partialOptions = {
...remaining,
plugins: plugins && plugins.filter((item => "..." !== item))
};
if (!partialOptions.fileSystem) throw new Error("fileSystem is missing in resolveOptions, but it's required for enhanced-resolve");
return removeOperations(resolveByProperty(partialOptions, "byDependency", dependencyType));
})(this.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType)), resolver = Factory.createResolver(resolveOptions);
if (!resolver) throw new Error("No resolver created");
const childCache = new WeakMap;
return resolver.withOptions = options => {
const cacheEntry = childCache.get(options);
if (void 0 !== cacheEntry) return cacheEntry;
const mergedOptions = cachedCleverMerge(originalResolveOptions, options), resolver = this.get(type, mergedOptions);
return childCache.set(options, resolver), resolver;
}, this.hooks.resolver.for(type).call(resolver, resolveOptions, originalResolveOptions), 
resolver;
}
};
},
50980: (__unused_webpack_module, exports) => {
"use strict";
exports.require = "__webpack_require__", exports.requireScope = "__webpack_require__.*", 
exports.exports = "__webpack_exports__", exports.thisAsExports = "top-level-this-exports", 
exports.returnExportsFromRuntime = "return-exports-from-runtime", exports.module = "module", 
exports.moduleId = "module.id", exports.moduleLoaded = "module.loaded", exports.publicPath = "__webpack_require__.p", 
exports.entryModuleId = "__webpack_require__.s", exports.moduleCache = "__webpack_require__.c", 
exports.moduleFactories = "__webpack_require__.m", exports.moduleFactoriesAddOnly = "__webpack_require__.m (add only)", 
exports.ensureChunk = "__webpack_require__.e", exports.ensureChunkHandlers = "__webpack_require__.f", 
exports.ensureChunkIncludeEntries = "__webpack_require__.f (include entries)", exports.prefetchChunk = "__webpack_require__.E", 
exports.prefetchChunkHandlers = "__webpack_require__.F", exports.preloadChunk = "__webpack_require__.G", 
exports.preloadChunkHandlers = "__webpack_require__.H", exports.definePropertyGetters = "__webpack_require__.d", 
exports.makeNamespaceObject = "__webpack_require__.r", exports.createFakeNamespaceObject = "__webpack_require__.t", 
exports.compatGetDefaultExport = "__webpack_require__.n", exports.harmonyModuleDecorator = "__webpack_require__.hmd", 
exports.nodeModuleDecorator = "__webpack_require__.nmd", exports.getFullHash = "__webpack_require__.h", 
exports.wasmInstances = "__webpack_require__.w", exports.instantiateWasm = "__webpack_require__.v", 
exports.uncaughtErrorHandler = "__webpack_require__.oe", exports.scriptNonce = "__webpack_require__.nc", 
exports.loadScript = "__webpack_require__.l", exports.createScript = "__webpack_require__.ts", 
exports.createScriptUrl = "__webpack_require__.tu", exports.getTrustedTypesPolicy = "__webpack_require__.tt", 
exports.chunkName = "__webpack_require__.cn", exports.runtimeId = "__webpack_require__.j", 
exports.getChunkScriptFilename = "__webpack_require__.u", exports.getChunkCssFilename = "__webpack_require__.k", 
exports.hasCssModules = "has css modules", exports.getChunkUpdateScriptFilename = "__webpack_require__.hu", 
exports.getChunkUpdateCssFilename = "__webpack_require__.hk", exports.startup = "__webpack_require__.x", 
exports.startupNoDefault = "__webpack_require__.x (no default handler)", exports.startupOnlyAfter = "__webpack_require__.x (only after)", 
exports.startupOnlyBefore = "__webpack_require__.x (only before)", exports.chunkCallback = "webpackChunk", 
exports.startupEntrypoint = "__webpack_require__.X", exports.onChunksLoaded = "__webpack_require__.O", 
exports.externalInstallChunk = "__webpack_require__.C", exports.interceptModuleExecution = "__webpack_require__.i", 
exports.global = "__webpack_require__.g", exports.shareScopeMap = "__webpack_require__.S", 
exports.initializeSharing = "__webpack_require__.I", exports.currentRemoteGetScope = "__webpack_require__.R", 
exports.getUpdateManifestFilename = "__webpack_require__.hmrF", exports.hmrDownloadManifest = "__webpack_require__.hmrM", 
exports.hmrDownloadUpdateHandlers = "__webpack_require__.hmrC", exports.hmrModuleData = "__webpack_require__.hmrD", 
exports.hmrInvalidateModuleHandlers = "__webpack_require__.hmrI", exports.hmrRuntimeStatePrefix = "__webpack_require__.hmrS", 
exports.amdDefine = "__webpack_require__.amdD", exports.amdOptions = "__webpack_require__.amdO", 
exports.system = "__webpack_require__.System", exports.hasOwnProperty = "__webpack_require__.o", 
exports.systemContext = "__webpack_require__.y", exports.baseURI = "__webpack_require__.b", 
exports.relativeUrl = "__webpack_require__.U", exports.asyncModule = "__webpack_require__.a";
},
30823: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), OriginalSource = __webpack_require__(37946).OriginalSource, Module = __webpack_require__(36797), TYPES = new Set([ "runtime" ]);
class RuntimeModule extends Module {
constructor(name, stage = 0) {
super("runtime"), this.name = name, this.stage = stage, this.buildMeta = {}, this.buildInfo = {}, 
this.compilation = void 0, this.chunk = void 0, this.chunkGraph = void 0, this.fullHash = !1, 
this.dependentHash = !1, this._cachedGeneratedCode = void 0;
}
attach(compilation, chunk, chunkGraph = compilation.chunkGraph) {
this.compilation = compilation, this.chunk = chunk, this.chunkGraph = chunkGraph;
}
identifier() {
return `webpack/runtime/${this.name}`;
}
readableIdentifier(requestShortener) {
return `webpack/runtime/${this.name}`;
}
needBuild(context, callback) {
return callback(null, !1);
}
build(options, compilation, resolver, fs, callback) {
callback();
}
updateHash(hash, context) {
hash.update(this.name), hash.update(`${this.stage}`);
try {
this.fullHash || this.dependentHash ? hash.update(this.generate()) : hash.update(this.getGeneratedCode());
} catch (err) {
hash.update(err.message);
}
super.updateHash(hash, context);
}
getSourceTypes() {
return TYPES;
}
codeGeneration(context) {
const sources = new Map, generatedCode = this.getGeneratedCode();
return generatedCode && sources.set("runtime", this.useSourceMap || this.useSimpleSourceMap ? new OriginalSource(generatedCode, this.identifier()) : new RawSource(generatedCode)), 
{
sources,
runtimeRequirements: null
};
}
size(type) {
try {
const source = this.getGeneratedCode();
return source ? source.length : 0;
} catch (e) {
return 0;
}
}
generate() {
throw new (__webpack_require__(91266));
}
getGeneratedCode() {
return this._cachedGeneratedCode ? this._cachedGeneratedCode : this._cachedGeneratedCode = this.generate();
}
shouldIsolate() {
return !0;
}
}
RuntimeModule.STAGE_NORMAL = 0, RuntimeModule.STAGE_BASIC = 5, RuntimeModule.STAGE_ATTACH = 10, 
RuntimeModule.STAGE_TRIGGER = 20, module.exports = RuntimeModule;
},
90822: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), {getChunkFilenameTemplate} = __webpack_require__(94536), RuntimeRequirementsDependency = __webpack_require__(40680), JavascriptModulesPlugin = __webpack_require__(18362), AsyncModuleRuntimeModule = __webpack_require__(71740), AutoPublicPathRuntimeModule = __webpack_require__(16343), BaseUriRuntimeModule = __webpack_require__(6598), CompatGetDefaultExportRuntimeModule = __webpack_require__(60950), CompatRuntimeModule = __webpack_require__(59909), CreateFakeNamespaceObjectRuntimeModule = __webpack_require__(7947), CreateScriptRuntimeModule = __webpack_require__(64035), CreateScriptUrlRuntimeModule = __webpack_require__(61946), DefinePropertyGettersRuntimeModule = __webpack_require__(41616), EnsureChunkRuntimeModule = __webpack_require__(50427), GetChunkFilenameRuntimeModule = __webpack_require__(34429), GetMainFilenameRuntimeModule = __webpack_require__(99191), GetTrustedTypesPolicyRuntimeModule = __webpack_require__(21578), GlobalRuntimeModule = __webpack_require__(88206), HasOwnPropertyRuntimeModule = __webpack_require__(12271), LoadScriptRuntimeModule = __webpack_require__(84914), MakeNamespaceObjectRuntimeModule = __webpack_require__(45796), NonceRuntimeModule = __webpack_require__(99719), OnChunksLoadedRuntimeModule = __webpack_require__(36892), PublicPathRuntimeModule = __webpack_require__(18165), RelativeUrlRuntimeModule = __webpack_require__(1041), RuntimeIdRuntimeModule = __webpack_require__(38062), SystemContextRuntimeModule = __webpack_require__(71138), ShareRuntimeModule = __webpack_require__(59931), StringXor = __webpack_require__(81664), GLOBALS_ON_REQUIRE = [ RuntimeGlobals.chunkName, RuntimeGlobals.runtimeId, RuntimeGlobals.compatGetDefaultExport, RuntimeGlobals.createFakeNamespaceObject, RuntimeGlobals.createScript, RuntimeGlobals.createScriptUrl, RuntimeGlobals.getTrustedTypesPolicy, RuntimeGlobals.definePropertyGetters, RuntimeGlobals.ensureChunk, RuntimeGlobals.entryModuleId, RuntimeGlobals.getFullHash, RuntimeGlobals.global, RuntimeGlobals.makeNamespaceObject, RuntimeGlobals.moduleCache, RuntimeGlobals.moduleFactories, RuntimeGlobals.moduleFactoriesAddOnly, RuntimeGlobals.interceptModuleExecution, RuntimeGlobals.publicPath, RuntimeGlobals.baseURI, RuntimeGlobals.relativeUrl, RuntimeGlobals.scriptNonce, RuntimeGlobals.uncaughtErrorHandler, RuntimeGlobals.asyncModule, RuntimeGlobals.wasmInstances, RuntimeGlobals.instantiateWasm, RuntimeGlobals.shareScopeMap, RuntimeGlobals.initializeSharing, RuntimeGlobals.loadScript, RuntimeGlobals.systemContext, RuntimeGlobals.onChunksLoaded ], MODULE_DEPENDENCIES = {
[RuntimeGlobals.moduleLoaded]: [ RuntimeGlobals.module ],
[RuntimeGlobals.moduleId]: [ RuntimeGlobals.module ]
}, TREE_DEPENDENCIES = {
[RuntimeGlobals.definePropertyGetters]: [ RuntimeGlobals.hasOwnProperty ],
[RuntimeGlobals.compatGetDefaultExport]: [ RuntimeGlobals.definePropertyGetters ],
[RuntimeGlobals.createFakeNamespaceObject]: [ RuntimeGlobals.definePropertyGetters, RuntimeGlobals.makeNamespaceObject, RuntimeGlobals.require ],
[RuntimeGlobals.initializeSharing]: [ RuntimeGlobals.shareScopeMap ],
[RuntimeGlobals.shareScopeMap]: [ RuntimeGlobals.hasOwnProperty ]
};
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RuntimePlugin", (compilation => {
const globalChunkLoading = compilation.outputOptions.chunkLoading;
compilation.dependencyTemplates.set(RuntimeRequirementsDependency, new RuntimeRequirementsDependency.Template);
for (const req of GLOBALS_ON_REQUIRE) compilation.hooks.runtimeRequirementInModule.for(req).tap("RuntimePlugin", ((module, set) => {
set.add(RuntimeGlobals.requireScope);
})), compilation.hooks.runtimeRequirementInTree.for(req).tap("RuntimePlugin", ((module, set) => {
set.add(RuntimeGlobals.requireScope);
}));
for (const req of Object.keys(TREE_DEPENDENCIES)) {
const deps = TREE_DEPENDENCIES[req];
compilation.hooks.runtimeRequirementInTree.for(req).tap("RuntimePlugin", ((chunk, set) => {
for (const dep of deps) set.add(dep);
}));
}
for (const req of Object.keys(MODULE_DEPENDENCIES)) {
const deps = MODULE_DEPENDENCIES[req];
compilation.hooks.runtimeRequirementInModule.for(req).tap("RuntimePlugin", ((chunk, set) => {
for (const dep of deps) set.add(dep);
}));
}
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.definePropertyGetters).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new DefinePropertyGettersRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.makeNamespaceObject).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new MakeNamespaceObjectRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.createFakeNamespaceObject).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new CreateFakeNamespaceObjectRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hasOwnProperty).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new HasOwnPropertyRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.compatGetDefaultExport).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new CompatGetDefaultExportRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.runtimeId).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new RuntimeIdRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.publicPath).tap("RuntimePlugin", ((chunk, set) => {
const {outputOptions} = compilation, {publicPath: globalPublicPath, scriptType} = outputOptions, entryOptions = chunk.getEntryOptions(), publicPath = entryOptions && void 0 !== entryOptions.publicPath ? entryOptions.publicPath : globalPublicPath;
if ("auto" === publicPath) {
const module = new AutoPublicPathRuntimeModule;
"module" !== scriptType && set.add(RuntimeGlobals.global), compilation.addRuntimeModule(chunk, module);
} else {
const module = new PublicPathRuntimeModule(publicPath);
("string" != typeof publicPath || /\[(full)?hash\]/.test(publicPath)) && (module.fullHash = !0), 
compilation.addRuntimeModule(chunk, module);
}
return !0;
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.global).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new GlobalRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.asyncModule).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new AsyncModuleRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.systemContext).tap("RuntimePlugin", (chunk => {
const {outputOptions} = compilation, {library: globalLibrary} = outputOptions, entryOptions = chunk.getEntryOptions();
return "system" === (entryOptions && void 0 !== entryOptions.library ? entryOptions.library.type : globalLibrary.type) && compilation.addRuntimeModule(chunk, new SystemContextRuntimeModule), 
!0;
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.getChunkScriptFilename).tap("RuntimePlugin", ((chunk, set) => ("string" == typeof compilation.outputOptions.chunkFilename && /\[(full)?hash(:\d+)?\]/.test(compilation.outputOptions.chunkFilename) && set.add(RuntimeGlobals.getFullHash), 
compilation.addRuntimeModule(chunk, new GetChunkFilenameRuntimeModule("javascript", "javascript", RuntimeGlobals.getChunkScriptFilename, (chunk => chunk.filenameTemplate || (chunk.canBeInitial() ? compilation.outputOptions.filename : compilation.outputOptions.chunkFilename)), !1)), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.getChunkCssFilename).tap("RuntimePlugin", ((chunk, set) => ("string" == typeof compilation.outputOptions.cssChunkFilename && /\[(full)?hash(:\d+)?\]/.test(compilation.outputOptions.cssChunkFilename) && set.add(RuntimeGlobals.getFullHash), 
compilation.addRuntimeModule(chunk, new GetChunkFilenameRuntimeModule("css", "css", RuntimeGlobals.getChunkCssFilename, (chunk => getChunkFilenameTemplate(chunk, compilation.outputOptions)), set.has(RuntimeGlobals.hmrDownloadUpdateHandlers))), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.getChunkUpdateScriptFilename).tap("RuntimePlugin", ((chunk, set) => (/\[(full)?hash(:\d+)?\]/.test(compilation.outputOptions.hotUpdateChunkFilename) && set.add(RuntimeGlobals.getFullHash), 
compilation.addRuntimeModule(chunk, new GetChunkFilenameRuntimeModule("javascript", "javascript update", RuntimeGlobals.getChunkUpdateScriptFilename, (c => compilation.outputOptions.hotUpdateChunkFilename), !0)), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.getUpdateManifestFilename).tap("RuntimePlugin", ((chunk, set) => (/\[(full)?hash(:\d+)?\]/.test(compilation.outputOptions.hotUpdateMainFilename) && set.add(RuntimeGlobals.getFullHash), 
compilation.addRuntimeModule(chunk, new GetMainFilenameRuntimeModule("update manifest", RuntimeGlobals.getUpdateManifestFilename, compilation.outputOptions.hotUpdateMainFilename)), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunk).tap("RuntimePlugin", ((chunk, set) => (chunk.hasAsyncChunks() && set.add(RuntimeGlobals.ensureChunkHandlers), 
compilation.addRuntimeModule(chunk, new EnsureChunkRuntimeModule(set)), !0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkIncludeEntries).tap("RuntimePlugin", ((chunk, set) => {
set.add(RuntimeGlobals.ensureChunkHandlers);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.shareScopeMap).tap("RuntimePlugin", ((chunk, set) => (compilation.addRuntimeModule(chunk, new ShareRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.loadScript).tap("RuntimePlugin", ((chunk, set) => {
const withCreateScriptUrl = !!compilation.outputOptions.trustedTypes;
return withCreateScriptUrl && set.add(RuntimeGlobals.createScriptUrl), compilation.addRuntimeModule(chunk, new LoadScriptRuntimeModule(withCreateScriptUrl)), 
!0;
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.createScript).tap("RuntimePlugin", ((chunk, set) => (compilation.outputOptions.trustedTypes && set.add(RuntimeGlobals.getTrustedTypesPolicy), 
compilation.addRuntimeModule(chunk, new CreateScriptRuntimeModule), !0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.createScriptUrl).tap("RuntimePlugin", ((chunk, set) => (compilation.outputOptions.trustedTypes && set.add(RuntimeGlobals.getTrustedTypesPolicy), 
compilation.addRuntimeModule(chunk, new CreateScriptUrlRuntimeModule), !0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.getTrustedTypesPolicy).tap("RuntimePlugin", ((chunk, set) => (compilation.addRuntimeModule(chunk, new GetTrustedTypesPolicyRuntimeModule(set)), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.relativeUrl).tap("RuntimePlugin", ((chunk, set) => (compilation.addRuntimeModule(chunk, new RelativeUrlRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.onChunksLoaded).tap("RuntimePlugin", ((chunk, set) => (compilation.addRuntimeModule(chunk, new OnChunksLoadedRuntimeModule), 
!0))), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.baseURI).tap("RuntimePlugin", (chunk => {
if ((chunk => {
const options = chunk.getEntryOptions();
return !1 === (options && void 0 !== options.chunkLoading ? options.chunkLoading : globalChunkLoading);
})(chunk)) return compilation.addRuntimeModule(chunk, new BaseUriRuntimeModule), 
!0;
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.scriptNonce).tap("RuntimePlugin", (chunk => (compilation.addRuntimeModule(chunk, new NonceRuntimeModule), 
!0))), compilation.hooks.additionalTreeRuntimeRequirements.tap("RuntimePlugin", ((chunk, set) => {
const {mainTemplate} = compilation;
(mainTemplate.hooks.bootstrap.isUsed() || mainTemplate.hooks.localVars.isUsed() || mainTemplate.hooks.requireEnsure.isUsed() || mainTemplate.hooks.requireExtensions.isUsed()) && compilation.addRuntimeModule(chunk, new CompatRuntimeModule);
})), JavascriptModulesPlugin.getCompilationHooks(compilation).chunkHash.tap("RuntimePlugin", ((chunk, hash, {chunkGraph}) => {
const xor = new StringXor;
for (const m of chunkGraph.getChunkRuntimeModulesIterable(chunk)) xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
xor.updateHash(hash);
}));
}));
}
};
},
52188: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), {equals} = __webpack_require__(8579), compileBooleanMatcher = __webpack_require__(65814), propertyAccess = __webpack_require__(10664), {forEachRuntime, subtractRuntime} = __webpack_require__(14372), noModuleIdErrorMessage = (module, chunkGraph) => `Module ${module.identifier()} has no id assigned.\nThis should not happen.\nIt's in these chunks: ${Array.from(chunkGraph.getModuleChunksIterable(module), (c => c.name || c.id || c.debugId)).join(", ") || "none"} (If module is in no chunk this indicates a bug in some chunk/module optimization logic)\nModule has these incoming connections: ${Array.from(chunkGraph.moduleGraph.getIncomingConnections(module), (connection => `\n - ${connection.originModule && connection.originModule.identifier()} ${connection.dependency && connection.dependency.type} ${connection.explanations && Array.from(connection.explanations).join(", ") || ""}`)).join("")}`;
module.exports = class {
constructor(compilation, outputOptions, requestShortener) {
this.compilation = compilation, this.outputOptions = outputOptions || {}, this.requestShortener = requestShortener, 
this.globalObject = function(definition) {
if (!definition) return definition;
const trimmed = definition.trim();
return trimmed.match(/^[_\p{L}][_0-9\p{L}]*$/iu) || trimmed.match(/^([_\p{L}][_0-9\p{L}]*)?\(.*\)$/iu) ? trimmed : `Object(${trimmed})`;
}(outputOptions.globalObject), this.contentHashReplacement = "X".repeat(outputOptions.hashDigestLength);
}
isIIFE() {
return this.outputOptions.iife;
}
isModule() {
return this.outputOptions.module;
}
supportsConst() {
return this.outputOptions.environment.const;
}
supportsArrowFunction() {
return this.outputOptions.environment.arrowFunction;
}
supportsOptionalChaining() {
return this.outputOptions.environment.optionalChaining;
}
supportsForOf() {
return this.outputOptions.environment.forOf;
}
supportsDestructuring() {
return this.outputOptions.environment.destructuring;
}
supportsBigIntLiteral() {
return this.outputOptions.environment.bigIntLiteral;
}
supportsDynamicImport() {
return this.outputOptions.environment.dynamicImport;
}
supportsEcmaScriptModuleSyntax() {
return this.outputOptions.environment.module;
}
supportTemplateLiteral() {
return this.outputOptions.environment.templateLiteral;
}
returningFunction(returnValue, args = "") {
return this.supportsArrowFunction() ? `(${args}) => (${returnValue})` : `function(${args}) { return ${returnValue}; }`;
}
basicFunction(args, body) {
return this.supportsArrowFunction() ? `(${args}) => {\n${Template.indent(body)}\n}` : `function(${args}) {\n${Template.indent(body)}\n}`;
}
concatenation(...args) {
const len = args.length;
if (2 === len) return this._es5Concatenation(args);
if (0 === len) return '""';
if (1 === len) return "string" == typeof args[0] ? JSON.stringify(args[0]) : `"" + ${args[0].expr}`;
if (!this.supportTemplateLiteral()) return this._es5Concatenation(args);
let templateCost = 0, concatenationCost = 0, lastWasExpr = !1;
for (const arg of args) {
const isExpr = "string" != typeof arg;
isExpr && (templateCost += 3, concatenationCost += lastWasExpr ? 1 : 4), lastWasExpr = isExpr;
}
return lastWasExpr && (concatenationCost -= 3), "string" != typeof args[0] && "string" == typeof args[1] && (concatenationCost -= 3), 
concatenationCost <= templateCost ? this._es5Concatenation(args) : `\`${args.map((arg => "string" == typeof arg ? arg : `\${${arg.expr}}`)).join("")}\``;
}
_es5Concatenation(args) {
const str = args.map((arg => "string" == typeof arg ? JSON.stringify(arg) : arg.expr)).join(" + ");
return "string" != typeof args[0] && "string" != typeof args[1] ? `"" + ${str}` : str;
}
expressionFunction(expression, args = "") {
return this.supportsArrowFunction() ? `(${args}) => (${expression})` : `function(${args}) { ${expression}; }`;
}
emptyFunction() {
return this.supportsArrowFunction() ? "x => {}" : "function() {}";
}
destructureArray(items, value) {
return this.supportsDestructuring() ? `var [${items.join(", ")}] = ${value};` : Template.asString(items.map(((item, i) => `var ${item} = ${value}[${i}];`)));
}
destructureObject(items, value) {
return this.supportsDestructuring() ? `var {${items.join(", ")}} = ${value};` : Template.asString(items.map((item => `var ${item} = ${value}${propertyAccess([ item ])};`)));
}
iife(args, body) {
return `(${this.basicFunction(args, body)})()`;
}
forEach(variable, array, body) {
return this.supportsForOf() ? `for(const ${variable} of ${array}) {\n${Template.indent(body)}\n}` : `${array}.forEach(function(${variable}) {\n${Template.indent(body)}\n});`;
}
comment({request, chunkName, chunkReason, message, exportName}) {
let content;
return content = this.outputOptions.pathinfo ? [ message, request, chunkName, chunkReason ].filter(Boolean).map((item => this.requestShortener.shorten(item))).join(" | ") : [ message, chunkName, chunkReason ].filter(Boolean).map((item => this.requestShortener.shorten(item))).join(" | "), 
content ? this.outputOptions.pathinfo ? Template.toComment(content) + " " : Template.toNormalComment(content) + " " : "";
}
throwMissingModuleErrorBlock({request}) {
const err = `Cannot find module '${request}'`;
return `var e = new Error(${JSON.stringify(err)}); e.code = 'MODULE_NOT_FOUND'; throw e;`;
}
throwMissingModuleErrorFunction({request}) {
return `function webpackMissingModule() { ${this.throwMissingModuleErrorBlock({
request
})} }`;
}
missingModule({request}) {
return `Object(${this.throwMissingModuleErrorFunction({
request
})}())`;
}
missingModuleStatement({request}) {
return `${this.missingModule({
request
})};\n`;
}
missingModulePromise({request}) {
return `Promise.resolve().then(${this.throwMissingModuleErrorFunction({
request
})})`;
}
weakError({module, chunkGraph, request, idExpr, type}) {
const moduleId = chunkGraph.getModuleId(module), errorStatements = `var e = new Error(${null === moduleId ? JSON.stringify("Module is not available (weak dependency)") : idExpr ? `"Module '" + ${idExpr} + "' is not available (weak dependency)"` : JSON.stringify(`Module '${moduleId}' is not available (weak dependency)`)}); ` + (request ? Template.toNormalComment(request) + " " : "") + "e.code = 'MODULE_NOT_FOUND'; throw e;";
switch (type) {
case "statements":
return errorStatements;

case "promise":
return `Promise.resolve().then(${this.basicFunction("", errorStatements)})`;

case "expression":
return this.iife("", errorStatements);
}
}
moduleId({module, chunkGraph, request, weak}) {
if (!module) return this.missingModule({
request
});
const moduleId = chunkGraph.getModuleId(module);
if (null === moduleId) {
if (weak) return "null /* weak dependency, without id */";
throw new Error(`RuntimeTemplate.moduleId(): ${noModuleIdErrorMessage(module, chunkGraph)}`);
}
return `${this.comment({
request
})}${JSON.stringify(moduleId)}`;
}
moduleRaw({module, chunkGraph, request, weak, runtimeRequirements}) {
if (!module) return this.missingModule({
request
});
if (null === chunkGraph.getModuleId(module)) {
if (weak) return this.weakError({
module,
chunkGraph,
request,
type: "expression"
});
throw new Error(`RuntimeTemplate.moduleId(): ${noModuleIdErrorMessage(module, chunkGraph)}`);
}
return runtimeRequirements.add(RuntimeGlobals.require), `__webpack_require__(${this.moduleId({
module,
chunkGraph,
request,
weak
})})`;
}
moduleExports({module, chunkGraph, request, weak, runtimeRequirements}) {
return this.moduleRaw({
module,
chunkGraph,
request,
weak,
runtimeRequirements
});
}
moduleNamespace({module, chunkGraph, request, strict, weak, runtimeRequirements}) {
if (!module) return this.missingModule({
request
});
if (null === chunkGraph.getModuleId(module)) {
if (weak) return this.weakError({
module,
chunkGraph,
request,
type: "expression"
});
throw new Error(`RuntimeTemplate.moduleNamespace(): ${noModuleIdErrorMessage(module, chunkGraph)}`);
}
const moduleId = this.moduleId({
module,
chunkGraph,
request,
weak
});
switch (module.getExportsType(chunkGraph.moduleGraph, strict)) {
case "namespace":
return this.moduleRaw({
module,
chunkGraph,
request,
weak,
runtimeRequirements
});

case "default-with-named":
return runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), `${RuntimeGlobals.createFakeNamespaceObject}(${moduleId}, 3)`;

case "default-only":
return runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), `${RuntimeGlobals.createFakeNamespaceObject}(${moduleId}, 1)`;

case "dynamic":
return runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), `${RuntimeGlobals.createFakeNamespaceObject}(${moduleId}, 7)`;
}
}
moduleNamespacePromise({chunkGraph, block, module, request, message, strict, weak, runtimeRequirements}) {
if (!module) return this.missingModulePromise({
request
});
if (null === chunkGraph.getModuleId(module)) {
if (weak) return this.weakError({
module,
chunkGraph,
request,
type: "promise"
});
throw new Error(`RuntimeTemplate.moduleNamespacePromise(): ${noModuleIdErrorMessage(module, chunkGraph)}`);
}
const promise = this.blockPromise({
chunkGraph,
block,
message,
runtimeRequirements
});
let appending, idExpr = JSON.stringify(chunkGraph.getModuleId(module));
const comment = this.comment({
request
});
let header = "";
weak && (idExpr.length > 8 && (header += `var id = ${idExpr}; `, idExpr = "id"), 
runtimeRequirements.add(RuntimeGlobals.moduleFactories), header += `if(!${RuntimeGlobals.moduleFactories}[${idExpr}]) { ${this.weakError({
module,
chunkGraph,
request,
idExpr,
type: "statements"
})} } `);
const moduleIdExpr = this.moduleId({
module,
chunkGraph,
request,
weak
});
let fakeType = 16;
switch (module.getExportsType(chunkGraph.moduleGraph, strict)) {
case "namespace":
if (header) {
const rawModule = this.moduleRaw({
module,
chunkGraph,
request,
weak,
runtimeRequirements
});
appending = `.then(${this.basicFunction("", `${header}return ${rawModule};`)})`;
} else runtimeRequirements.add(RuntimeGlobals.require), appending = `.then(__webpack_require__.bind(__webpack_require__, ${comment}${idExpr}))`;
break;

case "dynamic":
fakeType |= 4;

case "default-with-named":
fakeType |= 2;

case "default-only":
if (runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), chunkGraph.moduleGraph.isAsync(module)) {
if (header) {
const rawModule = this.moduleRaw({
module,
chunkGraph,
request,
weak,
runtimeRequirements
});
appending = `.then(${this.basicFunction("", `${header}return ${rawModule};`)})`;
} else runtimeRequirements.add(RuntimeGlobals.require), appending = `.then(__webpack_require__.bind(__webpack_require__, ${comment}${idExpr}))`;
appending += `.then(${this.returningFunction(`${RuntimeGlobals.createFakeNamespaceObject}(m, ${fakeType})`, "m")})`;
} else if (fakeType |= 1, header) {
const returnExpression = `${RuntimeGlobals.createFakeNamespaceObject}(${moduleIdExpr}, ${fakeType})`;
appending = `.then(${this.basicFunction("", `${header}return ${returnExpression};`)})`;
} else appending = `.then(${RuntimeGlobals.createFakeNamespaceObject}.bind(__webpack_require__, ${comment}${idExpr}, ${fakeType}))`;
}
return `${promise || "Promise.resolve()"}${appending}`;
}
runtimeConditionExpression({chunkGraph, runtimeCondition, runtime, runtimeRequirements}) {
if (void 0 === runtimeCondition) return "true";
if ("boolean" == typeof runtimeCondition) return `${runtimeCondition}`;
const positiveRuntimeIds = new Set;
forEachRuntime(runtimeCondition, (runtime => positiveRuntimeIds.add(`${chunkGraph.getRuntimeId(runtime)}`)));
const negativeRuntimeIds = new Set;
return forEachRuntime(subtractRuntime(runtime, runtimeCondition), (runtime => negativeRuntimeIds.add(`${chunkGraph.getRuntimeId(runtime)}`))), 
runtimeRequirements.add(RuntimeGlobals.runtimeId), compileBooleanMatcher.fromLists(Array.from(positiveRuntimeIds), Array.from(negativeRuntimeIds))(RuntimeGlobals.runtimeId);
}
importStatement({update, module, chunkGraph, request, importVar, originModule, weak, runtimeRequirements}) {
if (!module) return [ this.missingModuleStatement({
request
}), "" ];
if (null === chunkGraph.getModuleId(module)) {
if (weak) return [ this.weakError({
module,
chunkGraph,
request,
type: "statements"
}), "" ];
throw new Error(`RuntimeTemplate.importStatement(): ${noModuleIdErrorMessage(module, chunkGraph)}`);
}
const moduleId = this.moduleId({
module,
chunkGraph,
request,
weak
}), optDeclaration = update ? "" : "var ", exportsType = module.getExportsType(chunkGraph.moduleGraph, originModule.buildMeta.strictHarmonyModule);
runtimeRequirements.add(RuntimeGlobals.require);
const importContent = `/* harmony import */ ${optDeclaration}${importVar} = __webpack_require__(${moduleId});\n`;
return "dynamic" === exportsType ? (runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport), 
[ importContent, `/* harmony import */ ${optDeclaration}${importVar}_default = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${importVar});\n` ]) : [ importContent, "" ];
}
exportFromImport({moduleGraph, module, request, exportName, originModule, asiSafe, isCall, callContext, defaultInterop, importVar, initFragments, runtime, runtimeRequirements}) {
if (!module) return this.missingModule({
request
});
Array.isArray(exportName) || (exportName = exportName ? [ exportName ] : []);
const exportsType = module.getExportsType(moduleGraph, originModule.buildMeta.strictHarmonyModule);
if (defaultInterop) if (exportName.length > 0 && "default" === exportName[0]) switch (exportsType) {
case "dynamic":
return isCall ? `${importVar}_default()${propertyAccess(exportName, 1)}` : asiSafe ? `(${importVar}_default()${propertyAccess(exportName, 1)})` : !1 === asiSafe ? `;(${importVar}_default()${propertyAccess(exportName, 1)})` : `${importVar}_default.a${propertyAccess(exportName, 1)}`;

case "default-only":
case "default-with-named":
exportName = exportName.slice(1);
} else if (exportName.length > 0) {
if ("default-only" === exportsType) return "/* non-default import from non-esm module */undefined" + propertyAccess(exportName, 1);
if ("namespace" !== exportsType && "__esModule" === exportName[0]) return "/* __esModule */true";
} else if ("default-only" === exportsType || "default-with-named" === exportsType) return runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), 
initFragments.push(new InitFragment(`var ${importVar}_namespace_cache;\n`, InitFragment.STAGE_CONSTANTS, -1, `${importVar}_namespace_cache`)), 
`/*#__PURE__*/ ${asiSafe ? "" : !1 === asiSafe ? ";" : "Object"}(${importVar}_namespace_cache || (${importVar}_namespace_cache = ${RuntimeGlobals.createFakeNamespaceObject}(${importVar}${"default-only" === exportsType ? "" : ", 2"})))`;
if (exportName.length > 0) {
const used = moduleGraph.getExportsInfo(module).getUsedName(exportName, runtime);
if (!used) {
return `${Template.toNormalComment(`unused export ${propertyAccess(exportName)}`)} undefined`;
}
const access = `${importVar}${equals(used, exportName) ? "" : Template.toNormalComment(propertyAccess(exportName)) + " "}${propertyAccess(used)}`;
return isCall && !1 === callContext ? asiSafe ? `(0,${access})` : !1 === asiSafe ? `;(0,${access})` : `/*#__PURE__*/Object(${access})` : access;
}
return importVar;
}
blockPromise({block, message, chunkGraph, runtimeRequirements}) {
if (!block) {
return `Promise.resolve(${this.comment({
message
}).trim()})`;
}
const chunkGroup = chunkGraph.getBlockChunkGroup(block);
if (!chunkGroup || 0 === chunkGroup.chunks.length) {
return `Promise.resolve(${this.comment({
message
}).trim()})`;
}
const chunks = chunkGroup.chunks.filter((chunk => !chunk.hasRuntime() && null !== chunk.id)), comment = this.comment({
message,
chunkName: block.chunkName
});
if (1 === chunks.length) {
const chunkId = JSON.stringify(chunks[0].id);
return runtimeRequirements.add(RuntimeGlobals.ensureChunk), `${RuntimeGlobals.ensureChunk}(${comment}${chunkId})`;
}
if (chunks.length > 0) {
runtimeRequirements.add(RuntimeGlobals.ensureChunk);
const requireChunkId = chunk => `${RuntimeGlobals.ensureChunk}(${JSON.stringify(chunk.id)})`;
return `Promise.all(${comment.trim()}[${chunks.map(requireChunkId).join(", ")}])`;
}
return `Promise.resolve(${comment.trim()})`;
}
asyncModuleFactory({block, chunkGraph, runtimeRequirements, request}) {
const dep = block.dependencies[0], module = chunkGraph.moduleGraph.getModule(dep), ensureChunk = this.blockPromise({
block,
message: "",
chunkGraph,
runtimeRequirements
}), factory = this.returningFunction(this.moduleRaw({
module,
chunkGraph,
request,
runtimeRequirements
}));
return this.returningFunction(ensureChunk.startsWith("Promise.resolve(") ? `${factory}` : `${ensureChunk}.then(${this.returningFunction(factory)})`);
}
syncModuleFactory({dependency, chunkGraph, runtimeRequirements, request}) {
const module = chunkGraph.moduleGraph.getModule(dependency), factory = this.returningFunction(this.moduleRaw({
module,
chunkGraph,
request,
runtimeRequirements
}));
return this.returningFunction(factory);
}
defineEsModuleFlagStatement({exportsArgument, runtimeRequirements}) {
return runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject), runtimeRequirements.add(RuntimeGlobals.exports), 
`${RuntimeGlobals.makeNamespaceObject}(${exportsArgument});\n`;
}
assetUrl({publicPath, runtime, module, codeGenerationResults}) {
if (!module) return "data:,";
const codeGen = codeGenerationResults.get(module, runtime), {data} = codeGen, url = data.get("url");
if (url) return url.toString();
return publicPath + data.get("filename");
}
};
},
21465: module => {
"use strict";
module.exports = class {
constructor(moduleGraph) {
this.moduleGraph = moduleGraph;
}
create(data, callback) {
callback(null, {
module: this.moduleGraph.getParentModule(data.dependencies[0])
});
}
};
},
9568: (__unused_webpack_module, exports) => {
"use strict";
exports.formatSize = size => {
if ("number" != typeof size || !0 === Number.isNaN(size)) return "unknown size";
if (size <= 0) return "0 bytes";
const index = Math.floor(Math.log(size) / Math.log(1024));
return `${+(size / Math.pow(1024, index)).toPrecision(3)} ${[ "bytes", "KiB", "MiB", "GiB" ][index]}`;
};
},
89712: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const JavascriptModulesPlugin = __webpack_require__(18362);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compilation) {
!1 !== this.options.module ? (compilation.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin", (module => {
module.useSourceMap = !0;
})), compilation.hooks.runtimeModule.tap("SourceMapDevToolModuleOptionsPlugin", (module => {
module.useSourceMap = !0;
}))) : (compilation.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin", (module => {
module.useSimpleSourceMap = !0;
})), compilation.hooks.runtimeModule.tap("SourceMapDevToolModuleOptionsPlugin", (module => {
module.useSimpleSourceMap = !0;
}))), JavascriptModulesPlugin.getCompilationHooks(compilation).useSourceMap.tap("SourceMapDevToolModuleOptionsPlugin", (() => !0));
}
};
},
26131: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), {ConcatSource, RawSource} = __webpack_require__(37946), Compilation = __webpack_require__(62843), ModuleFilenameHelpers = __webpack_require__(23833), ProgressPlugin = __webpack_require__(17331), SourceMapDevToolModuleOptionsPlugin = __webpack_require__(89712), createSchemaValidation = __webpack_require__(59586), createHash = __webpack_require__(27466), {relative, dirname} = __webpack_require__(57075), {makePathsAbsolute} = __webpack_require__(63264), validate = createSchemaValidation(__webpack_require__(61710), (() => __webpack_require__(78061)), {
name: "SourceMap DevTool Plugin",
baseDataPath: "options"
}), quoteMeta = str => str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&");
module.exports = class {
constructor(options = {}) {
validate(options), this.sourceMapFilename = options.filename, this.sourceMappingURLComment = !1 !== options.append && (options.append || "\n//# sourceMappingURL=[url]"), 
this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]", 
this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack://[namespace]/[resourcePath]?[hash]", 
this.namespace = options.namespace || "", this.options = options;
}
apply(compiler) {
const outputFs = compiler.outputFileSystem, sourceMapFilename = this.sourceMapFilename, sourceMappingURLComment = this.sourceMappingURLComment, moduleFilenameTemplate = this.moduleFilenameTemplate, namespace = this.namespace, fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate, requestShortener = compiler.requestShortener, options = this.options;
options.test = options.test || /\.((c|m)?js|css)($|\?)/i;
const matchObject = ModuleFilenameHelpers.matchObject.bind(void 0, options);
compiler.hooks.compilation.tap("SourceMapDevToolPlugin", (compilation => {
new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation), compilation.hooks.processAssets.tapAsync({
name: "SourceMapDevToolPlugin",
stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,
additionalAssets: !0
}, ((assets, callback) => {
const chunkGraph = compilation.chunkGraph, cache = compilation.getCache("SourceMapDevToolPlugin"), moduleToSourceNameMapping = new Map, reportProgress = ProgressPlugin.getReporter(compilation.compiler) || (() => {}), fileToChunk = new Map;
for (const chunk of compilation.chunks) {
for (const file of chunk.files) fileToChunk.set(file, chunk);
for (const file of chunk.auxiliaryFiles) fileToChunk.set(file, chunk);
}
const files = [];
for (const file of Object.keys(assets)) matchObject(file) && files.push(file);
reportProgress(0);
const tasks = [];
let fileIndex = 0;
asyncLib.each(files, ((file, callback) => {
const asset = compilation.getAsset(file);
if (asset.info.related && asset.info.related.sourceMap) return fileIndex++, callback();
const cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));
cacheItem.get(((err, cacheEntry) => {
if (err) return callback(err);
if (cacheEntry) {
const {assets, assetsInfo} = cacheEntry;
for (const cachedFile of Object.keys(assets)) if (cachedFile === file ? compilation.updateAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]) : compilation.emitAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]), 
cachedFile !== file) {
const chunk = fileToChunk.get(file);
void 0 !== chunk && chunk.auxiliaryFiles.add(cachedFile);
}
return reportProgress(.5 * ++fileIndex / files.length, file, "restored cached SourceMap"), 
callback();
}
reportProgress(.5 * fileIndex / files.length, file, "generate SourceMap");
const task = ((file, asset, assetInfo, options, compilation, cacheItem) => {
let source, sourceMap;
if (asset.sourceAndMap) {
const sourceAndMap = asset.sourceAndMap(options);
sourceMap = sourceAndMap.map, source = sourceAndMap.source;
} else sourceMap = asset.map(options), source = asset.source();
if (!sourceMap || "string" != typeof source) return;
const context = compilation.options.context, root = compilation.compiler.root, cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root), modules = sourceMap.sources.map((source => source.startsWith("webpack://") ? (source = cachedAbsolutify(source.slice(10)), 
compilation.findModule(source) || source) : source));
return {
file,
asset,
source,
assetInfo,
sourceMap,
modules,
cacheItem
};
})(file, asset.source, asset.info, {
module: options.module,
columns: options.columns
}, compilation, cacheItem);
if (task) {
const modules = task.modules;
for (let idx = 0; idx < modules.length; idx++) {
const module = modules[idx];
moduleToSourceNameMapping.get(module) || moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {
moduleFilenameTemplate,
namespace
}, {
requestShortener,
chunkGraph,
hashFunction: compilation.outputOptions.hashFunction
}));
}
tasks.push(task);
}
reportProgress(.5 * ++fileIndex / files.length, file, "generated SourceMap"), callback();
}));
}), (err => {
if (err) return callback(err);
reportProgress(.5, "resolve sources");
const usedNamesSet = new Set(moduleToSourceNameMapping.values()), conflictDetectionSet = new Set, allModules = Array.from(moduleToSourceNameMapping.keys()).sort(((a, b) => {
const ai = "string" == typeof a ? a : a.identifier(), bi = "string" == typeof b ? b : b.identifier();
return ai.length - bi.length;
}));
for (let idx = 0; idx < allModules.length; idx++) {
const module = allModules[idx];
let sourceName = moduleToSourceNameMapping.get(module), hasName = conflictDetectionSet.has(sourceName);
if (hasName) if (sourceName = ModuleFilenameHelpers.createFilename(module, {
moduleFilenameTemplate: fallbackModuleFilenameTemplate,
namespace
}, {
requestShortener,
chunkGraph,
hashFunction: compilation.outputOptions.hashFunction
}), hasName = usedNamesSet.has(sourceName), hasName) {
for (;hasName; ) sourceName += "*", hasName = usedNamesSet.has(sourceName);
moduleToSourceNameMapping.set(module, sourceName), usedNamesSet.add(sourceName);
} else moduleToSourceNameMapping.set(module, sourceName), usedNamesSet.add(sourceName); else conflictDetectionSet.add(sourceName);
}
let taskIndex = 0;
asyncLib.each(tasks, ((task, callback) => {
const assets = Object.create(null), assetsInfo = Object.create(null), file = task.file, chunk = fileToChunk.get(file), sourceMap = task.sourceMap, source = task.source, modules = task.modules;
reportProgress(.5 + .5 * taskIndex / tasks.length, file, "attach SourceMap");
const moduleFilenames = modules.map((m => moduleToSourceNameMapping.get(m)));
sourceMap.sources = moduleFilenames, options.noSources && (sourceMap.sourcesContent = void 0), 
sourceMap.sourceRoot = options.sourceRoot || "", sourceMap.file = file;
const usesContentHash = sourceMapFilename && /\[contenthash(:\w+)?\]/.test(sourceMapFilename);
if (usesContentHash && task.assetInfo.contenthash) {
const contenthash = task.assetInfo.contenthash;
let pattern;
pattern = Array.isArray(contenthash) ? contenthash.map(quoteMeta).join("|") : quoteMeta(contenthash), 
sourceMap.file = sourceMap.file.replace(new RegExp(pattern, "g"), (m => "x".repeat(m.length)));
}
let currentSourceMappingURLComment = sourceMappingURLComment;
!1 !== currentSourceMappingURLComment && /\.css($|\?)/i.test(file) && (currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\n\/\/(.*)$/, "\n/*$1*/"));
const sourceMapString = JSON.stringify(sourceMap);
if (sourceMapFilename) {
let filename = file;
const sourceMapContentHash = usesContentHash && createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest("hex"), pathParams = {
chunk,
filename: options.fileContext ? relative(outputFs, `/${options.fileContext}`, `/${filename}`) : filename,
contentHash: sourceMapContentHash
}, {path: sourceMapFile, info: sourceMapInfo} = compilation.getPathWithInfo(sourceMapFilename, pathParams), sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, `/${file}`), `/${sourceMapFile}`);
let asset = new RawSource(source);
!1 !== currentSourceMappingURLComment && (asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({
url: sourceMapUrl
}, pathParams))));
const assetInfo = {
related: {
sourceMap: sourceMapFile
}
};
assets[file] = asset, assetsInfo[file] = assetInfo, compilation.updateAsset(file, asset, assetInfo);
const sourceMapAsset = new RawSource(sourceMapString), sourceMapAssetInfo = {
...sourceMapInfo,
development: !0
};
assets[sourceMapFile] = sourceMapAsset, assetsInfo[sourceMapFile] = sourceMapAssetInfo, 
compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo), void 0 !== chunk && chunk.auxiliaryFiles.add(sourceMapFile);
} else {
if (!1 === currentSourceMappingURLComment) throw new Error("SourceMapDevToolPlugin: append can't be false when no filename is provided");
const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\[map\]/g, (() => sourceMapString)).replace(/\[url\]/g, (() => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, "utf-8").toString("base64")}`)));
assets[file] = asset, assetsInfo[file] = void 0, compilation.updateAsset(file, asset);
}
task.cacheItem.store({
assets,
assetsInfo
}, (err => {
if (reportProgress(.5 + .5 * ++taskIndex / tasks.length, task.file, "attached SourceMap"), 
err) return callback(err);
callback();
}));
}), (err => {
reportProgress(1), callback(err);
}));
}));
}));
}));
}
};
},
16523: module => {
"use strict";
module.exports = class {
constructor(compilation) {
this.compilation = compilation;
}
get hash() {
return this.compilation.hash;
}
get startTime() {
return this.compilation.startTime;
}
get endTime() {
return this.compilation.endTime;
}
hasWarnings() {
return this.compilation.warnings.length > 0 || this.compilation.children.some((child => child.getStats().hasWarnings()));
}
hasErrors() {
return this.compilation.errors.length > 0 || this.compilation.children.some((child => child.getStats().hasErrors()));
}
toJson(options) {
options = this.compilation.createStatsOptions(options, {
forToString: !1
});
return this.compilation.createStatsFactory(options).create("compilation", this.compilation, {
compilation: this.compilation
});
}
toString(options) {
options = this.compilation.createStatsOptions(options, {
forToString: !0
});
const statsFactory = this.compilation.createStatsFactory(options), statsPrinter = this.compilation.createStatsPrinter(options), data = statsFactory.create("compilation", this.compilation, {
compilation: this.compilation
}), result = statsPrinter.print("compilation", data);
return void 0 === result ? "" : result;
}
};
},
88370: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, PrefixSource} = __webpack_require__(37946), START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0), START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0), DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1, NUMBER_OF_IDENTIFIER_START_CHARS = 2 * DELTA_A_TO_Z + 2, NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS = NUMBER_OF_IDENTIFIER_START_CHARS + 10, FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g, INDENT_MULTILINE_REGEX = /^\t/gm, LINE_SEPARATOR_REGEX = /\r?\n/g, IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/, IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g, COMMENT_END_REGEX = /\*\//g, PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g, MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g;
class Template {
static getFunctionContent(fn) {
return fn.toString().replace(FUNCTION_CONTENT_REGEX, "").replace(INDENT_MULTILINE_REGEX, "").replace(LINE_SEPARATOR_REGEX, "\n");
}
static toIdentifier(str) {
return "string" != typeof str ? "" : str.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_$1").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
}
static toComment(str) {
return str ? `/*! ${str.replace(COMMENT_END_REGEX, "* /")} */` : "";
}
static toNormalComment(str) {
return str ? `/* ${str.replace(COMMENT_END_REGEX, "* /")} */` : "";
}
static toPath(str) {
return "string" != typeof str ? "" : str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
}
static numberToIdentifier(n) {
return n >= NUMBER_OF_IDENTIFIER_START_CHARS ? Template.numberToIdentifier(n % NUMBER_OF_IDENTIFIER_START_CHARS) + Template.numberToIdentifierContinuation(Math.floor(n / NUMBER_OF_IDENTIFIER_START_CHARS)) : n < DELTA_A_TO_Z ? String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n) : (n -= DELTA_A_TO_Z) < DELTA_A_TO_Z ? String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n) : n === DELTA_A_TO_Z ? "_" : "$";
}
static numberToIdentifierContinuation(n) {
return n >= NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS ? Template.numberToIdentifierContinuation(n % NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS) + Template.numberToIdentifierContinuation(Math.floor(n / NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS)) : n < DELTA_A_TO_Z ? String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n) : (n -= DELTA_A_TO_Z) < DELTA_A_TO_Z ? String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n) : (n -= DELTA_A_TO_Z) < 10 ? `${n}` : 10 === n ? "_" : "$";
}
static indent(s) {
if (Array.isArray(s)) return s.map(Template.indent).join("\n");
{
const str = s.trimRight();
if (!str) return "";
return ("\n" === str[0] ? "" : "\t") + str.replace(/\n([^\n])/g, "\n\t$1");
}
}
static prefix(s, prefix) {
const str = Template.asString(s).trim();
if (!str) return "";
return ("\n" === str[0] ? "" : prefix) + str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
}
static asString(str) {
return Array.isArray(str) ? str.join("\n") : str;
}
static getModulesArrayBounds(modules) {
let maxId = -1 / 0, minId = 1 / 0;
for (const module of modules) {
const moduleId = module.id;
if ("number" != typeof moduleId) return !1;
maxId < moduleId && (maxId = moduleId), minId > moduleId && (minId = moduleId);
}
minId < 16 + ("" + minId).length && (minId = 0);
let objectOverhead = -1;
for (const module of modules) objectOverhead += `${module.id}`.length + 2;
return (0 === minId ? maxId : 16 + `${minId}`.length + maxId) < objectOverhead && [ minId, maxId ];
}
static renderChunkModules(renderContext, modules, renderModule, prefix = "") {
const {chunkGraph} = renderContext;
var source = new ConcatSource;
if (0 === modules.length) return null;
const allModules = modules.map((module => ({
id: chunkGraph.getModuleId(module),
source: renderModule(module) || "false"
}))), bounds = Template.getModulesArrayBounds(allModules);
if (bounds) {
const minId = bounds[0], maxId = bounds[1];
0 !== minId && source.add(`Array(${minId}).concat(`), source.add("[\n");
const modules = new Map;
for (const module of allModules) modules.set(module.id, module);
for (let idx = minId; idx <= maxId; idx++) {
const module = modules.get(idx);
idx !== minId && source.add(",\n"), source.add(`/* ${idx} */`), module && (source.add("\n"), 
source.add(module.source));
}
source.add("\n" + prefix + "]"), 0 !== minId && source.add(")");
} else {
source.add("{\n");
for (let i = 0; i < allModules.length; i++) {
const module = allModules[i];
0 !== i && source.add(",\n"), source.add(`\n/***/ ${JSON.stringify(module.id)}:\n`), 
source.add(module.source);
}
source.add(`\n\n${prefix}}`);
}
return source;
}
static renderRuntimeModules(runtimeModules, renderContext) {
const source = new ConcatSource;
for (const module of runtimeModules) {
const codeGenerationResults = renderContext.codeGenerationResults;
let runtimeSource;
if (codeGenerationResults) runtimeSource = codeGenerationResults.getSource(module, renderContext.chunk.runtime, "runtime"); else {
const codeGenResult = module.codeGeneration({
chunkGraph: renderContext.chunkGraph,
dependencyTemplates: renderContext.dependencyTemplates,
moduleGraph: renderContext.moduleGraph,
runtimeTemplate: renderContext.runtimeTemplate,
runtime: renderContext.chunk.runtime,
codeGenerationResults
});
if (!codeGenResult) continue;
runtimeSource = codeGenResult.sources.get("runtime");
}
runtimeSource && (source.add(Template.toNormalComment(module.identifier()) + "\n"), 
module.shouldIsolate() ? renderContext.runtimeTemplate.supportsArrowFunction() ? (source.add("(() => {\n"), 
source.add(new PrefixSource("\t", runtimeSource)), source.add("\n})();\n\n")) : (source.add("!function() {\n"), 
source.add(new PrefixSource("\t", runtimeSource)), source.add("\n}();\n\n")) : (source.add(runtimeSource), 
source.add("\n\n")));
}
return source;
}
static renderChunkRuntimeModules(runtimeModules, renderContext) {
return new PrefixSource("/******/ ", new ConcatSource("function(__webpack_require__) { // webpackRuntimeModules\n", this.renderRuntimeModules(runtimeModules, renderContext), "}\n"));
}
}
module.exports = Template, module.exports.NUMBER_OF_IDENTIFIER_START_CHARS = NUMBER_OF_IDENTIFIER_START_CHARS, 
module.exports.NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS = NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS;
},
66607: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const mime = __webpack_require__(80983), {basename, extname} = __webpack_require__(71017), util = __webpack_require__(73837), Chunk = __webpack_require__(76034), Module = __webpack_require__(36797), {parseResource} = __webpack_require__(63264), REGEXP = /\[\\*([\w:]+)\\*\]/gi, prepareId = id => {
if ("string" != typeof id) return id;
if (/^"\s\+*.*\+\s*"$/.test(id)) {
return `" + (${/^"\s\+*\s*(.*)\s*\+\s*"$/.exec(id)[1]} + "").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, "_") + "`;
}
return id.replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, "_");
}, hashLength = (replacer, handler, assetInfo, hashName) => (match, arg, input) => {
let result;
const length = arg && parseInt(arg, 10);
if (length && handler) result = handler(length); else {
const hash = replacer(match, arg, input);
result = length ? hash.slice(0, length) : hash;
}
return assetInfo && (assetInfo.immutable = !0, Array.isArray(assetInfo[hashName]) ? assetInfo[hashName] = [ ...assetInfo[hashName], result ] : assetInfo[hashName] ? assetInfo[hashName] = [ assetInfo[hashName], result ] : assetInfo[hashName] = result), 
result;
}, replacer = (value, allowEmpty) => (match, arg, input) => {
if ("function" == typeof value && (value = value()), null == value) {
if (!allowEmpty) throw new Error(`Path variable ${match} not implemented in this context: ${input}`);
return "";
}
return `${value}`;
}, deprecationCache = new Map, deprecatedFunction = () => {}, deprecated = (fn, message, code) => {
let d = deprecationCache.get(message);
return void 0 === d && (d = util.deprecate(deprecatedFunction, message, code), deprecationCache.set(message, d)), 
(...args) => (d(), fn(...args));
}, replacePathVariables = (path, data, assetInfo) => {
const chunkGraph = data.chunkGraph, replacements = new Map;
if ("string" == typeof data.filename) {
let match = data.filename.match(/^data:([^;,]+)/);
if (match) {
const ext = mime.extension(match[1]), emptyReplacer = replacer("", !0);
replacements.set("file", emptyReplacer), replacements.set("query", emptyReplacer), 
replacements.set("fragment", emptyReplacer), replacements.set("path", emptyReplacer), 
replacements.set("base", emptyReplacer), replacements.set("name", emptyReplacer), 
replacements.set("ext", replacer(ext ? `.${ext}` : "", !0)), replacements.set("filebase", deprecated(emptyReplacer, "[filebase] is now [base]", "DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_FILENAME"));
} else {
const {path: file, query, fragment} = parseResource(data.filename), ext = extname(file), base = basename(file), name = base.slice(0, base.length - ext.length), path = file.slice(0, file.length - base.length);
replacements.set("file", replacer(file)), replacements.set("query", replacer(query, !0)), 
replacements.set("fragment", replacer(fragment, !0)), replacements.set("path", replacer(path, !0)), 
replacements.set("base", replacer(base)), replacements.set("name", replacer(name)), 
replacements.set("ext", replacer(ext, !0)), replacements.set("filebase", deprecated(replacer(base), "[filebase] is now [base]", "DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_FILENAME"));
}
}
if (data.hash) {
const hashReplacer = hashLength(replacer(data.hash), data.hashWithLength, assetInfo, "fullhash");
replacements.set("fullhash", hashReplacer), replacements.set("hash", deprecated(hashReplacer, "[hash] is now [fullhash] (also consider using [chunkhash] or [contenthash], see documentation for details)", "DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_HASH"));
}
if (data.chunk) {
const chunk = data.chunk, contentHashType = data.contentHashType, idReplacer = replacer(chunk.id), nameReplacer = replacer(chunk.name || chunk.id), chunkhashReplacer = hashLength(replacer(chunk instanceof Chunk ? chunk.renderedHash : chunk.hash), "hashWithLength" in chunk ? chunk.hashWithLength : void 0, assetInfo, "chunkhash"), contenthashReplacer = hashLength(replacer(data.contentHash || contentHashType && chunk.contentHash && chunk.contentHash[contentHashType]), data.contentHashWithLength || ("contentHashWithLength" in chunk && chunk.contentHashWithLength ? chunk.contentHashWithLength[contentHashType] : void 0), assetInfo, "contenthash");
replacements.set("id", idReplacer), replacements.set("name", nameReplacer), replacements.set("chunkhash", chunkhashReplacer), 
replacements.set("contenthash", contenthashReplacer);
}
if (data.module) {
const module = data.module, idReplacer = replacer((() => prepareId(module instanceof Module ? chunkGraph.getModuleId(module) : module.id))), moduleHashReplacer = hashLength(replacer((() => module instanceof Module ? chunkGraph.getRenderedModuleHash(module, data.runtime) : module.hash)), "hashWithLength" in module ? module.hashWithLength : void 0, assetInfo, "modulehash"), contentHashReplacer = hashLength(replacer(data.contentHash), void 0, assetInfo, "contenthash");
replacements.set("id", idReplacer), replacements.set("modulehash", moduleHashReplacer), 
replacements.set("contenthash", contentHashReplacer), replacements.set("hash", data.contentHash ? contentHashReplacer : moduleHashReplacer), 
replacements.set("moduleid", deprecated(idReplacer, "[moduleid] is now [id]", "DEP_WEBPACK_TEMPLATE_PATH_PLUGIN_REPLACE_PATH_VARIABLES_MODULE_ID"));
}
return data.url && replacements.set("url", replacer(data.url)), "string" == typeof data.runtime ? replacements.set("runtime", replacer((() => prepareId(data.runtime)))) : replacements.set("runtime", replacer("_")), 
"function" == typeof path && (path = path(data, assetInfo)), path = path.replace(REGEXP, ((match, content) => {
if (content.length + 2 === match.length) {
const contentMatch = /^(\w+)(?::(\w+))?$/.exec(content);
if (!contentMatch) return match;
const [, kind, arg] = contentMatch, replacer = replacements.get(kind);
if (void 0 !== replacer) return replacer(match, arg, path);
} else if (match.startsWith("[\\") && match.endsWith("\\]")) return `[${match.slice(2, -2)}]`;
return match;
})), path;
}, plugin = "TemplatedPathPlugin";
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap(plugin, (compilation => {
compilation.hooks.assetPath.tap(plugin, replacePathVariables);
}));
}
};
},
48590: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class UnhandledSchemeError extends WebpackError {
constructor(scheme, resource) {
super(`Reading from "${resource}" is not handled by plugins (Unhandled scheme).\nWebpack supports "data:" and "file:" URIs by default.\nYou may need an additional plugin to handle "${scheme}:" URIs.`), 
this.file = resource, this.name = "UnhandledSchemeError";
}
}
makeSerializable(UnhandledSchemeError, "webpack/lib/UnhandledSchemeError", "UnhandledSchemeError"), 
module.exports = UnhandledSchemeError;
},
3490: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class UnsupportedFeatureWarning extends WebpackError {
constructor(message, loc) {
super(message), this.name = "UnsupportedFeatureWarning", this.loc = loc, this.hideStack = !0;
}
}
makeSerializable(UnsupportedFeatureWarning, "webpack/lib/UnsupportedFeatureWarning"), 
module.exports = UnsupportedFeatureWarning;
},
90417: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConstDependency = __webpack_require__(30339);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("UseStrictPlugin", ((compilation, {normalModuleFactory}) => {
const handler = parser => {
parser.hooks.program.tap("UseStrictPlugin", (ast => {
const firstNode = ast.body[0];
if (firstNode && "ExpressionStatement" === firstNode.type && "Literal" === firstNode.expression.type && "use strict" === firstNode.expression.value) {
const dep = new ConstDependency("", firstNode.range);
dep.loc = firstNode.loc, parser.state.module.addPresentationalDependency(dep), parser.state.module.buildInfo.strict = !0;
}
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("UseStrictPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("UseStrictPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("UseStrictPlugin", handler);
}));
}
};
},
16419: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const CaseSensitiveModulesWarning = __webpack_require__(64710);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("WarnCaseSensitiveModulesPlugin", (compilation => {
compilation.hooks.seal.tap("WarnCaseSensitiveModulesPlugin", (() => {
const moduleWithoutCase = new Map;
for (const module of compilation.modules) {
const identifier = module.identifier(), lowerIdentifier = identifier.toLowerCase();
let map = moduleWithoutCase.get(lowerIdentifier);
void 0 === map && (map = new Map, moduleWithoutCase.set(lowerIdentifier, map)), 
map.set(identifier, module);
}
for (const pair of moduleWithoutCase) {
const map = pair[1];
map.size > 1 && compilation.warnings.push(new CaseSensitiveModulesWarning(map.values(), compilation.moduleGraph));
}
}));
}));
}
};
},
96688: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
class DeprecatedOptionWarning extends WebpackError {
constructor(option, value, suggestion) {
super(), this.name = "DeprecatedOptionWarning", this.message = `configuration\nThe value '${value}' for option '${option}' is deprecated. Use '${suggestion}' instead.`;
}
}
module.exports = class {
constructor(option, value, suggestion) {
this.option = option, this.value = value, this.suggestion = suggestion;
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("WarnDeprecatedOptionPlugin", (compilation => {
compilation.warnings.push(new DeprecatedOptionWarning(this.option, this.value, this.suggestion));
}));
}
};
},
78209: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const NoModeWarning = __webpack_require__(24575);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("WarnNoModeSetPlugin", (compilation => {
compilation.warnings.push(new NoModeWarning);
}));
}
};
},
91158: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {groupBy} = __webpack_require__(8579), validate = __webpack_require__(59586)(__webpack_require__(99024), (() => __webpack_require__(91014)), {
name: "Watch Ignore Plugin",
baseDataPath: "options"
});
class IgnoringWatchFileSystem {
constructor(wfs, paths) {
this.wfs = wfs, this.paths = paths;
}
watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
files = Array.from(files), dirs = Array.from(dirs);
const ignored = path => this.paths.some((p => p instanceof RegExp ? p.test(path) : 0 === path.indexOf(p))), [ignoredFiles, notIgnoredFiles] = groupBy(files, ignored), [ignoredDirs, notIgnoredDirs] = groupBy(dirs, ignored), watcher = this.wfs.watch(notIgnoredFiles, notIgnoredDirs, missing, startTime, options, ((err, fileTimestamps, dirTimestamps, changedFiles, removedFiles) => {
if (err) return callback(err);
for (const path of ignoredFiles) fileTimestamps.set(path, "ignore");
for (const path of ignoredDirs) dirTimestamps.set(path, "ignore");
callback(err, fileTimestamps, dirTimestamps, changedFiles, removedFiles);
}), callbackUndelayed);
return {
close: () => watcher.close(),
pause: () => watcher.pause(),
getContextTimeInfoEntries: () => {
const dirTimestamps = watcher.getContextTimeInfoEntries();
for (const path of ignoredDirs) dirTimestamps.set(path, "ignore");
return dirTimestamps;
},
getFileTimeInfoEntries: () => {
const fileTimestamps = watcher.getFileTimeInfoEntries();
for (const path of ignoredFiles) fileTimestamps.set(path, "ignore");
return fileTimestamps;
},
getInfo: watcher.getInfo && (() => {
const info = watcher.getInfo(), {fileTimeInfoEntries, contextTimeInfoEntries} = info;
for (const path of ignoredFiles) fileTimeInfoEntries.set(path, "ignore");
for (const path of ignoredDirs) contextTimeInfoEntries.set(path, "ignore");
return info;
})
};
}
}
module.exports = class {
constructor(options) {
validate(options), this.paths = options.paths;
}
apply(compiler) {
compiler.hooks.afterEnvironment.tap("WatchIgnorePlugin", (() => {
compiler.watchFileSystem = new IgnoringWatchFileSystem(compiler.watchFileSystem, this.paths);
}));
}
};
},
69747: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Stats = __webpack_require__(16523);
module.exports = class {
constructor(compiler, watchOptions, handler) {
this.startTime = null, this.invalid = !1, this.handler = handler, this.callbacks = [], 
this._closeCallbacks = void 0, this.closed = !1, this.suspended = !1, this.blocked = !1, 
this._isBlocked = () => !1, this._onChange = () => {}, this._onInvalid = () => {}, 
this.watchOptions = "number" == typeof watchOptions ? {
aggregateTimeout: watchOptions
} : watchOptions && "object" == typeof watchOptions ? {
...watchOptions
} : {}, "number" != typeof this.watchOptions.aggregateTimeout && (this.watchOptions.aggregateTimeout = 20), 
this.compiler = compiler, this.running = !1, this._initial = !0, this._invalidReported = !0, 
this._needRecords = !0, this.watcher = void 0, this.pausedWatcher = void 0, this._collectedChangedFiles = void 0, 
this._collectedRemovedFiles = void 0, this._done = this._done.bind(this), process.nextTick((() => {
this._initial && this._invalidate();
}));
}
_mergeWithCollected(changedFiles, removedFiles) {
if (changedFiles) if (this._collectedChangedFiles) {
for (const file of changedFiles) this._collectedChangedFiles.add(file), this._collectedRemovedFiles.delete(file);
for (const file of removedFiles) this._collectedChangedFiles.delete(file), this._collectedRemovedFiles.add(file);
} else this._collectedChangedFiles = new Set(changedFiles), this._collectedRemovedFiles = new Set(removedFiles);
}
_go(fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles) {
if (this._initial = !1, null === this.startTime && (this.startTime = Date.now()), 
this.running = !0, this.watcher ? (this.pausedWatcher = this.watcher, this.lastWatcherStartTime = Date.now(), 
this.watcher.pause(), this.watcher = null) : this.lastWatcherStartTime || (this.lastWatcherStartTime = Date.now()), 
this.compiler.fsStartTime = Date.now(), changedFiles && removedFiles && fileTimeInfoEntries && contextTimeInfoEntries) this._mergeWithCollected(changedFiles, removedFiles), 
this.compiler.fileTimestamps = fileTimeInfoEntries, this.compiler.contextTimestamps = contextTimeInfoEntries; else if (this.pausedWatcher) if (this.pausedWatcher.getInfo) {
const {changes, removals, fileTimeInfoEntries, contextTimeInfoEntries} = this.pausedWatcher.getInfo();
this._mergeWithCollected(changes, removals), this.compiler.fileTimestamps = fileTimeInfoEntries, 
this.compiler.contextTimestamps = contextTimeInfoEntries;
} else this._mergeWithCollected(this.pausedWatcher.getAggregatedChanges && this.pausedWatcher.getAggregatedChanges(), this.pausedWatcher.getAggregatedRemovals && this.pausedWatcher.getAggregatedRemovals()), 
this.compiler.fileTimestamps = this.pausedWatcher.getFileTimeInfoEntries(), this.compiler.contextTimestamps = this.pausedWatcher.getContextTimeInfoEntries();
this.compiler.modifiedFiles = this._collectedChangedFiles, this._collectedChangedFiles = void 0, 
this.compiler.removedFiles = this._collectedRemovedFiles, this._collectedRemovedFiles = void 0;
const run = () => this.compiler.idle ? this.compiler.cache.endIdle((err => {
if (err) return this._done(err);
this.compiler.idle = !1, run();
})) : this._needRecords ? this.compiler.readRecords((err => {
if (err) return this._done(err);
this._needRecords = !1, run();
})) : (this.invalid = !1, this._invalidReported = !1, void this.compiler.hooks.watchRun.callAsync(this.compiler, (err => {
if (err) return this._done(err);
const onCompiled = (err, compilation) => err ? this._done(err, compilation) : this.invalid || !1 === this.compiler.hooks.shouldEmit.call(compilation) ? this._done(null, compilation) : void process.nextTick((() => {
const logger = compilation.getLogger("webpack.Compiler");
logger.time("emitAssets"), this.compiler.emitAssets(compilation, (err => (logger.timeEnd("emitAssets"), 
err ? this._done(err, compilation) : this.invalid ? this._done(null, compilation) : (logger.time("emitRecords"), 
void this.compiler.emitRecords((err => {
if (logger.timeEnd("emitRecords"), err) return this._done(err, compilation);
if (!compilation.hooks.needAdditionalPass.call()) return this._done(null, compilation);
{
compilation.needAdditionalPass = !0, compilation.startTime = this.startTime, compilation.endTime = Date.now(), 
logger.time("done hook");
const stats = new Stats(compilation);
this.compiler.hooks.done.callAsync(stats, (err => {
if (logger.timeEnd("done hook"), err) return this._done(err, compilation);
this.compiler.hooks.additionalPass.callAsync((err => {
if (err) return this._done(err, compilation);
this.compiler.compile(onCompiled);
}));
}));
}
}))))));
}));
this.compiler.compile(onCompiled);
})));
run();
}
_getStats(compilation) {
return new Stats(compilation);
}
_done(err, compilation) {
this.running = !1;
const logger = compilation && compilation.getLogger("webpack.Watching");
let stats = null;
const handleError = (err, cbs) => {
this.compiler.hooks.failed.call(err), this.compiler.cache.beginIdle(), this.compiler.idle = !0, 
this.handler(err, stats), cbs || (cbs = this.callbacks, this.callbacks = []);
for (const cb of cbs) cb(err);
};
if (this.invalid && !this.suspended && !this.blocked && (!this._isBlocked() || !(this.blocked = !0))) return void (compilation ? (logger.time("storeBuildDependencies"), 
this.compiler.cache.storeBuildDependencies(compilation.buildDependencies, (err => {
if (logger.timeEnd("storeBuildDependencies"), err) return handleError(err);
this._go();
}))) : this._go());
if (compilation && (compilation.startTime = this.startTime, compilation.endTime = Date.now(), 
stats = new Stats(compilation)), this.startTime = null, err) return handleError(err);
const cbs = this.callbacks;
this.callbacks = [], logger.time("done hook"), this.compiler.hooks.done.callAsync(stats, (err => {
if (logger.timeEnd("done hook"), err) return handleError(err, cbs);
this.handler(null, stats), logger.time("storeBuildDependencies"), this.compiler.cache.storeBuildDependencies(compilation.buildDependencies, (err => {
if (logger.timeEnd("storeBuildDependencies"), err) return handleError(err, cbs);
logger.time("beginIdle"), this.compiler.cache.beginIdle(), this.compiler.idle = !0, 
logger.timeEnd("beginIdle"), process.nextTick((() => {
this.closed || this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);
}));
for (const cb of cbs) cb(null);
this.compiler.hooks.afterDone.call(stats);
}));
}));
}
watch(files, dirs, missing) {
this.pausedWatcher = null, this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.lastWatcherStartTime, this.watchOptions, ((err, fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles) => {
if (err) return this.compiler.modifiedFiles = void 0, this.compiler.removedFiles = void 0, 
this.compiler.fileTimestamps = void 0, this.compiler.contextTimestamps = void 0, 
this.compiler.fsStartTime = void 0, this.handler(err);
this._invalidate(fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles), 
this._onChange();
}), ((fileName, changeTime) => {
this._invalidReported || (this._invalidReported = !0, this.compiler.hooks.invalid.call(fileName, changeTime)), 
this._onInvalid();
}));
}
invalidate(callback) {
callback && this.callbacks.push(callback), this._invalidReported || (this._invalidReported = !0, 
this.compiler.hooks.invalid.call(null, Date.now())), this._onChange(), this._invalidate();
}
_invalidate(fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles) {
this.suspended || this._isBlocked() && (this.blocked = !0) ? this._mergeWithCollected(changedFiles, removedFiles) : this.running ? (this._mergeWithCollected(changedFiles, removedFiles), 
this.invalid = !0) : this._go(fileTimeInfoEntries, contextTimeInfoEntries, changedFiles, removedFiles);
}
suspend() {
this.suspended = !0;
}
resume() {
this.suspended && (this.suspended = !1, this._invalidate());
}
close(callback) {
if (this._closeCallbacks) return void (callback && this._closeCallbacks.push(callback));
const finalCallback = (err, compilation) => {
this.running = !1, this.compiler.running = !1, this.compiler.watching = void 0, 
this.compiler.watchMode = !1, this.compiler.modifiedFiles = void 0, this.compiler.removedFiles = void 0, 
this.compiler.fileTimestamps = void 0, this.compiler.contextTimestamps = void 0, 
this.compiler.fsStartTime = void 0;
const shutdown = err => {
this.compiler.hooks.watchClose.call();
const closeCallbacks = this._closeCallbacks;
this._closeCallbacks = void 0;
for (const cb of closeCallbacks) cb(err);
};
if (compilation) {
const logger = compilation.getLogger("webpack.Watching");
logger.time("storeBuildDependencies"), this.compiler.cache.storeBuildDependencies(compilation.buildDependencies, (err2 => {
logger.timeEnd("storeBuildDependencies"), shutdown(err || err2);
}));
} else shutdown(err);
};
this.closed = !0, this.watcher && (this.watcher.close(), this.watcher = null), this.pausedWatcher && (this.pausedWatcher.close(), 
this.pausedWatcher = null), this._closeCallbacks = [], callback && this._closeCallbacks.push(callback), 
this.running ? (this.invalid = !0, this._done = finalCallback) : finalCallback();
}
};
},
64326: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const inspect = __webpack_require__(73837).inspect.custom, makeSerializable = __webpack_require__(45898);
class WebpackError extends Error {
constructor(message) {
super(message), this.details = void 0, this.module = void 0, this.loc = void 0, 
this.hideStack = void 0, this.chunk = void 0, this.file = void 0;
}
[inspect]() {
return this.stack + (this.details ? `\n${this.details}` : "");
}
serialize({write}) {
write(this.name), write(this.message), write(this.stack), write(this.details), write(this.loc), 
write(this.hideStack);
}
deserialize({read}) {
this.name = read(), this.message = read(), this.stack = read(), this.details = read(), 
this.loc = read(), this.hideStack = read();
}
}
makeSerializable(WebpackError, "webpack/lib/WebpackError"), module.exports = WebpackError;
},
64939: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const IgnoreErrorModuleFactory = __webpack_require__(99588), WebpackIsIncludedDependency = __webpack_require__(19981), {toConstantDependency} = __webpack_require__(78802);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("WebpackIsIncludedPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(WebpackIsIncludedDependency, new IgnoreErrorModuleFactory(normalModuleFactory)), 
compilation.dependencyTemplates.set(WebpackIsIncludedDependency, new WebpackIsIncludedDependency.Template);
const handler = parser => {
parser.hooks.call.for("__webpack_is_included__").tap("WebpackIsIncludedPlugin", (expr => {
if ("CallExpression" !== expr.type || 1 !== expr.arguments.length || "SpreadElement" === expr.arguments[0].type) return;
const request = parser.evaluateExpression(expr.arguments[0]);
if (!request.isString()) return;
const dep = new WebpackIsIncludedDependency(request.string, expr.range);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), !0;
})), parser.hooks.typeof.for("__webpack_is_included__").tap("WebpackIsIncludedPlugin", toConstantDependency(parser, JSON.stringify("function")));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("WebpackIsIncludedPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("WebpackIsIncludedPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("WebpackIsIncludedPlugin", handler);
}));
}
};
},
94890: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const OptionsApply = __webpack_require__(1114), AssetModulesPlugin = __webpack_require__(62170), JavascriptModulesPlugin = __webpack_require__(18362), JsonModulesPlugin = __webpack_require__(25175), ChunkPrefetchPreloadPlugin = __webpack_require__(42770), EntryOptionPlugin = __webpack_require__(51199), RecordIdsPlugin = __webpack_require__(9236), RuntimePlugin = __webpack_require__(90822), APIPlugin = __webpack_require__(25306), CompatibilityPlugin = __webpack_require__(97613), ConstPlugin = __webpack_require__(59973), ExportsInfoApiPlugin = __webpack_require__(5657), WebpackIsIncludedPlugin = __webpack_require__(64939), TemplatedPathPlugin = __webpack_require__(66607), UseStrictPlugin = __webpack_require__(90417), WarnCaseSensitiveModulesPlugin = __webpack_require__(16419), DataUriPlugin = __webpack_require__(41643), FileUriPlugin = __webpack_require__(62399), ResolverCachePlugin = __webpack_require__(65324), CommonJsPlugin = __webpack_require__(66563), HarmonyModulesPlugin = __webpack_require__(35908), ImportMetaContextPlugin = __webpack_require__(89402), ImportMetaPlugin = __webpack_require__(88748), ImportPlugin = __webpack_require__(32011), LoaderPlugin = __webpack_require__(61073), RequireContextPlugin = __webpack_require__(30842), RequireEnsurePlugin = __webpack_require__(9537), RequireIncludePlugin = __webpack_require__(52505), SystemPlugin = __webpack_require__(99334), URLPlugin = __webpack_require__(3286), WorkerPlugin = __webpack_require__(63376), InferAsyncModulesPlugin = __webpack_require__(91123), JavascriptMetaInfoPlugin = __webpack_require__(84584), DefaultStatsFactoryPlugin = __webpack_require__(41860), DefaultStatsPresetPlugin = __webpack_require__(11388), DefaultStatsPrinterPlugin = __webpack_require__(6004), {cleverMerge} = __webpack_require__(8639);
module.exports = class extends OptionsApply {
constructor() {
super();
}
process(options, compiler) {
if (compiler.outputPath = options.output.path, compiler.recordsInputPath = options.recordsInputPath || null, 
compiler.recordsOutputPath = options.recordsOutputPath || null, compiler.name = options.name, 
options.externals) {
new (__webpack_require__(29301))(options.externalsType, options.externals).apply(compiler);
}
if (options.externalsPresets.node) {
(new (__webpack_require__(81350))).apply(compiler);
}
if (options.externalsPresets.electronMain) {
new (__webpack_require__(84755))("main").apply(compiler);
}
if (options.externalsPresets.electronPreload) {
new (__webpack_require__(84755))("preload").apply(compiler);
}
if (options.externalsPresets.electronRenderer) {
new (__webpack_require__(84755))("renderer").apply(compiler);
}
if (options.externalsPresets.electron && !options.externalsPresets.electronMain && !options.externalsPresets.electronPreload && !options.externalsPresets.electronRenderer) {
(new (__webpack_require__(84755))).apply(compiler);
}
if (options.externalsPresets.nwjs) {
new (__webpack_require__(29301))("node-commonjs", "nw.gui").apply(compiler);
}
if (options.externalsPresets.webAsync) {
new (__webpack_require__(29301))("import", options.experiments.css ? ({request, dependencyType}, callback) => {
if ("url" === dependencyType) {
if (/^(\/\/|https?:\/\/)/.test(request)) return callback(null, `asset ${request}`);
} else if ("css-import" === dependencyType) {
if (/^(\/\/|https?:\/\/)/.test(request)) return callback(null, `css-import ${request}`);
} else if (/^(\/\/|https?:\/\/|std:)/.test(request)) return /^\.css(\?|$)/.test(request) ? callback(null, `css-import ${request}`) : callback(null, `import ${request}`);
callback();
} : /^(\/\/|https?:\/\/|std:)/).apply(compiler);
} else if (options.externalsPresets.web) {
new (__webpack_require__(29301))("module", options.experiments.css ? ({request, dependencyType}, callback) => {
if ("url" === dependencyType) {
if (/^(\/\/|https?:\/\/)/.test(request)) return callback(null, `asset ${request}`);
} else if ("css-import" === dependencyType) {
if (/^(\/\/|https?:\/\/)/.test(request)) return callback(null, `css-import ${request}`);
} else if (/^(\/\/|https?:\/\/|std:)/.test(request)) return /^\.css(\?|$)/.test(request) ? callback(null, `css-import ${request}`) : callback(null, `module ${request}`);
callback();
} : /^(\/\/|https?:\/\/|std:)/).apply(compiler);
}
if ((new ChunkPrefetchPreloadPlugin).apply(compiler), "string" == typeof options.output.chunkFormat) switch (options.output.chunkFormat) {
case "array-push":
(new (__webpack_require__(33978))).apply(compiler);
break;

case "commonjs":
(new (__webpack_require__(39074))).apply(compiler);
break;

case "module":
(new (__webpack_require__(20935))).apply(compiler);
break;

default:
throw new Error("Unsupported chunk format '" + options.output.chunkFormat + "'.");
}
if (options.output.enabledChunkLoadingTypes.length > 0) for (const type of options.output.enabledChunkLoadingTypes) {
new (__webpack_require__(64027))(type).apply(compiler);
}
if (options.output.enabledWasmLoadingTypes.length > 0) for (const type of options.output.enabledWasmLoadingTypes) {
new (__webpack_require__(44362))(type).apply(compiler);
}
if (options.output.enabledLibraryTypes.length > 0) for (const type of options.output.enabledLibraryTypes) {
new (__webpack_require__(30001))(type).apply(compiler);
}
if (options.output.pathinfo) {
new (__webpack_require__(69240))(!0 !== options.output.pathinfo).apply(compiler);
}
if (options.output.clean) {
new (__webpack_require__(32003))(!0 === options.output.clean ? {} : options.output.clean).apply(compiler);
}
if (options.devtool) if (options.devtool.includes("source-map")) {
const hidden = options.devtool.includes("hidden"), inline = options.devtool.includes("inline"), evalWrapped = options.devtool.includes("eval"), cheap = options.devtool.includes("cheap"), moduleMaps = options.devtool.includes("module"), noSources = options.devtool.includes("nosources");
new (__webpack_require__(evalWrapped ? 49695 : 26131))({
filename: inline ? null : options.output.sourceMapFilename,
moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
append: !hidden && void 0,
module: !!moduleMaps || !cheap,
columns: !cheap,
noSources,
namespace: options.output.devtoolNamespace
}).apply(compiler);
} else if (options.devtool.includes("eval")) {
new (__webpack_require__(47499))({
moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
namespace: options.output.devtoolNamespace
}).apply(compiler);
}
if ((new JavascriptModulesPlugin).apply(compiler), (new JsonModulesPlugin).apply(compiler), 
(new AssetModulesPlugin).apply(compiler), !options.experiments.outputModule) {
if (options.output.module) throw new Error("'output.module: true' is only allowed when 'experiments.outputModule' is enabled");
if (options.output.enabledLibraryTypes.includes("module")) throw new Error("library type \"module\" is only allowed when 'experiments.outputModule' is enabled");
if ("module" === options.externalsType) throw new Error("'externalsType: \"module\"' is only allowed when 'experiments.outputModule' is enabled");
}
if (options.experiments.syncWebAssembly) {
new (__webpack_require__(24698))({
mangleImports: options.optimization.mangleWasmImports
}).apply(compiler);
}
if (options.experiments.asyncWebAssembly) {
new (__webpack_require__(61986))({
mangleImports: options.optimization.mangleWasmImports
}).apply(compiler);
}
if (options.experiments.css) {
new (__webpack_require__(94536))(options.experiments.css).apply(compiler);
}
if (options.experiments.lazyCompilation) {
const LazyCompilationPlugin = __webpack_require__(52230), lazyOptions = "object" == typeof options.experiments.lazyCompilation ? options.experiments.lazyCompilation : null;
new LazyCompilationPlugin({
backend: "function" == typeof lazyOptions.backend ? lazyOptions.backend : __webpack_require__(4585)({
...lazyOptions.backend,
client: lazyOptions.backend && lazyOptions.backend.client || __webpack_require__(19117).resolve(`./lazy-compilation-${options.externalsPresets.node ? "node" : "web"}.js`)
}),
entries: !lazyOptions || !1 !== lazyOptions.entries,
imports: !lazyOptions || !1 !== lazyOptions.imports,
test: lazyOptions && lazyOptions.test || void 0
}).apply(compiler);
}
if (options.experiments.buildHttp) {
new (__webpack_require__(9420))(options.experiments.buildHttp).apply(compiler);
}
if ((new EntryOptionPlugin).apply(compiler), compiler.hooks.entryOption.call(options.context, options.entry), 
(new RuntimePlugin).apply(compiler), (new InferAsyncModulesPlugin).apply(compiler), 
(new DataUriPlugin).apply(compiler), (new FileUriPlugin).apply(compiler), (new CompatibilityPlugin).apply(compiler), 
new HarmonyModulesPlugin({
topLevelAwait: options.experiments.topLevelAwait
}).apply(compiler), !1 !== options.amd) {
const AMDPlugin = __webpack_require__(3687), RequireJsStuffPlugin = __webpack_require__(86834);
new AMDPlugin(options.amd || {}).apply(compiler), (new RequireJsStuffPlugin).apply(compiler);
}
if ((new CommonJsPlugin).apply(compiler), new LoaderPlugin({}).apply(compiler), 
!1 !== options.node) {
new (__webpack_require__(79441))(options.node).apply(compiler);
}
if ((new APIPlugin).apply(compiler), (new ExportsInfoApiPlugin).apply(compiler), 
(new WebpackIsIncludedPlugin).apply(compiler), (new ConstPlugin).apply(compiler), 
(new UseStrictPlugin).apply(compiler), (new RequireIncludePlugin).apply(compiler), 
(new RequireEnsurePlugin).apply(compiler), (new RequireContextPlugin).apply(compiler), 
(new ImportPlugin).apply(compiler), (new ImportMetaContextPlugin).apply(compiler), 
(new SystemPlugin).apply(compiler), (new ImportMetaPlugin).apply(compiler), (new URLPlugin).apply(compiler), 
new WorkerPlugin(options.output.workerChunkLoading, options.output.workerWasmLoading, options.output.module).apply(compiler), 
(new DefaultStatsFactoryPlugin).apply(compiler), (new DefaultStatsPresetPlugin).apply(compiler), 
(new DefaultStatsPrinterPlugin).apply(compiler), (new JavascriptMetaInfoPlugin).apply(compiler), 
"string" != typeof options.mode) {
(new (__webpack_require__(78209))).apply(compiler);
}
if ((new (__webpack_require__(60051))).apply(compiler), options.optimization.removeAvailableModules) {
(new (__webpack_require__(78888))).apply(compiler);
}
if (options.optimization.removeEmptyChunks) {
(new (__webpack_require__(64656))).apply(compiler);
}
if (options.optimization.mergeDuplicateChunks) {
(new (__webpack_require__(16152))).apply(compiler);
}
if (options.optimization.flagIncludedChunks) {
(new (__webpack_require__(88662))).apply(compiler);
}
if (options.optimization.sideEffects) {
new (__webpack_require__(72708))(!0 === options.optimization.sideEffects).apply(compiler);
}
if (options.optimization.providedExports) {
(new (__webpack_require__(61456))).apply(compiler);
}
if (options.optimization.usedExports) {
new (__webpack_require__(34080))("global" === options.optimization.usedExports).apply(compiler);
}
if (options.optimization.innerGraph) {
(new (__webpack_require__(97335))).apply(compiler);
}
if (options.optimization.mangleExports) {
new (__webpack_require__(75016))("size" !== options.optimization.mangleExports).apply(compiler);
}
if (options.optimization.concatenateModules) {
(new (__webpack_require__(13682))).apply(compiler);
}
if (options.optimization.splitChunks) {
new (__webpack_require__(222))(options.optimization.splitChunks).apply(compiler);
}
if (options.optimization.runtimeChunk) {
new (__webpack_require__(1058))(options.optimization.runtimeChunk).apply(compiler);
}
if (!options.optimization.emitOnErrors) {
(new (__webpack_require__(18810))).apply(compiler);
}
if (options.optimization.realContentHash) {
new (__webpack_require__(83582))({
hashFunction: options.output.hashFunction,
hashDigest: options.output.hashDigest
}).apply(compiler);
}
if (options.optimization.checkWasmTypes) {
(new (__webpack_require__(81833))).apply(compiler);
}
const moduleIds = options.optimization.moduleIds;
if (moduleIds) switch (moduleIds) {
case "natural":
(new (__webpack_require__(59940))).apply(compiler);
break;

case "named":
(new (__webpack_require__(13924))).apply(compiler);
break;

case "hashed":
{
const WarnDeprecatedOptionPlugin = __webpack_require__(96688), HashedModuleIdsPlugin = __webpack_require__(5429);
new WarnDeprecatedOptionPlugin("optimization.moduleIds", "hashed", "deterministic").apply(compiler), 
new HashedModuleIdsPlugin({
hashFunction: options.output.hashFunction
}).apply(compiler);
break;
}

case "deterministic":
(new (__webpack_require__(84967))).apply(compiler);
break;

case "size":
new (__webpack_require__(36669))({
prioritiseInitial: !0
}).apply(compiler);
break;

default:
throw new Error(`webpack bug: moduleIds: ${moduleIds} is not implemented`);
}
const chunkIds = options.optimization.chunkIds;
if (chunkIds) switch (chunkIds) {
case "natural":
(new (__webpack_require__(84118))).apply(compiler);
break;

case "named":
(new (__webpack_require__(55127))).apply(compiler);
break;

case "deterministic":
(new (__webpack_require__(34512))).apply(compiler);
break;

case "size":
new (__webpack_require__(4705))({
prioritiseInitial: !0
}).apply(compiler);
break;

case "total-size":
new (__webpack_require__(4705))({
prioritiseInitial: !1
}).apply(compiler);
break;

default:
throw new Error(`webpack bug: chunkIds: ${chunkIds} is not implemented`);
}
if (options.optimization.nodeEnv) {
new (__webpack_require__(98665))({
"process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
}).apply(compiler);
}
if (options.optimization.minimize) for (const minimizer of options.optimization.minimizer) "function" == typeof minimizer ? minimizer.call(compiler, compiler) : "..." !== minimizer && minimizer.apply(compiler);
if (options.performance) {
new (__webpack_require__(16725))(options.performance).apply(compiler);
}
(new TemplatedPathPlugin).apply(compiler), new RecordIdsPlugin({
portableIds: options.optimization.portableRecords
}).apply(compiler), (new WarnCaseSensitiveModulesPlugin).apply(compiler);
if (new (__webpack_require__(46820))(options.snapshot.managedPaths, options.snapshot.immutablePaths).apply(compiler), 
options.cache && "object" == typeof options.cache) {
const cacheOptions = options.cache;
switch (cacheOptions.type) {
case "memory":
if (isFinite(cacheOptions.maxGenerations)) {
new (__webpack_require__(52720))({
maxGenerations: cacheOptions.maxGenerations
}).apply(compiler);
} else {
(new (__webpack_require__(62472))).apply(compiler);
}
if (cacheOptions.cacheUnaffected) {
if (!options.experiments.cacheUnaffected) throw new Error("'cache.cacheUnaffected: true' is only allowed when 'experiments.cacheUnaffected' is enabled");
compiler.moduleMemCaches = new Map;
}
break;

case "filesystem":
{
const AddBuildDependenciesPlugin = __webpack_require__(66329);
for (const key in cacheOptions.buildDependencies) {
new AddBuildDependenciesPlugin(cacheOptions.buildDependencies[key]).apply(compiler);
}
if (isFinite(cacheOptions.maxMemoryGenerations)) {
if (0 !== cacheOptions.maxMemoryGenerations) {
new (__webpack_require__(52720))({
maxGenerations: cacheOptions.maxMemoryGenerations
}).apply(compiler);
}
} else {
(new (__webpack_require__(62472))).apply(compiler);
}
if (cacheOptions.memoryCacheUnaffected) {
if (!options.experiments.cacheUnaffected) throw new Error("'cache.memoryCacheUnaffected: true' is only allowed when 'experiments.cacheUnaffected' is enabled");
compiler.moduleMemCaches = new Map;
}
switch (cacheOptions.store) {
case "pack":
new (__webpack_require__(10034))(new (__webpack_require__(49634))({
compiler,
fs: compiler.intermediateFileSystem,
context: options.context,
cacheLocation: cacheOptions.cacheLocation,
version: cacheOptions.version,
logger: compiler.getInfrastructureLogger("webpack.cache.PackFileCacheStrategy"),
snapshot: options.snapshot,
maxAge: cacheOptions.maxAge,
profile: cacheOptions.profile,
allowCollectingMemory: cacheOptions.allowCollectingMemory,
compression: cacheOptions.compression
}), cacheOptions.idleTimeout, cacheOptions.idleTimeoutForInitialStore, cacheOptions.idleTimeoutAfterLargeChanges).apply(compiler);
break;

default:
throw new Error("Unhandled value for cache.store");
}
break;
}

default:
throw new Error(`Unknown cache type ${cacheOptions.type}`);
}
}
if ((new ResolverCachePlugin).apply(compiler), options.ignoreWarnings && options.ignoreWarnings.length > 0) {
new (__webpack_require__(52974))(options.ignoreWarnings).apply(compiler);
}
if (compiler.hooks.afterPlugins.call(compiler), !compiler.inputFileSystem) throw new Error("No input filesystem provided");
return compiler.resolverFactory.hooks.resolveOptions.for("normal").tap("WebpackOptionsApply", (resolveOptions => ((resolveOptions = cleverMerge(options.resolve, resolveOptions)).fileSystem = compiler.inputFileSystem, 
resolveOptions))), compiler.resolverFactory.hooks.resolveOptions.for("context").tap("WebpackOptionsApply", (resolveOptions => ((resolveOptions = cleverMerge(options.resolve, resolveOptions)).fileSystem = compiler.inputFileSystem, 
resolveOptions.resolveToContext = !0, resolveOptions))), compiler.resolverFactory.hooks.resolveOptions.for("loader").tap("WebpackOptionsApply", (resolveOptions => ((resolveOptions = cleverMerge(options.resolveLoader, resolveOptions)).fileSystem = compiler.inputFileSystem, 
resolveOptions))), compiler.hooks.afterResolvers.call(compiler), options;
}
};
},
93614: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {applyWebpackOptionsDefaults} = __webpack_require__(73054), {getNormalizedWebpackOptions} = __webpack_require__(70884);
module.exports = class {
process(options) {
return options = getNormalizedWebpackOptions(options), applyWebpackOptionsDefaults(options), 
options;
}
};
},
6201: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const mimeTypes = __webpack_require__(80983), path = __webpack_require__(71017), {RawSource} = __webpack_require__(37946), ConcatenationScope = __webpack_require__(87291), Generator = __webpack_require__(70607), RuntimeGlobals = __webpack_require__(50980), createHash = __webpack_require__(27466), {makePathsRelative} = __webpack_require__(63264), nonNumericOnlyHash = __webpack_require__(23388), mergeMaybeArrays = (a, b) => {
const set = new Set;
if (Array.isArray(a)) for (const item of a) set.add(item); else set.add(a);
if (Array.isArray(b)) for (const item of b) set.add(item); else set.add(b);
return Array.from(set);
}, mergeAssetInfo = (a, b) => {
const result = {
...a,
...b
};
for (const key of Object.keys(a)) if (key in b) {
if (a[key] === b[key]) continue;
switch (key) {
case "fullhash":
case "chunkhash":
case "modulehash":
case "contenthash":
result[key] = mergeMaybeArrays(a[key], b[key]);
break;

case "immutable":
case "development":
case "hotModuleReplacement":
case "javascriptModule":
result[key] = a[key] || b[key];
break;

case "related":
result[key] = mergeRelatedInfo(a[key], b[key]);
break;

default:
throw new Error(`Can't handle conflicting asset info for ${key}`);
}
}
return result;
}, mergeRelatedInfo = (a, b) => {
const result = {
...a,
...b
};
for (const key of Object.keys(a)) if (key in b) {
if (a[key] === b[key]) continue;
result[key] = mergeMaybeArrays(a[key], b[key]);
}
return result;
}, JS_TYPES = new Set([ "javascript" ]), JS_AND_ASSET_TYPES = new Set([ "javascript", "asset" ]);
module.exports = class extends Generator {
constructor(dataUrlOptions, filename, publicPath, outputPath, emit) {
super(), this.dataUrlOptions = dataUrlOptions, this.filename = filename, this.publicPath = publicPath, 
this.outputPath = outputPath, this.emit = emit;
}
getSourceFileName(module, runtimeTemplate) {
return makePathsRelative(runtimeTemplate.compilation.compiler.context, module.matchResource || module.resource, runtimeTemplate.compilation.compiler.root).replace(/^\.\//, "");
}
getConcatenationBailoutReason(module, context) {}
getMimeType(module) {
if ("function" == typeof this.dataUrlOptions) throw new Error("This method must not be called when dataUrlOptions is a function");
let mimeType = this.dataUrlOptions.mimetype;
if (void 0 === mimeType) {
const ext = path.extname(module.nameForCondition());
if (module.resourceResolveData && void 0 !== module.resourceResolveData.mimetype) mimeType = module.resourceResolveData.mimetype + module.resourceResolveData.parameters; else if (ext && (mimeType = mimeTypes.lookup(ext), 
"string" != typeof mimeType)) throw new Error(`DataUrl can't be generated automatically, because there is no mimetype for "${ext}" in mimetype database. Either pass a mimetype via "generator.mimetype" or use type: "asset/resource" to create a resource file instead of a DataUrl`);
}
if ("string" != typeof mimeType) throw new Error('DataUrl can\'t be generated automatically. Either pass a mimetype via "generator.mimetype" or use type: "asset/resource" to create a resource file instead of a DataUrl');
return mimeType;
}
generate(module, {runtime, concatenationScope, chunkGraph, runtimeTemplate, runtimeRequirements, type, getData}) {
if ("asset" === type) return module.originalSource();
{
let content;
const originalSource = module.originalSource();
if (module.buildInfo.dataUrl) {
let encodedSource;
if ("function" == typeof this.dataUrlOptions) encodedSource = this.dataUrlOptions.call(null, originalSource.source(), {
filename: module.matchResource || module.resource,
module
}); else {
let encoding = this.dataUrlOptions.encoding;
void 0 === encoding && module.resourceResolveData && void 0 !== module.resourceResolveData.encoding && (encoding = module.resourceResolveData.encoding), 
void 0 === encoding && (encoding = "base64");
const mimeType = this.getMimeType(module);
let encodedContent;
encodedContent = module.resourceResolveData && module.resourceResolveData.encoding === encoding && ((encoding, content) => "base64" === encoding ? Buffer.from(content, "base64") : Buffer.from(decodeURIComponent(content), "ascii"))(module.resourceResolveData.encoding, module.resourceResolveData.encodedContent).equals(originalSource.buffer()) ? module.resourceResolveData.encodedContent : ((encoding, source) => {
let encodedContent;
switch (encoding) {
case "base64":
encodedContent = source.buffer().toString("base64");
break;

case !1:
{
const content = source.source();
"string" != typeof content && (encodedContent = content.toString("utf-8")), encodedContent = encodeURIComponent(encodedContent).replace(/[!'()*]/g, (character => "%" + character.codePointAt(0).toString(16)));
break;
}

default:
throw new Error(`Unsupported encoding '${encoding}'`);
}
return encodedContent;
})(encoding, originalSource), encodedSource = `data:${mimeType}${encoding ? `;${encoding}` : ""},${encodedContent}`;
}
getData().set("url", Buffer.from(encodedSource)), content = JSON.stringify(encodedSource);
} else {
const assetModuleFilename = this.filename || runtimeTemplate.outputOptions.assetModuleFilename, hash = createHash(runtimeTemplate.outputOptions.hashFunction);
runtimeTemplate.outputOptions.hashSalt && hash.update(runtimeTemplate.outputOptions.hashSalt), 
hash.update(originalSource.buffer());
const fullHash = hash.digest(runtimeTemplate.outputOptions.hashDigest), contentHash = nonNumericOnlyHash(fullHash, runtimeTemplate.outputOptions.hashDigestLength);
module.buildInfo.fullContentHash = fullHash;
const sourceFilename = this.getSourceFileName(module, runtimeTemplate);
let assetPath, {path: filename, info: assetInfo} = runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, {
module,
runtime,
filename: sourceFilename,
chunkGraph,
contentHash
});
if (void 0 !== this.publicPath) {
const {path, info} = runtimeTemplate.compilation.getAssetPathWithInfo(this.publicPath, {
module,
runtime,
filename: sourceFilename,
chunkGraph,
contentHash
});
assetInfo = mergeAssetInfo(assetInfo, info), assetPath = JSON.stringify(path + filename);
} else runtimeRequirements.add(RuntimeGlobals.publicPath), assetPath = runtimeTemplate.concatenation({
expr: RuntimeGlobals.publicPath
}, filename);
if (assetInfo = {
sourceFilename,
...assetInfo
}, this.outputPath) {
const {path: outputPath, info} = runtimeTemplate.compilation.getAssetPathWithInfo(this.outputPath, {
module,
runtime,
filename: sourceFilename,
chunkGraph,
contentHash
});
assetInfo = mergeAssetInfo(assetInfo, info), filename = path.posix.join(outputPath, filename);
}
if (module.buildInfo.filename = filename, module.buildInfo.assetInfo = assetInfo, 
getData) {
const data = getData();
data.set("fullContentHash", fullHash), data.set("filename", filename), data.set("assetInfo", assetInfo);
}
content = assetPath;
}
return concatenationScope ? (concatenationScope.registerNamespaceExport(ConcatenationScope.NAMESPACE_OBJECT_EXPORT), 
new RawSource(`${runtimeTemplate.supportsConst() ? "const" : "var"} ${ConcatenationScope.NAMESPACE_OBJECT_EXPORT} = ${content};`)) : (runtimeRequirements.add(RuntimeGlobals.module), 
new RawSource(`${RuntimeGlobals.module}.exports = ${content};`));
}
}
getTypes(module) {
return module.buildInfo && module.buildInfo.dataUrl || !1 === this.emit ? JS_TYPES : JS_AND_ASSET_TYPES;
}
getSize(module, type) {
if ("asset" === type) {
const originalSource = module.originalSource();
return originalSource ? originalSource.size() : 0;
}
if (module.buildInfo && module.buildInfo.dataUrl) {
const originalSource = module.originalSource();
return originalSource ? 1.34 * originalSource.size() + 36 : 0;
}
return 42;
}
updateHash(hash, {module, runtime, runtimeTemplate, chunkGraph}) {
if (module.buildInfo.dataUrl) if (hash.update("data-url"), "function" == typeof this.dataUrlOptions) {
const ident = this.dataUrlOptions.ident;
ident && hash.update(ident);
} else this.dataUrlOptions.encoding && "base64" !== this.dataUrlOptions.encoding && hash.update(this.dataUrlOptions.encoding), 
this.dataUrlOptions.mimetype && hash.update(this.dataUrlOptions.mimetype); else {
hash.update("resource");
const pathData = {
module,
runtime,
filename: this.getSourceFileName(module, runtimeTemplate),
chunkGraph,
contentHash: runtimeTemplate.contentHashReplacement
};
if ("function" == typeof this.publicPath) {
hash.update("path");
const assetInfo = {};
hash.update(this.publicPath(pathData, assetInfo)), hash.update(JSON.stringify(assetInfo));
} else this.publicPath ? (hash.update("path"), hash.update(this.publicPath)) : hash.update("no-path");
const assetModuleFilename = this.filename || runtimeTemplate.outputOptions.assetModuleFilename, {path: filename, info} = runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, pathData);
hash.update(filename), hash.update(JSON.stringify(info));
}
}
};
},
62170: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {cleverMerge} = __webpack_require__(8639), {compareModulesByIdentifier} = __webpack_require__(40028), createSchemaValidation = __webpack_require__(59586), memoize = __webpack_require__(98216), getSchema = name => {
const {definitions} = __webpack_require__(46312);
return {
definitions,
oneOf: [ {
$ref: `#/definitions/${name}`
} ]
};
}, generatorValidationOptions = {
name: "Asset Modules Plugin",
baseDataPath: "generator"
}, validateGeneratorOptions = {
asset: createSchemaValidation(__webpack_require__(53e3), (() => getSchema("AssetGeneratorOptions")), generatorValidationOptions),
"asset/resource": createSchemaValidation(__webpack_require__(5970), (() => getSchema("AssetResourceGeneratorOptions")), generatorValidationOptions),
"asset/inline": createSchemaValidation(__webpack_require__(71251), (() => getSchema("AssetInlineGeneratorOptions")), generatorValidationOptions)
}, validateParserOptions = createSchemaValidation(__webpack_require__(63319), (() => getSchema("AssetParserOptions")), {
name: "Asset Modules Plugin",
baseDataPath: "parser"
}), getAssetGenerator = memoize((() => __webpack_require__(6201))), getAssetParser = memoize((() => __webpack_require__(57575))), getAssetSourceParser = memoize((() => __webpack_require__(33543))), getAssetSourceGenerator = memoize((() => __webpack_require__(84188))), plugin = "AssetModulesPlugin";
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap(plugin, ((compilation, {normalModuleFactory}) => {
normalModuleFactory.hooks.createParser.for("asset").tap(plugin, (parserOptions => {
validateParserOptions(parserOptions);
let dataUrlCondition = (parserOptions = cleverMerge(compiler.options.module.parser.asset, parserOptions)).dataUrlCondition;
dataUrlCondition && "object" != typeof dataUrlCondition || (dataUrlCondition = {
maxSize: 8096,
...dataUrlCondition
});
return new (getAssetParser())(dataUrlCondition);
})), normalModuleFactory.hooks.createParser.for("asset/inline").tap(plugin, (parserOptions => new (getAssetParser())(!0))), 
normalModuleFactory.hooks.createParser.for("asset/resource").tap(plugin, (parserOptions => new (getAssetParser())(!1))), 
normalModuleFactory.hooks.createParser.for("asset/source").tap(plugin, (parserOptions => new (getAssetSourceParser())));
for (const type of [ "asset", "asset/inline", "asset/resource" ]) normalModuleFactory.hooks.createGenerator.for(type).tap(plugin, (generatorOptions => {
let dataUrl, filename, publicPath, outputPath;
validateGeneratorOptions[type](generatorOptions), "asset/resource" !== type && (dataUrl = generatorOptions.dataUrl, 
dataUrl && "object" != typeof dataUrl || (dataUrl = {
encoding: void 0,
mimetype: void 0,
...dataUrl
})), "asset/inline" !== type && (filename = generatorOptions.filename, publicPath = generatorOptions.publicPath, 
outputPath = generatorOptions.outputPath);
return new (getAssetGenerator())(dataUrl, filename, publicPath, outputPath, !1 !== generatorOptions.emit);
}));
normalModuleFactory.hooks.createGenerator.for("asset/source").tap(plugin, (() => new (getAssetSourceGenerator()))), 
compilation.hooks.renderManifest.tap(plugin, ((result, options) => {
const {chunkGraph} = compilation, {chunk, codeGenerationResults} = options, modules = chunkGraph.getOrderedChunkModulesIterableBySourceType(chunk, "asset", compareModulesByIdentifier);
if (modules) for (const module of modules) try {
const codeGenResult = codeGenerationResults.get(module, chunk.runtime);
result.push({
render: () => codeGenResult.sources.get("asset"),
filename: module.buildInfo.filename || codeGenResult.data.get("filename"),
info: module.buildInfo.assetInfo || codeGenResult.data.get("assetInfo"),
auxiliary: !0,
identifier: `assetModule${chunkGraph.getModuleId(module)}`,
hash: module.buildInfo.fullContentHash || codeGenResult.data.get("fullContentHash")
});
} catch (e) {
throw e.message += `\nduring rendering of asset ${module.identifier()}`, e;
}
return result;
})), compilation.hooks.prepareModuleExecution.tap("AssetModulesPlugin", ((options, context) => {
const {codeGenerationResult} = options, source = codeGenerationResult.sources.get("asset");
void 0 !== source && context.assets.set(codeGenerationResult.data.get("filename"), {
source,
info: codeGenerationResult.data.get("assetInfo")
});
}));
}));
}
};
},
57575: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Parser = __webpack_require__(21475);
module.exports = class extends Parser {
constructor(dataUrlCondition) {
super(), this.dataUrlCondition = dataUrlCondition;
}
parse(source, state) {
if ("object" == typeof source && !Buffer.isBuffer(source)) throw new Error("AssetParser doesn't accept preparsed AST");
if (state.module.buildInfo.strict = !0, state.module.buildMeta.exportsType = "default", 
state.module.buildMeta.defaultObject = !1, "function" == typeof this.dataUrlCondition) state.module.buildInfo.dataUrl = this.dataUrlCondition(source, {
filename: state.module.matchResource || state.module.resource,
module: state.module
}); else if ("boolean" == typeof this.dataUrlCondition) state.module.buildInfo.dataUrl = this.dataUrlCondition; else {
if (!this.dataUrlCondition || "object" != typeof this.dataUrlCondition) throw new Error("Unexpected dataUrlCondition type");
state.module.buildInfo.dataUrl = Buffer.byteLength(source) <= this.dataUrlCondition.maxSize;
}
return state;
}
};
},
84188: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), ConcatenationScope = __webpack_require__(87291), Generator = __webpack_require__(70607), RuntimeGlobals = __webpack_require__(50980), TYPES = new Set([ "javascript" ]);
module.exports = class extends Generator {
generate(module, {concatenationScope, chunkGraph, runtimeTemplate, runtimeRequirements}) {
const originalSource = module.originalSource();
if (!originalSource) return new RawSource("");
const content = originalSource.source();
let encodedSource, sourceContent;
return encodedSource = "string" == typeof content ? content : content.toString("utf-8"), 
concatenationScope ? (concatenationScope.registerNamespaceExport(ConcatenationScope.NAMESPACE_OBJECT_EXPORT), 
sourceContent = `${runtimeTemplate.supportsConst() ? "const" : "var"} ${ConcatenationScope.NAMESPACE_OBJECT_EXPORT} = ${JSON.stringify(encodedSource)};`) : (runtimeRequirements.add(RuntimeGlobals.module), 
sourceContent = `${RuntimeGlobals.module}.exports = ${JSON.stringify(encodedSource)};`), 
new RawSource(sourceContent);
}
getConcatenationBailoutReason(module, context) {}
getTypes(module) {
return TYPES;
}
getSize(module, type) {
const originalSource = module.originalSource();
return originalSource ? originalSource.size() + 12 : 0;
}
};
},
33543: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Parser = __webpack_require__(21475);
module.exports = class extends Parser {
parse(source, state) {
if ("object" == typeof source && !Buffer.isBuffer(source)) throw new Error("AssetSourceParser doesn't accept preparsed AST");
const {module} = state;
return module.buildInfo.strict = !0, module.buildMeta.exportsType = "default", state.module.buildMeta.defaultObject = !1, 
state;
}
};
},
89779: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), TYPES = new Set([ "javascript" ]);
class RawDataUrlModule extends Module {
constructor(url, identifier, readableIdentifier) {
super("asset/raw-data-url", null), this.url = url, this.urlBuffer = url ? Buffer.from(url) : void 0, 
this.identifierStr = identifier || this.url, this.readableIdentifierStr = readableIdentifier || this.identifierStr;
}
getSourceTypes() {
return TYPES;
}
identifier() {
return this.identifierStr;
}
size(type) {
return void 0 === this.url && (this.url = this.urlBuffer.toString()), Math.max(1, this.url.length);
}
readableIdentifier(requestShortener) {
return requestShortener.shorten(this.readableIdentifierStr);
}
needBuild(context, callback) {
return callback(null, !this.buildMeta);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {}, this.buildInfo = {
cacheable: !0
}, callback();
}
codeGeneration(context) {
void 0 === this.url && (this.url = this.urlBuffer.toString());
const sources = new Map;
sources.set("javascript", new RawSource(`module.exports = ${JSON.stringify(this.url)};`));
const data = new Map;
data.set("url", this.urlBuffer);
const runtimeRequirements = new Set;
return runtimeRequirements.add(RuntimeGlobals.module), {
sources,
runtimeRequirements,
data
};
}
updateHash(hash, context) {
hash.update(this.urlBuffer), super.updateHash(hash, context);
}
serialize(context) {
const {write} = context;
write(this.urlBuffer), write(this.identifierStr), write(this.readableIdentifierStr), 
super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.urlBuffer = read(), this.identifierStr = read(), this.readableIdentifierStr = read(), 
super.deserialize(context);
}
}
makeSerializable(RawDataUrlModule, "webpack/lib/asset/RawDataUrlModule"), module.exports = RawDataUrlModule;
},
45788: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370);
class AwaitDependenciesInitFragment extends InitFragment {
constructor(promises) {
super(void 0, InitFragment.STAGE_ASYNC_DEPENDENCIES, 0, "await-dependencies"), this.promises = promises;
}
merge(other) {
const promises = new Set(other.promises);
for (const p of this.promises) promises.add(p);
return new AwaitDependenciesInitFragment(promises);
}
getContent({runtimeRequirements}) {
runtimeRequirements.add(RuntimeGlobals.module);
const promises = this.promises;
if (0 === promises.size) return "";
if (1 === promises.size) for (const p of promises) return Template.asString([ `var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([${p}]);`, `${p} = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];`, "" ]);
const sepPromises = Array.from(promises).join(", ");
return Template.asString([ `var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([${sepPromises}]);`, `([${sepPromises}] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);`, "" ]);
}
}
module.exports = AwaitDependenciesInitFragment;
},
91123: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const HarmonyImportDependency = __webpack_require__(75015);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("InferAsyncModulesPlugin", (compilation => {
const {moduleGraph} = compilation;
compilation.hooks.finishModules.tap("InferAsyncModulesPlugin", (modules => {
const queue = new Set;
for (const module of modules) module.buildMeta && module.buildMeta.async && queue.add(module);
for (const module of queue) {
moduleGraph.setAsync(module);
for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) connections.some((c => c.dependency instanceof HarmonyImportDependency && c.isTargetActive(void 0))) && queue.add(originModule);
}
}));
}));
}
};
},
70383: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const AsyncDependencyToInitialChunkError = __webpack_require__(94359), {connectChunkGroupParentAndChild} = __webpack_require__(19402), ModuleGraphConnection = __webpack_require__(63867), {getEntryRuntime, mergeRuntime} = __webpack_require__(14372), EMPTY_SET = new Set;
EMPTY_SET.plus = EMPTY_SET;
const bySetSize = (a, b) => b.size + b.plus.size - a.size - a.plus.size, extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {
let blockCache, modules;
const arrays = [], queue = [ module ];
for (;queue.length > 0; ) {
const block = queue.pop(), arr = [];
arrays.push(arr), blockModulesMap.set(block, arr);
for (const b of block.blocks) queue.push(b);
}
for (const connection of moduleGraph.getOutgoingConnections(module)) {
const d = connection.dependency;
if (!d) continue;
const m = connection.module;
if (!m) continue;
if (connection.weak) continue;
const state = connection.getActiveState(runtime);
if (!1 === state) continue;
const block = moduleGraph.getParentBlock(d);
let index = moduleGraph.getParentBlockIndex(d);
index < 0 && (index = block.dependencies.indexOf(d)), blockCache !== block && (modules = blockModulesMap.get(blockCache = block));
const i = index << 2;
modules[i] = m, modules[i + 1] = state;
}
for (const modules of arrays) {
if (0 === modules.length) continue;
let indexMap, length = 0;
outer: for (let j = 0; j < modules.length; j += 2) {
const m = modules[j];
if (void 0 === m) continue;
const state = modules[j + 1];
if (void 0 === indexMap) {
let i = 0;
for (;i < length; i += 2) if (modules[i] === m) {
const merged = modules[i + 1];
if (!0 === merged) continue outer;
modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);
}
if (modules[length] = m, length++, modules[length] = state, length++, length > 30) {
indexMap = new Map;
for (let i = 0; i < length; i += 2) indexMap.set(modules[i], i + 1);
}
} else {
const idx = indexMap.get(m);
if (void 0 !== idx) {
const merged = modules[idx];
if (!0 === merged) continue outer;
modules[idx] = ModuleGraphConnection.addConnectionStates(merged, state);
} else modules[length] = m, length++, modules[length] = state, indexMap.set(m, length), 
length++;
}
}
modules.length = length;
}
};
module.exports = (compilation, inputEntrypointsAndModules) => {
const logger = compilation.getLogger("webpack.buildChunkGraph"), blockConnections = new Map, allCreatedChunkGroups = new Set, chunkGroupInfoMap = new Map, blocksWithNestedBlocks = new Set;
logger.time("visitModules"), ((logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {
const {moduleGraph, chunkGraph, moduleMemCaches} = compilation, blockModulesRuntimeMap = new Map;
let blockModulesMap;
const getBlockModules = (block, runtime) => {
!1 !== runtime && (blockModulesMap = blockModulesRuntimeMap.get(runtime), void 0 === blockModulesMap && (blockModulesMap = new Map, 
blockModulesRuntimeMap.set(runtime, blockModulesMap)));
let blockModules = blockModulesMap.get(block);
if (void 0 !== blockModules) return blockModules;
const module = block.getRootBlock(), memCache = moduleMemCaches && moduleMemCaches.get(module);
if (void 0 !== memCache) {
const map = memCache.provide("bundleChunkGraph.blockModules", runtime, (() => {
logger.time("visitModules: prepare");
const map = new Map;
return extractBlockModules(module, moduleGraph, runtime, map), logger.timeAggregate("visitModules: prepare"), 
map;
}));
for (const [block, blockModules] of map) blockModulesMap.set(block, blockModules);
return map.get(block);
}
return logger.time("visitModules: prepare"), extractBlockModules(module, moduleGraph, runtime, blockModulesMap), 
blockModules = blockModulesMap.get(block), logger.timeAggregate("visitModules: prepare"), 
blockModules;
};
let statProcessedQueueItems = 0, statProcessedBlocks = 0, statConnectedChunkGroups = 0, statProcessedChunkGroupsForMerging = 0, statMergedAvailableModuleSets = 0, statForkedAvailableModules = 0, statForkedAvailableModulesCount = 0, statForkedAvailableModulesCountPlus = 0, statForkedMergedModulesCount = 0, statForkedMergedModulesCountPlus = 0, statForkedResultModulesCount = 0, statChunkGroupInfoUpdated = 0, statChildChunkGroupsReconnected = 0, nextChunkGroupIndex = 0, nextFreeModulePreOrderIndex = 0, nextFreeModulePostOrderIndex = 0;
const blockChunkGroups = new Map, namedChunkGroups = new Map, namedAsyncEntrypoints = new Map;
let queue = [];
const queueConnect = new Map, chunkGroupsForCombining = new Set;
for (const [chunkGroup, modules] of inputEntrypointsAndModules) {
const chunkGroupInfo = {
chunkGroup,
runtime: getEntryRuntime(compilation, chunkGroup.name, chunkGroup.options),
minAvailableModules: void 0,
minAvailableModulesOwned: !1,
availableModulesToBeMerged: [],
skippedItems: void 0,
resultingAvailableModules: void 0,
children: void 0,
availableSources: void 0,
availableChildren: void 0,
preOrderIndex: 0,
postOrderIndex: 0,
chunkLoading: void 0 !== chunkGroup.options.chunkLoading ? !1 !== chunkGroup.options.chunkLoading : !1 !== compilation.outputOptions.chunkLoading,
asyncChunks: void 0 !== chunkGroup.options.asyncChunks ? chunkGroup.options.asyncChunks : !1 !== compilation.outputOptions.asyncChunks
};
if (chunkGroup.index = nextChunkGroupIndex++, chunkGroup.getNumberOfParents() > 0) {
const skippedItems = new Set;
for (const module of modules) skippedItems.add(module);
chunkGroupInfo.skippedItems = skippedItems, chunkGroupsForCombining.add(chunkGroupInfo);
} else {
chunkGroupInfo.minAvailableModules = EMPTY_SET;
const chunk = chunkGroup.getEntrypointChunk();
for (const module of modules) queue.push({
action: 1,
block: module,
module,
chunk,
chunkGroup,
chunkGroupInfo
});
}
chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo), chunkGroup.name && namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);
}
for (const chunkGroupInfo of chunkGroupsForCombining) {
const {chunkGroup} = chunkGroupInfo;
chunkGroupInfo.availableSources = new Set;
for (const parent of chunkGroup.parentsIterable) {
const parentChunkGroupInfo = chunkGroupInfoMap.get(parent);
chunkGroupInfo.availableSources.add(parentChunkGroupInfo), void 0 === parentChunkGroupInfo.availableChildren && (parentChunkGroupInfo.availableChildren = new Set), 
parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);
}
}
queue.reverse();
const outdatedChunkGroupInfo = new Set, chunkGroupsForMerging = new Set;
let queueDelayed = [];
const skipConnectionBuffer = [], skipBuffer = [], queueBuffer = [];
let module, chunk, chunkGroup, block, chunkGroupInfo;
const iteratorBlock = b => {
let c, entrypoint, cgi = blockChunkGroups.get(b);
const entryOptions = b.groupOptions && b.groupOptions.entryOptions;
if (void 0 === cgi) {
const chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;
entryOptions ? (cgi = namedAsyncEntrypoints.get(chunkName), cgi ? (entrypoint = cgi.chunkGroup, 
entrypoint.addOrigin(module, b.loc, b.request), chunkGraph.connectBlockAndChunkGroup(b, entrypoint)) : (entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, b.loc, b.request), 
entrypoint.index = nextChunkGroupIndex++, cgi = {
chunkGroup: entrypoint,
runtime: entrypoint.options.runtime || entrypoint.name,
minAvailableModules: EMPTY_SET,
minAvailableModulesOwned: !1,
availableModulesToBeMerged: [],
skippedItems: void 0,
resultingAvailableModules: void 0,
children: void 0,
availableSources: void 0,
availableChildren: void 0,
preOrderIndex: 0,
postOrderIndex: 0,
chunkLoading: void 0 !== entryOptions.chunkLoading ? !1 !== entryOptions.chunkLoading : chunkGroupInfo.chunkLoading,
asyncChunks: void 0 !== entryOptions.asyncChunks ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks
}, chunkGroupInfoMap.set(entrypoint, cgi), chunkGraph.connectBlockAndChunkGroup(b, entrypoint), 
chunkName && namedAsyncEntrypoints.set(chunkName, cgi)), queueDelayed.push({
action: 4,
block: b,
module,
chunk: entrypoint.chunks[0],
chunkGroup: entrypoint,
chunkGroupInfo: cgi
})) : chunkGroupInfo.asyncChunks && chunkGroupInfo.chunkLoading ? (cgi = chunkName && namedChunkGroups.get(chunkName), 
cgi ? (c = cgi.chunkGroup, c.isInitial() && (compilation.errors.push(new AsyncDependencyToInitialChunkError(chunkName, module, b.loc)), 
c = chunkGroup), c.addOptions(b.groupOptions), c.addOrigin(module, b.loc, b.request)) : (c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request), 
c.index = nextChunkGroupIndex++, cgi = {
chunkGroup: c,
runtime: chunkGroupInfo.runtime,
minAvailableModules: void 0,
minAvailableModulesOwned: void 0,
availableModulesToBeMerged: [],
skippedItems: void 0,
resultingAvailableModules: void 0,
children: void 0,
availableSources: void 0,
availableChildren: void 0,
preOrderIndex: 0,
postOrderIndex: 0,
chunkLoading: chunkGroupInfo.chunkLoading,
asyncChunks: chunkGroupInfo.asyncChunks
}, allCreatedChunkGroups.add(c), chunkGroupInfoMap.set(c, cgi), chunkName && namedChunkGroups.set(chunkName, cgi)), 
blockConnections.set(b, [])) : queue.push({
action: 3,
block: b,
module,
chunk,
chunkGroup,
chunkGroupInfo
}), blockChunkGroups.set(b, cgi);
} else entryOptions ? entrypoint = cgi.chunkGroup : c = cgi.chunkGroup;
if (void 0 !== c) {
blockConnections.get(b).push({
originChunkGroupInfo: chunkGroupInfo,
chunkGroup: c
});
let connectList = queueConnect.get(chunkGroupInfo);
void 0 === connectList && (connectList = new Set, queueConnect.set(chunkGroupInfo, connectList)), 
connectList.add(cgi), queueDelayed.push({
action: 3,
block: b,
module,
chunk: c.chunks[0],
chunkGroup: c,
chunkGroupInfo: cgi
});
} else void 0 !== entrypoint && chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);
}, processBlock = block => {
statProcessedBlocks++;
const blockModules = getBlockModules(block, chunkGroupInfo.runtime);
if (void 0 !== blockModules) {
const {minAvailableModules} = chunkGroupInfo;
for (let i = 0; i < blockModules.length; i += 2) {
const refModule = blockModules[i];
if (chunkGraph.isModuleInChunk(refModule, chunk)) continue;
const activeState = blockModules[i + 1];
!0 !== activeState && (skipConnectionBuffer.push([ refModule, activeState ]), !1 === activeState) || (!0 !== activeState || !minAvailableModules.has(refModule) && !minAvailableModules.plus.has(refModule) ? queueBuffer.push({
action: !0 === activeState ? 1 : 3,
block: refModule,
module: refModule,
chunk,
chunkGroup,
chunkGroupInfo
}) : skipBuffer.push(refModule));
}
if (skipConnectionBuffer.length > 0) {
let {skippedModuleConnections} = chunkGroupInfo;
void 0 === skippedModuleConnections && (chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set);
for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) skippedModuleConnections.add(skipConnectionBuffer[i]);
skipConnectionBuffer.length = 0;
}
if (skipBuffer.length > 0) {
let {skippedItems} = chunkGroupInfo;
void 0 === skippedItems && (chunkGroupInfo.skippedItems = skippedItems = new Set);
for (let i = skipBuffer.length - 1; i >= 0; i--) skippedItems.add(skipBuffer[i]);
skipBuffer.length = 0;
}
if (queueBuffer.length > 0) {
for (let i = queueBuffer.length - 1; i >= 0; i--) queue.push(queueBuffer[i]);
queueBuffer.length = 0;
}
}
for (const b of block.blocks) iteratorBlock(b);
block.blocks.length > 0 && module !== block && blocksWithNestedBlocks.add(block);
}, processEntryBlock = block => {
statProcessedBlocks++;
const blockModules = getBlockModules(block, chunkGroupInfo.runtime);
if (void 0 !== blockModules) {
for (let i = 0; i < blockModules.length; i += 2) {
const refModule = blockModules[i], activeState = blockModules[i + 1];
queueBuffer.push({
action: !0 === activeState ? 0 : 3,
block: refModule,
module: refModule,
chunk,
chunkGroup,
chunkGroupInfo
});
}
if (queueBuffer.length > 0) {
for (let i = queueBuffer.length - 1; i >= 0; i--) queue.push(queueBuffer[i]);
queueBuffer.length = 0;
}
}
for (const b of block.blocks) iteratorBlock(b);
block.blocks.length > 0 && module !== block && blocksWithNestedBlocks.add(block);
}, processQueue = () => {
for (;queue.length; ) {
statProcessedQueueItems++;
const queueItem = queue.pop();
switch (module = queueItem.module, block = queueItem.block, chunk = queueItem.chunk, 
chunkGroup = queueItem.chunkGroup, chunkGroupInfo = queueItem.chunkGroupInfo, queueItem.action) {
case 0:
chunkGraph.connectChunkAndEntryModule(chunk, module, chunkGroup);

case 1:
if (chunkGraph.isModuleInChunk(module, chunk)) break;
chunkGraph.connectChunkAndModule(chunk, module);

case 2:
void 0 === chunkGroup.getModulePreOrderIndex(module) && chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++), 
moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex) && nextFreeModulePreOrderIndex++, 
queueItem.action = 5, queue.push(queueItem);

case 3:
processBlock(block);
break;

case 4:
processEntryBlock(block);
break;

case 5:
void 0 === chunkGroup.getModulePostOrderIndex(module) && chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++), 
moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex) && nextFreeModulePostOrderIndex++;
}
}
}, calculateResultingAvailableModules = chunkGroupInfo => {
if (chunkGroupInfo.resultingAvailableModules) return chunkGroupInfo.resultingAvailableModules;
const minAvailableModules = chunkGroupInfo.minAvailableModules;
let resultingAvailableModules;
if (minAvailableModules.size > minAvailableModules.plus.size) {
resultingAvailableModules = new Set;
for (const module of minAvailableModules.plus) minAvailableModules.add(module);
minAvailableModules.plus = EMPTY_SET, resultingAvailableModules.plus = minAvailableModules, 
chunkGroupInfo.minAvailableModulesOwned = !1;
} else resultingAvailableModules = new Set(minAvailableModules), resultingAvailableModules.plus = minAvailableModules.plus;
for (const chunk of chunkGroupInfo.chunkGroup.chunks) for (const m of chunkGraph.getChunkModulesIterable(chunk)) resultingAvailableModules.add(m);
return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;
}, processConnectQueue = () => {
for (const [chunkGroupInfo, targets] of queueConnect) {
if (void 0 === chunkGroupInfo.children) chunkGroupInfo.children = targets; else for (const target of targets) chunkGroupInfo.children.add(target);
const resultingAvailableModules = calculateResultingAvailableModules(chunkGroupInfo), runtime = chunkGroupInfo.runtime;
for (const target of targets) {
target.availableModulesToBeMerged.push(resultingAvailableModules), chunkGroupsForMerging.add(target);
const oldRuntime = target.runtime, newRuntime = mergeRuntime(oldRuntime, runtime);
oldRuntime !== newRuntime && (target.runtime = newRuntime, outdatedChunkGroupInfo.add(target));
}
statConnectedChunkGroups += targets.size;
}
queueConnect.clear();
}, processChunkGroupsForMerging = () => {
statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;
for (const info of chunkGroupsForMerging) {
const availableModulesToBeMerged = info.availableModulesToBeMerged;
let cachedMinAvailableModules = info.minAvailableModules;
statMergedAvailableModuleSets += availableModulesToBeMerged.length, availableModulesToBeMerged.length > 1 && availableModulesToBeMerged.sort(bySetSize);
let changed = !1;
merge: for (const availableModules of availableModulesToBeMerged) if (void 0 === cachedMinAvailableModules) cachedMinAvailableModules = availableModules, 
info.minAvailableModules = cachedMinAvailableModules, info.minAvailableModulesOwned = !1, 
changed = !0; else if (info.minAvailableModulesOwned) if (cachedMinAvailableModules.plus === availableModules.plus) for (const m of cachedMinAvailableModules) availableModules.has(m) || (cachedMinAvailableModules.delete(m), 
changed = !0); else {
for (const m of cachedMinAvailableModules) availableModules.has(m) || availableModules.plus.has(m) || (cachedMinAvailableModules.delete(m), 
changed = !0);
for (const m of cachedMinAvailableModules.plus) if (!availableModules.has(m) && !availableModules.plus.has(m)) {
const iterator = cachedMinAvailableModules.plus[Symbol.iterator]();
let it;
for (;!(it = iterator.next()).done; ) {
const module = it.value;
if (module === m) break;
cachedMinAvailableModules.add(module);
}
for (;!(it = iterator.next()).done; ) {
const module = it.value;
(availableModules.has(module) || availableModules.plus.has(module)) && cachedMinAvailableModules.add(module);
}
cachedMinAvailableModules.plus = EMPTY_SET, changed = !0;
continue merge;
}
} else if (cachedMinAvailableModules.plus === availableModules.plus) {
if (availableModules.size < cachedMinAvailableModules.size) {
statForkedAvailableModules++, statForkedAvailableModulesCount += availableModules.size, 
statForkedMergedModulesCount += cachedMinAvailableModules.size;
const newSet = new Set;
newSet.plus = availableModules.plus;
for (const m of availableModules) cachedMinAvailableModules.has(m) && newSet.add(m);
statForkedResultModulesCount += newSet.size, cachedMinAvailableModules = newSet, 
info.minAvailableModulesOwned = !0, info.minAvailableModules = newSet, changed = !0;
continue merge;
}
for (const m of cachedMinAvailableModules) if (!availableModules.has(m)) {
statForkedAvailableModules++, statForkedAvailableModulesCount += cachedMinAvailableModules.size, 
statForkedMergedModulesCount += availableModules.size;
const newSet = new Set;
newSet.plus = availableModules.plus;
const iterator = cachedMinAvailableModules[Symbol.iterator]();
let it;
for (;!(it = iterator.next()).done; ) {
const module = it.value;
if (module === m) break;
newSet.add(module);
}
for (;!(it = iterator.next()).done; ) {
const module = it.value;
availableModules.has(module) && newSet.add(module);
}
statForkedResultModulesCount += newSet.size, cachedMinAvailableModules = newSet, 
info.minAvailableModulesOwned = !0, info.minAvailableModules = newSet, changed = !0;
continue merge;
}
} else {
for (const m of cachedMinAvailableModules) if (!availableModules.has(m) && !availableModules.plus.has(m)) {
statForkedAvailableModules++, statForkedAvailableModulesCount += cachedMinAvailableModules.size, 
statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size, statForkedMergedModulesCount += availableModules.size, 
statForkedMergedModulesCountPlus += availableModules.plus.size;
const newSet = new Set;
newSet.plus = EMPTY_SET;
const iterator = cachedMinAvailableModules[Symbol.iterator]();
let it;
for (;!(it = iterator.next()).done; ) {
const module = it.value;
if (module === m) break;
newSet.add(module);
}
for (;!(it = iterator.next()).done; ) {
const module = it.value;
(availableModules.has(module) || availableModules.plus.has(module)) && newSet.add(module);
}
for (const module of cachedMinAvailableModules.plus) (availableModules.has(module) || availableModules.plus.has(module)) && newSet.add(module);
statForkedResultModulesCount += newSet.size, cachedMinAvailableModules = newSet, 
info.minAvailableModulesOwned = !0, info.minAvailableModules = newSet, changed = !0;
continue merge;
}
for (const m of cachedMinAvailableModules.plus) if (!availableModules.has(m) && !availableModules.plus.has(m)) {
statForkedAvailableModules++, statForkedAvailableModulesCount += cachedMinAvailableModules.size, 
statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size, statForkedMergedModulesCount += availableModules.size, 
statForkedMergedModulesCountPlus += availableModules.plus.size;
const newSet = new Set(cachedMinAvailableModules);
newSet.plus = EMPTY_SET;
const iterator = cachedMinAvailableModules.plus[Symbol.iterator]();
let it;
for (;!(it = iterator.next()).done; ) {
const module = it.value;
if (module === m) break;
newSet.add(module);
}
for (;!(it = iterator.next()).done; ) {
const module = it.value;
(availableModules.has(module) || availableModules.plus.has(module)) && newSet.add(module);
}
statForkedResultModulesCount += newSet.size, cachedMinAvailableModules = newSet, 
info.minAvailableModulesOwned = !0, info.minAvailableModules = newSet, changed = !0;
continue merge;
}
}
availableModulesToBeMerged.length = 0, changed && (info.resultingAvailableModules = void 0, 
outdatedChunkGroupInfo.add(info));
}
chunkGroupsForMerging.clear();
}, processChunkGroupsForCombining = () => {
for (const info of chunkGroupsForCombining) for (const source of info.availableSources) if (!source.minAvailableModules) {
chunkGroupsForCombining.delete(info);
break;
}
for (const info of chunkGroupsForCombining) {
const availableModules = new Set;
availableModules.plus = EMPTY_SET;
const mergeSet = set => {
if (set.size > availableModules.plus.size) {
for (const item of availableModules.plus) availableModules.add(item);
availableModules.plus = set;
} else for (const item of set) availableModules.add(item);
};
for (const source of info.availableSources) {
const resultingAvailableModules = calculateResultingAvailableModules(source);
mergeSet(resultingAvailableModules), mergeSet(resultingAvailableModules.plus);
}
info.minAvailableModules = availableModules, info.minAvailableModulesOwned = !1, 
info.resultingAvailableModules = void 0, outdatedChunkGroupInfo.add(info);
}
chunkGroupsForCombining.clear();
}, processOutdatedChunkGroupInfo = () => {
statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;
for (const info of outdatedChunkGroupInfo) {
if (void 0 !== info.skippedItems) {
const {minAvailableModules} = info;
for (const module of info.skippedItems) minAvailableModules.has(module) || minAvailableModules.plus.has(module) || (queue.push({
action: 1,
block: module,
module,
chunk: info.chunkGroup.chunks[0],
chunkGroup: info.chunkGroup,
chunkGroupInfo: info
}), info.skippedItems.delete(module));
}
if (void 0 !== info.skippedModuleConnections) {
const {minAvailableModules} = info;
for (const entry of info.skippedModuleConnections) {
const [module, activeState] = entry;
!1 !== activeState && (!0 === activeState && info.skippedModuleConnections.delete(entry), 
!0 !== activeState || !minAvailableModules.has(module) && !minAvailableModules.plus.has(module) ? queue.push({
action: !0 === activeState ? 1 : 3,
block: module,
module,
chunk: info.chunkGroup.chunks[0],
chunkGroup: info.chunkGroup,
chunkGroupInfo: info
}) : info.skippedItems.add(module));
}
}
if (void 0 !== info.children) {
statChildChunkGroupsReconnected += info.children.size;
for (const cgi of info.children) {
let connectList = queueConnect.get(info);
void 0 === connectList && (connectList = new Set, queueConnect.set(info, connectList)), 
connectList.add(cgi);
}
}
if (void 0 !== info.availableChildren) for (const cgi of info.availableChildren) chunkGroupsForCombining.add(cgi);
}
outdatedChunkGroupInfo.clear();
};
for (;queue.length || queueConnect.size; ) if (logger.time("visitModules: visiting"), 
processQueue(), logger.timeAggregateEnd("visitModules: prepare"), logger.timeEnd("visitModules: visiting"), 
chunkGroupsForCombining.size > 0 && (logger.time("visitModules: combine available modules"), 
processChunkGroupsForCombining(), logger.timeEnd("visitModules: combine available modules")), 
queueConnect.size > 0 && (logger.time("visitModules: calculating available modules"), 
processConnectQueue(), logger.timeEnd("visitModules: calculating available modules"), 
chunkGroupsForMerging.size > 0 && (logger.time("visitModules: merging available modules"), 
processChunkGroupsForMerging(), logger.timeEnd("visitModules: merging available modules"))), 
outdatedChunkGroupInfo.size > 0 && (logger.time("visitModules: check modules for revisit"), 
processOutdatedChunkGroupInfo(), logger.timeEnd("visitModules: check modules for revisit")), 
0 === queue.length) {
const tempQueue = queue;
queue = queueDelayed.reverse(), queueDelayed = tempQueue;
}
logger.log(`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`), 
logger.log(`${statConnectedChunkGroups} chunk groups connected`), logger.log(`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`), 
logger.log(`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`);
})(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups), 
logger.timeEnd("visitModules"), logger.time("connectChunkGroups"), ((compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {
const {chunkGraph} = compilation, areModulesAvailable = (chunkGroup, availableModules) => {
for (const chunk of chunkGroup.chunks) for (const module of chunkGraph.getChunkModulesIterable(chunk)) if (!availableModules.has(module) && !availableModules.plus.has(module)) return !1;
return !0;
};
for (const [block, connections] of blockConnections) if (blocksWithNestedBlocks.has(block) || !connections.every((({chunkGroup, originChunkGroupInfo}) => areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules)))) for (let i = 0; i < connections.length; i++) {
const {chunkGroup, originChunkGroupInfo} = connections[i];
chunkGraph.connectBlockAndChunkGroup(block, chunkGroup), connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);
}
})(compilation, blocksWithNestedBlocks, blockConnections), logger.timeEnd("connectChunkGroups");
for (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) for (const chunk of chunkGroup.chunks) chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);
logger.time("cleanup"), ((compilation, allCreatedChunkGroups) => {
const {chunkGraph} = compilation;
for (const chunkGroup of allCreatedChunkGroups) if (0 === chunkGroup.getNumberOfParents()) {
for (const chunk of chunkGroup.chunks) compilation.chunks.delete(chunk), chunkGraph.disconnectChunk(chunk);
chunkGraph.disconnectChunkGroup(chunkGroup), chunkGroup.remove();
}
})(compilation, allCreatedChunkGroups), logger.timeEnd("cleanup");
};
},
66329: module => {
"use strict";
module.exports = class {
constructor(buildDependencies) {
this.buildDependencies = new Set(buildDependencies);
}
apply(compiler) {
compiler.hooks.compilation.tap("AddBuildDependenciesPlugin", (compilation => {
compilation.buildDependencies.addAll(this.buildDependencies);
}));
}
};
},
46820: module => {
"use strict";
module.exports = class {
constructor(managedPaths, immutablePaths) {
this.managedPaths = new Set(managedPaths), this.immutablePaths = new Set(immutablePaths);
}
apply(compiler) {
for (const managedPath of this.managedPaths) compiler.managedPaths.add(managedPath);
for (const immutablePath of this.immutablePaths) compiler.immutablePaths.add(immutablePath);
}
};
},
10034: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Cache = __webpack_require__(54499), ProgressPlugin = __webpack_require__(17331), BUILD_DEPENDENCIES_KEY = Symbol();
module.exports = class {
constructor(strategy, idleTimeout, idleTimeoutForInitialStore, idleTimeoutAfterLargeChanges) {
this.strategy = strategy, this.idleTimeout = idleTimeout, this.idleTimeoutForInitialStore = idleTimeoutForInitialStore, 
this.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;
}
apply(compiler) {
let strategy = this.strategy;
const idleTimeout = this.idleTimeout, idleTimeoutForInitialStore = Math.min(idleTimeout, this.idleTimeoutForInitialStore), idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges, resolvedPromise = Promise.resolve();
let timeSpendInBuild = 0, timeSpendInStore = 0, avgTimeSpendInStore = 0;
const pendingIdleTasks = new Map;
compiler.cache.hooks.store.tap({
name: "IdleFileCachePlugin",
stage: Cache.STAGE_DISK
}, ((identifier, etag, data) => {
pendingIdleTasks.set(identifier, (() => strategy.store(identifier, etag, data)));
})), compiler.cache.hooks.get.tapPromise({
name: "IdleFileCachePlugin",
stage: Cache.STAGE_DISK
}, ((identifier, etag, gotHandlers) => {
const restore = () => strategy.restore(identifier, etag).then((cacheEntry => {
if (void 0 !== cacheEntry) return cacheEntry;
gotHandlers.push(((result, callback) => {
void 0 !== result && pendingIdleTasks.set(identifier, (() => strategy.store(identifier, etag, result))), 
callback();
}));
})), pendingTask = pendingIdleTasks.get(identifier);
return void 0 !== pendingTask ? (pendingIdleTasks.delete(identifier), pendingTask().then(restore)) : restore();
})), compiler.cache.hooks.storeBuildDependencies.tap({
name: "IdleFileCachePlugin",
stage: Cache.STAGE_DISK
}, (dependencies => {
pendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, (() => strategy.storeBuildDependencies(dependencies)));
})), compiler.cache.hooks.shutdown.tapPromise({
name: "IdleFileCachePlugin",
stage: Cache.STAGE_DISK
}, (() => {
idleTimer && (clearTimeout(idleTimer), idleTimer = void 0), isIdle = !1;
const reportProgress = ProgressPlugin.getReporter(compiler), jobs = Array.from(pendingIdleTasks.values());
reportProgress && reportProgress(0, "process pending cache items");
const promises = jobs.map((fn => fn()));
pendingIdleTasks.clear(), promises.push(currentIdlePromise);
const promise = Promise.all(promises);
return currentIdlePromise = promise.then((() => strategy.afterAllStored())), reportProgress && (currentIdlePromise = currentIdlePromise.then((() => {
reportProgress(1, "stored");
}))), currentIdlePromise.then((() => {
strategy.clear && strategy.clear();
}));
}));
let currentIdlePromise = resolvedPromise, isIdle = !1, isInitialStore = !0;
const processIdleTasks = () => {
if (isIdle) {
const startTime = Date.now();
if (pendingIdleTasks.size > 0) {
const promises = [ currentIdlePromise ], maxTime = startTime + 100;
let maxCount = 100;
for (const [filename, factory] of pendingIdleTasks) if (pendingIdleTasks.delete(filename), 
promises.push(factory()), maxCount-- <= 0 || Date.now() > maxTime) break;
return currentIdlePromise = Promise.all(promises), void currentIdlePromise.then((() => {
timeSpendInStore += Date.now() - startTime, idleTimer = setTimeout(processIdleTasks, 0), 
idleTimer.unref();
}));
}
currentIdlePromise = currentIdlePromise.then((async () => {
await strategy.afterAllStored(), timeSpendInStore += Date.now() - startTime, avgTimeSpendInStore = .9 * Math.max(avgTimeSpendInStore, timeSpendInStore) + .1 * timeSpendInStore, 
timeSpendInStore = 0, timeSpendInBuild = 0;
})).catch((err => {
const logger = compiler.getInfrastructureLogger("IdleFileCachePlugin");
logger.warn(`Background tasks during idle failed: ${err.message}`), logger.debug(err.stack);
})), isInitialStore = !1;
}
};
let idleTimer;
compiler.cache.hooks.beginIdle.tap({
name: "IdleFileCachePlugin",
stage: Cache.STAGE_DISK
}, (() => {
const isLargeChange = timeSpendInBuild > 2 * avgTimeSpendInStore;
isInitialStore && idleTimeoutForInitialStore < idleTimeout ? compiler.getInfrastructureLogger("IdleFileCachePlugin").log(`Initial cache was generated and cache will be persisted in ${idleTimeoutForInitialStore / 1e3}s.`) : isLargeChange && idleTimeoutAfterLargeChanges < idleTimeout && compiler.getInfrastructureLogger("IdleFileCachePlugin").log(`Spend ${Math.round(timeSpendInBuild) / 1e3}s in build and ${Math.round(avgTimeSpendInStore) / 1e3}s in average in cache store. This is considered as large change and cache will be persisted in ${idleTimeoutAfterLargeChanges / 1e3}s.`), 
idleTimer = setTimeout((() => {
idleTimer = void 0, isIdle = !0, resolvedPromise.then(processIdleTasks);
}), Math.min(isInitialStore ? idleTimeoutForInitialStore : 1 / 0, isLargeChange ? idleTimeoutAfterLargeChanges : 1 / 0, idleTimeout)), 
idleTimer.unref();
})), compiler.cache.hooks.endIdle.tap({
name: "IdleFileCachePlugin",
stage: Cache.STAGE_DISK
}, (() => {
idleTimer && (clearTimeout(idleTimer), idleTimer = void 0), isIdle = !1;
})), compiler.hooks.done.tap("IdleFileCachePlugin", (stats => {
timeSpendInBuild *= .9, timeSpendInBuild += stats.endTime - stats.startTime;
}));
}
};
},
62472: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Cache = __webpack_require__(54499);
module.exports = class {
apply(compiler) {
const cache = new Map;
compiler.cache.hooks.store.tap({
name: "MemoryCachePlugin",
stage: Cache.STAGE_MEMORY
}, ((identifier, etag, data) => {
cache.set(identifier, {
etag,
data
});
})), compiler.cache.hooks.get.tap({
name: "MemoryCachePlugin",
stage: Cache.STAGE_MEMORY
}, ((identifier, etag, gotHandlers) => {
const cacheEntry = cache.get(identifier);
return null === cacheEntry ? null : void 0 !== cacheEntry ? cacheEntry.etag === etag ? cacheEntry.data : null : void gotHandlers.push(((result, callback) => (void 0 === result ? cache.set(identifier, null) : cache.set(identifier, {
etag,
data: result
}), callback())));
})), compiler.cache.hooks.shutdown.tap({
name: "MemoryCachePlugin",
stage: Cache.STAGE_MEMORY
}, (() => {
cache.clear();
}));
}
};
},
52720: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Cache = __webpack_require__(54499);
module.exports = class {
constructor({maxGenerations}) {
this._maxGenerations = maxGenerations;
}
apply(compiler) {
const maxGenerations = this._maxGenerations, cache = new Map, oldCache = new Map;
let generation = 0, cachePosition = 0;
const logger = compiler.getInfrastructureLogger("MemoryWithGcCachePlugin");
compiler.hooks.afterDone.tap("MemoryWithGcCachePlugin", (() => {
generation++;
let lastClearedIdentifier, clearedEntries = 0;
for (const [identifier, entry] of oldCache) {
if (entry.until > generation) break;
oldCache.delete(identifier), void 0 === cache.get(identifier) && (cache.delete(identifier), 
clearedEntries++, lastClearedIdentifier = identifier);
}
(clearedEntries > 0 || oldCache.size > 0) && logger.log(`${cache.size - oldCache.size} active entries, ${oldCache.size} recently unused cached entries${clearedEntries > 0 ? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}` : ""}`);
let i = cache.size / maxGenerations | 0, j = cachePosition >= cache.size ? 0 : cachePosition;
cachePosition = j + i;
for (const [identifier, entry] of cache) if (0 === j) {
if (void 0 !== entry && (cache.set(identifier, void 0), oldCache.delete(identifier), 
oldCache.set(identifier, {
entry,
until: generation + maxGenerations
}), 0 == i--)) break;
} else j--;
})), compiler.cache.hooks.store.tap({
name: "MemoryWithGcCachePlugin",
stage: Cache.STAGE_MEMORY
}, ((identifier, etag, data) => {
cache.set(identifier, {
etag,
data
});
})), compiler.cache.hooks.get.tap({
name: "MemoryWithGcCachePlugin",
stage: Cache.STAGE_MEMORY
}, ((identifier, etag, gotHandlers) => {
const cacheEntry = cache.get(identifier);
if (null === cacheEntry) return null;
if (void 0 !== cacheEntry) return cacheEntry.etag === etag ? cacheEntry.data : null;
const oldCacheEntry = oldCache.get(identifier);
if (void 0 !== oldCacheEntry) {
const cacheEntry = oldCacheEntry.entry;
return null === cacheEntry ? (oldCache.delete(identifier), cache.set(identifier, cacheEntry), 
null) : cacheEntry.etag !== etag ? null : (oldCache.delete(identifier), cache.set(identifier, cacheEntry), 
cacheEntry.data);
}
gotHandlers.push(((result, callback) => (void 0 === result ? cache.set(identifier, null) : cache.set(identifier, {
etag,
data: result
}), callback())));
})), compiler.cache.hooks.shutdown.tap({
name: "MemoryWithGcCachePlugin",
stage: Cache.STAGE_MEMORY
}, (() => {
cache.clear(), oldCache.clear();
}));
}
};
},
49634: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const FileSystemInfo = __webpack_require__(91664), ProgressPlugin = __webpack_require__(17331), {formatSize} = __webpack_require__(9568), SerializerMiddleware = __webpack_require__(66852), LazySet = __webpack_require__(92585), makeSerializable = __webpack_require__(45898), memoize = __webpack_require__(98216), {createFileSerializer, NOT_SERIALIZABLE} = __webpack_require__(86601);
class PackContainer {
constructor(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {
this.data = data, this.version = version, this.buildSnapshot = buildSnapshot, this.buildDependencies = buildDependencies, 
this.resolveResults = resolveResults, this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;
}
serialize({write, writeLazy}) {
write(this.version), write(this.buildSnapshot), write(this.buildDependencies), write(this.resolveResults), 
write(this.resolveBuildDependenciesSnapshot), writeLazy(this.data);
}
deserialize({read}) {
this.version = read(), this.buildSnapshot = read(), this.buildDependencies = read(), 
this.resolveResults = read(), this.resolveBuildDependenciesSnapshot = read(), this.data = read();
}
}
makeSerializable(PackContainer, "webpack/lib/cache/PackFileCacheStrategy", "PackContainer");
class PackItemInfo {
constructor(identifier, etag, value) {
this.identifier = identifier, this.etag = etag, this.location = -1, this.lastAccess = Date.now(), 
this.freshValue = value;
}
}
class Pack {
constructor(logger, maxAge) {
this.itemInfo = new Map, this.requests = [], this.requestsTimeout = void 0, this.freshContent = new Map, 
this.content = [], this.invalid = !1, this.logger = logger, this.maxAge = maxAge;
}
_addRequest(identifier) {
this.requests.push(identifier), void 0 === this.requestsTimeout && (this.requestsTimeout = setTimeout((() => {
this.requests.push(void 0), this.requestsTimeout = void 0;
}), 6e4), this.requestsTimeout.unref && this.requestsTimeout.unref());
}
stopCapturingRequests() {
void 0 !== this.requestsTimeout && (clearTimeout(this.requestsTimeout), this.requestsTimeout = void 0);
}
get(identifier, etag) {
const info = this.itemInfo.get(identifier);
if (this._addRequest(identifier), void 0 === info) return;
if (info.etag !== etag) return null;
info.lastAccess = Date.now();
const loc = info.location;
return -1 === loc ? info.freshValue : this.content[loc] ? this.content[loc].get(identifier) : void 0;
}
set(identifier, etag, data) {
this.invalid || (this.invalid = !0, this.logger.log(`Pack got invalid because of write to: ${identifier}`));
const info = this.itemInfo.get(identifier);
if (void 0 === info) {
const newInfo = new PackItemInfo(identifier, etag, data);
this.itemInfo.set(identifier, newInfo), this._addRequest(identifier), this.freshContent.set(identifier, newInfo);
} else {
const loc = info.location;
if (loc >= 0) {
this._addRequest(identifier), this.freshContent.set(identifier, info);
const content = this.content[loc];
content.delete(identifier), 0 === content.items.size && (this.content[loc] = void 0, 
this.logger.debug("Pack %d got empty and is removed", loc));
}
info.freshValue = data, info.lastAccess = Date.now(), info.etag = etag, info.location = -1;
}
}
getContentStats() {
let count = 0, size = 0;
for (const content of this.content) if (void 0 !== content) {
count++;
const s = content.getSize();
s > 0 && (size += s);
}
return {
count,
size
};
}
_findLocation() {
let i;
for (i = 0; i < this.content.length && void 0 !== this.content[i]; i++) ;
return i;
}
_gcAndUpdateLocation(items, usedItems, newLoc) {
let lastGC, count = 0;
const now = Date.now();
for (const identifier of items) {
const info = this.itemInfo.get(identifier);
now - info.lastAccess > this.maxAge ? (this.itemInfo.delete(identifier), items.delete(identifier), 
usedItems.delete(identifier), count++, lastGC = identifier) : info.location = newLoc;
}
count > 0 && this.logger.log("Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s", count, newLoc, items.size, lastGC);
}
_persistFreshContent() {
const itemsCount = this.freshContent.size;
if (itemsCount > 0) {
const packCount = Math.ceil(itemsCount / 5e4), itemsPerPack = Math.ceil(itemsCount / packCount), packs = [];
let i = 0, ignoreNextTimeTick = !1;
const createNextPack = () => {
const loc = this._findLocation();
this.content[loc] = null;
const pack = {
items: new Set,
map: new Map,
loc
};
return packs.push(pack), pack;
};
let pack = createNextPack();
void 0 !== this.requestsTimeout && clearTimeout(this.requestsTimeout);
for (const identifier of this.requests) {
if (void 0 === identifier) {
ignoreNextTimeTick ? ignoreNextTimeTick = !1 : pack.items.size >= 100 && (i = 0, 
pack = createNextPack());
continue;
}
const info = this.freshContent.get(identifier);
void 0 !== info && (pack.items.add(identifier), pack.map.set(identifier, info.freshValue), 
info.location = pack.loc, info.freshValue = void 0, this.freshContent.delete(identifier), 
++i > itemsPerPack && (i = 0, pack = createNextPack(), ignoreNextTimeTick = !0));
}
this.requests.length = 0;
for (const pack of packs) this.content[pack.loc] = new PackContent(pack.items, new Set(pack.items), new PackContentItems(pack.map));
this.logger.log(`${itemsCount} fresh items in cache put into pack ${packs.length > 1 ? packs.map((pack => `${pack.loc} (${pack.items.size} items)`)).join(", ") : packs[0].loc}`);
}
}
_optimizeSmallContent() {
const smallUsedContents = [];
let smallUsedContentSize = 0;
const smallUnusedContents = [];
let mergedIndices, smallUnusedContentSize = 0;
for (let i = 0; i < this.content.length; i++) {
const content = this.content[i];
if (void 0 === content) continue;
if (content.outdated) continue;
const size = content.getSize();
size < 0 || size > 1048576 || (content.used.size > 0 ? (smallUsedContents.push(i), 
smallUsedContentSize += size) : (smallUnusedContents.push(i), smallUnusedContentSize += size));
}
if (smallUsedContents.length >= 10 || smallUsedContentSize > 1048576) mergedIndices = smallUsedContents; else {
if (!(smallUnusedContents.length >= 10 || smallUnusedContentSize > 1048576)) return;
mergedIndices = smallUnusedContents;
}
const mergedContent = [];
for (const i of mergedIndices) mergedContent.push(this.content[i]), this.content[i] = void 0;
const mergedItems = new Set, mergedUsedItems = new Set, addToMergedMap = [];
for (const content of mergedContent) {
for (const identifier of content.items) mergedItems.add(identifier);
for (const identifier of content.used) mergedUsedItems.add(identifier);
addToMergedMap.push((async map => {
await content.unpack("it should be merged with other small pack contents");
for (const [identifier, value] of content.content) map.set(identifier, value);
}));
}
const newLoc = this._findLocation();
this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc), mergedItems.size > 0 && (this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize((async () => {
const map = new Map;
return await Promise.all(addToMergedMap.map((fn => fn(map)))), new PackContentItems(map);
}))), this.logger.log("Merged %d small files with %d cache items into pack %d", mergedContent.length, mergedItems.size, newLoc));
}
_optimizeUnusedContent() {
for (let i = 0; i < this.content.length; i++) {
const content = this.content[i];
if (void 0 === content) continue;
if (content.getSize() < 1048576) continue;
const used = content.used.size, total = content.items.size;
if (used > 0 && used < total) {
this.content[i] = void 0;
const usedItems = new Set(content.used), newLoc = this._findLocation();
this._gcAndUpdateLocation(usedItems, usedItems, newLoc), usedItems.size > 0 && (this.content[newLoc] = new PackContent(usedItems, new Set(usedItems), (async () => {
await content.unpack("it should be splitted into used and unused items");
const map = new Map;
for (const identifier of usedItems) map.set(identifier, content.content.get(identifier));
return new PackContentItems(map);
})));
const unusedItems = new Set(content.items), usedOfUnusedItems = new Set;
for (const identifier of usedItems) unusedItems.delete(identifier);
const newUnusedLoc = this._findLocation();
return this._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc), 
unusedItems.size > 0 && (this.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, (async () => {
await content.unpack("it should be splitted into used and unused items");
const map = new Map;
for (const identifier of unusedItems) map.set(identifier, content.content.get(identifier));
return new PackContentItems(map);
}))), void this.logger.log("Split pack %d into pack %d with %d used items and pack %d with %d unused items", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size);
}
}
}
_gcOldestContent() {
let oldest;
for (const info of this.itemInfo.values()) (void 0 === oldest || info.lastAccess < oldest.lastAccess) && (oldest = info);
if (Date.now() - oldest.lastAccess > this.maxAge) {
const loc = oldest.location;
if (loc < 0) return;
const content = this.content[loc], items = new Set(content.items), usedItems = new Set(content.used);
this._gcAndUpdateLocation(items, usedItems, loc), this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, (async () => {
await content.unpack("it contains old items that should be garbage collected");
const map = new Map;
for (const identifier of items) map.set(identifier, content.content.get(identifier));
return new PackContentItems(map);
})) : void 0;
}
}
serialize({write, writeSeparate}) {
this._persistFreshContent(), this._optimizeSmallContent(), this._optimizeUnusedContent(), 
this._gcOldestContent();
for (const identifier of this.itemInfo.keys()) write(identifier);
write(null);
for (const info of this.itemInfo.values()) write(info.etag);
for (const info of this.itemInfo.values()) write(info.lastAccess);
for (let i = 0; i < this.content.length; i++) {
const content = this.content[i];
void 0 !== content ? (write(content.items), content.writeLazy((lazy => writeSeparate(lazy, {
name: `${i}`
})))) : write(void 0);
}
write(null);
}
deserialize({read, logger}) {
this.logger = logger;
{
const items = [];
let item = read();
for (;null !== item; ) items.push(item), item = read();
this.itemInfo.clear();
const infoItems = items.map((identifier => {
const info = new PackItemInfo(identifier, void 0, void 0);
return this.itemInfo.set(identifier, info), info;
}));
for (const info of infoItems) info.etag = read();
for (const info of infoItems) info.lastAccess = read();
}
this.content.length = 0;
let items = read();
for (;null !== items; ) {
if (void 0 === items) this.content.push(items); else {
const idx = this.content.length, lazy = read();
this.content.push(new PackContent(items, new Set, lazy, logger, `${this.content.length}`));
for (const identifier of items) this.itemInfo.get(identifier).location = idx;
}
items = read();
}
}
}
makeSerializable(Pack, "webpack/lib/cache/PackFileCacheStrategy", "Pack");
class PackContentItems {
constructor(map) {
this.map = map;
}
serialize({write, snapshot, rollback, logger, profile}) {
if (profile) {
write(!1);
for (const [key, value] of this.map) {
const s = snapshot();
try {
write(key);
const start = process.hrtime();
write(value);
const durationHr = process.hrtime(start), duration = 1e3 * durationHr[0] + durationHr[1] / 1e6;
duration > 1 && (duration > 500 ? logger.error(`Serialization of '${key}': ${duration} ms`) : duration > 50 ? logger.warn(`Serialization of '${key}': ${duration} ms`) : duration > 10 ? logger.info(`Serialization of '${key}': ${duration} ms`) : duration > 5 ? logger.log(`Serialization of '${key}': ${duration} ms`) : logger.debug(`Serialization of '${key}': ${duration} ms`));
} catch (e) {
if (rollback(s), e === NOT_SERIALIZABLE) continue;
const msg = "Skipped not serializable cache item";
e.message.includes("ModuleBuildError") ? (logger.log(`${msg} (in build error): ${e.message}`), 
logger.debug(`${msg} '${key}' (in build error): ${e.stack}`)) : (logger.warn(`${msg}: ${e.message}`), 
logger.debug(`${msg} '${key}': ${e.stack}`));
}
}
return void write(null);
}
const s = snapshot();
try {
write(!0), write(this.map);
} catch (e) {
rollback(s), write(!1);
for (const [key, value] of this.map) {
const s = snapshot();
try {
write(key), write(value);
} catch (e) {
if (rollback(s), e === NOT_SERIALIZABLE) continue;
logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`), logger.debug(e.stack);
}
}
write(null);
}
}
deserialize({read, logger, profile}) {
if (read()) this.map = read(); else if (profile) {
const map = new Map;
let key = read();
for (;null !== key; ) {
const start = process.hrtime(), value = read(), durationHr = process.hrtime(start), duration = 1e3 * durationHr[0] + durationHr[1] / 1e6;
duration > 1 && (duration > 100 ? logger.error(`Deserialization of '${key}': ${duration} ms`) : duration > 20 ? logger.warn(`Deserialization of '${key}': ${duration} ms`) : duration > 5 ? logger.info(`Deserialization of '${key}': ${duration} ms`) : duration > 2 ? logger.log(`Deserialization of '${key}': ${duration} ms`) : logger.debug(`Deserialization of '${key}': ${duration} ms`)), 
map.set(key, value), key = read();
}
this.map = map;
} else {
const map = new Map;
let key = read();
for (;null !== key; ) map.set(key, read()), key = read();
this.map = map;
}
}
}
makeSerializable(PackContentItems, "webpack/lib/cache/PackFileCacheStrategy", "PackContentItems");
class PackContent {
constructor(items, usedItems, dataOrFn, logger, lazyName) {
this.items = items, this.lazy = "function" == typeof dataOrFn ? dataOrFn : void 0, 
this.content = "function" == typeof dataOrFn ? void 0 : dataOrFn.map, this.outdated = !1, 
this.used = usedItems, this.logger = logger, this.lazyName = lazyName;
}
get(identifier) {
if (this.used.add(identifier), this.content) return this.content.get(identifier);
const {lazyName} = this;
let timeMessage;
lazyName && (this.lazyName = void 0, timeMessage = `restore cache content ${lazyName} (${formatSize(this.getSize())})`, 
this.logger.log(`starting to restore cache content ${lazyName} (${formatSize(this.getSize())}) because of request to: ${identifier}`), 
this.logger.time(timeMessage));
const value = this.lazy();
if ("then" in value) return value.then((data => {
const map = data.map;
return timeMessage && this.logger.timeEnd(timeMessage), this.content = map, this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy), 
map.get(identifier);
}));
{
const map = value.map;
return timeMessage && this.logger.timeEnd(timeMessage), this.content = map, this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy), 
map.get(identifier);
}
}
unpack(reason) {
if (!this.content && this.lazy) {
const {lazyName} = this;
let timeMessage;
lazyName && (this.lazyName = void 0, timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`, 
this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because ${reason}`), 
this.logger.time(timeMessage));
const value = this.lazy();
if ("then" in value) return value.then((data => {
timeMessage && this.logger.timeEnd(timeMessage), this.content = data.map;
}));
timeMessage && this.logger.timeEnd(timeMessage), this.content = value.map;
}
}
getSize() {
if (!this.lazy) return -1;
const options = this.lazy.options;
if (!options) return -1;
const size = options.size;
return "number" != typeof size ? -1 : size;
}
delete(identifier) {
this.items.delete(identifier), this.used.delete(identifier), this.outdated = !0;
}
writeLazy(write) {
if (!this.outdated && this.lazy) return void write(this.lazy);
if (!this.outdated && this.content) {
const map = new Map(this.content);
return void (this.lazy = SerializerMiddleware.unMemoizeLazy(write((() => new PackContentItems(map)))));
}
if (this.content) {
const map = new Map;
for (const item of this.items) map.set(item, this.content.get(item));
return this.outdated = !1, this.content = map, void (this.lazy = SerializerMiddleware.unMemoizeLazy(write((() => new PackContentItems(map)))));
}
const {lazyName} = this;
let timeMessage;
lazyName && (this.lazyName = void 0, timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`, 
this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because it's outdated and need to be serialized`), 
this.logger.time(timeMessage));
const value = this.lazy();
if (this.outdated = !1, "then" in value) this.lazy = write((() => value.then((data => {
timeMessage && this.logger.timeEnd(timeMessage);
const oldMap = data.map, map = new Map;
for (const item of this.items) map.set(item, oldMap.get(item));
return this.content = map, this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy), 
new PackContentItems(map);
})))); else {
timeMessage && this.logger.timeEnd(timeMessage);
const oldMap = value.map, map = new Map;
for (const item of this.items) map.set(item, oldMap.get(item));
this.content = map, this.lazy = write((() => new PackContentItems(map)));
}
}
}
const allowCollectingMemory = buf => {
const wasted = buf.buffer.byteLength - buf.byteLength;
return wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength) ? Buffer.from(buf) : buf;
};
module.exports = class {
constructor({compiler, fs, context, cacheLocation, version, logger, snapshot, maxAge, profile, allowCollectingMemory, compression}) {
this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction), 
this.fileSystemInfo = new FileSystemInfo(fs, {
managedPaths: snapshot.managedPaths,
immutablePaths: snapshot.immutablePaths,
logger: logger.getChildLogger("webpack.FileSystemInfo"),
hashFunction: compiler.options.output.hashFunction
}), this.compiler = compiler, this.context = context, this.cacheLocation = cacheLocation, 
this.version = version, this.logger = logger, this.maxAge = maxAge, this.profile = profile, 
this.allowCollectingMemory = allowCollectingMemory, this.compression = compression, 
this._extension = "brotli" === compression ? ".pack.br" : "gzip" === compression ? ".pack.gz" : ".pack", 
this.snapshot = snapshot, this.buildDependencies = new Set, this.newBuildDependencies = new LazySet, 
this.resolveBuildDependenciesSnapshot = void 0, this.resolveResults = void 0, this.buildSnapshot = void 0, 
this.packPromise = this._openPack(), this.storePromise = Promise.resolve();
}
_getPack() {
return void 0 === this.packPromise && (this.packPromise = this.storePromise.then((() => this._openPack()))), 
this.packPromise;
}
_openPack() {
const {logger, profile, cacheLocation, version} = this;
let buildSnapshot, buildDependencies, newBuildDependencies, resolveBuildDependenciesSnapshot, resolveResults;
return logger.time("restore cache container"), this.fileSerializer.deserialize(null, {
filename: `${cacheLocation}/index${this._extension}`,
extension: `${this._extension}`,
logger,
profile,
retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : void 0
}).catch((err => {
"ENOENT" !== err.code ? (logger.warn(`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`), 
logger.debug(err.stack)) : logger.debug(`No pack exists at ${cacheLocation}${this._extension}: ${err}`);
})).then((packContainer => {
if (logger.timeEnd("restore cache container"), packContainer) if (packContainer instanceof PackContainer) {
if (packContainer.version === version) return logger.time("check build dependencies"), 
Promise.all([ new Promise(((resolve, reject) => {
this.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, ((err, valid) => err ? (logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`), 
logger.debug(err.stack), resolve(!1)) : valid ? (buildSnapshot = packContainer.buildSnapshot, 
resolve(!0)) : (logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`), 
resolve(!1))));
})), new Promise(((resolve, reject) => {
this.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, ((err, valid) => err ? (logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`), 
logger.debug(err.stack), resolve(!1)) : valid ? (resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot, 
buildDependencies = packContainer.buildDependencies, resolveResults = packContainer.resolveResults, 
resolve(!0)) : (logger.log("resolving of build dependencies is invalid, will re-resolve build dependencies"), 
void this.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, ((err, valid) => err ? (logger.log(`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`), 
logger.debug(err.stack), resolve(!1)) : valid ? (newBuildDependencies = packContainer.buildDependencies, 
resolveResults = packContainer.resolveResults, resolve(!0)) : (logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`), 
resolve(!1)))))));
})) ]).catch((err => {
throw logger.timeEnd("check build dependencies"), err;
})).then((([buildSnapshotValid, resolveValid]) => {
if (logger.timeEnd("check build dependencies"), buildSnapshotValid && resolveValid) {
logger.time("restore cache content metadata");
const d = packContainer.data();
return logger.timeEnd("restore cache content metadata"), d;
}
}));
logger.log(`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`);
} else logger.warn(`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`, packContainer);
})).then((pack => pack ? (pack.maxAge = this.maxAge, this.buildSnapshot = buildSnapshot, 
buildDependencies && (this.buildDependencies = buildDependencies), newBuildDependencies && this.newBuildDependencies.addAll(newBuildDependencies), 
this.resolveResults = resolveResults, this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot, 
pack) : new Pack(logger, this.maxAge))).catch((err => (this.logger.warn(`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`), 
this.logger.debug(err.stack), new Pack(logger, this.maxAge))));
}
store(identifier, etag, data) {
return this._getPack().then((pack => {
pack.set(identifier, null === etag ? null : etag.toString(), data);
}));
}
restore(identifier, etag) {
return this._getPack().then((pack => pack.get(identifier, null === etag ? null : etag.toString()))).catch((err => {
err && "ENOENT" !== err.code && (this.logger.warn(`Restoring failed for ${identifier} from pack: ${err}`), 
this.logger.debug(err.stack));
}));
}
storeBuildDependencies(dependencies) {
this.newBuildDependencies.addAll(dependencies);
}
afterAllStored() {
const packPromise = this.packPromise;
if (void 0 === packPromise) return Promise.resolve();
const reportProgress = ProgressPlugin.getReporter(this.compiler);
return this.storePromise = packPromise.then((pack => {
if (pack.stopCapturingRequests(), !pack.invalid) return;
let promise;
this.packPromise = void 0, this.logger.log("Storing pack...");
const newBuildDependencies = new Set;
for (const dep of this.newBuildDependencies) this.buildDependencies.has(dep) || newBuildDependencies.add(dep);
return newBuildDependencies.size > 0 || !this.buildSnapshot ? (reportProgress && reportProgress(.5, "resolve build dependencies"), 
this.logger.debug(`Capturing build dependencies... (${Array.from(newBuildDependencies).join(", ")})`), 
promise = new Promise(((resolve, reject) => {
this.logger.time("resolve build dependencies"), this.fileSystemInfo.resolveBuildDependencies(this.context, newBuildDependencies, ((err, result) => {
if (this.logger.timeEnd("resolve build dependencies"), err) return reject(err);
this.logger.time("snapshot build dependencies");
const {files, directories, missing, resolveResults, resolveDependencies} = result;
if (this.resolveResults) for (const [key, value] of resolveResults) this.resolveResults.set(key, value); else this.resolveResults = resolveResults;
reportProgress && reportProgress(.6, "snapshot build dependencies", "resolving"), 
this.fileSystemInfo.createSnapshot(void 0, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, this.snapshot.resolveBuildDependencies, ((err, snapshot) => err ? (this.logger.timeEnd("snapshot build dependencies"), 
reject(err)) : snapshot ? (this.resolveBuildDependenciesSnapshot ? this.resolveBuildDependenciesSnapshot = this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot, snapshot) : this.resolveBuildDependenciesSnapshot = snapshot, 
reportProgress && reportProgress(.7, "snapshot build dependencies", "modules"), 
void this.fileSystemInfo.createSnapshot(void 0, files, directories, missing, this.snapshot.buildDependencies, ((err, snapshot) => (this.logger.timeEnd("snapshot build dependencies"), 
err ? reject(err) : snapshot ? (this.logger.debug("Captured build dependencies"), 
this.buildSnapshot ? this.buildSnapshot = this.fileSystemInfo.mergeSnapshots(this.buildSnapshot, snapshot) : this.buildSnapshot = snapshot, 
void resolve()) : reject(new Error("Unable to snapshot build dependencies")))))) : (this.logger.timeEnd("snapshot build dependencies"), 
reject(new Error("Unable to snapshot resolve dependencies")))));
}));
}))) : promise = Promise.resolve(), promise.then((() => {
reportProgress && reportProgress(.8, "serialize pack"), this.logger.time("store pack");
const updatedBuildDependencies = new Set(this.buildDependencies);
for (const dep of newBuildDependencies) updatedBuildDependencies.add(dep);
const content = new PackContainer(pack, this.version, this.buildSnapshot, updatedBuildDependencies, this.resolveResults, this.resolveBuildDependenciesSnapshot);
return this.fileSerializer.serialize(content, {
filename: `${this.cacheLocation}/index${this._extension}`,
extension: `${this._extension}`,
logger: this.logger,
profile: this.profile
}).then((() => {
for (const dep of newBuildDependencies) this.buildDependencies.add(dep);
this.newBuildDependencies.clear(), this.logger.timeEnd("store pack");
const stats = pack.getContentStats();
this.logger.log("Stored pack (%d items, %d files, %d MiB)", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));
})).catch((err => {
this.logger.timeEnd("store pack"), this.logger.warn(`Caching failed for pack: ${err}`), 
this.logger.debug(err.stack);
}));
}));
})).catch((err => {
this.logger.warn(`Caching failed for pack: ${err}`), this.logger.debug(err.stack);
}));
}
clear() {
this.fileSystemInfo.clear(), this.buildDependencies.clear(), this.newBuildDependencies.clear(), 
this.resolveBuildDependenciesSnapshot = void 0, this.resolveResults = void 0, this.buildSnapshot = void 0, 
this.packPromise = void 0;
}
};
},
65324: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const LazySet = __webpack_require__(92585), makeSerializable = __webpack_require__(45898);
class CacheEntry {
constructor(result, snapshot) {
this.result = result, this.snapshot = snapshot;
}
serialize({write}) {
write(this.result), write(this.snapshot);
}
deserialize({read}) {
this.result = read(), this.snapshot = read();
}
}
makeSerializable(CacheEntry, "webpack/lib/cache/ResolverCachePlugin");
const addAllToSet = (set, otherSet) => {
if (set instanceof LazySet) set.addAll(otherSet); else for (const item of otherSet) set.add(item);
}, objectToString = (object, excludeContext) => {
let str = "";
for (const key in object) {
if (excludeContext && "context" === key) continue;
const value = object[key];
str += "object" == typeof value && null !== value ? `|${key}=[${objectToString(value, !1)}|]` : `|${key}=|${value}`;
}
return str;
};
module.exports = class {
apply(compiler) {
const cache = compiler.getCache("ResolverCachePlugin");
let fileSystemInfo, snapshotOptions, realResolves = 0, cachedResolves = 0, cacheInvalidResolves = 0, concurrentResolves = 0;
compiler.hooks.thisCompilation.tap("ResolverCachePlugin", (compilation => {
snapshotOptions = compilation.options.snapshot.resolve, fileSystemInfo = compilation.fileSystemInfo, 
compilation.hooks.finishModules.tap("ResolverCachePlugin", (() => {
if (realResolves + cachedResolves > 0) {
compilation.getLogger("webpack.ResolverCachePlugin").log(`${Math.round(100 * realResolves / (realResolves + cachedResolves))}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`), 
realResolves = 0, cachedResolves = 0, cacheInvalidResolves = 0, concurrentResolves = 0;
}
}));
}));
const doRealResolve = (itemCache, resolver, resolveContext, request, callback) => {
realResolves++;
const newRequest = {
_ResolverCachePluginCacheMiss: !0,
...request
}, newResolveContext = {
...resolveContext,
stack: new Set,
missingDependencies: new LazySet,
fileDependencies: new LazySet,
contextDependencies: new LazySet
};
let yieldResult, withYield = !1;
"function" == typeof newResolveContext.yield && (yieldResult = [], withYield = !0, 
newResolveContext.yield = obj => yieldResult.push(obj));
const propagate = key => {
resolveContext[key] && addAllToSet(resolveContext[key], newResolveContext[key]);
}, resolveTime = Date.now();
resolver.doResolve(resolver.hooks.resolve, newRequest, "Cache miss", newResolveContext, ((err, result) => {
if (propagate("fileDependencies"), propagate("contextDependencies"), propagate("missingDependencies"), 
err) return callback(err);
const fileDependencies = newResolveContext.fileDependencies, contextDependencies = newResolveContext.contextDependencies, missingDependencies = newResolveContext.missingDependencies;
fileSystemInfo.createSnapshot(resolveTime, fileDependencies, contextDependencies, missingDependencies, snapshotOptions, ((err, snapshot) => {
if (err) return callback(err);
const resolveResult = withYield ? yieldResult : result;
if (withYield && result && yieldResult.push(result), !snapshot) return resolveResult ? callback(null, resolveResult) : callback();
itemCache.store(new CacheEntry(resolveResult, snapshot), (storeErr => storeErr ? callback(storeErr) : resolveResult ? callback(null, resolveResult) : void callback()));
}));
}));
};
compiler.resolverFactory.hooks.resolver.intercept({
factory(type, hook) {
const activeRequests = new Map, activeRequestsWithYield = new Map;
return hook.tap("ResolverCachePlugin", ((resolver, options, userOptions) => {
if (!0 !== options.cache) return;
const optionsIdent = objectToString(userOptions, !1), cacheWithContext = void 0 !== options.cacheWithContext && options.cacheWithContext;
resolver.hooks.resolve.tapAsync({
name: "ResolverCachePlugin",
stage: -100
}, ((request, resolveContext, callback) => {
if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) return callback();
const withYield = "function" == typeof resolveContext.yield, identifier = `${type}${withYield ? "|yield" : "|default"}${optionsIdent}${objectToString(request, !cacheWithContext)}`;
if (withYield) {
const activeRequest = activeRequestsWithYield.get(identifier);
if (activeRequest) return activeRequest[0].push(callback), void activeRequest[1].push(resolveContext.yield);
} else {
const activeRequest = activeRequests.get(identifier);
if (activeRequest) return void activeRequest.push(callback);
}
const itemCache = cache.getItemCache(identifier, null);
let callbacks, yields;
const done = withYield ? (err, result) => {
if (void 0 === callbacks) {
if (err) callback(err); else {
if (result) for (const r of result) resolveContext.yield(r);
callback(null, null);
}
yields = void 0, callbacks = !1;
} else {
if (err) for (const cb of callbacks) cb(err); else for (let i = 0; i < callbacks.length; i++) {
const cb = callbacks[i], yield_ = yields[i];
if (result) for (const r of result) yield_(r);
cb(null, null);
}
activeRequestsWithYield.delete(identifier), yields = void 0, callbacks = !1;
}
} : (err, result) => {
if (void 0 === callbacks) callback(err, result), callbacks = !1; else {
for (const callback of callbacks) callback(err, result);
activeRequests.delete(identifier), callbacks = !1;
}
};
itemCache.get(((err, cacheEntry) => {
if (err) return done(err);
if (cacheEntry) {
const {snapshot, result} = cacheEntry;
fileSystemInfo.checkSnapshotValid(snapshot, ((err, valid) => {
if (err || !valid) return cacheInvalidResolves++, doRealResolve(itemCache, resolver, resolveContext, request, done);
cachedResolves++, resolveContext.missingDependencies && addAllToSet(resolveContext.missingDependencies, snapshot.getMissingIterable()), 
resolveContext.fileDependencies && addAllToSet(resolveContext.fileDependencies, snapshot.getFileIterable()), 
resolveContext.contextDependencies && addAllToSet(resolveContext.contextDependencies, snapshot.getContextIterable()), 
done(null, result);
}));
} else doRealResolve(itemCache, resolver, resolveContext, request, done);
})), withYield && void 0 === callbacks ? (callbacks = [ callback ], yields = [ resolveContext.yield ], 
activeRequestsWithYield.set(identifier, [ callbacks, yields ])) : void 0 === callbacks && (callbacks = [ callback ], 
activeRequests.set(identifier, callbacks));
}));
})), hook;
}
});
}
};
},
19436: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const createHash = __webpack_require__(27466);
class LazyHashedEtag {
constructor(obj, hashFunction = "md4") {
this._obj = obj, this._hash = void 0, this._hashFunction = hashFunction;
}
toString() {
if (void 0 === this._hash) {
const hash = createHash(this._hashFunction);
this._obj.updateHash(hash), this._hash = hash.digest("base64");
}
return this._hash;
}
}
const mapStrings = new Map, mapObjects = new WeakMap;
module.exports = (obj, hashFunction = "md4") => {
let innerMap;
if ("string" == typeof hashFunction) {
if (innerMap = mapStrings.get(hashFunction), void 0 === innerMap) {
const newHash = new LazyHashedEtag(obj, hashFunction);
return innerMap = new WeakMap, innerMap.set(obj, newHash), mapStrings.set(hashFunction, innerMap), 
newHash;
}
} else if (innerMap = mapObjects.get(hashFunction), void 0 === innerMap) {
const newHash = new LazyHashedEtag(obj, hashFunction);
return innerMap = new WeakMap, innerMap.set(obj, newHash), mapObjects.set(hashFunction, innerMap), 
newHash;
}
const hash = innerMap.get(obj);
if (void 0 !== hash) return hash;
const newHash = new LazyHashedEtag(obj, hashFunction);
return innerMap.set(obj, newHash), newHash;
};
},
85197: module => {
"use strict";
class MergedEtag {
constructor(a, b) {
this.a = a, this.b = b;
}
toString() {
return `${this.a.toString()}|${this.b.toString()}`;
}
}
const dualObjectMap = new WeakMap, objectStringMap = new WeakMap;
module.exports = (a, b) => {
if ("string" == typeof a) {
if ("string" == typeof b) return `${a}|${b}`;
{
const temp = b;
b = a, a = temp;
}
} else if ("string" != typeof b) {
let map = dualObjectMap.get(a);
void 0 === map && dualObjectMap.set(a, map = new WeakMap);
const mergedEtag = map.get(b);
if (void 0 === mergedEtag) {
const newMergedEtag = new MergedEtag(a, b);
return map.set(b, newMergedEtag), newMergedEtag;
}
return mergedEtag;
}
let map = objectStringMap.get(a);
void 0 === map && objectStringMap.set(a, map = new Map);
const mergedEtag = map.get(b);
if (void 0 === mergedEtag) {
const newMergedEtag = new MergedEtag(a, b);
return map.set(b, newMergedEtag), newMergedEtag;
}
return mergedEtag;
};
},
59705: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), webpackSchema = __webpack_require__(46312), cliAddedItems = new WeakMap, setValue = (config, schemaPath, value, index) => {
const {problem, object, property} = ((config, schemaPath, index = 0) => {
if (!schemaPath) return {
value: config
};
const parts = schemaPath.split(".");
let property = parts.pop(), current = config, i = 0;
for (const part of parts) {
const isArray = part.endsWith("[]"), name = isArray ? part.slice(0, -2) : part;
let value = current[name];
if (isArray) if (void 0 === value) value = {}, current[name] = [ ...Array.from({
length: index
}), value ], cliAddedItems.set(current[name], index + 1); else {
if (!Array.isArray(value)) return {
problem: {
type: "unexpected-non-array-in-path",
path: parts.slice(0, i).join(".")
}
};
{
let addedItems = cliAddedItems.get(value) || 0;
for (;addedItems <= index; ) value.push(void 0), addedItems++;
cliAddedItems.set(value, addedItems);
const x = value.length - addedItems + index;
if (void 0 === value[x]) value[x] = {}; else if (null === value[x] || "object" != typeof value[x]) return {
problem: {
type: "unexpected-non-object-in-path",
path: parts.slice(0, i).join(".")
}
};
value = value[x];
}
} else if (void 0 === value) value = current[name] = {}; else if (null === value || "object" != typeof value) return {
problem: {
type: "unexpected-non-object-in-path",
path: parts.slice(0, i).join(".")
}
};
current = value, i++;
}
let value = current[property];
if (property.endsWith("[]")) {
const name = property.slice(0, -2), value = current[name];
if (void 0 === value) return current[name] = [ ...Array.from({
length: index
}), void 0 ], cliAddedItems.set(current[name], index + 1), {
object: current[name],
property: index,
value: void 0
};
if (Array.isArray(value)) {
let addedItems = cliAddedItems.get(value) || 0;
for (;addedItems <= index; ) value.push(void 0), addedItems++;
cliAddedItems.set(value, addedItems);
const x = value.length - addedItems + index;
if (void 0 === value[x]) value[x] = {}; else if (null === value[x] || "object" != typeof value[x]) return {
problem: {
type: "unexpected-non-object-in-path",
path: schemaPath
}
};
return {
object: value,
property: x,
value: value[x]
};
}
return current[name] = [ value, ...Array.from({
length: index
}), void 0 ], cliAddedItems.set(current[name], index + 1), {
object: current[name],
property: index + 1,
value: void 0
};
}
return {
object: current,
property,
value
};
})(config, schemaPath, index);
return problem || (object[property] = value, null);
}, processArgumentConfig = (argConfig, config, value, index) => {
if (void 0 !== index && !argConfig.multiple) return {
type: "multiple-values-unexpected",
path: argConfig.path
};
const parsed = parseValueForArgumentConfig(argConfig, value);
if (void 0 === parsed) return {
type: "invalid-value",
path: argConfig.path,
expected: getExpectedValue(argConfig)
};
const problem = setValue(config, argConfig.path, parsed, index);
return problem || null;
}, getExpectedValue = argConfig => {
switch (argConfig.type) {
default:
return argConfig.type;

case "boolean":
return "true | false";

case "RegExp":
return "regular expression (example: /ab?c*/)";

case "enum":
return argConfig.values.map((v => `${v}`)).join(" | ");

case "reset":
return "true (will reset the previous value to an empty array)";
}
}, parseValueForArgumentConfig = (argConfig, value) => {
switch (argConfig.type) {
case "string":
if ("string" == typeof value) return value;
break;

case "path":
if ("string" == typeof value) return path.resolve(value);
break;

case "number":
if ("number" == typeof value) return value;
if ("string" == typeof value) {
const n = +value;
if (!isNaN(n)) return n;
}
break;

case "boolean":
if ("boolean" == typeof value) return value;
if ("true" === value) return !0;
if ("false" === value) return !1;
break;

case "RegExp":
if (value instanceof RegExp) return value;
if ("string" == typeof value) {
const match = /^\/(.*)\/([yugi]*)$/.exec(value);
if (match && !/[^\\]\//.test(match[1])) return new RegExp(match[1], match[2]);
}
break;

case "enum":
if (argConfig.values.includes(value)) return value;
for (const item of argConfig.values) if (`${item}` === value) return item;
break;

case "reset":
if (!0 === value) return [];
}
};
exports.getArguments = (schema = webpackSchema) => {
const flags = {}, pathToArgumentName = input => input.replace(/\./g, "-").replace(/\[\]/g, "").replace(/(\p{Uppercase_Letter}+|\p{Lowercase_Letter}|\d)(\p{Uppercase_Letter}+)/gu, "$1-$2").replace(/-?[^\p{Uppercase_Letter}\p{Lowercase_Letter}\d]+/gu, "-").toLowerCase(), getSchemaPart = path => {
const newPath = path.split("/");
let schemaPart = schema;
for (let i = 1; i < newPath.length; i++) {
const inner = schemaPart[newPath[i]];
if (!inner) break;
schemaPart = inner;
}
return schemaPart;
}, getDescription = path => {
for (const {schema} of path) {
if (schema.cli) {
if (schema.cli.helper) continue;
if (schema.cli.description) return schema.cli.description;
}
if (schema.description) return schema.description;
}
}, traverse = (schemaPart, schemaPath = "", path = [], inArray = null) => {
for (;schemaPart.$ref; ) schemaPart = getSchemaPart(schemaPart.$ref);
const repetitions = path.filter((({schema}) => schema === schemaPart));
if (repetitions.length >= 2 || repetitions.some((({path}) => path === schemaPath))) return 0;
if (schemaPart.cli && schemaPart.cli.exclude) return 0;
const fullPath = [ {
schema: schemaPart,
path: schemaPath
}, ...path ];
let addedArguments = 0;
if (addedArguments += ((path, multiple) => {
const argConfigBase = (schemaPart => {
if (schemaPart.enum) return {
type: "enum",
values: schemaPart.enum
};
switch (schemaPart.type) {
case "number":
return {
type: "number"
};

case "string":
return {
type: schemaPart.absolutePath ? "path" : "string"
};

case "boolean":
return {
type: "boolean"
};
}
return "RegExp" === schemaPart.instanceof ? {
type: "RegExp"
} : void 0;
})(path[0].schema);
if (!argConfigBase) return 0;
const negatedDescription = (path => {
for (const {schema} of path) if (schema.cli) {
if (schema.cli.helper) continue;
if (schema.cli.negatedDescription) return schema.cli.negatedDescription;
}
})(path), name = pathToArgumentName(path[0].path), argConfig = {
...argConfigBase,
multiple,
description: getDescription(path),
path: path[0].path
};
if (negatedDescription && (argConfig.negatedDescription = negatedDescription), flags[name] || (flags[name] = {
configs: [],
description: void 0,
simpleType: void 0,
multiple: void 0
}), flags[name].configs.some((item => JSON.stringify(item) === JSON.stringify(argConfig)))) return 0;
if (flags[name].configs.some((item => item.type === argConfig.type && item.multiple !== multiple))) {
if (multiple) throw new Error(`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`);
return 0;
}
return flags[name].configs.push(argConfig), 1;
})(fullPath, !!inArray), "object" === schemaPart.type) {
if (schemaPart.properties) for (const property of Object.keys(schemaPart.properties)) addedArguments += traverse(schemaPart.properties[property], schemaPath ? `${schemaPath}.${property}` : property, fullPath, inArray);
return addedArguments;
}
if ("array" === schemaPart.type) {
if (inArray) return 0;
if (Array.isArray(schemaPart.items)) {
let i = 0;
for (const item of schemaPart.items) addedArguments += traverse(item, `${schemaPath}.${i}`, fullPath, schemaPath);
return addedArguments;
}
return addedArguments += traverse(schemaPart.items, `${schemaPath}[]`, fullPath, schemaPath), 
addedArguments > 0 && ((path => {
const schemaPath = path[0].path, name = pathToArgumentName(`${schemaPath}.reset`), description = (path => {
for (const {schema} of path) if (schema.cli) {
if (schema.cli.helper) continue;
if (schema.cli.resetDescription) return schema.cli.resetDescription;
}
})(path) || `Clear all items provided in '${schemaPath}' configuration. ${getDescription(path)}`;
flags[name] = {
configs: [ {
type: "reset",
multiple: !1,
description,
path: schemaPath
} ],
description: void 0,
simpleType: void 0,
multiple: void 0
};
})(fullPath), addedArguments++), addedArguments;
}
const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;
if (maybeOf) {
const items = maybeOf;
for (let i = 0; i < items.length; i++) addedArguments += traverse(items[i], schemaPath, fullPath, inArray);
return addedArguments;
}
return addedArguments;
};
traverse(schema);
for (const name of Object.keys(flags)) {
const argument = flags[name];
argument.description = argument.configs.reduce(((desc, {description}) => desc ? description ? desc.includes(description) ? desc : `${desc} ${description}` : desc : description), void 0), 
argument.simpleType = argument.configs.reduce(((t, argConfig) => {
let type = "string";
switch (argConfig.type) {
case "number":
type = "number";
break;

case "reset":
case "boolean":
type = "boolean";
break;

case "enum":
argConfig.values.every((v => "boolean" == typeof v)) && (type = "boolean"), argConfig.values.every((v => "number" == typeof v)) && (type = "number");
}
return void 0 === t ? type : t === type ? t : "string";
}), void 0), argument.multiple = argument.configs.some((c => c.multiple));
}
return flags;
}, exports.processArguments = (args, config, values) => {
const problems = [];
for (const key of Object.keys(values)) {
const arg = args[key];
if (!arg) {
problems.push({
type: "unknown-argument",
path: "",
argument: key
});
continue;
}
const processValue = (value, i) => {
const currentProblems = [];
for (const argConfig of arg.configs) {
const problem = processArgumentConfig(argConfig, config, value, i);
if (!problem) return;
currentProblems.push({
...problem,
argument: key,
value,
index: i
});
}
problems.push(...currentProblems);
};
let value = values[key];
if (Array.isArray(value)) for (let i = 0; i < value.length; i++) processValue(value[i], i); else processValue(value, void 0);
}
return 0 === problems.length ? null : problems;
};
},
49396: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const browserslist = __webpack_require__(89943), path = __webpack_require__(71017), inputRx = /^(?:((?:[A-Z]:)?[/\\].*?))?(?::(.+?))?$/i;
module.exports = {
resolve: browsers => {
const rawChecker = versions => browsers.every((v => {
const [name, parsedVersion] = v.split(" ");
if (!name) return !1;
const requiredVersion = versions[name];
if (!requiredVersion) return !1;
const [parsedMajor, parserMinor] = "TP" === parsedVersion ? [ 1 / 0, 1 / 0 ] : parsedVersion.split(".");
return "number" == typeof requiredVersion ? +parsedMajor >= requiredVersion : requiredVersion[0] === +parsedMajor ? +parserMinor >= requiredVersion[1] : +parsedMajor > requiredVersion[0];
})), anyNode = browsers.some((b => /^node /.test(b))), anyBrowser = browsers.some((b => /^(?!node)/.test(b))), browserProperty = !!anyBrowser && (!anyNode || null), nodeProperty = !!anyNode && (!anyBrowser || null), es6DynamicImport = rawChecker({
chrome: 63,
and_chr: 63,
edge: 79,
firefox: 67,
and_ff: 67,
opera: 50,
op_mob: 46,
safari: [ 11, 1 ],
ios_saf: [ 11, 3 ],
samsung: [ 8, 2 ],
android: 63,
and_qq: [ 10, 4 ],
node: [ 12, 17 ]
});
return {
const: rawChecker({
chrome: 49,
and_chr: 49,
edge: 12,
firefox: 36,
and_ff: 36,
opera: 36,
op_mob: 36,
safari: [ 10, 0 ],
ios_saf: [ 10, 0 ],
samsung: [ 5, 0 ],
android: 37,
and_qq: [ 10, 4 ],
and_uc: [ 12, 12 ],
kaios: [ 2, 5 ],
node: [ 6, 0 ]
}),
arrowFunction: rawChecker({
chrome: 45,
and_chr: 45,
edge: 12,
firefox: 39,
and_ff: 39,
opera: 32,
op_mob: 32,
safari: 10,
ios_saf: 10,
samsung: [ 5, 0 ],
android: 45,
and_qq: [ 10, 4 ],
baidu: [ 7, 12 ],
and_uc: [ 12, 12 ],
kaios: [ 2, 5 ],
node: [ 6, 0 ]
}),
forOf: rawChecker({
chrome: 38,
and_chr: 38,
edge: 12,
firefox: 51,
and_ff: 51,
opera: 25,
op_mob: 25,
safari: 7,
ios_saf: 7,
samsung: [ 3, 0 ],
android: 38,
node: [ 0, 12 ]
}),
destructuring: rawChecker({
chrome: 49,
and_chr: 49,
edge: 14,
firefox: 41,
and_ff: 41,
opera: 36,
op_mob: 36,
safari: 8,
ios_saf: 8,
samsung: [ 5, 0 ],
android: 49,
node: [ 6, 0 ]
}),
bigIntLiteral: rawChecker({
chrome: 67,
and_chr: 67,
edge: 79,
firefox: 68,
and_ff: 68,
opera: 54,
op_mob: 48,
safari: 14,
ios_saf: 14,
samsung: [ 9, 2 ],
android: 67,
node: [ 10, 4 ]
}),
module: rawChecker({
chrome: 61,
and_chr: 61,
edge: 16,
firefox: 60,
and_ff: 60,
opera: 48,
op_mob: 45,
safari: [ 10, 1 ],
ios_saf: [ 10, 3 ],
samsung: [ 8, 0 ],
android: 61,
and_qq: [ 10, 4 ],
node: [ 12, 17 ]
}),
dynamicImport: es6DynamicImport,
dynamicImportInWorker: es6DynamicImport && !anyNode,
globalThis: rawChecker({
chrome: 71,
and_chr: 71,
edge: 79,
firefox: 65,
and_ff: 65,
opera: 58,
op_mob: 50,
safari: [ 12, 1 ],
ios_saf: [ 12, 2 ],
samsung: [ 10, 1 ],
android: 71,
node: 12
}),
optionalChaining: rawChecker({
chrome: 80,
and_chr: 80,
edge: 80,
firefox: 74,
and_ff: 79,
opera: 67,
op_mob: 64,
safari: [ 13, 1 ],
ios_saf: [ 13, 4 ],
samsung: 13,
android: 80,
node: 14
}),
templateLiteral: rawChecker({
chrome: 41,
and_chr: 41,
edge: 13,
firefox: 34,
and_ff: 34,
opera: 29,
op_mob: 64,
safari: [ 9, 1 ],
ios_saf: 9,
samsung: 4,
android: 41,
and_qq: [ 10, 4 ],
baidu: [ 7, 12 ],
and_uc: [ 12, 12 ],
kaios: [ 2, 5 ],
node: 4
}),
browser: browserProperty,
electron: !1,
node: nodeProperty,
nwjs: !1,
web: browserProperty,
webworker: !1,
document: browserProperty,
fetchWasm: browserProperty,
global: nodeProperty,
importScripts: !1,
importScriptsInWorker: !0,
nodeBuiltins: nodeProperty,
require: nodeProperty
};
},
load: (input, context) => {
const {configPath, env, query} = ((input, context) => {
if (!input) return {};
if (path.isAbsolute(input)) {
const [, configPath, env] = inputRx.exec(input) || [];
return {
configPath,
env
};
}
const config = browserslist.findConfig(context);
return config && Object.keys(config).includes(input) ? {
env: input
} : {
query: input
};
})(input, context), config = query || (configPath ? browserslist.loadConfig({
config: configPath,
env
}) : browserslist.loadConfig({
path: context,
env
}));
return config ? browserslist(config) : null;
}
};
},
73054: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const fs = __webpack_require__(57147), path = __webpack_require__(71017), Template = __webpack_require__(88370), {cleverMerge} = __webpack_require__(8639), {getTargetsProperties, getTargetProperties, getDefaultTarget} = __webpack_require__(75119), NODE_MODULES_REGEXP = /[\\/]node_modules[\\/]/i, D = (obj, prop, value) => {
void 0 === obj[prop] && (obj[prop] = value);
}, F = (obj, prop, factory) => {
void 0 === obj[prop] && (obj[prop] = factory());
}, A = (obj, prop, factory) => {
const value = obj[prop];
if (void 0 === value) obj[prop] = factory(); else if (Array.isArray(value)) {
let newArray;
for (let i = 0; i < value.length; i++) {
const item = value[i];
if ("..." === item) {
void 0 === newArray && (newArray = value.slice(0, i), obj[prop] = newArray);
const items = factory();
if (void 0 !== items) for (const item of items) newArray.push(item);
} else void 0 !== newArray && newArray.push(item);
}
}
}, applyExperimentsDefaults = (experiments, {production, development, targetProperties}) => {
D(experiments, "futureDefaults", !1), D(experiments, "backCompat", !experiments.futureDefaults), 
D(experiments, "topLevelAwait", experiments.futureDefaults), D(experiments, "syncWebAssembly", !1), 
D(experiments, "asyncWebAssembly", experiments.futureDefaults), D(experiments, "outputModule", !1), 
D(experiments, "layers", !1), D(experiments, "lazyCompilation", void 0), D(experiments, "buildHttp", void 0), 
D(experiments, "cacheUnaffected", experiments.futureDefaults), F(experiments, "css", (() => experiments.futureDefaults ? {} : void 0)), 
"object" == typeof experiments.buildHttp && (D(experiments.buildHttp, "frozen", production), 
D(experiments.buildHttp, "upgrade", !1)), "object" == typeof experiments.css && D(experiments.css, "exportsOnly", !targetProperties || !targetProperties.document);
}, applyCacheDefaults = (cache, {name, mode, development, cacheUnaffected}) => {
if (!1 !== cache) switch (cache.type) {
case "filesystem":
F(cache, "name", (() => name + "-" + mode)), D(cache, "version", ""), F(cache, "cacheDirectory", (() => {
const cwd = process.cwd();
let dir = cwd;
for (;;) {
try {
if (fs.statSync(path.join(dir, "package.json")).isFile()) break;
} catch (e) {}
const parent = path.dirname(dir);
if (dir === parent) {
dir = void 0;
break;
}
dir = parent;
}
return dir ? "1" === process.versions.pnp ? path.resolve(dir, ".pnp/.cache/webpack") : "3" === process.versions.pnp ? path.resolve(dir, ".yarn/.cache/webpack") : path.resolve(dir, "node_modules/.cache/webpack") : path.resolve(cwd, ".cache/webpack");
})), F(cache, "cacheLocation", (() => path.resolve(cache.cacheDirectory, cache.name))), 
D(cache, "hashAlgorithm", "md4"), D(cache, "store", "pack"), D(cache, "compression", !1), 
D(cache, "profile", !1), D(cache, "idleTimeout", 6e4), D(cache, "idleTimeoutForInitialStore", 5e3), 
D(cache, "idleTimeoutAfterLargeChanges", 1e3), D(cache, "maxMemoryGenerations", development ? 5 : 1 / 0), 
D(cache, "maxAge", 5184e6), D(cache, "allowCollectingMemory", development), D(cache, "memoryCacheUnaffected", development && cacheUnaffected), 
D(cache.buildDependencies, "defaultWebpack", [ path.resolve(__dirname, "..") + path.sep ]);
break;

case "memory":
D(cache, "maxGenerations", 1 / 0), D(cache, "cacheUnaffected", development && cacheUnaffected);
}
}, applySnapshotDefaults = (snapshot, {production, futureDefaults}) => {
futureDefaults ? (F(snapshot, "managedPaths", (() => "3" === process.versions.pnp ? [ /^(.+?(?:[\\/]\.yarn[\\/]unplugged[\\/][^\\/]+)?[\\/]node_modules[\\/])/ ] : [ /^(.+?[\\/]node_modules[\\/])/ ])), 
F(snapshot, "immutablePaths", (() => "3" === process.versions.pnp ? [ /^(.+?[\\/]cache[\\/][^\\/]+\.zip[\\/]node_modules[\\/])/ ] : []))) : (A(snapshot, "managedPaths", (() => {
if ("3" === process.versions.pnp) {
const match = /^(.+?)[\\/]cache[\\/]watchpack-npm-[^\\/]+\.zip[\\/]node_modules[\\/]/.exec(15722);
if (match) return [ path.resolve(match[1], "unplugged") ];
} else {
const match = /^(.+?[\\/]node_modules[\\/])/.exec(15722);
if (match) return [ match[1] ];
}
return [];
})), A(snapshot, "immutablePaths", (() => {
if ("1" === process.versions.pnp) {
const match = /^(.+?[\\/]v4)[\\/]npm-watchpack-[^\\/]+-[\da-f]{40}[\\/]node_modules[\\/]/.exec(15722);
if (match) return [ match[1] ];
} else if ("3" === process.versions.pnp) {
const match = /^(.+?)[\\/]watchpack-npm-[^\\/]+\.zip[\\/]node_modules[\\/]/.exec(15722);
if (match) return [ match[1] ];
}
return [];
}))), F(snapshot, "resolveBuildDependencies", (() => ({
timestamp: !0,
hash: !0
}))), F(snapshot, "buildDependencies", (() => ({
timestamp: !0,
hash: !0
}))), F(snapshot, "module", (() => production ? {
timestamp: !0,
hash: !0
} : {
timestamp: !0
})), F(snapshot, "resolve", (() => production ? {
timestamp: !0,
hash: !0
} : {
timestamp: !0
}));
}, applyModuleDefaults = (module, {cache, syncWebAssembly, asyncWebAssembly, css, futureDefaults, isNode}) => {
D(module, "unsafeCache", !!cache && (module => {
const name = module.nameForCondition();
return name && NODE_MODULES_REGEXP.test(name);
})), F(module.parser, "asset", (() => ({}))), F(module.parser.asset, "dataUrlCondition", (() => ({}))), 
"object" == typeof module.parser.asset.dataUrlCondition && D(module.parser.asset.dataUrlCondition, "maxSize", 8096), 
F(module.parser, "javascript", (() => ({}))), ((parserOptions, {futureDefaults, isNode}) => {
D(parserOptions, "unknownContextRequest", "."), D(parserOptions, "unknownContextRegExp", !1), 
D(parserOptions, "unknownContextRecursive", !0), D(parserOptions, "unknownContextCritical", !0), 
D(parserOptions, "exprContextRequest", "."), D(parserOptions, "exprContextRegExp", !1), 
D(parserOptions, "exprContextRecursive", !0), D(parserOptions, "exprContextCritical", !0), 
D(parserOptions, "wrappedContextRegExp", /.*/), D(parserOptions, "wrappedContextRecursive", !0), 
D(parserOptions, "wrappedContextCritical", !1), D(parserOptions, "strictThisContextOnImports", !1), 
D(parserOptions, "importMeta", !0), D(parserOptions, "dynamicImportMode", "lazy"), 
D(parserOptions, "dynamicImportPrefetch", !1), D(parserOptions, "dynamicImportPreload", !1), 
D(parserOptions, "createRequire", isNode), futureDefaults && D(parserOptions, "exportsPresence", "error");
})(module.parser.javascript, {
futureDefaults,
isNode
}), A(module, "defaultRules", (() => {
const esm = {
type: "javascript/esm",
resolve: {
byDependency: {
esm: {
fullySpecified: !0
}
}
}
}, commonjs = {
type: "javascript/dynamic"
}, rules = [ {
mimetype: "application/node",
type: "javascript/auto"
}, {
test: /\.json$/i,
type: "json"
}, {
mimetype: "application/json",
type: "json"
}, {
test: /\.mjs$/i,
...esm
}, {
test: /\.js$/i,
descriptionData: {
type: "module"
},
...esm
}, {
test: /\.cjs$/i,
...commonjs
}, {
test: /\.js$/i,
descriptionData: {
type: "commonjs"
},
...commonjs
}, {
mimetype: {
or: [ "text/javascript", "application/javascript" ]
},
...esm
} ];
if (asyncWebAssembly) {
const wasm = {
type: "webassembly/async",
rules: [ {
descriptionData: {
type: "module"
},
resolve: {
fullySpecified: !0
}
} ]
};
rules.push({
test: /\.wasm$/i,
...wasm
}), rules.push({
mimetype: "application/wasm",
...wasm
});
} else if (syncWebAssembly) {
const wasm = {
type: "webassembly/sync",
rules: [ {
descriptionData: {
type: "module"
},
resolve: {
fullySpecified: !0
}
} ]
};
rules.push({
test: /\.wasm$/i,
...wasm
}), rules.push({
mimetype: "application/wasm",
...wasm
});
}
if (css) {
const cssRule = {
type: "css",
resolve: {
fullySpecified: !0,
preferRelative: !0
}
}, cssModulesRule = {
type: "css/module",
resolve: {
fullySpecified: !0
}
};
rules.push({
test: /\.css$/i,
oneOf: [ {
test: /\.module\.css$/i,
...cssModulesRule
}, {
...cssRule
} ]
}), rules.push({
mimetype: "text/css+module",
...cssModulesRule
}), rules.push({
mimetype: "text/css",
...cssRule
});
}
return rules.push({
dependency: "url",
oneOf: [ {
scheme: /^data$/,
type: "asset/inline"
}, {
type: "asset/resource"
} ]
}, {
assert: {
type: "json"
},
type: "json"
}), rules;
}));
}, applyOutputDefaults = (output, {context, targetProperties: tp, isAffectedByBrowserslist, outputModule, development, entry, module, futureDefaults}) => {
const getLibraryName = library => {
const libraryName = "object" == typeof library && library && !Array.isArray(library) && "type" in library ? library.name : library;
return Array.isArray(libraryName) ? libraryName.join(".") : "object" == typeof libraryName ? getLibraryName(libraryName.root) : "string" == typeof libraryName ? libraryName : "";
};
F(output, "uniqueName", (() => {
const libraryName = getLibraryName(output.library).replace(/^\[(\\*[\w:]+\\*)\](\.)|(\.)\[(\\*[\w:]+\\*)\](?=\.|$)|\[(\\*[\w:]+\\*)\]/g, ((m, a, d1, d2, b, c) => {
const content = a || b || c;
return content.startsWith("\\") && content.endsWith("\\") ? `${d2 || ""}[${content.slice(1, -1)}]${d1 || ""}` : "";
}));
if (libraryName) return libraryName;
const pkgPath = path.resolve(context, "package.json");
try {
return JSON.parse(fs.readFileSync(pkgPath, "utf-8")).name || "";
} catch (e) {
if ("ENOENT" !== e.code) throw e.message += `\nwhile determining default 'output.uniqueName' from 'name' in ${pkgPath}`, 
e;
return "";
}
})), F(output, "module", (() => !!outputModule)), D(output, "filename", output.module ? "[name].mjs" : "[name].js"), 
F(output, "iife", (() => !output.module)), D(output, "importFunctionName", "import"), 
D(output, "importMetaName", "import.meta"), F(output, "chunkFilename", (() => {
const filename = output.filename;
if ("function" != typeof filename) {
const hasName = filename.includes("[name]"), hasId = filename.includes("[id]"), hasChunkHash = filename.includes("[chunkhash]"), hasContentHash = filename.includes("[contenthash]");
return hasChunkHash || hasContentHash || hasName || hasId ? filename : filename.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
}
return output.module ? "[id].mjs" : "[id].js";
})), F(output, "cssFilename", (() => {
const filename = output.filename;
return "function" != typeof filename ? filename.replace(/\.[mc]?js(\?|$)/, ".css$1") : "[id].css";
})), F(output, "cssChunkFilename", (() => {
const chunkFilename = output.chunkFilename;
return "function" != typeof chunkFilename ? chunkFilename.replace(/\.[mc]?js(\?|$)/, ".css$1") : "[id].css";
})), D(output, "assetModuleFilename", "[hash][ext][query]"), D(output, "webassemblyModuleFilename", "[hash].module.wasm"), 
D(output, "compareBeforeEmit", !0), D(output, "charset", !0), F(output, "hotUpdateGlobal", (() => Template.toIdentifier("webpackHotUpdate" + Template.toIdentifier(output.uniqueName)))), 
F(output, "chunkLoadingGlobal", (() => Template.toIdentifier("webpackChunk" + Template.toIdentifier(output.uniqueName)))), 
F(output, "globalObject", (() => {
if (tp) {
if (tp.global) return "global";
if (tp.globalThis) return "globalThis";
}
return "self";
})), F(output, "chunkFormat", (() => {
if (tp) {
const helpMessage = isAffectedByBrowserslist ? "Make sure that your 'browserslist' includes only platforms that support these features or select an appropriate 'target' to allow selecting a chunk format by default. Alternatively specify the 'output.chunkFormat' directly." : "Select an appropriate 'target' to allow selecting one by default, or specify the 'output.chunkFormat' directly.";
if (output.module) {
if (tp.dynamicImport) return "module";
if (tp.document) return "array-push";
throw new Error("For the selected environment is no default ESM chunk format available:\nESM exports can be chosen when 'import()' is available.\nJSONP Array push can be chosen when 'document' is available.\n" + helpMessage);
}
if (tp.document) return "array-push";
if (tp.require) return "commonjs";
if (tp.nodeBuiltins) return "commonjs";
if (tp.importScripts) return "array-push";
throw new Error("For the selected environment is no default script chunk format available:\nJSONP Array push can be chosen when 'document' or 'importScripts' is available.\nCommonJs exports can be chosen when 'require' or node builtins are available.\n" + helpMessage);
}
throw new Error("Chunk format can't be selected by default when no target is specified");
})), D(output, "asyncChunks", !0), F(output, "chunkLoading", (() => {
if (tp) {
switch (output.chunkFormat) {
case "array-push":
if (tp.document) return "jsonp";
if (tp.importScripts) return "import-scripts";
break;

case "commonjs":
if (tp.require) return "require";
if (tp.nodeBuiltins) return "async-node";
break;

case "module":
if (tp.dynamicImport) return "import";
}
if (null === tp.require || null === tp.nodeBuiltins || null === tp.document || null === tp.importScripts) return "universal";
}
return !1;
})), F(output, "workerChunkLoading", (() => {
if (tp) {
switch (output.chunkFormat) {
case "array-push":
if (tp.importScriptsInWorker) return "import-scripts";
break;

case "commonjs":
if (tp.require) return "require";
if (tp.nodeBuiltins) return "async-node";
break;

case "module":
if (tp.dynamicImportInWorker) return "import";
}
if (null === tp.require || null === tp.nodeBuiltins || null === tp.importScriptsInWorker) return "universal";
}
return !1;
})), F(output, "wasmLoading", (() => {
if (tp) {
if (tp.fetchWasm) return "fetch";
if (tp.nodeBuiltins) return output.module ? "async-node-module" : "async-node";
if (null === tp.nodeBuiltins || null === tp.fetchWasm) return "universal";
}
return !1;
})), F(output, "workerWasmLoading", (() => output.wasmLoading)), F(output, "devtoolNamespace", (() => output.uniqueName)), 
output.library && F(output.library, "type", (() => output.module ? "module" : "var")), 
F(output, "path", (() => path.join(process.cwd(), "dist"))), F(output, "pathinfo", (() => development)), 
D(output, "sourceMapFilename", "[file].map[query]"), D(output, "hotUpdateChunkFilename", "[id].[fullhash].hot-update." + (output.module ? "mjs" : "js")), 
D(output, "hotUpdateMainFilename", "[runtime].[fullhash].hot-update.json"), D(output, "crossOriginLoading", !1), 
F(output, "scriptType", (() => !!output.module && "module")), D(output, "publicPath", tp && (tp.document || tp.importScripts) || "module" === output.scriptType ? "auto" : ""), 
D(output, "chunkLoadTimeout", 12e4), D(output, "hashFunction", futureDefaults ? "xxhash64" : "md4"), 
D(output, "hashDigest", "hex"), D(output, "hashDigestLength", futureDefaults ? 16 : 20), 
D(output, "strictModuleExceptionHandling", !1);
const optimistic = v => v || void 0 === v, conditionallyOptimistic = (v, c) => void 0 === v && c || v;
F(output.environment, "arrowFunction", (() => tp && optimistic(tp.arrowFunction))), 
F(output.environment, "const", (() => tp && optimistic(tp.const))), F(output.environment, "destructuring", (() => tp && optimistic(tp.destructuring))), 
F(output.environment, "forOf", (() => tp && optimistic(tp.forOf))), F(output.environment, "bigIntLiteral", (() => tp && tp.bigIntLiteral)), 
F(output.environment, "dynamicImport", (() => conditionallyOptimistic(tp && tp.dynamicImport, output.module))), 
F(output.environment, "module", (() => conditionallyOptimistic(tp && tp.module, output.module)));
const {trustedTypes} = output;
trustedTypes && F(trustedTypes, "policyName", (() => output.uniqueName.replace(/[^a-zA-Z0-9\-#=_/@.%]+/g, "_") || "webpack"));
const forEachEntry = fn => {
for (const name of Object.keys(entry)) fn(entry[name]);
};
A(output, "enabledLibraryTypes", (() => {
const enabledLibraryTypes = [];
return output.library && enabledLibraryTypes.push(output.library.type), forEachEntry((desc => {
desc.library && enabledLibraryTypes.push(desc.library.type);
})), enabledLibraryTypes;
})), A(output, "enabledChunkLoadingTypes", (() => {
const enabledChunkLoadingTypes = new Set;
return output.chunkLoading && enabledChunkLoadingTypes.add(output.chunkLoading), 
output.workerChunkLoading && enabledChunkLoadingTypes.add(output.workerChunkLoading), 
forEachEntry((desc => {
desc.chunkLoading && enabledChunkLoadingTypes.add(desc.chunkLoading);
})), Array.from(enabledChunkLoadingTypes);
})), A(output, "enabledWasmLoadingTypes", (() => {
const enabledWasmLoadingTypes = new Set;
return output.wasmLoading && enabledWasmLoadingTypes.add(output.wasmLoading), output.workerWasmLoading && enabledWasmLoadingTypes.add(output.workerWasmLoading), 
forEachEntry((desc => {
desc.wasmLoading && enabledWasmLoadingTypes.add(desc.wasmLoading);
})), Array.from(enabledWasmLoadingTypes);
}));
}, applyExternalsPresetsDefaults = (externalsPresets, {targetProperties, buildHttp}) => {
D(externalsPresets, "web", !buildHttp && targetProperties && targetProperties.web), 
D(externalsPresets, "node", targetProperties && targetProperties.node), D(externalsPresets, "nwjs", targetProperties && targetProperties.nwjs), 
D(externalsPresets, "electron", targetProperties && targetProperties.electron), 
D(externalsPresets, "electronMain", targetProperties && targetProperties.electron && targetProperties.electronMain), 
D(externalsPresets, "electronPreload", targetProperties && targetProperties.electron && targetProperties.electronPreload), 
D(externalsPresets, "electronRenderer", targetProperties && targetProperties.electron && targetProperties.electronRenderer);
}, applyLoaderDefaults = (loader, {targetProperties}) => {
F(loader, "target", (() => {
if (targetProperties) {
if (targetProperties.electron) return targetProperties.electronMain ? "electron-main" : targetProperties.electronPreload ? "electron-preload" : targetProperties.electronRenderer ? "electron-renderer" : "electron";
if (targetProperties.nwjs) return "nwjs";
if (targetProperties.node) return "node";
if (targetProperties.web) return "web";
}
}));
}, applyNodeDefaults = (node, {futureDefaults, targetProperties}) => {
!1 !== node && (F(node, "global", (() => (!targetProperties || !targetProperties.global) && (!futureDefaults || "warn"))), 
F(node, "__filename", (() => targetProperties && targetProperties.node ? "eval-only" : futureDefaults ? "warn-mock" : "mock")), 
F(node, "__dirname", (() => targetProperties && targetProperties.node ? "eval-only" : futureDefaults ? "warn-mock" : "mock")));
}, applyPerformanceDefaults = (performance, {production}) => {
!1 !== performance && (D(performance, "maxAssetSize", 25e4), D(performance, "maxEntrypointSize", 25e4), 
F(performance, "hints", (() => !!production && "warning")));
}, applyOptimizationDefaults = (optimization, {production, development, css, records}) => {
D(optimization, "removeAvailableModules", !1), D(optimization, "removeEmptyChunks", !0), 
D(optimization, "mergeDuplicateChunks", !0), D(optimization, "flagIncludedChunks", production), 
F(optimization, "moduleIds", (() => production ? "deterministic" : development ? "named" : "natural")), 
F(optimization, "chunkIds", (() => production ? "deterministic" : development ? "named" : "natural")), 
F(optimization, "sideEffects", (() => !!production || "flag")), D(optimization, "providedExports", !0), 
D(optimization, "usedExports", production), D(optimization, "innerGraph", production), 
D(optimization, "mangleExports", production), D(optimization, "concatenateModules", production), 
D(optimization, "runtimeChunk", !1), D(optimization, "emitOnErrors", !production), 
D(optimization, "checkWasmTypes", production), D(optimization, "mangleWasmImports", !1), 
D(optimization, "portableRecords", records), D(optimization, "realContentHash", production), 
D(optimization, "minimize", production), A(optimization, "minimizer", (() => [ {
apply: compiler => {
new (__webpack_require__(2357))({
terserOptions: {
compress: {
passes: 2
}
}
}).apply(compiler);
}
} ])), F(optimization, "nodeEnv", (() => production ? "production" : !!development && "development"));
const {splitChunks} = optimization;
if (splitChunks) {
A(splitChunks, "defaultSizeTypes", (() => css ? [ "javascript", "css", "unknown" ] : [ "javascript", "unknown" ])), 
D(splitChunks, "hidePathInfo", production), D(splitChunks, "chunks", "async"), D(splitChunks, "usedExports", !0 === optimization.usedExports), 
D(splitChunks, "minChunks", 1), F(splitChunks, "minSize", (() => production ? 2e4 : 1e4)), 
F(splitChunks, "minRemainingSize", (() => development ? 0 : void 0)), F(splitChunks, "enforceSizeThreshold", (() => production ? 5e4 : 3e4)), 
F(splitChunks, "maxAsyncRequests", (() => production ? 30 : 1 / 0)), F(splitChunks, "maxInitialRequests", (() => production ? 30 : 1 / 0)), 
D(splitChunks, "automaticNameDelimiter", "-");
const {cacheGroups} = splitChunks;
F(cacheGroups, "default", (() => ({
idHint: "",
reuseExistingChunk: !0,
minChunks: 2,
priority: -20
}))), F(cacheGroups, "defaultVendors", (() => ({
idHint: "vendors",
reuseExistingChunk: !0,
test: NODE_MODULES_REGEXP,
priority: -10
})));
}
}, getResolveDefaults = ({cache, context, targetProperties, mode}) => {
const conditions = [ "webpack" ];
conditions.push("development" === mode ? "development" : "production"), targetProperties && (targetProperties.webworker && conditions.push("worker"), 
targetProperties.node && conditions.push("node"), targetProperties.web && conditions.push("browser"), 
targetProperties.electron && conditions.push("electron"), targetProperties.nwjs && conditions.push("nwjs"));
const jsExtensions = [ ".js", ".json", ".wasm" ], tp = targetProperties, browserField = tp && tp.web && (!tp.node || tp.electron && tp.electronRenderer), cjsDeps = () => ({
aliasFields: browserField ? [ "browser" ] : [],
mainFields: browserField ? [ "browser", "module", "..." ] : [ "module", "..." ],
conditionNames: [ "require", "module", "..." ],
extensions: [ ...jsExtensions ]
}), esmDeps = () => ({
aliasFields: browserField ? [ "browser" ] : [],
mainFields: browserField ? [ "browser", "module", "..." ] : [ "module", "..." ],
conditionNames: [ "import", "module", "..." ],
extensions: [ ...jsExtensions ]
});
return {
cache,
modules: [ "node_modules" ],
conditionNames: conditions,
mainFiles: [ "index" ],
extensions: [],
aliasFields: [],
exportsFields: [ "exports" ],
roots: [ context ],
mainFields: [ "main" ],
byDependency: {
wasm: esmDeps(),
esm: esmDeps(),
loaderImport: esmDeps(),
url: {
preferRelative: !0
},
worker: {
...esmDeps(),
preferRelative: !0
},
commonjs: cjsDeps(),
amd: cjsDeps(),
loader: cjsDeps(),
unknown: cjsDeps(),
undefined: cjsDeps()
}
};
}, getResolveLoaderDefaults = ({cache}) => ({
cache,
conditionNames: [ "loader", "require", "node" ],
exportsFields: [ "exports" ],
mainFields: [ "loader", "main" ],
extensions: [ ".js" ],
mainFiles: [ "index" ]
}), applyInfrastructureLoggingDefaults = infrastructureLogging => {
F(infrastructureLogging, "stream", (() => process.stderr));
const tty = infrastructureLogging.stream.isTTY && "dumb" !== process.env.TERM;
D(infrastructureLogging, "level", "info"), D(infrastructureLogging, "debug", !1), 
D(infrastructureLogging, "colors", tty), D(infrastructureLogging, "appendOnly", !tty);
};
exports.applyWebpackOptionsBaseDefaults = options => {
F(options, "context", (() => process.cwd())), applyInfrastructureLoggingDefaults(options.infrastructureLogging);
}, exports.applyWebpackOptionsDefaults = options => {
F(options, "context", (() => process.cwd())), F(options, "target", (() => getDefaultTarget(options.context)));
const {mode, name, target} = options;
let targetProperties = !1 !== target && ("string" == typeof target ? getTargetProperties(target, options.context) : getTargetsProperties(target, options.context));
const development = "development" === mode, production = "production" === mode || !mode;
if ("function" != typeof options.entry) for (const key of Object.keys(options.entry)) F(options.entry[key], "import", (() => [ "./src" ]));
F(options, "devtool", (() => !!development && "eval")), D(options, "watch", !1), 
D(options, "profile", !1), D(options, "parallelism", 100), D(options, "recordsInputPath", !1), 
D(options, "recordsOutputPath", !1), applyExperimentsDefaults(options.experiments, {
production,
development,
targetProperties
});
const futureDefaults = options.experiments.futureDefaults;
F(options, "cache", (() => !!development && {
type: "memory"
})), applyCacheDefaults(options.cache, {
name: name || "default",
mode: mode || "production",
development,
cacheUnaffected: options.experiments.cacheUnaffected
});
const cache = !!options.cache;
applySnapshotDefaults(options.snapshot, {
production,
futureDefaults
}), applyModuleDefaults(options.module, {
cache,
syncWebAssembly: options.experiments.syncWebAssembly,
asyncWebAssembly: options.experiments.asyncWebAssembly,
css: options.experiments.css,
futureDefaults,
isNode: targetProperties && !0 === targetProperties.node
}), applyOutputDefaults(options.output, {
context: options.context,
targetProperties,
isAffectedByBrowserslist: void 0 === target || "string" == typeof target && target.startsWith("browserslist") || Array.isArray(target) && target.some((target => target.startsWith("browserslist"))),
outputModule: options.experiments.outputModule,
development,
entry: options.entry,
module: options.module,
futureDefaults
}), applyExternalsPresetsDefaults(options.externalsPresets, {
targetProperties,
buildHttp: !!options.experiments.buildHttp
}), applyLoaderDefaults(options.loader, {
targetProperties
}), F(options, "externalsType", (() => {
const validExternalTypes = __webpack_require__(46312).definitions.ExternalsType.enum;
return options.output.library && validExternalTypes.includes(options.output.library.type) ? options.output.library.type : options.output.module ? "module" : "var";
})), applyNodeDefaults(options.node, {
futureDefaults: options.experiments.futureDefaults,
targetProperties
}), F(options, "performance", (() => !(!production || !targetProperties || !targetProperties.browser && null !== targetProperties.browser) && {})), 
applyPerformanceDefaults(options.performance, {
production
}), applyOptimizationDefaults(options.optimization, {
development,
production,
css: options.experiments.css,
records: !(!options.recordsInputPath && !options.recordsOutputPath)
}), options.resolve = cleverMerge(getResolveDefaults({
cache,
context: options.context,
targetProperties,
mode: options.mode
}), options.resolve), options.resolveLoader = cleverMerge(getResolveLoaderDefaults({
cache
}), options.resolveLoader);
};
},
70884: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const handledDeprecatedNoEmitOnErrors = __webpack_require__(73837).deprecate(((noEmitOnErrors, emitOnErrors) => {
if (void 0 !== emitOnErrors && !noEmitOnErrors == !emitOnErrors) throw new Error("Conflicting use of 'optimization.noEmitOnErrors' and 'optimization.emitOnErrors'. Remove deprecated 'optimization.noEmitOnErrors' from config.");
return !noEmitOnErrors;
}), "optimization.noEmitOnErrors is deprecated in favor of optimization.emitOnErrors", "DEP_WEBPACK_CONFIGURATION_OPTIMIZATION_NO_EMIT_ON_ERRORS"), nestedConfig = (value, fn) => fn(void 0 === value ? {} : value), cloneObject = value => ({
...value
}), optionalNestedConfig = (value, fn) => void 0 === value ? void 0 : fn(value), nestedArray = (value, fn) => Array.isArray(value) ? fn(value) : fn([]), optionalNestedArray = (value, fn) => Array.isArray(value) ? fn(value) : void 0, keyedNestedConfig = (value, fn, customKeys) => {
const result = void 0 === value ? {} : Object.keys(value).reduce(((obj, key) => (obj[key] = (customKeys && key in customKeys ? customKeys[key] : fn)(value[key]), 
obj)), {});
if (customKeys) for (const key of Object.keys(customKeys)) key in result || (result[key] = customKeys[key]({}));
return result;
}, getNormalizedEntryStatic = entry => {
if ("string" == typeof entry) return {
main: {
import: [ entry ]
}
};
if (Array.isArray(entry)) return {
main: {
import: entry
}
};
const result = {};
for (const key of Object.keys(entry)) {
const value = entry[key];
"string" == typeof value ? result[key] = {
import: [ value ]
} : Array.isArray(value) ? result[key] = {
import: value
} : result[key] = {
import: value.import && (Array.isArray(value.import) ? value.import : [ value.import ]),
filename: value.filename,
layer: value.layer,
runtime: value.runtime,
baseUri: value.baseUri,
publicPath: value.publicPath,
chunkLoading: value.chunkLoading,
asyncChunks: value.asyncChunks,
wasmLoading: value.wasmLoading,
dependOn: value.dependOn && (Array.isArray(value.dependOn) ? value.dependOn : [ value.dependOn ]),
library: value.library
};
}
return result;
}, getNormalizedOptimizationRuntimeChunk = runtimeChunk => {
if (void 0 === runtimeChunk) return;
if (!1 === runtimeChunk) return !1;
if ("single" === runtimeChunk) return {
name: () => "runtime"
};
if (!0 === runtimeChunk || "multiple" === runtimeChunk) return {
name: entrypoint => `runtime~${entrypoint.name}`
};
const {name} = runtimeChunk;
return {
name: "function" == typeof name ? name : () => name
};
};
exports.getNormalizedWebpackOptions = config => {
return {
amd: config.amd,
bail: config.bail,
cache: optionalNestedConfig(config.cache, (cache => {
if (!1 === cache) return !1;
if (!0 === cache) return {
type: "memory",
maxGenerations: void 0
};
switch (cache.type) {
case "filesystem":
return {
type: "filesystem",
allowCollectingMemory: cache.allowCollectingMemory,
maxMemoryGenerations: cache.maxMemoryGenerations,
maxAge: cache.maxAge,
profile: cache.profile,
buildDependencies: cloneObject(cache.buildDependencies),
cacheDirectory: cache.cacheDirectory,
cacheLocation: cache.cacheLocation,
hashAlgorithm: cache.hashAlgorithm,
compression: cache.compression,
idleTimeout: cache.idleTimeout,
idleTimeoutForInitialStore: cache.idleTimeoutForInitialStore,
idleTimeoutAfterLargeChanges: cache.idleTimeoutAfterLargeChanges,
name: cache.name,
store: cache.store,
version: cache.version
};

case void 0:
case "memory":
return {
type: "memory",
maxGenerations: cache.maxGenerations
};

default:
throw new Error(`Not implemented cache.type ${cache.type}`);
}
})),
context: config.context,
dependencies: config.dependencies,
devServer: optionalNestedConfig(config.devServer, (devServer => ({
...devServer
}))),
devtool: config.devtool,
entry: void 0 === config.entry ? {
main: {}
} : "function" == typeof config.entry ? (fn = config.entry, () => Promise.resolve().then(fn).then(getNormalizedEntryStatic)) : getNormalizedEntryStatic(config.entry),
experiments: nestedConfig(config.experiments, (experiments => ({
...experiments,
buildHttp: optionalNestedConfig(experiments.buildHttp, (options => Array.isArray(options) ? {
allowedUris: options
} : options)),
lazyCompilation: optionalNestedConfig(experiments.lazyCompilation, (options => !0 === options ? {} : !1 === options ? void 0 : options)),
css: optionalNestedConfig(experiments.css, (options => !0 === options ? {} : !1 === options ? void 0 : options))
}))),
externals: config.externals,
externalsPresets: cloneObject(config.externalsPresets),
externalsType: config.externalsType,
ignoreWarnings: config.ignoreWarnings ? config.ignoreWarnings.map((ignore => {
if ("function" == typeof ignore) return ignore;
const i = ignore instanceof RegExp ? {
message: ignore
} : ignore;
return (warning, {requestShortener}) => !!(i.message || i.module || i.file) && (!(i.message && !i.message.test(warning.message)) && (!!(!i.module || warning.module && i.module.test(warning.module.readableIdentifier(requestShortener))) && !!(!i.file || warning.file && i.file.test(warning.file))));
})) : void 0,
infrastructureLogging: cloneObject(config.infrastructureLogging),
loader: cloneObject(config.loader),
mode: config.mode,
module: nestedConfig(config.module, (module => ({
noParse: module.noParse,
unsafeCache: module.unsafeCache,
parser: keyedNestedConfig(module.parser, cloneObject, {
javascript: parserOptions => ({
unknownContextRequest: module.unknownContextRequest,
unknownContextRegExp: module.unknownContextRegExp,
unknownContextRecursive: module.unknownContextRecursive,
unknownContextCritical: module.unknownContextCritical,
exprContextRequest: module.exprContextRequest,
exprContextRegExp: module.exprContextRegExp,
exprContextRecursive: module.exprContextRecursive,
exprContextCritical: module.exprContextCritical,
wrappedContextRegExp: module.wrappedContextRegExp,
wrappedContextRecursive: module.wrappedContextRecursive,
wrappedContextCritical: module.wrappedContextCritical,
strictExportPresence: module.strictExportPresence,
strictThisContextOnImports: module.strictThisContextOnImports,
...parserOptions
})
}),
generator: cloneObject(module.generator),
defaultRules: optionalNestedArray(module.defaultRules, (r => [ ...r ])),
rules: nestedArray(module.rules, (r => [ ...r ]))
}))),
name: config.name,
node: nestedConfig(config.node, (node => node && {
...node
})),
optimization: nestedConfig(config.optimization, (optimization => ({
...optimization,
runtimeChunk: getNormalizedOptimizationRuntimeChunk(optimization.runtimeChunk),
splitChunks: nestedConfig(optimization.splitChunks, (splitChunks => splitChunks && {
...splitChunks,
defaultSizeTypes: splitChunks.defaultSizeTypes ? [ ...splitChunks.defaultSizeTypes ] : [ "..." ],
cacheGroups: cloneObject(splitChunks.cacheGroups)
})),
emitOnErrors: void 0 !== optimization.noEmitOnErrors ? handledDeprecatedNoEmitOnErrors(optimization.noEmitOnErrors, optimization.emitOnErrors) : optimization.emitOnErrors
}))),
output: nestedConfig(config.output, (output => {
const {library} = output, libraryAsName = library, libraryBase = "object" == typeof library && library && !Array.isArray(library) && "type" in library ? library : libraryAsName || output.libraryTarget ? {
name: libraryAsName
} : void 0;
return {
assetModuleFilename: output.assetModuleFilename,
asyncChunks: output.asyncChunks,
charset: output.charset,
chunkFilename: output.chunkFilename,
chunkFormat: output.chunkFormat,
chunkLoading: output.chunkLoading,
chunkLoadingGlobal: output.chunkLoadingGlobal,
chunkLoadTimeout: output.chunkLoadTimeout,
cssFilename: output.cssFilename,
cssChunkFilename: output.cssChunkFilename,
clean: output.clean,
compareBeforeEmit: output.compareBeforeEmit,
crossOriginLoading: output.crossOriginLoading,
devtoolFallbackModuleFilenameTemplate: output.devtoolFallbackModuleFilenameTemplate,
devtoolModuleFilenameTemplate: output.devtoolModuleFilenameTemplate,
devtoolNamespace: output.devtoolNamespace,
environment: cloneObject(output.environment),
enabledChunkLoadingTypes: output.enabledChunkLoadingTypes ? [ ...output.enabledChunkLoadingTypes ] : [ "..." ],
enabledLibraryTypes: output.enabledLibraryTypes ? [ ...output.enabledLibraryTypes ] : [ "..." ],
enabledWasmLoadingTypes: output.enabledWasmLoadingTypes ? [ ...output.enabledWasmLoadingTypes ] : [ "..." ],
filename: output.filename,
globalObject: output.globalObject,
hashDigest: output.hashDigest,
hashDigestLength: output.hashDigestLength,
hashFunction: output.hashFunction,
hashSalt: output.hashSalt,
hotUpdateChunkFilename: output.hotUpdateChunkFilename,
hotUpdateGlobal: output.hotUpdateGlobal,
hotUpdateMainFilename: output.hotUpdateMainFilename,
iife: output.iife,
importFunctionName: output.importFunctionName,
importMetaName: output.importMetaName,
scriptType: output.scriptType,
library: libraryBase && {
type: void 0 !== output.libraryTarget ? output.libraryTarget : libraryBase.type,
auxiliaryComment: void 0 !== output.auxiliaryComment ? output.auxiliaryComment : libraryBase.auxiliaryComment,
export: void 0 !== output.libraryExport ? output.libraryExport : libraryBase.export,
name: libraryBase.name,
umdNamedDefine: void 0 !== output.umdNamedDefine ? output.umdNamedDefine : libraryBase.umdNamedDefine
},
module: output.module,
path: output.path,
pathinfo: output.pathinfo,
publicPath: output.publicPath,
sourceMapFilename: output.sourceMapFilename,
sourcePrefix: output.sourcePrefix,
strictModuleExceptionHandling: output.strictModuleExceptionHandling,
trustedTypes: optionalNestedConfig(output.trustedTypes, (trustedTypes => !0 === trustedTypes ? {} : "string" == typeof trustedTypes ? {
policyName: trustedTypes
} : {
...trustedTypes
})),
uniqueName: output.uniqueName,
wasmLoading: output.wasmLoading,
webassemblyModuleFilename: output.webassemblyModuleFilename,
workerChunkLoading: output.workerChunkLoading,
workerWasmLoading: output.workerWasmLoading
};
})),
parallelism: config.parallelism,
performance: optionalNestedConfig(config.performance, (performance => !1 !== performance && {
...performance
})),
plugins: nestedArray(config.plugins, (p => [ ...p ])),
profile: config.profile,
recordsInputPath: void 0 !== config.recordsInputPath ? config.recordsInputPath : config.recordsPath,
recordsOutputPath: void 0 !== config.recordsOutputPath ? config.recordsOutputPath : config.recordsPath,
resolve: nestedConfig(config.resolve, (resolve => ({
...resolve,
byDependency: keyedNestedConfig(resolve.byDependency, cloneObject)
}))),
resolveLoader: cloneObject(config.resolveLoader),
snapshot: nestedConfig(config.snapshot, (snapshot => ({
resolveBuildDependencies: optionalNestedConfig(snapshot.resolveBuildDependencies, (resolveBuildDependencies => ({
timestamp: resolveBuildDependencies.timestamp,
hash: resolveBuildDependencies.hash
}))),
buildDependencies: optionalNestedConfig(snapshot.buildDependencies, (buildDependencies => ({
timestamp: buildDependencies.timestamp,
hash: buildDependencies.hash
}))),
resolve: optionalNestedConfig(snapshot.resolve, (resolve => ({
timestamp: resolve.timestamp,
hash: resolve.hash
}))),
module: optionalNestedConfig(snapshot.module, (module => ({
timestamp: module.timestamp,
hash: module.hash
}))),
immutablePaths: optionalNestedArray(snapshot.immutablePaths, (p => [ ...p ])),
managedPaths: optionalNestedArray(snapshot.managedPaths, (p => [ ...p ]))
}))),
stats: nestedConfig(config.stats, (stats => !1 === stats ? {
preset: "none"
} : !0 === stats ? {
preset: "normal"
} : "string" == typeof stats ? {
preset: stats
} : {
...stats
})),
target: config.target,
watch: config.watch,
watchOptions: cloneObject(config.watchOptions)
};
var fn;
};
},
75119: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const getBrowserslistTargetHandler = __webpack_require__(98216)((() => __webpack_require__(49396))), versionDependent = (major, minor) => major ? (major = +major, 
minor = minor ? +minor : 0, (vMajor, vMinor = 0) => major > vMajor || major === vMajor && minor >= vMinor) : () => {}, TARGETS = [ [ "browserslist / browserslist:env / browserslist:query / browserslist:path-to-config / browserslist:path-to-config:env", "Resolve features from browserslist. Will resolve browserslist config automatically. Only browser or node queries are supported (electron is not supported). Examples: 'browserslist:modern' to use 'modern' environment from browserslist config", /^browserslist(?::(.+))?$/, (rest, context) => {
const browserslistTargetHandler = getBrowserslistTargetHandler(), browsers = browserslistTargetHandler.load(rest ? rest.trim() : null, context);
if (!browsers) throw new Error("No browserslist config found to handle the 'browserslist' target.\nSee https://github.com/browserslist/browserslist#queries for possible ways to provide a config.\nThe recommended way is to add a 'browserslist' key to your package.json and list supported browsers (resp. node.js versions).\nYou can also more options via the 'target' option: 'browserslist' / 'browserslist:env' / 'browserslist:query' / 'browserslist:path-to-config' / 'browserslist:path-to-config:env'");
return browserslistTargetHandler.resolve(browsers);
} ], [ "web", "Web browser.", /^web$/, () => ({
web: !0,
browser: !0,
webworker: null,
node: !1,
electron: !1,
nwjs: !1,
document: !0,
importScriptsInWorker: !0,
fetchWasm: !0,
nodeBuiltins: !1,
importScripts: !1,
require: !1,
global: !1
}) ], [ "webworker", "Web Worker, SharedWorker or Service Worker.", /^webworker$/, () => ({
web: !0,
browser: !0,
webworker: !0,
node: !1,
electron: !1,
nwjs: !1,
importScripts: !0,
importScriptsInWorker: !0,
fetchWasm: !0,
nodeBuiltins: !1,
require: !1,
document: !1,
global: !1
}) ], [ "[async-]node[X[.Y]]", "Node.js in version X.Y. The 'async-' prefix will load chunks asynchronously via 'fs' and 'vm' instead of 'require()'. Examples: node14.5, async-node10.", /^(async-)?node(\d+(?:\.(\d+))?)?$/, (asyncFlag, major, minor) => {
const v = versionDependent(major, minor);
return {
node: !0,
electron: !1,
nwjs: !1,
web: !1,
webworker: !1,
browser: !1,
require: !asyncFlag,
nodeBuiltins: !0,
global: !0,
document: !1,
fetchWasm: !1,
importScripts: !1,
importScriptsInWorker: !1,
globalThis: v(12),
const: v(6),
templateLiteral: v(4),
optionalChaining: v(14),
arrowFunction: v(6),
forOf: v(5),
destructuring: v(6),
bigIntLiteral: v(10, 4),
dynamicImport: v(12, 17),
dynamicImportInWorker: !major && void 0,
module: v(12, 17)
};
} ], [ "electron[X[.Y]]-main/preload/renderer", "Electron in version X.Y. Script is running in main, preload resp. renderer context.", /^electron(\d+(?:\.(\d+))?)?-(main|preload|renderer)$/, (major, minor, context) => {
const v = versionDependent(major, minor);
return {
node: !0,
electron: !0,
web: "main" !== context,
webworker: !1,
browser: !1,
nwjs: !1,
electronMain: "main" === context,
electronPreload: "preload" === context,
electronRenderer: "renderer" === context,
global: !0,
nodeBuiltins: !0,
require: !0,
document: "renderer" === context,
fetchWasm: "renderer" === context,
importScripts: !1,
importScriptsInWorker: !0,
globalThis: v(5),
const: v(1, 1),
templateLiteral: v(1, 1),
optionalChaining: v(8),
arrowFunction: v(1, 1),
forOf: v(0, 36),
destructuring: v(1, 1),
bigIntLiteral: v(4),
dynamicImport: v(11),
dynamicImportInWorker: !major && void 0,
module: v(11)
};
} ], [ "nwjs[X[.Y]] / node-webkit[X[.Y]]", "NW.js in version X.Y.", /^(?:nwjs|node-webkit)(\d+(?:\.(\d+))?)?$/, (major, minor) => {
const v = versionDependent(major, minor);
return {
node: !0,
web: !0,
nwjs: !0,
webworker: null,
browser: !1,
electron: !1,
global: !0,
nodeBuiltins: !0,
document: !1,
importScriptsInWorker: !1,
fetchWasm: !1,
importScripts: !1,
require: !1,
globalThis: v(0, 43),
const: v(0, 15),
templateLiteral: v(0, 13),
optionalChaining: v(0, 44),
arrowFunction: v(0, 15),
forOf: v(0, 13),
destructuring: v(0, 15),
bigIntLiteral: v(0, 32),
dynamicImport: v(0, 43),
dynamicImportInWorker: !major && void 0,
module: v(0, 43)
};
} ], [ "esX", "EcmaScript in this version. Examples: es2020, es5.", /^es(\d+)$/, version => {
let v = +version;
return v < 1e3 && (v += 2009), {
const: v >= 2015,
templateLiteral: v >= 2015,
optionalChaining: v >= 2020,
arrowFunction: v >= 2015,
forOf: v >= 2015,
destructuring: v >= 2015,
module: v >= 2015,
globalThis: v >= 2020,
bigIntLiteral: v >= 2020,
dynamicImport: v >= 2020,
dynamicImportInWorker: v >= 2020
};
} ] ], getTargetProperties = (target, context) => {
for (const [, , regExp, handler] of TARGETS) {
const match = regExp.exec(target);
if (match) {
const [, ...args] = match, result = handler(...args, context);
if (result) return result;
}
}
throw new Error(`Unknown target '${target}'. The following targets are supported:\n${TARGETS.map((([name, description]) => `* ${name}: ${description}`)).join("\n")}`);
};
exports.getDefaultTarget = context => getBrowserslistTargetHandler().load(null, context) ? "browserslist" : "web", 
exports.getTargetProperties = getTargetProperties, exports.getTargetsProperties = (targets, context) => (targetProperties => {
const keys = new Set;
for (const tp of targetProperties) for (const key of Object.keys(tp)) keys.add(key);
const result = {};
for (const key of keys) {
let hasTrue = !1, hasFalse = !1;
for (const tp of targetProperties) switch (tp[key]) {
case !0:
hasTrue = !0;
break;

case !1:
hasFalse = !0;
}
(hasTrue || hasFalse) && (result[key] = hasFalse && hasTrue ? null : !!hasTrue);
}
return result;
})(targets.map((t => getTargetProperties(t, context))));
},
49545: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898);
class ContainerEntryDependency extends Dependency {
constructor(name, exposes, shareScope) {
super(), this.name = name, this.exposes = exposes, this.shareScope = shareScope;
}
getResourceIdentifier() {
return `container-entry-${this.name}`;
}
get type() {
return "container entry";
}
get category() {
return "esm";
}
}
makeSerializable(ContainerEntryDependency, "webpack/lib/container/ContainerEntryDependency"), 
module.exports = ContainerEntryDependency;
},
63687: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {OriginalSource, RawSource} = __webpack_require__(37946), AsyncDependenciesBlock = __webpack_require__(89353), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), StaticExportsDependency = __webpack_require__(21776), makeSerializable = __webpack_require__(45898), ContainerExposedDependency = __webpack_require__(23693), SOURCE_TYPES = new Set([ "javascript" ]);
class ContainerEntryModule extends Module {
constructor(name, exposes, shareScope) {
super("javascript/dynamic", null), this._name = name, this._exposes = exposes, this._shareScope = shareScope;
}
getSourceTypes() {
return SOURCE_TYPES;
}
identifier() {
return `container entry (${this._shareScope}) ${JSON.stringify(this._exposes)}`;
}
readableIdentifier(requestShortener) {
return "container entry";
}
libIdent(options) {
return `${this.layer ? `(${this.layer})/` : ""}webpack/container/entry/${this._name}`;
}
needBuild(context, callback) {
return callback(null, !this.buildMeta);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {}, this.buildInfo = {
strict: !0,
topLevelDeclarations: new Set([ "moduleMap", "get", "init" ])
}, this.buildMeta.exportsType = "namespace", this.clearDependenciesAndBlocks();
for (const [name, options] of this._exposes) {
const block = new AsyncDependenciesBlock({
name: options.name
}, {
name
}, options.import[options.import.length - 1]);
let idx = 0;
for (const request of options.import) {
const dep = new ContainerExposedDependency(name, request);
dep.loc = {
name,
index: idx++
}, block.addDependency(dep);
}
this.addBlock(block);
}
this.addDependency(new StaticExportsDependency([ "get", "init" ], !1)), callback();
}
codeGeneration({moduleGraph, chunkGraph, runtimeTemplate}) {
const sources = new Map, runtimeRequirements = new Set([ RuntimeGlobals.definePropertyGetters, RuntimeGlobals.hasOwnProperty, RuntimeGlobals.exports ]), getters = [];
for (const block of this.blocks) {
const {dependencies} = block, modules = dependencies.map((dependency => {
const dep = dependency;
return {
name: dep.exposedName,
module: moduleGraph.getModule(dep),
request: dep.userRequest
};
}));
let str;
str = modules.some((m => !m.module)) ? runtimeTemplate.throwMissingModuleErrorBlock({
request: modules.map((m => m.request)).join(", ")
}) : `return ${runtimeTemplate.blockPromise({
block,
message: "",
chunkGraph,
runtimeRequirements
})}.then(${runtimeTemplate.returningFunction(runtimeTemplate.returningFunction(`(${modules.map((({module, request}) => runtimeTemplate.moduleRaw({
module,
chunkGraph,
request,
weak: !1,
runtimeRequirements
}))).join(", ")})`))});`, getters.push(`${JSON.stringify(modules[0].name)}: ${runtimeTemplate.basicFunction("", str)}`);
}
const source = Template.asString([ "var moduleMap = {", Template.indent(getters.join(",\n")), "};", `var get = ${runtimeTemplate.basicFunction("module, getScope", [ `${RuntimeGlobals.currentRemoteGetScope} = getScope;`, "getScope = (", Template.indent([ `${RuntimeGlobals.hasOwnProperty}(moduleMap, module)`, Template.indent([ "? moduleMap[module]()", `: Promise.resolve().then(${runtimeTemplate.basicFunction("", "throw new Error('Module \"' + module + '\" does not exist in container.');")})` ]) ]), ");", `${RuntimeGlobals.currentRemoteGetScope} = undefined;`, "return getScope;" ])};`, `var init = ${runtimeTemplate.basicFunction("shareScope, initScope", [ `if (!${RuntimeGlobals.shareScopeMap}) return;`, `var name = ${JSON.stringify(this._shareScope)}`, `var oldScope = ${RuntimeGlobals.shareScopeMap}[name];`, 'if(oldScope && oldScope !== shareScope) throw new Error("Container initialization failed as it has already been initialized with a different share scope");', `${RuntimeGlobals.shareScopeMap}[name] = shareScope;`, `return ${RuntimeGlobals.initializeSharing}(name, initScope);` ])};`, "", "// This exports getters to disallow modifications", `${RuntimeGlobals.definePropertyGetters}(exports, {`, Template.indent([ `get: ${runtimeTemplate.returningFunction("get")},`, `init: ${runtimeTemplate.returningFunction("init")}` ]), "});" ]);
return sources.set("javascript", this.useSourceMap || this.useSimpleSourceMap ? new OriginalSource(source, "webpack/container-entry") : new RawSource(source)), 
{
sources,
runtimeRequirements
};
}
size(type) {
return 42;
}
serialize(context) {
const {write} = context;
write(this._name), write(this._exposes), write(this._shareScope), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new ContainerEntryModule(read(), read(), read());
return obj.deserialize(context), obj;
}
}
makeSerializable(ContainerEntryModule, "webpack/lib/container/ContainerEntryModule"), 
module.exports = ContainerEntryModule;
},
90333: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleFactory = __webpack_require__(37019), ContainerEntryModule = __webpack_require__(63687);
module.exports = class extends ModuleFactory {
create({dependencies: [dependency]}, callback) {
const dep = dependency;
callback(null, {
module: new ContainerEntryModule(dep.name, dep.exposes, dep.shareScope)
});
}
};
},
23693: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216), makeSerializable = __webpack_require__(45898);
class ContainerExposedDependency extends ModuleDependency {
constructor(exposedName, request) {
super(request), this.exposedName = exposedName;
}
get type() {
return "container exposed";
}
get category() {
return "esm";
}
getResourceIdentifier() {
return `exposed dependency ${this.exposedName}=${this.request}`;
}
serialize(context) {
context.write(this.exposedName), super.serialize(context);
}
deserialize(context) {
this.exposedName = context.read(), super.deserialize(context);
}
}
makeSerializable(ContainerExposedDependency, "webpack/lib/container/ContainerExposedDependency"), 
module.exports = ContainerExposedDependency;
},
6870: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const createSchemaValidation = __webpack_require__(59586), ContainerEntryDependency = __webpack_require__(49545), ContainerEntryModuleFactory = __webpack_require__(90333), ContainerExposedDependency = __webpack_require__(23693), {parseOptions} = __webpack_require__(20912), validate = createSchemaValidation(__webpack_require__(38902), (() => __webpack_require__(93944)), {
name: "Container Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options) {
validate(options), this._options = {
name: options.name,
shareScope: options.shareScope || "default",
library: options.library || {
type: "var",
name: options.name
},
runtime: options.runtime,
filename: options.filename || void 0,
exposes: parseOptions(options.exposes, (item => ({
import: Array.isArray(item) ? item : [ item ],
name: void 0
})), (item => ({
import: Array.isArray(item.import) ? item.import : [ item.import ],
name: item.name || void 0
})))
};
}
apply(compiler) {
const {name, exposes, shareScope, filename, library, runtime} = this._options;
compiler.options.output.enabledLibraryTypes.push(library.type), compiler.hooks.make.tapAsync("ContainerPlugin", ((compilation, callback) => {
const dep = new ContainerEntryDependency(name, exposes, shareScope);
dep.loc = {
name
}, compilation.addEntry(compilation.options.context, dep, {
name,
filename,
runtime,
library
}, (error => {
if (error) return callback(error);
callback();
}));
})), compiler.hooks.thisCompilation.tap("ContainerPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(ContainerEntryDependency, new ContainerEntryModuleFactory), 
compilation.dependencyFactories.set(ContainerExposedDependency, normalModuleFactory);
}));
}
};
},
37033: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ExternalsPlugin = __webpack_require__(29301), RuntimeGlobals = __webpack_require__(50980), createSchemaValidation = __webpack_require__(59586), FallbackDependency = __webpack_require__(34196), FallbackItemDependency = __webpack_require__(60996), FallbackModuleFactory = __webpack_require__(4685), RemoteModule = __webpack_require__(653), RemoteRuntimeModule = __webpack_require__(6217), RemoteToExternalDependency = __webpack_require__(18969), {parseOptions} = __webpack_require__(20912), validate = createSchemaValidation(__webpack_require__(83832), (() => __webpack_require__(38279)), {
name: "Container Reference Plugin",
baseDataPath: "options"
}), slashCode = "/".charCodeAt(0);
module.exports = class {
constructor(options) {
validate(options), this._remoteType = options.remoteType, this._remotes = parseOptions(options.remotes, (item => ({
external: Array.isArray(item) ? item : [ item ],
shareScope: options.shareScope || "default"
})), (item => ({
external: Array.isArray(item.external) ? item.external : [ item.external ],
shareScope: item.shareScope || options.shareScope || "default"
})));
}
apply(compiler) {
const {_remotes: remotes, _remoteType: remoteType} = this, remoteExternals = {};
for (const [key, config] of remotes) {
let i = 0;
for (const external of config.external) external.startsWith("internal ") || (remoteExternals[`webpack/container/reference/${key}${i ? `/fallback-${i}` : ""}`] = external, 
i++);
}
new ExternalsPlugin(remoteType, remoteExternals).apply(compiler), compiler.hooks.compilation.tap("ContainerReferencePlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(RemoteToExternalDependency, normalModuleFactory), 
compilation.dependencyFactories.set(FallbackItemDependency, normalModuleFactory), 
compilation.dependencyFactories.set(FallbackDependency, new FallbackModuleFactory), 
normalModuleFactory.hooks.factorize.tap("ContainerReferencePlugin", (data => {
if (!data.request.includes("!")) for (const [key, config] of remotes) if (data.request.startsWith(`${key}`) && (data.request.length === key.length || data.request.charCodeAt(key.length) === slashCode)) return new RemoteModule(data.request, config.external.map(((external, i) => external.startsWith("internal ") ? external.slice(9) : `webpack/container/reference/${key}${i ? `/fallback-${i}` : ""}`)), `.${data.request.slice(key.length)}`, config.shareScope);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("ContainerReferencePlugin", ((chunk, set) => {
set.add(RuntimeGlobals.module), set.add(RuntimeGlobals.moduleFactoriesAddOnly), 
set.add(RuntimeGlobals.hasOwnProperty), set.add(RuntimeGlobals.initializeSharing), 
set.add(RuntimeGlobals.shareScopeMap), compilation.addRuntimeModule(chunk, new RemoteRuntimeModule);
}));
}));
}
};
},
34196: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898);
class FallbackDependency extends Dependency {
constructor(requests) {
super(), this.requests = requests;
}
getResourceIdentifier() {
return `fallback ${this.requests.join(" ")}`;
}
get type() {
return "fallback";
}
get category() {
return "esm";
}
serialize(context) {
const {write} = context;
write(this.requests), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new FallbackDependency(read());
return obj.deserialize(context), obj;
}
}
makeSerializable(FallbackDependency, "webpack/lib/container/FallbackDependency"), 
module.exports = FallbackDependency;
},
60996: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216), makeSerializable = __webpack_require__(45898);
class FallbackItemDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "fallback item";
}
get category() {
return "esm";
}
}
makeSerializable(FallbackItemDependency, "webpack/lib/container/FallbackItemDependency"), 
module.exports = FallbackItemDependency;
},
35600: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), makeSerializable = __webpack_require__(45898), FallbackItemDependency = __webpack_require__(60996), TYPES = new Set([ "javascript" ]), RUNTIME_REQUIREMENTS = new Set([ RuntimeGlobals.module ]);
class FallbackModule extends Module {
constructor(requests) {
super("fallback-module"), this.requests = requests, this._identifier = `fallback ${this.requests.join(" ")}`;
}
identifier() {
return this._identifier;
}
readableIdentifier(requestShortener) {
return this._identifier;
}
libIdent(options) {
return `${this.layer ? `(${this.layer})/` : ""}webpack/container/fallback/${this.requests[0]}/and ${this.requests.length - 1} more`;
}
chunkCondition(chunk, {chunkGraph}) {
return chunkGraph.getNumberOfEntryModules(chunk) > 0;
}
needBuild(context, callback) {
callback(null, !this.buildInfo);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {}, this.buildInfo = {
strict: !0
}, this.clearDependenciesAndBlocks();
for (const request of this.requests) this.addDependency(new FallbackItemDependency(request));
callback();
}
size(type) {
return 5 * this.requests.length + 42;
}
getSourceTypes() {
return TYPES;
}
codeGeneration({runtimeTemplate, moduleGraph, chunkGraph}) {
const ids = this.dependencies.map((dep => chunkGraph.getModuleId(moduleGraph.getModule(dep)))), code = Template.asString([ `var ids = ${JSON.stringify(ids)};`, "var error, result, i = 0;", `var loop = ${runtimeTemplate.basicFunction("next", [ "while(i < ids.length) {", Template.indent([ "try { next = __webpack_require__(ids[i++]); } catch(e) { return handleError(e); }", "if(next) return next.then ? next.then(handleResult, handleError) : handleResult(next);" ]), "}", "if(error) throw error;" ])}`, `var handleResult = ${runtimeTemplate.basicFunction("result", [ "if(result) return result;", "return loop();" ])};`, `var handleError = ${runtimeTemplate.basicFunction("e", [ "error = e;", "return loop();" ])};`, "module.exports = loop();" ]), sources = new Map;
return sources.set("javascript", new RawSource(code)), {
sources,
runtimeRequirements: RUNTIME_REQUIREMENTS
};
}
serialize(context) {
const {write} = context;
write(this.requests), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new FallbackModule(read());
return obj.deserialize(context), obj;
}
}
makeSerializable(FallbackModule, "webpack/lib/container/FallbackModule"), module.exports = FallbackModule;
},
4685: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleFactory = __webpack_require__(37019), FallbackModule = __webpack_require__(35600);
module.exports = class extends ModuleFactory {
create({dependencies: [dependency]}, callback) {
callback(null, {
module: new FallbackModule(dependency.requests)
});
}
};
},
91509: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const isValidExternalsType = __webpack_require__(9530), SharePlugin = __webpack_require__(5979), createSchemaValidation = __webpack_require__(59586), ContainerPlugin = __webpack_require__(6870), ContainerReferencePlugin = __webpack_require__(37033), validate = createSchemaValidation(__webpack_require__(68979), (() => __webpack_require__(85195)), {
name: "Module Federation Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options) {
validate(options), this._options = options;
}
apply(compiler) {
const {_options: options} = this, library = options.library || {
type: "var",
name: options.name
}, remoteType = options.remoteType || (options.library && isValidExternalsType(options.library.type) ? options.library.type : "script");
library && !compiler.options.output.enabledLibraryTypes.includes(library.type) && compiler.options.output.enabledLibraryTypes.push(library.type), 
compiler.hooks.afterPlugins.tap("ModuleFederationPlugin", (() => {
options.exposes && (Array.isArray(options.exposes) ? options.exposes.length > 0 : Object.keys(options.exposes).length > 0) && new ContainerPlugin({
name: options.name,
library,
filename: options.filename,
runtime: options.runtime,
shareScope: options.shareScope,
exposes: options.exposes
}).apply(compiler), options.remotes && (Array.isArray(options.remotes) ? options.remotes.length > 0 : Object.keys(options.remotes).length > 0) && new ContainerReferencePlugin({
remoteType,
shareScope: options.shareScope,
remotes: options.remotes
}).apply(compiler), options.shared && new SharePlugin({
shared: options.shared,
shareScope: options.shareScope
}).apply(compiler);
}));
}
};
},
653: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), FallbackDependency = __webpack_require__(34196), RemoteToExternalDependency = __webpack_require__(18969), TYPES = new Set([ "remote", "share-init" ]), RUNTIME_REQUIREMENTS = new Set([ RuntimeGlobals.module ]);
class RemoteModule extends Module {
constructor(request, externalRequests, internalRequest, shareScope) {
super("remote-module"), this.request = request, this.externalRequests = externalRequests, 
this.internalRequest = internalRequest, this.shareScope = shareScope, this._identifier = `remote (${shareScope}) ${this.externalRequests.join(" ")} ${this.internalRequest}`;
}
identifier() {
return this._identifier;
}
readableIdentifier(requestShortener) {
return `remote ${this.request}`;
}
libIdent(options) {
return `${this.layer ? `(${this.layer})/` : ""}webpack/container/remote/${this.request}`;
}
needBuild(context, callback) {
callback(null, !this.buildInfo);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {}, this.buildInfo = {
strict: !0
}, this.clearDependenciesAndBlocks(), 1 === this.externalRequests.length ? this.addDependency(new RemoteToExternalDependency(this.externalRequests[0])) : this.addDependency(new FallbackDependency(this.externalRequests)), 
callback();
}
size(type) {
return 6;
}
getSourceTypes() {
return TYPES;
}
nameForCondition() {
return this.request;
}
codeGeneration({runtimeTemplate, moduleGraph, chunkGraph}) {
const module = moduleGraph.getModule(this.dependencies[0]), id = module && chunkGraph.getModuleId(module), sources = new Map;
sources.set("remote", new RawSource(""));
const data = new Map;
return data.set("share-init", [ {
shareScope: this.shareScope,
initStage: 20,
init: void 0 === id ? "" : `initExternal(${JSON.stringify(id)});`
} ]), {
sources,
data,
runtimeRequirements: RUNTIME_REQUIREMENTS
};
}
serialize(context) {
const {write} = context;
write(this.request), write(this.externalRequests), write(this.internalRequest), 
write(this.shareScope), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new RemoteModule(read(), read(), read(), read());
return obj.deserialize(context), obj;
}
}
makeSerializable(RemoteModule, "webpack/lib/container/RemoteModule"), module.exports = RemoteModule;
},
6217: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor() {
super("remotes loading");
}
generate() {
const {compilation, chunkGraph} = this, {runtimeTemplate, moduleGraph} = compilation, chunkToRemotesMapping = {}, idToExternalAndNameMapping = {};
for (const chunk of this.chunk.getAllAsyncChunks()) {
const modules = chunkGraph.getChunkModulesIterableBySourceType(chunk, "remote");
if (!modules) continue;
const remotes = chunkToRemotesMapping[chunk.id] = [];
for (const m of modules) {
const module = m, name = module.internalRequest, id = chunkGraph.getModuleId(module), shareScope = module.shareScope, dep = module.dependencies[0], externalModule = moduleGraph.getModule(dep), externalModuleId = externalModule && chunkGraph.getModuleId(externalModule);
remotes.push(id), idToExternalAndNameMapping[id] = [ shareScope, name, externalModuleId ];
}
}
return Template.asString([ `var chunkMapping = ${JSON.stringify(chunkToRemotesMapping, null, "\t")};`, `var idToExternalAndNameMapping = ${JSON.stringify(idToExternalAndNameMapping, null, "\t")};`, `${RuntimeGlobals.ensureChunkHandlers}.remotes = ${runtimeTemplate.basicFunction("chunkId, promises", [ `if(${RuntimeGlobals.hasOwnProperty}(chunkMapping, chunkId)) {`, Template.indent([ `chunkMapping[chunkId].forEach(${runtimeTemplate.basicFunction("id", [ `var getScope = ${RuntimeGlobals.currentRemoteGetScope};`, "if(!getScope) getScope = [];", "var data = idToExternalAndNameMapping[id];", "if(getScope.indexOf(data) >= 0) return;", "getScope.push(data);", "if(data.p) return promises.push(data.p);", `var onError = ${runtimeTemplate.basicFunction("error", [ 'if(!error) error = new Error("Container missing");', 'if(typeof error.message === "string")', Template.indent("error.message += '\\nwhile loading \"' + data[1] + '\" from ' + data[2];"), `${RuntimeGlobals.moduleFactories}[id] = ${runtimeTemplate.basicFunction("", [ "throw error;" ])}`, "data.p = 0;" ])};`, `var handleFunction = ${runtimeTemplate.basicFunction("fn, arg1, arg2, d, next, first", [ "try {", Template.indent([ "var promise = fn(arg1, arg2);", "if(promise && promise.then) {", Template.indent([ `var p = promise.then(${runtimeTemplate.returningFunction("next(result, d)", "result")}, onError);`, "if(first) promises.push(data.p = p); else return p;" ]), "} else {", Template.indent([ "return next(promise, d, first);" ]), "}" ]), "} catch(error) {", Template.indent([ "onError(error);" ]), "}" ])}`, `var onExternal = ${runtimeTemplate.returningFunction(`external ? handleFunction(${RuntimeGlobals.initializeSharing}, data[0], 0, external, onInitialized, first) : onError()`, "external, _, first")};`, `var onInitialized = ${runtimeTemplate.returningFunction("handleFunction(external.get, data[1], getScope, 0, onFactory, first)", "_, external, first")};`, `var onFactory = ${runtimeTemplate.basicFunction("factory", [ "data.p = 1;", `${RuntimeGlobals.moduleFactories}[id] = ${runtimeTemplate.basicFunction("module", [ "module.exports = factory();" ])}` ])};`, "handleFunction(__webpack_require__, data[2], 0, 0, onExternal, 1);" ])});` ]), "}" ])}` ]);
}
};
},
18969: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216), makeSerializable = __webpack_require__(45898);
class RemoteToExternalDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "remote to external";
}
get category() {
return "esm";
}
}
makeSerializable(RemoteToExternalDependency, "webpack/lib/container/RemoteToExternalDependency"), 
module.exports = RemoteToExternalDependency;
},
20912: (__unused_webpack_module, exports) => {
"use strict";
const process = (options, normalizeSimple, normalizeOptions, fn) => {
const object = obj => {
for (const [key, value] of Object.entries(obj)) "string" == typeof value || Array.isArray(value) ? fn(key, normalizeSimple(value, key)) : fn(key, normalizeOptions(value, key));
};
if (options) if (Array.isArray(options)) (items => {
for (const item of items) if ("string" == typeof item) fn(item, normalizeSimple(item, item)); else {
if (!item || "object" != typeof item) throw new Error("Unexpected options format");
object(item);
}
})(options); else {
if ("object" != typeof options) throw new Error("Unexpected options format");
object(options);
}
};
exports.parseOptions = (options, normalizeSimple, normalizeOptions) => {
const items = [];
return process(options, normalizeSimple, normalizeOptions, ((key, value) => {
items.push([ key, value ]);
})), items;
}, exports.scope = (scope, options) => {
const obj = {};
return process(options, (item => item), (item => item), ((key, value) => {
obj[key.startsWith("./") ? `${scope}${key.slice(1)}` : `${scope}/${key}`] = value;
})), obj;
};
},
37343: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ReplaceSource, RawSource, ConcatSource} = __webpack_require__(37946), {UsageState} = __webpack_require__(74603), Generator = __webpack_require__(70607), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), TYPES = new Set([ "javascript" ]);
module.exports = class extends Generator {
constructor() {
super();
}
generate(module, generateContext) {
const source = new ReplaceSource(new RawSource("")), cssExports = new Map;
generateContext.runtimeRequirements.add(RuntimeGlobals.module);
const runtimeRequirements = new Set, templateContext = {
runtimeTemplate: generateContext.runtimeTemplate,
dependencyTemplates: generateContext.dependencyTemplates,
moduleGraph: generateContext.moduleGraph,
chunkGraph: generateContext.chunkGraph,
module,
runtime: generateContext.runtime,
runtimeRequirements,
concatenationScope: generateContext.concatenationScope,
codeGenerationResults: generateContext.codeGenerationResults,
initFragments: [],
cssExports
};
if (module.dependencies.forEach((dependency => {
const constructor = dependency.constructor, template = generateContext.dependencyTemplates.get(constructor);
if (!template) throw new Error("No template for dependency: " + dependency.constructor.name);
template.apply(dependency, source, templateContext);
})), generateContext.concatenationScope) {
const source = new ConcatSource, usedIdentifiers = new Set;
for (const [k, v] of cssExports) {
let identifier = Template.toIdentifier(k), i = 0;
for (;usedIdentifiers.has(identifier); ) identifier = Template.toIdentifier(k + i);
usedIdentifiers.add(identifier), generateContext.concatenationScope.registerExport(k, identifier), 
source.add(`${generateContext.runtimeTemplate.supportsConst ? "const" : "var"} ${identifier} = ${JSON.stringify(v)};\n`);
}
return source;
}
{
const otherUsed = generateContext.moduleGraph.getExportsInfo(module).otherExportsInfo.getUsed(generateContext.runtime) !== UsageState.Unused;
return otherUsed && generateContext.runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject), 
new RawSource(`${otherUsed ? `${RuntimeGlobals.makeNamespaceObject}(` : ""}${module.moduleArgument}.exports = {\n${Array.from(cssExports, (([k, v]) => `\t${JSON.stringify(k)}: ${JSON.stringify(v)}`)).join(",\n")}\n}${otherUsed ? ")" : ""};`);
}
}
getTypes(module) {
return TYPES;
}
getSize(module, type) {
return 42;
}
updateHash(hash, {module}) {}
};
},
35776: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ReplaceSource} = __webpack_require__(37946), Generator = __webpack_require__(70607), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), TYPES = new Set([ "css" ]);
module.exports = class extends Generator {
constructor() {
super();
}
generate(module, generateContext) {
const originalSource = module.originalSource(), source = new ReplaceSource(originalSource), initFragments = [], cssExports = new Map;
generateContext.runtimeRequirements.add(RuntimeGlobals.hasCssModules);
const templateContext = {
runtimeTemplate: generateContext.runtimeTemplate,
dependencyTemplates: generateContext.dependencyTemplates,
moduleGraph: generateContext.moduleGraph,
chunkGraph: generateContext.chunkGraph,
module,
runtime: generateContext.runtime,
runtimeRequirements: generateContext.runtimeRequirements,
concatenationScope: generateContext.concatenationScope,
codeGenerationResults: generateContext.codeGenerationResults,
initFragments,
cssExports
}, handleDependency = dependency => {
const constructor = dependency.constructor, template = generateContext.dependencyTemplates.get(constructor);
if (!template) throw new Error("No template for dependency: " + dependency.constructor.name);
template.apply(dependency, source, templateContext);
};
if (module.dependencies.forEach(handleDependency), void 0 !== module.presentationalDependencies && module.presentationalDependencies.forEach(handleDependency), 
cssExports.size > 0) {
generateContext.getData().set("css-exports", cssExports);
}
return InitFragment.addToSource(source, initFragments, generateContext);
}
getTypes(module) {
return TYPES;
}
getSize(module, type) {
const originalSource = module.originalSource();
return originalSource ? originalSource.size() : 0;
}
updateHash(hash, {module}) {}
};
},
85934: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook} = __webpack_require__(89991), Compilation = __webpack_require__(62843), RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), compileBooleanMatcher = __webpack_require__(65814), {chunkHasCss} = __webpack_require__(94536), compilationHooksMap = new WeakMap;
class CssLoadingRuntimeModule extends RuntimeModule {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
createStylesheet: new SyncWaterfallHook([ "source", "chunk" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(runtimeRequirements, runtimeOptions) {
super("css loading", 10), this._runtimeRequirements = runtimeRequirements, this.runtimeOptions = runtimeOptions;
}
generate() {
const {compilation, chunk, _runtimeRequirements} = this, {chunkGraph, runtimeTemplate, outputOptions: {crossOriginLoading, uniqueName, chunkLoadTimeout: loadTimeout}} = compilation, fn = RuntimeGlobals.ensureChunkHandlers, conditionMap = chunkGraph.getChunkConditionMap(chunk, ((chunk, chunkGraph) => !!chunkGraph.getChunkModulesIterableBySourceType(chunk, "css"))), hasCssMatcher = compileBooleanMatcher(conditionMap), withLoading = _runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers) && !1 !== hasCssMatcher, withHmr = _runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), initialChunkIdsWithCss = new Set, initialChunkIdsWithoutCss = new Set;
for (const c of chunk.getAllInitialChunks()) (chunkHasCss(c, chunkGraph) ? initialChunkIdsWithCss : initialChunkIdsWithoutCss).add(c.id);
if (!withLoading && !withHmr && 0 === initialChunkIdsWithCss.size) return null;
const {createStylesheet} = CssLoadingRuntimeModule.getCompilationHooks(compilation), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_css` : void 0, code = Template.asString([ "link = document.createElement('link');", uniqueName ? 'link.setAttribute("data-webpack", uniqueName + ":" + key);' : "", "link.setAttribute(loadingAttribute, 1);", 'link.rel = "stylesheet";', "link.href = url;", crossOriginLoading ? "use-credentials" === crossOriginLoading ? 'link.crossOrigin = "use-credentials";' : Template.asString([ "if (link.src.indexOf(window.location.origin + '/') !== 0) {", Template.indent(`link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), "}" ]) : "" ]), cc = str => str.charCodeAt(0);
return Template.asString([ "// object to store loaded and loading chunks", "// undefined = chunk not loaded, null = chunk preloaded/prefetched", "// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded", `var installedChunks = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{${Array.from(initialChunkIdsWithoutCss, (id => `${JSON.stringify(id)}:0`)).join(",")}};`, "", uniqueName ? `var uniqueName = ${JSON.stringify(runtimeTemplate.outputOptions.uniqueName)};` : "// data-webpack is not used as build has no uniqueName", `var loadCssChunkData = ${runtimeTemplate.basicFunction("target, link, chunkId", [ `var data, token = "", token2, exports = {}, exportsWithId = [], exportsWithDashes = [], ${withHmr ? "moduleIds = [], " : ""}i = 0, cc = 1;`, "try { if(!link) link = loadStylesheet(chunkId); data = link.sheet.cssRules; data = data[data.length - 1].style; } catch(e) { data = getComputedStyle(document.head); }", `data = data.getPropertyValue(${uniqueName ? runtimeTemplate.concatenation("--webpack-", {
expr: "uniqueName"
}, "-", {
expr: "chunkId"
}) : runtimeTemplate.concatenation("--webpack-", {
expr: "chunkId"
})});`, "if(!data) return [];", "for(; cc; i++) {", Template.indent([ "cc = data.charCodeAt(i);", `if(cc == ${cc("(")}) { token2 = token; token = ""; }`, `else if(cc == ${cc(")")}) { exports[token2.replace(/^_/, "")] = token.replace(/^_/, ""); token = ""; }`, `else if(cc == ${cc("/")} || cc == ${cc("%")}) { token = token.replace(/^_/, ""); exports[token] = token; exportsWithId.push(token); if(cc == ${cc("%")}) exportsWithDashes.push(token); token = ""; }`, `else if(!cc || cc == ${cc(",")}) { token = token.replace(/^_/, ""); exportsWithId.forEach(${runtimeTemplate.expressionFunction(`exports[x] = ${uniqueName ? runtimeTemplate.concatenation({
expr: "uniqueName"
}, "-", {
expr: "token"
}, "-", {
expr: "exports[x]"
}) : runtimeTemplate.concatenation({
expr: "token"
}, "-", {
expr: "exports[x]"
})}`, "x")}); exportsWithDashes.forEach(${runtimeTemplate.expressionFunction('exports[x] = "--" + exports[x]', "x")}); ${RuntimeGlobals.makeNamespaceObject}(exports); target[token] = (${runtimeTemplate.basicFunction("exports, module", "module.exports = exports;")}).bind(null, exports); ${withHmr ? "moduleIds.push(token); " : ""}token = ""; exports = {}; exportsWithId.length = 0; }`, `else if(cc == ${cc("\\")}) { token += data[++i] }`, "else { token += data[i]; }" ]), "}", (withHmr ? `if(target == ${RuntimeGlobals.moduleFactories}) ` : "") + "installedChunks[chunkId] = 0;", withHmr ? "return moduleIds;" : "" ])}`, 'var loadingAttribute = "data-webpack-loading";', `var loadStylesheet = ${runtimeTemplate.basicFunction("chunkId, url, done" + (withHmr ? ", hmr" : ""), [ 'var link, needAttach, key = "chunk-" + chunkId;', withHmr ? "if(!hmr) {" : "", 'var links = document.getElementsByTagName("link");', "for(var i = 0; i < links.length; i++) {", Template.indent([ "var l = links[i];", `if(l.rel == "stylesheet" && (${withHmr ? 'l.href.startsWith(url) || l.getAttribute("href").startsWith(url)' : 'l.href == url || l.getAttribute("href") == url'}${uniqueName ? ' || l.getAttribute("data-webpack") == uniqueName + ":" + key' : ""})) { link = l; break; }` ]), "}", "if(!done) return link;", withHmr ? "}" : "", "if(!link) {", Template.indent([ "needAttach = true;", createStylesheet.call(code, this.chunk) ]), "}", `var onLinkComplete = ${runtimeTemplate.basicFunction("prev, event", Template.asString([ "link.onerror = link.onload = null;", "link.removeAttribute(loadingAttribute);", "clearTimeout(timeout);", 'if(event && event.type != "load") link.parentNode.removeChild(link)', "done(event);", "if(prev) return prev(event);" ]))};`, "if(link.getAttribute(loadingAttribute)) {", Template.indent([ `var timeout = setTimeout(onLinkComplete.bind(null, undefined, { type: 'timeout', target: link }), ${loadTimeout});`, "link.onerror = onLinkComplete.bind(null, link.onerror);", "link.onload = onLinkComplete.bind(null, link.onload);" ]), "} else onLinkComplete(undefined, { type: 'load', target: link });", withHmr ? "hmr ? document.head.insertBefore(link, hmr) :" : "", "needAttach && document.head.appendChild(link);", "return link;" ])};`, initialChunkIdsWithCss.size > 2 ? `${JSON.stringify(Array.from(initialChunkIdsWithCss))}.forEach(loadCssChunkData.bind(null, ${RuntimeGlobals.moduleFactories}, 0));` : initialChunkIdsWithCss.size > 0 ? `${Array.from(initialChunkIdsWithCss, (id => `loadCssChunkData(${RuntimeGlobals.moduleFactories}, 0, ${JSON.stringify(id)});`)).join("")}` : "// no initial css", "", withLoading ? Template.asString([ `${fn}.css = ${runtimeTemplate.basicFunction("chunkId, promises", [ "// css chunk loading", `var installedChunkData = ${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`, 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent([ "", '// a Promise means "currently loading".', "if(installedChunkData) {", Template.indent([ "promises.push(installedChunkData[2]);" ]), "} else {", Template.indent([ !0 === hasCssMatcher ? "if(true) { // all chunks have CSS" : `if(${hasCssMatcher("chunkId")}) {`, Template.indent([ "// setup Promise in chunk cache", `var promise = new Promise(${runtimeTemplate.expressionFunction("installedChunkData = installedChunks[chunkId] = [resolve, reject]", "resolve, reject")});`, "promises.push(installedChunkData[2] = promise);", "", "// start chunk loading", `var url = ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkCssFilename}(chunkId);`, "// create error before stack unwound to get useful stacktrace later", "var error = new Error();", `var loadingEnded = ${runtimeTemplate.basicFunction("event", [ `if(${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId)) {`, Template.indent([ "installedChunkData = installedChunks[chunkId];", "if(installedChunkData !== 0) installedChunks[chunkId] = undefined;", "if(installedChunkData) {", Template.indent([ 'if(event.type !== "load") {', Template.indent([ "var errorType = event && event.type;", "var realSrc = event && event.target && event.target.src;", "error.message = 'Loading css chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';", "error.name = 'ChunkLoadError';", "error.type = errorType;", "error.request = realSrc;", "installedChunkData[1](error);" ]), "} else {", Template.indent([ `loadCssChunkData(${RuntimeGlobals.moduleFactories}, link, chunkId);`, "installedChunkData[0]();" ]), "}" ]), "}" ]), "}" ])};`, "var link = loadStylesheet(chunkId, url, loadingEnded);" ]), "} else installedChunks[chunkId] = 0;" ]), "}" ]), "}" ])};` ]) : "// no chunk loading", "", withHmr ? Template.asString([ "var oldTags = [];", "var newTags = [];", `var applyHandler = ${runtimeTemplate.basicFunction("options", [ `return { dispose: ${runtimeTemplate.basicFunction("", [])}, apply: ${runtimeTemplate.basicFunction("", [ "var moduleIds = [];", `newTags.forEach(${runtimeTemplate.expressionFunction("info[1].sheet.disabled = false", "info")});`, "while(oldTags.length) {", Template.indent([ "var oldTag = oldTags.pop();", "if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);" ]), "}", "while(newTags.length) {", Template.indent([ "var info = newTags.pop();", `var chunkModuleIds = loadCssChunkData(${RuntimeGlobals.moduleFactories}, info[1], info[0]);`, `chunkModuleIds.forEach(${runtimeTemplate.expressionFunction("moduleIds.push(id)", "id")});` ]), "}", "return moduleIds;" ])} };` ])}`, `var cssTextKey = ${runtimeTemplate.returningFunction(`Array.from(link.sheet.cssRules, ${runtimeTemplate.returningFunction("r.cssText", "r")}).join()`, "link")}`, `${RuntimeGlobals.hmrDownloadUpdateHandlers}.css = ${runtimeTemplate.basicFunction("chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList", [ "applyHandlers.push(applyHandler);", `chunkIds.forEach(${runtimeTemplate.basicFunction("chunkId", [ `var filename = ${RuntimeGlobals.getChunkCssFilename}(chunkId);`, `var url = ${RuntimeGlobals.publicPath} + filename;`, "var oldTag = loadStylesheet(chunkId, url);", "if(!oldTag) return;", `promises.push(new Promise(${runtimeTemplate.basicFunction("resolve, reject", [ `var link = loadStylesheet(chunkId, url + (url.indexOf("?") < 0 ? "?" : "&") + "hmr=" + Date.now(), ${runtimeTemplate.basicFunction("event", [ 'if(event.type !== "load") {', Template.indent([ "var errorType = event && event.type;", "var realSrc = event && event.target && event.target.src;", "error.message = 'Loading css hot update chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';", "error.name = 'ChunkLoadError';", "error.type = errorType;", "error.request = realSrc;", "reject(error);" ]), "} else {", Template.indent([ "try { if(cssTextKey(oldTag) == cssTextKey(link)) { if(link.parentNode) link.parentNode.removeChild(link); return resolve(); } } catch(e) {}", "var factories = {};", "loadCssChunkData(factories, link, chunkId);", `Object.keys(factories).forEach(${runtimeTemplate.expressionFunction("updatedModulesList.push(id)", "id")})`, "link.sheet.disabled = true;", "oldTags.push(oldTag);", "newTags.push([chunkId, link]);", "resolve();" ]), "}" ])}, oldTag);` ])}));` ])});` ])}` ]) : "// no hmr" ]);
}
}
module.exports = CssLoadingRuntimeModule;
},
94536: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), HotUpdateChunk = __webpack_require__(6902), RuntimeGlobals = __webpack_require__(50980), SelfModuleFactory = __webpack_require__(21465), CssExportDependency = __webpack_require__(32037), CssImportDependency = __webpack_require__(55754), CssLocalIdentifierDependency = __webpack_require__(1995), CssSelfLocalIdentifierDependency = __webpack_require__(87027), CssUrlDependency = __webpack_require__(22058), StaticExportsDependency = __webpack_require__(21776), {compareModulesByIdentifier} = __webpack_require__(40028), createSchemaValidation = __webpack_require__(59586), createHash = __webpack_require__(27466), memoize = __webpack_require__(98216), nonNumericOnlyHash = __webpack_require__(23388), CssExportsGenerator = __webpack_require__(37343), CssGenerator = __webpack_require__(35776), CssParser = __webpack_require__(5850), getCssLoadingRuntimeModule = memoize((() => __webpack_require__(85934))), getSchema = name => {
const {definitions} = __webpack_require__(46312);
return {
definitions,
oneOf: [ {
$ref: `#/definitions/${name}`
} ]
};
}, validateGeneratorOptions = createSchemaValidation(__webpack_require__(55391), (() => getSchema("CssGeneratorOptions")), {
name: "Css Modules Plugin",
baseDataPath: "parser"
}), validateParserOptions = createSchemaValidation(__webpack_require__(380), (() => getSchema("CssParserOptions")), {
name: "Css Modules Plugin",
baseDataPath: "parser"
}), escapeCss = (str, omitOptionalUnderscore) => {
const escaped = `${str}`.replace(/[^a-zA-Z0-9_\u0081-\uffff-]/g, (s => `\\${s}`));
return !omitOptionalUnderscore && /^(?!--)[0-9_-]/.test(escaped) ? `_${escaped}` : escaped;
}, plugin = "CssModulesPlugin";
class CssModulesPlugin {
constructor({exportsOnly = !1}) {
this._exportsOnly = exportsOnly;
}
apply(compiler) {
compiler.hooks.compilation.tap(plugin, ((compilation, {normalModuleFactory}) => {
const selfFactory = new SelfModuleFactory(compilation.moduleGraph);
compilation.dependencyFactories.set(CssUrlDependency, normalModuleFactory), compilation.dependencyTemplates.set(CssUrlDependency, new CssUrlDependency.Template), 
compilation.dependencyTemplates.set(CssLocalIdentifierDependency, new CssLocalIdentifierDependency.Template), 
compilation.dependencyFactories.set(CssSelfLocalIdentifierDependency, selfFactory), 
compilation.dependencyTemplates.set(CssSelfLocalIdentifierDependency, new CssSelfLocalIdentifierDependency.Template), 
compilation.dependencyTemplates.set(CssExportDependency, new CssExportDependency.Template), 
compilation.dependencyFactories.set(CssImportDependency, normalModuleFactory), compilation.dependencyTemplates.set(CssImportDependency, new CssImportDependency.Template), 
compilation.dependencyTemplates.set(StaticExportsDependency, new StaticExportsDependency.Template), 
normalModuleFactory.hooks.createParser.for("css").tap(plugin, (parserOptions => (validateParserOptions(parserOptions), 
new CssParser))), normalModuleFactory.hooks.createParser.for("css/global").tap(plugin, (parserOptions => (validateParserOptions(parserOptions), 
new CssParser({
allowPseudoBlocks: !1,
allowModeSwitch: !1
})))), normalModuleFactory.hooks.createParser.for("css/module").tap(plugin, (parserOptions => (validateParserOptions(parserOptions), 
new CssParser({
defaultMode: "local"
})))), normalModuleFactory.hooks.createGenerator.for("css").tap(plugin, (generatorOptions => (validateGeneratorOptions(generatorOptions), 
this._exportsOnly ? new CssExportsGenerator : new CssGenerator))), normalModuleFactory.hooks.createGenerator.for("css/global").tap(plugin, (generatorOptions => (validateGeneratorOptions(generatorOptions), 
this._exportsOnly ? new CssExportsGenerator : new CssGenerator))), normalModuleFactory.hooks.createGenerator.for("css/module").tap(plugin, (generatorOptions => (validateGeneratorOptions(generatorOptions), 
this._exportsOnly ? new CssExportsGenerator : new CssGenerator)));
const orderedCssModulesPerChunk = new WeakMap;
compilation.hooks.afterCodeGeneration.tap("CssModulesPlugin", (() => {
const {chunkGraph} = compilation;
for (const chunk of compilation.chunks) CssModulesPlugin.chunkHasCss(chunk, chunkGraph) && orderedCssModulesPerChunk.set(chunk, this.getOrderedChunkCssModules(chunk, chunkGraph, compilation));
})), compilation.hooks.contentHash.tap("CssModulesPlugin", (chunk => {
const {chunkGraph, outputOptions: {hashSalt, hashDigest, hashDigestLength, hashFunction}} = compilation, modules = orderedCssModulesPerChunk.get(chunk);
if (void 0 === modules) return;
const hash = createHash(hashFunction);
hashSalt && hash.update(hashSalt);
for (const module of modules) hash.update(chunkGraph.getModuleHash(module, chunk.runtime));
const digest = hash.digest(hashDigest);
chunk.contentHash.css = nonNumericOnlyHash(digest, hashDigestLength);
})), compilation.hooks.renderManifest.tap(plugin, ((result, options) => {
const {chunkGraph} = compilation, {hash, chunk, codeGenerationResults} = options;
if (chunk instanceof HotUpdateChunk) return result;
const modules = orderedCssModulesPerChunk.get(chunk);
return void 0 !== modules && result.push({
render: () => this.renderChunk({
chunk,
chunkGraph,
codeGenerationResults,
uniqueName: compilation.outputOptions.uniqueName,
modules
}),
filenameTemplate: CssModulesPlugin.getChunkFilenameTemplate(chunk, compilation.outputOptions),
pathOptions: {
hash,
runtime: chunk.runtime,
chunk,
contentHashType: "css"
},
identifier: `css${chunk.id}`,
hash: chunk.contentHash.css
}), result;
}));
const enabledChunks = new WeakSet, handler = (chunk, set) => {
if (enabledChunks.has(chunk)) return;
enabledChunks.add(chunk), set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.getChunkCssFilename), 
set.add(RuntimeGlobals.hasOwnProperty), set.add(RuntimeGlobals.moduleFactoriesAddOnly), 
set.add(RuntimeGlobals.makeNamespaceObject);
const CssLoadingRuntimeModule = getCssLoadingRuntimeModule();
compilation.addRuntimeModule(chunk, new CssLoadingRuntimeModule(set));
};
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hasCssModules).tap(plugin, handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap(plugin, handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap(plugin, handler);
}));
}
getModulesInOrder(chunk, modules, compilation) {
if (!modules) return [];
const modulesList = [ ...modules ], modulesByChunkGroup = Array.from(chunk.groupsIterable, (chunkGroup => {
const sortedModules = modulesList.map((module => ({
module,
index: chunkGroup.getModulePostOrderIndex(module)
}))).filter((item => void 0 !== item.index)).sort(((a, b) => b.index - a.index)).map((item => item.module));
return {
list: sortedModules,
set: new Set(sortedModules)
};
}));
if (1 === modulesByChunkGroup.length) return modulesByChunkGroup[0].list.reverse();
const compareModuleLists = ({list: a}, {list: b}) => 0 === a.length ? 0 === b.length ? 0 : 1 : 0 === b.length ? -1 : compareModulesByIdentifier(a[a.length - 1], b[b.length - 1]);
modulesByChunkGroup.sort(compareModuleLists);
const finalModules = [];
for (;;) {
const failedModules = new Set, list = modulesByChunkGroup[0].list;
if (0 === list.length) break;
let hasFailed, selectedModule = list[list.length - 1];
outer: for (;;) {
for (const {list, set} of modulesByChunkGroup) {
if (0 === list.length) continue;
const lastModule = list[list.length - 1];
if (lastModule !== selectedModule && set.has(selectedModule)) {
if (failedModules.add(selectedModule), !failedModules.has(lastModule)) {
selectedModule = lastModule, hasFailed = !1;
continue outer;
}
hasFailed = lastModule;
}
}
break;
}
hasFailed && (compilation && compilation.warnings.push(new Error(`chunk ${chunk.name || chunk.id}\nConflicting order between ${hasFailed.readableIdentifier(compilation.requestShortener)} and ${selectedModule.readableIdentifier(compilation.requestShortener)}`)), 
selectedModule = hasFailed), finalModules.push(selectedModule);
for (const {list, set} of modulesByChunkGroup) {
if (list[list.length - 1] === selectedModule) list.pop(); else if (hasFailed && set.has(selectedModule)) {
const idx = list.indexOf(selectedModule);
idx >= 0 && list.splice(idx, 1);
}
}
modulesByChunkGroup.sort(compareModuleLists);
}
return finalModules;
}
getOrderedChunkCssModules(chunk, chunkGraph, compilation) {
return [ ...this.getModulesInOrder(chunk, chunkGraph.getOrderedChunkModulesIterableBySourceType(chunk, "css-import", compareModulesByIdentifier), compilation), ...this.getModulesInOrder(chunk, chunkGraph.getOrderedChunkModulesIterableBySourceType(chunk, "css", compareModulesByIdentifier), compilation) ];
}
renderChunk({uniqueName, chunk, chunkGraph, codeGenerationResults, modules}) {
const source = new ConcatSource, metaData = [];
for (const module of modules) try {
const codeGenResult = codeGenerationResults.get(module, chunk.runtime), s = codeGenResult.sources.get("css") || codeGenResult.sources.get("css-import");
s && (source.add(s), source.add("\n"));
const exports = codeGenResult.data && codeGenResult.data.get("css-exports"), moduleId = chunkGraph.getModuleId(module) + "";
metaData.push(`${exports ? Array.from(exports, (([n, v]) => {
const shortcutValue = `${uniqueName ? uniqueName + "-" : ""}${moduleId}-${n}`;
return v === shortcutValue ? `${escapeCss(n)}/` : v === "--" + shortcutValue ? `${escapeCss(n)}%` : `${escapeCss(n)}(${escapeCss(v)})`;
})).join("") : ""}${escapeCss(moduleId)}`);
} catch (e) {
throw e.message += `\nduring rendering of css ${module.identifier()}`, e;
}
return source.add(`head{--webpack-${escapeCss((uniqueName ? uniqueName + "-" : "") + chunk.id, !0)}:${metaData.join(",")};}`), 
source;
}
static getChunkFilenameTemplate(chunk, outputOptions) {
return chunk.cssFilenameTemplate ? chunk.cssFilenameTemplate : chunk.canBeInitial() ? outputOptions.cssFilename : outputOptions.cssChunkFilename;
}
static chunkHasCss(chunk, chunkGraph) {
return !!chunkGraph.getChunkModulesIterableBySourceType(chunk, "css") || !!chunkGraph.getChunkModulesIterableBySourceType(chunk, "css-import");
}
}
module.exports = CssModulesPlugin;
},
5850: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Parser = __webpack_require__(21475), ConstDependency = __webpack_require__(30339), CssExportDependency = __webpack_require__(32037), CssImportDependency = __webpack_require__(55754), CssLocalIdentifierDependency = __webpack_require__(1995), CssSelfLocalIdentifierDependency = __webpack_require__(87027), CssUrlDependency = __webpack_require__(22058), StaticExportsDependency = __webpack_require__(21776), walkCssTokens = __webpack_require__(82191), CC_LEFT_CURLY = "{".charCodeAt(0), CC_RIGHT_CURLY = "}".charCodeAt(0), CC_COLON = ":".charCodeAt(0), CC_SLASH = "/".charCodeAt(0), CC_SEMICOLON = ";".charCodeAt(0), cssUnescape = str => str.replace(/\\([0-9a-fA-F]{1,6}[ \t\n\r\f]?|[\s\S])/g, (match => match.length > 2 ? String.fromCharCode(parseInt(match.slice(1).trim(), 16)) : match[1]));
class LocConverter {
constructor(input) {
this._input = input, this.line = 1, this.column = 0, this.pos = 0;
}
get(pos) {
if (this.pos !== pos) {
if (this.pos < pos) {
const str = this._input.slice(this.pos, pos);
let i = str.lastIndexOf("\n");
if (-1 === i) this.column += str.length; else for (this.column = str.length - i - 1, 
this.line++; i > 0 && -1 !== (i = str.lastIndexOf("\n", i - 1)); ) this.line++;
} else {
let i = this._input.lastIndexOf("\n", this.pos);
for (;i >= pos; ) this.line--, i = i > 0 ? this._input.lastIndexOf("\n", i - 1) : -1;
this.column = pos - i;
}
this.pos = pos;
}
return this;
}
}
const explainMode = mode => {
switch (mode) {
case 0:
return "parsing top level css";

case 1:
return "parsing css rule content (global)";

case 2:
return "parsing css rule content (local)";

case 3:
return "parsing @import (expecting url)";

case 4:
return "parsing @import (expecting optionally supports or media query)";

case 5:
return "parsing @import (expecting optionally media query)";

case 6:
return "parsing at-rule";

default:
return mode;
}
};
module.exports = class extends Parser {
constructor({allowPseudoBlocks = !0, allowModeSwitch = !0, defaultMode = "global"} = {}) {
super(), this.allowPseudoBlocks = allowPseudoBlocks, this.allowModeSwitch = allowModeSwitch, 
this.defaultMode = defaultMode;
}
parse(source, state) {
if (Buffer.isBuffer(source)) source = source.toString("utf-8"); else if ("object" == typeof source) throw new Error("webpackAst is unexpected for the CssParser");
"\ufeff" === source[0] && (source = source.slice(1));
const module = state.module, declaredCssVariables = new Set, locConverter = new LocConverter(source);
let modeData, singleClassSelector, lastIdentifier, mode = 0, modePos = 0, modeNestingLevel = 0;
const modeStack = [], isTopLevelLocal = () => "local" === modeData || "local" === this.defaultMode && void 0 === modeData, eatWhiteLine = (input, pos) => {
for (;;) {
const cc = input.charCodeAt(pos);
if (32 !== cc && 9 !== cc) {
10 === cc && pos++;
break;
}
pos++;
}
return pos;
}, eatUntil = chars => {
const charCodes = Array.from({
length: chars.length
}, ((_, i) => chars.charCodeAt(i))), arr = Array.from({
length: charCodes.reduce(((a, b) => Math.max(a, b)), 0) + 1
}, (() => !1));
return charCodes.forEach((cc => arr[cc] = !0)), (input, pos) => {
for (;;) {
const cc = input.charCodeAt(pos);
if (cc < arr.length && arr[cc]) return pos;
if (++pos === input.length) return pos;
}
};
}, eatText = (input, pos, eater) => {
let text = "";
for (;;) {
if (input.charCodeAt(pos) === CC_SLASH) {
const newPos = walkCssTokens.eatComments(input, pos);
if (pos !== newPos) {
if ((pos = newPos) === input.length) break;
} else if (text += "/", ++pos === input.length) break;
}
const newPos = eater(input, pos);
if (pos === newPos) break;
if (text += input.slice(pos, newPos), (pos = newPos) === input.length) break;
}
return [ pos, text.trimRight() ];
}, eatExportName = eatUntil(":};/"), eatExportValue = eatUntil("};/"), eatPropertyName = eatUntil(":{};"), processLocalDeclaration = (input, pos) => {
modeData = void 0;
const start = pos, propertyNameStart = pos = walkCssTokens.eatWhitespaceAndComments(input, pos), [propertyNameEnd, propertyName] = eatText(input, pos, eatPropertyName);
if (input.charCodeAt(propertyNameEnd) !== CC_COLON) return start;
if (pos = propertyNameEnd + 1, propertyName.startsWith("--")) {
const {line: sl, column: sc} = locConverter.get(propertyNameStart), {line: el, column: ec} = locConverter.get(propertyNameEnd), name = propertyName.slice(2), dep = new CssLocalIdentifierDependency(name, [ propertyNameStart, propertyNameEnd ], "--");
dep.setLoc(sl, sc, el, ec), module.addDependency(dep), declaredCssVariables.add(name);
} else "animation-name" !== propertyName && "animation" !== propertyName || (modeData = "animation", 
lastIdentifier = void 0);
return pos;
}, processDeclarationValueDone = (input, pos) => {
if ("animation" === modeData && lastIdentifier) {
const {line: sl, column: sc} = locConverter.get(lastIdentifier[0]), {line: el, column: ec} = locConverter.get(lastIdentifier[1]), name = input.slice(lastIdentifier[0], lastIdentifier[1]), dep = new CssSelfLocalIdentifierDependency(name, lastIdentifier);
dep.setLoc(sl, sc, el, ec), module.addDependency(dep);
}
}, eatKeyframes = eatUntil("{};/"), eatNameInVar = eatUntil(",)};/");
return walkCssTokens(source, {
isSelector: () => 1 !== mode && 2 !== mode,
url: (input, start, end, contentStart, contentEnd) => {
const value = cssUnescape(input.slice(contentStart, contentEnd));
switch (mode) {
case 3:
modeData.url = value, mode = 4;
break;

case 4:
case 5:
throw new Error(`Unexpected ${input.slice(start, end)} at ${start} during ${explainMode(mode)}`);

default:
{
const dep = new CssUrlDependency(value, [ start, end ], "url"), {line: sl, column: sc} = locConverter.get(start), {line: el, column: ec} = locConverter.get(end);
dep.setLoc(sl, sc, el, ec), module.addDependency(dep), module.addCodeGenerationDependency(dep);
break;
}
}
return end;
},
string: (input, start, end) => {
if (3 === mode) modeData.url = cssUnescape(input.slice(start + 1, end - 1)), mode = 4;
return end;
},
atKeyword: (input, start, end) => {
const name = input.slice(start, end);
if ("@namespace" === name) throw new Error("@namespace is not supported in bundled CSS");
if ("@import" === name) {
if (0 !== mode) throw new Error(`Unexpected @import at ${start} during ${explainMode(mode)}`);
mode = 3, modePos = end, modeData = {
start,
url: void 0,
supports: void 0
};
}
if ("@keyframes" === name) {
let pos = end;
if (pos = walkCssTokens.eatWhitespaceAndComments(input, pos), pos === input.length) return pos;
const [newPos, name] = eatText(input, pos, eatKeyframes), {line: sl, column: sc} = locConverter.get(pos), {line: el, column: ec} = locConverter.get(newPos), dep = new CssLocalIdentifierDependency(name, [ pos, newPos ]);
if (dep.setLoc(sl, sc, el, ec), module.addDependency(dep), pos = newPos, pos === input.length) return pos;
if (input.charCodeAt(pos) !== CC_LEFT_CURLY) throw new Error(`Unexpected ${input[pos]} at ${pos} during parsing of @keyframes (expected '{')`);
return mode = 2, modeNestingLevel = 1, pos + 1;
}
return end;
},
semicolon: (input, start, end) => {
switch (mode) {
case 3:
throw new Error(`Expected URL for @import at ${start}`);

case 5:
case 4:
{
const {line: sl, column: sc} = locConverter.get(modeData.start), {line: el, column: ec} = locConverter.get(end);
end = eatWhiteLine(input, end);
const media = input.slice(modePos, start).trim(), dep = new CssImportDependency(modeData.url, [ modeData.start, end ], modeData.supports, media);
dep.setLoc(sl, sc, el, ec), module.addDependency(dep);
break;
}

case 2:
return processDeclarationValueDone(input), processLocalDeclaration(input, end);

case 1:
return end;
}
return mode = 0, modeData = void 0, singleClassSelector = void 0, end;
},
leftCurlyBracket: (input, start, end) => {
switch (mode) {
case 0:
if (mode = isTopLevelLocal() ? 2 : 1, modeNestingLevel = 1, 2 === mode) return processLocalDeclaration(input, end);
break;

case 1:
case 2:
modeNestingLevel++;
}
return end;
},
rightCurlyBracket: (input, start, end) => {
switch (mode) {
case 2:
processDeclarationValueDone(input);

case 1:
0 == --modeNestingLevel && (mode = 0, modeData = void 0, singleClassSelector = void 0);
}
return end;
},
id: (input, start, end) => {
if (singleClassSelector = !1, 0 === mode) if (isTopLevelLocal()) {
const name = input.slice(start + 1, end), dep = new CssLocalIdentifierDependency(name, [ start + 1, end ]), {line: sl, column: sc} = locConverter.get(start), {line: el, column: ec} = locConverter.get(end);
dep.setLoc(sl, sc, el, ec), module.addDependency(dep);
}
return end;
},
identifier: (input, start, end) => {
if (singleClassSelector = !1, 2 === mode) "animation" === modeData && (lastIdentifier = [ start, end ]);
return end;
},
class: (input, start, end) => {
if (0 === mode) if (isTopLevelLocal()) {
const name = input.slice(start + 1, end), dep = new CssLocalIdentifierDependency(name, [ start + 1, end ]), {line: sl, column: sc} = locConverter.get(start), {line: el, column: ec} = locConverter.get(end);
dep.setLoc(sl, sc, el, ec), module.addDependency(dep), void 0 === singleClassSelector && (singleClassSelector = name);
} else singleClassSelector = !1;
return end;
},
leftParenthesis: (input, start, end) => {
if (0 === mode) modeStack.push(!1);
return end;
},
rightParenthesis: (input, start, end) => {
switch (mode) {
case 0:
{
const newModeData = modeStack.pop();
if (!1 !== newModeData) {
modeData = newModeData;
const dep = new ConstDependency("", [ start, end ]);
module.addPresentationalDependency(dep);
}
break;
}
}
return end;
},
pseudoClass: (input, start, end) => {
switch (singleClassSelector = !1, mode) {
case 0:
{
const name = input.slice(start, end);
if (this.allowModeSwitch && ":global" === name) {
modeData = "global";
const dep = new ConstDependency("", [ start, end ]);
module.addPresentationalDependency(dep);
} else if (this.allowModeSwitch && ":local" === name) {
modeData = "local";
const dep = new ConstDependency("", [ start, end ]);
module.addPresentationalDependency(dep);
} else if (this.allowPseudoBlocks && ":export" === name) {
const pos = ((input, pos) => {
if (pos = walkCssTokens.eatWhitespaceAndComments(input, pos), input.charCodeAt(pos) !== CC_LEFT_CURLY) throw new Error(`Unexpected ${input[pos]} at ${pos} during parsing of ':export' (expected '{')`);
for (pos++, pos = walkCssTokens.eatWhitespaceAndComments(input, pos); input.charCodeAt(pos) !== CC_RIGHT_CURLY; ) {
if ((pos = walkCssTokens.eatWhitespaceAndComments(input, pos)) === input.length) return pos;
let name, value, start = pos;
if ([pos, name] = eatText(input, pos, eatExportName), pos === input.length) return pos;
if (input.charCodeAt(pos) !== CC_COLON) throw new Error(`Unexpected ${input[pos]} at ${pos} during parsing of export name in ':export' (expected ':')`);
if (++pos === input.length) return pos;
if ((pos = walkCssTokens.eatWhitespaceAndComments(input, pos)) === input.length) return pos;
if ([pos, value] = eatText(input, pos, eatExportValue), pos === input.length) return pos;
const cc = input.charCodeAt(pos);
if (cc === CC_SEMICOLON) {
if (++pos === input.length) return pos;
if ((pos = walkCssTokens.eatWhitespaceAndComments(input, pos)) === input.length) return pos;
} else if (cc !== CC_RIGHT_CURLY) throw new Error(`Unexpected ${input[pos]} at ${pos} during parsing of export value in ':export' (expected ';' or '}')`);
const dep = new CssExportDependency(name, value), {line: sl, column: sc} = locConverter.get(start), {line: el, column: ec} = locConverter.get(pos);
dep.setLoc(sl, sc, el, ec), module.addDependency(dep);
}
return ++pos === input.length ? pos : pos = eatWhiteLine(input, pos);
})(input, end), dep = new ConstDependency("", [ start, pos ]);
return module.addPresentationalDependency(dep), pos;
}
break;
}
}
return end;
},
pseudoFunction: (input, start, end) => {
switch (mode) {
case 0:
{
const name = input.slice(start, end - 1);
if (this.allowModeSwitch && ":global" === name) {
modeStack.push(modeData), modeData = "global";
const dep = new ConstDependency("", [ start, end ]);
module.addPresentationalDependency(dep);
} else if (this.allowModeSwitch && ":local" === name) {
modeStack.push(modeData), modeData = "local";
const dep = new ConstDependency("", [ start, end ]);
module.addPresentationalDependency(dep);
} else modeStack.push(!1);
break;
}
}
return end;
},
function: (input, start, end) => {
switch (mode) {
case 2:
if ("var" === input.slice(start, end - 1)) {
let pos = walkCssTokens.eatWhitespaceAndComments(input, end);
if (pos === input.length) return pos;
const [newPos, name] = eatText(input, pos, eatNameInVar);
if (!name.startsWith("--")) return end;
const {line: sl, column: sc} = locConverter.get(pos), {line: el, column: ec} = locConverter.get(newPos), dep = new CssSelfLocalIdentifierDependency(name.slice(2), [ pos, newPos ], "--", declaredCssVariables);
return dep.setLoc(sl, sc, el, ec), module.addDependency(dep), newPos;
}
break;
}
return end;
},
comma: (input, start, end) => {
switch (mode) {
case 0:
modeData = void 0, modeStack.length = 0;
break;

case 2:
processDeclarationValueDone(input);
}
return end;
}
}), module.buildInfo.strict = !0, module.buildMeta.exportsType = "namespace", module.addDependency(new StaticExportsDependency([], !0)), 
state;
}
};
},
82191: module => {
"use strict";
const CC_LINE_FEED = "\n".charCodeAt(0), CC_CARRIAGE_RETURN = "\r".charCodeAt(0), CC_FORM_FEED = "\f".charCodeAt(0), CC_TAB = "\t".charCodeAt(0), CC_SPACE = " ".charCodeAt(0), CC_SLASH = "/".charCodeAt(0), CC_BACK_SLASH = "\\".charCodeAt(0), CC_ASTERISK = "*".charCodeAt(0), CC_LEFT_PARENTHESIS = "(".charCodeAt(0), CC_RIGHT_PARENTHESIS = ")".charCodeAt(0), CC_LEFT_CURLY = "{".charCodeAt(0), CC_RIGHT_CURLY = "}".charCodeAt(0), CC_QUOTATION_MARK = '"'.charCodeAt(0), CC_APOSTROPHE = "'".charCodeAt(0), CC_FULL_STOP = ".".charCodeAt(0), CC_COLON = ":".charCodeAt(0), CC_SEMICOLON = ";".charCodeAt(0), CC_COMMA = ",".charCodeAt(0), CC_PERCENTAGE = "%".charCodeAt(0), CC_AT_SIGN = "@".charCodeAt(0), CC_LOW_LINE = "_".charCodeAt(0), CC_LOWER_A = "a".charCodeAt(0), CC_LOWER_U = "u".charCodeAt(0), CC_LOWER_E = "e".charCodeAt(0), CC_LOWER_Z = "z".charCodeAt(0), CC_UPPER_A = "A".charCodeAt(0), CC_UPPER_E = "E".charCodeAt(0), CC_UPPER_Z = "Z".charCodeAt(0), CC_0 = "0".charCodeAt(0), CC_9 = "9".charCodeAt(0), CC_NUMBER_SIGN = "#".charCodeAt(0), CC_PLUS_SIGN = "+".charCodeAt(0), CC_HYPHEN_MINUS = "-".charCodeAt(0), CC_LESS_THAN_SIGN = "<".charCodeAt(0), CC_GREATER_THAN_SIGN = ">".charCodeAt(0), _isNewLine = cc => cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED, consumeSpace = (input, pos, callbacks) => {
let cc;
do {
pos++, cc = input.charCodeAt(pos);
} while (_isWhiteSpace(cc));
return pos;
}, _isWhiteSpace = cc => cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED || cc === CC_TAB || cc === CC_SPACE, consumeSingleCharToken = (input, pos, callbacks) => pos + 1, consumePotentialComment = (input, pos, callbacks) => {
if (++pos === input.length) return pos;
let cc = input.charCodeAt(pos);
if (cc !== CC_ASTERISK) return pos;
for (;;) {
if (++pos === input.length) return pos;
for (cc = input.charCodeAt(pos); cc === CC_ASTERISK; ) {
if (++pos === input.length) return pos;
if (cc = input.charCodeAt(pos), cc === CC_SLASH) return pos + 1;
}
}
}, _consumeString = (input, pos, end) => {
for (pos++; ;) {
if (pos === input.length) return pos;
const cc = input.charCodeAt(pos);
if (cc === end) return pos + 1;
if (_isNewLine(cc)) return pos;
if (cc === CC_BACK_SLASH) {
if (++pos === input.length) return pos;
pos++;
} else pos++;
}
}, _isIdentifierStartCode = cc => cc === CC_LOW_LINE || cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z || cc > 128, _isDigit = cc => cc >= CC_0 && cc <= CC_9, _startsIdentifier = (input, pos) => {
const cc = input.charCodeAt(pos);
if (cc === CC_HYPHEN_MINUS) {
if (pos === input.length) return !1;
const cc = input.charCodeAt(pos + 1);
if (cc === CC_HYPHEN_MINUS) return !0;
if (cc === CC_BACK_SLASH) {
const cc = input.charCodeAt(pos + 2);
return !_isNewLine(cc);
}
return _isIdentifierStartCode(cc);
}
if (cc === CC_BACK_SLASH) {
const cc = input.charCodeAt(pos + 1);
return !_isNewLine(cc);
}
return _isIdentifierStartCode(cc);
}, consumeNumberSign = (input, pos, callbacks) => {
const start = pos;
return ++pos === input.length ? pos : callbacks.isSelector(input, pos) && _startsIdentifier(input, pos) && (pos = _consumeIdentifier(input, pos), 
void 0 !== callbacks.id) ? callbacks.id(input, start, pos) : pos;
}, consumeMinus = (input, pos, callbacks) => {
const start = pos;
if (++pos === input.length) return pos;
const cc = input.charCodeAt(pos);
if (cc === CC_FULL_STOP || _isDigit(cc)) return consumeNumericToken(input, pos, callbacks);
if (cc === CC_HYPHEN_MINUS) {
if (++pos === input.length) return pos;
if (input.charCodeAt(pos) === CC_GREATER_THAN_SIGN) return pos + 1;
if (pos = _consumeIdentifier(input, pos), void 0 !== callbacks.identifier) return callbacks.identifier(input, start, pos);
} else if (cc === CC_BACK_SLASH) {
if (pos + 1 === input.length) return pos;
const cc = input.charCodeAt(pos + 1);
if (_isNewLine(cc)) return pos;
if (pos = _consumeIdentifier(input, pos), void 0 !== callbacks.identifier) return callbacks.identifier(input, start, pos);
} else if (_isIdentifierStartCode(cc) && (pos++, pos = _consumeIdentifier(input, pos), 
void 0 !== callbacks.identifier)) return callbacks.identifier(input, start, pos);
return pos;
}, consumeDot = (input, pos, callbacks) => {
const start = pos;
if (++pos === input.length) return pos;
const cc = input.charCodeAt(pos);
return _isDigit(cc) ? consumeNumericToken(input, pos - 2, callbacks) : callbacks.isSelector(input, pos) && _startsIdentifier(input, pos) ? (pos = _consumeIdentifier(input, pos), 
void 0 !== callbacks.class ? callbacks.class(input, start, pos) : pos) : pos;
}, consumeNumericToken = (input, pos, callbacks) => {
if ((pos = _consumeNumber(input, pos)) === input.length) return pos;
if (_startsIdentifier(input, pos)) return _consumeIdentifier(input, pos);
return input.charCodeAt(pos) === CC_PERCENTAGE ? pos + 1 : pos;
}, consumeOtherIdentifier = (input, pos, callbacks) => {
const start = pos;
if ((pos = _consumeIdentifier(input, pos)) === input.length || callbacks.isSelector(input, pos) || input.charCodeAt(pos) !== CC_LEFT_PARENTHESIS) {
if (void 0 !== callbacks.identifier) return callbacks.identifier(input, start, pos);
} else if (pos++, void 0 !== callbacks.function) return callbacks.function(input, start, pos);
return pos;
}, consumePotentialUrl = (input, pos, callbacks) => {
const start = pos;
if ((pos = _consumeIdentifier(input, pos)) !== start + 3 || "url(" !== input.slice(start, pos + 1)) return void 0 !== callbacks.identifier ? callbacks.identifier(input, start, pos) : pos;
{
pos++;
let cc = input.charCodeAt(pos);
for (;_isWhiteSpace(cc); ) {
if (++pos === input.length) return pos;
cc = input.charCodeAt(pos);
}
if (cc === CC_QUOTATION_MARK || cc === CC_APOSTROPHE) {
const contentStart = ++pos, contentEnd = (pos = _consumeString(input, pos, cc)) - 1;
for (cc = input.charCodeAt(pos); _isWhiteSpace(cc); ) {
if (++pos === input.length) return pos;
cc = input.charCodeAt(pos);
}
return cc !== CC_RIGHT_PARENTHESIS ? pos : (pos++, void 0 !== callbacks.url ? callbacks.url(input, start, pos, contentStart, contentEnd) : pos);
}
{
const contentStart = pos;
let contentEnd;
for (;;) {
if (cc === CC_BACK_SLASH) {
if (++pos === input.length) return pos;
pos++;
} else {
if (_isWhiteSpace(cc)) {
contentEnd = pos;
do {
if (++pos === input.length) return pos;
cc = input.charCodeAt(pos);
} while (_isWhiteSpace(cc));
return cc !== CC_RIGHT_PARENTHESIS ? pos : (pos++, void 0 !== callbacks.url ? callbacks.url(input, start, pos, contentStart, contentEnd) : pos);
}
if (cc === CC_RIGHT_PARENTHESIS) return contentEnd = pos, pos++, void 0 !== callbacks.url ? callbacks.url(input, start, pos, contentStart, contentEnd) : pos;
if (cc === CC_LEFT_PARENTHESIS) return pos;
pos++;
}
if (pos === input.length) return pos;
cc = input.charCodeAt(pos);
}
}
}
}, consumePotentialPseudo = (input, pos, callbacks) => {
const start = pos;
if (pos++, !callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos)) return pos;
return pos = _consumeIdentifier(input, pos), input.charCodeAt(pos) === CC_LEFT_PARENTHESIS ? (pos++, 
void 0 !== callbacks.pseudoFunction ? callbacks.pseudoFunction(input, start, pos) : pos) : void 0 !== callbacks.pseudoClass ? callbacks.pseudoClass(input, start, pos) : pos;
}, consumeLeftParenthesis = (input, pos, callbacks) => (pos++, void 0 !== callbacks.leftParenthesis ? callbacks.leftParenthesis(input, pos - 1, pos) : pos), consumeRightParenthesis = (input, pos, callbacks) => (pos++, 
void 0 !== callbacks.rightParenthesis ? callbacks.rightParenthesis(input, pos - 1, pos) : pos), consumeLeftCurlyBracket = (input, pos, callbacks) => (pos++, 
void 0 !== callbacks.leftCurlyBracket ? callbacks.leftCurlyBracket(input, pos - 1, pos) : pos), consumeRightCurlyBracket = (input, pos, callbacks) => (pos++, 
void 0 !== callbacks.rightCurlyBracket ? callbacks.rightCurlyBracket(input, pos - 1, pos) : pos), consumeSemicolon = (input, pos, callbacks) => (pos++, 
void 0 !== callbacks.semicolon ? callbacks.semicolon(input, pos - 1, pos) : pos), consumeComma = (input, pos, callbacks) => (pos++, 
void 0 !== callbacks.comma ? callbacks.comma(input, pos - 1, pos) : pos), _consumeIdentifier = (input, pos) => {
for (;;) {
const cc = input.charCodeAt(pos);
if (cc === CC_BACK_SLASH) {
if (++pos === input.length) return pos;
pos++;
} else {
if (!_isIdentifierStartCode(cc) && !_isDigit(cc) && cc !== CC_HYPHEN_MINUS) return pos;
pos++;
}
}
}, _consumeNumber = (input, pos) => {
if (++pos === input.length) return pos;
let cc = input.charCodeAt(pos);
for (;_isDigit(cc); ) {
if (++pos === input.length) return pos;
cc = input.charCodeAt(pos);
}
if (cc === CC_FULL_STOP && pos + 1 !== input.length) {
const next = input.charCodeAt(pos + 1);
if (_isDigit(next)) for (pos += 2, cc = input.charCodeAt(pos); _isDigit(cc); ) {
if (++pos === input.length) return pos;
cc = input.charCodeAt(pos);
}
}
if (cc !== CC_LOWER_E && cc !== CC_UPPER_E) return pos;
if (pos + 1 !== input.length) {
const next = input.charCodeAt(pos + 2);
if (_isDigit(next)) pos += 2; else {
if (next !== CC_HYPHEN_MINUS && next !== CC_PLUS_SIGN || pos + 2 === input.length) return pos;
{
const next = input.charCodeAt(pos + 2);
if (!_isDigit(next)) return pos;
pos += 3;
}
}
}
for (cc = input.charCodeAt(pos); _isDigit(cc); ) {
if (++pos === input.length) return pos;
cc = input.charCodeAt(pos);
}
return pos;
}, consumeLessThan = (input, pos, callbacks) => "!--" === input.slice(pos + 1, pos + 4) ? pos + 4 : pos + 1, consumeAt = (input, pos, callbacks) => {
const start = pos;
return ++pos === input.length || _startsIdentifier(input, pos) && (pos = _consumeIdentifier(input, pos), 
void 0 !== callbacks.atKeyword && (pos = callbacks.atKeyword(input, start, pos))), 
pos;
}, CHAR_MAP = Array.from({
length: 128
}, ((_, cc) => {
switch (cc) {
case CC_LINE_FEED:
case CC_CARRIAGE_RETURN:
case CC_FORM_FEED:
case CC_TAB:
case CC_SPACE:
return consumeSpace;

case CC_QUOTATION_MARK:
case CC_APOSTROPHE:
return end = cc, (input, pos, callbacks) => {
const start = pos;
return pos = _consumeString(input, pos, end), void 0 !== callbacks.string && (pos = callbacks.string(input, start, pos)), 
pos;
};

case CC_NUMBER_SIGN:
return consumeNumberSign;

case CC_SLASH:
return consumePotentialComment;

case CC_COMMA:
return consumeComma;

case CC_SEMICOLON:
return consumeSemicolon;

case CC_LEFT_PARENTHESIS:
return consumeLeftParenthesis;

case CC_RIGHT_PARENTHESIS:
return consumeRightParenthesis;

case CC_LEFT_CURLY:
return consumeLeftCurlyBracket;

case CC_RIGHT_CURLY:
return consumeRightCurlyBracket;

case CC_COLON:
return consumePotentialPseudo;

case CC_PLUS_SIGN:
return consumeNumericToken;

case CC_FULL_STOP:
return consumeDot;

case CC_HYPHEN_MINUS:
return consumeMinus;

case CC_LESS_THAN_SIGN:
return consumeLessThan;

case CC_AT_SIGN:
return consumeAt;

case CC_LOWER_U:
return consumePotentialUrl;

case CC_LOW_LINE:
return consumeOtherIdentifier;

default:
return _isDigit(cc) ? consumeNumericToken : cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z ? consumeOtherIdentifier : consumeSingleCharToken;
}
var end;
}));
module.exports = (input, callbacks) => {
let pos = 0;
for (;pos < input.length; ) {
const cc = input.charCodeAt(pos);
cc < 128 ? pos = CHAR_MAP[cc](input, pos, callbacks) : pos++;
}
}, module.exports.eatComments = (input, pos) => {
loop: for (;;) {
if (input.charCodeAt(pos) === CC_SLASH) {
if (pos === input.length) return pos;
let cc = input.charCodeAt(pos + 1);
if (cc !== CC_ASTERISK) return pos;
for (pos++; ;) {
if (++pos === input.length) return pos;
for (cc = input.charCodeAt(pos); cc === CC_ASTERISK; ) {
if (++pos === input.length) return pos;
if (cc = input.charCodeAt(pos), cc === CC_SLASH) {
pos++;
continue loop;
}
}
}
}
return pos;
}
}, module.exports.eatWhitespaceAndComments = (input, pos) => {
loop: for (;;) {
const cc = input.charCodeAt(pos);
if (cc === CC_SLASH) {
if (pos === input.length) return pos;
let cc = input.charCodeAt(pos + 1);
if (cc !== CC_ASTERISK) return pos;
for (pos++; ;) {
if (++pos === input.length) return pos;
for (cc = input.charCodeAt(pos); cc === CC_ASTERISK; ) {
if (++pos === input.length) return pos;
if (cc = input.charCodeAt(pos), cc === CC_SLASH) {
pos++;
continue loop;
}
}
}
} else if (_isWhiteSpace(cc)) {
pos++;
continue;
}
return pos;
}
};
},
17678: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {Tracer} = __webpack_require__(6391), createSchemaValidation = __webpack_require__(59586), {dirname, mkdirpSync} = __webpack_require__(57075), validate = createSchemaValidation(__webpack_require__(15919), (() => __webpack_require__(78555)), {
name: "Profiling Plugin",
baseDataPath: "options"
});
let inspector;
try {
inspector = __webpack_require__(31405);
} catch (e) {
console.log("Unable to CPU profile in < node 8.0");
}
class Profiler {
constructor(inspector) {
this.session = void 0, this.inspector = inspector, this._startTime = 0;
}
hasSession() {
return void 0 !== this.session;
}
startProfiling() {
if (void 0 === this.inspector) return Promise.resolve();
try {
this.session = new inspector.Session, this.session.connect();
} catch (_) {
return this.session = void 0, Promise.resolve();
}
const hrtime = process.hrtime();
return this._startTime = 1e6 * hrtime[0] + Math.round(hrtime[1] / 1e3), Promise.all([ this.sendCommand("Profiler.setSamplingInterval", {
interval: 100
}), this.sendCommand("Profiler.enable"), this.sendCommand("Profiler.start") ]);
}
sendCommand(method, params) {
return this.hasSession() ? new Promise(((res, rej) => this.session.post(method, params, ((err, params) => {
null !== err ? rej(err) : res(params);
})))) : Promise.resolve();
}
destroy() {
return this.hasSession() && this.session.disconnect(), Promise.resolve();
}
stopProfiling() {
return this.sendCommand("Profiler.stop").then((({profile}) => {
const hrtime = process.hrtime(), endTime = 1e6 * hrtime[0] + Math.round(hrtime[1] / 1e3);
if (profile.startTime < this._startTime || profile.endTime > endTime) {
const duration = profile.endTime - profile.startTime, ownDuration = endTime - this._startTime, untracked = Math.max(0, ownDuration - duration);
profile.startTime = this._startTime + untracked / 2, profile.endTime = endTime - untracked / 2;
}
return {
profile
};
}));
}
}
const interceptAllHooksFor = (instance, tracer, logLabel) => {
Reflect.has(instance, "hooks") && Object.keys(instance.hooks).forEach((hookName => {
const hook = instance.hooks[hookName];
hook && !hook._fakeHook && hook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));
}));
}, interceptAllParserHooks = (moduleFactory, tracer) => {
[ "javascript/auto", "javascript/dynamic", "javascript/esm", "json", "webassembly/async", "webassembly/sync" ].forEach((moduleType => {
moduleFactory.hooks.parser.for(moduleType).tap("ProfilingPlugin", ((parser, parserOpts) => {
interceptAllHooksFor(parser, tracer, "Parser");
}));
}));
}, interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {
interceptAllHooksFor({
hooks: __webpack_require__(18362).getCompilationHooks(compilation)
}, tracer, "JavascriptModulesPlugin");
}, makeInterceptorFor = (instance, tracer) => hookName => ({
register: tapInfo => {
const {name, type, fn} = tapInfo, newFn = "ProfilingPlugin" === name ? fn : makeNewProfiledTapFn(hookName, tracer, {
name,
type,
fn
});
return {
...tapInfo,
fn: newFn
};
}
}), makeNewProfiledTapFn = (hookName, tracer, {name, type, fn}) => {
const defaultCategory = [ "blink.user_timing" ];
switch (type) {
case "promise":
return (...args) => {
const id = ++tracer.counter;
tracer.trace.begin({
name,
id,
cat: defaultCategory
});
return fn(...args).then((r => (tracer.trace.end({
name,
id,
cat: defaultCategory
}), r)));
};

case "async":
return (...args) => {
const id = ++tracer.counter;
tracer.trace.begin({
name,
id,
cat: defaultCategory
});
const callback = args.pop();
fn(...args, ((...r) => {
tracer.trace.end({
name,
id,
cat: defaultCategory
}), callback(...r);
}));
};

case "sync":
return (...args) => {
const id = ++tracer.counter;
if ("ProfilingPlugin" === name) return fn(...args);
let r;
tracer.trace.begin({
name,
id,
cat: defaultCategory
});
try {
r = fn(...args);
} catch (error) {
throw tracer.trace.end({
name,
id,
cat: defaultCategory
}), error;
}
return tracer.trace.end({
name,
id,
cat: defaultCategory
}), r;
};
}
};
module.exports = class {
constructor(options = {}) {
validate(options), this.outputPath = options.outputPath || "events.json";
}
apply(compiler) {
const tracer = ((fs, outputPath) => {
const trace = new Tracer, profiler = new Profiler(inspector);
if (/\/|\\/.test(outputPath)) {
const dirPath = dirname(fs, outputPath);
mkdirpSync(fs, dirPath);
}
const fsStream = fs.createWriteStream(outputPath);
let counter = 0;
return trace.pipe(fsStream), trace.instantEvent({
name: "TracingStartedInPage",
id: ++counter,
cat: [ "disabled-by-default-devtools.timeline" ],
args: {
data: {
sessionId: "-1",
page: "0xfff",
frames: [ {
frame: "0xfff",
url: "webpack",
name: ""
} ]
}
}
}), trace.instantEvent({
name: "TracingStartedInBrowser",
id: ++counter,
cat: [ "disabled-by-default-devtools.timeline" ],
args: {
data: {
sessionId: "-1"
}
}
}), {
trace,
counter: 2,
profiler,
end: callback => {
trace.push("]"), fsStream.on("close", (() => {
callback();
})), trace.push(null);
}
};
})(compiler.intermediateFileSystem, this.outputPath);
tracer.profiler.startProfiling(), Object.keys(compiler.hooks).forEach((hookName => {
const hook = compiler.hooks[hookName];
hook && hook.intercept(makeInterceptorFor("Compiler", tracer)(hookName));
})), Object.keys(compiler.resolverFactory.hooks).forEach((hookName => {
const hook = compiler.resolverFactory.hooks[hookName];
hook && hook.intercept(makeInterceptorFor("Resolver", tracer)(hookName));
})), compiler.hooks.compilation.tap("ProfilingPlugin", ((compilation, {normalModuleFactory, contextModuleFactory}) => {
interceptAllHooksFor(compilation, tracer, "Compilation"), interceptAllHooksFor(normalModuleFactory, tracer, "Normal Module Factory"), 
interceptAllHooksFor(contextModuleFactory, tracer, "Context Module Factory"), interceptAllParserHooks(normalModuleFactory, tracer), 
interceptAllJavascriptModulesPluginHooks(compilation, tracer);
})), compiler.hooks.done.tapAsync({
name: "ProfilingPlugin",
stage: 1 / 0
}, ((stats, callback) => {
if (compiler.watchMode) return callback();
tracer.profiler.stopProfiling().then((parsedResults => {
if (void 0 === parsedResults) return tracer.profiler.destroy(), void tracer.end(callback);
const cpuStartTime = parsedResults.profile.startTime, cpuEndTime = parsedResults.profile.endTime;
tracer.trace.completeEvent({
name: "TaskQueueManager::ProcessTaskFromWorkQueue",
id: ++tracer.counter,
cat: [ "toplevel" ],
ts: cpuStartTime,
args: {
src_file: "../../ipc/ipc_moji_bootstrap.cc",
src_func: "Accept"
}
}), tracer.trace.completeEvent({
name: "EvaluateScript",
id: ++tracer.counter,
cat: [ "devtools.timeline" ],
ts: cpuStartTime,
dur: cpuEndTime - cpuStartTime,
args: {
data: {
url: "webpack",
lineNumber: 1,
columnNumber: 1,
frame: "0xFFF"
}
}
}), tracer.trace.instantEvent({
name: "CpuProfile",
id: ++tracer.counter,
cat: [ "disabled-by-default-devtools.timeline" ],
ts: cpuEndTime,
args: {
data: {
cpuProfile: parsedResults.profile
}
}
}), tracer.profiler.destroy(), tracer.end(callback);
}));
}));
}
}, module.exports.Profiler = Profiler;
},
80147: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649), DEFINITIONS = {
f: {
definition: "var __WEBPACK_AMD_DEFINE_RESULT__;",
content: "!(__WEBPACK_AMD_DEFINE_RESULT__ = (#).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))",
requests: [ RuntimeGlobals.require, RuntimeGlobals.exports, RuntimeGlobals.module ]
},
o: {
definition: "",
content: "!(module.exports = #)",
requests: [ RuntimeGlobals.module ]
},
of: {
definition: "var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;",
content: "!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))",
requests: [ RuntimeGlobals.require, RuntimeGlobals.exports, RuntimeGlobals.module ]
},
af: {
definition: "var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",
content: "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = (#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))",
requests: [ RuntimeGlobals.exports, RuntimeGlobals.module ]
},
ao: {
definition: "",
content: "!(#, module.exports = #)",
requests: [ RuntimeGlobals.module ]
},
aof: {
definition: "var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;",
content: "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))",
requests: [ RuntimeGlobals.exports, RuntimeGlobals.module ]
},
lf: {
definition: "var XXX, XXXmodule;",
content: "!(XXXmodule = { id: YYY, exports: {}, loaded: false }, XXX = (#).call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule), XXXmodule.loaded = true, XXX === undefined && (XXX = XXXmodule.exports))",
requests: [ RuntimeGlobals.require, RuntimeGlobals.module ]
},
lo: {
definition: "var XXX;",
content: "!(XXX = #)",
requests: []
},
lof: {
definition: "var XXX, XXXfactory, XXXmodule;",
content: "!(XXXfactory = (#), (typeof XXXfactory === 'function' ? ((XXXmodule = { id: YYY, exports: {}, loaded: false }), (XXX = XXXfactory.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule)), (XXXmodule.loaded = true), XXX === undefined && (XXX = XXXmodule.exports)) : XXX = XXXfactory))",
requests: [ RuntimeGlobals.require, RuntimeGlobals.module ]
},
laf: {
definition: "var __WEBPACK_AMD_DEFINE_ARRAY__, XXX, XXXexports;",
content: "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = (#).apply(XXXexports = {}, __WEBPACK_AMD_DEFINE_ARRAY__), XXX === undefined && (XXX = XXXexports))",
requests: []
},
lao: {
definition: "var XXX;",
content: "!(#, XXX = #)",
requests: []
},
laof: {
definition: "var XXXarray, XXXfactory, XXXexports, XXX;",
content: "!(XXXarray = #, XXXfactory = (#),\n\t\t(typeof XXXfactory === 'function' ?\n\t\t\t((XXX = XXXfactory.apply(XXXexports = {}, XXXarray)), XXX === undefined && (XXX = XXXexports)) :\n\t\t\t(XXX = XXXfactory)\n\t\t))",
requests: []
}
};
class AMDDefineDependency extends NullDependency {
constructor(range, arrayRange, functionRange, objectRange, namedModule) {
super(), this.range = range, this.arrayRange = arrayRange, this.functionRange = functionRange, 
this.objectRange = objectRange, this.namedModule = namedModule, this.localModule = null;
}
get type() {
return "amd define";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.arrayRange), write(this.functionRange), write(this.objectRange), 
write(this.namedModule), write(this.localModule), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.arrayRange = read(), this.functionRange = read(), this.objectRange = read(), 
this.namedModule = read(), this.localModule = read(), super.deserialize(context);
}
}
makeSerializable(AMDDefineDependency, "webpack/lib/dependencies/AMDDefineDependency"), 
AMDDefineDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeRequirements}) {
const dep = dependency, branch = this.branch(dep), {definition, content, requests} = DEFINITIONS[branch];
for (const req of requests) runtimeRequirements.add(req);
this.replace(dep, source, definition, content);
}
localModuleVar(dependency) {
return dependency.localModule && dependency.localModule.used && dependency.localModule.variableName();
}
branch(dependency) {
return (this.localModuleVar(dependency) ? "l" : "") + (dependency.arrayRange ? "a" : "") + (dependency.objectRange ? "o" : "") + (dependency.functionRange ? "f" : "");
}
replace(dependency, source, definition, text) {
const localModuleVar = this.localModuleVar(dependency);
localModuleVar && (text = text.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$")), 
definition = definition.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"))), 
dependency.namedModule && (text = text.replace(/YYY/g, JSON.stringify(dependency.namedModule)));
const texts = text.split("#");
definition && source.insert(0, definition);
let current = dependency.range[0];
if (dependency.arrayRange && (source.replace(current, dependency.arrayRange[0] - 1, texts.shift()), 
current = dependency.arrayRange[1]), dependency.objectRange ? (source.replace(current, dependency.objectRange[0] - 1, texts.shift()), 
current = dependency.objectRange[1]) : dependency.functionRange && (source.replace(current, dependency.functionRange[0] - 1, texts.shift()), 
current = dependency.functionRange[1]), source.replace(current, dependency.range[1] - 1, texts.shift()), 
texts.length > 0) throw new Error("Implementation error");
}
}, module.exports = AMDDefineDependency;
},
51930: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), AMDDefineDependency = __webpack_require__(80147), AMDRequireArrayDependency = __webpack_require__(98773), AMDRequireContextDependency = __webpack_require__(35974), AMDRequireItemDependency = __webpack_require__(39744), ConstDependency = __webpack_require__(30339), ContextDependencyHelpers = __webpack_require__(52963), DynamicExports = __webpack_require__(78722), LocalModuleDependency = __webpack_require__(7306), {addLocalModule, getLocalModule} = __webpack_require__(81603), isBoundFunctionExpression = expr => "CallExpression" === expr.type && ("MemberExpression" === expr.callee.type && (!expr.callee.computed && ("FunctionExpression" === expr.callee.object.type && ("Identifier" === expr.callee.property.type && "bind" === expr.callee.property.name)))), isUnboundFunctionExpression = expr => "FunctionExpression" === expr.type || "ArrowFunctionExpression" === expr.type, isCallable = expr => !!isUnboundFunctionExpression(expr) || !!isBoundFunctionExpression(expr);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(parser) {
parser.hooks.call.for("define").tap("AMDDefineDependencyParserPlugin", this.processCallDefine.bind(this, parser));
}
processArray(parser, expr, param, identifiers, namedModule) {
if (param.isArray()) return param.items.forEach(((param, idx) => {
param.isString() && [ "require", "module", "exports" ].includes(param.string) && (identifiers[idx] = param.string);
void 0 === this.processItem(parser, expr, param, namedModule) && this.processContext(parser, expr, param);
})), !0;
if (param.isConstArray()) {
const deps = [];
param.array.forEach(((request, idx) => {
let dep, localModule;
"require" === request ? (identifiers[idx] = request, dep = "__webpack_require__") : [ "exports", "module" ].includes(request) ? (identifiers[idx] = request, 
dep = request) : (localModule = getLocalModule(parser.state, request)) ? (localModule.flagUsed(), 
dep = new LocalModuleDependency(localModule, void 0, !1), dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep)) : (dep = this.newRequireItemDependency(request), 
dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep)), 
deps.push(dep);
}));
const dep = this.newRequireArrayDependency(deps, param.range);
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}
processItem(parser, expr, param, namedModule) {
if (param.isConditional()) return param.options.forEach((param => {
void 0 === this.processItem(parser, expr, param) && this.processContext(parser, expr, param);
})), !0;
if (param.isString()) {
let dep, localModule;
if ("require" === param.string) dep = new ConstDependency("__webpack_require__", param.range, [ RuntimeGlobals.require ]); else if ("exports" === param.string) dep = new ConstDependency("exports", param.range, [ RuntimeGlobals.exports ]); else if ("module" === param.string) dep = new ConstDependency("module", param.range, [ RuntimeGlobals.module ]); else {
if (!(localModule = getLocalModule(parser.state, param.string, namedModule))) return dep = this.newRequireItemDependency(param.string, param.range), 
dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), !0;
localModule.flagUsed(), dep = new LocalModuleDependency(localModule, param.range, !1);
}
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}
processContext(parser, expr, param) {
const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {
category: "amd"
}, parser);
if (dep) return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
}
processCallDefine(parser, expr) {
let array, fn, obj, namedModule;
switch (expr.arguments.length) {
case 1:
isCallable(expr.arguments[0]) ? fn = expr.arguments[0] : obj = "ObjectExpression" === expr.arguments[0].type ? expr.arguments[0] : fn = expr.arguments[0];
break;

case 2:
"Literal" === expr.arguments[0].type ? (namedModule = expr.arguments[0].value, isCallable(expr.arguments[1]) ? fn = expr.arguments[1] : obj = "ObjectExpression" === expr.arguments[1].type ? expr.arguments[1] : fn = expr.arguments[1]) : (array = expr.arguments[0], 
isCallable(expr.arguments[1]) ? fn = expr.arguments[1] : obj = "ObjectExpression" === expr.arguments[1].type ? expr.arguments[1] : fn = expr.arguments[1]);
break;

case 3:
namedModule = expr.arguments[0].value, array = expr.arguments[1], isCallable(expr.arguments[2]) ? fn = expr.arguments[2] : obj = "ObjectExpression" === expr.arguments[2].type ? expr.arguments[2] : fn = expr.arguments[2];
break;

default:
return;
}
DynamicExports.bailout(parser.state);
let fnParams = null, fnParamsOffset = 0;
fn && (isUnboundFunctionExpression(fn) ? fnParams = fn.params : isBoundFunctionExpression(fn) && (fnParams = fn.callee.object.params, 
fnParamsOffset = fn.arguments.length - 1, fnParamsOffset < 0 && (fnParamsOffset = 0)));
let inTry, fnRenames = new Map;
if (array) {
const identifiers = {}, param = parser.evaluateExpression(array);
if (!this.processArray(parser, expr, param, identifiers, namedModule)) return;
fnParams && (fnParams = fnParams.slice(fnParamsOffset).filter(((param, idx) => !identifiers[idx] || (fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx])), 
!1))));
} else {
const identifiers = [ "require", "exports", "module" ];
fnParams && (fnParams = fnParams.slice(fnParamsOffset).filter(((param, idx) => !identifiers[idx] || (fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx])), 
!1))));
}
fn && isUnboundFunctionExpression(fn) ? (inTry = parser.scope.inTry, parser.inScope(fnParams, (() => {
for (const [name, varInfo] of fnRenames) parser.setVariable(name, varInfo);
if (parser.scope.inTry = inTry, "BlockStatement" === fn.body.type) {
parser.detectMode(fn.body.body);
const prev = parser.prevStatement;
parser.preWalkStatement(fn.body), parser.prevStatement = prev, parser.walkStatement(fn.body);
} else parser.walkExpression(fn.body);
}))) : fn && isBoundFunctionExpression(fn) ? (inTry = parser.scope.inTry, parser.inScope(fn.callee.object.params.filter((i => ![ "require", "module", "exports" ].includes(i.name))), (() => {
for (const [name, varInfo] of fnRenames) parser.setVariable(name, varInfo);
if (parser.scope.inTry = inTry, "BlockStatement" === fn.callee.object.body.type) {
parser.detectMode(fn.callee.object.body.body);
const prev = parser.prevStatement;
parser.preWalkStatement(fn.callee.object.body), parser.prevStatement = prev, parser.walkStatement(fn.callee.object.body);
} else parser.walkExpression(fn.callee.object.body);
})), fn.arguments && parser.walkExpressions(fn.arguments)) : (fn || obj) && parser.walkExpression(fn || obj);
const dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule || null);
return dep.loc = expr.loc, namedModule && (dep.localModule = addLocalModule(parser.state, namedModule)), 
parser.state.module.addPresentationalDependency(dep), !0;
}
newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {
return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);
}
newRequireArrayDependency(depsArray, range) {
return new AMDRequireArrayDependency(depsArray, range);
}
newRequireItemDependency(request, range) {
return new AMDRequireItemDependency(request, range);
}
};
},
3687: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), {approve, evaluateToIdentifier, evaluateToString, toConstantDependency} = __webpack_require__(78802), AMDDefineDependency = __webpack_require__(80147), AMDDefineDependencyParserPlugin = __webpack_require__(51930), AMDRequireArrayDependency = __webpack_require__(98773), AMDRequireContextDependency = __webpack_require__(35974), AMDRequireDependenciesBlockParserPlugin = __webpack_require__(70216), AMDRequireDependency = __webpack_require__(70479), AMDRequireItemDependency = __webpack_require__(39744), {AMDDefineRuntimeModule, AMDOptionsRuntimeModule} = __webpack_require__(31459), ConstDependency = __webpack_require__(30339), LocalModuleDependency = __webpack_require__(7306), UnsupportedDependency = __webpack_require__(7615);
module.exports = class {
constructor(amdOptions) {
this.amdOptions = amdOptions;
}
apply(compiler) {
const amdOptions = this.amdOptions;
compiler.hooks.compilation.tap("AMDPlugin", ((compilation, {contextModuleFactory, normalModuleFactory}) => {
compilation.dependencyTemplates.set(AMDRequireDependency, new AMDRequireDependency.Template), 
compilation.dependencyFactories.set(AMDRequireItemDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(AMDRequireItemDependency, new AMDRequireItemDependency.Template), 
compilation.dependencyTemplates.set(AMDRequireArrayDependency, new AMDRequireArrayDependency.Template), 
compilation.dependencyFactories.set(AMDRequireContextDependency, contextModuleFactory), 
compilation.dependencyTemplates.set(AMDRequireContextDependency, new AMDRequireContextDependency.Template), 
compilation.dependencyTemplates.set(AMDDefineDependency, new AMDDefineDependency.Template), 
compilation.dependencyTemplates.set(UnsupportedDependency, new UnsupportedDependency.Template), 
compilation.dependencyTemplates.set(LocalModuleDependency, new LocalModuleDependency.Template), 
compilation.hooks.runtimeRequirementInModule.for(RuntimeGlobals.amdDefine).tap("AMDPlugin", ((module, set) => {
set.add(RuntimeGlobals.require);
})), compilation.hooks.runtimeRequirementInModule.for(RuntimeGlobals.amdOptions).tap("AMDPlugin", ((module, set) => {
set.add(RuntimeGlobals.requireScope);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.amdDefine).tap("AMDPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new AMDDefineRuntimeModule);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.amdOptions).tap("AMDPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new AMDOptionsRuntimeModule(amdOptions));
}));
const handler = (parser, parserOptions) => {
if (void 0 !== parserOptions.amd && !parserOptions.amd) return;
const tapOptionsHooks = (optionExpr, rootName, getMembers) => {
parser.hooks.expression.for(optionExpr).tap("AMDPlugin", toConstantDependency(parser, RuntimeGlobals.amdOptions, [ RuntimeGlobals.amdOptions ])), 
parser.hooks.evaluateIdentifier.for(optionExpr).tap("AMDPlugin", evaluateToIdentifier(optionExpr, rootName, getMembers, !0)), 
parser.hooks.evaluateTypeof.for(optionExpr).tap("AMDPlugin", evaluateToString("object")), 
parser.hooks.typeof.for(optionExpr).tap("AMDPlugin", toConstantDependency(parser, JSON.stringify("object")));
};
new AMDRequireDependenciesBlockParserPlugin(parserOptions).apply(parser), new AMDDefineDependencyParserPlugin(parserOptions).apply(parser), 
tapOptionsHooks("define.amd", "define", (() => "amd")), tapOptionsHooks("require.amd", "require", (() => [ "amd" ])), 
tapOptionsHooks("__webpack_amd_options__", "__webpack_amd_options__", (() => [])), 
parser.hooks.expression.for("define").tap("AMDPlugin", (expr => {
const dep = new ConstDependency(RuntimeGlobals.amdDefine, expr.range, [ RuntimeGlobals.amdDefine ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.typeof.for("define").tap("AMDPlugin", toConstantDependency(parser, JSON.stringify("function"))), 
parser.hooks.evaluateTypeof.for("define").tap("AMDPlugin", evaluateToString("function")), 
parser.hooks.canRename.for("define").tap("AMDPlugin", approve), parser.hooks.rename.for("define").tap("AMDPlugin", (expr => {
const dep = new ConstDependency(RuntimeGlobals.amdDefine, expr.range, [ RuntimeGlobals.amdDefine ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!1;
})), parser.hooks.typeof.for("require").tap("AMDPlugin", toConstantDependency(parser, JSON.stringify("function"))), 
parser.hooks.evaluateTypeof.for("require").tap("AMDPlugin", evaluateToString("function"));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("AMDPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("AMDPlugin", handler);
}));
}
};
},
98773: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DependencyTemplate = __webpack_require__(44515), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class AMDRequireArrayDependency extends NullDependency {
constructor(depsArray, range) {
super(), this.depsArray = depsArray, this.range = range;
}
get type() {
return "amd require array";
}
get category() {
return "amd";
}
serialize(context) {
const {write} = context;
write(this.depsArray), write(this.range), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.depsArray = read(), this.range = read(), super.deserialize(context);
}
}
makeSerializable(AMDRequireArrayDependency, "webpack/lib/dependencies/AMDRequireArrayDependency"), 
AMDRequireArrayDependency.Template = class extends DependencyTemplate {
apply(dependency, source, templateContext) {
const dep = dependency, content = this.getContent(dep, templateContext);
source.replace(dep.range[0], dep.range[1] - 1, content);
}
getContent(dep, templateContext) {
return `[${dep.depsArray.map((dependency => this.contentForDependency(dependency, templateContext))).join(", ")}]`;
}
contentForDependency(dep, {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements}) {
return "string" == typeof dep ? dep : dep.localModule ? dep.localModule.variableName() : runtimeTemplate.moduleExports({
module: moduleGraph.getModule(dep),
chunkGraph,
request: dep.request,
runtimeRequirements
});
}
}, module.exports = AMDRequireArrayDependency;
},
35974: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ContextDependency = __webpack_require__(97818);
class AMDRequireContextDependency extends ContextDependency {
constructor(options, range, valueRange) {
super(options), this.range = range, this.valueRange = valueRange;
}
get type() {
return "amd require context";
}
get category() {
return "amd";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.valueRange), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.valueRange = read(), super.deserialize(context);
}
}
makeSerializable(AMDRequireContextDependency, "webpack/lib/dependencies/AMDRequireContextDependency"), 
AMDRequireContextDependency.Template = __webpack_require__(31131), module.exports = AMDRequireContextDependency;
},
64887: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const AsyncDependenciesBlock = __webpack_require__(89353), makeSerializable = __webpack_require__(45898);
class AMDRequireDependenciesBlock extends AsyncDependenciesBlock {
constructor(loc, request) {
super(null, loc, request);
}
}
makeSerializable(AMDRequireDependenciesBlock, "webpack/lib/dependencies/AMDRequireDependenciesBlock"), 
module.exports = AMDRequireDependenciesBlock;
},
70216: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), UnsupportedFeatureWarning = __webpack_require__(3490), AMDRequireArrayDependency = __webpack_require__(98773), AMDRequireContextDependency = __webpack_require__(35974), AMDRequireDependenciesBlock = __webpack_require__(64887), AMDRequireDependency = __webpack_require__(70479), AMDRequireItemDependency = __webpack_require__(39744), ConstDependency = __webpack_require__(30339), ContextDependencyHelpers = __webpack_require__(52963), LocalModuleDependency = __webpack_require__(7306), {getLocalModule} = __webpack_require__(81603), UnsupportedDependency = __webpack_require__(7615), getFunctionExpression = __webpack_require__(40142);
module.exports = class {
constructor(options) {
this.options = options;
}
processFunctionArgument(parser, expression) {
let bindThis = !0;
const fnData = getFunctionExpression(expression);
return fnData ? (parser.inScope(fnData.fn.params.filter((i => ![ "require", "module", "exports" ].includes(i.name))), (() => {
"BlockStatement" === fnData.fn.body.type ? parser.walkStatement(fnData.fn.body) : parser.walkExpression(fnData.fn.body);
})), parser.walkExpressions(fnData.expressions), !1 === fnData.needThis && (bindThis = !1)) : parser.walkExpression(expression), 
bindThis;
}
apply(parser) {
parser.hooks.call.for("require").tap("AMDRequireDependenciesBlockParserPlugin", this.processCallRequire.bind(this, parser));
}
processArray(parser, expr, param) {
if (param.isArray()) {
for (const p of param.items) {
void 0 === this.processItem(parser, expr, p) && this.processContext(parser, expr, p);
}
return !0;
}
if (param.isConstArray()) {
const deps = [];
for (const request of param.array) {
let dep, localModule;
"require" === request ? dep = "__webpack_require__" : [ "exports", "module" ].includes(request) ? dep = request : (localModule = getLocalModule(parser.state, request)) ? (localModule.flagUsed(), 
dep = new LocalModuleDependency(localModule, void 0, !1), dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep)) : (dep = this.newRequireItemDependency(request), 
dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep)), 
deps.push(dep);
}
const dep = this.newRequireArrayDependency(deps, param.range);
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}
processItem(parser, expr, param) {
if (param.isConditional()) {
for (const p of param.options) {
void 0 === this.processItem(parser, expr, p) && this.processContext(parser, expr, p);
}
return !0;
}
if (param.isString()) {
let dep, localModule;
if ("require" === param.string) dep = new ConstDependency("__webpack_require__", param.string, [ RuntimeGlobals.require ]); else if ("module" === param.string) dep = new ConstDependency(parser.state.module.buildInfo.moduleArgument, param.range, [ RuntimeGlobals.module ]); else if ("exports" === param.string) dep = new ConstDependency(parser.state.module.buildInfo.exportsArgument, param.range, [ RuntimeGlobals.exports ]); else {
if (!(localModule = getLocalModule(parser.state, param.string))) return dep = this.newRequireItemDependency(param.string, param.range), 
dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
localModule.flagUsed(), dep = new LocalModuleDependency(localModule, param.range, !1);
}
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}
processContext(parser, expr, param) {
const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {
category: "amd"
}, parser);
if (dep) return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
}
processArrayForRequestString(param) {
if (param.isArray()) {
const result = param.items.map((item => this.processItemForRequestString(item)));
if (result.every(Boolean)) return result.join(" ");
} else if (param.isConstArray()) return param.array.join(" ");
}
processItemForRequestString(param) {
if (param.isConditional()) {
const result = param.options.map((item => this.processItemForRequestString(item)));
if (result.every(Boolean)) return result.join("|");
} else if (param.isString()) return param.string;
}
processCallRequire(parser, expr) {
let param, depBlock, dep, result;
const old = parser.state.current;
if (expr.arguments.length >= 1 && (param = parser.evaluateExpression(expr.arguments[0]), 
depBlock = this.newRequireDependenciesBlock(expr.loc, this.processArrayForRequestString(param)), 
dep = this.newRequireDependency(expr.range, param.range, expr.arguments.length > 1 ? expr.arguments[1].range : null, expr.arguments.length > 2 ? expr.arguments[2].range : null), 
dep.loc = expr.loc, depBlock.addDependency(dep), parser.state.current = depBlock), 
1 === expr.arguments.length) {
if (parser.inScope([], (() => {
result = this.processArray(parser, expr, param);
})), parser.state.current = old, !result) return;
return parser.state.current.addBlock(depBlock), !0;
}
if (2 === expr.arguments.length || 3 === expr.arguments.length) {
try {
if (parser.inScope([], (() => {
result = this.processArray(parser, expr, param);
})), !result) {
const dep = new UnsupportedDependency("unsupported", expr.range);
return old.addPresentationalDependency(dep), parser.state.module && parser.state.module.addError(new UnsupportedFeatureWarning("Cannot statically analyse 'require(…, …)' in line " + expr.loc.start.line, expr.loc)), 
depBlock = null, !0;
}
dep.functionBindThis = this.processFunctionArgument(parser, expr.arguments[1]), 
3 === expr.arguments.length && (dep.errorCallbackBindThis = this.processFunctionArgument(parser, expr.arguments[2]));
} finally {
parser.state.current = old, depBlock && parser.state.current.addBlock(depBlock);
}
return !0;
}
}
newRequireDependenciesBlock(loc, request) {
return new AMDRequireDependenciesBlock(loc, request);
}
newRequireDependency(outerRange, arrayRange, functionRange, errorCallbackRange) {
return new AMDRequireDependency(outerRange, arrayRange, functionRange, errorCallbackRange);
}
newRequireItemDependency(request, range) {
return new AMDRequireItemDependency(request, range);
}
newRequireArrayDependency(depsArray, range) {
return new AMDRequireArrayDependency(depsArray, range);
}
};
},
70479: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class AMDRequireDependency extends NullDependency {
constructor(outerRange, arrayRange, functionRange, errorCallbackRange) {
super(), this.outerRange = outerRange, this.arrayRange = arrayRange, this.functionRange = functionRange, 
this.errorCallbackRange = errorCallbackRange, this.functionBindThis = !1, this.errorCallbackBindThis = !1;
}
get category() {
return "amd";
}
serialize(context) {
const {write} = context;
write(this.outerRange), write(this.arrayRange), write(this.functionRange), write(this.errorCallbackRange), 
write(this.functionBindThis), write(this.errorCallbackBindThis), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.outerRange = read(), this.arrayRange = read(), this.functionRange = read(), 
this.errorCallbackRange = read(), this.functionBindThis = read(), this.errorCallbackBindThis = read(), 
super.deserialize(context);
}
}
makeSerializable(AMDRequireDependency, "webpack/lib/dependencies/AMDRequireDependency"), 
AMDRequireDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency, depBlock = moduleGraph.getParentBlock(dep), promise = runtimeTemplate.blockPromise({
chunkGraph,
block: depBlock,
message: "AMD require",
runtimeRequirements
});
if (dep.arrayRange && !dep.functionRange) {
const startBlock = `${promise}.then(function() {`, endBlock = `;})['catch'](${RuntimeGlobals.uncaughtErrorHandler})`;
return runtimeRequirements.add(RuntimeGlobals.uncaughtErrorHandler), source.replace(dep.outerRange[0], dep.arrayRange[0] - 1, startBlock), 
void source.replace(dep.arrayRange[1], dep.outerRange[1] - 1, endBlock);
}
if (dep.functionRange && !dep.arrayRange) {
const startBlock = `${promise}.then((`, endBlock = `).bind(exports, __webpack_require__, exports, module))['catch'](${RuntimeGlobals.uncaughtErrorHandler})`;
return runtimeRequirements.add(RuntimeGlobals.uncaughtErrorHandler), source.replace(dep.outerRange[0], dep.functionRange[0] - 1, startBlock), 
void source.replace(dep.functionRange[1], dep.outerRange[1] - 1, endBlock);
}
if (dep.arrayRange && dep.functionRange && dep.errorCallbackRange) {
const startBlock = `${promise}.then(function() { `, errorRangeBlock = `}${dep.functionBindThis ? ".bind(this)" : ""})['catch'](`, endBlock = (dep.errorCallbackBindThis ? ".bind(this)" : "") + ")";
return source.replace(dep.outerRange[0], dep.arrayRange[0] - 1, startBlock), source.insert(dep.arrayRange[0], "var __WEBPACK_AMD_REQUIRE_ARRAY__ = "), 
source.replace(dep.arrayRange[1], dep.functionRange[0] - 1, "; ("), source.insert(dep.functionRange[1], ").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"), 
source.replace(dep.functionRange[1], dep.errorCallbackRange[0] - 1, errorRangeBlock), 
void source.replace(dep.errorCallbackRange[1], dep.outerRange[1] - 1, endBlock);
}
if (dep.arrayRange && dep.functionRange) {
const startBlock = `${promise}.then(function() { `, endBlock = `}${dep.functionBindThis ? ".bind(this)" : ""})['catch'](${RuntimeGlobals.uncaughtErrorHandler})`;
runtimeRequirements.add(RuntimeGlobals.uncaughtErrorHandler), source.replace(dep.outerRange[0], dep.arrayRange[0] - 1, startBlock), 
source.insert(dep.arrayRange[0], "var __WEBPACK_AMD_REQUIRE_ARRAY__ = "), source.replace(dep.arrayRange[1], dep.functionRange[0] - 1, "; ("), 
source.insert(dep.functionRange[1], ").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"), 
source.replace(dep.functionRange[1], dep.outerRange[1] - 1, endBlock);
}
}
}, module.exports = AMDRequireDependency;
},
39744: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyTemplateAsRequireId = __webpack_require__(74362);
class AMDRequireItemDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range;
}
get type() {
return "amd require";
}
get category() {
return "amd";
}
}
makeSerializable(AMDRequireItemDependency, "webpack/lib/dependencies/AMDRequireItemDependency"), 
AMDRequireItemDependency.Template = ModuleDependencyTemplateAsRequireId, module.exports = AMDRequireItemDependency;
},
31459: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
exports.AMDDefineRuntimeModule = class extends RuntimeModule {
constructor() {
super("amd define");
}
generate() {
return Template.asString([ `${RuntimeGlobals.amdDefine} = function () {`, Template.indent("throw new Error('define cannot be used indirect');"), "};" ]);
}
}, exports.AMDOptionsRuntimeModule = class extends RuntimeModule {
constructor(options) {
super("amd options"), this.options = options;
}
generate() {
return Template.asString([ `${RuntimeGlobals.amdOptions} = ${JSON.stringify(this.options)};` ]);
}
};
},
26919: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DependencyTemplate = __webpack_require__(44515), InitFragment = __webpack_require__(95328), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class CachedConstDependency extends NullDependency {
constructor(expression, range, identifier) {
super(), this.expression = expression, this.range = range, this.identifier = identifier, 
this._hashUpdate = void 0;
}
updateHash(hash, context) {
void 0 === this._hashUpdate && (this._hashUpdate = "" + this.identifier + this.range + this.expression), 
hash.update(this._hashUpdate);
}
serialize(context) {
const {write} = context;
write(this.expression), write(this.range), write(this.identifier), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.expression = read(), this.range = read(), this.identifier = read(), super.deserialize(context);
}
}
makeSerializable(CachedConstDependency, "webpack/lib/dependencies/CachedConstDependency"), 
CachedConstDependency.Template = class extends DependencyTemplate {
apply(dependency, source, {runtimeTemplate, dependencyTemplates, initFragments}) {
const dep = dependency;
initFragments.push(new InitFragment(`var ${dep.identifier} = ${dep.expression};\n`, InitFragment.STAGE_CONSTANTS, 0, `const ${dep.identifier}`)), 
"number" != typeof dep.range ? source.replace(dep.range[0], dep.range[1] - 1, dep.identifier) : source.insert(dep.range, dep.identifier);
}
}, module.exports = CachedConstDependency;
},
50600: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980);
exports.handleDependencyBase = (depBase, module, runtimeRequirements) => {
let base, type;
switch (depBase) {
case "exports":
runtimeRequirements.add(RuntimeGlobals.exports), base = module.exportsArgument, 
type = "expression";
break;

case "module.exports":
runtimeRequirements.add(RuntimeGlobals.module), base = `${module.moduleArgument}.exports`, 
type = "expression";
break;

case "this":
runtimeRequirements.add(RuntimeGlobals.thisAsExports), base = "this", type = "expression";
break;

case "Object.defineProperty(exports)":
runtimeRequirements.add(RuntimeGlobals.exports), base = module.exportsArgument, 
type = "Object.defineProperty";
break;

case "Object.defineProperty(module.exports)":
runtimeRequirements.add(RuntimeGlobals.module), base = `${module.moduleArgument}.exports`, 
type = "Object.defineProperty";
break;

case "Object.defineProperty(this)":
runtimeRequirements.add(RuntimeGlobals.thisAsExports), base = "this", type = "Object.defineProperty";
break;

default:
throw new Error(`Unsupported base ${depBase}`);
}
return [ type, base ];
};
},
98893: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), {UsageState} = __webpack_require__(74603), Template = __webpack_require__(88370), {equals} = __webpack_require__(8579), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), {handleDependencyBase} = __webpack_require__(50600), ModuleDependency = __webpack_require__(15216), processExportInfo = __webpack_require__(97556), idsSymbol = Symbol("CommonJsExportRequireDependency.ids"), EMPTY_OBJECT = {};
class CommonJsExportRequireDependency extends ModuleDependency {
constructor(range, valueRange, base, names, request, ids, resultUsed) {
super(request), this.range = range, this.valueRange = valueRange, this.base = base, 
this.names = names, this.ids = ids, this.resultUsed = resultUsed, this.asiSafe = void 0;
}
get type() {
return "cjs export require";
}
couldAffectReferencingModule() {
return Dependency.TRANSITIVE;
}
getIds(moduleGraph) {
return moduleGraph.getMeta(this)[idsSymbol] || this.ids;
}
setIds(moduleGraph, ids) {
moduleGraph.getMeta(this)[idsSymbol] = ids;
}
getReferencedExports(moduleGraph, runtime) {
const ids = this.getIds(moduleGraph), getFullResult = () => 0 === ids.length ? Dependency.EXPORTS_OBJECT_REFERENCED : [ {
name: ids,
canMangle: !1
} ];
if (this.resultUsed) return getFullResult();
let exportsInfo = moduleGraph.getExportsInfo(moduleGraph.getParentModule(this));
for (const name of this.names) {
const exportInfo = exportsInfo.getReadOnlyExportInfo(name), used = exportInfo.getUsed(runtime);
if (used === UsageState.Unused) return Dependency.NO_EXPORTS_REFERENCED;
if (used !== UsageState.OnlyPropertiesUsed) return getFullResult();
if (exportsInfo = exportInfo.exportsInfo, !exportsInfo) return getFullResult();
}
if (exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused) return getFullResult();
const referencedExports = [];
for (const exportInfo of exportsInfo.orderedExports) processExportInfo(runtime, referencedExports, ids.concat(exportInfo.name), exportInfo, !1);
return referencedExports.map((name => ({
name,
canMangle: !1
})));
}
getExports(moduleGraph) {
const ids = this.getIds(moduleGraph);
if (1 === this.names.length) {
const name = this.names[0], from = moduleGraph.getConnection(this);
if (!from) return;
return {
exports: [ {
name,
from,
export: 0 === ids.length ? null : ids,
canMangle: !(name in EMPTY_OBJECT) && !1
} ],
dependencies: [ from.module ]
};
}
if (this.names.length > 0) {
const name = this.names[0];
return {
exports: [ {
name,
canMangle: !(name in EMPTY_OBJECT) && !1
} ],
dependencies: void 0
};
}
{
const from = moduleGraph.getConnection(this);
if (!from) return;
const reexportInfo = this.getStarReexports(moduleGraph, void 0, from.module);
return reexportInfo ? {
exports: Array.from(reexportInfo.exports, (name => ({
name,
from,
export: ids.concat(name),
canMangle: !(name in EMPTY_OBJECT) && !1
}))),
dependencies: [ from.module ]
} : {
exports: !0,
from: 0 === ids.length ? from : void 0,
canMangle: !1,
dependencies: [ from.module ]
};
}
}
getStarReexports(moduleGraph, runtime, importedModule = moduleGraph.getModule(this)) {
let importedExportsInfo = moduleGraph.getExportsInfo(importedModule);
const ids = this.getIds(moduleGraph);
ids.length > 0 && (importedExportsInfo = importedExportsInfo.getNestedExportsInfo(ids));
let exportsInfo = moduleGraph.getExportsInfo(moduleGraph.getParentModule(this));
this.names.length > 0 && (exportsInfo = exportsInfo.getNestedExportsInfo(this.names));
const noExtraExports = importedExportsInfo && !1 === importedExportsInfo.otherExportsInfo.provided, noExtraImports = exportsInfo && exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused;
if (!noExtraExports && !noExtraImports) return;
const isNamespaceImport = "namespace" === importedModule.getExportsType(moduleGraph, !1), exports = new Set, checked = new Set;
if (noExtraImports) for (const exportInfo of exportsInfo.orderedExports) {
const name = exportInfo.name;
if (exportInfo.getUsed(runtime) !== UsageState.Unused) if ("__esModule" === name && isNamespaceImport) exports.add(name); else if (importedExportsInfo) {
const importedExportInfo = importedExportsInfo.getReadOnlyExportInfo(name);
if (!1 === importedExportInfo.provided) continue;
if (exports.add(name), !0 === importedExportInfo.provided) continue;
checked.add(name);
} else exports.add(name), checked.add(name);
} else if (noExtraExports) {
for (const importedExportInfo of importedExportsInfo.orderedExports) {
const name = importedExportInfo.name;
if (!1 !== importedExportInfo.provided) {
if (exportsInfo) {
if (exportsInfo.getReadOnlyExportInfo(name).getUsed(runtime) === UsageState.Unused) continue;
}
exports.add(name), !0 !== importedExportInfo.provided && checked.add(name);
}
}
isNamespaceImport && (exports.add("__esModule"), checked.delete("__esModule"));
}
return {
exports,
checked
};
}
serialize(context) {
const {write} = context;
write(this.asiSafe), write(this.range), write(this.valueRange), write(this.base), 
write(this.names), write(this.ids), write(this.resultUsed), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.asiSafe = read(), this.range = read(), this.valueRange = read(), this.base = read(), 
this.names = read(), this.ids = read(), this.resultUsed = read(), super.deserialize(context);
}
}
makeSerializable(CommonJsExportRequireDependency, "webpack/lib/dependencies/CommonJsExportRequireDependency"), 
CommonJsExportRequireDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, {module, runtimeTemplate, chunkGraph, moduleGraph, runtimeRequirements, runtime}) {
const dep = dependency, used = moduleGraph.getExportsInfo(module).getUsedName(dep.names, runtime), [type, base] = handleDependencyBase(dep.base, module, runtimeRequirements), importedModule = moduleGraph.getModule(dep);
let requireExpr = runtimeTemplate.moduleExports({
module: importedModule,
chunkGraph,
request: dep.request,
weak: dep.weak,
runtimeRequirements
});
if (importedModule) {
const ids = dep.getIds(moduleGraph), usedImported = moduleGraph.getExportsInfo(importedModule).getUsedName(ids, runtime);
if (usedImported) {
requireExpr += `${equals(usedImported, ids) ? "" : Template.toNormalComment(propertyAccess(ids)) + " "}${propertyAccess(usedImported)}`;
}
}
switch (type) {
case "expression":
return void source.replace(dep.range[0], dep.range[1] - 1, used ? `${base}${propertyAccess(used)} = ${requireExpr}` : `/* unused reexport */ ${requireExpr}`);

case "Object.defineProperty":
throw new Error("TODO");

default:
throw new Error("Unexpected type");
}
}
}, module.exports = CommonJsExportRequireDependency;
},
78247: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const InitFragment = __webpack_require__(95328), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), {handleDependencyBase} = __webpack_require__(50600), NullDependency = __webpack_require__(52649), EMPTY_OBJECT = {};
class CommonJsExportsDependency extends NullDependency {
constructor(range, valueRange, base, names) {
super(), this.range = range, this.valueRange = valueRange, this.base = base, this.names = names;
}
get type() {
return "cjs exports";
}
getExports(moduleGraph) {
const name = this.names[0];
return {
exports: [ {
name,
canMangle: !(name in EMPTY_OBJECT)
} ],
dependencies: void 0
};
}
serialize(context) {
const {write} = context;
write(this.range), write(this.valueRange), write(this.base), write(this.names), 
super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.valueRange = read(), this.base = read(), this.names = read(), 
super.deserialize(context);
}
}
makeSerializable(CommonJsExportsDependency, "webpack/lib/dependencies/CommonJsExportsDependency"), 
CommonJsExportsDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, moduleGraph, initFragments, runtimeRequirements, runtime}) {
const dep = dependency, used = moduleGraph.getExportsInfo(module).getUsedName(dep.names, runtime), [type, base] = handleDependencyBase(dep.base, module, runtimeRequirements);
switch (type) {
case "expression":
return used ? void source.replace(dep.range[0], dep.range[1] - 1, `${base}${propertyAccess(used)}`) : (initFragments.push(new InitFragment("var __webpack_unused_export__;\n", InitFragment.STAGE_CONSTANTS, 0, "__webpack_unused_export__")), 
void source.replace(dep.range[0], dep.range[1] - 1, "__webpack_unused_export__"));

case "Object.defineProperty":
return used ? (source.replace(dep.range[0], dep.valueRange[0] - 1, `Object.defineProperty(${base}${propertyAccess(used.slice(0, -1))}, ${JSON.stringify(used[used.length - 1])}, (`), 
void source.replace(dep.valueRange[1], dep.range[1] - 1, "))")) : (initFragments.push(new InitFragment("var __webpack_unused_export__;\n", InitFragment.STAGE_CONSTANTS, 0, "__webpack_unused_export__")), 
source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_unused_export__ = ("), 
void source.replace(dep.valueRange[1], dep.range[1] - 1, ")"));
}
}
}, module.exports = CommonJsExportsDependency;
},
49532: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), formatLocation = __webpack_require__(78509), {evaluateToString} = __webpack_require__(78802), propertyAccess = __webpack_require__(10664), CommonJsExportRequireDependency = __webpack_require__(98893), CommonJsExportsDependency = __webpack_require__(78247), CommonJsSelfReferenceDependency = __webpack_require__(3256), DynamicExports = __webpack_require__(78722), HarmonyExports = __webpack_require__(60836), ModuleDecoratorDependency = __webpack_require__(90331), isTruthyLiteral = expr => {
switch (expr.type) {
case "Literal":
return !!expr.value;

case "UnaryExpression":
if ("!" === expr.operator) return isFalsyLiteral(expr.argument);
}
return !1;
}, isFalsyLiteral = expr => {
switch (expr.type) {
case "Literal":
return !expr.value;

case "UnaryExpression":
if ("!" === expr.operator) return isTruthyLiteral(expr.argument);
}
return !1;
};
module.exports = class {
constructor(moduleGraph) {
this.moduleGraph = moduleGraph;
}
apply(parser) {
const enableStructuredExports = () => {
DynamicExports.enable(parser.state);
}, checkNamespace = (topLevel, members, valueExpr) => {
DynamicExports.isEnabled(parser.state) && members.length > 0 && "__esModule" === members[0] && (valueExpr && isTruthyLiteral(valueExpr) && topLevel ? DynamicExports.setFlagged(parser.state) : DynamicExports.setDynamic(parser.state));
}, bailout = reason => {
DynamicExports.bailout(parser.state), reason && bailoutHint(reason);
}, bailoutHint = reason => {
this.moduleGraph.getOptimizationBailout(parser.state.module).push(`CommonJS bailout: ${reason}`);
};
parser.hooks.evaluateTypeof.for("module").tap("CommonJsExportsParserPlugin", evaluateToString("object")), 
parser.hooks.evaluateTypeof.for("exports").tap("CommonJsPlugin", evaluateToString("object"));
const handleAssignExport = (expr, base, members) => {
if (HarmonyExports.isEnabled(parser.state)) return;
const requireCall = ((parser, expr) => {
const ids = [];
for (;"MemberExpression" === expr.type; ) {
if ("Super" === expr.object.type) return;
if (!expr.property) return;
const prop = expr.property;
if (expr.computed) {
if ("Literal" !== prop.type) return;
ids.push(`${prop.value}`);
} else {
if ("Identifier" !== prop.type) return;
ids.push(prop.name);
}
expr = expr.object;
}
if ("CallExpression" !== expr.type || 1 !== expr.arguments.length) return;
const callee = expr.callee;
if ("Identifier" !== callee.type || "require" !== parser.getVariableInfo(callee.name)) return;
const arg = expr.arguments[0];
if ("SpreadElement" === arg.type) return;
return {
argument: parser.evaluateExpression(arg),
ids: ids.reverse()
};
})(parser, expr.right);
if (requireCall && requireCall.argument.isString() && (0 === members.length || "__esModule" !== members[0])) {
enableStructuredExports(), 0 === members.length && DynamicExports.setDynamic(parser.state);
const dep = new CommonJsExportRequireDependency(expr.range, null, base, members, requireCall.argument.string, requireCall.ids, !parser.isStatementLevelExpression(expr));
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.module.addDependency(dep), 
!0;
}
if (0 === members.length) return;
enableStructuredExports();
const remainingMembers = members;
checkNamespace(1 === parser.statementPath.length && parser.isStatementLevelExpression(expr), remainingMembers, expr.right);
const dep = new CommonJsExportsDependency(expr.left.range, null, base, remainingMembers);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), parser.walkExpression(expr.right), 
!0;
};
parser.hooks.assignMemberChain.for("exports").tap("CommonJsExportsParserPlugin", ((expr, members) => handleAssignExport(expr, "exports", members))), 
parser.hooks.assignMemberChain.for("this").tap("CommonJsExportsParserPlugin", ((expr, members) => {
if (parser.scope.topLevelScope) return handleAssignExport(expr, "this", members);
})), parser.hooks.assignMemberChain.for("module").tap("CommonJsExportsParserPlugin", ((expr, members) => {
if ("exports" === members[0]) return handleAssignExport(expr, "module.exports", members.slice(1));
})), parser.hooks.call.for("Object.defineProperty").tap("CommonJsExportsParserPlugin", (expression => {
const expr = expression;
if (!parser.isStatementLevelExpression(expr)) return;
if (3 !== expr.arguments.length) return;
if ("SpreadElement" === expr.arguments[0].type) return;
if ("SpreadElement" === expr.arguments[1].type) return;
if ("SpreadElement" === expr.arguments[2].type) return;
const exportsArg = parser.evaluateExpression(expr.arguments[0]);
if (!exportsArg.isIdentifier()) return;
if ("exports" !== exportsArg.identifier && "module.exports" !== exportsArg.identifier && ("this" !== exportsArg.identifier || !parser.scope.topLevelScope)) return;
const property = parser.evaluateExpression(expr.arguments[1]).asString();
if ("string" != typeof property) return;
enableStructuredExports();
const descArg = expr.arguments[2];
checkNamespace(1 === parser.statementPath.length, [ property ], (expr => {
if ("ObjectExpression" === expr.type) for (const property of expr.properties) {
if (property.computed) continue;
const key = property.key;
if ("Identifier" === key.type && "value" === key.name) return property.value;
}
})(descArg));
const dep = new CommonJsExportsDependency(expr.range, expr.arguments[2].range, `Object.defineProperty(${exportsArg.identifier})`, [ property ]);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), parser.walkExpression(expr.arguments[2]), 
!0;
}));
const handleAccessExport = (expr, base, members, call) => {
if (HarmonyExports.isEnabled(parser.state)) return;
0 === members.length && bailout(`${base} is used directly at ${formatLocation(expr.loc)}`), 
call && 1 === members.length && bailoutHint(`${base}${propertyAccess(members)}(...) prevents optimization as ${base} is passed as call context at ${formatLocation(expr.loc)}`);
const dep = new CommonJsSelfReferenceDependency(expr.range, base, members, !!call);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), call && parser.walkExpressions(call.arguments), 
!0;
};
parser.hooks.callMemberChain.for("exports").tap("CommonJsExportsParserPlugin", ((expr, members) => handleAccessExport(expr.callee, "exports", members, expr))), 
parser.hooks.expressionMemberChain.for("exports").tap("CommonJsExportsParserPlugin", ((expr, members) => handleAccessExport(expr, "exports", members))), 
parser.hooks.expression.for("exports").tap("CommonJsExportsParserPlugin", (expr => handleAccessExport(expr, "exports", []))), 
parser.hooks.callMemberChain.for("module").tap("CommonJsExportsParserPlugin", ((expr, members) => {
if ("exports" === members[0]) return handleAccessExport(expr.callee, "module.exports", members.slice(1), expr);
})), parser.hooks.expressionMemberChain.for("module").tap("CommonJsExportsParserPlugin", ((expr, members) => {
if ("exports" === members[0]) return handleAccessExport(expr, "module.exports", members.slice(1));
})), parser.hooks.expression.for("module.exports").tap("CommonJsExportsParserPlugin", (expr => handleAccessExport(expr, "module.exports", []))), 
parser.hooks.callMemberChain.for("this").tap("CommonJsExportsParserPlugin", ((expr, members) => {
if (parser.scope.topLevelScope) return handleAccessExport(expr.callee, "this", members, expr);
})), parser.hooks.expressionMemberChain.for("this").tap("CommonJsExportsParserPlugin", ((expr, members) => {
if (parser.scope.topLevelScope) return handleAccessExport(expr, "this", members);
})), parser.hooks.expression.for("this").tap("CommonJsExportsParserPlugin", (expr => {
if (parser.scope.topLevelScope) return handleAccessExport(expr, "this", []);
})), parser.hooks.expression.for("module").tap("CommonJsPlugin", (expr => {
bailout();
const isHarmony = HarmonyExports.isEnabled(parser.state), dep = new ModuleDecoratorDependency(isHarmony ? RuntimeGlobals.harmonyModuleDecorator : RuntimeGlobals.nodeModuleDecorator, !isHarmony);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), !0;
}));
}
};
},
76523: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Template = __webpack_require__(88370), {equals} = __webpack_require__(8579), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), ModuleDependency = __webpack_require__(15216);
class CommonJsFullRequireDependency extends ModuleDependency {
constructor(request, range, names) {
super(request), this.range = range, this.names = names, this.call = !1, this.asiSafe = void 0;
}
getReferencedExports(moduleGraph, runtime) {
if (this.call) {
const importedModule = moduleGraph.getModule(this);
if (!importedModule || "namespace" !== importedModule.getExportsType(moduleGraph, !1)) return [ this.names.slice(0, -1) ];
}
return [ this.names ];
}
serialize(context) {
const {write} = context;
write(this.names), write(this.call), write(this.asiSafe), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.names = read(), this.call = read(), this.asiSafe = read(), super.deserialize(context);
}
get type() {
return "cjs full require";
}
get category() {
return "commonjs";
}
}
CommonJsFullRequireDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, {module, runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements, runtime, initFragments}) {
const dep = dependency;
if (!dep.range) return;
const importedModule = moduleGraph.getModule(dep);
let requireExpr = runtimeTemplate.moduleExports({
module: importedModule,
chunkGraph,
request: dep.request,
weak: dep.weak,
runtimeRequirements
});
if (importedModule) {
const ids = dep.names, usedImported = moduleGraph.getExportsInfo(importedModule).getUsedName(ids, runtime);
if (usedImported) {
const access = `${equals(usedImported, ids) ? "" : Template.toNormalComment(propertyAccess(ids)) + " "}${propertyAccess(usedImported)}`;
requireExpr = !0 === dep.asiSafe ? `(${requireExpr}${access})` : `${requireExpr}${access}`;
}
}
source.replace(dep.range[0], dep.range[1] - 1, requireExpr);
}
}, makeSerializable(CommonJsFullRequireDependency, "webpack/lib/dependencies/CommonJsFullRequireDependency"), 
module.exports = CommonJsFullRequireDependency;
},
4300: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {fileURLToPath} = __webpack_require__(57310), CommentCompilationWarning = __webpack_require__(35931), RuntimeGlobals = __webpack_require__(50980), UnsupportedFeatureWarning = __webpack_require__(3490), WebpackError = __webpack_require__(64326), BasicEvaluatedExpression = __webpack_require__(47789), {evaluateToIdentifier, evaluateToString, expressionIsUnsupported, toConstantDependency} = __webpack_require__(78802), CommonJsFullRequireDependency = __webpack_require__(76523), CommonJsRequireContextDependency = __webpack_require__(92890), CommonJsRequireDependency = __webpack_require__(26777), ConstDependency = __webpack_require__(30339), ContextDependencyHelpers = __webpack_require__(52963), LocalModuleDependency = __webpack_require__(7306), {getLocalModule} = __webpack_require__(81603), RequireHeaderDependency = __webpack_require__(24547), RequireResolveContextDependency = __webpack_require__(31572), RequireResolveDependency = __webpack_require__(92551), RequireResolveHeaderDependency = __webpack_require__(4637), createRequireSpecifierTag = Symbol("createRequire"), createdRequireIdentifierTag = Symbol("createRequire()");
module.exports = class {
constructor(options) {
this.options = options;
}
apply(parser) {
const options = this.options, getContext = () => {
if (parser.currentTagData) {
const {context} = parser.currentTagData;
return context;
}
}, tapRequireExpression = (expression, getMembers) => {
parser.hooks.typeof.for(expression).tap("CommonJsImportsParserPlugin", toConstantDependency(parser, JSON.stringify("function"))), 
parser.hooks.evaluateTypeof.for(expression).tap("CommonJsImportsParserPlugin", evaluateToString("function")), 
parser.hooks.evaluateIdentifier.for(expression).tap("CommonJsImportsParserPlugin", evaluateToIdentifier(expression, "require", getMembers, !0));
}, tapRequireExpressionTag = tag => {
parser.hooks.typeof.for(tag).tap("CommonJsImportsParserPlugin", toConstantDependency(parser, JSON.stringify("function"))), 
parser.hooks.evaluateTypeof.for(tag).tap("CommonJsImportsParserPlugin", evaluateToString("function"));
};
tapRequireExpression("require", (() => [])), tapRequireExpression("require.resolve", (() => [ "resolve" ])), 
tapRequireExpression("require.resolveWeak", (() => [ "resolveWeak" ])), parser.hooks.assign.for("require").tap("CommonJsImportsParserPlugin", (expr => {
const dep = new ConstDependency("var require;", 0);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.expression.for("require.main").tap("CommonJsImportsParserPlugin", expressionIsUnsupported(parser, "require.main is not supported by webpack.")), 
parser.hooks.call.for("require.main.require").tap("CommonJsImportsParserPlugin", expressionIsUnsupported(parser, "require.main.require is not supported by webpack.")), 
parser.hooks.expression.for("module.parent.require").tap("CommonJsImportsParserPlugin", expressionIsUnsupported(parser, "module.parent.require is not supported by webpack.")), 
parser.hooks.call.for("module.parent.require").tap("CommonJsImportsParserPlugin", expressionIsUnsupported(parser, "module.parent.require is not supported by webpack."));
const defineUndefined = expr => {
const dep = new ConstDependency("undefined", expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!1;
};
parser.hooks.canRename.for("require").tap("CommonJsImportsParserPlugin", (() => !0)), 
parser.hooks.rename.for("require").tap("CommonJsImportsParserPlugin", defineUndefined);
const requireCache = toConstantDependency(parser, RuntimeGlobals.moduleCache, [ RuntimeGlobals.moduleCache, RuntimeGlobals.moduleId, RuntimeGlobals.moduleLoaded ]);
parser.hooks.expression.for("require.cache").tap("CommonJsImportsParserPlugin", requireCache);
const requireAsExpressionHandler = expr => {
const dep = new CommonJsRequireContextDependency({
request: options.unknownContextRequest,
recursive: options.unknownContextRecursive,
regExp: options.unknownContextRegExp,
mode: "sync"
}, expr.range, void 0, parser.scope.inShorthand, getContext());
return dep.critical = options.unknownContextCritical && "require function is used in a way in which dependencies cannot be statically extracted", 
dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
};
parser.hooks.expression.for("require").tap("CommonJsImportsParserPlugin", requireAsExpressionHandler);
const processRequireItem = (expr, param) => {
if (param.isString()) {
const dep = new CommonJsRequireDependency(param.string, param.range, getContext());
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
}
}, createRequireHandler = callNew => expr => {
if (options.commonjsMagicComments) {
const {options: requireOptions, errors: commentErrors} = parser.parseCommentOptions(expr.range);
if (commentErrors) for (const e of commentErrors) {
const {comment} = e;
parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));
}
if (requireOptions && void 0 !== requireOptions.webpackIgnore) if ("boolean" != typeof requireOptions.webpackIgnore) parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackIgnore\` expected a boolean, but received: ${requireOptions.webpackIgnore}.`, expr.loc)); else if (requireOptions.webpackIgnore) return !0;
}
if (1 !== expr.arguments.length) return;
let localModule;
const param = parser.evaluateExpression(expr.arguments[0]);
if (param.isConditional()) {
let isExpression = !1;
for (const p of param.options) {
void 0 === processRequireItem(expr, p) && (isExpression = !0);
}
if (!isExpression) {
const dep = new RequireHeaderDependency(expr.callee.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}
if (param.isString() && (localModule = getLocalModule(parser.state, param.string))) {
localModule.flagUsed();
const dep = new LocalModuleDependency(localModule, expr.range, callNew);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
if (void 0 === processRequireItem(expr, param)) ((expr, param) => {
const dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency, expr.range, param, expr, options, {
category: "commonjs"
}, parser, void 0, getContext());
if (dep) dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep);
})(expr, param); else {
const dep = new RequireHeaderDependency(expr.callee.range);
dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep);
}
return !0;
};
parser.hooks.call.for("require").tap("CommonJsImportsParserPlugin", createRequireHandler(!1)), 
parser.hooks.new.for("require").tap("CommonJsImportsParserPlugin", createRequireHandler(!0)), 
parser.hooks.call.for("module.require").tap("CommonJsImportsParserPlugin", createRequireHandler(!1)), 
parser.hooks.new.for("module.require").tap("CommonJsImportsParserPlugin", createRequireHandler(!0));
const chainHandler = (expr, calleeMembers, callExpr, members) => {
if (1 !== callExpr.arguments.length) return;
const param = parser.evaluateExpression(callExpr.arguments[0]);
if (param.isString() && !getLocalModule(parser.state, param.string)) {
const dep = new CommonJsFullRequireDependency(param.string, expr.range, members);
return dep.asiSafe = !parser.isAsiPosition(expr.range[0]), dep.optional = !!parser.scope.inTry, 
dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
}
}, callChainHandler = (expr, calleeMembers, callExpr, members) => {
if (1 !== callExpr.arguments.length) return;
const param = parser.evaluateExpression(callExpr.arguments[0]);
if (param.isString() && !getLocalModule(parser.state, param.string)) {
const dep = new CommonJsFullRequireDependency(param.string, expr.callee.range, members);
return dep.call = !0, dep.asiSafe = !parser.isAsiPosition(expr.range[0]), dep.optional = !!parser.scope.inTry, 
dep.loc = expr.callee.loc, parser.state.current.addDependency(dep), parser.walkExpressions(expr.arguments), 
!0;
}
};
parser.hooks.memberChainOfCallMemberChain.for("require").tap("CommonJsImportsParserPlugin", chainHandler), 
parser.hooks.memberChainOfCallMemberChain.for("module.require").tap("CommonJsImportsParserPlugin", chainHandler), 
parser.hooks.callMemberChainOfCallMemberChain.for("require").tap("CommonJsImportsParserPlugin", callChainHandler), 
parser.hooks.callMemberChainOfCallMemberChain.for("module.require").tap("CommonJsImportsParserPlugin", callChainHandler);
const processResolve = (expr, weak) => {
if (1 !== expr.arguments.length) return;
const param = parser.evaluateExpression(expr.arguments[0]);
if (param.isConditional()) {
for (const option of param.options) {
void 0 === processResolveItem(expr, option, weak) && processResolveContext(expr, option, weak);
}
const dep = new RequireResolveHeaderDependency(expr.callee.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
{
void 0 === processResolveItem(expr, param, weak) && processResolveContext(expr, param, weak);
const dep = new RequireResolveHeaderDependency(expr.callee.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}
}, processResolveItem = (expr, param, weak) => {
if (param.isString()) {
const dep = new RequireResolveDependency(param.string, param.range, getContext());
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, dep.weak = weak, 
parser.state.current.addDependency(dep), !0;
}
}, processResolveContext = (expr, param, weak) => {
const dep = ContextDependencyHelpers.create(RequireResolveContextDependency, param.range, param, expr, options, {
category: "commonjs",
mode: weak ? "weak" : "sync"
}, parser, getContext());
if (dep) return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
};
if (parser.hooks.call.for("require.resolve").tap("CommonJsImportsParserPlugin", (expr => processResolve(expr, !1))), 
parser.hooks.call.for("require.resolveWeak").tap("CommonJsImportsParserPlugin", (expr => processResolve(expr, !0))), 
!options.createRequire) return;
let moduleName, specifierName;
if (!0 === options.createRequire) moduleName = "module", specifierName = "createRequire"; else {
const match = /^(.*) from (.*)$/.exec(options.createRequire);
if (match && ([, specifierName, moduleName] = match), !specifierName || !moduleName) {
const err = new WebpackError(`Parsing javascript parser option "createRequire" failed, got ${JSON.stringify(options.createRequire)}`);
throw err.details = 'Expected string in format "createRequire from module", where "createRequire" is specifier name and "module" name of the module', 
err;
}
}
tapRequireExpressionTag(createdRequireIdentifierTag), tapRequireExpressionTag(createRequireSpecifierTag), 
parser.hooks.evaluateCallExpression.for(createRequireSpecifierTag).tap("CommonJsImportsParserPlugin", (expr => {
const context = parseCreateRequireArguments(expr);
if (void 0 === context) return;
const ident = parser.evaluatedVariable({
tag: createdRequireIdentifierTag,
data: {
context
},
next: void 0
});
return (new BasicEvaluatedExpression).setIdentifier(ident, ident, (() => [])).setSideEffects(!1).setRange(expr.range);
})), parser.hooks.unhandledExpressionMemberChain.for(createdRequireIdentifierTag).tap("CommonJsImportsParserPlugin", ((expr, members) => expressionIsUnsupported(parser, `createRequire().${members.join(".")} is not supported by webpack.`)(expr))), 
parser.hooks.canRename.for(createdRequireIdentifierTag).tap("CommonJsImportsParserPlugin", (() => !0)), 
parser.hooks.canRename.for(createRequireSpecifierTag).tap("CommonJsImportsParserPlugin", (() => !0)), 
parser.hooks.rename.for(createRequireSpecifierTag).tap("CommonJsImportsParserPlugin", defineUndefined), 
parser.hooks.expression.for(createdRequireIdentifierTag).tap("CommonJsImportsParserPlugin", requireAsExpressionHandler), 
parser.hooks.call.for(createdRequireIdentifierTag).tap("CommonJsImportsParserPlugin", createRequireHandler(!1));
const parseCreateRequireArguments = expr => {
const args = expr.arguments;
if (1 !== args.length) {
const err = new WebpackError("module.createRequire supports only one argument.");
return err.loc = expr.loc, void parser.state.module.addWarning(err);
}
const arg = args[0], evaluated = parser.evaluateExpression(arg);
if (!evaluated.isString()) {
const err = new WebpackError("module.createRequire failed parsing argument.");
return err.loc = arg.loc, void parser.state.module.addWarning(err);
}
const ctx = evaluated.string.startsWith("file://") ? fileURLToPath(evaluated.string) : evaluated.string;
return ctx.slice(0, ctx.lastIndexOf(ctx.startsWith("/") ? "/" : "\\"));
};
parser.hooks.import.tap({
name: "CommonJsImportsParserPlugin",
stage: -10
}, ((statement, source) => {
if (source !== moduleName || 1 !== statement.specifiers.length || "ImportSpecifier" !== statement.specifiers[0].type || "Identifier" !== statement.specifiers[0].imported.type || statement.specifiers[0].imported.name !== specifierName) return;
const clearDep = new ConstDependency(parser.isAsiPosition(statement.range[0]) ? ";" : "", statement.range);
return clearDep.loc = statement.loc, parser.state.module.addPresentationalDependency(clearDep), 
parser.unsetAsiPosition(statement.range[1]), !0;
})), parser.hooks.importSpecifier.tap({
name: "CommonJsImportsParserPlugin",
stage: -10
}, ((statement, source, id, name) => {
if (source === moduleName && id === specifierName) return parser.tagVariable(name, createRequireSpecifierTag), 
!0;
})), parser.hooks.preDeclarator.tap("CommonJsImportsParserPlugin", (declarator => {
if ("Identifier" !== declarator.id.type || !declarator.init || "CallExpression" !== declarator.init.type || "Identifier" !== declarator.init.callee.type) return;
const variableInfo = parser.getVariableInfo(declarator.init.callee.name);
if (variableInfo && variableInfo.tagInfo && variableInfo.tagInfo.tag === createRequireSpecifierTag) {
const context = parseCreateRequireArguments(declarator.init);
if (void 0 === context) return;
return parser.tagVariable(declarator.id.name, createdRequireIdentifierTag, {
name: declarator.id.name,
context
}), !0;
}
})), parser.hooks.memberChainOfCallMemberChain.for(createRequireSpecifierTag).tap("CommonJsImportsParserPlugin", ((expr, calleeMembers, callExpr, members) => {
if (0 !== calleeMembers.length || 1 !== members.length || "cache" !== members[0]) return;
return void 0 !== parseCreateRequireArguments(callExpr) ? requireCache(expr) : void 0;
})), parser.hooks.callMemberChainOfCallMemberChain.for(createRequireSpecifierTag).tap("CommonJsImportsParserPlugin", ((expr, calleeMembers, innerCallExpression, members) => {
if (0 === calleeMembers.length && 1 === members.length && "resolve" === members[0]) return processResolve(expr, !1);
})), parser.hooks.expressionMemberChain.for(createdRequireIdentifierTag).tap("CommonJsImportsParserPlugin", ((expr, members) => {
if (1 === members.length && "cache" === members[0]) return requireCache(expr);
})), parser.hooks.callMemberChain.for(createdRequireIdentifierTag).tap("CommonJsImportsParserPlugin", ((expr, members) => {
if (1 === members.length && "resolve" === members[0]) return processResolve(expr, !1);
})), parser.hooks.call.for(createRequireSpecifierTag).tap("CommonJsImportsParserPlugin", (expr => {
const clearDep = new ConstDependency("/* createRequire() */ undefined", expr.range);
return clearDep.loc = expr.loc, parser.state.module.addPresentationalDependency(clearDep), 
!0;
}));
}
};
},
66563: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), SelfModuleFactory = __webpack_require__(21465), Template = __webpack_require__(88370), CommonJsExportsDependency = __webpack_require__(78247), CommonJsFullRequireDependency = __webpack_require__(76523), CommonJsRequireContextDependency = __webpack_require__(92890), CommonJsRequireDependency = __webpack_require__(26777), CommonJsSelfReferenceDependency = __webpack_require__(3256), ModuleDecoratorDependency = __webpack_require__(90331), RequireHeaderDependency = __webpack_require__(24547), RequireResolveContextDependency = __webpack_require__(31572), RequireResolveDependency = __webpack_require__(92551), RequireResolveHeaderDependency = __webpack_require__(4637), RuntimeRequirementsDependency = __webpack_require__(40680), CommonJsExportsParserPlugin = __webpack_require__(49532), CommonJsImportsParserPlugin = __webpack_require__(4300), {evaluateToIdentifier, toConstantDependency} = __webpack_require__(78802), CommonJsExportRequireDependency = __webpack_require__(98893);
class HarmonyModuleDecoratorRuntimeModule extends RuntimeModule {
constructor() {
super("harmony module decorator");
}
generate() {
const {runtimeTemplate} = this.compilation;
return Template.asString([ `${RuntimeGlobals.harmonyModuleDecorator} = ${runtimeTemplate.basicFunction("module", [ "module = Object.create(module);", "if (!module.children) module.children = [];", "Object.defineProperty(module, 'exports', {", Template.indent([ "enumerable: true,", `set: ${runtimeTemplate.basicFunction("", [ "throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);" ])}` ]), "});", "return module;" ])};` ]);
}
}
class NodeModuleDecoratorRuntimeModule extends RuntimeModule {
constructor() {
super("node module decorator");
}
generate() {
const {runtimeTemplate} = this.compilation;
return Template.asString([ `${RuntimeGlobals.nodeModuleDecorator} = ${runtimeTemplate.basicFunction("module", [ "module.paths = [];", "if (!module.children) module.children = [];", "return module;" ])};` ]);
}
}
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("CommonJsPlugin", ((compilation, {contextModuleFactory, normalModuleFactory}) => {
compilation.dependencyFactories.set(CommonJsRequireDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(CommonJsRequireDependency, new CommonJsRequireDependency.Template), 
compilation.dependencyFactories.set(CommonJsFullRequireDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(CommonJsFullRequireDependency, new CommonJsFullRequireDependency.Template), 
compilation.dependencyFactories.set(CommonJsRequireContextDependency, contextModuleFactory), 
compilation.dependencyTemplates.set(CommonJsRequireContextDependency, new CommonJsRequireContextDependency.Template), 
compilation.dependencyFactories.set(RequireResolveDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(RequireResolveDependency, new RequireResolveDependency.Template), 
compilation.dependencyFactories.set(RequireResolveContextDependency, contextModuleFactory), 
compilation.dependencyTemplates.set(RequireResolveContextDependency, new RequireResolveContextDependency.Template), 
compilation.dependencyTemplates.set(RequireResolveHeaderDependency, new RequireResolveHeaderDependency.Template), 
compilation.dependencyTemplates.set(RequireHeaderDependency, new RequireHeaderDependency.Template), 
compilation.dependencyTemplates.set(CommonJsExportsDependency, new CommonJsExportsDependency.Template), 
compilation.dependencyFactories.set(CommonJsExportRequireDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(CommonJsExportRequireDependency, new CommonJsExportRequireDependency.Template);
const selfFactory = new SelfModuleFactory(compilation.moduleGraph);
compilation.dependencyFactories.set(CommonJsSelfReferenceDependency, selfFactory), 
compilation.dependencyTemplates.set(CommonJsSelfReferenceDependency, new CommonJsSelfReferenceDependency.Template), 
compilation.dependencyFactories.set(ModuleDecoratorDependency, selfFactory), compilation.dependencyTemplates.set(ModuleDecoratorDependency, new ModuleDecoratorDependency.Template), 
compilation.hooks.runtimeRequirementInModule.for(RuntimeGlobals.harmonyModuleDecorator).tap("CommonJsPlugin", ((module, set) => {
set.add(RuntimeGlobals.module), set.add(RuntimeGlobals.requireScope);
})), compilation.hooks.runtimeRequirementInModule.for(RuntimeGlobals.nodeModuleDecorator).tap("CommonJsPlugin", ((module, set) => {
set.add(RuntimeGlobals.module), set.add(RuntimeGlobals.requireScope);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.harmonyModuleDecorator).tap("CommonJsPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new HarmonyModuleDecoratorRuntimeModule);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.nodeModuleDecorator).tap("CommonJsPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new NodeModuleDecoratorRuntimeModule);
}));
const handler = (parser, parserOptions) => {
(void 0 === parserOptions.commonjs || parserOptions.commonjs) && (parser.hooks.typeof.for("module").tap("CommonJsPlugin", toConstantDependency(parser, JSON.stringify("object"))), 
parser.hooks.expression.for("require.main").tap("CommonJsPlugin", toConstantDependency(parser, `${RuntimeGlobals.moduleCache}[${RuntimeGlobals.entryModuleId}]`, [ RuntimeGlobals.moduleCache, RuntimeGlobals.entryModuleId ])), 
parser.hooks.expression.for("module.loaded").tap("CommonJsPlugin", (expr => {
parser.state.module.buildInfo.moduleConcatenationBailout = "module.loaded";
const dep = new RuntimeRequirementsDependency([ RuntimeGlobals.moduleLoaded ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.expression.for("module.id").tap("CommonJsPlugin", (expr => {
parser.state.module.buildInfo.moduleConcatenationBailout = "module.id";
const dep = new RuntimeRequirementsDependency([ RuntimeGlobals.moduleId ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluateIdentifier.for("module.hot").tap("CommonJsPlugin", evaluateToIdentifier("module.hot", "module", (() => [ "hot" ]), null)), 
new CommonJsImportsParserPlugin(parserOptions).apply(parser), new CommonJsExportsParserPlugin(compilation.moduleGraph).apply(parser));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("CommonJsPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("CommonJsPlugin", handler);
}));
}
};
},
92890: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ContextDependency = __webpack_require__(97818), ContextDependencyTemplateAsRequireCall = __webpack_require__(31131);
class CommonJsRequireContextDependency extends ContextDependency {
constructor(options, range, valueRange, inShorthand, context) {
super(options, context), this.range = range, this.valueRange = valueRange, this.inShorthand = inShorthand;
}
get type() {
return "cjs require context";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.valueRange), write(this.inShorthand), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.valueRange = read(), this.inShorthand = read(), super.deserialize(context);
}
}
makeSerializable(CommonJsRequireContextDependency, "webpack/lib/dependencies/CommonJsRequireContextDependency"), 
CommonJsRequireContextDependency.Template = ContextDependencyTemplateAsRequireCall, 
module.exports = CommonJsRequireContextDependency;
},
26777: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyTemplateAsId = __webpack_require__(13714);
class CommonJsRequireDependency extends ModuleDependency {
constructor(request, range, context) {
super(request), this.range = range, this._context = context;
}
get type() {
return "cjs require";
}
get category() {
return "commonjs";
}
}
CommonJsRequireDependency.Template = ModuleDependencyTemplateAsId, makeSerializable(CommonJsRequireDependency, "webpack/lib/dependencies/CommonJsRequireDependency"), 
module.exports = CommonJsRequireDependency;
},
3256: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), {equals} = __webpack_require__(8579), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), NullDependency = __webpack_require__(52649);
class CommonJsSelfReferenceDependency extends NullDependency {
constructor(range, base, names, call) {
super(), this.range = range, this.base = base, this.names = names, this.call = call;
}
get type() {
return "cjs self exports reference";
}
get category() {
return "self";
}
getResourceIdentifier() {
return "self";
}
getReferencedExports(moduleGraph, runtime) {
return [ this.call ? this.names.slice(0, -1) : this.names ];
}
serialize(context) {
const {write} = context;
write(this.range), write(this.base), write(this.names), write(this.call), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.base = read(), this.names = read(), this.call = read(), 
super.deserialize(context);
}
}
makeSerializable(CommonJsSelfReferenceDependency, "webpack/lib/dependencies/CommonJsSelfReferenceDependency"), 
CommonJsSelfReferenceDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, moduleGraph, runtime, runtimeRequirements}) {
const dep = dependency;
let used, base;
if (used = 0 === dep.names.length ? dep.names : moduleGraph.getExportsInfo(module).getUsedName(dep.names, runtime), 
!used) throw new Error("Self-reference dependency has unused export name: This should not happen");
switch (dep.base) {
case "exports":
runtimeRequirements.add(RuntimeGlobals.exports), base = module.exportsArgument;
break;

case "module.exports":
runtimeRequirements.add(RuntimeGlobals.module), base = `${module.moduleArgument}.exports`;
break;

case "this":
runtimeRequirements.add(RuntimeGlobals.thisAsExports), base = "this";
break;

default:
throw new Error(`Unsupported base ${dep.base}`);
}
base === dep.base && equals(used, dep.names) || source.replace(dep.range[0], dep.range[1] - 1, `${base}${propertyAccess(used)}`);
}
}, module.exports = CommonJsSelfReferenceDependency;
},
30339: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class ConstDependency extends NullDependency {
constructor(expression, range, runtimeRequirements) {
super(), this.expression = expression, this.range = range, this.runtimeRequirements = runtimeRequirements ? new Set(runtimeRequirements) : null, 
this._hashUpdate = void 0;
}
updateHash(hash, context) {
if (void 0 === this._hashUpdate) {
let hashUpdate = this.range + "|" + this.expression;
if (this.runtimeRequirements) for (const item of this.runtimeRequirements) hashUpdate += "|", 
hashUpdate += item;
this._hashUpdate = hashUpdate;
}
hash.update(this._hashUpdate);
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !1;
}
serialize(context) {
const {write} = context;
write(this.expression), write(this.range), write(this.runtimeRequirements), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.expression = read(), this.range = read(), this.runtimeRequirements = read(), 
super.deserialize(context);
}
}
makeSerializable(ConstDependency, "webpack/lib/dependencies/ConstDependency"), ConstDependency.Template = class extends NullDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency;
if (dep.runtimeRequirements) for (const req of dep.runtimeRequirements) templateContext.runtimeRequirements.add(req);
"number" != typeof dep.range ? source.replace(dep.range[0], dep.range[1] - 1, dep.expression) : source.insert(dep.range, dep.expression);
}
}, module.exports = ConstDependency;
},
97818: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), DependencyTemplate = __webpack_require__(44515), makeSerializable = __webpack_require__(45898), getCriticalDependencyWarning = __webpack_require__(98216)((() => __webpack_require__(14663))), regExpToString = r => r ? r + "" : "";
class ContextDependency extends Dependency {
constructor(options, context) {
super(), this.options = options, this.userRequest = this.options && this.options.request, 
this.critical = !1, this.hadGlobalOrStickyRegExp = !1, this.options && (this.options.regExp.global || this.options.regExp.sticky) && (this.options = {
...this.options,
regExp: null
}, this.hadGlobalOrStickyRegExp = !0), this.request = void 0, this.range = void 0, 
this.valueRange = void 0, this.inShorthand = void 0, this.replaces = void 0, this._requestContext = context;
}
getContext() {
return this._requestContext;
}
get category() {
return "commonjs";
}
couldAffectReferencingModule() {
return !0;
}
getResourceIdentifier() {
return `context${this._requestContext || ""}|ctx request${this.options.request} ${this.options.recursive} ${regExpToString(this.options.regExp)} ${regExpToString(this.options.include)} ${regExpToString(this.options.exclude)} ${this.options.mode} ${this.options.chunkName} ${JSON.stringify(this.options.groupOptions)}`;
}
getWarnings(moduleGraph) {
let warnings = super.getWarnings(moduleGraph);
if (this.critical) {
warnings || (warnings = []);
const CriticalDependencyWarning = getCriticalDependencyWarning();
warnings.push(new CriticalDependencyWarning(this.critical));
}
if (this.hadGlobalOrStickyRegExp) {
warnings || (warnings = []);
const CriticalDependencyWarning = getCriticalDependencyWarning();
warnings.push(new CriticalDependencyWarning("Contexts can't use RegExps with the 'g' or 'y' flags."));
}
return warnings;
}
serialize(context) {
const {write} = context;
write(this.options), write(this.userRequest), write(this.critical), write(this.hadGlobalOrStickyRegExp), 
write(this.request), write(this._requestContext), write(this.range), write(this.valueRange), 
write(this.prepend), write(this.replaces), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.options = read(), this.userRequest = read(), this.critical = read(), this.hadGlobalOrStickyRegExp = read(), 
this.request = read(), this._requestContext = read(), this.range = read(), this.valueRange = read(), 
this.prepend = read(), this.replaces = read(), super.deserialize(context);
}
}
makeSerializable(ContextDependency, "webpack/lib/dependencies/ContextDependency"), 
ContextDependency.Template = DependencyTemplate, module.exports = ContextDependency;
},
52963: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const {parseResource} = __webpack_require__(63264), quoteMeta = str => str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&"), splitContextFromPrefix = prefix => {
const idx = prefix.lastIndexOf("/");
let context = ".";
return idx >= 0 && (context = prefix.slice(0, idx), prefix = `.${prefix.slice(idx)}`), 
{
context,
prefix
};
};
exports.create = (Dep, range, param, expr, options, contextOptions, parser, ...depArgs) => {
if (param.isTemplateString()) {
let prefixRaw = param.quasis[0].string, postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : "";
const valueRange = param.range, {context, prefix} = splitContextFromPrefix(prefixRaw), {path: postfix, query, fragment} = parseResource(postfixRaw, parser), innerQuasis = param.quasis.slice(1, param.quasis.length - 1), innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map((q => quoteMeta(q.string) + options.wrappedContextRegExp.source)).join(""), regExp = new RegExp(`^${quoteMeta(prefix)}${innerRegExp}${quoteMeta(postfix)}$`), dep = new Dep({
request: context + query + fragment,
recursive: options.wrappedContextRecursive,
regExp,
mode: "sync",
...contextOptions
}, range, valueRange, ...depArgs);
dep.loc = expr.loc;
const replaces = [];
return param.parts.forEach(((part, i) => {
if (i % 2 == 0) {
let range = part.range, value = part.string;
if ("cooked" === param.templateStringKind && (value = JSON.stringify(value), value = value.slice(1, value.length - 1)), 
0 === i) value = prefix, range = [ param.range[0], part.range[1] ], value = ("cooked" === param.templateStringKind ? "`" : "String.raw`") + value; else if (i === param.parts.length - 1) value = postfix, 
range = [ part.range[0], param.range[1] ], value += "`"; else if (part.expression && "TemplateElement" === part.expression.type && part.expression.value.raw === value) return;
replaces.push({
range,
value
});
} else parser.walkExpression(part.expression);
})), dep.replaces = replaces, dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression", 
dep;
}
if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {
let prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : "", postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : "";
const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null, postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null, valueRange = param.range, {context, prefix} = splitContextFromPrefix(prefixRaw), {path: postfix, query, fragment} = parseResource(postfixRaw, parser), regExp = new RegExp(`^${quoteMeta(prefix)}${options.wrappedContextRegExp.source}${quoteMeta(postfix)}$`), dep = new Dep({
request: context + query + fragment,
recursive: options.wrappedContextRecursive,
regExp,
mode: "sync",
...contextOptions
}, range, valueRange, ...depArgs);
dep.loc = expr.loc;
const replaces = [];
if (prefixRange && replaces.push({
range: prefixRange,
value: JSON.stringify(prefix)
}), postfixRange && replaces.push({
range: postfixRange,
value: JSON.stringify(postfix)
}), dep.replaces = replaces, dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression", 
parser && param.wrappedInnerExpressions) for (const part of param.wrappedInnerExpressions) part.expression && parser.walkExpression(part.expression);
return dep;
}
{
const dep = new Dep({
request: options.exprContextRequest,
recursive: options.exprContextRecursive,
regExp: options.exprContextRegExp,
mode: "sync",
...contextOptions
}, range, param.range, ...depArgs);
return dep.loc = expr.loc, dep.critical = options.exprContextCritical && "the request of a dependency is an expression", 
parser.walkExpression(param.expression), dep;
}
};
},
23324: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ContextDependency = __webpack_require__(97818);
class ContextDependencyTemplateAsId extends ContextDependency.Template {
apply(dependency, source, {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency, moduleExports = runtimeTemplate.moduleExports({
module: moduleGraph.getModule(dep),
chunkGraph,
request: dep.request,
weak: dep.weak,
runtimeRequirements
});
if (moduleGraph.getModule(dep)) if (dep.valueRange) {
if (Array.isArray(dep.replaces)) for (let i = 0; i < dep.replaces.length; i++) {
const rep = dep.replaces[i];
source.replace(rep.range[0], rep.range[1] - 1, rep.value);
}
source.replace(dep.valueRange[1], dep.range[1] - 1, ")"), source.replace(dep.range[0], dep.valueRange[0] - 1, `${moduleExports}.resolve(`);
} else source.replace(dep.range[0], dep.range[1] - 1, `${moduleExports}.resolve`); else source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
}
}
module.exports = ContextDependencyTemplateAsId;
},
31131: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ContextDependency = __webpack_require__(97818);
class ContextDependencyTemplateAsRequireCall extends ContextDependency.Template {
apply(dependency, source, {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency;
let moduleExports = runtimeTemplate.moduleExports({
module: moduleGraph.getModule(dep),
chunkGraph,
request: dep.request,
runtimeRequirements
});
if (dep.inShorthand && (moduleExports = `${dep.inShorthand}: ${moduleExports}`), 
moduleGraph.getModule(dep)) if (dep.valueRange) {
if (Array.isArray(dep.replaces)) for (let i = 0; i < dep.replaces.length; i++) {
const rep = dep.replaces[i];
source.replace(rep.range[0], rep.range[1] - 1, rep.value);
}
source.replace(dep.valueRange[1], dep.range[1] - 1, ")"), source.replace(dep.range[0], dep.valueRange[0] - 1, `${moduleExports}(`);
} else source.replace(dep.range[0], dep.range[1] - 1, moduleExports); else source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
}
}
module.exports = ContextDependencyTemplateAsRequireCall;
},
84407: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class ContextElementDependency extends ModuleDependency {
constructor(request, userRequest, typePrefix, category, referencedExports, context) {
super(request), this.referencedExports = referencedExports, this._typePrefix = typePrefix, 
this._category = category, this._context = context || void 0, userRequest && (this.userRequest = userRequest);
}
get type() {
return this._typePrefix ? `${this._typePrefix} context element` : "context element";
}
get category() {
return this._category;
}
getReferencedExports(moduleGraph, runtime) {
return this.referencedExports ? this.referencedExports.map((e => ({
name: e,
canMangle: !1
}))) : Dependency.EXPORTS_OBJECT_REFERENCED;
}
serialize(context) {
const {write} = context;
write(this._typePrefix), write(this._category), write(this.referencedExports), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this._typePrefix = read(), this._category = read(), this.referencedExports = read(), 
super.deserialize(context);
}
}
makeSerializable(ContextElementDependency, "webpack/lib/dependencies/ContextElementDependency"), 
module.exports = ContextElementDependency;
},
66869: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class CreateScriptUrlDependency extends NullDependency {
constructor(range) {
super(), this.range = range;
}
get type() {
return "create script url";
}
serialize(context) {
const {write} = context;
write(this.range), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), super.deserialize(context);
}
}
CreateScriptUrlDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeRequirements}) {
const dep = dependency;
runtimeRequirements.add(RuntimeGlobals.createScriptUrl), source.insert(dep.range[0], `${RuntimeGlobals.createScriptUrl}(`), 
source.insert(dep.range[1], ")");
}
}, makeSerializable(CreateScriptUrlDependency, "webpack/lib/dependencies/CreateScriptUrlDependency"), 
module.exports = CreateScriptUrlDependency;
},
14663: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), makeSerializable = __webpack_require__(45898);
class CriticalDependencyWarning extends WebpackError {
constructor(message) {
super(), this.name = "CriticalDependencyWarning", this.message = "Critical dependency: " + message;
}
}
makeSerializable(CriticalDependencyWarning, "webpack/lib/dependencies/CriticalDependencyWarning"), 
module.exports = CriticalDependencyWarning;
},
32037: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class CssExportDependency extends NullDependency {
constructor(name, value) {
super(), this.name = name, this.value = value;
}
get type() {
return "css :export";
}
getExports(moduleGraph) {
return {
exports: [ {
name: this.name,
canMangle: !0
} ],
dependencies: void 0
};
}
serialize(context) {
const {write} = context;
write(this.name), write(this.value), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.name = read(), this.value = read(), super.deserialize(context);
}
}
CssExportDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {cssExports}) {
const dep = dependency;
cssExports.set(dep.name, dep.value);
}
}, makeSerializable(CssExportDependency, "webpack/lib/dependencies/CssExportDependency"), 
module.exports = CssExportDependency;
},
55754: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class CssImportDependency extends ModuleDependency {
constructor(request, range, supports, media) {
super(request), this.range = range, this.supports = supports, this.media = media;
}
get type() {
return "css @import";
}
get category() {
return "css-import";
}
createIgnoredModule(context) {
return null;
}
}
CssImportDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency;
source.replace(dep.range[0], dep.range[1] - 1, "");
}
}, makeSerializable(CssImportDependency, "webpack/lib/dependencies/CssImportDependency"), 
module.exports = CssImportDependency;
},
1995: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class CssLocalIdentifierDependency extends NullDependency {
constructor(name, range, prefix = "") {
super(), this.name = name, this.range = range, this.prefix = prefix;
}
get type() {
return "css local identifier";
}
getExports(moduleGraph) {
return {
exports: [ {
name: this.name,
canMangle: !0
} ],
dependencies: void 0
};
}
serialize(context) {
const {write} = context;
write(this.name), write(this.range), write(this.prefix), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.name = read(), this.range = read(), this.prefix = read(), super.deserialize(context);
}
}
CssLocalIdentifierDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, moduleGraph, chunkGraph, runtime, runtimeTemplate, cssExports}) {
const dep = dependency, used = moduleGraph.getExportInfo(module, dep.name).getUsedName(dep.name, runtime), moduleId = chunkGraph.getModuleId(module), identifier = dep.prefix + (runtimeTemplate.outputOptions.uniqueName ? runtimeTemplate.outputOptions.uniqueName + "-" : "") + (used ? moduleId + "-" + used : "-");
source.replace(dep.range[0], dep.range[1] - 1, ((str, omitUnderscore) => {
const escaped = `${str}`.replace(/[^a-zA-Z0-9_\u0081-\uffff-]/g, (s => `\\${s}`));
return !omitUnderscore && /^(?!--)[0-9-]/.test(escaped) ? `_${escaped}` : escaped;
})(identifier, dep.prefix)), used && cssExports.set(used, identifier);
}
}, makeSerializable(CssLocalIdentifierDependency, "webpack/lib/dependencies/CssLocalIdentifierDependency"), 
module.exports = CssLocalIdentifierDependency;
},
87027: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898), CssLocalIdentifierDependency = __webpack_require__(1995);
class CssSelfLocalIdentifierDependency extends CssLocalIdentifierDependency {
constructor(name, range, prefix = "", declaredSet) {
super(name, range, prefix), this.declaredSet = declaredSet;
}
get type() {
return "css self local identifier";
}
get category() {
return "self";
}
getResourceIdentifier() {
return "self";
}
getExports(moduleGraph) {
if (!this.declaredSet || this.declaredSet.has(this.name)) return super.getExports(moduleGraph);
}
getReferencedExports(moduleGraph, runtime) {
return this.declaredSet && !this.declaredSet.has(this.name) ? Dependency.NO_EXPORTS_REFERENCED : [ [ this.name ] ];
}
serialize(context) {
const {write} = context;
write(this.declaredSet), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.declaredSet = read(), super.deserialize(context);
}
}
CssSelfLocalIdentifierDependency.Template = class extends CssLocalIdentifierDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency;
dep.declaredSet && !dep.declaredSet.has(dep.name) || super.apply(dependency, source, templateContext);
}
}, makeSerializable(CssSelfLocalIdentifierDependency, "webpack/lib/dependencies/CssSelfLocalIdentifierDependency"), 
module.exports = CssSelfLocalIdentifierDependency;
},
22058: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), memoize = __webpack_require__(98216), ModuleDependency = __webpack_require__(15216), getRawDataUrlModule = memoize((() => __webpack_require__(89779)));
class CssUrlDependency extends ModuleDependency {
constructor(request, range, cssFunctionKind) {
super(request), this.range = range, this.cssFunctionKind = cssFunctionKind;
}
get type() {
return "css url()";
}
get category() {
return "url";
}
createIgnoredModule(context) {
return new (getRawDataUrlModule())("data:,", "ignored-asset", "(ignored asset)");
}
serialize(context) {
const {write} = context;
write(this.cssFunctionKind), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.cssFunctionKind = read(), super.deserialize(context);
}
}
CssUrlDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, {runtime, moduleGraph, runtimeTemplate, codeGenerationResults}) {
const dep = dependency;
source.replace(dep.range[0], dep.range[1] - 1, `${dep.cssFunctionKind}(${(str => {
let countWhiteOrBracket = 0, countQuotation = 0, countApostrophe = 0;
for (let i = 0; i < str.length; i++) switch (str.charCodeAt(i)) {
case 9:
case 10:
case 32:
case 40:
case 41:
countWhiteOrBracket++;
break;

case 34:
countQuotation++;
break;

case 39:
countApostrophe++;
}
return countWhiteOrBracket < 2 ? str.replace(/[\n\t ()'"\\]/g, (m => `\\${m}`)) : countQuotation <= countApostrophe ? `"${str.replace(/[\n"\\]/g, (m => `\\${m}`))}"` : `'${str.replace(/[\n'\\]/g, (m => `\\${m}`))}'`;
})(runtimeTemplate.assetUrl({
publicPath: "",
runtime,
module: moduleGraph.getModule(dep),
codeGenerationResults
}))})`);
}
}, makeSerializable(CssUrlDependency, "webpack/lib/dependencies/CssUrlDependency"), 
module.exports = CssUrlDependency;
},
10307: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class DelegatedSourceDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "delegated source";
}
get category() {
return "esm";
}
}
makeSerializable(DelegatedSourceDependency, "webpack/lib/dependencies/DelegatedSourceDependency"), 
module.exports = DelegatedSourceDependency;
},
59968: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898);
class DllEntryDependency extends Dependency {
constructor(dependencies, name) {
super(), this.dependencies = dependencies, this.name = name;
}
get type() {
return "dll entry";
}
serialize(context) {
const {write} = context;
write(this.dependencies), write(this.name), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.dependencies = read(), this.name = read(), super.deserialize(context);
}
}
makeSerializable(DllEntryDependency, "webpack/lib/dependencies/DllEntryDependency"), 
module.exports = DllEntryDependency;
},
78722: (__unused_webpack_module, exports) => {
"use strict";
const parserStateExportsState = new WeakMap;
exports.bailout = parserState => {
const value = parserStateExportsState.get(parserState);
parserStateExportsState.set(parserState, !1), !0 === value && (parserState.module.buildMeta.exportsType = void 0, 
parserState.module.buildMeta.defaultObject = !1);
}, exports.enable = parserState => {
const value = parserStateExportsState.get(parserState);
!1 !== value && (parserStateExportsState.set(parserState, !0), !0 !== value && (parserState.module.buildMeta.exportsType = "default", 
parserState.module.buildMeta.defaultObject = "redirect"));
}, exports.setFlagged = parserState => {
if (!0 !== parserStateExportsState.get(parserState)) return;
const buildMeta = parserState.module.buildMeta;
"dynamic" !== buildMeta.exportsType && (buildMeta.exportsType = "flagged");
}, exports.setDynamic = parserState => {
!0 === parserStateExportsState.get(parserState) && (parserState.module.buildMeta.exportsType = "dynamic");
}, exports.isEnabled = parserState => !0 === parserStateExportsState.get(parserState);
},
74989: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class EntryDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "entry";
}
get category() {
return "esm";
}
}
makeSerializable(EntryDependency, "webpack/lib/dependencies/EntryDependency"), module.exports = EntryDependency;
},
14525: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {UsageState} = __webpack_require__(74603), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class ExportsInfoDependency extends NullDependency {
constructor(range, exportName, property) {
super(), this.range = range, this.exportName = exportName, this.property = property;
}
serialize(context) {
const {write} = context;
write(this.range), write(this.exportName), write(this.property), super.serialize(context);
}
static deserialize(context) {
const obj = new ExportsInfoDependency(context.read(), context.read(), context.read());
return obj.deserialize(context), obj;
}
}
makeSerializable(ExportsInfoDependency, "webpack/lib/dependencies/ExportsInfoDependency"), 
ExportsInfoDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, moduleGraph, runtime}) {
const dep = dependency, value = ((moduleGraph, module, exportName, property, runtime) => {
if (!exportName && "usedExports" === property) {
const usedExports = moduleGraph.getExportsInfo(module).getUsedExports(runtime);
return "boolean" == typeof usedExports || null == usedExports ? usedExports : Array.from(usedExports).sort();
}
switch (property) {
case "canMangle":
{
const exportsInfo = moduleGraph.getExportsInfo(module), exportInfo = exportsInfo.getExportInfo(exportName);
return exportInfo ? exportInfo.canMangle : exportsInfo.otherExportsInfo.canMangle;
}

case "used":
return moduleGraph.getExportsInfo(module).getUsed(exportName, runtime) !== UsageState.Unused;

case "useInfo":
{
const state = moduleGraph.getExportsInfo(module).getUsed(exportName, runtime);
switch (state) {
case UsageState.Used:
case UsageState.OnlyPropertiesUsed:
return !0;

case UsageState.Unused:
return !1;

case UsageState.NoInfo:
return;

case UsageState.Unknown:
return null;

default:
throw new Error(`Unexpected UsageState ${state}`);
}
}

case "provideInfo":
return moduleGraph.getExportsInfo(module).isExportProvided(exportName);
}
})(moduleGraph, module, dep.exportName, dep.property, runtime);
source.replace(dep.range[0], dep.range[1] - 1, void 0 === value ? "undefined" : JSON.stringify(value));
}
}, module.exports = ExportsInfoDependency;
},
29549: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Template = __webpack_require__(88370), makeSerializable = __webpack_require__(45898), HarmonyImportDependency = __webpack_require__(75015), NullDependency = __webpack_require__(52649);
class HarmonyAcceptDependency extends NullDependency {
constructor(range, dependencies, hasCallback) {
super(), this.range = range, this.dependencies = dependencies, this.hasCallback = hasCallback;
}
get type() {
return "accepted harmony modules";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.dependencies), write(this.hasCallback), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.dependencies = read(), this.hasCallback = read(), super.deserialize(context);
}
}
makeSerializable(HarmonyAcceptDependency, "webpack/lib/dependencies/HarmonyAcceptDependency"), 
HarmonyAcceptDependency.Template = class extends NullDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency, {module, runtime, runtimeRequirements, runtimeTemplate, moduleGraph, chunkGraph} = templateContext, content = dep.dependencies.map((dependency => {
const referencedModule = moduleGraph.getModule(dependency);
return {
dependency,
runtimeCondition: !!referencedModule && HarmonyImportDependency.Template.getImportEmittedRuntime(module, referencedModule)
};
})).filter((({runtimeCondition}) => !1 !== runtimeCondition)).map((({dependency, runtimeCondition}) => {
const condition = runtimeTemplate.runtimeConditionExpression({
chunkGraph,
runtime,
runtimeCondition,
runtimeRequirements
}), s = dependency.getImportStatement(!0, templateContext), code = s[0] + s[1];
return "true" !== condition ? `if (${condition}) {\n${Template.indent(code)}\n}\n` : code;
})).join("");
if (dep.hasCallback) return void (runtimeTemplate.supportsArrowFunction() ? (source.insert(dep.range[0], `__WEBPACK_OUTDATED_DEPENDENCIES__ => { ${content}(`), 
source.insert(dep.range[1], ")(__WEBPACK_OUTDATED_DEPENDENCIES__); }")) : (source.insert(dep.range[0], `function(__WEBPACK_OUTDATED_DEPENDENCIES__) { ${content}(`), 
source.insert(dep.range[1], ")(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this)")));
const arrow = runtimeTemplate.supportsArrowFunction();
source.insert(dep.range[1] - .5, `, ${arrow ? "() =>" : "function()"} { ${content} }`);
}
}, module.exports = HarmonyAcceptDependency;
},
77337: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), HarmonyImportDependency = __webpack_require__(75015), NullDependency = __webpack_require__(52649);
class HarmonyAcceptImportDependency extends HarmonyImportDependency {
constructor(request) {
super(request, NaN), this.weak = !0;
}
get type() {
return "harmony accept";
}
}
makeSerializable(HarmonyAcceptImportDependency, "webpack/lib/dependencies/HarmonyAcceptImportDependency"), 
HarmonyAcceptImportDependency.Template = NullDependency.Template, module.exports = HarmonyAcceptImportDependency;
},
35285: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {UsageState} = __webpack_require__(74603), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class HarmonyCompatibilityDependency extends NullDependency {
get type() {
return "harmony export header";
}
}
makeSerializable(HarmonyCompatibilityDependency, "webpack/lib/dependencies/HarmonyCompatibilityDependency"), 
HarmonyCompatibilityDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, runtimeTemplate, moduleGraph, initFragments, runtimeRequirements, runtime, concatenationScope}) {
if (concatenationScope) return;
if (moduleGraph.getExportsInfo(module).getReadOnlyExportInfo("__esModule").getUsed(runtime) !== UsageState.Unused) {
const content = runtimeTemplate.defineEsModuleFlagStatement({
exportsArgument: module.exportsArgument,
runtimeRequirements
});
initFragments.push(new InitFragment(content, InitFragment.STAGE_HARMONY_EXPORTS, 0, "harmony compatibility"));
}
moduleGraph.isAsync(module) && (runtimeRequirements.add(RuntimeGlobals.module), 
runtimeRequirements.add(RuntimeGlobals.asyncModule), initFragments.push(new InitFragment(runtimeTemplate.supportsArrowFunction() ? `${RuntimeGlobals.asyncModule}(${module.moduleArgument}, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n` : `${RuntimeGlobals.asyncModule}(${module.moduleArgument}, async function (__webpack_handle_async_dependencies__, __webpack_async_result__) { try {\n`, InitFragment.STAGE_ASYNC_BOUNDARY, 0, void 0, `\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }${module.buildMeta.async ? ", 1" : ""});`)));
}
}, module.exports = HarmonyCompatibilityDependency;
},
76334: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const DynamicExports = __webpack_require__(78722), HarmonyCompatibilityDependency = __webpack_require__(35285), HarmonyExports = __webpack_require__(60836);
module.exports = class {
constructor(options) {
const {topLevelAwait = !1} = options || {};
this.topLevelAwait = topLevelAwait;
}
apply(parser) {
parser.hooks.program.tap("HarmonyDetectionParserPlugin", (ast => {
const isStrictHarmony = "javascript/esm" === parser.state.module.type;
if (isStrictHarmony || ast.body.some((statement => "ImportDeclaration" === statement.type || "ExportDefaultDeclaration" === statement.type || "ExportNamedDeclaration" === statement.type || "ExportAllDeclaration" === statement.type))) {
const module = parser.state.module, compatDep = new HarmonyCompatibilityDependency;
compatDep.loc = {
start: {
line: -1,
column: 0
},
end: {
line: -1,
column: 0
},
index: -3
}, module.addPresentationalDependency(compatDep), DynamicExports.bailout(parser.state), 
HarmonyExports.enable(parser.state, isStrictHarmony), parser.scope.isStrict = !0;
}
})), parser.hooks.topLevelAwait.tap("HarmonyDetectionParserPlugin", (() => {
const module = parser.state.module;
if (!this.topLevelAwait) throw new Error("The top-level-await experiment is not enabled (set experiments.topLevelAwait: true to enabled it)");
if (!HarmonyExports.isEnabled(parser.state)) throw new Error("Top-level-await is only supported in EcmaScript Modules");
module.buildMeta.async = !0;
}));
const skipInHarmony = () => {
if (HarmonyExports.isEnabled(parser.state)) return !0;
}, nullInHarmony = () => {
if (HarmonyExports.isEnabled(parser.state)) return null;
}, nonHarmonyIdentifiers = [ "define", "exports" ];
for (const identifier of nonHarmonyIdentifiers) parser.hooks.evaluateTypeof.for(identifier).tap("HarmonyDetectionParserPlugin", nullInHarmony), 
parser.hooks.typeof.for(identifier).tap("HarmonyDetectionParserPlugin", skipInHarmony), 
parser.hooks.evaluate.for(identifier).tap("HarmonyDetectionParserPlugin", nullInHarmony), 
parser.hooks.expression.for(identifier).tap("HarmonyDetectionParserPlugin", skipInHarmony), 
parser.hooks.call.for(identifier).tap("HarmonyDetectionParserPlugin", skipInHarmony);
}
};
},
43613: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), HarmonyImportSpecifierDependency = __webpack_require__(68081);
class HarmonyEvaluatedImportSpecifierDependency extends HarmonyImportSpecifierDependency {
constructor(request, sourceOrder, ids, name, range, assertions, operator) {
super(request, sourceOrder, ids, name, range, !1, assertions), this.operator = operator;
}
get type() {
return `evaluated X ${this.operator} harmony import specifier`;
}
serialize(context) {
super.serialize(context);
const {write} = context;
write(this.operator);
}
deserialize(context) {
super.deserialize(context);
const {read} = context;
this.operator = read();
}
}
makeSerializable(HarmonyEvaluatedImportSpecifierDependency, "webpack/lib/dependencies/HarmonyEvaluatedImportSpecifierDependency"), 
HarmonyEvaluatedImportSpecifierDependency.Template = class extends HarmonyImportSpecifierDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency, {module, moduleGraph, runtime} = templateContext, connection = moduleGraph.getConnection(dep);
if (connection && !connection.isTargetActive(runtime)) return;
const exportsInfo = moduleGraph.getExportsInfo(connection.module), ids = dep.getIds(moduleGraph);
let value;
switch (connection.module.getExportsType(moduleGraph, module.buildMeta.strictHarmonyModule)) {
case "default-with-named":
value = "default" === ids[0] ? 1 === ids.length || exportsInfo.isExportProvided(ids.slice(1)) : exportsInfo.isExportProvided(ids);
break;

case "namespace":
value = "__esModule" === ids[0] ? 1 === ids.length || void 0 : exportsInfo.isExportProvided(ids);
break;

case "dynamic":
"default" !== ids[0] && (value = exportsInfo.isExportProvided(ids));
}
if ("boolean" == typeof value) source.replace(dep.range[0], dep.range[1] - 1, ` ${value}`); else {
const usedName = exportsInfo.getUsedName(ids, runtime), code = this._getCodeForIds(dep, source, templateContext, ids.slice(0, -1));
source.replace(dep.range[0], dep.range[1] - 1, `${usedName ? JSON.stringify(usedName[usedName.length - 1]) : '""'} in ${code}`);
}
}
}, module.exports = HarmonyEvaluatedImportSpecifierDependency;
},
69420: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const InnerGraph = __webpack_require__(93639), ConstDependency = __webpack_require__(30339), HarmonyExportExpressionDependency = __webpack_require__(30146), HarmonyExportHeaderDependency = __webpack_require__(40366), HarmonyExportImportedSpecifierDependency = __webpack_require__(59411), HarmonyExportSpecifierDependency = __webpack_require__(61750), {ExportPresenceModes} = __webpack_require__(75015), {harmonySpecifierTag, getAssertions} = __webpack_require__(20529), HarmonyImportSideEffectDependency = __webpack_require__(39052), {HarmonyStarExportsList} = HarmonyExportImportedSpecifierDependency;
module.exports = class {
constructor(options) {
this.exportPresenceMode = void 0 !== options.reexportExportsPresence ? ExportPresenceModes.fromUserOption(options.reexportExportsPresence) : void 0 !== options.exportsPresence ? ExportPresenceModes.fromUserOption(options.exportsPresence) : options.strictExportPresence ? ExportPresenceModes.ERROR : ExportPresenceModes.AUTO;
}
apply(parser) {
const {exportPresenceMode} = this;
parser.hooks.export.tap("HarmonyExportDependencyParserPlugin", (statement => {
const dep = new HarmonyExportHeaderDependency(statement.declaration && statement.declaration.range, statement.range);
return dep.loc = Object.create(statement.loc), dep.loc.index = -1, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.exportImport.tap("HarmonyExportDependencyParserPlugin", ((statement, source) => {
parser.state.lastHarmonyImportOrder = (parser.state.lastHarmonyImportOrder || 0) + 1;
const clearDep = new ConstDependency("", statement.range);
clearDep.loc = Object.create(statement.loc), clearDep.loc.index = -1, parser.state.module.addPresentationalDependency(clearDep);
const sideEffectDep = new HarmonyImportSideEffectDependency(source, parser.state.lastHarmonyImportOrder, getAssertions(statement));
return sideEffectDep.loc = Object.create(statement.loc), sideEffectDep.loc.index = -1, 
parser.state.current.addDependency(sideEffectDep), !0;
})), parser.hooks.exportExpression.tap("HarmonyExportDependencyParserPlugin", ((statement, expr) => {
const isFunctionDeclaration = "FunctionDeclaration" === expr.type, comments = parser.getComments([ statement.range[0], expr.range[0] ]), dep = new HarmonyExportExpressionDependency(expr.range, statement.range, comments.map((c => {
switch (c.type) {
case "Block":
return `/*${c.value}*/`;

case "Line":
return `//${c.value}\n`;
}
return "";
})).join(""), expr.type.endsWith("Declaration") && expr.id ? expr.id.name : isFunctionDeclaration ? {
id: expr.id ? expr.id.name : void 0,
range: [ expr.range[0], expr.params.length > 0 ? expr.params[0].range[0] : expr.body.range[0] ],
prefix: `${expr.async ? "async " : ""}function${expr.generator ? "*" : ""} `,
suffix: "(" + (expr.params.length > 0 ? "" : ") ")
} : void 0);
return dep.loc = Object.create(statement.loc), dep.loc.index = -1, parser.state.current.addDependency(dep), 
InnerGraph.addVariableUsage(parser, expr.type.endsWith("Declaration") && expr.id ? expr.id.name : "*default*", "default"), 
!0;
})), parser.hooks.exportSpecifier.tap("HarmonyExportDependencyParserPlugin", ((statement, id, name, idx) => {
const settings = parser.getTagData(id, harmonySpecifierTag);
let dep;
const harmonyNamedExports = parser.state.harmonyNamedExports = parser.state.harmonyNamedExports || new Set;
return harmonyNamedExports.add(name), InnerGraph.addVariableUsage(parser, id, name), 
dep = settings ? new HarmonyExportImportedSpecifierDependency(settings.source, settings.sourceOrder, settings.ids, name, harmonyNamedExports, null, exportPresenceMode, null, settings.assertions) : new HarmonyExportSpecifierDependency(id, name), 
dep.loc = Object.create(statement.loc), dep.loc.index = idx, parser.state.current.addDependency(dep), 
!0;
})), parser.hooks.exportImportSpecifier.tap("HarmonyExportDependencyParserPlugin", ((statement, source, id, name, idx) => {
const harmonyNamedExports = parser.state.harmonyNamedExports = parser.state.harmonyNamedExports || new Set;
let harmonyStarExports = null;
name ? harmonyNamedExports.add(name) : harmonyStarExports = parser.state.harmonyStarExports = parser.state.harmonyStarExports || new HarmonyStarExportsList;
const dep = new HarmonyExportImportedSpecifierDependency(source, parser.state.lastHarmonyImportOrder, id ? [ id ] : [], name, harmonyNamedExports, harmonyStarExports && harmonyStarExports.slice(), exportPresenceMode, harmonyStarExports);
return harmonyStarExports && harmonyStarExports.push(dep), dep.loc = Object.create(statement.loc), 
dep.loc.index = idx, parser.state.current.addDependency(dep), !0;
}));
}
};
},
30146: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConcatenationScope = __webpack_require__(87291), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), HarmonyExportInitFragment = __webpack_require__(16515), NullDependency = __webpack_require__(52649);
class HarmonyExportExpressionDependency extends NullDependency {
constructor(range, rangeStatement, prefix, declarationId) {
super(), this.range = range, this.rangeStatement = rangeStatement, this.prefix = prefix, 
this.declarationId = declarationId;
}
get type() {
return "harmony export expression";
}
getExports(moduleGraph) {
return {
exports: [ "default" ],
priority: 1,
terminalBinding: !0,
dependencies: void 0
};
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !1;
}
serialize(context) {
const {write} = context;
write(this.range), write(this.rangeStatement), write(this.prefix), write(this.declarationId), 
super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.rangeStatement = read(), this.prefix = read(), this.declarationId = read(), 
super.deserialize(context);
}
}
makeSerializable(HarmonyExportExpressionDependency, "webpack/lib/dependencies/HarmonyExportExpressionDependency"), 
HarmonyExportExpressionDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, moduleGraph, runtimeTemplate, runtimeRequirements, initFragments, runtime, concatenationScope}) {
const dep = dependency, {declarationId} = dep, exportsName = module.exportsArgument;
if (declarationId) {
let name;
if ("string" == typeof declarationId ? name = declarationId : (name = ConcatenationScope.DEFAULT_EXPORT, 
source.replace(declarationId.range[0], declarationId.range[1] - 1, `${declarationId.prefix}${name}${declarationId.suffix}`)), 
concatenationScope) concatenationScope.registerExport("default", name); else {
const used = moduleGraph.getExportsInfo(module).getUsedName("default", runtime);
if (used) {
const map = new Map;
map.set(used, `/* export default binding */ ${name}`), initFragments.push(new HarmonyExportInitFragment(exportsName, map));
}
}
source.replace(dep.rangeStatement[0], dep.range[0] - 1, `/* harmony default export */ ${dep.prefix}`);
} else {
let content;
const name = ConcatenationScope.DEFAULT_EXPORT;
if (runtimeTemplate.supportsConst()) if (content = `/* harmony default export */ const ${name} = `, 
concatenationScope) concatenationScope.registerExport("default", name); else {
const used = moduleGraph.getExportsInfo(module).getUsedName("default", runtime);
if (used) {
runtimeRequirements.add(RuntimeGlobals.exports);
const map = new Map;
map.set(used, name), initFragments.push(new HarmonyExportInitFragment(exportsName, map));
} else content = `/* unused harmony default export */ var ${name} = `;
} else if (concatenationScope) content = `/* harmony default export */ var ${name} = `, 
concatenationScope.registerExport("default", name); else {
const used = moduleGraph.getExportsInfo(module).getUsedName("default", runtime);
used ? (runtimeRequirements.add(RuntimeGlobals.exports), content = `/* harmony default export */ ${exportsName}[${JSON.stringify(used)}] = `) : content = `/* unused harmony default export */ var ${name} = `;
}
if (dep.range) return source.replace(dep.rangeStatement[0], dep.range[0] - 1, content + "(" + dep.prefix), 
void source.replace(dep.range[1], dep.rangeStatement[1] - .5, ");");
source.replace(dep.rangeStatement[0], dep.rangeStatement[1] - 1, content);
}
}
}, module.exports = HarmonyExportExpressionDependency;
},
40366: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class HarmonyExportHeaderDependency extends NullDependency {
constructor(range, rangeStatement) {
super(), this.range = range, this.rangeStatement = rangeStatement;
}
get type() {
return "harmony export header";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.rangeStatement), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.rangeStatement = read(), super.deserialize(context);
}
}
makeSerializable(HarmonyExportHeaderDependency, "webpack/lib/dependencies/HarmonyExportHeaderDependency"), 
HarmonyExportHeaderDependency.Template = class extends NullDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency, replaceUntil = dep.range ? dep.range[0] - 1 : dep.rangeStatement[1] - 1;
source.replace(dep.rangeStatement[0], replaceUntil, "");
}
}, module.exports = HarmonyExportHeaderDependency;
},
59411: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), {UsageState} = __webpack_require__(74603), HarmonyLinkingError = __webpack_require__(7729), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), {countIterable} = __webpack_require__(30416), {first, combine} = __webpack_require__(73974), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), {getRuntimeKey, keyToRuntime} = __webpack_require__(14372), HarmonyExportInitFragment = __webpack_require__(16515), HarmonyImportDependency = __webpack_require__(75015), processExportInfo = __webpack_require__(97556), {ExportPresenceModes} = HarmonyImportDependency, idsSymbol = Symbol("HarmonyExportImportedSpecifierDependency.ids");
class NormalReexportItem {
constructor(name, ids, exportInfo, checked, hidden) {
this.name = name, this.ids = ids, this.exportInfo = exportInfo, this.checked = checked, 
this.hidden = hidden;
}
}
class ExportMode {
constructor(type) {
this.type = type, this.items = null, this.name = null, this.partialNamespaceExportInfo = null, 
this.ignored = null, this.hidden = null, this.userRequest = null, this.fakeType = 0;
}
}
const determineExportAssignments = (moduleGraph, dependencies, additionalDependency) => {
const names = new Set, dependencyIndices = [];
additionalDependency && (dependencies = dependencies.concat(additionalDependency));
for (const dep of dependencies) {
const i = dependencyIndices.length;
dependencyIndices[i] = names.size;
const otherImportedModule = moduleGraph.getModule(dep);
if (otherImportedModule) {
const exportsInfo = moduleGraph.getExportsInfo(otherImportedModule);
for (const exportInfo of exportsInfo.exports) !0 !== exportInfo.provided || "default" === exportInfo.name || names.has(exportInfo.name) || (names.add(exportInfo.name), 
dependencyIndices[i] = names.size);
}
}
return dependencyIndices.push(names.size), {
names: Array.from(names),
dependencyIndices
};
}, findDependencyForName = ({names, dependencyIndices}, name, dependencies) => {
const dependenciesIt = dependencies[Symbol.iterator](), dependencyIndicesIt = dependencyIndices[Symbol.iterator]();
let dependenciesItResult = dependenciesIt.next(), dependencyIndicesItResult = dependencyIndicesIt.next();
if (!dependencyIndicesItResult.done) for (let i = 0; i < names.length; i++) {
for (;i >= dependencyIndicesItResult.value; ) if (dependenciesItResult = dependenciesIt.next(), 
dependencyIndicesItResult = dependencyIndicesIt.next(), dependencyIndicesItResult.done) return;
if (names[i] === name) return dependenciesItResult.value;
}
}, getMode = (moduleGraph, dep, runtimeKey) => {
const importedModule = moduleGraph.getModule(dep);
if (!importedModule) {
const mode = new ExportMode("missing");
return mode.userRequest = dep.userRequest, mode;
}
const name = dep.name, runtime = keyToRuntime(runtimeKey), parentModule = moduleGraph.getParentModule(dep), exportsInfo = moduleGraph.getExportsInfo(parentModule);
if (name ? exportsInfo.getUsed(name, runtime) === UsageState.Unused : !1 === exportsInfo.isUsed(runtime)) {
const mode = new ExportMode("unused");
return mode.name = name || "*", mode;
}
const importedExportsType = importedModule.getExportsType(moduleGraph, parentModule.buildMeta.strictHarmonyModule), ids = dep.getIds(moduleGraph);
if (name && ids.length > 0 && "default" === ids[0]) switch (importedExportsType) {
case "dynamic":
{
const mode = new ExportMode("reexport-dynamic-default");
return mode.name = name, mode;
}

case "default-only":
case "default-with-named":
{
const exportInfo = exportsInfo.getReadOnlyExportInfo(name), mode = new ExportMode("reexport-named-default");
return mode.name = name, mode.partialNamespaceExportInfo = exportInfo, mode;
}
}
if (name) {
let mode;
const exportInfo = exportsInfo.getReadOnlyExportInfo(name);
if (ids.length > 0) if ("default-only" === importedExportsType) mode = new ExportMode("reexport-undefined"), 
mode.name = name; else mode = new ExportMode("normal-reexport"), mode.items = [ new NormalReexportItem(name, ids, exportInfo, !1, !1) ]; else switch (importedExportsType) {
case "default-only":
mode = new ExportMode("reexport-fake-namespace-object"), mode.name = name, mode.partialNamespaceExportInfo = exportInfo, 
mode.fakeType = 0;
break;

case "default-with-named":
mode = new ExportMode("reexport-fake-namespace-object"), mode.name = name, mode.partialNamespaceExportInfo = exportInfo, 
mode.fakeType = 2;
break;

default:
mode = new ExportMode("reexport-namespace-object"), mode.name = name, mode.partialNamespaceExportInfo = exportInfo;
}
return mode;
}
const {ignoredExports, exports, checked, hidden} = dep.getStarReexports(moduleGraph, runtime, exportsInfo, importedModule);
if (!exports) {
const mode = new ExportMode("dynamic-reexport");
return mode.ignored = ignoredExports, mode.hidden = hidden, mode;
}
if (0 === exports.size) {
const mode = new ExportMode("empty-star");
return mode.hidden = hidden, mode;
}
const mode = new ExportMode("normal-reexport");
if (mode.items = Array.from(exports, (exportName => new NormalReexportItem(exportName, [ exportName ], exportsInfo.getReadOnlyExportInfo(exportName), checked.has(exportName), !1))), 
void 0 !== hidden) for (const exportName of hidden) mode.items.push(new NormalReexportItem(exportName, [ exportName ], exportsInfo.getReadOnlyExportInfo(exportName), !1, !0));
return mode;
};
class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
constructor(request, sourceOrder, ids, name, activeExports, otherStarExports, exportPresenceMode, allStarExports, assertions) {
super(request, sourceOrder, assertions), this.ids = ids, this.name = name, this.activeExports = activeExports, 
this.otherStarExports = otherStarExports, this.exportPresenceMode = exportPresenceMode, 
this.allStarExports = allStarExports;
}
couldAffectReferencingModule() {
return Dependency.TRANSITIVE;
}
get id() {
throw new Error("id was renamed to ids and type changed to string[]");
}
getId() {
throw new Error("id was renamed to ids and type changed to string[]");
}
setId() {
throw new Error("id was renamed to ids and type changed to string[]");
}
get type() {
return "harmony export imported specifier";
}
getIds(moduleGraph) {
return moduleGraph.getMeta(this)[idsSymbol] || this.ids;
}
setIds(moduleGraph, ids) {
moduleGraph.getMeta(this)[idsSymbol] = ids;
}
getMode(moduleGraph, runtime) {
return moduleGraph.dependencyCacheProvide(this, getRuntimeKey(runtime), getMode);
}
getStarReexports(moduleGraph, runtime, exportsInfo = moduleGraph.getExportsInfo(moduleGraph.getParentModule(this)), importedModule = moduleGraph.getModule(this)) {
const importedExportsInfo = moduleGraph.getExportsInfo(importedModule), noExtraExports = !1 === importedExportsInfo.otherExportsInfo.provided, noExtraImports = exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused, ignoredExports = new Set([ "default", ...this.activeExports ]);
let hiddenExports;
const otherStarExports = this._discoverActiveExportsFromOtherStarExports(moduleGraph);
if (void 0 !== otherStarExports) {
hiddenExports = new Set;
for (let i = 0; i < otherStarExports.namesSlice; i++) hiddenExports.add(otherStarExports.names[i]);
for (const e of ignoredExports) hiddenExports.delete(e);
}
if (!noExtraExports && !noExtraImports) return {
ignoredExports,
hidden: hiddenExports
};
const exports = new Set, checked = new Set, hidden = void 0 !== hiddenExports ? new Set : void 0;
if (noExtraImports) for (const exportInfo of exportsInfo.orderedExports) {
const name = exportInfo.name;
if (ignoredExports.has(name)) continue;
if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
const importedExportInfo = importedExportsInfo.getReadOnlyExportInfo(name);
!1 !== importedExportInfo.provided && (void 0 !== hiddenExports && hiddenExports.has(name) ? hidden.add(name) : (exports.add(name), 
!0 !== importedExportInfo.provided && checked.add(name)));
} else if (noExtraExports) for (const importedExportInfo of importedExportsInfo.orderedExports) {
const name = importedExportInfo.name;
if (ignoredExports.has(name)) continue;
if (!1 === importedExportInfo.provided) continue;
exportsInfo.getReadOnlyExportInfo(name).getUsed(runtime) !== UsageState.Unused && (void 0 !== hiddenExports && hiddenExports.has(name) ? hidden.add(name) : (exports.add(name), 
!0 !== importedExportInfo.provided && checked.add(name)));
}
return {
ignoredExports,
exports,
checked,
hidden
};
}
getCondition(moduleGraph) {
return (connection, runtime) => {
const mode = this.getMode(moduleGraph, runtime);
return "unused" !== mode.type && "empty-star" !== mode.type;
};
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !1;
}
getReferencedExports(moduleGraph, runtime) {
const mode = this.getMode(moduleGraph, runtime);
switch (mode.type) {
case "missing":
case "unused":
case "empty-star":
case "reexport-undefined":
return Dependency.NO_EXPORTS_REFERENCED;

case "reexport-dynamic-default":
case "dynamic-reexport":
return Dependency.EXPORTS_OBJECT_REFERENCED;

case "reexport-named-default":
{
if (!mode.partialNamespaceExportInfo) return Dependency.EXPORTS_OBJECT_REFERENCED;
const referencedExports = [];
return processExportInfo(runtime, referencedExports, [], mode.partialNamespaceExportInfo), 
referencedExports;
}

case "reexport-namespace-object":
case "reexport-fake-namespace-object":
{
if (!mode.partialNamespaceExportInfo) return Dependency.EXPORTS_OBJECT_REFERENCED;
const referencedExports = [];
return processExportInfo(runtime, referencedExports, [], mode.partialNamespaceExportInfo, "reexport-fake-namespace-object" === mode.type), 
referencedExports;
}

case "normal-reexport":
{
const referencedExports = [];
for (const {ids, exportInfo, hidden} of mode.items) hidden || processExportInfo(runtime, referencedExports, ids, exportInfo, !1);
return referencedExports;
}

default:
throw new Error(`Unknown mode ${mode.type}`);
}
}
_discoverActiveExportsFromOtherStarExports(moduleGraph) {
if (!this.otherStarExports) return;
const i = "length" in this.otherStarExports ? this.otherStarExports.length : countIterable(this.otherStarExports);
if (0 === i) return;
if (this.allStarExports) {
const {names, dependencyIndices} = moduleGraph.cached(determineExportAssignments, this.allStarExports.dependencies);
return {
names,
namesSlice: dependencyIndices[i - 1],
dependencyIndices,
dependencyIndex: i
};
}
const {names, dependencyIndices} = moduleGraph.cached(determineExportAssignments, this.otherStarExports, this);
return {
names,
namesSlice: dependencyIndices[i - 1],
dependencyIndices,
dependencyIndex: i
};
}
getExports(moduleGraph) {
const mode = this.getMode(moduleGraph, void 0);
switch (mode.type) {
case "missing":
return;

case "dynamic-reexport":
{
const from = moduleGraph.getConnection(this);
return {
exports: !0,
from,
canMangle: !1,
excludeExports: mode.hidden ? combine(mode.ignored, mode.hidden) : mode.ignored,
hideExports: mode.hidden,
dependencies: [ from.module ]
};
}

case "empty-star":
return {
exports: [],
hideExports: mode.hidden,
dependencies: [ moduleGraph.getModule(this) ]
};

case "normal-reexport":
{
const from = moduleGraph.getConnection(this);
return {
exports: Array.from(mode.items, (item => ({
name: item.name,
from,
export: item.ids,
hidden: item.hidden
}))),
priority: 1,
dependencies: [ from.module ]
};
}

case "reexport-dynamic-default":
{
const from = moduleGraph.getConnection(this);
return {
exports: [ {
name: mode.name,
from,
export: [ "default" ]
} ],
priority: 1,
dependencies: [ from.module ]
};
}

case "reexport-undefined":
return {
exports: [ mode.name ],
dependencies: [ moduleGraph.getModule(this) ]
};

case "reexport-fake-namespace-object":
{
const from = moduleGraph.getConnection(this);
return {
exports: [ {
name: mode.name,
from,
export: null,
exports: [ {
name: "default",
canMangle: !1,
from,
export: null
} ]
} ],
priority: 1,
dependencies: [ from.module ]
};
}

case "reexport-namespace-object":
{
const from = moduleGraph.getConnection(this);
return {
exports: [ {
name: mode.name,
from,
export: null
} ],
priority: 1,
dependencies: [ from.module ]
};
}

case "reexport-named-default":
{
const from = moduleGraph.getConnection(this);
return {
exports: [ {
name: mode.name,
from,
export: [ "default" ]
} ],
priority: 1,
dependencies: [ from.module ]
};
}

default:
throw new Error(`Unknown mode ${mode.type}`);
}
}
_getEffectiveExportPresenceLevel(moduleGraph) {
return this.exportPresenceMode !== ExportPresenceModes.AUTO ? this.exportPresenceMode : moduleGraph.getParentModule(this).buildMeta.strictHarmonyModule ? ExportPresenceModes.ERROR : ExportPresenceModes.WARN;
}
getWarnings(moduleGraph) {
return this._getEffectiveExportPresenceLevel(moduleGraph) === ExportPresenceModes.WARN ? this._getErrors(moduleGraph) : null;
}
getErrors(moduleGraph) {
return this._getEffectiveExportPresenceLevel(moduleGraph) === ExportPresenceModes.ERROR ? this._getErrors(moduleGraph) : null;
}
_getErrors(moduleGraph) {
const ids = this.getIds(moduleGraph);
let errors = this.getLinkingErrors(moduleGraph, ids, `(reexported as '${this.name}')`);
if (0 === ids.length && null === this.name) {
const potentialConflicts = this._discoverActiveExportsFromOtherStarExports(moduleGraph);
if (potentialConflicts && potentialConflicts.namesSlice > 0) {
const ownNames = new Set(potentialConflicts.names.slice(potentialConflicts.namesSlice, potentialConflicts.dependencyIndices[potentialConflicts.dependencyIndex])), importedModule = moduleGraph.getModule(this);
if (importedModule) {
const exportsInfo = moduleGraph.getExportsInfo(importedModule), conflicts = new Map;
for (const exportInfo of exportsInfo.orderedExports) {
if (!0 !== exportInfo.provided) continue;
if ("default" === exportInfo.name) continue;
if (this.activeExports.has(exportInfo.name)) continue;
if (ownNames.has(exportInfo.name)) continue;
const conflictingDependency = findDependencyForName(potentialConflicts, exportInfo.name, this.allStarExports ? this.allStarExports.dependencies : [ ...this.otherStarExports, this ]);
if (!conflictingDependency) continue;
const target = exportInfo.getTerminalBinding(moduleGraph);
if (!target) continue;
const conflictingModule = moduleGraph.getModule(conflictingDependency);
if (conflictingModule === importedModule) continue;
const conflictingTarget = moduleGraph.getExportInfo(conflictingModule, exportInfo.name).getTerminalBinding(moduleGraph);
if (!conflictingTarget) continue;
if (target === conflictingTarget) continue;
const list = conflicts.get(conflictingDependency.request);
void 0 === list ? conflicts.set(conflictingDependency.request, [ exportInfo.name ]) : list.push(exportInfo.name);
}
for (const [request, exports] of conflicts) errors || (errors = []), errors.push(new HarmonyLinkingError(`The requested module '${this.request}' contains conflicting star exports for the ${exports.length > 1 ? "names" : "name"} ${exports.map((e => `'${e}'`)).join(", ")} with the previous requested module '${request}'`));
}
}
}
return errors;
}
serialize(context) {
const {write, setCircularReference} = context;
setCircularReference(this), write(this.ids), write(this.name), write(this.activeExports), 
write(this.otherStarExports), write(this.exportPresenceMode), write(this.allStarExports), 
super.serialize(context);
}
deserialize(context) {
const {read, setCircularReference} = context;
setCircularReference(this), this.ids = read(), this.name = read(), this.activeExports = read(), 
this.otherStarExports = read(), this.exportPresenceMode = read(), this.allStarExports = read(), 
super.deserialize(context);
}
}
makeSerializable(HarmonyExportImportedSpecifierDependency, "webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency"), 
module.exports = HarmonyExportImportedSpecifierDependency, HarmonyExportImportedSpecifierDependency.Template = class extends HarmonyImportDependency.Template {
apply(dependency, source, templateContext) {
const {moduleGraph, runtime, concatenationScope} = templateContext, dep = dependency, mode = dep.getMode(moduleGraph, runtime);
if (concatenationScope) {
if ("reexport-undefined" === mode.type) concatenationScope.registerRawExport(mode.name, "/* reexport non-default export from non-harmony */ undefined");
} else "unused" !== mode.type && "empty-star" !== mode.type && (super.apply(dependency, source, templateContext), 
this._addExportFragments(templateContext.initFragments, dep, mode, templateContext.module, moduleGraph, runtime, templateContext.runtimeTemplate, templateContext.runtimeRequirements));
}
_addExportFragments(initFragments, dep, mode, module, moduleGraph, runtime, runtimeTemplate, runtimeRequirements) {
const importedModule = moduleGraph.getModule(dep), importVar = dep.getImportVar(moduleGraph);
switch (mode.type) {
case "missing":
case "empty-star":
initFragments.push(new InitFragment("/* empty/unused harmony star reexport */\n", InitFragment.STAGE_HARMONY_EXPORTS, 1));
break;

case "unused":
initFragments.push(new InitFragment(`${Template.toNormalComment(`unused harmony reexport ${mode.name}`)}\n`, InitFragment.STAGE_HARMONY_EXPORTS, 1));
break;

case "reexport-dynamic-default":
initFragments.push(this.getReexportFragment(module, "reexport default from dynamic", moduleGraph.getExportsInfo(module).getUsedName(mode.name, runtime), importVar, null, runtimeRequirements));
break;

case "reexport-fake-namespace-object":
initFragments.push(...this.getReexportFakeNamespaceObjectFragments(module, moduleGraph.getExportsInfo(module).getUsedName(mode.name, runtime), importVar, mode.fakeType, runtimeRequirements));
break;

case "reexport-undefined":
initFragments.push(this.getReexportFragment(module, "reexport non-default export from non-harmony", moduleGraph.getExportsInfo(module).getUsedName(mode.name, runtime), "undefined", "", runtimeRequirements));
break;

case "reexport-named-default":
initFragments.push(this.getReexportFragment(module, "reexport default export from named module", moduleGraph.getExportsInfo(module).getUsedName(mode.name, runtime), importVar, "", runtimeRequirements));
break;

case "reexport-namespace-object":
initFragments.push(this.getReexportFragment(module, "reexport module object", moduleGraph.getExportsInfo(module).getUsedName(mode.name, runtime), importVar, "", runtimeRequirements));
break;

case "normal-reexport":
for (const {name, ids, checked, hidden} of mode.items) hidden || (checked ? initFragments.push(new InitFragment("/* harmony reexport (checked) */ " + this.getConditionalReexportStatement(module, name, importVar, ids, runtimeRequirements), moduleGraph.isAsync(importedModule) ? InitFragment.STAGE_ASYNC_HARMONY_IMPORTS : InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder)) : initFragments.push(this.getReexportFragment(module, "reexport safe", moduleGraph.getExportsInfo(module).getUsedName(name, runtime), importVar, moduleGraph.getExportsInfo(importedModule).getUsedName(ids, runtime), runtimeRequirements)));
break;

case "dynamic-reexport":
{
const ignored = mode.hidden ? combine(mode.ignored, mode.hidden) : mode.ignored, modern = runtimeTemplate.supportsConst() && runtimeTemplate.supportsArrowFunction();
let content = `/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(${modern ? "const" : "var"} __WEBPACK_IMPORT_KEY__ in ${importVar}) `;
ignored.size > 1 ? content += "if(" + JSON.stringify(Array.from(ignored)) + ".indexOf(__WEBPACK_IMPORT_KEY__) < 0) " : 1 === ignored.size && (content += `if(__WEBPACK_IMPORT_KEY__ !== ${JSON.stringify(first(ignored))}) `), 
content += "__WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = ", content += modern ? `() => ${importVar}[__WEBPACK_IMPORT_KEY__]` : `function(key) { return ${importVar}[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)`, 
runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
const exportsName = module.exportsArgument;
initFragments.push(new InitFragment(`${content}\n/* harmony reexport (unknown) */ ${RuntimeGlobals.definePropertyGetters}(${exportsName}, __WEBPACK_REEXPORT_OBJECT__);\n`, moduleGraph.isAsync(importedModule) ? InitFragment.STAGE_ASYNC_HARMONY_IMPORTS : InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder));
break;
}

default:
throw new Error(`Unknown mode ${mode.type}`);
}
}
getReexportFragment(module, comment, key, name, valueKey, runtimeRequirements) {
const returnValue = this.getReturnValue(name, valueKey);
runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
const map = new Map;
return map.set(key, `/* ${comment} */ ${returnValue}`), new HarmonyExportInitFragment(module.exportsArgument, map);
}
getReexportFakeNamespaceObjectFragments(module, key, name, fakeType, runtimeRequirements) {
runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.definePropertyGetters), 
runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
const map = new Map;
return map.set(key, `/* reexport fake namespace object from non-harmony */ ${name}_namespace_cache || (${name}_namespace_cache = ${RuntimeGlobals.createFakeNamespaceObject}(${name}${fakeType ? `, ${fakeType}` : ""}))`), 
[ new InitFragment(`var ${name}_namespace_cache;\n`, InitFragment.STAGE_CONSTANTS, -1, `${name}_namespace_cache`), new HarmonyExportInitFragment(module.exportsArgument, map) ];
}
getConditionalReexportStatement(module, key, name, valueKey, runtimeRequirements) {
if (!1 === valueKey) return "/* unused export */\n";
const exportsName = module.exportsArgument, returnValue = this.getReturnValue(name, valueKey);
return runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.definePropertyGetters), 
runtimeRequirements.add(RuntimeGlobals.hasOwnProperty), `if(${RuntimeGlobals.hasOwnProperty}(${name}, ${JSON.stringify(valueKey[0])})) ${RuntimeGlobals.definePropertyGetters}(${exportsName}, { ${JSON.stringify(key)}: function() { return ${returnValue}; } });\n`;
}
getReturnValue(name, valueKey) {
return null === valueKey ? `${name}_default.a` : "" === valueKey ? name : !1 === valueKey ? "/* unused export */ undefined" : `${name}${propertyAccess(valueKey)}`;
}
};
class HarmonyStarExportsList {
constructor() {
this.dependencies = [];
}
push(dep) {
this.dependencies.push(dep);
}
slice() {
return this.dependencies.slice();
}
serialize({write, setCircularReference}) {
setCircularReference(this), write(this.dependencies);
}
deserialize({read, setCircularReference}) {
setCircularReference(this), this.dependencies = read();
}
}
makeSerializable(HarmonyStarExportsList, "webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency", "HarmonyStarExportsList"), 
module.exports.HarmonyStarExportsList = HarmonyStarExportsList;
},
16515: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), {first} = __webpack_require__(73974), EMPTY_MAP = new Map, EMPTY_SET = new Set;
class HarmonyExportInitFragment extends InitFragment {
constructor(exportsArgument, exportMap = EMPTY_MAP, unusedExports = EMPTY_SET) {
super(void 0, InitFragment.STAGE_HARMONY_EXPORTS, 1, "harmony-exports"), this.exportsArgument = exportsArgument, 
this.exportMap = exportMap, this.unusedExports = unusedExports;
}
mergeAll(fragments) {
let exportMap, unusedExports, exportMapOwned = !1, unusedExportsOwned = !1;
for (const fragment of fragments) {
if (0 !== fragment.exportMap.size) if (void 0 === exportMap) exportMap = fragment.exportMap, 
exportMapOwned = !1; else {
exportMapOwned || (exportMap = new Map(exportMap), exportMapOwned = !0);
for (const [key, value] of fragment.exportMap) exportMap.has(key) || exportMap.set(key, value);
}
if (0 !== fragment.unusedExports.size) if (void 0 === unusedExports) unusedExports = fragment.unusedExports, 
unusedExportsOwned = !1; else {
unusedExportsOwned || (unusedExports = new Set(unusedExports), unusedExportsOwned = !0);
for (const value of fragment.unusedExports) unusedExports.add(value);
}
}
return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);
}
merge(other) {
let exportMap, unusedExports;
if (0 === this.exportMap.size) exportMap = other.exportMap; else if (0 === other.exportMap.size) exportMap = this.exportMap; else {
exportMap = new Map(other.exportMap);
for (const [key, value] of this.exportMap) exportMap.has(key) || exportMap.set(key, value);
}
if (0 === this.unusedExports.size) unusedExports = other.unusedExports; else if (0 === other.unusedExports.size) unusedExports = this.unusedExports; else {
unusedExports = new Set(other.unusedExports);
for (const value of this.unusedExports) unusedExports.add(value);
}
return new HarmonyExportInitFragment(this.exportsArgument, exportMap, unusedExports);
}
getContent({runtimeTemplate, runtimeRequirements}) {
runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
const unusedPart = this.unusedExports.size > 1 ? `/* unused harmony exports ${(iterable => {
let str = "", first = !0;
for (const item of iterable) first ? first = !1 : str += ", ", str += item;
return str;
})(this.unusedExports)} */\n` : this.unusedExports.size > 0 ? `/* unused harmony export ${first(this.unusedExports)} */\n` : "", definitions = [], orderedExportMap = Array.from(this.exportMap).sort((([a], [b]) => a < b ? -1 : 1));
for (const [key, value] of orderedExportMap) definitions.push(`\n/* harmony export */   ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(value)}`);
return `${this.exportMap.size > 0 ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(",")}\n/* harmony export */ });\n` : ""}${unusedPart}`;
}
}
module.exports = HarmonyExportInitFragment;
},
61750: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), HarmonyExportInitFragment = __webpack_require__(16515), NullDependency = __webpack_require__(52649);
class HarmonyExportSpecifierDependency extends NullDependency {
constructor(id, name) {
super(), this.id = id, this.name = name;
}
get type() {
return "harmony export specifier";
}
getExports(moduleGraph) {
return {
exports: [ this.name ],
priority: 1,
terminalBinding: !0,
dependencies: void 0
};
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !1;
}
serialize(context) {
const {write} = context;
write(this.id), write(this.name), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.id = read(), this.name = read(), super.deserialize(context);
}
}
makeSerializable(HarmonyExportSpecifierDependency, "webpack/lib/dependencies/HarmonyExportSpecifierDependency"), 
HarmonyExportSpecifierDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, moduleGraph, initFragments, runtime, concatenationScope}) {
const dep = dependency;
if (concatenationScope) return void concatenationScope.registerExport(dep.name, dep.id);
const used = moduleGraph.getExportsInfo(module).getUsedName(dep.name, runtime);
if (!used) {
const set = new Set;
return set.add(dep.name || "namespace"), void initFragments.push(new HarmonyExportInitFragment(module.exportsArgument, void 0, set));
}
const map = new Map;
map.set(used, `/* binding */ ${dep.id}`), initFragments.push(new HarmonyExportInitFragment(module.exportsArgument, map, void 0));
}
}, module.exports = HarmonyExportSpecifierDependency;
},
60836: (__unused_webpack_module, exports) => {
"use strict";
const parserStateExportsState = new WeakMap;
exports.enable = (parserState, isStrictHarmony) => {
const value = parserStateExportsState.get(parserState);
!1 !== value && (parserStateExportsState.set(parserState, !0), !0 !== value && (parserState.module.buildMeta.exportsType = "namespace", 
parserState.module.buildInfo.strict = !0, parserState.module.buildInfo.exportsArgument = "__webpack_exports__", 
isStrictHarmony && (parserState.module.buildMeta.strictHarmonyModule = !0, parserState.module.buildInfo.moduleArgument = "__webpack_module__")));
}, exports.isEnabled = parserState => !0 === parserStateExportsState.get(parserState);
},
75015: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConditionalInitFragment = __webpack_require__(29226), Dependency = __webpack_require__(14926), HarmonyLinkingError = __webpack_require__(7729), InitFragment = __webpack_require__(95328), Template = __webpack_require__(88370), AwaitDependenciesInitFragment = __webpack_require__(45788), {filterRuntime, mergeRuntime} = __webpack_require__(14372), ModuleDependency = __webpack_require__(15216), ExportPresenceModes = {
NONE: 0,
WARN: 1,
AUTO: 2,
ERROR: 3,
fromUserOption(str) {
switch (str) {
case "error":
return ExportPresenceModes.ERROR;

case "warn":
return ExportPresenceModes.WARN;

case "auto":
return ExportPresenceModes.AUTO;

case !1:
return ExportPresenceModes.NONE;

default:
throw new Error(`Invalid export presence value ${str}`);
}
}
};
class HarmonyImportDependency extends ModuleDependency {
constructor(request, sourceOrder, assertions) {
super(request), this.sourceOrder = sourceOrder, this.assertions = assertions;
}
get category() {
return "esm";
}
getReferencedExports(moduleGraph, runtime) {
return Dependency.NO_EXPORTS_REFERENCED;
}
getImportVar(moduleGraph) {
const module = moduleGraph.getParentModule(this), meta = moduleGraph.getMeta(module);
let importVarMap = meta.importVarMap;
importVarMap || (meta.importVarMap = importVarMap = new Map);
let importVar = importVarMap.get(moduleGraph.getModule(this));
return importVar || (importVar = `${Template.toIdentifier(`${this.userRequest}`)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`, 
importVarMap.set(moduleGraph.getModule(this), importVar), importVar);
}
getImportStatement(update, {runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements}) {
return runtimeTemplate.importStatement({
update,
module: moduleGraph.getModule(this),
chunkGraph,
importVar: this.getImportVar(moduleGraph),
request: this.request,
originModule: module,
runtimeRequirements
});
}
getLinkingErrors(moduleGraph, ids, additionalMessage) {
const importedModule = moduleGraph.getModule(this);
if (!importedModule || importedModule.getNumberOfErrors() > 0) return;
const parentModule = moduleGraph.getParentModule(this), exportsType = importedModule.getExportsType(moduleGraph, parentModule.buildMeta.strictHarmonyModule);
if ("namespace" === exportsType || "default-with-named" === exportsType) {
if (0 === ids.length) return;
if (("default-with-named" !== exportsType || "default" !== ids[0]) && !1 === moduleGraph.isExportProvided(importedModule, ids)) {
let pos = 0, exportsInfo = moduleGraph.getExportsInfo(importedModule);
for (;pos < ids.length && exportsInfo; ) {
const id = ids[pos++], exportInfo = exportsInfo.getReadOnlyExportInfo(id);
if (!1 === exportInfo.provided) {
const providedExports = exportsInfo.getProvidedExports(), moreInfo = Array.isArray(providedExports) ? 0 === providedExports.length ? " (module has no exports)" : ` (possible exports: ${providedExports.join(", ")})` : " (possible exports unknown)";
return [ new HarmonyLinkingError(`export ${ids.slice(0, pos).map((id => `'${id}'`)).join(".")} ${additionalMessage} was not found in '${this.userRequest}'${moreInfo}`) ];
}
exportsInfo = exportInfo.getNestedExportsInfo();
}
return [ new HarmonyLinkingError(`export ${ids.map((id => `'${id}'`)).join(".")} ${additionalMessage} was not found in '${this.userRequest}'`) ];
}
}
switch (exportsType) {
case "default-only":
if (ids.length > 0 && "default" !== ids[0]) return [ new HarmonyLinkingError(`Can't import the named export ${ids.map((id => `'${id}'`)).join(".")} ${additionalMessage} from default-exporting module (only default export is available)`) ];
break;

case "default-with-named":
if (ids.length > 0 && "default" !== ids[0] && "redirect-warn" === importedModule.buildMeta.defaultObject) return [ new HarmonyLinkingError(`Should not import the named export ${ids.map((id => `'${id}'`)).join(".")} ${additionalMessage} from default-exporting module (only default export is available soon)`) ];
}
}
serialize(context) {
const {write} = context;
write(this.sourceOrder), write(this.assertions), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.sourceOrder = read(), this.assertions = read(), super.deserialize(context);
}
}
module.exports = HarmonyImportDependency;
const importEmittedMap = new WeakMap;
HarmonyImportDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency, {module, chunkGraph, moduleGraph, runtime} = templateContext, connection = moduleGraph.getConnection(dep);
if (connection && !connection.isTargetActive(runtime)) return;
const referencedModule = connection && connection.module;
if (connection && connection.weak && referencedModule && null === chunkGraph.getModuleId(referencedModule)) return;
const key = `harmony import ${referencedModule ? referencedModule.identifier() : dep.request}`, runtimeCondition = !dep.weak && (!connection || filterRuntime(runtime, (r => connection.isTargetActive(r))));
if (module && referencedModule) {
let emittedModules = importEmittedMap.get(module);
void 0 === emittedModules && (emittedModules = new WeakMap, importEmittedMap.set(module, emittedModules));
let mergedRuntimeCondition = runtimeCondition;
const oldRuntimeCondition = emittedModules.get(referencedModule) || !1;
!1 !== oldRuntimeCondition && !0 !== mergedRuntimeCondition && (mergedRuntimeCondition = !1 === mergedRuntimeCondition || !0 === oldRuntimeCondition ? oldRuntimeCondition : mergeRuntime(oldRuntimeCondition, mergedRuntimeCondition)), 
emittedModules.set(referencedModule, mergedRuntimeCondition);
}
const importStatement = dep.getImportStatement(!1, templateContext);
referencedModule && templateContext.moduleGraph.isAsync(referencedModule) ? (templateContext.initFragments.push(new ConditionalInitFragment(importStatement[0], InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder, key, runtimeCondition)), 
templateContext.initFragments.push(new AwaitDependenciesInitFragment(new Set([ dep.getImportVar(templateContext.moduleGraph) ]))), 
templateContext.initFragments.push(new ConditionalInitFragment(importStatement[1], InitFragment.STAGE_ASYNC_HARMONY_IMPORTS, dep.sourceOrder, key + " compat", runtimeCondition))) : templateContext.initFragments.push(new ConditionalInitFragment(importStatement[0] + importStatement[1], InitFragment.STAGE_HARMONY_IMPORTS, dep.sourceOrder, key, runtimeCondition));
}
static getImportEmittedRuntime(module, referencedModule) {
const emittedModules = importEmittedMap.get(module);
return void 0 !== emittedModules && (emittedModules.get(referencedModule) || !1);
}
}, module.exports.ExportPresenceModes = ExportPresenceModes;
},
20529: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const HotModuleReplacementPlugin = __webpack_require__(17049), InnerGraph = __webpack_require__(93639), ConstDependency = __webpack_require__(30339), HarmonyAcceptDependency = __webpack_require__(29549), HarmonyAcceptImportDependency = __webpack_require__(77337), HarmonyEvaluatedImportSpecifierDependency = __webpack_require__(43613), HarmonyExports = __webpack_require__(60836), {ExportPresenceModes} = __webpack_require__(75015), HarmonyImportSideEffectDependency = __webpack_require__(39052), HarmonyImportSpecifierDependency = __webpack_require__(68081), harmonySpecifierTag = Symbol("harmony import");
function getAssertions(node) {
const assertions = node.assertions;
if (void 0 === assertions) return;
const result = {};
for (const assertion of assertions) {
result["Identifier" === assertion.key.type ? assertion.key.name : assertion.key.value] = assertion.value.value;
}
return result;
}
module.exports = class {
constructor(options) {
this.exportPresenceMode = void 0 !== options.importExportsPresence ? ExportPresenceModes.fromUserOption(options.importExportsPresence) : void 0 !== options.exportsPresence ? ExportPresenceModes.fromUserOption(options.exportsPresence) : options.strictExportPresence ? ExportPresenceModes.ERROR : ExportPresenceModes.AUTO, 
this.strictThisContextOnImports = options.strictThisContextOnImports;
}
apply(parser) {
const {exportPresenceMode} = this;
function getNonOptionalPart(members, membersOptionals) {
let i = 0;
for (;i < members.length && !1 === membersOptionals[i]; ) i++;
return i !== members.length ? members.slice(0, i) : members;
}
function getNonOptionalMemberChain(node, count) {
for (;count--; ) node = node.object;
return node;
}
parser.hooks.isPure.for("Identifier").tap("HarmonyImportDependencyParserPlugin", (expression => {
const expr = expression;
if (parser.isVariableDefined(expr.name) || parser.getTagData(expr.name, harmonySpecifierTag)) return !0;
})), parser.hooks.import.tap("HarmonyImportDependencyParserPlugin", ((statement, source) => {
parser.state.lastHarmonyImportOrder = (parser.state.lastHarmonyImportOrder || 0) + 1;
const clearDep = new ConstDependency(parser.isAsiPosition(statement.range[0]) ? ";" : "", statement.range);
clearDep.loc = statement.loc, parser.state.module.addPresentationalDependency(clearDep), 
parser.unsetAsiPosition(statement.range[1]);
const assertions = getAssertions(statement), sideEffectDep = new HarmonyImportSideEffectDependency(source, parser.state.lastHarmonyImportOrder, assertions);
return sideEffectDep.loc = statement.loc, parser.state.module.addDependency(sideEffectDep), 
!0;
})), parser.hooks.importSpecifier.tap("HarmonyImportDependencyParserPlugin", ((statement, source, id, name) => {
const ids = null === id ? [] : [ id ];
return parser.tagVariable(name, harmonySpecifierTag, {
name,
source,
ids,
sourceOrder: parser.state.lastHarmonyImportOrder,
assertions: getAssertions(statement)
}), !0;
})), parser.hooks.binaryExpression.tap("HarmonyImportDependencyParserPlugin", (expression => {
if ("in" !== expression.operator) return;
const leftPartEvaluated = parser.evaluateExpression(expression.left);
if (leftPartEvaluated.couldHaveSideEffects()) return;
const leftPart = leftPartEvaluated.asString();
if (!leftPart) return;
const rightPart = parser.evaluateExpression(expression.right);
if (!rightPart.isIdentifier()) return;
const rootInfo = rightPart.rootInfo;
if (!rootInfo || !rootInfo.tagInfo || rootInfo.tagInfo.tag !== harmonySpecifierTag) return;
const settings = rootInfo.tagInfo.data, members = rightPart.getMembers(), dep = new HarmonyEvaluatedImportSpecifierDependency(settings.source, settings.sourceOrder, settings.ids.concat(members).concat([ leftPart ]), settings.name, expression.range, settings.assertions, "in");
return dep.directImport = 0 === members.length, dep.asiSafe = !parser.isAsiPosition(expression.range[0]), 
dep.loc = expression.loc, parser.state.module.addDependency(dep), InnerGraph.onUsage(parser.state, (e => dep.usedByExports = e)), 
!0;
})), parser.hooks.expression.for(harmonySpecifierTag).tap("HarmonyImportDependencyParserPlugin", (expr => {
const settings = parser.currentTagData, dep = new HarmonyImportSpecifierDependency(settings.source, settings.sourceOrder, settings.ids, settings.name, expr.range, exportPresenceMode, settings.assertions);
return dep.shorthand = parser.scope.inShorthand, dep.directImport = !0, dep.asiSafe = !parser.isAsiPosition(expr.range[0]), 
dep.loc = expr.loc, parser.state.module.addDependency(dep), InnerGraph.onUsage(parser.state, (e => dep.usedByExports = e)), 
!0;
})), parser.hooks.expressionMemberChain.for(harmonySpecifierTag).tap("HarmonyImportDependencyParserPlugin", ((expression, members, membersOptionals) => {
const settings = parser.currentTagData, nonOptionalMembers = getNonOptionalPart(members, membersOptionals), expr = nonOptionalMembers !== members ? getNonOptionalMemberChain(expression, members.length - nonOptionalMembers.length) : expression, ids = settings.ids.concat(nonOptionalMembers), dep = new HarmonyImportSpecifierDependency(settings.source, settings.sourceOrder, ids, settings.name, expr.range, exportPresenceMode, settings.assertions);
return dep.asiSafe = !parser.isAsiPosition(expr.range[0]), dep.loc = expr.loc, parser.state.module.addDependency(dep), 
InnerGraph.onUsage(parser.state, (e => dep.usedByExports = e)), !0;
})), parser.hooks.callMemberChain.for(harmonySpecifierTag).tap("HarmonyImportDependencyParserPlugin", ((expression, members, membersOptionals) => {
const {arguments: args, callee} = expression, settings = parser.currentTagData, nonOptionalMembers = getNonOptionalPart(members, membersOptionals), expr = nonOptionalMembers !== members ? getNonOptionalMemberChain(callee, members.length - nonOptionalMembers.length) : callee, ids = settings.ids.concat(nonOptionalMembers), dep = new HarmonyImportSpecifierDependency(settings.source, settings.sourceOrder, ids, settings.name, expr.range, exportPresenceMode, settings.assertions);
return dep.directImport = 0 === members.length, dep.call = !0, dep.asiSafe = !parser.isAsiPosition(expr.range[0]), 
dep.namespaceObjectAsContext = members.length > 0 && this.strictThisContextOnImports, 
dep.loc = expr.loc, parser.state.module.addDependency(dep), args && parser.walkExpressions(args), 
InnerGraph.onUsage(parser.state, (e => dep.usedByExports = e)), !0;
}));
const {hotAcceptCallback, hotAcceptWithoutCallback} = HotModuleReplacementPlugin.getParserHooks(parser);
hotAcceptCallback.tap("HarmonyImportDependencyParserPlugin", ((expr, requests) => {
if (!HarmonyExports.isEnabled(parser.state)) return;
const dependencies = requests.map((request => {
const dep = new HarmonyAcceptImportDependency(request);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), dep;
}));
if (dependencies.length > 0) {
const dep = new HarmonyAcceptDependency(expr.range, dependencies, !0);
dep.loc = expr.loc, parser.state.module.addDependency(dep);
}
})), hotAcceptWithoutCallback.tap("HarmonyImportDependencyParserPlugin", ((expr, requests) => {
if (!HarmonyExports.isEnabled(parser.state)) return;
const dependencies = requests.map((request => {
const dep = new HarmonyAcceptImportDependency(request);
return dep.loc = expr.loc, parser.state.module.addDependency(dep), dep;
}));
if (dependencies.length > 0) {
const dep = new HarmonyAcceptDependency(expr.range, dependencies, !1);
dep.loc = expr.loc, parser.state.module.addDependency(dep);
}
}));
}
}, module.exports.harmonySpecifierTag = harmonySpecifierTag, module.exports.getAssertions = getAssertions;
},
39052: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), HarmonyImportDependency = __webpack_require__(75015);
class HarmonyImportSideEffectDependency extends HarmonyImportDependency {
constructor(request, sourceOrder, assertions) {
super(request, sourceOrder, assertions);
}
get type() {
return "harmony side effect evaluation";
}
getCondition(moduleGraph) {
return connection => {
const refModule = connection.resolvedModule;
return !refModule || refModule.getSideEffectsConnectionState(moduleGraph);
};
}
getModuleEvaluationSideEffectsState(moduleGraph) {
const refModule = moduleGraph.getModule(this);
return !refModule || refModule.getSideEffectsConnectionState(moduleGraph);
}
}
makeSerializable(HarmonyImportSideEffectDependency, "webpack/lib/dependencies/HarmonyImportSideEffectDependency"), 
HarmonyImportSideEffectDependency.Template = class extends HarmonyImportDependency.Template {
apply(dependency, source, templateContext) {
const {moduleGraph, concatenationScope} = templateContext;
if (concatenationScope) {
const module = moduleGraph.getModule(dependency);
if (concatenationScope.isModuleInScope(module)) return;
}
super.apply(dependency, source, templateContext);
}
}, module.exports = HarmonyImportSideEffectDependency;
},
68081: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), {getDependencyUsedByExportsCondition} = __webpack_require__(93639), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), HarmonyImportDependency = __webpack_require__(75015), idsSymbol = Symbol("HarmonyImportSpecifierDependency.ids"), {ExportPresenceModes} = HarmonyImportDependency;
class HarmonyImportSpecifierDependency extends HarmonyImportDependency {
constructor(request, sourceOrder, ids, name, range, exportPresenceMode, assertions) {
super(request, sourceOrder, assertions), this.ids = ids, this.name = name, this.range = range, 
this.exportPresenceMode = exportPresenceMode, this.namespaceObjectAsContext = !1, 
this.call = void 0, this.directImport = void 0, this.shorthand = void 0, this.asiSafe = void 0, 
this.usedByExports = void 0;
}
get id() {
throw new Error("id was renamed to ids and type changed to string[]");
}
getId() {
throw new Error("id was renamed to ids and type changed to string[]");
}
setId() {
throw new Error("id was renamed to ids and type changed to string[]");
}
get type() {
return "harmony import specifier";
}
getIds(moduleGraph) {
const meta = moduleGraph.getMetaIfExisting(this);
if (void 0 === meta) return this.ids;
const ids = meta[idsSymbol];
return void 0 !== ids ? ids : this.ids;
}
setIds(moduleGraph, ids) {
moduleGraph.getMeta(this)[idsSymbol] = ids;
}
getCondition(moduleGraph) {
return getDependencyUsedByExportsCondition(this, this.usedByExports, moduleGraph);
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !1;
}
getReferencedExports(moduleGraph, runtime) {
let ids = this.getIds(moduleGraph);
if (0 === ids.length) return Dependency.EXPORTS_OBJECT_REFERENCED;
let namespaceObjectAsContext = this.namespaceObjectAsContext;
if ("default" === ids[0]) {
const selfModule = moduleGraph.getParentModule(this);
switch (moduleGraph.getModule(this).getExportsType(moduleGraph, selfModule.buildMeta.strictHarmonyModule)) {
case "default-only":
case "default-with-named":
if (1 === ids.length) return Dependency.EXPORTS_OBJECT_REFERENCED;
ids = ids.slice(1), namespaceObjectAsContext = !0;
break;

case "dynamic":
return Dependency.EXPORTS_OBJECT_REFERENCED;
}
}
if (this.call && !this.directImport && (namespaceObjectAsContext || ids.length > 1)) {
if (1 === ids.length) return Dependency.EXPORTS_OBJECT_REFERENCED;
ids = ids.slice(0, -1);
}
return [ ids ];
}
_getEffectiveExportPresenceLevel(moduleGraph) {
return this.exportPresenceMode !== ExportPresenceModes.AUTO ? this.exportPresenceMode : moduleGraph.getParentModule(this).buildMeta.strictHarmonyModule ? ExportPresenceModes.ERROR : ExportPresenceModes.WARN;
}
getWarnings(moduleGraph) {
return this._getEffectiveExportPresenceLevel(moduleGraph) === ExportPresenceModes.WARN ? this._getErrors(moduleGraph) : null;
}
getErrors(moduleGraph) {
return this._getEffectiveExportPresenceLevel(moduleGraph) === ExportPresenceModes.ERROR ? this._getErrors(moduleGraph) : null;
}
_getErrors(moduleGraph) {
const ids = this.getIds(moduleGraph);
return this.getLinkingErrors(moduleGraph, ids, `(imported as '${this.name}')`);
}
getNumberOfIdOccurrences() {
return 0;
}
serialize(context) {
const {write} = context;
write(this.ids), write(this.name), write(this.range), write(this.exportPresenceMode), 
write(this.namespaceObjectAsContext), write(this.call), write(this.directImport), 
write(this.shorthand), write(this.asiSafe), write(this.usedByExports), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.ids = read(), this.name = read(), this.range = read(), this.exportPresenceMode = read(), 
this.namespaceObjectAsContext = read(), this.call = read(), this.directImport = read(), 
this.shorthand = read(), this.asiSafe = read(), this.usedByExports = read(), super.deserialize(context);
}
}
makeSerializable(HarmonyImportSpecifierDependency, "webpack/lib/dependencies/HarmonyImportSpecifierDependency"), 
HarmonyImportSpecifierDependency.Template = class extends HarmonyImportDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency, {moduleGraph, runtime} = templateContext, connection = moduleGraph.getConnection(dep);
if (connection && !connection.isTargetActive(runtime)) return;
const ids = dep.getIds(moduleGraph), exportExpr = this._getCodeForIds(dep, source, templateContext, ids), range = dep.range;
dep.shorthand ? source.insert(range[1], `: ${exportExpr}`) : source.replace(range[0], range[1] - 1, exportExpr);
}
_getCodeForIds(dep, source, templateContext, ids) {
const {moduleGraph, module, runtime, concatenationScope} = templateContext, connection = moduleGraph.getConnection(dep);
let exportExpr;
if (connection && concatenationScope && concatenationScope.isModuleInScope(connection.module)) exportExpr = 0 === ids.length ? concatenationScope.createModuleReference(connection.module, {
asiSafe: dep.asiSafe
}) : dep.namespaceObjectAsContext && 1 === ids.length ? concatenationScope.createModuleReference(connection.module, {
asiSafe: dep.asiSafe
}) + propertyAccess(ids) : concatenationScope.createModuleReference(connection.module, {
ids,
call: dep.call,
directImport: dep.directImport,
asiSafe: dep.asiSafe
}); else {
super.apply(dep, source, templateContext);
const {runtimeTemplate, initFragments, runtimeRequirements} = templateContext;
exportExpr = runtimeTemplate.exportFromImport({
moduleGraph,
module: moduleGraph.getModule(dep),
request: dep.request,
exportName: ids,
originModule: module,
asiSafe: !!dep.shorthand || dep.asiSafe,
isCall: dep.call,
callContext: !dep.directImport,
defaultInterop: !0,
importVar: dep.getImportVar(moduleGraph),
initFragments,
runtime,
runtimeRequirements
});
}
return exportExpr;
}
}, module.exports = HarmonyImportSpecifierDependency;
},
35908: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const HarmonyAcceptDependency = __webpack_require__(29549), HarmonyAcceptImportDependency = __webpack_require__(77337), HarmonyCompatibilityDependency = __webpack_require__(35285), HarmonyEvaluatedImportSpecifierDependency = __webpack_require__(43613), HarmonyExportExpressionDependency = __webpack_require__(30146), HarmonyExportHeaderDependency = __webpack_require__(40366), HarmonyExportImportedSpecifierDependency = __webpack_require__(59411), HarmonyExportSpecifierDependency = __webpack_require__(61750), HarmonyImportSideEffectDependency = __webpack_require__(39052), HarmonyImportSpecifierDependency = __webpack_require__(68081), HarmonyDetectionParserPlugin = __webpack_require__(76334), HarmonyExportDependencyParserPlugin = __webpack_require__(69420), HarmonyImportDependencyParserPlugin = __webpack_require__(20529), HarmonyTopLevelThisParserPlugin = __webpack_require__(73935);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
compiler.hooks.compilation.tap("HarmonyModulesPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyTemplates.set(HarmonyCompatibilityDependency, new HarmonyCompatibilityDependency.Template), 
compilation.dependencyFactories.set(HarmonyImportSideEffectDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(HarmonyImportSideEffectDependency, new HarmonyImportSideEffectDependency.Template), 
compilation.dependencyFactories.set(HarmonyImportSpecifierDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(HarmonyImportSpecifierDependency, new HarmonyImportSpecifierDependency.Template), 
compilation.dependencyFactories.set(HarmonyEvaluatedImportSpecifierDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(HarmonyEvaluatedImportSpecifierDependency, new HarmonyEvaluatedImportSpecifierDependency.Template), 
compilation.dependencyTemplates.set(HarmonyExportHeaderDependency, new HarmonyExportHeaderDependency.Template), 
compilation.dependencyTemplates.set(HarmonyExportExpressionDependency, new HarmonyExportExpressionDependency.Template), 
compilation.dependencyTemplates.set(HarmonyExportSpecifierDependency, new HarmonyExportSpecifierDependency.Template), 
compilation.dependencyFactories.set(HarmonyExportImportedSpecifierDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(HarmonyExportImportedSpecifierDependency, new HarmonyExportImportedSpecifierDependency.Template), 
compilation.dependencyTemplates.set(HarmonyAcceptDependency, new HarmonyAcceptDependency.Template), 
compilation.dependencyFactories.set(HarmonyAcceptImportDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(HarmonyAcceptImportDependency, new HarmonyAcceptImportDependency.Template);
const handler = (parser, parserOptions) => {
(void 0 === parserOptions.harmony || parserOptions.harmony) && (new HarmonyDetectionParserPlugin(this.options).apply(parser), 
new HarmonyImportDependencyParserPlugin(parserOptions).apply(parser), new HarmonyExportDependencyParserPlugin(parserOptions).apply(parser), 
(new HarmonyTopLevelThisParserPlugin).apply(parser));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("HarmonyModulesPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("HarmonyModulesPlugin", handler);
}));
}
};
},
73935: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ConstDependency = __webpack_require__(30339), HarmonyExports = __webpack_require__(60836);
module.exports = class {
apply(parser) {
parser.hooks.expression.for("this").tap("HarmonyTopLevelThisParserPlugin", (node => {
if (parser.scope.topLevelScope && HarmonyExports.isEnabled(parser.state)) {
const dep = new ConstDependency("undefined", node.range, null);
return dep.loc = node.loc, parser.state.module.addPresentationalDependency(dep), 
this;
}
}));
}
};
},
99554: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ContextDependency = __webpack_require__(97818), ContextDependencyTemplateAsRequireCall = __webpack_require__(31131);
class ImportContextDependency extends ContextDependency {
constructor(options, range, valueRange) {
super(options), this.range = range, this.valueRange = valueRange;
}
get type() {
return `import() context ${this.options.mode}`;
}
get category() {
return "esm";
}
serialize(context) {
const {write} = context;
write(this.valueRange), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.valueRange = read(), super.deserialize(context);
}
}
makeSerializable(ImportContextDependency, "webpack/lib/dependencies/ImportContextDependency"), 
ImportContextDependency.Template = ContextDependencyTemplateAsRequireCall, module.exports = ImportContextDependency;
},
75035: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class ImportDependency extends ModuleDependency {
constructor(request, range, referencedExports) {
super(request), this.range = range, this.referencedExports = referencedExports;
}
get type() {
return "import()";
}
get category() {
return "esm";
}
getReferencedExports(moduleGraph, runtime) {
return this.referencedExports ? this.referencedExports.map((e => ({
name: e,
canMangle: !1
}))) : Dependency.EXPORTS_OBJECT_REFERENCED;
}
serialize(context) {
context.write(this.range), context.write(this.referencedExports), super.serialize(context);
}
deserialize(context) {
this.range = context.read(), this.referencedExports = context.read(), super.deserialize(context);
}
}
makeSerializable(ImportDependency, "webpack/lib/dependencies/ImportDependency"), 
ImportDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, {runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency, block = moduleGraph.getParentBlock(dep), content = runtimeTemplate.moduleNamespacePromise({
chunkGraph,
block,
module: moduleGraph.getModule(dep),
request: dep.request,
strict: module.buildMeta.strictHarmonyModule,
message: "import()",
runtimeRequirements
});
source.replace(dep.range[0], dep.range[1] - 1, content);
}
}, module.exports = ImportDependency;
},
76636: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ImportDependency = __webpack_require__(75035);
class ImportEagerDependency extends ImportDependency {
constructor(request, range, referencedExports) {
super(request, range, referencedExports);
}
get type() {
return "import() eager";
}
get category() {
return "esm";
}
}
makeSerializable(ImportEagerDependency, "webpack/lib/dependencies/ImportEagerDependency"), 
ImportEagerDependency.Template = class extends ImportDependency.Template {
apply(dependency, source, {runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency, content = runtimeTemplate.moduleNamespacePromise({
chunkGraph,
module: moduleGraph.getModule(dep),
request: dep.request,
strict: module.buildMeta.strictHarmonyModule,
message: "import() eager",
runtimeRequirements
});
source.replace(dep.range[0], dep.range[1] - 1, content);
}
}, module.exports = ImportEagerDependency;
},
68385: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ContextDependency = __webpack_require__(97818), ModuleDependencyTemplateAsRequireId = __webpack_require__(74362);
class ImportMetaContextDependency extends ContextDependency {
constructor(options, range) {
super(options), this.range = range;
}
get category() {
return "esm";
}
get type() {
return `import.meta.webpackContext ${this.options.mode}`;
}
}
makeSerializable(ImportMetaContextDependency, "webpack/lib/dependencies/ImportMetaContextDependency"), 
ImportMetaContextDependency.Template = ModuleDependencyTemplateAsRequireId, module.exports = ImportMetaContextDependency;
},
73678: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), {evaluateToIdentifier} = __webpack_require__(78802), ImportMetaContextDependency = __webpack_require__(68385);
function createPropertyParseError(prop, expect) {
return createError(`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(prop.key.name)}, expected type ${expect}.`, prop.value.loc);
}
function createError(msg, loc) {
const error = new WebpackError(msg);
return error.name = "ImportMetaContextError", error.loc = loc, error;
}
module.exports = class {
apply(parser) {
parser.hooks.evaluateIdentifier.for("import.meta.webpackContext").tap("HotModuleReplacementPlugin", (expr => evaluateToIdentifier("import.meta.webpackContext", "import.meta", (() => [ "webpackContext" ]), !0)(expr))), 
parser.hooks.call.for("import.meta.webpackContext").tap("ImportMetaContextDependencyParserPlugin", (expr => {
if (expr.arguments.length < 1 || expr.arguments.length > 2) return;
const [directoryNode, optionsNode] = expr.arguments;
if (optionsNode && "ObjectExpression" !== optionsNode.type) return;
const requestExpr = parser.evaluateExpression(directoryNode);
if (!requestExpr.isString()) return;
const request = requestExpr.string, errors = [];
let include, exclude, regExp = /^\.\/.*$/, recursive = !0, mode = "sync";
const groupOptions = {};
let chunkName, exports;
if (optionsNode) for (const prop of optionsNode.properties) {
if ("Property" !== prop.type || "Identifier" !== prop.key.type) {
errors.push(createError("Parsing import.meta.webpackContext options failed.", optionsNode.loc));
break;
}
switch (prop.key.name) {
case "regExp":
{
const regExpExpr = parser.evaluateExpression(prop.value);
regExpExpr.isRegExp() ? regExp = regExpExpr.regExp : errors.push(createPropertyParseError(prop, "RegExp"));
break;
}

case "include":
{
const regExpExpr = parser.evaluateExpression(prop.value);
regExpExpr.isRegExp() ? include = regExpExpr.regExp : errors.push(createPropertyParseError(prop, "RegExp"));
break;
}

case "exclude":
{
const regExpExpr = parser.evaluateExpression(prop.value);
regExpExpr.isRegExp() ? exclude = regExpExpr.regExp : errors.push(createPropertyParseError(prop, "RegExp"));
break;
}

case "mode":
{
const modeExpr = parser.evaluateExpression(prop.value);
modeExpr.isString() ? mode = modeExpr.string : errors.push(createPropertyParseError(prop, "string"));
break;
}

case "chunkName":
{
const expr = parser.evaluateExpression(prop.value);
expr.isString() ? chunkName = expr.string : errors.push(createPropertyParseError(prop, "string"));
break;
}

case "exports":
{
const expr = parser.evaluateExpression(prop.value);
if (expr.isString()) exports = [ [ expr.string ] ]; else if (expr.isArray()) {
const items = expr.items;
if (items.every((i => {
if (!i.isArray()) return !1;
return i.items.every((i => i.isString()));
}))) {
exports = [];
for (const i1 of items) {
const export_ = [];
for (const i2 of i1.items) export_.push(i2.string);
exports.push(export_);
}
} else errors.push(createPropertyParseError(prop, "string|string[][]"));
} else errors.push(createPropertyParseError(prop, "string|string[][]"));
break;
}

case "prefetch":
{
const expr = parser.evaluateExpression(prop.value);
expr.isBoolean() ? groupOptions.prefetchOrder = 0 : expr.isNumber() ? groupOptions.prefetchOrder = expr.number : errors.push(createPropertyParseError(prop, "boolean|number"));
break;
}

case "preload":
{
const expr = parser.evaluateExpression(prop.value);
expr.isBoolean() ? groupOptions.preloadOrder = 0 : expr.isNumber() ? groupOptions.preloadOrder = expr.number : errors.push(createPropertyParseError(prop, "boolean|number"));
break;
}

case "recursive":
{
const recursiveExpr = parser.evaluateExpression(prop.value);
recursiveExpr.isBoolean() ? recursive = recursiveExpr.bool : errors.push(createPropertyParseError(prop, "boolean"));
break;
}

default:
errors.push(createError(`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(prop.key.name)}.`, optionsNode.loc));
}
}
if (errors.length) {
for (const error of errors) parser.state.current.addError(error);
return;
}
const dep = new ImportMetaContextDependency({
request,
include,
exclude,
recursive,
regExp,
groupOptions,
chunkName,
referencedExports: exports,
mode,
category: "esm"
}, expr.range);
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
}));
}
};
},
89402: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ContextElementDependency = __webpack_require__(84407), ImportMetaContextDependency = __webpack_require__(68385), ImportMetaContextDependencyParserPlugin = __webpack_require__(73678);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RequireContextPlugin", ((compilation, {contextModuleFactory, normalModuleFactory}) => {
compilation.dependencyFactories.set(ImportMetaContextDependency, contextModuleFactory), 
compilation.dependencyTemplates.set(ImportMetaContextDependency, new ImportMetaContextDependency.Template), 
compilation.dependencyFactories.set(ContextElementDependency, normalModuleFactory);
const handler = (parser, parserOptions) => {
(void 0 === parserOptions.importMetaContext || parserOptions.importMetaContext) && (new ImportMetaContextDependencyParserPlugin).apply(parser);
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("ImportMetaContextPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("ImportMetaContextPlugin", handler);
}));
}
};
},
35606: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyTemplateAsId = __webpack_require__(13714);
class ImportMetaHotAcceptDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range, this.weak = !0;
}
get type() {
return "import.meta.webpackHot.accept";
}
get category() {
return "esm";
}
}
makeSerializable(ImportMetaHotAcceptDependency, "webpack/lib/dependencies/ImportMetaHotAcceptDependency"), 
ImportMetaHotAcceptDependency.Template = ModuleDependencyTemplateAsId, module.exports = ImportMetaHotAcceptDependency;
},
15234: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyTemplateAsId = __webpack_require__(13714);
class ImportMetaHotDeclineDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range, this.weak = !0;
}
get type() {
return "import.meta.webpackHot.decline";
}
get category() {
return "esm";
}
}
makeSerializable(ImportMetaHotDeclineDependency, "webpack/lib/dependencies/ImportMetaHotDeclineDependency"), 
ImportMetaHotDeclineDependency.Template = ModuleDependencyTemplateAsId, module.exports = ImportMetaHotDeclineDependency;
},
88748: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {pathToFileURL} = __webpack_require__(57310), ModuleDependencyWarning = __webpack_require__(50020), Template = __webpack_require__(88370), BasicEvaluatedExpression = __webpack_require__(47789), {evaluateToIdentifier, toConstantDependency, evaluateToString, evaluateToNumber} = __webpack_require__(78802), memoize = __webpack_require__(98216), propertyAccess = __webpack_require__(10664), ConstDependency = __webpack_require__(30339), getCriticalDependencyWarning = memoize((() => __webpack_require__(14663)));
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("ImportMetaPlugin", ((compilation, {normalModuleFactory}) => {
const getUrl = module => pathToFileURL(module.resource).toString(), parserHandler = (parser, {importMeta}) => {
if (!1 === importMeta) {
const {importMetaName} = compilation.outputOptions;
if ("import.meta" === importMetaName) return;
return void parser.hooks.expression.for("import.meta").tap("ImportMetaPlugin", (metaProperty => {
const dep = new ConstDependency(importMetaName, metaProperty.range);
return dep.loc = metaProperty.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}));
}
parser.hooks.typeof.for("import.meta").tap("ImportMetaPlugin", toConstantDependency(parser, JSON.stringify("object"))), 
parser.hooks.expression.for("import.meta").tap("ImportMetaPlugin", (metaProperty => {
const CriticalDependencyWarning = getCriticalDependencyWarning();
parser.state.module.addWarning(new ModuleDependencyWarning(parser.state.module, new CriticalDependencyWarning("Accessing import.meta directly is unsupported (only property access is supported)"), metaProperty.loc));
const dep = new ConstDependency((parser.isAsiPosition(metaProperty.range[0]) ? ";" : "") + "({})", metaProperty.range);
return dep.loc = metaProperty.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluateTypeof.for("import.meta").tap("ImportMetaPlugin", evaluateToString("object")), 
parser.hooks.evaluateIdentifier.for("import.meta").tap("ImportMetaPlugin", evaluateToIdentifier("import.meta", "import.meta", (() => []), !0)), 
parser.hooks.typeof.for("import.meta.url").tap("ImportMetaPlugin", toConstantDependency(parser, JSON.stringify("string"))), 
parser.hooks.expression.for("import.meta.url").tap("ImportMetaPlugin", (expr => {
const dep = new ConstDependency(JSON.stringify(getUrl(parser.state.module)), expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluateTypeof.for("import.meta.url").tap("ImportMetaPlugin", evaluateToString("string")), 
parser.hooks.evaluateIdentifier.for("import.meta.url").tap("ImportMetaPlugin", (expr => (new BasicEvaluatedExpression).setString(getUrl(parser.state.module)).setRange(expr.range)));
const webpackVersion = parseInt(__webpack_require__(37589).i8, 10);
parser.hooks.typeof.for("import.meta.webpack").tap("ImportMetaPlugin", toConstantDependency(parser, JSON.stringify("number"))), 
parser.hooks.expression.for("import.meta.webpack").tap("ImportMetaPlugin", toConstantDependency(parser, JSON.stringify(webpackVersion))), 
parser.hooks.evaluateTypeof.for("import.meta.webpack").tap("ImportMetaPlugin", evaluateToString("number")), 
parser.hooks.evaluateIdentifier.for("import.meta.webpack").tap("ImportMetaPlugin", evaluateToNumber(webpackVersion)), 
parser.hooks.unhandledExpressionMemberChain.for("import.meta").tap("ImportMetaPlugin", ((expr, members) => {
const dep = new ConstDependency(`${Template.toNormalComment("unsupported import.meta." + members.join("."))} undefined${propertyAccess(members, 1)}`, expr.range);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.evaluate.for("MemberExpression").tap("ImportMetaPlugin", (expression => {
const expr = expression;
if ("MetaProperty" === expr.object.type && "import" === expr.object.meta.name && "meta" === expr.object.property.name && expr.property.type === (expr.computed ? "Literal" : "Identifier")) return (new BasicEvaluatedExpression).setUndefined().setRange(expr.range);
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("ImportMetaPlugin", parserHandler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("ImportMetaPlugin", parserHandler);
}));
}
};
},
93201: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const AsyncDependenciesBlock = __webpack_require__(89353), CommentCompilationWarning = __webpack_require__(35931), UnsupportedFeatureWarning = __webpack_require__(3490), ContextDependencyHelpers = __webpack_require__(52963), ImportContextDependency = __webpack_require__(99554), ImportDependency = __webpack_require__(75035), ImportEagerDependency = __webpack_require__(76636), ImportWeakDependency = __webpack_require__(1);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(parser) {
parser.hooks.importCall.tap("ImportParserPlugin", (expr => {
const param = parser.evaluateExpression(expr.source);
let chunkName = null, mode = this.options.dynamicImportMode, include = null, exclude = null, exports = null;
const groupOptions = {}, {dynamicImportPreload, dynamicImportPrefetch} = this.options;
void 0 !== dynamicImportPreload && !1 !== dynamicImportPreload && (groupOptions.preloadOrder = !0 === dynamicImportPreload ? 0 : dynamicImportPreload), 
void 0 !== dynamicImportPrefetch && !1 !== dynamicImportPrefetch && (groupOptions.prefetchOrder = !0 === dynamicImportPrefetch ? 0 : dynamicImportPrefetch);
const {options: importOptions, errors: commentErrors} = parser.parseCommentOptions(expr.range);
if (commentErrors) for (const e of commentErrors) {
const {comment} = e;
parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));
}
if (importOptions) {
if (void 0 !== importOptions.webpackIgnore) if ("boolean" != typeof importOptions.webpackIgnore) parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackIgnore\` expected a boolean, but received: ${importOptions.webpackIgnore}.`, expr.loc)); else if (importOptions.webpackIgnore) return !1;
void 0 !== importOptions.webpackChunkName && ("string" != typeof importOptions.webpackChunkName ? parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackChunkName\` expected a string, but received: ${importOptions.webpackChunkName}.`, expr.loc)) : chunkName = importOptions.webpackChunkName), 
void 0 !== importOptions.webpackMode && ("string" != typeof importOptions.webpackMode ? parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackMode\` expected a string, but received: ${importOptions.webpackMode}.`, expr.loc)) : mode = importOptions.webpackMode), 
void 0 !== importOptions.webpackPrefetch && (!0 === importOptions.webpackPrefetch ? groupOptions.prefetchOrder = 0 : "number" == typeof importOptions.webpackPrefetch ? groupOptions.prefetchOrder = importOptions.webpackPrefetch : parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackPrefetch\` expected true or a number, but received: ${importOptions.webpackPrefetch}.`, expr.loc))), 
void 0 !== importOptions.webpackPreload && (!0 === importOptions.webpackPreload ? groupOptions.preloadOrder = 0 : "number" == typeof importOptions.webpackPreload ? groupOptions.preloadOrder = importOptions.webpackPreload : parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackPreload\` expected true or a number, but received: ${importOptions.webpackPreload}.`, expr.loc))), 
void 0 !== importOptions.webpackInclude && (importOptions.webpackInclude && "RegExp" === importOptions.webpackInclude.constructor.name ? include = new RegExp(importOptions.webpackInclude) : parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackInclude\` expected a regular expression, but received: ${importOptions.webpackInclude}.`, expr.loc))), 
void 0 !== importOptions.webpackExclude && (importOptions.webpackExclude && "RegExp" === importOptions.webpackExclude.constructor.name ? exclude = new RegExp(importOptions.webpackExclude) : parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackExclude\` expected a regular expression, but received: ${importOptions.webpackExclude}.`, expr.loc))), 
void 0 !== importOptions.webpackExports && ("string" == typeof importOptions.webpackExports || Array.isArray(importOptions.webpackExports) && importOptions.webpackExports.every((item => "string" == typeof item)) ? exports = "string" == typeof importOptions.webpackExports ? [ [ importOptions.webpackExports ] ] : Array.from(importOptions.webpackExports, (e => [ e ])) : parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackExports\` expected a string or an array of strings, but received: ${importOptions.webpackExports}.`, expr.loc)));
}
if ("lazy" !== mode && "lazy-once" !== mode && "eager" !== mode && "weak" !== mode && (parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackMode\` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ${mode}.`, expr.loc)), 
mode = "lazy"), param.isString()) {
if ("eager" === mode) {
const dep = new ImportEagerDependency(param.string, expr.range, exports);
parser.state.current.addDependency(dep);
} else if ("weak" === mode) {
const dep = new ImportWeakDependency(param.string, expr.range, exports);
parser.state.current.addDependency(dep);
} else {
const depBlock = new AsyncDependenciesBlock({
...groupOptions,
name: chunkName
}, expr.loc, param.string), dep = new ImportDependency(param.string, expr.range, exports);
dep.loc = expr.loc, depBlock.addDependency(dep), parser.state.current.addBlock(depBlock);
}
return !0;
}
{
"weak" === mode && (mode = "async-weak");
const dep = ContextDependencyHelpers.create(ImportContextDependency, expr.range, param, expr, this.options, {
chunkName,
groupOptions,
include,
exclude,
mode,
namespaceObject: !parser.state.module.buildMeta.strictHarmonyModule || "strict",
typePrefix: "import()",
category: "esm",
referencedExports: exports
}, parser);
if (!dep) return;
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
}
}));
}
};
},
32011: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ImportContextDependency = __webpack_require__(99554), ImportDependency = __webpack_require__(75035), ImportEagerDependency = __webpack_require__(76636), ImportParserPlugin = __webpack_require__(93201), ImportWeakDependency = __webpack_require__(1);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("ImportPlugin", ((compilation, {contextModuleFactory, normalModuleFactory}) => {
compilation.dependencyFactories.set(ImportDependency, normalModuleFactory), compilation.dependencyTemplates.set(ImportDependency, new ImportDependency.Template), 
compilation.dependencyFactories.set(ImportEagerDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(ImportEagerDependency, new ImportEagerDependency.Template), 
compilation.dependencyFactories.set(ImportWeakDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(ImportWeakDependency, new ImportWeakDependency.Template), 
compilation.dependencyFactories.set(ImportContextDependency, contextModuleFactory), 
compilation.dependencyTemplates.set(ImportContextDependency, new ImportContextDependency.Template);
const handler = (parser, parserOptions) => {
(void 0 === parserOptions.import || parserOptions.import) && new ImportParserPlugin(parserOptions).apply(parser);
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("ImportPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ImportPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("ImportPlugin", handler);
}));
}
};
},
1: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ImportDependency = __webpack_require__(75035);
class ImportWeakDependency extends ImportDependency {
constructor(request, range, referencedExports) {
super(request, range, referencedExports), this.weak = !0;
}
get type() {
return "import() weak";
}
}
makeSerializable(ImportWeakDependency, "webpack/lib/dependencies/ImportWeakDependency"), 
ImportWeakDependency.Template = class extends ImportDependency.Template {
apply(dependency, source, {runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency, content = runtimeTemplate.moduleNamespacePromise({
chunkGraph,
module: moduleGraph.getModule(dep),
request: dep.request,
strict: module.buildMeta.strictHarmonyModule,
message: "import() weak",
weak: !0,
runtimeRequirements
});
source.replace(dep.range[0], dep.range[1] - 1, content);
}
}, module.exports = ImportWeakDependency;
},
94084: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649), getExportsFromData = data => {
if (data && "object" == typeof data) {
if (Array.isArray(data)) return data.length < 100 ? data.map(((item, idx) => ({
name: `${idx}`,
canMangle: !0,
exports: getExportsFromData(item)
}))) : void 0;
{
const exports = [];
for (const key of Object.keys(data)) exports.push({
name: key,
canMangle: !0,
exports: getExportsFromData(data[key])
});
return exports;
}
}
};
class JsonExportsDependency extends NullDependency {
constructor(data) {
super(), this.data = data;
}
get type() {
return "json exports";
}
getExports(moduleGraph) {
return {
exports: getExportsFromData(this.data && this.data.get()),
dependencies: void 0
};
}
updateHash(hash, context) {
this.data.updateHash(hash);
}
serialize(context) {
const {write} = context;
write(this.data), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.data = read(), super.deserialize(context);
}
}
makeSerializable(JsonExportsDependency, "webpack/lib/dependencies/JsonExportsDependency"), 
module.exports = JsonExportsDependency;
},
4861: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216);
module.exports = class extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "loader";
}
get category() {
return "loader";
}
getCondition(moduleGraph) {
return !1;
}
};
},
16627: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216);
module.exports = class extends ModuleDependency {
constructor(request) {
super(request), this.weak = !0;
}
get type() {
return "loader import";
}
get category() {
return "loaderImport";
}
getCondition(moduleGraph) {
return !1;
}
};
},
61073: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const NormalModule = __webpack_require__(3213), LazySet = __webpack_require__(92585), LoaderDependency = __webpack_require__(4861), LoaderImportDependency = __webpack_require__(16627);
module.exports = class {
constructor(options = {}) {}
apply(compiler) {
compiler.hooks.compilation.tap("LoaderPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory), compilation.dependencyFactories.set(LoaderImportDependency, normalModuleFactory);
})), compiler.hooks.compilation.tap("LoaderPlugin", (compilation => {
const moduleGraph = compilation.moduleGraph;
NormalModule.getCompilationHooks(compilation).loader.tap("LoaderPlugin", (loaderContext => {
loaderContext.loadModule = (request, callback) => {
const dep = new LoaderDependency(request);
dep.loc = {
name: request
};
const factory = compilation.dependencyFactories.get(dep.constructor);
if (void 0 === factory) return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));
compilation.buildQueue.increaseParallelism(), compilation.handleModuleCreation({
factory,
dependencies: [ dep ],
originModule: loaderContext._module,
context: loaderContext.context,
recursive: !1
}, (err => {
if (compilation.buildQueue.decreaseParallelism(), err) return callback(err);
const referencedModule = moduleGraph.getModule(dep);
if (!referencedModule) return callback(new Error("Cannot load the module"));
if (referencedModule.getNumberOfErrors() > 0) return callback(new Error("The loaded module contains errors"));
const moduleSource = referencedModule.originalSource();
if (!moduleSource) return callback(new Error("The module created for a LoaderDependency must have an original source"));
let source, map;
if (moduleSource.sourceAndMap) {
const sourceAndMap = moduleSource.sourceAndMap();
map = sourceAndMap.map, source = sourceAndMap.source;
} else map = moduleSource.map(), source = moduleSource.source();
const fileDependencies = new LazySet, contextDependencies = new LazySet, missingDependencies = new LazySet, buildDependencies = new LazySet;
referencedModule.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);
for (const d of fileDependencies) loaderContext.addDependency(d);
for (const d of contextDependencies) loaderContext.addContextDependency(d);
for (const d of missingDependencies) loaderContext.addMissingDependency(d);
for (const d of buildDependencies) loaderContext.addBuildDependency(d);
return callback(null, source, map, referencedModule);
}));
};
const importModule = (request, options, callback) => {
const dep = new LoaderImportDependency(request);
dep.loc = {
name: request
};
const factory = compilation.dependencyFactories.get(dep.constructor);
if (void 0 === factory) return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));
compilation.buildQueue.increaseParallelism(), compilation.handleModuleCreation({
factory,
dependencies: [ dep ],
originModule: loaderContext._module,
contextInfo: {
issuerLayer: options.layer
},
context: loaderContext.context,
connectOrigin: !1
}, (err => {
if (compilation.buildQueue.decreaseParallelism(), err) return callback(err);
const referencedModule = moduleGraph.getModule(dep);
if (!referencedModule) return callback(new Error("Cannot load the module"));
compilation.executeModule(referencedModule, {
entryOptions: {
baseUri: options.baseUri,
publicPath: options.publicPath
}
}, ((err, result) => {
if (err) return callback(err);
for (const d of result.fileDependencies) loaderContext.addDependency(d);
for (const d of result.contextDependencies) loaderContext.addContextDependency(d);
for (const d of result.missingDependencies) loaderContext.addMissingDependency(d);
for (const d of result.buildDependencies) loaderContext.addBuildDependency(d);
!1 === result.cacheable && loaderContext.cacheable(!1);
for (const [name, {source, info}] of result.assets) {
const {buildInfo} = loaderContext._module;
buildInfo.assets || (buildInfo.assets = Object.create(null), buildInfo.assetsInfo = new Map), 
buildInfo.assets[name] = source, buildInfo.assetsInfo.set(name, info);
}
callback(null, result.exports);
}));
}));
};
loaderContext.importModule = (request, options, callback) => callback ? importModule(request, options || {}, callback) : new Promise(((resolve, reject) => {
importModule(request, options || {}, ((err, result) => {
err ? reject(err) : resolve(result);
}));
}));
}));
}));
}
};
},
37937: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898);
class LocalModule {
constructor(name, idx) {
this.name = name, this.idx = idx, this.used = !1;
}
flagUsed() {
this.used = !0;
}
variableName() {
return "__WEBPACK_LOCAL_MODULE_" + this.idx + "__";
}
serialize(context) {
const {write} = context;
write(this.name), write(this.idx), write(this.used);
}
deserialize(context) {
const {read} = context;
this.name = read(), this.idx = read(), this.used = read();
}
}
makeSerializable(LocalModule, "webpack/lib/dependencies/LocalModule"), module.exports = LocalModule;
},
7306: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class LocalModuleDependency extends NullDependency {
constructor(localModule, range, callNew) {
super(), this.localModule = localModule, this.range = range, this.callNew = callNew;
}
serialize(context) {
const {write} = context;
write(this.localModule), write(this.range), write(this.callNew), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.localModule = read(), this.range = read(), this.callNew = read(), super.deserialize(context);
}
}
makeSerializable(LocalModuleDependency, "webpack/lib/dependencies/LocalModuleDependency"), 
LocalModuleDependency.Template = class extends NullDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency;
if (!dep.range) return;
const moduleInstance = dep.callNew ? `new (function () { return ${dep.localModule.variableName()}; })()` : dep.localModule.variableName();
source.replace(dep.range[0], dep.range[1] - 1, moduleInstance);
}
}, module.exports = LocalModuleDependency;
},
81603: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const LocalModule = __webpack_require__(37937);
exports.addLocalModule = (state, name) => {
state.localModules || (state.localModules = []);
const m = new LocalModule(name, state.localModules.length);
return state.localModules.push(m), m;
}, exports.getLocalModule = (state, name, namedModule) => {
if (!state.localModules) return null;
namedModule && (name = ((parent, mod) => {
if ("." !== mod.charAt(0)) return mod;
var path = parent.split("/"), segments = mod.split("/");
path.pop();
for (let i = 0; i < segments.length; i++) {
const seg = segments[i];
".." === seg ? path.pop() : "." !== seg && path.push(seg);
}
return path.join("/");
})(namedModule, name));
for (let i = 0; i < state.localModules.length; i++) if (state.localModules[i].name === name) return state.localModules[i];
return null;
};
},
90331: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class ModuleDecoratorDependency extends NullDependency {
constructor(decorator, allowExportsAccess) {
super(), this.decorator = decorator, this.allowExportsAccess = allowExportsAccess, 
this._hashUpdate = void 0;
}
get type() {
return "module decorator";
}
get category() {
return "self";
}
getResourceIdentifier() {
return "self";
}
getReferencedExports(moduleGraph, runtime) {
return this.allowExportsAccess ? Dependency.EXPORTS_OBJECT_REFERENCED : Dependency.NO_EXPORTS_REFERENCED;
}
updateHash(hash, context) {
void 0 === this._hashUpdate && (this._hashUpdate = `${this.decorator}${this.allowExportsAccess}`), 
hash.update(this._hashUpdate);
}
serialize(context) {
const {write} = context;
write(this.decorator), write(this.allowExportsAccess), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.decorator = read(), this.allowExportsAccess = read(), super.deserialize(context);
}
}
makeSerializable(ModuleDecoratorDependency, "webpack/lib/dependencies/ModuleDecoratorDependency"), 
ModuleDecoratorDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {module, chunkGraph, initFragments, runtimeRequirements}) {
const dep = dependency;
runtimeRequirements.add(RuntimeGlobals.moduleLoaded), runtimeRequirements.add(RuntimeGlobals.moduleId), 
runtimeRequirements.add(RuntimeGlobals.module), runtimeRequirements.add(dep.decorator), 
initFragments.push(new InitFragment(`/* module decorator */ ${module.moduleArgument} = ${dep.decorator}(${module.moduleArgument});\n`, InitFragment.STAGE_PROVIDES, 0, `module decorator ${chunkGraph.getModuleId(module)}`));
}
}, module.exports = ModuleDecoratorDependency;
},
15216: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), DependencyTemplate = __webpack_require__(44515), getRawModule = __webpack_require__(98216)((() => __webpack_require__(85315)));
class ModuleDependency extends Dependency {
constructor(request) {
super(), this.request = request, this.userRequest = request, this.range = void 0, 
this.assertions = void 0, this._context = void 0;
}
getContext() {
return this._context;
}
getResourceIdentifier() {
let str = `context${this._context || ""}|module${this.request}`;
return void 0 !== this.assertions && (str += JSON.stringify(this.assertions)), str;
}
couldAffectReferencingModule() {
return !0;
}
createIgnoredModule(context) {
return new (getRawModule())("/* (ignored) */", `ignored|${context}|${this.request}`, `${this.request} (ignored)`);
}
serialize(context) {
const {write} = context;
write(this.request), write(this.userRequest), write(this._context), write(this.range), 
super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.request = read(), this.userRequest = read(), this._context = read(), this.range = read(), 
super.deserialize(context);
}
}
ModuleDependency.Template = DependencyTemplate, module.exports = ModuleDependency;
},
13714: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216);
class ModuleDependencyTemplateAsId extends ModuleDependency.Template {
apply(dependency, source, {runtimeTemplate, moduleGraph, chunkGraph}) {
const dep = dependency;
if (!dep.range) return;
const content = runtimeTemplate.moduleId({
module: moduleGraph.getModule(dep),
chunkGraph,
request: dep.request,
weak: dep.weak
});
source.replace(dep.range[0], dep.range[1] - 1, content);
}
}
module.exports = ModuleDependencyTemplateAsId;
},
74362: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216);
class ModuleDependencyTemplateAsRequireId extends ModuleDependency.Template {
apply(dependency, source, {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency;
if (!dep.range) return;
const content = runtimeTemplate.moduleExports({
module: moduleGraph.getModule(dep),
chunkGraph,
request: dep.request,
weak: dep.weak,
runtimeRequirements
});
source.replace(dep.range[0], dep.range[1] - 1, content);
}
}
module.exports = ModuleDependencyTemplateAsRequireId;
},
50994: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyTemplateAsId = __webpack_require__(13714);
class ModuleHotAcceptDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range, this.weak = !0;
}
get type() {
return "module.hot.accept";
}
get category() {
return "commonjs";
}
}
makeSerializable(ModuleHotAcceptDependency, "webpack/lib/dependencies/ModuleHotAcceptDependency"), 
ModuleHotAcceptDependency.Template = ModuleDependencyTemplateAsId, module.exports = ModuleHotAcceptDependency;
},
60219: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyTemplateAsId = __webpack_require__(13714);
class ModuleHotDeclineDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range, this.weak = !0;
}
get type() {
return "module.hot.decline";
}
get category() {
return "commonjs";
}
}
makeSerializable(ModuleHotDeclineDependency, "webpack/lib/dependencies/ModuleHotDeclineDependency"), 
ModuleHotDeclineDependency.Template = ModuleDependencyTemplateAsId, module.exports = ModuleHotDeclineDependency;
},
52649: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), DependencyTemplate = __webpack_require__(44515);
class NullDependency extends Dependency {
get type() {
return "null";
}
couldAffectReferencingModule() {
return !1;
}
}
NullDependency.Template = class extends DependencyTemplate {
apply(dependency, source, templateContext) {}
}, module.exports = NullDependency;
},
63352: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216);
module.exports = class extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "prefetch";
}
get category() {
return "esm";
}
};
},
37386: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), InitFragment = __webpack_require__(95328), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class ProvidedDependency extends ModuleDependency {
constructor(request, identifier, ids, range) {
super(request), this.identifier = identifier, this.ids = ids, this.range = range, 
this._hashUpdate = void 0;
}
get type() {
return "provided";
}
get category() {
return "esm";
}
getReferencedExports(moduleGraph, runtime) {
let ids = this.ids;
return 0 === ids.length ? Dependency.EXPORTS_OBJECT_REFERENCED : [ ids ];
}
updateHash(hash, context) {
void 0 === this._hashUpdate && (this._hashUpdate = this.identifier + (this.ids ? this.ids.join(",") : "")), 
hash.update(this._hashUpdate);
}
serialize(context) {
const {write} = context;
write(this.identifier), write(this.ids), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.identifier = read(), this.ids = read(), super.deserialize(context);
}
}
makeSerializable(ProvidedDependency, "webpack/lib/dependencies/ProvidedDependency");
class ProvidedDependencyTemplate extends ModuleDependency.Template {
apply(dependency, source, {runtime, runtimeTemplate, moduleGraph, chunkGraph, initFragments, runtimeRequirements}) {
const dep = dependency, connection = moduleGraph.getConnection(dep), usedName = moduleGraph.getExportsInfo(connection.module).getUsedName(dep.ids, runtime);
var path;
initFragments.push(new InitFragment(`/* provided dependency */ var ${dep.identifier} = ${runtimeTemplate.moduleExports({
module: moduleGraph.getModule(dep),
chunkGraph,
request: dep.request,
runtimeRequirements
})}${path = usedName, null !== path && path.length > 0 ? path.map((part => `[${JSON.stringify(part)}]`)).join("") : ""};\n`, InitFragment.STAGE_PROVIDES, 1, `provided ${dep.identifier}`)), 
source.replace(dep.range[0], dep.range[1] - 1, dep.identifier);
}
}
ProvidedDependency.Template = ProvidedDependencyTemplate, module.exports = ProvidedDependency;
},
3988: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {UsageState} = __webpack_require__(74603), makeSerializable = __webpack_require__(45898), {filterRuntime} = __webpack_require__(14372), NullDependency = __webpack_require__(52649);
class PureExpressionDependency extends NullDependency {
constructor(range) {
super(), this.range = range, this.usedByExports = !1, this._hashUpdate = void 0;
}
updateHash(hash, context) {
void 0 === this._hashUpdate && (this._hashUpdate = this.range + ""), hash.update(this._hashUpdate);
}
getModuleEvaluationSideEffectsState(moduleGraph) {
return !1;
}
serialize(context) {
const {write} = context;
write(this.range), write(this.usedByExports), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.usedByExports = read(), super.deserialize(context);
}
}
makeSerializable(PureExpressionDependency, "webpack/lib/dependencies/PureExpressionDependency"), 
PureExpressionDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {chunkGraph, moduleGraph, runtime, runtimeTemplate, runtimeRequirements}) {
const dep = dependency, usedByExports = dep.usedByExports;
if (!1 !== usedByExports) {
const selfModule = moduleGraph.getParentModule(dep), exportsInfo = moduleGraph.getExportsInfo(selfModule), runtimeCondition = filterRuntime(runtime, (runtime => {
for (const exportName of usedByExports) if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return !0;
return !1;
}));
if (!0 === runtimeCondition) return;
if (!1 !== runtimeCondition) {
const condition = runtimeTemplate.runtimeConditionExpression({
chunkGraph,
runtime,
runtimeCondition,
runtimeRequirements
});
return source.insert(dep.range[0], `(/* runtime-dependent pure expression or super */ ${condition} ? (`), 
void source.insert(dep.range[1], ") : null)");
}
}
source.insert(dep.range[0], "(/* unused pure expression or super */ null && ("), 
source.insert(dep.range[1], "))");
}
}, module.exports = PureExpressionDependency;
},
71051: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ContextDependency = __webpack_require__(97818), ModuleDependencyTemplateAsRequireId = __webpack_require__(74362);
class RequireContextDependency extends ContextDependency {
constructor(options, range) {
super(options), this.range = range;
}
get type() {
return "require.context";
}
}
makeSerializable(RequireContextDependency, "webpack/lib/dependencies/RequireContextDependency"), 
RequireContextDependency.Template = ModuleDependencyTemplateAsRequireId, module.exports = RequireContextDependency;
},
47057: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RequireContextDependency = __webpack_require__(71051);
module.exports = class {
apply(parser) {
parser.hooks.call.for("require.context").tap("RequireContextDependencyParserPlugin", (expr => {
let regExp = /^\.\/.*$/, recursive = !0, mode = "sync";
switch (expr.arguments.length) {
case 4:
{
const modeExpr = parser.evaluateExpression(expr.arguments[3]);
if (!modeExpr.isString()) return;
mode = modeExpr.string;
}

case 3:
{
const regExpExpr = parser.evaluateExpression(expr.arguments[2]);
if (!regExpExpr.isRegExp()) return;
regExp = regExpExpr.regExp;
}

case 2:
{
const recursiveExpr = parser.evaluateExpression(expr.arguments[1]);
if (!recursiveExpr.isBoolean()) return;
recursive = recursiveExpr.bool;
}

case 1:
{
const requestExpr = parser.evaluateExpression(expr.arguments[0]);
if (!requestExpr.isString()) return;
const dep = new RequireContextDependency({
request: requestExpr.string,
recursive,
regExp,
mode,
category: "commonjs"
}, expr.range);
return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
!0;
}
}
}));
}
};
},
30842: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {cachedSetProperty} = __webpack_require__(8639), ContextElementDependency = __webpack_require__(84407), RequireContextDependency = __webpack_require__(71051), RequireContextDependencyParserPlugin = __webpack_require__(47057), EMPTY_RESOLVE_OPTIONS = {};
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RequireContextPlugin", ((compilation, {contextModuleFactory, normalModuleFactory}) => {
compilation.dependencyFactories.set(RequireContextDependency, contextModuleFactory), 
compilation.dependencyTemplates.set(RequireContextDependency, new RequireContextDependency.Template), 
compilation.dependencyFactories.set(ContextElementDependency, normalModuleFactory);
const handler = (parser, parserOptions) => {
(void 0 === parserOptions.requireContext || parserOptions.requireContext) && (new RequireContextDependencyParserPlugin).apply(parser);
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireContextPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireContextPlugin", handler), 
contextModuleFactory.hooks.alternativeRequests.tap("RequireContextPlugin", ((items, options) => {
if (0 === items.length) return items;
const finalResolveOptions = compiler.resolverFactory.get("normal", cachedSetProperty(options.resolveOptions || EMPTY_RESOLVE_OPTIONS, "dependencyType", options.category)).options;
let newItems;
if (!finalResolveOptions.fullySpecified) {
newItems = [];
for (const item of items) {
const {request, context} = item;
for (const ext of finalResolveOptions.extensions) request.endsWith(ext) && newItems.push({
context,
request: request.slice(0, -ext.length)
});
finalResolveOptions.enforceExtension || newItems.push(item);
}
items = newItems, newItems = [];
for (const obj of items) {
const {request, context} = obj;
for (const mainFile of finalResolveOptions.mainFiles) request.endsWith(`/${mainFile}`) && (newItems.push({
context,
request: request.slice(0, -mainFile.length)
}), newItems.push({
context,
request: request.slice(0, -mainFile.length - 1)
}));
newItems.push(obj);
}
items = newItems;
}
newItems = [];
for (const item of items) {
let hideOriginal = !1;
for (const modulesItems of finalResolveOptions.modules) if (Array.isArray(modulesItems)) for (const dir of modulesItems) item.request.startsWith(`./${dir}/`) && (newItems.push({
context: item.context,
request: item.request.slice(dir.length + 3)
}), hideOriginal = !0); else {
const dir = modulesItems.replace(/\\/g, "/"), fullPath = item.context.replace(/\\/g, "/") + item.request.slice(1);
fullPath.startsWith(dir) && newItems.push({
context: item.context,
request: fullPath.slice(dir.length + 1)
});
}
hideOriginal || newItems.push(item);
}
return newItems;
}));
}));
}
};
},
47603: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const AsyncDependenciesBlock = __webpack_require__(89353), makeSerializable = __webpack_require__(45898);
class RequireEnsureDependenciesBlock extends AsyncDependenciesBlock {
constructor(chunkName, loc) {
super(chunkName, loc, null);
}
}
makeSerializable(RequireEnsureDependenciesBlock, "webpack/lib/dependencies/RequireEnsureDependenciesBlock"), 
module.exports = RequireEnsureDependenciesBlock;
},
6221: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RequireEnsureDependenciesBlock = __webpack_require__(47603), RequireEnsureDependency = __webpack_require__(43286), RequireEnsureItemDependency = __webpack_require__(69567), getFunctionExpression = __webpack_require__(40142);
module.exports = class {
apply(parser) {
parser.hooks.call.for("require.ensure").tap("RequireEnsureDependenciesBlockParserPlugin", (expr => {
let chunkName = null, errorExpressionArg = null, errorExpression = null;
switch (expr.arguments.length) {
case 4:
{
const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
if (!chunkNameExpr.isString()) return;
chunkName = chunkNameExpr.string;
}

case 3:
if (errorExpressionArg = expr.arguments[2], errorExpression = getFunctionExpression(errorExpressionArg), 
!errorExpression && !chunkName) {
const chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);
if (!chunkNameExpr.isString()) return;
chunkName = chunkNameExpr.string;
}

case 2:
{
const dependenciesExpr = parser.evaluateExpression(expr.arguments[0]), dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [ dependenciesExpr ], successExpressionArg = expr.arguments[1], successExpression = getFunctionExpression(successExpressionArg);
successExpression && parser.walkExpressions(successExpression.expressions), errorExpression && parser.walkExpressions(errorExpression.expressions);
const depBlock = new RequireEnsureDependenciesBlock(chunkName, expr.loc), errorCallbackExists = 4 === expr.arguments.length || !chunkName && 3 === expr.arguments.length, dep = new RequireEnsureDependency(expr.range, expr.arguments[1].range, errorCallbackExists && expr.arguments[2].range);
dep.loc = expr.loc, depBlock.addDependency(dep);
const old = parser.state.current;
parser.state.current = depBlock;
try {
let failed = !1;
if (parser.inScope([], (() => {
for (const ee of dependenciesItems) if (ee.isString()) {
const ensureDependency = new RequireEnsureItemDependency(ee.string);
ensureDependency.loc = ee.loc || expr.loc, depBlock.addDependency(ensureDependency);
} else failed = !0;
})), failed) return;
successExpression && ("BlockStatement" === successExpression.fn.body.type ? parser.walkStatement(successExpression.fn.body) : parser.walkExpression(successExpression.fn.body)), 
old.addBlock(depBlock);
} finally {
parser.state.current = old;
}
return successExpression || parser.walkExpression(successExpressionArg), errorExpression ? "BlockStatement" === errorExpression.fn.body.type ? parser.walkStatement(errorExpression.fn.body) : parser.walkExpression(errorExpression.fn.body) : errorExpressionArg && parser.walkExpression(errorExpressionArg), 
!0;
}
}
}));
}
};
},
43286: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class RequireEnsureDependency extends NullDependency {
constructor(range, contentRange, errorHandlerRange) {
super(), this.range = range, this.contentRange = contentRange, this.errorHandlerRange = errorHandlerRange;
}
get type() {
return "require.ensure";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.contentRange), write(this.errorHandlerRange), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.contentRange = read(), this.errorHandlerRange = read(), 
super.deserialize(context);
}
}
makeSerializable(RequireEnsureDependency, "webpack/lib/dependencies/RequireEnsureDependency"), 
RequireEnsureDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements}) {
const dep = dependency, depBlock = moduleGraph.getParentBlock(dep), promise = runtimeTemplate.blockPromise({
chunkGraph,
block: depBlock,
message: "require.ensure",
runtimeRequirements
}), range = dep.range, contentRange = dep.contentRange, errorHandlerRange = dep.errorHandlerRange;
source.replace(range[0], contentRange[0] - 1, `${promise}.then((`), errorHandlerRange ? (source.replace(contentRange[1], errorHandlerRange[0] - 1, ").bind(null, __webpack_require__))['catch']("), 
source.replace(errorHandlerRange[1], range[1] - 1, ")")) : source.replace(contentRange[1], range[1] - 1, `).bind(null, __webpack_require__))['catch'](${RuntimeGlobals.uncaughtErrorHandler})`);
}
}, module.exports = RequireEnsureDependency;
},
69567: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), NullDependency = __webpack_require__(52649);
class RequireEnsureItemDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "require.ensure item";
}
get category() {
return "commonjs";
}
}
makeSerializable(RequireEnsureItemDependency, "webpack/lib/dependencies/RequireEnsureItemDependency"), 
RequireEnsureItemDependency.Template = NullDependency.Template, module.exports = RequireEnsureItemDependency;
},
9537: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RequireEnsureDependency = __webpack_require__(43286), RequireEnsureItemDependency = __webpack_require__(69567), RequireEnsureDependenciesBlockParserPlugin = __webpack_require__(6221), {evaluateToString, toConstantDependency} = __webpack_require__(78802);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RequireEnsurePlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(RequireEnsureItemDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(RequireEnsureItemDependency, new RequireEnsureItemDependency.Template), 
compilation.dependencyTemplates.set(RequireEnsureDependency, new RequireEnsureDependency.Template);
const handler = (parser, parserOptions) => {
(void 0 === parserOptions.requireEnsure || parserOptions.requireEnsure) && ((new RequireEnsureDependenciesBlockParserPlugin).apply(parser), 
parser.hooks.evaluateTypeof.for("require.ensure").tap("RequireEnsurePlugin", evaluateToString("function")), 
parser.hooks.typeof.for("require.ensure").tap("RequireEnsurePlugin", toConstantDependency(parser, JSON.stringify("function"))));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireEnsurePlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireEnsurePlugin", handler);
}));
}
};
},
24547: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class RequireHeaderDependency extends NullDependency {
constructor(range) {
if (super(), !Array.isArray(range)) throw new Error("range must be valid");
this.range = range;
}
serialize(context) {
const {write} = context;
write(this.range), super.serialize(context);
}
static deserialize(context) {
const obj = new RequireHeaderDependency(context.read());
return obj.deserialize(context), obj;
}
}
makeSerializable(RequireHeaderDependency, "webpack/lib/dependencies/RequireHeaderDependency"), 
RequireHeaderDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeRequirements}) {
const dep = dependency;
runtimeRequirements.add(RuntimeGlobals.require), source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__");
}
}, module.exports = RequireHeaderDependency;
},
79788: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), Template = __webpack_require__(88370), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class RequireIncludeDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range;
}
getReferencedExports(moduleGraph, runtime) {
return Dependency.NO_EXPORTS_REFERENCED;
}
get type() {
return "require.include";
}
get category() {
return "commonjs";
}
}
makeSerializable(RequireIncludeDependency, "webpack/lib/dependencies/RequireIncludeDependency"), 
RequireIncludeDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, {runtimeTemplate}) {
const dep = dependency, comment = runtimeTemplate.outputOptions.pathinfo ? Template.toComment(`require.include ${runtimeTemplate.requestShortener.shorten(dep.request)}`) : "";
source.replace(dep.range[0], dep.range[1] - 1, `undefined${comment}`);
}
}, module.exports = RequireIncludeDependency;
},
14713: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), {evaluateToString, toConstantDependency} = __webpack_require__(78802), makeSerializable = __webpack_require__(45898), RequireIncludeDependency = __webpack_require__(79788);
module.exports = class {
constructor(warn) {
this.warn = warn;
}
apply(parser) {
const {warn} = this;
parser.hooks.call.for("require.include").tap("RequireIncludeDependencyParserPlugin", (expr => {
if (1 !== expr.arguments.length) return;
const param = parser.evaluateExpression(expr.arguments[0]);
if (!param.isString()) return;
warn && parser.state.module.addWarning(new RequireIncludeDeprecationWarning(expr.loc));
const dep = new RequireIncludeDependency(param.string, expr.range);
return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
})), parser.hooks.evaluateTypeof.for("require.include").tap("RequireIncludePlugin", (expr => (warn && parser.state.module.addWarning(new RequireIncludeDeprecationWarning(expr.loc)), 
evaluateToString("function")(expr)))), parser.hooks.typeof.for("require.include").tap("RequireIncludePlugin", (expr => (warn && parser.state.module.addWarning(new RequireIncludeDeprecationWarning(expr.loc)), 
toConstantDependency(parser, JSON.stringify("function"))(expr))));
}
};
class RequireIncludeDeprecationWarning extends WebpackError {
constructor(loc) {
super("require.include() is deprecated and will be removed soon."), this.name = "RequireIncludeDeprecationWarning", 
this.loc = loc;
}
}
makeSerializable(RequireIncludeDeprecationWarning, "webpack/lib/dependencies/RequireIncludeDependencyParserPlugin", "RequireIncludeDeprecationWarning");
},
52505: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RequireIncludeDependency = __webpack_require__(79788), RequireIncludeDependencyParserPlugin = __webpack_require__(14713);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RequireIncludePlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(RequireIncludeDependency, normalModuleFactory), 
compilation.dependencyTemplates.set(RequireIncludeDependency, new RequireIncludeDependency.Template);
const handler = (parser, parserOptions) => {
if (!1 === parserOptions.requireInclude) return;
const warn = void 0 === parserOptions.requireInclude;
new RequireIncludeDependencyParserPlugin(warn).apply(parser);
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireIncludePlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireIncludePlugin", handler);
}));
}
};
},
31572: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), ContextDependency = __webpack_require__(97818), ContextDependencyTemplateAsId = __webpack_require__(23324);
class RequireResolveContextDependency extends ContextDependency {
constructor(options, range, valueRange, context) {
super(options, context), this.range = range, this.valueRange = valueRange;
}
get type() {
return "amd require context";
}
serialize(context) {
const {write} = context;
write(this.range), write(this.valueRange), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.range = read(), this.valueRange = read(), super.deserialize(context);
}
}
makeSerializable(RequireResolveContextDependency, "webpack/lib/dependencies/RequireResolveContextDependency"), 
RequireResolveContextDependency.Template = ContextDependencyTemplateAsId, module.exports = RequireResolveContextDependency;
},
92551: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216), ModuleDependencyAsId = __webpack_require__(13714);
class RequireResolveDependency extends ModuleDependency {
constructor(request, range, context) {
super(request), this.range = range, this._context = context;
}
get type() {
return "require.resolve";
}
get category() {
return "commonjs";
}
getReferencedExports(moduleGraph, runtime) {
return Dependency.NO_EXPORTS_REFERENCED;
}
}
makeSerializable(RequireResolveDependency, "webpack/lib/dependencies/RequireResolveDependency"), 
RequireResolveDependency.Template = ModuleDependencyAsId, module.exports = RequireResolveDependency;
},
4637: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class RequireResolveHeaderDependency extends NullDependency {
constructor(range) {
if (super(), !Array.isArray(range)) throw new Error("range must be valid");
this.range = range;
}
serialize(context) {
const {write} = context;
write(this.range), super.serialize(context);
}
static deserialize(context) {
const obj = new RequireResolveHeaderDependency(context.read());
return obj.deserialize(context), obj;
}
}
makeSerializable(RequireResolveHeaderDependency, "webpack/lib/dependencies/RequireResolveHeaderDependency"), 
RequireResolveHeaderDependency.Template = class extends NullDependency.Template {
apply(dependency, source, templateContext) {
const dep = dependency;
source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
}
applyAsTemplateArgument(name, dep, source) {
source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
}
}, module.exports = RequireResolveHeaderDependency;
},
40680: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class RuntimeRequirementsDependency extends NullDependency {
constructor(runtimeRequirements) {
super(), this.runtimeRequirements = new Set(runtimeRequirements), this._hashUpdate = void 0;
}
updateHash(hash, context) {
void 0 === this._hashUpdate && (this._hashUpdate = Array.from(this.runtimeRequirements).join() + ""), 
hash.update(this._hashUpdate);
}
serialize(context) {
const {write} = context;
write(this.runtimeRequirements), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.runtimeRequirements = read(), super.deserialize(context);
}
}
makeSerializable(RuntimeRequirementsDependency, "webpack/lib/dependencies/RuntimeRequirementsDependency"), 
RuntimeRequirementsDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeRequirements}) {
const dep = dependency;
for (const req of dep.runtimeRequirements) runtimeRequirements.add(req);
}
}, module.exports = RuntimeRequirementsDependency;
},
21776: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class StaticExportsDependency extends NullDependency {
constructor(exports, canMangle) {
super(), this.exports = exports, this.canMangle = canMangle;
}
get type() {
return "static exports";
}
getExports(moduleGraph) {
return {
exports: this.exports,
canMangle: this.canMangle,
dependencies: void 0
};
}
serialize(context) {
const {write} = context;
write(this.exports), write(this.canMangle), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.exports = read(), this.canMangle = read(), super.deserialize(context);
}
}
makeSerializable(StaticExportsDependency, "webpack/lib/dependencies/StaticExportsDependency"), 
module.exports = StaticExportsDependency;
},
99334: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), WebpackError = __webpack_require__(64326), {evaluateToString, expressionIsUnsupported, toConstantDependency} = __webpack_require__(78802), makeSerializable = __webpack_require__(45898), ConstDependency = __webpack_require__(30339), SystemRuntimeModule = __webpack_require__(41208);
class SystemImportDeprecationWarning extends WebpackError {
constructor(loc) {
super("System.import() is deprecated and will be removed soon. Use import() instead.\nFor more info visit https://webpack.js.org/guides/code-splitting/"), 
this.name = "SystemImportDeprecationWarning", this.loc = loc;
}
}
makeSerializable(SystemImportDeprecationWarning, "webpack/lib/dependencies/SystemPlugin", "SystemImportDeprecationWarning"), 
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("SystemPlugin", ((compilation, {normalModuleFactory}) => {
compilation.hooks.runtimeRequirementInModule.for(RuntimeGlobals.system).tap("SystemPlugin", ((module, set) => {
set.add(RuntimeGlobals.requireScope);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.system).tap("SystemPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new SystemRuntimeModule);
}));
const handler = (parser, parserOptions) => {
if (void 0 === parserOptions.system || !parserOptions.system) return;
const setNotSupported = name => {
parser.hooks.evaluateTypeof.for(name).tap("SystemPlugin", evaluateToString("undefined")), 
parser.hooks.expression.for(name).tap("SystemPlugin", expressionIsUnsupported(parser, name + " is not supported by webpack."));
};
parser.hooks.typeof.for("System.import").tap("SystemPlugin", toConstantDependency(parser, JSON.stringify("function"))), 
parser.hooks.evaluateTypeof.for("System.import").tap("SystemPlugin", evaluateToString("function")), 
parser.hooks.typeof.for("System").tap("SystemPlugin", toConstantDependency(parser, JSON.stringify("object"))), 
parser.hooks.evaluateTypeof.for("System").tap("SystemPlugin", evaluateToString("object")), 
setNotSupported("System.set"), setNotSupported("System.get"), setNotSupported("System.register"), 
parser.hooks.expression.for("System").tap("SystemPlugin", (expr => {
const dep = new ConstDependency(RuntimeGlobals.system, expr.range, [ RuntimeGlobals.system ]);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
})), parser.hooks.call.for("System.import").tap("SystemPlugin", (expr => (parser.state.module.addWarning(new SystemImportDeprecationWarning(expr.loc)), 
parser.hooks.importCall.call({
type: "ImportExpression",
source: expr.arguments[0],
loc: expr.loc,
range: expr.range
}))));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("SystemPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("SystemPlugin", handler);
}));
}
}, module.exports.SystemImportDeprecationWarning = SystemImportDeprecationWarning;
},
41208: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor() {
super("system");
}
generate() {
return Template.asString([ `${RuntimeGlobals.system} = {`, Template.indent([ "import: function () {", Template.indent("throw new Error('System.import cannot be used indirectly');"), "}" ]), "};" ]);
}
};
},
25105: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), {getDependencyUsedByExportsCondition} = __webpack_require__(93639), makeSerializable = __webpack_require__(45898), memoize = __webpack_require__(98216), ModuleDependency = __webpack_require__(15216), getRawDataUrlModule = memoize((() => __webpack_require__(89779)));
class URLDependency extends ModuleDependency {
constructor(request, range, outerRange, relative) {
super(request), this.range = range, this.outerRange = outerRange, this.relative = relative || !1, 
this.usedByExports = void 0;
}
get type() {
return "new URL()";
}
get category() {
return "url";
}
getCondition(moduleGraph) {
return getDependencyUsedByExportsCondition(this, this.usedByExports, moduleGraph);
}
createIgnoredModule(context) {
return new (getRawDataUrlModule())("data:,", "ignored-asset", "(ignored asset)");
}
serialize(context) {
const {write} = context;
write(this.outerRange), write(this.relative), write(this.usedByExports), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.outerRange = read(), this.relative = read(), this.usedByExports = read(), super.deserialize(context);
}
}
URLDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, templateContext) {
const {chunkGraph, moduleGraph, runtimeRequirements, runtimeTemplate, runtime} = templateContext, dep = dependency, connection = moduleGraph.getConnection(dep);
!connection || connection.isTargetActive(runtime) ? (runtimeRequirements.add(RuntimeGlobals.require), 
dep.relative ? (runtimeRequirements.add(RuntimeGlobals.relativeUrl), source.replace(dep.outerRange[0], dep.outerRange[1] - 1, `/* asset import */ new ${RuntimeGlobals.relativeUrl}(${runtimeTemplate.moduleRaw({
chunkGraph,
module: moduleGraph.getModule(dep),
request: dep.request,
runtimeRequirements,
weak: !1
})})`)) : (runtimeRequirements.add(RuntimeGlobals.baseURI), source.replace(dep.range[0], dep.range[1] - 1, `/* asset import */ ${runtimeTemplate.moduleRaw({
chunkGraph,
module: moduleGraph.getModule(dep),
request: dep.request,
runtimeRequirements,
weak: !1
})}, ${RuntimeGlobals.baseURI}`))) : source.replace(dep.outerRange[0], dep.outerRange[1] - 1, "/* unused asset import */ undefined");
}
}, makeSerializable(URLDependency, "webpack/lib/dependencies/URLDependency"), module.exports = URLDependency;
},
3286: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {pathToFileURL} = __webpack_require__(57310), BasicEvaluatedExpression = __webpack_require__(47789), {approve} = __webpack_require__(78802), InnerGraph = __webpack_require__(93639), URLDependency = __webpack_require__(25105);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("URLPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(URLDependency, normalModuleFactory), compilation.dependencyTemplates.set(URLDependency, new URLDependency.Template);
const parserCallback = (parser, parserOptions) => {
if (!1 === parserOptions.url) return;
const relative = "relative" === parserOptions.url, getUrlRequest = expr => {
if (2 !== expr.arguments.length) return;
const [arg1, arg2] = expr.arguments;
if ("MemberExpression" !== arg2.type || "SpreadElement" === arg1.type) return;
const chain = parser.extractMemberExpressionChain(arg2);
if (1 !== chain.members.length || "MetaProperty" !== chain.object.type || "import" !== chain.object.meta.name || "meta" !== chain.object.property.name || "url" !== chain.members[0]) return;
return parser.evaluateExpression(arg1).asString();
};
parser.hooks.canRename.for("URL").tap("URLPlugin", approve), parser.hooks.evaluateNewExpression.for("URL").tap("URLPlugin", (expr => {
const request = getUrlRequest(expr);
if (!request) return;
const url = new URL(request, (module => pathToFileURL(module.resource))(parser.state.module));
return (new BasicEvaluatedExpression).setString(url.toString()).setRange(expr.range);
})), parser.hooks.new.for("URL").tap("URLPlugin", (_expr => {
const expr = _expr, request = getUrlRequest(expr);
if (!request) return;
const [arg1, arg2] = expr.arguments, dep = new URLDependency(request, [ arg1.range[0], arg2.range[1] ], expr.range, relative);
return dep.loc = expr.loc, parser.state.current.addDependency(dep), InnerGraph.onUsage(parser.state, (e => dep.usedByExports = e)), 
!0;
})), parser.hooks.isPure.for("NewExpression").tap("URLPlugin", (_expr => {
const expr = _expr, {callee} = expr;
if ("Identifier" !== callee.type) return;
const calleeInfo = parser.getFreeInfoFromVariable(callee.name);
if (!calleeInfo || "URL" !== calleeInfo.name) return;
return !!getUrlRequest(expr) || void 0;
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("URLPlugin", parserCallback), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("URLPlugin", parserCallback);
}));
}
};
},
7615: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), NullDependency = __webpack_require__(52649);
class UnsupportedDependency extends NullDependency {
constructor(request, range) {
super(), this.request = request, this.range = range;
}
serialize(context) {
const {write} = context;
write(this.request), write(this.range), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.request = read(), this.range = read(), super.deserialize(context);
}
}
makeSerializable(UnsupportedDependency, "webpack/lib/dependencies/UnsupportedDependency"), 
UnsupportedDependency.Template = class extends NullDependency.Template {
apply(dependency, source, {runtimeTemplate}) {
const dep = dependency;
source.replace(dep.range[0], dep.range[1], runtimeTemplate.missingModule({
request: dep.request
}));
}
}, module.exports = UnsupportedDependency;
},
66847: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class WebAssemblyExportImportedDependency extends ModuleDependency {
constructor(exportName, request, name, valueType) {
super(request), this.exportName = exportName, this.name = name, this.valueType = valueType;
}
couldAffectReferencingModule() {
return Dependency.TRANSITIVE;
}
getReferencedExports(moduleGraph, runtime) {
return [ [ this.name ] ];
}
get type() {
return "wasm export import";
}
get category() {
return "wasm";
}
serialize(context) {
const {write} = context;
write(this.exportName), write(this.name), write(this.valueType), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.exportName = read(), this.name = read(), this.valueType = read(), super.deserialize(context);
}
}
makeSerializable(WebAssemblyExportImportedDependency, "webpack/lib/dependencies/WebAssemblyExportImportedDependency"), 
module.exports = WebAssemblyExportImportedDependency;
},
68953: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), UnsupportedWebAssemblyFeatureError = __webpack_require__(45676), ModuleDependency = __webpack_require__(15216);
class WebAssemblyImportDependency extends ModuleDependency {
constructor(request, name, description, onlyDirectImport) {
super(request), this.name = name, this.description = description, this.onlyDirectImport = onlyDirectImport;
}
get type() {
return "wasm import";
}
get category() {
return "wasm";
}
getReferencedExports(moduleGraph, runtime) {
return [ [ this.name ] ];
}
getErrors(moduleGraph) {
const module = moduleGraph.getModule(this);
if (this.onlyDirectImport && module && !module.type.startsWith("webassembly")) return [ new UnsupportedWebAssemblyFeatureError(`Import "${this.name}" from "${this.request}" with ${this.onlyDirectImport} can only be used for direct wasm to wasm dependencies`) ];
}
serialize(context) {
const {write} = context;
write(this.name), write(this.description), write(this.onlyDirectImport), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.name = read(), this.description = read(), this.onlyDirectImport = read(), super.deserialize(context);
}
}
makeSerializable(WebAssemblyImportDependency, "webpack/lib/dependencies/WebAssemblyImportDependency"), 
module.exports = WebAssemblyImportDependency;
},
19981: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), Template = __webpack_require__(88370), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class WebpackIsIncludedDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.weak = !0, this.range = range;
}
getReferencedExports(moduleGraph, runtime) {
return Dependency.NO_EXPORTS_REFERENCED;
}
get type() {
return "__webpack_is_included__";
}
}
makeSerializable(WebpackIsIncludedDependency, "webpack/lib/dependencies/WebpackIsIncludedDependency"), 
WebpackIsIncludedDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, {runtimeTemplate, chunkGraph, moduleGraph}) {
const dep = dependency, connection = moduleGraph.getConnection(dep), included = !!connection && chunkGraph.getNumberOfModuleChunks(connection.module) > 0, comment = runtimeTemplate.outputOptions.pathinfo ? Template.toComment(`__webpack_is_included__ ${runtimeTemplate.requestShortener.shorten(dep.request)}`) : "";
source.replace(dep.range[0], dep.range[1] - 1, `${comment}${JSON.stringify(included)}`);
}
}, module.exports = WebpackIsIncludedDependency;
},
41399: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), ModuleDependency = __webpack_require__(15216);
class WorkerDependency extends ModuleDependency {
constructor(request, range) {
super(request), this.range = range;
}
getReferencedExports(moduleGraph, runtime) {
return Dependency.NO_EXPORTS_REFERENCED;
}
get type() {
return "new Worker()";
}
get category() {
return "worker";
}
}
WorkerDependency.Template = class extends ModuleDependency.Template {
apply(dependency, source, templateContext) {
const {chunkGraph, moduleGraph, runtimeRequirements} = templateContext, dep = dependency, block = moduleGraph.getParentBlock(dependency), chunk = chunkGraph.getBlockChunkGroup(block).getEntrypointChunk();
runtimeRequirements.add(RuntimeGlobals.publicPath), runtimeRequirements.add(RuntimeGlobals.baseURI), 
runtimeRequirements.add(RuntimeGlobals.getChunkScriptFilename), source.replace(dep.range[0], dep.range[1] - 1, `/* worker import */ ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkScriptFilename}(${JSON.stringify(chunk.id)}), ${RuntimeGlobals.baseURI}`);
}
}, makeSerializable(WorkerDependency, "webpack/lib/dependencies/WorkerDependency"), 
module.exports = WorkerDependency;
},
63376: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {pathToFileURL} = __webpack_require__(57310), AsyncDependenciesBlock = __webpack_require__(89353), CommentCompilationWarning = __webpack_require__(35931), UnsupportedFeatureWarning = __webpack_require__(3490), EnableChunkLoadingPlugin = __webpack_require__(64027), {equals} = __webpack_require__(8579), createHash = __webpack_require__(27466), {contextify} = __webpack_require__(63264), EnableWasmLoadingPlugin = __webpack_require__(44362), ConstDependency = __webpack_require__(30339), CreateScriptUrlDependency = __webpack_require__(66869), {harmonySpecifierTag} = __webpack_require__(20529), WorkerDependency = __webpack_require__(41399), DEFAULT_SYNTAX = [ "Worker", "SharedWorker", "navigator.serviceWorker.register()", "Worker from worker_threads" ], workerIndexMap = new WeakMap;
module.exports = class {
constructor(chunkLoading, wasmLoading, module) {
this._chunkLoading = chunkLoading, this._wasmLoading = wasmLoading, this._module = module;
}
apply(compiler) {
this._chunkLoading && new EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler), 
this._wasmLoading && new EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);
const cachedContextify = contextify.bindContextCache(compiler.context, compiler.root);
compiler.hooks.thisCompilation.tap("WorkerPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(WorkerDependency, normalModuleFactory), compilation.dependencyTemplates.set(WorkerDependency, new WorkerDependency.Template), 
compilation.dependencyTemplates.set(CreateScriptUrlDependency, new CreateScriptUrlDependency.Template);
const parseModuleUrl = (parser, expr) => {
if ("NewExpression" !== expr.type || "Super" === expr.callee.type || 2 !== expr.arguments.length) return;
const [arg1, arg2] = expr.arguments;
if ("SpreadElement" === arg1.type) return;
if ("SpreadElement" === arg2.type) return;
const callee = parser.evaluateExpression(expr.callee);
if (!callee.isIdentifier() || "URL" !== callee.identifier) return;
const arg2Value = parser.evaluateExpression(arg2);
if (!arg2Value.isString() || !arg2Value.string.startsWith("file://") || arg2Value.string !== (module => pathToFileURL(module.resource).toString())(parser.state.module)) return;
return [ parser.evaluateExpression(arg1), [ arg1.range[0], arg2.range[1] ] ];
}, parserPlugin = (parser, parserOptions) => {
if (!1 === parserOptions.worker) return;
const options = Array.isArray(parserOptions.worker) ? parserOptions.worker : [ "..." ], handleNewWorker = expr => {
if (0 === expr.arguments.length || expr.arguments.length > 2) return;
const [arg1, arg2] = expr.arguments;
if ("SpreadElement" === arg1.type) return;
if (arg2 && "SpreadElement" === arg2.type) return;
const parsedUrl = parseModuleUrl(parser, arg1);
if (!parsedUrl) return;
const [url, range] = parsedUrl;
if (!url.isString()) return;
const {expressions, otherElements, values: options, spread: hasSpreadInOptions, insertType, insertLocation} = arg2 && "ObjectExpression" === arg2.type ? ((parser, expr) => {
const values = {}, expressions = {}, otherElements = [];
let spread = !1;
for (const prop of expr.properties) if ("SpreadElement" === prop.type) spread = !0; else if ("Property" !== prop.type || prop.method || prop.computed || "Identifier" !== prop.key.type) otherElements.push(prop); else if (expressions[prop.key.name] = prop.value, 
!prop.shorthand && !prop.value.type.endsWith("Pattern")) {
const value = parser.evaluateExpression(prop.value);
value.isCompileTimeValue() && (values[prop.key.name] = value.asCompileTimeValue());
}
return {
expressions,
otherElements,
values,
spread,
insertType: expr.properties.length > 0 ? "comma" : "single",
insertLocation: expr.properties[expr.properties.length - 1].range[1]
};
})(parser, arg2) : {
expressions: {},
otherElements: [],
values: {},
spread: !1,
insertType: arg2 ? "spread" : "argument",
insertLocation: arg2 ? arg2.range : arg1.range[1]
}, {options: importOptions, errors: commentErrors} = parser.parseCommentOptions(expr.range);
if (commentErrors) for (const e of commentErrors) {
const {comment} = e;
parser.state.module.addWarning(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, comment.loc));
}
let entryOptions = {};
if (importOptions) {
if (void 0 !== importOptions.webpackIgnore) if ("boolean" != typeof importOptions.webpackIgnore) parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackIgnore\` expected a boolean, but received: ${importOptions.webpackIgnore}.`, expr.loc)); else if (importOptions.webpackIgnore) return !1;
void 0 !== importOptions.webpackEntryOptions && ("object" != typeof importOptions.webpackEntryOptions || null === importOptions.webpackEntryOptions ? parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackEntryOptions\` expected a object, but received: ${importOptions.webpackEntryOptions}.`, expr.loc)) : Object.assign(entryOptions, importOptions.webpackEntryOptions)), 
void 0 !== importOptions.webpackChunkName && ("string" != typeof importOptions.webpackChunkName ? parser.state.module.addWarning(new UnsupportedFeatureWarning(`\`webpackChunkName\` expected a string, but received: ${importOptions.webpackChunkName}.`, expr.loc)) : entryOptions.name = importOptions.webpackChunkName);
}
if (!Object.prototype.hasOwnProperty.call(entryOptions, "name") && options && "string" == typeof options.name && (entryOptions.name = options.name), 
void 0 === entryOptions.runtime) {
let i = workerIndexMap.get(parser.state) || 0;
workerIndexMap.set(parser.state, i + 1);
let name = `${cachedContextify(parser.state.module.identifier())}|${i}`;
const hash = createHash(compilation.outputOptions.hashFunction);
hash.update(name);
const digest = hash.digest(compilation.outputOptions.hashDigest);
entryOptions.runtime = digest.slice(0, compilation.outputOptions.hashDigestLength);
}
const block = new AsyncDependenciesBlock({
name: entryOptions.name,
entryOptions: {
chunkLoading: this._chunkLoading,
wasmLoading: this._wasmLoading,
...entryOptions
}
});
block.loc = expr.loc;
const dep = new WorkerDependency(url.string, range);
if (dep.loc = expr.loc, block.addDependency(dep), parser.state.module.addBlock(block), 
compilation.outputOptions.trustedTypes) {
const dep = new CreateScriptUrlDependency(expr.arguments[0].range);
dep.loc = expr.loc, parser.state.module.addDependency(dep);
}
if (expressions.type) {
const expr = expressions.type;
if (!1 !== options.type) {
const dep = new ConstDependency(this._module ? '"module"' : "undefined", expr.range);
dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), expressions.type = void 0;
}
} else if ("comma" === insertType) {
if (this._module || hasSpreadInOptions) {
const dep = new ConstDependency(", type: " + (this._module ? '"module"' : "undefined"), insertLocation);
dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep);
}
} else if ("spread" === insertType) {
const dep1 = new ConstDependency("Object.assign({}, ", insertLocation[0]), dep2 = new ConstDependency(`, { type: ${this._module ? '"module"' : "undefined"} })`, insertLocation[1]);
dep1.loc = expr.loc, dep2.loc = expr.loc, parser.state.module.addPresentationalDependency(dep1), 
parser.state.module.addPresentationalDependency(dep2);
} else if ("argument" === insertType && this._module) {
const dep = new ConstDependency(', { type: "module" }', insertLocation);
dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep);
}
parser.walkExpression(expr.callee);
for (const key of Object.keys(expressions)) expressions[key] && parser.walkExpression(expressions[key]);
for (const prop of otherElements) parser.walkProperty(prop);
return "spread" === insertType && parser.walkExpression(arg2), !0;
}, processItem = item => {
if (item.endsWith("()")) parser.hooks.call.for(item.slice(0, -2)).tap("WorkerPlugin", handleNewWorker); else {
const match = /^(.+?)(\(\))?\s+from\s+(.+)$/.exec(item);
if (match) {
const ids = match[1].split("."), call = match[2], source = match[3];
(call ? parser.hooks.call : parser.hooks.new).for(harmonySpecifierTag).tap("WorkerPlugin", (expr => {
const settings = parser.currentTagData;
if (settings && settings.source === source && equals(settings.ids, ids)) return handleNewWorker(expr);
}));
} else parser.hooks.new.for(item).tap("WorkerPlugin", handleNewWorker);
}
};
for (const item of options) "..." === item ? DEFAULT_SYNTAX.forEach(processItem) : processItem(item);
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("WorkerPlugin", parserPlugin), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("WorkerPlugin", parserPlugin);
}));
}
};
},
40142: module => {
"use strict";
module.exports = expr => "FunctionExpression" === expr.type || "ArrowFunctionExpression" === expr.type ? {
fn: expr,
expressions: [],
needThis: !1
} : "CallExpression" === expr.type && "MemberExpression" === expr.callee.type && "FunctionExpression" === expr.callee.object.type && "Identifier" === expr.callee.property.type && "bind" === expr.callee.property.name && 1 === expr.arguments.length ? {
fn: expr.callee.object,
expressions: [ expr.arguments[0] ],
needThis: void 0
} : "CallExpression" === expr.type && "FunctionExpression" === expr.callee.type && "BlockStatement" === expr.callee.body.type && 1 === expr.arguments.length && "ThisExpression" === expr.arguments[0].type && expr.callee.body.body && 1 === expr.callee.body.body.length && "ReturnStatement" === expr.callee.body.body[0].type && expr.callee.body.body[0].argument && "FunctionExpression" === expr.callee.body.body[0].argument.type ? {
fn: expr.callee.body.body[0].argument,
expressions: [],
needThis: !0
} : void 0;
},
97556: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {UsageState} = __webpack_require__(74603), processExportInfo = (runtime, referencedExports, prefix, exportInfo, defaultPointsToSelf = !1, alreadyVisited = new Set) => {
if (!exportInfo) return void referencedExports.push(prefix);
const used = exportInfo.getUsed(runtime);
if (used === UsageState.Unused) return;
if (alreadyVisited.has(exportInfo)) return void referencedExports.push(prefix);
if (alreadyVisited.add(exportInfo), used !== UsageState.OnlyPropertiesUsed || !exportInfo.exportsInfo || exportInfo.exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused) return alreadyVisited.delete(exportInfo), 
void referencedExports.push(prefix);
const exportsInfo = exportInfo.exportsInfo;
for (const exportInfo of exportsInfo.orderedExports) processExportInfo(runtime, referencedExports, defaultPointsToSelf && "default" === exportInfo.name ? prefix : prefix.concat(exportInfo.name), exportInfo, !1, alreadyVisited);
alreadyVisited.delete(exportInfo);
};
module.exports = processExportInfo;
},
84755: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ExternalsPlugin = __webpack_require__(29301);
module.exports = class {
constructor(context) {
this._context = context;
}
apply(compiler) {
switch (new ExternalsPlugin("node-commonjs", [ "clipboard", "crash-reporter", "electron", "ipc", "native-image", "original-fs", "screen", "shell" ]).apply(compiler), 
this._context) {
case "main":
new ExternalsPlugin("node-commonjs", [ "app", "auto-updater", "browser-window", "content-tracing", "dialog", "global-shortcut", "ipc-main", "menu", "menu-item", "power-monitor", "power-save-blocker", "protocol", "session", "tray", "web-contents" ]).apply(compiler);
break;

case "preload":
case "renderer":
new ExternalsPlugin("node-commonjs", [ "desktop-capturer", "ipc-renderer", "remote", "web-frame" ]).apply(compiler);
}
}
};
},
24401: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module) {
super("There is a circular build dependency, which makes it impossible to create this module"), 
this.name = "BuildCycleError", this.module = module;
}
};
},
20627: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("export webpack runtime", RuntimeModule.STAGE_ATTACH);
}
shouldIsolate() {
return !1;
}
generate() {
return "export default __webpack_require__;";
}
};
},
20935: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), {RuntimeGlobals} = __webpack_require__(91459), HotUpdateChunk = __webpack_require__(6902), Template = __webpack_require__(88370), {getAllChunks} = __webpack_require__(92535), {getCompilationHooks, getChunkFilenameTemplate} = __webpack_require__(18362), {updateHashForEntryStartup} = __webpack_require__(19202);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("ModuleChunkFormatPlugin", (compilation => {
compilation.hooks.additionalChunkRuntimeRequirements.tap("ModuleChunkFormatPlugin", ((chunk, set) => {
chunk.hasRuntime() || compilation.chunkGraph.getNumberOfEntryModules(chunk) > 0 && (set.add(RuntimeGlobals.require), 
set.add(RuntimeGlobals.startupEntrypoint), set.add(RuntimeGlobals.externalInstallChunk));
}));
const hooks = getCompilationHooks(compilation);
hooks.renderChunk.tap("ModuleChunkFormatPlugin", ((modules, renderContext) => {
const {chunk, chunkGraph, runtimeTemplate} = renderContext, hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null, source = new ConcatSource;
if (hotUpdateChunk) throw new Error("HMR is not implemented for module chunk format yet");
{
source.add(`export const id = ${JSON.stringify(chunk.id)};\n`), source.add(`export const ids = ${JSON.stringify(chunk.ids)};\n`), 
source.add("export const modules = "), source.add(modules), source.add(";\n");
const runtimeModules = chunkGraph.getChunkRuntimeModulesInOrder(chunk);
runtimeModules.length > 0 && (source.add("export const runtime =\n"), source.add(Template.renderChunkRuntimeModules(runtimeModules, renderContext)));
const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));
if (entries.length > 0) {
const runtimeChunk = entries[0][1].getRuntimeChunk(), currentOutputName = compilation.getPath(getChunkFilenameTemplate(chunk, compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}).split("/");
currentOutputName.pop();
const getRelativePath = chunk => {
const baseOutputName = currentOutputName.slice(), chunkOutputName = compilation.getPath(getChunkFilenameTemplate(chunk, compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}).split("/");
for (;baseOutputName.length > 0 && chunkOutputName.length > 0 && baseOutputName[0] === chunkOutputName[0]; ) baseOutputName.shift(), 
chunkOutputName.shift();
return (baseOutputName.length > 0 ? "../".repeat(baseOutputName.length) : "./") + chunkOutputName.join("/");
}, entrySource = new ConcatSource;
entrySource.add(source), entrySource.add(";\n\n// load runtime\n"), entrySource.add(`import __webpack_require__ from ${JSON.stringify(getRelativePath(runtimeChunk))};\n`);
const startupSource = new ConcatSource;
startupSource.add(`var __webpack_exec__ = ${runtimeTemplate.returningFunction(`__webpack_require__(${RuntimeGlobals.entryModuleId} = moduleId)`, "moduleId")}\n`);
const loadedChunks = new Set;
let index = 0;
for (let i = 0; i < entries.length; i++) {
const [module, entrypoint] = entries[i], final = i + 1 === entries.length, moduleId = chunkGraph.getModuleId(module), chunks = getAllChunks(entrypoint, runtimeChunk, void 0);
for (const chunk of chunks) loadedChunks.has(chunk) || (loadedChunks.add(chunk), 
startupSource.add(`import * as __webpack_chunk_${index}__ from ${JSON.stringify(getRelativePath(chunk))};\n`), 
startupSource.add(`${RuntimeGlobals.externalInstallChunk}(__webpack_chunk_${index}__);\n`), 
index++);
startupSource.add(`${final ? "var __webpack_exports__ = " : ""}__webpack_exec__(${JSON.stringify(moduleId)});\n`);
}
return entrySource.add(hooks.renderStartup.call(startupSource, entries[entries.length - 1][0], {
...renderContext,
inlined: !1
})), entrySource;
}
}
return source;
})), hooks.chunkHash.tap("ModuleChunkFormatPlugin", ((chunk, hash, {chunkGraph, runtimeTemplate}) => {
if (chunk.hasRuntime()) return;
hash.update("ModuleChunkFormatPlugin"), hash.update("1");
const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));
updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
}));
}));
}
};
},
86440: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), ExportWebpackRequireRuntimeModule = __webpack_require__(20627), ModuleChunkLoadingRuntimeModule = __webpack_require__(94387);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("ModuleChunkLoadingPlugin", (compilation => {
const globalChunkLoading = compilation.outputOptions.chunkLoading, isEnabledForChunk = chunk => {
const options = chunk.getEntryOptions();
return "import" === (options && void 0 !== options.chunkLoading ? options.chunkLoading : globalChunkLoading);
}, onceForChunkSet = new WeakSet, handler = (chunk, set) => {
onceForChunkSet.has(chunk) || (onceForChunkSet.add(chunk), isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.moduleFactoriesAddOnly), 
set.add(RuntimeGlobals.hasOwnProperty), compilation.addRuntimeModule(chunk, new ModuleChunkLoadingRuntimeModule(set))));
};
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("ModuleChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.baseURI).tap("ModuleChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.externalInstallChunk).tap("ModuleChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.onChunksLoaded).tap("ModuleChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.externalInstallChunk).tap("ModuleChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && compilation.addRuntimeModule(chunk, new ExportWebpackRequireRuntimeModule);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("ModuleChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && set.add(RuntimeGlobals.getChunkScriptFilename);
}));
}));
}
};
},
94387: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook} = __webpack_require__(89991), Compilation = __webpack_require__(62843), RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {getChunkFilenameTemplate, chunkHasJs} = __webpack_require__(18362), {getInitialChunkIds} = __webpack_require__(19202), compileBooleanMatcher = __webpack_require__(65814), {getUndoPath} = __webpack_require__(63264), compilationHooksMap = new WeakMap;
module.exports = class extends RuntimeModule {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
linkPreload: new SyncWaterfallHook([ "source", "chunk" ]),
linkPrefetch: new SyncWaterfallHook([ "source", "chunk" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(runtimeRequirements) {
super("import chunk loading", RuntimeModule.STAGE_ATTACH), this._runtimeRequirements = runtimeRequirements;
}
_generateBaseUri(chunk, rootOutputDir) {
const options = chunk.getEntryOptions();
if (options && options.baseUri) return `${RuntimeGlobals.baseURI} = ${JSON.stringify(options.baseUri)};`;
const {compilation: {outputOptions: {importMetaName}}} = this;
return `${RuntimeGlobals.baseURI} = new URL(${JSON.stringify(rootOutputDir)}, ${importMetaName}.url);`;
}
generate() {
const {compilation, chunk, chunkGraph} = this, {runtimeTemplate, outputOptions: {importFunctionName}} = compilation, fn = RuntimeGlobals.ensureChunkHandlers, withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI), withExternalInstallChunk = this._runtimeRequirements.has(RuntimeGlobals.externalInstallChunk), withLoading = this._runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers), withOnChunkLoad = this._runtimeRequirements.has(RuntimeGlobals.onChunksLoaded), withHmr = this._runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs), hasJsMatcher = compileBooleanMatcher(conditionMap), initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs), outputName = this.compilation.getPath(getChunkFilenameTemplate(chunk, this.compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}), rootOutputDir = getUndoPath(outputName, this.compilation.outputOptions.path, !0), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_module` : void 0;
return Template.asString([ withBaseURI ? this._generateBaseUri(chunk, rootOutputDir) : "// no baseURI", "", "// object to store loaded and loading chunks", "// undefined = chunk not loaded, null = chunk preloaded/prefetched", "// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded", `var installedChunks = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{`, Template.indent(Array.from(initialChunkIds, (id => `${JSON.stringify(id)}: 0`)).join(",\n")), "};", "", withLoading || withExternalInstallChunk ? `var installChunk = ${runtimeTemplate.basicFunction("data", [ runtimeTemplate.destructureObject([ "ids", "modules", "runtime" ], "data"), '// add "modules" to the modules object,', '// then flag all "ids" as loaded and fire callback', "var moduleId, chunkId, i = 0;", "for(moduleId in modules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(modules, moduleId)) {`, Template.indent(`${RuntimeGlobals.moduleFactories}[moduleId] = modules[moduleId];`), "}" ]), "}", "if(runtime) runtime(__webpack_require__);", "for(;i < ids.length; i++) {", Template.indent([ "chunkId = ids[i];", `if(${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) && installedChunks[chunkId]) {`, Template.indent("installedChunks[chunkId][0]();"), "}", "installedChunks[ids[i]] = 0;" ]), "}", withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}();` : "" ])}` : "// no install chunk", "", withLoading ? Template.asString([ `${fn}.j = ${runtimeTemplate.basicFunction("chunkId, promises", !1 !== hasJsMatcher ? Template.indent([ "// import() chunk loading for javascript", `var installedChunkData = ${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`, 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent([ "", '// a Promise means "currently loading".', "if(installedChunkData) {", Template.indent([ "promises.push(installedChunkData[1]);" ]), "} else {", Template.indent([ !0 === hasJsMatcher ? "if(true) { // all chunks have JS" : `if(${hasJsMatcher("chunkId")}) {`, Template.indent([ "// setup Promise in chunk cache", `var promise = ${importFunctionName}(${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId)).then(installChunk, ${runtimeTemplate.basicFunction("e", [ "if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;", "throw e;" ])});`, `var promise = Promise.race([promise, new Promise(${runtimeTemplate.expressionFunction("installedChunkData = installedChunks[chunkId] = [resolve]", "resolve")})])`, "promises.push(installedChunkData[1] = promise);" ]), "} else installedChunks[chunkId] = 0;" ]), "}" ]), "}" ]) : Template.indent([ "installedChunks[chunkId] = 0;" ]))};` ]) : "// no chunk on demand loading", "", withExternalInstallChunk ? Template.asString([ `${RuntimeGlobals.externalInstallChunk} = installChunk;` ]) : "// no external install chunk", "", withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}.j = ${runtimeTemplate.returningFunction("installedChunks[chunkId] === 0", "chunkId")};` : "// no on chunks loaded" ]);
}
};
},
78509: module => {
"use strict";
const formatPosition = pos => {
if (pos && "object" == typeof pos) {
if ("line" in pos && "column" in pos) return `${pos.line}:${pos.column}`;
if ("line" in pos) return `${pos.line}:?`;
}
return "";
};
module.exports = loc => {
if (loc && "object" == typeof loc) {
if ("start" in loc && loc.start && "end" in loc && loc.end) return "object" == typeof loc.start && "number" == typeof loc.start.line && "object" == typeof loc.end && "number" == typeof loc.end.line && "number" == typeof loc.end.column && loc.start.line === loc.end.line ? `${formatPosition(loc.start)}-${loc.end.column}` : "object" == typeof loc.start && "number" == typeof loc.start.line && "number" != typeof loc.start.column && "object" == typeof loc.end && "number" == typeof loc.end.line && "number" != typeof loc.end.column ? `${loc.start.line}-${loc.end.line}` : `${formatPosition(loc.start)}-${formatPosition(loc.end)}`;
if ("start" in loc && loc.start) return formatPosition(loc.start);
if ("name" in loc && "index" in loc) return `${loc.name}[${loc.index}]`;
if ("name" in loc) return loc.name;
}
return "";
};
},
12343: module => {
"use strict";
var $interceptModuleExecution$ = void 0, $hmrDownloadUpdateHandlers$ = void 0, $hmrInvalidateModuleHandlers$ = void 0, __webpack_require__ = void 0;
module.exports = function() {
var currentChildModule, currentUpdateApplyHandlers, queuedInvalidatedModules, currentModuleData = {}, currentParents = [], registeredStatusHandlers = [], currentStatus = "idle", blockingPromises = 0, blockingPromisesWaiting = [];
function setStatus(newStatus) {
currentStatus = newStatus;
for (var results = [], i = 0; i < registeredStatusHandlers.length; i++) results[i] = registeredStatusHandlers[i].call(null, newStatus);
return Promise.all(results);
}
function unblock() {
0 == --blockingPromises && setStatus("ready").then((function() {
if (0 === blockingPromises) {
var list = blockingPromisesWaiting;
blockingPromisesWaiting = [];
for (var i = 0; i < list.length; i++) list[i]();
}
}));
}
function hotCheck(applyOnUpdate) {
if ("idle" !== currentStatus) throw new Error("check() is only allowed in idle status");
return setStatus("check").then(undefined).then((function(update) {
return update ? setStatus("prepare").then((function() {
var updatedModules = [];
return currentUpdateApplyHandlers = [], Promise.all(Object.keys($hmrDownloadUpdateHandlers$).reduce((function(promises, key) {
return $hmrDownloadUpdateHandlers$[key](update.c, update.r, update.m, promises, currentUpdateApplyHandlers, updatedModules), 
promises;
}), [])).then((function() {
return fn = function() {
return applyOnUpdate ? internalApply(applyOnUpdate) : setStatus("ready").then((function() {
return updatedModules;
}));
}, 0 === blockingPromises ? fn() : new Promise((function(resolve) {
blockingPromisesWaiting.push((function() {
resolve(fn());
}));
}));
var fn;
}));
})) : setStatus(applyInvalidatedModules() ? "ready" : "idle").then((function() {
return null;
}));
}));
}
function hotApply(options) {
return "ready" !== currentStatus ? Promise.resolve().then((function() {
throw new Error("apply() is only allowed in ready status (state: " + currentStatus + ")");
})) : internalApply(options);
}
function internalApply(options) {
options = options || {}, applyInvalidatedModules();
var results = currentUpdateApplyHandlers.map((function(handler) {
return handler(options);
}));
currentUpdateApplyHandlers = void 0;
var errors = results.map((function(r) {
return r.error;
})).filter(Boolean);
if (errors.length > 0) return setStatus("abort").then((function() {
throw errors[0];
}));
var disposePromise = setStatus("dispose");
results.forEach((function(result) {
result.dispose && result.dispose();
}));
var error, applyPromise = setStatus("apply"), reportError = function(err) {
error || (error = err);
}, outdatedModules = [];
return results.forEach((function(result) {
if (result.apply) {
var modules = result.apply(reportError);
if (modules) for (var i = 0; i < modules.length; i++) outdatedModules.push(modules[i]);
}
})), Promise.all([ disposePromise, applyPromise ]).then((function() {
return error ? setStatus("fail").then((function() {
throw error;
})) : queuedInvalidatedModules ? internalApply(options).then((function(list) {
return outdatedModules.forEach((function(moduleId) {
list.indexOf(moduleId) < 0 && list.push(moduleId);
})), list;
})) : setStatus("idle").then((function() {
return outdatedModules;
}));
}));
}
function applyInvalidatedModules() {
if (queuedInvalidatedModules) return currentUpdateApplyHandlers || (currentUpdateApplyHandlers = []), 
Object.keys($hmrInvalidateModuleHandlers$).forEach((function(key) {
queuedInvalidatedModules.forEach((function(moduleId) {
$hmrInvalidateModuleHandlers$[key](moduleId, currentUpdateApplyHandlers);
}));
})), queuedInvalidatedModules = void 0, !0;
}
currentModuleData, $interceptModuleExecution$.push((function(options) {
var moduleId, me, _main, hot, module = options.module, require = function(require, moduleId) {
var me = undefined[moduleId];
if (!me) return require;
var fn = function(request) {
if (me.hot.active) {
if (undefined[request]) {
var parents = undefined[request].parents;
-1 === parents.indexOf(moduleId) && parents.push(moduleId);
} else currentParents = [ moduleId ], currentChildModule = request;
-1 === me.children.indexOf(request) && me.children.push(request);
} else console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId), 
currentParents = [];
return require(request);
}, createPropertyDescriptor = function(name) {
return {
configurable: !0,
enumerable: !0,
get: function() {
return require[name];
},
set: function(value) {
require[name] = value;
}
};
};
for (var name in require) Object.prototype.hasOwnProperty.call(require, name) && "e" !== name && Object.defineProperty(fn, name, createPropertyDescriptor(name));
return fn.e = function(chunkId) {
return function(promise) {
switch (currentStatus) {
case "ready":
setStatus("prepare");

case "prepare":
return blockingPromises++, promise.then(unblock, unblock), promise;

default:
return promise;
}
}(require.e(chunkId));
}, fn;
}(options.require, options.id);
module.hot = (moduleId = options.id, me = module, hot = {
_acceptedDependencies: {},
_acceptedErrorHandlers: {},
_declinedDependencies: {},
_selfAccepted: !1,
_selfDeclined: !1,
_selfInvalidated: !1,
_disposeHandlers: [],
_main: _main = currentChildModule !== moduleId,
_requireSelf: function() {
currentParents = me.parents.slice(), currentChildModule = _main ? void 0 : moduleId, 
__webpack_require__(moduleId);
},
active: !0,
accept: function(dep, callback, errorHandler) {
if (void 0 === dep) hot._selfAccepted = !0; else if ("function" == typeof dep) hot._selfAccepted = dep; else if ("object" == typeof dep && null !== dep) for (var i = 0; i < dep.length; i++) hot._acceptedDependencies[dep[i]] = callback || function() {}, 
hot._acceptedErrorHandlers[dep[i]] = errorHandler; else hot._acceptedDependencies[dep] = callback || function() {}, 
hot._acceptedErrorHandlers[dep] = errorHandler;
},
decline: function(dep) {
if (void 0 === dep) hot._selfDeclined = !0; else if ("object" == typeof dep && null !== dep) for (var i = 0; i < dep.length; i++) hot._declinedDependencies[dep[i]] = !0; else hot._declinedDependencies[dep] = !0;
},
dispose: function(callback) {
hot._disposeHandlers.push(callback);
},
addDisposeHandler: function(callback) {
hot._disposeHandlers.push(callback);
},
removeDisposeHandler: function(callback) {
var idx = hot._disposeHandlers.indexOf(callback);
idx >= 0 && hot._disposeHandlers.splice(idx, 1);
},
invalidate: function() {
switch (this._selfInvalidated = !0, currentStatus) {
case "idle":
currentUpdateApplyHandlers = [], Object.keys($hmrInvalidateModuleHandlers$).forEach((function(key) {
$hmrInvalidateModuleHandlers$[key](moduleId, currentUpdateApplyHandlers);
})), setStatus("ready");
break;

case "ready":
Object.keys($hmrInvalidateModuleHandlers$).forEach((function(key) {
$hmrInvalidateModuleHandlers$[key](moduleId, currentUpdateApplyHandlers);
}));
break;

case "prepare":
case "check":
case "dispose":
case "apply":
(queuedInvalidatedModules = queuedInvalidatedModules || []).push(moduleId);
}
},
check: hotCheck,
apply: hotApply,
status: function(l) {
if (!l) return currentStatus;
registeredStatusHandlers.push(l);
},
addStatusHandler: function(l) {
registeredStatusHandlers.push(l);
},
removeStatusHandler: function(l) {
var idx = registeredStatusHandlers.indexOf(l);
idx >= 0 && registeredStatusHandlers.splice(idx, 1);
},
data: currentModuleData[moduleId]
}, currentChildModule = void 0, hot), module.parents = currentParents, module.children = [], 
currentParents = [], options.require = require;
})), $hmrDownloadUpdateHandlers$ = {}, $hmrInvalidateModuleHandlers$ = {};
};
},
79963: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor() {
super("hot module replacement", RuntimeModule.STAGE_BASIC);
}
generate() {
return Template.getFunctionContent(__webpack_require__(12343)).replace(/\$getFullHash\$/g, RuntimeGlobals.getFullHash).replace(/\$interceptModuleExecution\$/g, RuntimeGlobals.interceptModuleExecution).replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache).replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData).replace(/\$hmrDownloadManifest\$/g, RuntimeGlobals.hmrDownloadManifest).replace(/\$hmrInvalidateModuleHandlers\$/g, RuntimeGlobals.hmrInvalidateModuleHandlers).replace(/\$hmrDownloadUpdateHandlers\$/g, RuntimeGlobals.hmrDownloadUpdateHandlers);
}
};
},
9692: module => {
"use strict";
var $installedChunks$ = void 0, $loadUpdateChunk$ = void 0, $moduleCache$ = void 0, $moduleFactories$ = void 0, $ensureChunkHandlers$ = void 0, $hasOwnProperty$ = void 0, $hmrModuleData$ = void 0, $hmrDownloadUpdateHandlers$ = void 0, $hmrInvalidateModuleHandlers$ = void 0;
module.exports = function() {
var currentUpdateChunks, currentUpdate, currentUpdateRemovedChunks, currentUpdateRuntime;
function applyHandler(options) {
function getAffectedModuleEffects(updateModuleId) {
for (var outdatedModules = [ updateModuleId ], outdatedDependencies = {}, queue = outdatedModules.map((function(id) {
return {
chain: [ id ],
id
};
})); queue.length > 0; ) {
var queueItem = queue.pop(), moduleId = queueItem.id, chain = queueItem.chain, module = $moduleCache$[moduleId];
if (module && (!module.hot._selfAccepted || module.hot._selfInvalidated)) {
if (module.hot._selfDeclined) return {
type: "self-declined",
chain,
moduleId
};
if (module.hot._main) return {
type: "unaccepted",
chain,
moduleId
};
for (var i = 0; i < module.parents.length; i++) {
var parentId = module.parents[i], parent = $moduleCache$[parentId];
if (parent) {
if (parent.hot._declinedDependencies[moduleId]) return {
type: "declined",
chain: chain.concat([ parentId ]),
moduleId,
parentId
};
-1 === outdatedModules.indexOf(parentId) && (parent.hot._acceptedDependencies[moduleId] ? (outdatedDependencies[parentId] || (outdatedDependencies[parentId] = []), 
addAllToSet(outdatedDependencies[parentId], [ moduleId ])) : (delete outdatedDependencies[parentId], 
outdatedModules.push(parentId), queue.push({
chain: chain.concat([ parentId ]),
id: parentId
})));
}
}
}
}
return {
type: "accepted",
moduleId: updateModuleId,
outdatedModules,
outdatedDependencies
};
}
function addAllToSet(a, b) {
for (var i = 0; i < b.length; i++) {
var item = b[i];
-1 === a.indexOf(item) && a.push(item);
}
}
$ensureChunkHandlers$ && delete $ensureChunkHandlers$.$key$Hmr, currentUpdateChunks = void 0;
var outdatedDependencies = {}, outdatedModules = [], appliedUpdate = {}, warnUnexpectedRequire = function(module) {
console.warn("[HMR] unexpected require(" + module.id + ") to disposed module");
};
for (var moduleId in currentUpdate) if ($hasOwnProperty$(currentUpdate, moduleId)) {
var result, newModuleFactory = currentUpdate[moduleId], abortError = !1, doApply = !1, doDispose = !1, chainInfo = "";
switch ((result = newModuleFactory ? getAffectedModuleEffects(moduleId) : {
type: "disposed",
moduleId
}).chain && (chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ")), 
result.type) {
case "self-declined":
options.onDeclined && options.onDeclined(result), options.ignoreDeclined || (abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo));
break;

case "declined":
options.onDeclined && options.onDeclined(result), options.ignoreDeclined || (abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo));
break;

case "unaccepted":
options.onUnaccepted && options.onUnaccepted(result), options.ignoreUnaccepted || (abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo));
break;

case "accepted":
options.onAccepted && options.onAccepted(result), doApply = !0;
break;

case "disposed":
options.onDisposed && options.onDisposed(result), doDispose = !0;
break;

default:
throw new Error("Unexception type " + result.type);
}
if (abortError) return {
error: abortError
};
if (doApply) for (moduleId in appliedUpdate[moduleId] = newModuleFactory, addAllToSet(outdatedModules, result.outdatedModules), 
result.outdatedDependencies) $hasOwnProperty$(result.outdatedDependencies, moduleId) && (outdatedDependencies[moduleId] || (outdatedDependencies[moduleId] = []), 
addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]));
doDispose && (addAllToSet(outdatedModules, [ result.moduleId ]), appliedUpdate[moduleId] = warnUnexpectedRequire);
}
currentUpdate = void 0;
for (var moduleOutdatedDependencies, outdatedSelfAcceptedModules = [], j = 0; j < outdatedModules.length; j++) {
var outdatedModuleId = outdatedModules[j], module = $moduleCache$[outdatedModuleId];
module && (module.hot._selfAccepted || module.hot._main) && appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire && !module.hot._selfInvalidated && outdatedSelfAcceptedModules.push({
module: outdatedModuleId,
require: module.hot._requireSelf,
errorHandler: module.hot._selfAccepted
});
}
return {
dispose: function() {
var idx;
currentUpdateRemovedChunks.forEach((function(chunkId) {
delete $installedChunks$[chunkId];
})), currentUpdateRemovedChunks = void 0;
for (var dependency, queue = outdatedModules.slice(); queue.length > 0; ) {
var moduleId = queue.pop(), module = $moduleCache$[moduleId];
if (module) {
var data = {}, disposeHandlers = module.hot._disposeHandlers;
for (j = 0; j < disposeHandlers.length; j++) disposeHandlers[j].call(null, data);
for ($hmrModuleData$[moduleId] = data, module.hot.active = !1, delete $moduleCache$[moduleId], 
delete outdatedDependencies[moduleId], j = 0; j < module.children.length; j++) {
var child = $moduleCache$[module.children[j]];
child && ((idx = child.parents.indexOf(moduleId)) >= 0 && child.parents.splice(idx, 1));
}
}
}
for (var outdatedModuleId in outdatedDependencies) if ($hasOwnProperty$(outdatedDependencies, outdatedModuleId) && (module = $moduleCache$[outdatedModuleId])) for (moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId], 
j = 0; j < moduleOutdatedDependencies.length; j++) dependency = moduleOutdatedDependencies[j], 
(idx = module.children.indexOf(dependency)) >= 0 && module.children.splice(idx, 1);
},
apply: function(reportError) {
for (var updateModuleId in appliedUpdate) $hasOwnProperty$(appliedUpdate, updateModuleId) && ($moduleFactories$[updateModuleId] = appliedUpdate[updateModuleId]);
for (var i = 0; i < currentUpdateRuntime.length; i++) currentUpdateRuntime[i](undefined);
for (var outdatedModuleId in outdatedDependencies) if ($hasOwnProperty$(outdatedDependencies, outdatedModuleId)) {
var module = $moduleCache$[outdatedModuleId];
if (module) {
moduleOutdatedDependencies = outdatedDependencies[outdatedModuleId];
for (var callbacks = [], errorHandlers = [], dependenciesForCallbacks = [], j = 0; j < moduleOutdatedDependencies.length; j++) {
var dependency = moduleOutdatedDependencies[j], acceptCallback = module.hot._acceptedDependencies[dependency], errorHandler = module.hot._acceptedErrorHandlers[dependency];
if (acceptCallback) {
if (-1 !== callbacks.indexOf(acceptCallback)) continue;
callbacks.push(acceptCallback), errorHandlers.push(errorHandler), dependenciesForCallbacks.push(dependency);
}
}
for (var k = 0; k < callbacks.length; k++) try {
callbacks[k].call(null, moduleOutdatedDependencies);
} catch (err) {
if ("function" == typeof errorHandlers[k]) try {
errorHandlers[k](err, {
moduleId: outdatedModuleId,
dependencyId: dependenciesForCallbacks[k]
});
} catch (err2) {
options.onErrored && options.onErrored({
type: "accept-error-handler-errored",
moduleId: outdatedModuleId,
dependencyId: dependenciesForCallbacks[k],
error: err2,
originalError: err
}), options.ignoreErrored || (reportError(err2), reportError(err));
} else options.onErrored && options.onErrored({
type: "accept-errored",
moduleId: outdatedModuleId,
dependencyId: dependenciesForCallbacks[k],
error: err
}), options.ignoreErrored || reportError(err);
}
}
}
for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
var item = outdatedSelfAcceptedModules[o], moduleId = item.module;
try {
item.require(moduleId);
} catch (err) {
if ("function" == typeof item.errorHandler) try {
item.errorHandler(err, {
moduleId,
module: $moduleCache$[moduleId]
});
} catch (err2) {
options.onErrored && options.onErrored({
type: "self-accept-error-handler-errored",
moduleId,
error: err2,
originalError: err
}), options.ignoreErrored || (reportError(err2), reportError(err));
} else options.onErrored && options.onErrored({
type: "self-accept-errored",
moduleId,
error: err
}), options.ignoreErrored || reportError(err);
}
}
return outdatedModules;
}
};
}
$hmrInvalidateModuleHandlers$.$key$ = function(moduleId, applyHandlers) {
currentUpdate || (currentUpdate = {}, currentUpdateRuntime = [], currentUpdateRemovedChunks = [], 
applyHandlers.push(applyHandler)), $hasOwnProperty$(currentUpdate, moduleId) || (currentUpdate[moduleId] = $moduleFactories$[moduleId]);
}, $hmrDownloadUpdateHandlers$.$key$ = function(chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList) {
applyHandlers.push(applyHandler), currentUpdateChunks = {}, currentUpdateRemovedChunks = removedChunks, 
currentUpdate = removedModules.reduce((function(obj, key) {
return obj[key] = !1, obj;
}), {}), currentUpdateRuntime = [], chunkIds.forEach((function(chunkId) {
$hasOwnProperty$($installedChunks$, chunkId) && void 0 !== $installedChunks$[chunkId] ? (promises.push($loadUpdateChunk$(chunkId, updatedModulesList)), 
currentUpdateChunks[chunkId] = !0) : currentUpdateChunks[chunkId] = !1;
})), $ensureChunkHandlers$ && ($ensureChunkHandlers$.$key$Hmr = function(chunkId, promises) {
currentUpdateChunks && $hasOwnProperty$(currentUpdateChunks, chunkId) && !currentUpdateChunks[chunkId] && (promises.push($loadUpdateChunk$(chunkId)), 
currentUpdateChunks[chunkId] = !0);
});
};
};
},
52230: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), AsyncDependenciesBlock = __webpack_require__(89353), Dependency = __webpack_require__(14926), Module = __webpack_require__(36797), ModuleFactory = __webpack_require__(37019), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), CommonJsRequireDependency = __webpack_require__(26777), {registerNotSerializable} = __webpack_require__(86601), HMR_DEPENDENCY_TYPES = new Set([ "import.meta.webpackHot.accept", "import.meta.webpackHot.decline", "module.hot.accept", "module.hot.decline" ]), TYPES = new Set([ "javascript" ]);
class LazyCompilationDependency extends Dependency {
constructor(proxyModule) {
super(), this.proxyModule = proxyModule;
}
get category() {
return "esm";
}
get type() {
return "lazy import()";
}
getResourceIdentifier() {
return this.proxyModule.originalModule.identifier();
}
}
registerNotSerializable(LazyCompilationDependency);
class LazyCompilationProxyModule extends Module {
constructor(context, originalModule, request, client, data, active) {
super("lazy-compilation-proxy", context, originalModule.layer), this.originalModule = originalModule, 
this.request = request, this.client = client, this.data = data, this.active = active;
}
identifier() {
return `lazy-compilation-proxy|${this.originalModule.identifier()}`;
}
readableIdentifier(requestShortener) {
return `lazy-compilation-proxy ${this.originalModule.readableIdentifier(requestShortener)}`;
}
updateCacheModule(module) {
super.updateCacheModule(module);
const m = module;
this.originalModule = m.originalModule, this.request = m.request, this.client = m.client, 
this.data = m.data, this.active = m.active;
}
libIdent(options) {
return `${this.originalModule.libIdent(options)}!lazy-compilation-proxy`;
}
needBuild(context, callback) {
callback(null, !this.buildInfo || this.buildInfo.active !== this.active);
}
build(options, compilation, resolver, fs, callback) {
this.buildInfo = {
active: this.active
}, this.buildMeta = {}, this.clearDependenciesAndBlocks();
const dep = new CommonJsRequireDependency(this.client);
if (this.addDependency(dep), this.active) {
const dep = new LazyCompilationDependency(this), block = new AsyncDependenciesBlock({});
block.addDependency(dep), this.addBlock(block);
}
callback();
}
getSourceTypes() {
return TYPES;
}
size(type) {
return 200;
}
codeGeneration({runtimeTemplate, chunkGraph, moduleGraph}) {
const sources = new Map, runtimeRequirements = new Set;
runtimeRequirements.add(RuntimeGlobals.module);
const clientDep = this.dependencies[0], clientModule = moduleGraph.getModule(clientDep), block = this.blocks[0], client = Template.asString([ `var client = ${runtimeTemplate.moduleExports({
module: clientModule,
chunkGraph,
request: clientDep.userRequest,
runtimeRequirements
})}`, `var data = ${JSON.stringify(this.data)};` ]), keepActive = Template.asString([ `var dispose = client.keepAlive({ data: data, active: ${JSON.stringify(!!block)}, module: module, onError: onError });` ]);
let source;
if (block) {
const dep = block.dependencies[0], module = moduleGraph.getModule(dep);
source = Template.asString([ client, `module.exports = ${runtimeTemplate.moduleNamespacePromise({
chunkGraph,
block,
module,
request: this.request,
strict: !1,
message: "import()",
runtimeRequirements
})};`, "if (module.hot) {", Template.indent([ "module.hot.accept();", `module.hot.accept(${JSON.stringify(chunkGraph.getModuleId(module))}, function() { module.hot.invalidate(); });`, "module.hot.dispose(function(data) { delete data.resolveSelf; dispose(data); });", "if (module.hot.data && module.hot.data.resolveSelf) module.hot.data.resolveSelf(module.exports);" ]), "}", "function onError() { /* ignore */ }", keepActive ]);
} else source = Template.asString([ client, "var resolveSelf, onError;", "module.exports = new Promise(function(resolve, reject) { resolveSelf = resolve; onError = reject; });", "if (module.hot) {", Template.indent([ "module.hot.accept();", "if (module.hot.data && module.hot.data.resolveSelf) module.hot.data.resolveSelf(module.exports);", "module.hot.dispose(function(data) { data.resolveSelf = resolveSelf; dispose(data); });" ]), "}", keepActive ]);
return sources.set("javascript", new RawSource(source)), {
sources,
runtimeRequirements
};
}
updateHash(hash, context) {
super.updateHash(hash, context), hash.update(this.active ? "active" : ""), hash.update(JSON.stringify(this.data));
}
}
registerNotSerializable(LazyCompilationProxyModule);
class LazyCompilationDependencyFactory extends ModuleFactory {
constructor(factory) {
super(), this._factory = factory;
}
create(data, callback) {
callback(null, {
module: data.dependencies[0].proxyModule.originalModule
});
}
}
module.exports = class {
constructor({backend, entries, imports, test}) {
this.backend = backend, this.entries = entries, this.imports = imports, this.test = test;
}
apply(compiler) {
let backend;
compiler.hooks.beforeCompile.tapAsync("LazyCompilationPlugin", ((params, callback) => {
if (void 0 !== backend) return callback();
const promise = this.backend(compiler, ((err, result) => {
if (err) return callback(err);
backend = result, callback();
}));
promise && promise.then && promise.then((b => {
backend = b, callback();
}), callback);
})), compiler.hooks.thisCompilation.tap("LazyCompilationPlugin", ((compilation, {normalModuleFactory}) => {
normalModuleFactory.hooks.module.tap("LazyCompilationPlugin", ((originalModule, createData, resolveData) => {
if (resolveData.dependencies.every((dep => HMR_DEPENDENCY_TYPES.has(dep.type)))) {
const hmrDep = resolveData.dependencies[0];
if (!compilation.moduleGraph.getParentModule(hmrDep).blocks.some((block => block.dependencies.some((dep => "import()" === dep.type && dep.request === hmrDep.request))))) return;
} else if (!resolveData.dependencies.every((dep => HMR_DEPENDENCY_TYPES.has(dep.type) || this.imports && ("import()" === dep.type || "import() context element" === dep.type) || this.entries && "entry" === dep.type))) return;
if (/webpack[/\\]hot[/\\]|webpack-dev-server[/\\]client|webpack-hot-middleware[/\\]client/.test(resolveData.request) || !((test, module) => {
if (void 0 === test) return !0;
if ("function" == typeof test) return test(module);
if ("string" == typeof test) {
const name = module.nameForCondition();
return name && name.startsWith(test);
}
if (test instanceof RegExp) {
const name = module.nameForCondition();
return name && test.test(name);
}
return !1;
})(this.test, originalModule)) return;
const moduleInfo = backend.module(originalModule);
if (!moduleInfo) return;
const {client, data, active} = moduleInfo;
return new LazyCompilationProxyModule(compiler.context, originalModule, resolveData.request, client, data, active);
})), compilation.dependencyFactories.set(LazyCompilationDependency, new LazyCompilationDependencyFactory);
})), compiler.hooks.shutdown.tapAsync("LazyCompilationPlugin", (callback => {
backend.dispose(callback);
}));
}
};
},
4585: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
module.exports = options => (compiler, callback) => {
const logger = compiler.getInfrastructureLogger("LazyCompilationBackend"), activeModules = new Map, prefix = "/lazy-compilation-using-", isHttps = "https" === options.protocol || "object" == typeof options.server && ("key" in options.server || "pfx" in options.server), createServer = "function" == typeof options.server ? options.server : (() => {
const http = __webpack_require__(isHttps ? 95687 : 13685);
return http.createServer.bind(http, options.server);
})(), listen = "function" == typeof options.listen ? options.listen : server => {
let listen = options.listen;
"object" != typeof listen || "port" in listen || (listen = {
...listen,
port: void 0
}), server.listen(listen);
}, protocol = options.protocol || (isHttps ? "https" : "http"), requestListener = (req, res) => {
const keys = req.url.slice(prefix.length).split("@");
req.socket.on("close", (() => {
setTimeout((() => {
for (const key of keys) {
const oldValue = activeModules.get(key) || 0;
activeModules.set(key, oldValue - 1), 1 === oldValue && logger.log(`${key} is no longer in use. Next compilation will skip this module.`);
}
}), 12e4);
})), req.socket.setNoDelay(!0), res.writeHead(200, {
"content-type": "text/event-stream",
"Access-Control-Allow-Origin": "*",
"Access-Control-Allow-Methods": "*",
"Access-Control-Allow-Headers": "*"
}), res.write("\n");
let moduleActivated = !1;
for (const key of keys) {
const oldValue = activeModules.get(key) || 0;
activeModules.set(key, oldValue + 1), 0 === oldValue && (logger.log(`${key} is now in use and will be compiled.`), 
moduleActivated = !0);
}
moduleActivated && compiler.watching && compiler.watching.invalidate();
}, server = createServer();
server.on("request", requestListener);
let isClosing = !1;
const sockets = new Set;
server.on("connection", (socket => {
sockets.add(socket), socket.on("close", (() => {
sockets.delete(socket);
})), isClosing && socket.destroy();
})), server.on("clientError", (e => {
"Server is disposing" !== e.message && logger.warn(e);
})), server.on("listening", (err => {
if (err) return callback(err);
const addr = server.address();
if ("string" == typeof addr) throw new Error("addr must not be a string");
const urlBase = "::" === addr.address || "0.0.0.0" === addr.address ? `${protocol}://localhost:${addr.port}` : "IPv6" === addr.family ? `${protocol}://[${addr.address}]:${addr.port}` : `${protocol}://${addr.address}:${addr.port}`;
logger.log(`Server-Sent-Events server for lazy compilation open at ${urlBase}.`), 
callback(null, {
dispose(callback) {
isClosing = !0, server.off("request", requestListener), server.close((err => {
callback(err);
}));
for (const socket of sockets) socket.destroy(new Error("Server is disposing"));
},
module(originalModule) {
const key = `${encodeURIComponent(originalModule.identifier().replace(/\\/g, "/").replace(/@/g, "_")).replace(/%(2F|3A|24|26|2B|2C|3B|3D|3A)/g, decodeURIComponent)}`, active = activeModules.get(key) > 0;
return {
client: `${options.client}?${encodeURIComponent(urlBase + prefix)}`,
data: key,
active
};
}
});
})), listen(server);
};
},
83690: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {find} = __webpack_require__(73974), {compareModulesByPreOrderIndexOrIdentifier, compareModulesByPostOrderIndexOrIdentifier} = __webpack_require__(40028);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
const options = this.options;
compiler.hooks.compilation.tap("ChunkModuleIdRangePlugin", (compilation => {
const moduleGraph = compilation.moduleGraph;
compilation.hooks.moduleIds.tap("ChunkModuleIdRangePlugin", (modules => {
const chunkGraph = compilation.chunkGraph, chunk = find(compilation.chunks, (chunk => chunk.name === options.name));
if (!chunk) throw new Error(`ChunkModuleIdRangePlugin: Chunk with name '${options.name}"' was not found`);
let chunkModules;
if (options.order) {
let cmpFn;
switch (options.order) {
case "index":
case "preOrderIndex":
cmpFn = compareModulesByPreOrderIndexOrIdentifier(moduleGraph);
break;

case "index2":
case "postOrderIndex":
cmpFn = compareModulesByPostOrderIndexOrIdentifier(moduleGraph);
break;

default:
throw new Error("ChunkModuleIdRangePlugin: unexpected value of order");
}
chunkModules = chunkGraph.getOrderedChunkModules(chunk, cmpFn);
} else chunkModules = Array.from(modules).filter((m => chunkGraph.isModuleInChunk(m, chunk))).sort(compareModulesByPreOrderIndexOrIdentifier(moduleGraph));
let currentId = options.start || 0;
for (let i = 0; i < chunkModules.length; i++) {
const m = chunkModules[i];
if (m.needId && null === chunkGraph.getModuleId(m) && chunkGraph.setModuleId(m, currentId++), 
options.end && currentId > options.end) break;
}
}));
}));
}
};
},
34512: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareChunksNatural} = __webpack_require__(40028), {getFullChunkName, getUsedChunkIds, assignDeterministicIds} = __webpack_require__(89945);
module.exports = class {
constructor(options) {
this.options = options || {};
}
apply(compiler) {
compiler.hooks.compilation.tap("DeterministicChunkIdsPlugin", (compilation => {
compilation.hooks.chunkIds.tap("DeterministicChunkIdsPlugin", (chunks => {
const chunkGraph = compilation.chunkGraph, context = this.options.context ? this.options.context : compiler.context, maxLength = this.options.maxLength || 3, compareNatural = compareChunksNatural(chunkGraph), usedIds = getUsedChunkIds(compilation);
assignDeterministicIds(Array.from(chunks).filter((chunk => null === chunk.id)), (chunk => getFullChunkName(chunk, chunkGraph, context, compiler.root)), compareNatural, ((chunk, id) => {
const size = usedIds.size;
return usedIds.add(`${id}`), size !== usedIds.size && (chunk.id = id, chunk.ids = [ id ], 
!0);
}), [ Math.pow(10, maxLength) ], 10, usedIds.size);
}));
}));
}
};
},
84967: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareModulesByPreOrderIndexOrIdentifier} = __webpack_require__(40028), {getUsedModuleIdsAndModules, getFullModuleName, assignDeterministicIds} = __webpack_require__(89945);
module.exports = class {
constructor(options = {}) {
this.options = options;
}
apply(compiler) {
compiler.hooks.compilation.tap("DeterministicModuleIdsPlugin", (compilation => {
compilation.hooks.moduleIds.tap("DeterministicModuleIdsPlugin", (() => {
const chunkGraph = compilation.chunkGraph, context = this.options.context ? this.options.context : compiler.context, maxLength = this.options.maxLength || 3, failOnConflict = this.options.failOnConflict || !1, fixedLength = this.options.fixedLength || !1, salt = this.options.salt || 0;
let conflicts = 0;
const [usedIds, modules] = getUsedModuleIdsAndModules(compilation, this.options.test);
if (assignDeterministicIds(modules, (module => getFullModuleName(module, context, compiler.root)), failOnConflict ? () => 0 : compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph), ((module, id) => {
const size = usedIds.size;
return usedIds.add(`${id}`), size === usedIds.size ? (conflicts++, !1) : (chunkGraph.setModuleId(module, id), 
!0);
}), [ Math.pow(10, maxLength) ], fixedLength ? 0 : 10, usedIds.size, salt), failOnConflict && conflicts) throw new Error(`Assigning deterministic module ids has lead to ${conflicts} conflict${conflicts > 1 ? "s" : ""}.\nIncrease the 'maxLength' to increase the id space and make conflicts less likely (recommended when there are many conflicts or application is expected to grow), or add an 'salt' number to try another hash starting value in the same id space (recommended when there is only a single conflict).`);
}));
}));
}
};
},
5429: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareModulesByPreOrderIndexOrIdentifier} = __webpack_require__(40028), createSchemaValidation = __webpack_require__(59586), createHash = __webpack_require__(27466), {getUsedModuleIdsAndModules, getFullModuleName} = __webpack_require__(89945), validate = createSchemaValidation(__webpack_require__(35227), (() => __webpack_require__(39586)), {
name: "Hashed Module Ids Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options = {}) {
validate(options), this.options = {
context: null,
hashFunction: "md4",
hashDigest: "base64",
hashDigestLength: 4,
...options
};
}
apply(compiler) {
const options = this.options;
compiler.hooks.compilation.tap("HashedModuleIdsPlugin", (compilation => {
compilation.hooks.moduleIds.tap("HashedModuleIdsPlugin", (() => {
const chunkGraph = compilation.chunkGraph, context = this.options.context ? this.options.context : compiler.context, [usedIds, modules] = getUsedModuleIdsAndModules(compilation), modulesInNaturalOrder = modules.sort(compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph));
for (const module of modulesInNaturalOrder) {
const ident = getFullModuleName(module, context, compiler.root), hash = createHash(options.hashFunction);
hash.update(ident || "");
const hashId = hash.digest(options.hashDigest);
let len = options.hashDigestLength;
for (;usedIds.has(hashId.slice(0, len)); ) len++;
const moduleId = hashId.slice(0, len);
chunkGraph.setModuleId(module, moduleId), usedIds.add(moduleId);
}
}));
}));
}
};
},
89945: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const createHash = __webpack_require__(27466), {makePathsRelative} = __webpack_require__(63264), numberHash = __webpack_require__(42731), getHash = (str, len, hashFunction) => {
const hash = createHash(hashFunction);
hash.update(str);
return hash.digest("hex").slice(0, len);
}, avoidNumber = str => {
if (str.length > 21) return str;
const firstChar = str.charCodeAt(0);
if (firstChar < 49) {
if (45 !== firstChar) return str;
} else if (firstChar > 57) return str;
return str === +str + "" ? `_${str}` : str;
}, requestToId = request => request.replace(/^(\.\.?\/)+/, "").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, "_");
exports.requestToId = requestToId;
const shortenLongString = (string, delimiter, hashFunction) => string.length < 100 ? string : string.slice(0, 94 - delimiter.length) + delimiter + getHash(string, 6, hashFunction), getShortModuleName = (module, context, associatedObjectForCache) => {
const libIdent = module.libIdent({
context,
associatedObjectForCache
});
if (libIdent) return avoidNumber(libIdent);
const nameForCondition = module.nameForCondition();
return nameForCondition ? avoidNumber(makePathsRelative(context, nameForCondition, associatedObjectForCache)) : "";
};
exports.getShortModuleName = getShortModuleName;
const getLongModuleName = (shortName, module, context, hashFunction, associatedObjectForCache) => {
const fullName = getFullModuleName(module, context, associatedObjectForCache);
return `${shortName}?${getHash(fullName, 4, hashFunction)}`;
};
exports.getLongModuleName = getLongModuleName;
const getFullModuleName = (module, context, associatedObjectForCache) => makePathsRelative(context, module.identifier(), associatedObjectForCache);
exports.getFullModuleName = getFullModuleName;
exports.getShortChunkName = (chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) => {
const shortModuleNames = chunkGraph.getChunkRootModules(chunk).map((m => requestToId(getShortModuleName(m, context, associatedObjectForCache))));
chunk.idNameHints.sort();
const chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames).filter(Boolean).join(delimiter);
return shortenLongString(chunkName, delimiter, hashFunction);
};
exports.getLongChunkName = (chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) => {
const modules = chunkGraph.getChunkRootModules(chunk), shortModuleNames = modules.map((m => requestToId(getShortModuleName(m, context, associatedObjectForCache)))), longModuleNames = modules.map((m => requestToId(getLongModuleName("", m, context, hashFunction, associatedObjectForCache))));
chunk.idNameHints.sort();
const chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames, longModuleNames).filter(Boolean).join(delimiter);
return shortenLongString(chunkName, delimiter, hashFunction);
};
exports.getFullChunkName = (chunk, chunkGraph, context, associatedObjectForCache) => {
if (chunk.name) return chunk.name;
return chunkGraph.getChunkRootModules(chunk).map((m => makePathsRelative(context, m.identifier(), associatedObjectForCache))).join();
};
const addToMapOfItems = (map, key, value) => {
let array = map.get(key);
void 0 === array && (array = [], map.set(key, array)), array.push(value);
};
exports.getUsedModuleIdsAndModules = (compilation, filter) => {
const chunkGraph = compilation.chunkGraph, modules = [], usedIds = new Set;
if (compilation.usedModuleIds) for (const id of compilation.usedModuleIds) usedIds.add(id + "");
for (const module of compilation.modules) {
if (!module.needId) continue;
const moduleId = chunkGraph.getModuleId(module);
null !== moduleId ? usedIds.add(moduleId + "") : filter && !filter(module) || 0 === chunkGraph.getNumberOfModuleChunks(module) || modules.push(module);
}
return [ usedIds, modules ];
};
const getUsedChunkIds = compilation => {
const usedIds = new Set;
if (compilation.usedChunkIds) for (const id of compilation.usedChunkIds) usedIds.add(id + "");
for (const chunk of compilation.chunks) {
const chunkId = chunk.id;
null !== chunkId && usedIds.add(chunkId + "");
}
return usedIds;
};
exports.getUsedChunkIds = getUsedChunkIds;
exports.assignNames = (items, getShortName, getLongName, comparator, usedIds, assignName) => {
const nameToItems = new Map;
for (const item of items) {
const name = getShortName(item);
addToMapOfItems(nameToItems, name, item);
}
const nameToItems2 = new Map;
for (const [name, items] of nameToItems) if (items.length > 1 || !name) for (const item of items) {
const longName = getLongName(item, name);
addToMapOfItems(nameToItems2, longName, item);
} else addToMapOfItems(nameToItems2, name, items[0]);
const unnamedItems = [];
for (const [name, items] of nameToItems2) if (name) if (1 !== items.length || usedIds.has(name)) {
items.sort(comparator);
let i = 0;
for (const item of items) {
for (;nameToItems2.has(name + i) && usedIds.has(name + i); ) i++;
assignName(item, name + i), usedIds.add(name + i), i++;
}
} else assignName(items[0], name), usedIds.add(name); else for (const item of items) unnamedItems.push(item);
return unnamedItems.sort(comparator), unnamedItems;
};
exports.assignDeterministicIds = (items, getName, comparator, assignId, ranges = [ 10 ], expandFactor = 10, extraSpace = 0, salt = 0) => {
items.sort(comparator);
const optimalRange = Math.min(Math.ceil(20 * items.length) + extraSpace, Number.MAX_SAFE_INTEGER);
let i = 0, range = ranges[i];
for (;range < optimalRange; ) if (i++, i < ranges.length) range = Math.min(ranges[i], Number.MAX_SAFE_INTEGER); else {
if (!expandFactor) break;
range = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);
}
for (const item of items) {
const ident = getName(item);
let id, i = salt;
do {
id = numberHash(ident + i++, range);
} while (!assignId(item, id));
}
};
exports.assignAscendingModuleIds = (usedIds, modules, compilation) => {
const chunkGraph = compilation.chunkGraph;
let assignId, nextId = 0;
assignId = usedIds.size > 0 ? module => {
if (null === chunkGraph.getModuleId(module)) {
for (;usedIds.has(nextId + ""); ) nextId++;
chunkGraph.setModuleId(module, nextId++);
}
} : module => {
null === chunkGraph.getModuleId(module) && chunkGraph.setModuleId(module, nextId++);
};
for (const module of modules) assignId(module);
};
exports.assignAscendingChunkIds = (chunks, compilation) => {
const usedIds = getUsedChunkIds(compilation);
let nextId = 0;
if (usedIds.size > 0) {
for (const chunk of chunks) if (null === chunk.id) {
for (;usedIds.has(nextId + ""); ) nextId++;
chunk.id = nextId, chunk.ids = [ nextId ], nextId++;
}
} else for (const chunk of chunks) null === chunk.id && (chunk.id = nextId, chunk.ids = [ nextId ], 
nextId++);
};
},
55127: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareChunksNatural} = __webpack_require__(40028), {getShortChunkName, getLongChunkName, assignNames, getUsedChunkIds, assignAscendingChunkIds} = __webpack_require__(89945);
module.exports = class {
constructor(options) {
this.delimiter = options && options.delimiter || "-", this.context = options && options.context;
}
apply(compiler) {
compiler.hooks.compilation.tap("NamedChunkIdsPlugin", (compilation => {
const {hashFunction} = compilation.outputOptions;
compilation.hooks.chunkIds.tap("NamedChunkIdsPlugin", (chunks => {
const chunkGraph = compilation.chunkGraph, context = this.context ? this.context : compiler.context, delimiter = this.delimiter, unnamedChunks = assignNames(Array.from(chunks).filter((chunk => (chunk.name && (chunk.id = chunk.name, 
chunk.ids = [ chunk.name ]), null === chunk.id))), (chunk => getShortChunkName(chunk, chunkGraph, context, delimiter, hashFunction, compiler.root)), (chunk => getLongChunkName(chunk, chunkGraph, context, delimiter, hashFunction, compiler.root)), compareChunksNatural(chunkGraph), getUsedChunkIds(compilation), ((chunk, name) => {
chunk.id = name, chunk.ids = [ name ];
}));
unnamedChunks.length > 0 && assignAscendingChunkIds(unnamedChunks, compilation);
}));
}));
}
};
},
13924: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareModulesByIdentifier} = __webpack_require__(40028), {getShortModuleName, getLongModuleName, assignNames, getUsedModuleIdsAndModules, assignAscendingModuleIds} = __webpack_require__(89945);
module.exports = class {
constructor(options) {
this.options = options || {};
}
apply(compiler) {
const {root} = compiler;
compiler.hooks.compilation.tap("NamedModuleIdsPlugin", (compilation => {
const {hashFunction} = compilation.outputOptions;
compilation.hooks.moduleIds.tap("NamedModuleIdsPlugin", (() => {
const chunkGraph = compilation.chunkGraph, context = this.options.context ? this.options.context : compiler.context, [usedIds, modules] = getUsedModuleIdsAndModules(compilation), unnamedModules = assignNames(modules, (m => getShortModuleName(m, context, root)), ((m, shortName) => getLongModuleName(shortName, m, context, hashFunction, root)), compareModulesByIdentifier, usedIds, ((m, name) => chunkGraph.setModuleId(m, name)));
unnamedModules.length > 0 && assignAscendingModuleIds(usedIds, unnamedModules, compilation);
}));
}));
}
};
},
84118: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareChunksNatural} = __webpack_require__(40028), {assignAscendingChunkIds} = __webpack_require__(89945);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("NaturalChunkIdsPlugin", (compilation => {
compilation.hooks.chunkIds.tap("NaturalChunkIdsPlugin", (chunks => {
const chunkGraph = compilation.chunkGraph, compareNatural = compareChunksNatural(chunkGraph), chunksInNaturalOrder = Array.from(chunks).sort(compareNatural);
assignAscendingChunkIds(chunksInNaturalOrder, compilation);
}));
}));
}
};
},
59940: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareModulesByPreOrderIndexOrIdentifier} = __webpack_require__(40028), {assignAscendingModuleIds, getUsedModuleIdsAndModules} = __webpack_require__(89945);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("NaturalModuleIdsPlugin", (compilation => {
compilation.hooks.moduleIds.tap("NaturalModuleIdsPlugin", (modules => {
const [usedIds, modulesInNaturalOrder] = getUsedModuleIdsAndModules(compilation);
modulesInNaturalOrder.sort(compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph)), 
assignAscendingModuleIds(usedIds, modulesInNaturalOrder, compilation);
}));
}));
}
};
},
4705: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareChunksNatural} = __webpack_require__(40028), createSchemaValidation = __webpack_require__(59586), {assignAscendingChunkIds} = __webpack_require__(89945), validate = createSchemaValidation(__webpack_require__(12599), (() => __webpack_require__(9659)), {
name: "Occurrence Order Chunk Ids Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options = {}) {
validate(options), this.options = options;
}
apply(compiler) {
const prioritiseInitial = this.options.prioritiseInitial;
compiler.hooks.compilation.tap("OccurrenceChunkIdsPlugin", (compilation => {
compilation.hooks.chunkIds.tap("OccurrenceChunkIdsPlugin", (chunks => {
const chunkGraph = compilation.chunkGraph, occursInInitialChunksMap = new Map, compareNatural = compareChunksNatural(chunkGraph);
for (const c of chunks) {
let occurs = 0;
for (const chunkGroup of c.groupsIterable) for (const parent of chunkGroup.parentsIterable) parent.isInitial() && occurs++;
occursInInitialChunksMap.set(c, occurs);
}
const chunksInOccurrenceOrder = Array.from(chunks).sort(((a, b) => {
if (prioritiseInitial) {
const aEntryOccurs = occursInInitialChunksMap.get(a), bEntryOccurs = occursInInitialChunksMap.get(b);
if (aEntryOccurs > bEntryOccurs) return -1;
if (aEntryOccurs < bEntryOccurs) return 1;
}
const aOccurs = a.getNumberOfGroups(), bOccurs = b.getNumberOfGroups();
return aOccurs > bOccurs ? -1 : aOccurs < bOccurs ? 1 : compareNatural(a, b);
}));
assignAscendingChunkIds(chunksInOccurrenceOrder, compilation);
}));
}));
}
};
},
36669: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {compareModulesByPreOrderIndexOrIdentifier} = __webpack_require__(40028), createSchemaValidation = __webpack_require__(59586), {assignAscendingModuleIds, getUsedModuleIdsAndModules} = __webpack_require__(89945), validate = createSchemaValidation(__webpack_require__(29209), (() => __webpack_require__(37931)), {
name: "Occurrence Order Module Ids Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options = {}) {
validate(options), this.options = options;
}
apply(compiler) {
const prioritiseInitial = this.options.prioritiseInitial;
compiler.hooks.compilation.tap("OccurrenceModuleIdsPlugin", (compilation => {
const moduleGraph = compilation.moduleGraph;
compilation.hooks.moduleIds.tap("OccurrenceModuleIdsPlugin", (() => {
const chunkGraph = compilation.chunkGraph, [usedIds, modulesInOccurrenceOrder] = getUsedModuleIdsAndModules(compilation), occursInInitialChunksMap = new Map, occursInAllChunksMap = new Map, initialChunkChunkMap = new Map, entryCountMap = new Map;
for (const m of modulesInOccurrenceOrder) {
let initial = 0, entry = 0;
for (const c of chunkGraph.getModuleChunksIterable(m)) c.canBeInitial() && initial++, 
chunkGraph.isEntryModuleInChunk(m, c) && entry++;
initialChunkChunkMap.set(m, initial), entryCountMap.set(m, entry);
}
const countOccursInEntry = module => {
let sum = 0;
for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) originModule && connections.some((c => c.isTargetActive(void 0))) && (sum += initialChunkChunkMap.get(originModule));
return sum;
}, countOccurs = module => {
let sum = 0;
for (const [originModule, connections] of moduleGraph.getIncomingConnectionsByOriginModule(module)) {
if (!originModule) continue;
const chunkModules = chunkGraph.getNumberOfModuleChunks(originModule);
for (const c of connections) {
if (!c.isTargetActive(void 0)) continue;
if (!c.dependency) continue;
const factor = c.dependency.getNumberOfIdOccurrences();
0 !== factor && (sum += factor * chunkModules);
}
}
return sum;
};
if (prioritiseInitial) for (const m of modulesInOccurrenceOrder) {
const result = countOccursInEntry(m) + initialChunkChunkMap.get(m) + entryCountMap.get(m);
occursInInitialChunksMap.set(m, result);
}
for (const m of modulesInOccurrenceOrder) {
const result = countOccurs(m) + chunkGraph.getNumberOfModuleChunks(m) + entryCountMap.get(m);
occursInAllChunksMap.set(m, result);
}
const naturalCompare = compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph);
modulesInOccurrenceOrder.sort(((a, b) => {
if (prioritiseInitial) {
const aEntryOccurs = occursInInitialChunksMap.get(a), bEntryOccurs = occursInInitialChunksMap.get(b);
if (aEntryOccurs > bEntryOccurs) return -1;
if (aEntryOccurs < bEntryOccurs) return 1;
}
const aOccurs = occursInAllChunksMap.get(a), bOccurs = occursInAllChunksMap.get(b);
return aOccurs > bOccurs ? -1 : aOccurs < bOccurs ? 1 : naturalCompare(a, b);
})), assignAscendingModuleIds(usedIds, modulesInOccurrenceOrder, compilation);
}));
}));
}
};
},
12686: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {WebpackError} = __webpack_require__(91459), {getUsedModuleIdsAndModules} = __webpack_require__(89945), plugin = "SyncModuleIdsPlugin";
module.exports = class {
constructor({path, context, test, mode}) {
this._path = path, this._context = context, this._test = test || (() => !0);
const readAndWrite = !mode || "merge" === mode || "update" === mode;
this._read = readAndWrite || "read" === mode, this._write = readAndWrite || "create" === mode, 
this._prune = "update" === mode;
}
apply(compiler) {
let data, dataChanged = !1;
this._read && compiler.hooks.readRecords.tapAsync(plugin, (callback => {
compiler.intermediateFileSystem.readFile(this._path, ((err, buffer) => {
if (err) return "ENOENT" !== err.code ? callback(err) : callback();
const json = JSON.parse(buffer.toString());
data = new Map;
for (const key of Object.keys(json)) data.set(key, json[key]);
return dataChanged = !1, callback();
}));
})), this._write && compiler.hooks.emitRecords.tapAsync(plugin, (callback => {
if (!data || !dataChanged) return callback();
const json = {}, sorted = Array.from(data).sort((([a], [b]) => a < b ? -1 : 1));
for (const [key, value] of sorted) json[key] = value;
compiler.intermediateFileSystem.writeFile(this._path, JSON.stringify(json), callback);
})), compiler.hooks.thisCompilation.tap(plugin, (compilation => {
const associatedObjectForCache = compiler.root, context = this._context || compiler.context;
this._read && compilation.hooks.reviveModules.tap(plugin, ((_1, _2) => {
if (!data) return;
const {chunkGraph} = compilation, [usedIds, modules] = getUsedModuleIdsAndModules(compilation, this._test);
for (const module of modules) {
const name = module.libIdent({
context,
associatedObjectForCache
});
if (!name) continue;
const id = data.get(name), idAsString = `${id}`;
if (usedIds.has(idAsString)) {
const err = new WebpackError(`SyncModuleIdsPlugin: Unable to restore id '${id}' from '${this._path}' as it's already used.`);
err.module = module, compilation.errors.push(err);
}
chunkGraph.setModuleId(module, id), usedIds.add(idAsString);
}
})), this._write && compilation.hooks.recordModules.tap(plugin, (modules => {
const {chunkGraph} = compilation;
let oldData = data;
oldData ? this._prune && (data = new Map) : oldData = data = new Map;
for (const module of modules) if (this._test(module)) {
const name = module.libIdent({
context,
associatedObjectForCache
});
if (!name) continue;
const id = chunkGraph.getModuleId(module);
if (null === id) continue;
if (oldData.get(name) !== id) dataChanged = !0; else if (data === oldData) continue;
data.set(name, id);
}
data.size !== oldData.size && (dataChanged = !0);
}));
}));
}
};
},
33978: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, PrefixSource, RawSource} = __webpack_require__(37946), {RuntimeGlobals} = __webpack_require__(91459), HotUpdateChunk = __webpack_require__(6902), Template = __webpack_require__(88370), {getCompilationHooks} = __webpack_require__(18362), {generateEntryStartup, updateHashForEntryStartup} = __webpack_require__(19202);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("ArrayPushCallbackChunkFormatPlugin", (compilation => {
compilation.hooks.additionalChunkRuntimeRequirements.tap("ArrayPushCallbackChunkFormatPlugin", ((chunk, set, {chunkGraph}) => {
chunk.hasRuntime() || (chunkGraph.getNumberOfEntryModules(chunk) > 0 && (set.add(RuntimeGlobals.onChunksLoaded), 
set.add(RuntimeGlobals.require)), set.add(RuntimeGlobals.chunkCallback));
}));
const hooks = getCompilationHooks(compilation);
hooks.renderChunk.tap("ArrayPushCallbackChunkFormatPlugin", ((modules, renderContext) => {
const {chunk, chunkGraph, runtimeTemplate} = renderContext, hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null, globalObject = runtimeTemplate.globalObject, source = new ConcatSource, runtimeModules = chunkGraph.getChunkRuntimeModulesInOrder(chunk);
if (hotUpdateChunk) {
const hotUpdateGlobal = runtimeTemplate.outputOptions.hotUpdateGlobal;
if (source.add(`${globalObject}[${JSON.stringify(hotUpdateGlobal)}](`), source.add(`${JSON.stringify(chunk.id)},`), 
source.add(modules), runtimeModules.length > 0) {
source.add(",\n");
const runtimePart = Template.renderChunkRuntimeModules(runtimeModules, renderContext);
source.add(runtimePart);
}
source.add(")");
} else {
const chunkLoadingGlobal = runtimeTemplate.outputOptions.chunkLoadingGlobal;
source.add(`(${globalObject}[${JSON.stringify(chunkLoadingGlobal)}] = ${globalObject}[${JSON.stringify(chunkLoadingGlobal)}] || []).push([`), 
source.add(`${JSON.stringify(chunk.ids)},`), source.add(modules);
const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));
if (runtimeModules.length > 0 || entries.length > 0) {
const runtime = new ConcatSource((runtimeTemplate.supportsArrowFunction() ? "__webpack_require__ =>" : "function(__webpack_require__)") + " { // webpackRuntimeModules\n");
if (runtimeModules.length > 0 && runtime.add(Template.renderRuntimeModules(runtimeModules, {
...renderContext,
codeGenerationResults: compilation.codeGenerationResults
})), entries.length > 0) {
const startupSource = new RawSource(generateEntryStartup(chunkGraph, runtimeTemplate, entries, chunk, !0));
runtime.add(hooks.renderStartup.call(startupSource, entries[entries.length - 1][0], {
...renderContext,
inlined: !1
})), chunkGraph.getChunkRuntimeRequirements(chunk).has(RuntimeGlobals.returnExportsFromRuntime) && runtime.add("return __webpack_exports__;\n");
}
runtime.add("}\n"), source.add(",\n"), source.add(new PrefixSource("/******/ ", runtime));
}
source.add("])");
}
return source;
})), hooks.chunkHash.tap("ArrayPushCallbackChunkFormatPlugin", ((chunk, hash, {chunkGraph, runtimeTemplate}) => {
if (chunk.hasRuntime()) return;
hash.update(`ArrayPushCallbackChunkFormatPlugin1${runtimeTemplate.outputOptions.chunkLoadingGlobal}${runtimeTemplate.outputOptions.hotUpdateGlobal}${runtimeTemplate.globalObject}`);
const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));
updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
}));
}));
}
};
},
47789: module => {
"use strict";
class BasicEvaluatedExpression {
constructor() {
this.type = 0, this.range = void 0, this.falsy = !1, this.truthy = !1, this.nullish = void 0, 
this.sideEffects = !0, this.bool = void 0, this.number = void 0, this.bigint = void 0, 
this.regExp = void 0, this.string = void 0, this.quasis = void 0, this.parts = void 0, 
this.array = void 0, this.items = void 0, this.options = void 0, this.prefix = void 0, 
this.postfix = void 0, this.wrappedInnerExpressions = void 0, this.identifier = void 0, 
this.rootInfo = void 0, this.getMembers = void 0, this.getMembersOptionals = void 0, 
this.expression = void 0;
}
isUnknown() {
return 0 === this.type;
}
isNull() {
return 2 === this.type;
}
isUndefined() {
return 1 === this.type;
}
isString() {
return 3 === this.type;
}
isNumber() {
return 4 === this.type;
}
isBigInt() {
return 13 === this.type;
}
isBoolean() {
return 5 === this.type;
}
isRegExp() {
return 6 === this.type;
}
isConditional() {
return 7 === this.type;
}
isArray() {
return 8 === this.type;
}
isConstArray() {
return 9 === this.type;
}
isIdentifier() {
return 10 === this.type;
}
isWrapped() {
return 11 === this.type;
}
isTemplateString() {
return 12 === this.type;
}
isPrimitiveType() {
switch (this.type) {
case 1:
case 2:
case 3:
case 4:
case 5:
case 13:
case 11:
case 12:
return !0;

case 6:
case 8:
case 9:
return !1;

default:
return;
}
}
isCompileTimeValue() {
switch (this.type) {
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 9:
case 13:
return !0;

default:
return !1;
}
}
asCompileTimeValue() {
switch (this.type) {
case 1:
return;

case 2:
return null;

case 3:
return this.string;

case 4:
return this.number;

case 5:
return this.bool;

case 6:
return this.regExp;

case 9:
return this.array;

case 13:
return this.bigint;

default:
throw new Error("asCompileTimeValue must only be called for compile-time values");
}
}
isTruthy() {
return this.truthy;
}
isFalsy() {
return this.falsy;
}
isNullish() {
return this.nullish;
}
couldHaveSideEffects() {
return this.sideEffects;
}
asBool() {
if (this.truthy) return !0;
if (this.falsy || this.nullish) return !1;
if (this.isBoolean()) return this.bool;
if (this.isNull()) return !1;
if (this.isUndefined()) return !1;
if (this.isString()) return "" !== this.string;
if (this.isNumber()) return 0 !== this.number;
if (this.isBigInt()) return this.bigint !== BigInt(0);
if (this.isRegExp()) return !0;
if (this.isArray()) return !0;
if (this.isConstArray()) return !0;
if (this.isWrapped()) return !!(this.prefix && this.prefix.asBool() || this.postfix && this.postfix.asBool()) || void 0;
if (this.isTemplateString()) {
const str = this.asString();
if ("string" == typeof str) return "" !== str;
}
}
asNullish() {
const nullish = this.isNullish();
return !(!0 !== nullish && !this.isNull() && !this.isUndefined()) || !1 !== nullish && (!this.isTruthy() && (!this.isBoolean() && (!this.isString() && (!this.isNumber() && (!this.isBigInt() && (!this.isRegExp() && (!this.isArray() && (!this.isConstArray() && (!this.isTemplateString() && (!this.isRegExp() && void 0))))))))));
}
asString() {
if (this.isBoolean()) return `${this.bool}`;
if (this.isNull()) return "null";
if (this.isUndefined()) return "undefined";
if (this.isString()) return this.string;
if (this.isNumber()) return `${this.number}`;
if (this.isBigInt()) return `${this.bigint}`;
if (this.isRegExp()) return `${this.regExp}`;
if (this.isArray()) {
let array = [];
for (const item of this.items) {
const itemStr = item.asString();
if (void 0 === itemStr) return;
array.push(itemStr);
}
return `${array}`;
}
if (this.isConstArray()) return `${this.array}`;
if (this.isTemplateString()) {
let str = "";
for (const part of this.parts) {
const partStr = part.asString();
if (void 0 === partStr) return;
str += partStr;
}
return str;
}
}
setString(string) {
return this.type = 3, this.string = string, this.sideEffects = !1, this;
}
setUndefined() {
return this.type = 1, this.sideEffects = !1, this;
}
setNull() {
return this.type = 2, this.sideEffects = !1, this;
}
setNumber(number) {
return this.type = 4, this.number = number, this.sideEffects = !1, this;
}
setBigInt(bigint) {
return this.type = 13, this.bigint = bigint, this.sideEffects = !1, this;
}
setBoolean(bool) {
return this.type = 5, this.bool = bool, this.sideEffects = !1, this;
}
setRegExp(regExp) {
return this.type = 6, this.regExp = regExp, this.sideEffects = !1, this;
}
setIdentifier(identifier, rootInfo, getMembers, getMembersOptionals) {
return this.type = 10, this.identifier = identifier, this.rootInfo = rootInfo, this.getMembers = getMembers, 
this.getMembersOptionals = getMembersOptionals, this.sideEffects = !0, this;
}
setWrapped(prefix, postfix, innerExpressions) {
return this.type = 11, this.prefix = prefix, this.postfix = postfix, this.wrappedInnerExpressions = innerExpressions, 
this.sideEffects = !0, this;
}
setOptions(options) {
return this.type = 7, this.options = options, this.sideEffects = !0, this;
}
addOptions(options) {
this.options || (this.type = 7, this.options = [], this.sideEffects = !0);
for (const item of options) this.options.push(item);
return this;
}
setItems(items) {
return this.type = 8, this.items = items, this.sideEffects = items.some((i => i.couldHaveSideEffects())), 
this;
}
setArray(array) {
return this.type = 9, this.array = array, this.sideEffects = !1, this;
}
setTemplateString(quasis, parts, kind) {
return this.type = 12, this.quasis = quasis, this.parts = parts, this.templateStringKind = kind, 
this.sideEffects = parts.some((p => p.sideEffects)), this;
}
setTruthy() {
return this.falsy = !1, this.truthy = !0, this.nullish = !1, this;
}
setFalsy() {
return this.falsy = !0, this.truthy = !1, this;
}
setNullish(value) {
return this.nullish = value, value ? this.setFalsy() : this;
}
setRange(range) {
return this.range = range, this;
}
setSideEffects(sideEffects = !0) {
return this.sideEffects = sideEffects, this;
}
setExpression(expression) {
return this.expression = expression, this;
}
}
BasicEvaluatedExpression.isValidRegExpFlags = flags => {
const len = flags.length;
if (0 === len) return !0;
if (len > 4) return !1;
let remaining = 0;
for (let i = 0; i < len; i++) switch (flags.charCodeAt(i)) {
case 103:
if (8 & remaining) return !1;
remaining |= 8;
break;

case 105:
if (4 & remaining) return !1;
remaining |= 4;
break;

case 109:
if (2 & remaining) return !1;
remaining |= 2;
break;

case 121:
if (1 & remaining) return !1;
remaining |= 1;
break;

default:
return !1;
}
return !0;
}, module.exports = BasicEvaluatedExpression;
},
92535: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const Entrypoint = __webpack_require__(7807);
exports.getAllChunks = (entrypoint, excludedChunk1, excludedChunk2) => {
const queue = new Set([ entrypoint ]), chunks = new Set;
for (const entrypoint of queue) {
for (const chunk of entrypoint.chunks) chunk !== excludedChunk1 && chunk !== excludedChunk2 && chunks.add(chunk);
for (const parent of entrypoint.parentsIterable) parent instanceof Entrypoint && queue.add(parent);
}
return chunks;
};
},
39074: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, RawSource} = __webpack_require__(37946), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), {getChunkFilenameTemplate, getCompilationHooks} = __webpack_require__(18362), {generateEntryStartup, updateHashForEntryStartup} = __webpack_require__(19202);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("CommonJsChunkFormatPlugin", (compilation => {
compilation.hooks.additionalChunkRuntimeRequirements.tap("CommonJsChunkLoadingPlugin", ((chunk, set, {chunkGraph}) => {
chunk.hasRuntime() || chunkGraph.getNumberOfEntryModules(chunk) > 0 && (set.add(RuntimeGlobals.require), 
set.add(RuntimeGlobals.startupEntrypoint), set.add(RuntimeGlobals.externalInstallChunk));
}));
const hooks = getCompilationHooks(compilation);
hooks.renderChunk.tap("CommonJsChunkFormatPlugin", ((modules, renderContext) => {
const {chunk, chunkGraph, runtimeTemplate} = renderContext, source = new ConcatSource;
source.add(`exports.id = ${JSON.stringify(chunk.id)};\n`), source.add(`exports.ids = ${JSON.stringify(chunk.ids)};\n`), 
source.add("exports.modules = "), source.add(modules), source.add(";\n");
const runtimeModules = chunkGraph.getChunkRuntimeModulesInOrder(chunk);
runtimeModules.length > 0 && (source.add("exports.runtime =\n"), source.add(Template.renderChunkRuntimeModules(runtimeModules, renderContext)));
const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));
if (entries.length > 0) {
const runtimeChunk = entries[0][1].getRuntimeChunk(), currentOutputName = compilation.getPath(getChunkFilenameTemplate(chunk, compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}).split("/"), runtimeOutputName = compilation.getPath(getChunkFilenameTemplate(runtimeChunk, compilation.outputOptions), {
chunk: runtimeChunk,
contentHashType: "javascript"
}).split("/");
for (currentOutputName.pop(); currentOutputName.length > 0 && runtimeOutputName.length > 0 && currentOutputName[0] === runtimeOutputName[0]; ) currentOutputName.shift(), 
runtimeOutputName.shift();
const runtimePath = (currentOutputName.length > 0 ? "../".repeat(currentOutputName.length) : "./") + runtimeOutputName.join("/"), entrySource = new ConcatSource;
entrySource.add(`(${runtimeTemplate.supportsArrowFunction() ? "() => " : "function() "}{\n`), 
entrySource.add("var exports = {};\n"), entrySource.add(source), entrySource.add(";\n\n// load runtime\n"), 
entrySource.add(`var __webpack_require__ = require(${JSON.stringify(runtimePath)});\n`), 
entrySource.add(`${RuntimeGlobals.externalInstallChunk}(exports);\n`);
const startupSource = new RawSource(generateEntryStartup(chunkGraph, runtimeTemplate, entries, chunk, !1));
return entrySource.add(hooks.renderStartup.call(startupSource, entries[entries.length - 1][0], {
...renderContext,
inlined: !1
})), entrySource.add("\n})()"), entrySource;
}
return source;
})), hooks.chunkHash.tap("CommonJsChunkFormatPlugin", ((chunk, hash, {chunkGraph}) => {
if (chunk.hasRuntime()) return;
hash.update("CommonJsChunkFormatPlugin"), hash.update("1");
const entries = Array.from(chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk));
updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
}));
}));
}
};
},
64027: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const enabledTypes = new WeakMap, getEnabledTypes = compiler => {
let set = enabledTypes.get(compiler);
return void 0 === set && (set = new Set, enabledTypes.set(compiler, set)), set;
};
module.exports = class {
constructor(type) {
this.type = type;
}
static setEnabled(compiler, type) {
getEnabledTypes(compiler).add(type);
}
static checkEnabled(compiler, type) {
if (!getEnabledTypes(compiler).has(type)) throw new Error(`Chunk loading type "${type}" is not enabled. EnableChunkLoadingPlugin need to be used to enable this type of chunk loading. This usually happens through the "output.enabledChunkLoadingTypes" option. If you are using a function as entry which sets "chunkLoading", you need to add all potential chunk loading types to "output.enabledChunkLoadingTypes". These types are enabled: ` + Array.from(getEnabledTypes(compiler)).join(", "));
}
apply(compiler) {
const {type} = this, enabled = getEnabledTypes(compiler);
if (!enabled.has(type) && (enabled.add(type), "string" == typeof type)) switch (type) {
case "jsonp":
(new (__webpack_require__(31333))).apply(compiler);
break;

case "import-scripts":
(new (__webpack_require__(80594))).apply(compiler);
break;

case "require":
new (__webpack_require__(69155))({
asyncChunkLoading: !1
}).apply(compiler);
break;

case "async-node":
new (__webpack_require__(69155))({
asyncChunkLoading: !0
}).apply(compiler);
break;

case "import":
(new (__webpack_require__(86440))).apply(compiler);
break;

case "universal":
throw new Error("Universal Chunk Loading is not implemented yet");

default:
throw new Error(`Unsupported chunk loading type ${type}.\nPlugins which provide custom chunk loading types must call EnableChunkLoadingPlugin.setEnabled(compiler, type) to disable this error.`);
}
}
};
},
69784: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), {RawSource, ReplaceSource} = __webpack_require__(37946), Generator = __webpack_require__(70607), InitFragment = __webpack_require__(95328), HarmonyCompatibilityDependency = __webpack_require__(35285), deprecatedGetInitFragments = util.deprecate(((template, dependency, templateContext) => template.getInitFragments(dependency, templateContext)), "DependencyTemplate.getInitFragment is deprecated (use apply(dep, source, { initFragments }) instead)", "DEP_WEBPACK_JAVASCRIPT_GENERATOR_GET_INIT_FRAGMENTS"), TYPES = new Set([ "javascript" ]);
module.exports = class extends Generator {
getTypes(module) {
return TYPES;
}
getSize(module, type) {
const originalSource = module.originalSource();
return originalSource ? originalSource.size() : 39;
}
getConcatenationBailoutReason(module, context) {
return module.buildMeta && "namespace" === module.buildMeta.exportsType && void 0 !== module.presentationalDependencies && module.presentationalDependencies.some((d => d instanceof HarmonyCompatibilityDependency)) ? module.buildInfo && module.buildInfo.moduleConcatenationBailout ? `Module uses ${module.buildInfo.moduleConcatenationBailout}` : void 0 : "Module is not an ECMAScript module";
}
generate(module, generateContext) {
const originalSource = module.originalSource();
if (!originalSource) return new RawSource("throw new Error('No source available');");
const source = new ReplaceSource(originalSource), initFragments = [];
return this.sourceModule(module, initFragments, source, generateContext), InitFragment.addToSource(source, initFragments, generateContext);
}
sourceModule(module, initFragments, source, generateContext) {
for (const dependency of module.dependencies) this.sourceDependency(module, dependency, initFragments, source, generateContext);
if (void 0 !== module.presentationalDependencies) for (const dependency of module.presentationalDependencies) this.sourceDependency(module, dependency, initFragments, source, generateContext);
for (const childBlock of module.blocks) this.sourceBlock(module, childBlock, initFragments, source, generateContext);
}
sourceBlock(module, block, initFragments, source, generateContext) {
for (const dependency of block.dependencies) this.sourceDependency(module, dependency, initFragments, source, generateContext);
for (const childBlock of block.blocks) this.sourceBlock(module, childBlock, initFragments, source, generateContext);
}
sourceDependency(module, dependency, initFragments, source, generateContext) {
const constructor = dependency.constructor, template = generateContext.dependencyTemplates.get(constructor);
if (!template) throw new Error("No template for dependency: " + dependency.constructor.name);
const templateContext = {
runtimeTemplate: generateContext.runtimeTemplate,
dependencyTemplates: generateContext.dependencyTemplates,
moduleGraph: generateContext.moduleGraph,
chunkGraph: generateContext.chunkGraph,
module,
runtime: generateContext.runtime,
runtimeRequirements: generateContext.runtimeRequirements,
concatenationScope: generateContext.concatenationScope,
codeGenerationResults: generateContext.codeGenerationResults,
initFragments
};
if (template.apply(dependency, source, templateContext), "getInitFragments" in template) {
const fragments = deprecatedGetInitFragments(template, dependency, templateContext);
if (fragments) for (const fragment of fragments) initFragments.push(fragment);
}
}
};
},
18362: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook, SyncHook, SyncBailHook} = __webpack_require__(89991), vm = __webpack_require__(26144), {ConcatSource, OriginalSource, PrefixSource, RawSource, CachedSource} = __webpack_require__(37946), Compilation = __webpack_require__(62843), {tryRunOrWebpackError} = __webpack_require__(44741), HotUpdateChunk = __webpack_require__(6902), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), {last, someInIterable} = __webpack_require__(30416), StringXor = __webpack_require__(81664), {compareModulesByIdentifier} = __webpack_require__(40028), createHash = __webpack_require__(27466), nonNumericOnlyHash = __webpack_require__(23388), {intersectRuntime} = __webpack_require__(14372), JavascriptGenerator = __webpack_require__(69784), JavascriptParser = __webpack_require__(36793), chunkHasJs = (chunk, chunkGraph) => chunkGraph.getNumberOfEntryModules(chunk) > 0 || !!chunkGraph.getChunkModulesIterableBySourceType(chunk, "javascript"), printGeneratedCodeForStack = (module, code) => {
const lines = code.split("\n"), n = `${lines.length}`.length;
return `\n\nGenerated code for ${module.identifier()}\n${lines.map(((line, i, lines) => {
const iStr = `${i + 1}`;
return `${" ".repeat(n - iStr.length)}${iStr} | ${line}`;
})).join("\n")}`;
}, compilationHooksMap = new WeakMap;
class JavascriptModulesPlugin {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
renderModuleContent: new SyncWaterfallHook([ "source", "module", "renderContext" ]),
renderModuleContainer: new SyncWaterfallHook([ "source", "module", "renderContext" ]),
renderModulePackage: new SyncWaterfallHook([ "source", "module", "renderContext" ]),
render: new SyncWaterfallHook([ "source", "renderContext" ]),
renderContent: new SyncWaterfallHook([ "source", "renderContext" ]),
renderStartup: new SyncWaterfallHook([ "source", "module", "startupRenderContext" ]),
renderChunk: new SyncWaterfallHook([ "source", "renderContext" ]),
renderMain: new SyncWaterfallHook([ "source", "renderContext" ]),
renderRequire: new SyncWaterfallHook([ "code", "renderContext" ]),
inlineInRuntimeBailout: new SyncBailHook([ "module", "renderContext" ]),
embedInRuntimeBailout: new SyncBailHook([ "module", "renderContext" ]),
strictRuntimeBailout: new SyncBailHook([ "renderContext" ]),
chunkHash: new SyncHook([ "chunk", "hash", "context" ]),
useSourceMap: new SyncBailHook([ "chunk", "renderContext" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(options = {}) {
this.options = options, this._moduleFactoryCache = new WeakMap;
}
apply(compiler) {
compiler.hooks.compilation.tap("JavascriptModulesPlugin", ((compilation, {normalModuleFactory}) => {
const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
normalModuleFactory.hooks.createParser.for("javascript/auto").tap("JavascriptModulesPlugin", (options => new JavascriptParser("auto"))), 
normalModuleFactory.hooks.createParser.for("javascript/dynamic").tap("JavascriptModulesPlugin", (options => new JavascriptParser("script"))), 
normalModuleFactory.hooks.createParser.for("javascript/esm").tap("JavascriptModulesPlugin", (options => new JavascriptParser("module"))), 
normalModuleFactory.hooks.createGenerator.for("javascript/auto").tap("JavascriptModulesPlugin", (() => new JavascriptGenerator)), 
normalModuleFactory.hooks.createGenerator.for("javascript/dynamic").tap("JavascriptModulesPlugin", (() => new JavascriptGenerator)), 
normalModuleFactory.hooks.createGenerator.for("javascript/esm").tap("JavascriptModulesPlugin", (() => new JavascriptGenerator)), 
compilation.hooks.renderManifest.tap("JavascriptModulesPlugin", ((result, options) => {
const {hash, chunk, chunkGraph, moduleGraph, runtimeTemplate, dependencyTemplates, outputOptions, codeGenerationResults} = options, hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null;
let render;
const filenameTemplate = JavascriptModulesPlugin.getChunkFilenameTemplate(chunk, outputOptions);
if (hotUpdateChunk) render = () => this.renderChunk({
chunk,
dependencyTemplates,
runtimeTemplate,
moduleGraph,
chunkGraph,
codeGenerationResults,
strictMode: runtimeTemplate.isModule()
}, hooks); else if (chunk.hasRuntime()) render = () => this.renderMain({
hash,
chunk,
dependencyTemplates,
runtimeTemplate,
moduleGraph,
chunkGraph,
codeGenerationResults,
strictMode: runtimeTemplate.isModule()
}, hooks, compilation); else {
if (!chunkHasJs(chunk, chunkGraph)) return result;
render = () => this.renderChunk({
chunk,
dependencyTemplates,
runtimeTemplate,
moduleGraph,
chunkGraph,
codeGenerationResults,
strictMode: runtimeTemplate.isModule()
}, hooks);
}
return result.push({
render,
filenameTemplate,
pathOptions: {
hash,
runtime: chunk.runtime,
chunk,
contentHashType: "javascript"
},
info: {
javascriptModule: compilation.runtimeTemplate.isModule()
},
identifier: hotUpdateChunk ? `hotupdatechunk${chunk.id}` : `chunk${chunk.id}`,
hash: chunk.contentHash.javascript
}), result;
})), compilation.hooks.chunkHash.tap("JavascriptModulesPlugin", ((chunk, hash, context) => {
hooks.chunkHash.call(chunk, hash, context), chunk.hasRuntime() && this.updateHashWithBootstrap(hash, {
hash: "0000",
chunk,
codeGenerationResults: context.codeGenerationResults,
chunkGraph: context.chunkGraph,
moduleGraph: context.moduleGraph,
runtimeTemplate: context.runtimeTemplate
}, hooks);
})), compilation.hooks.contentHash.tap("JavascriptModulesPlugin", (chunk => {
const {chunkGraph, codeGenerationResults, moduleGraph, runtimeTemplate, outputOptions: {hashSalt, hashDigest, hashDigestLength, hashFunction}} = compilation, hash = createHash(hashFunction);
hashSalt && hash.update(hashSalt), chunk.hasRuntime() ? this.updateHashWithBootstrap(hash, {
hash: "0000",
chunk,
codeGenerationResults,
chunkGraph: compilation.chunkGraph,
moduleGraph: compilation.moduleGraph,
runtimeTemplate: compilation.runtimeTemplate
}, hooks) : (hash.update(`${chunk.id} `), hash.update(chunk.ids ? chunk.ids.join(",") : "")), 
hooks.chunkHash.call(chunk, hash, {
chunkGraph,
codeGenerationResults,
moduleGraph,
runtimeTemplate
});
const modules = chunkGraph.getChunkModulesIterableBySourceType(chunk, "javascript");
if (modules) {
const xor = new StringXor;
for (const m of modules) xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
xor.updateHash(hash);
}
const runtimeModules = chunkGraph.getChunkModulesIterableBySourceType(chunk, "runtime");
if (runtimeModules) {
const xor = new StringXor;
for (const m of runtimeModules) xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
xor.updateHash(hash);
}
const digest = hash.digest(hashDigest);
chunk.contentHash.javascript = nonNumericOnlyHash(digest, hashDigestLength);
})), compilation.hooks.additionalTreeRuntimeRequirements.tap("JavascriptModulesPlugin", ((chunk, set, {chunkGraph}) => {
!set.has(RuntimeGlobals.startupNoDefault) && chunkGraph.hasChunkEntryDependentChunks(chunk) && (set.add(RuntimeGlobals.onChunksLoaded), 
set.add(RuntimeGlobals.require));
})), compilation.hooks.executeModule.tap("JavascriptModulesPlugin", ((options, context) => {
const source = options.codeGenerationResult.sources.get("javascript");
if (void 0 === source) return;
const {module, moduleObject} = options, code = source.source(), fn = vm.runInThisContext(`(function(${module.moduleArgument}, ${module.exportsArgument}, __webpack_require__) {\n${code}\n/**/})`, {
filename: module.identifier(),
lineOffset: -1
});
try {
fn.call(moduleObject.exports, moduleObject, moduleObject.exports, context.__webpack_require__);
} catch (e) {
throw e.stack += printGeneratedCodeForStack(options.module, code), e;
}
})), compilation.hooks.executeModule.tap("JavascriptModulesPlugin", ((options, context) => {
const source = options.codeGenerationResult.sources.get("runtime");
if (void 0 === source) return;
let code = source.source();
"string" != typeof code && (code = code.toString());
const fn = vm.runInThisContext(`(function(__webpack_require__) {\n${code}\n/**/})`, {
filename: options.module.identifier(),
lineOffset: -1
});
try {
fn.call(null, context.__webpack_require__);
} catch (e) {
throw e.stack += printGeneratedCodeForStack(options.module, code), e;
}
}));
}));
}
static getChunkFilenameTemplate(chunk, outputOptions) {
return chunk.filenameTemplate ? chunk.filenameTemplate : chunk instanceof HotUpdateChunk ? outputOptions.hotUpdateChunkFilename : chunk.canBeInitial() ? outputOptions.filename : outputOptions.chunkFilename;
}
renderModule(module, renderContext, hooks, factory) {
const {chunk, chunkGraph, runtimeTemplate, codeGenerationResults, strictMode} = renderContext;
try {
const codeGenResult = codeGenerationResults.get(module, chunk.runtime), moduleSource = codeGenResult.sources.get("javascript");
if (!moduleSource) return null;
if (void 0 !== codeGenResult.data) {
const chunkInitFragments = codeGenResult.data.get("chunkInitFragments");
if (chunkInitFragments) for (const i of chunkInitFragments) renderContext.chunkInitFragments.push(i);
}
const moduleSourcePostContent = tryRunOrWebpackError((() => hooks.renderModuleContent.call(moduleSource, module, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderModuleContent");
let moduleSourcePostContainer;
if (factory) {
const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(module, chunk.runtime), needModule = runtimeRequirements.has(RuntimeGlobals.module), needExports = runtimeRequirements.has(RuntimeGlobals.exports), needRequire = runtimeRequirements.has(RuntimeGlobals.require) || runtimeRequirements.has(RuntimeGlobals.requireScope), needThisAsExports = runtimeRequirements.has(RuntimeGlobals.thisAsExports), needStrict = module.buildInfo.strict && !strictMode, cacheEntry = this._moduleFactoryCache.get(moduleSourcePostContent);
let source;
if (cacheEntry && cacheEntry.needModule === needModule && cacheEntry.needExports === needExports && cacheEntry.needRequire === needRequire && cacheEntry.needThisAsExports === needThisAsExports && cacheEntry.needStrict === needStrict) source = cacheEntry.source; else {
const factorySource = new ConcatSource, args = [];
(needExports || needRequire || needModule) && args.push(needModule ? module.moduleArgument : "__unused_webpack_" + module.moduleArgument), 
(needExports || needRequire) && args.push(needExports ? module.exportsArgument : "__unused_webpack_" + module.exportsArgument), 
needRequire && args.push("__webpack_require__"), !needThisAsExports && runtimeTemplate.supportsArrowFunction() ? factorySource.add("/***/ ((" + args.join(", ") + ") => {\n\n") : factorySource.add("/***/ (function(" + args.join(", ") + ") {\n\n"), 
needStrict && factorySource.add('"use strict";\n'), factorySource.add(moduleSourcePostContent), 
factorySource.add("\n\n/***/ })"), source = new CachedSource(factorySource), this._moduleFactoryCache.set(moduleSourcePostContent, {
source,
needModule,
needExports,
needRequire,
needThisAsExports,
needStrict
});
}
moduleSourcePostContainer = tryRunOrWebpackError((() => hooks.renderModuleContainer.call(source, module, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer");
} else moduleSourcePostContainer = moduleSourcePostContent;
return tryRunOrWebpackError((() => hooks.renderModulePackage.call(moduleSourcePostContainer, module, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderModulePackage");
} catch (e) {
throw e.module = module, e;
}
}
renderChunk(renderContext, hooks) {
const {chunk, chunkGraph} = renderContext, modules = chunkGraph.getOrderedChunkModulesIterableBySourceType(chunk, "javascript", compareModulesByIdentifier), allModules = modules ? Array.from(modules) : [];
let strictHeader, allStrict = renderContext.strictMode;
if (!allStrict && allModules.every((m => m.buildInfo.strict))) {
const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
strictHeader = strictBailout ? `// runtime can't be in strict mode because ${strictBailout}.\n` : '"use strict";\n', 
strictBailout || (allStrict = !0);
}
const chunkRenderContext = {
...renderContext,
chunkInitFragments: [],
strictMode: allStrict
}, moduleSources = Template.renderChunkModules(chunkRenderContext, allModules, (module => this.renderModule(module, chunkRenderContext, hooks, !0))) || new RawSource("{}");
let source = tryRunOrWebpackError((() => hooks.renderChunk.call(moduleSources, chunkRenderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderChunk");
if (source = tryRunOrWebpackError((() => hooks.renderContent.call(source, chunkRenderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderContent"), 
!source) throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something");
if (source = InitFragment.addToSource(source, chunkRenderContext.chunkInitFragments, chunkRenderContext), 
source = tryRunOrWebpackError((() => hooks.render.call(source, chunkRenderContext)), "JavascriptModulesPlugin.getCompilationHooks().render"), 
!source) throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something");
return chunk.rendered = !0, strictHeader ? new ConcatSource(strictHeader, source, ";") : renderContext.runtimeTemplate.isModule() ? source : new ConcatSource(source, ";");
}
renderMain(renderContext, hooks, compilation) {
const {chunk, chunkGraph, runtimeTemplate} = renderContext, runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk), iife = runtimeTemplate.isIIFE(), bootstrap = this.renderBootstrap(renderContext, hooks), useSourceMap = hooks.useSourceMap.call(chunk, renderContext), allModules = Array.from(chunkGraph.getOrderedChunkModulesIterableBySourceType(chunk, "javascript", compareModulesByIdentifier) || []), hasEntryModules = chunkGraph.getNumberOfEntryModules(chunk) > 0;
let inlinedModules;
bootstrap.allowInlineStartup && hasEntryModules && (inlinedModules = new Set(chunkGraph.getChunkEntryModulesIterable(chunk)));
let prefix, source = new ConcatSource;
iife ? (runtimeTemplate.supportsArrowFunction() ? source.add("/******/ (() => { // webpackBootstrap\n") : source.add("/******/ (function() { // webpackBootstrap\n"), 
prefix = "/******/ \t") : prefix = "/******/ ";
let allStrict = renderContext.strictMode;
if (!allStrict && allModules.every((m => m.buildInfo.strict))) {
const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
strictBailout ? source.add(prefix + `// runtime can't be in strict mode because ${strictBailout}.\n`) : (allStrict = !0, 
source.add(prefix + '"use strict";\n'));
}
const chunkRenderContext = {
...renderContext,
chunkInitFragments: [],
strictMode: allStrict
}, chunkModules = Template.renderChunkModules(chunkRenderContext, inlinedModules ? allModules.filter((m => !inlinedModules.has(m))) : allModules, (module => this.renderModule(module, chunkRenderContext, hooks, !0)), prefix);
if ((chunkModules || runtimeRequirements.has(RuntimeGlobals.moduleFactories) || runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly) || runtimeRequirements.has(RuntimeGlobals.require)) && (source.add(prefix + "var __webpack_modules__ = ("), 
source.add(chunkModules || "{}"), source.add(");\n"), source.add("/************************************************************************/\n")), 
bootstrap.header.length > 0) {
const header = Template.asString(bootstrap.header) + "\n";
source.add(new PrefixSource(prefix, useSourceMap ? new OriginalSource(header, "webpack/bootstrap") : new RawSource(header))), 
source.add("/************************************************************************/\n");
}
const runtimeModules = renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);
if (runtimeModules.length > 0) {
source.add(new PrefixSource(prefix, Template.renderRuntimeModules(runtimeModules, chunkRenderContext))), 
source.add("/************************************************************************/\n");
for (const module of runtimeModules) compilation.codeGeneratedModules.add(module);
}
if (inlinedModules) {
if (bootstrap.beforeStartup.length > 0) {
const beforeStartup = Template.asString(bootstrap.beforeStartup) + "\n";
source.add(new PrefixSource(prefix, useSourceMap ? new OriginalSource(beforeStartup, "webpack/before-startup") : new RawSource(beforeStartup)));
}
const lastInlinedModule = last(inlinedModules), startupSource = new ConcatSource;
startupSource.add("var __webpack_exports__ = {};\n");
for (const m of inlinedModules) {
const renderedModule = this.renderModule(m, chunkRenderContext, hooks, !1);
if (renderedModule) {
const innerStrict = !allStrict && m.buildInfo.strict, exports = chunkGraph.getModuleRuntimeRequirements(m, chunk.runtime).has(RuntimeGlobals.exports), webpackExports = exports && "__webpack_exports__" === m.exportsArgument;
let footer, iife = innerStrict ? "it need to be in strict mode." : inlinedModules.size > 1 ? "it need to be isolated against other entry modules." : chunkModules ? "it need to be isolated against other modules in the chunk." : exports && !webpackExports ? `it uses a non-standard name for the exports (${m.exportsArgument}).` : hooks.embedInRuntimeBailout.call(m, renderContext);
if (void 0 !== iife) {
startupSource.add(`// This entry need to be wrapped in an IIFE because ${iife}\n`);
runtimeTemplate.supportsArrowFunction() ? (startupSource.add("(() => {\n"), footer = "\n})();\n\n") : (startupSource.add("!function() {\n"), 
footer = "\n}();\n"), innerStrict && startupSource.add('"use strict";\n');
} else footer = "\n";
exports && (m !== lastInlinedModule ? startupSource.add(`var ${m.exportsArgument} = {};\n`) : "__webpack_exports__" !== m.exportsArgument && startupSource.add(`var ${m.exportsArgument} = __webpack_exports__;\n`)), 
startupSource.add(renderedModule), startupSource.add(footer);
}
}
if (runtimeRequirements.has(RuntimeGlobals.onChunksLoaded) && startupSource.add(`__webpack_exports__ = ${RuntimeGlobals.onChunksLoaded}(__webpack_exports__);\n`), 
source.add(hooks.renderStartup.call(startupSource, lastInlinedModule, {
...renderContext,
inlined: !0
})), bootstrap.afterStartup.length > 0) {
const afterStartup = Template.asString(bootstrap.afterStartup) + "\n";
source.add(new PrefixSource(prefix, useSourceMap ? new OriginalSource(afterStartup, "webpack/after-startup") : new RawSource(afterStartup)));
}
} else {
const lastEntryModule = last(chunkGraph.getChunkEntryModulesIterable(chunk)), toSource = useSourceMap ? (content, name) => new OriginalSource(Template.asString(content), name) : content => new RawSource(Template.asString(content));
source.add(new PrefixSource(prefix, new ConcatSource(toSource(bootstrap.beforeStartup, "webpack/before-startup"), "\n", hooks.renderStartup.call(toSource(bootstrap.startup.concat(""), "webpack/startup"), lastEntryModule, {
...renderContext,
inlined: !1
}), toSource(bootstrap.afterStartup, "webpack/after-startup"), "\n")));
}
hasEntryModules && runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime) && source.add(`${prefix}return __webpack_exports__;\n`), 
iife && source.add("/******/ })()\n");
let finalSource = tryRunOrWebpackError((() => hooks.renderMain.call(source, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderMain");
if (!finalSource) throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderMain plugins should return something");
if (finalSource = tryRunOrWebpackError((() => hooks.renderContent.call(finalSource, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderContent"), 
!finalSource) throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something");
if (finalSource = InitFragment.addToSource(finalSource, chunkRenderContext.chunkInitFragments, chunkRenderContext), 
finalSource = tryRunOrWebpackError((() => hooks.render.call(finalSource, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().render"), 
!finalSource) throw new Error("JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something");
return chunk.rendered = !0, iife ? new ConcatSource(finalSource, ";") : finalSource;
}
updateHashWithBootstrap(hash, renderContext, hooks) {
const bootstrap = this.renderBootstrap(renderContext, hooks);
for (const key of Object.keys(bootstrap)) if (hash.update(key), Array.isArray(bootstrap[key])) for (const line of bootstrap[key]) hash.update(line); else hash.update(JSON.stringify(bootstrap[key]));
}
renderBootstrap(renderContext, hooks) {
const {chunkGraph, codeGenerationResults, moduleGraph, chunk, runtimeTemplate} = renderContext, runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk), requireFunction = runtimeRequirements.has(RuntimeGlobals.require), moduleCache = runtimeRequirements.has(RuntimeGlobals.moduleCache), moduleFactories = runtimeRequirements.has(RuntimeGlobals.moduleFactories), moduleUsed = runtimeRequirements.has(RuntimeGlobals.module), requireScopeUsed = runtimeRequirements.has(RuntimeGlobals.requireScope), interceptModuleExecution = runtimeRequirements.has(RuntimeGlobals.interceptModuleExecution), useRequire = requireFunction || interceptModuleExecution || moduleUsed, result = {
header: [],
beforeStartup: [],
startup: [],
afterStartup: [],
allowInlineStartup: !0
};
let {header: buf, startup, beforeStartup, afterStartup} = result;
if (result.allowInlineStartup && moduleFactories && (startup.push("// module factories are used so entry inlining is disabled"), 
result.allowInlineStartup = !1), result.allowInlineStartup && moduleCache && (startup.push("// module cache are used so entry inlining is disabled"), 
result.allowInlineStartup = !1), result.allowInlineStartup && interceptModuleExecution && (startup.push("// module execution is intercepted so entry inlining is disabled"), 
result.allowInlineStartup = !1), (useRequire || moduleCache) && (buf.push("// The module cache"), 
buf.push("var __webpack_module_cache__ = {};"), buf.push("")), useRequire ? (buf.push("// The require function"), 
buf.push("function __webpack_require__(moduleId) {"), buf.push(Template.indent(this.renderRequire(renderContext, hooks))), 
buf.push("}"), buf.push("")) : runtimeRequirements.has(RuntimeGlobals.requireScope) && (buf.push("// The require scope"), 
buf.push("var __webpack_require__ = {};"), buf.push("")), (moduleFactories || runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly)) && (buf.push("// expose the modules object (__webpack_modules__)"), 
buf.push(`${RuntimeGlobals.moduleFactories} = __webpack_modules__;`), buf.push("")), 
moduleCache && (buf.push("// expose the module cache"), buf.push(`${RuntimeGlobals.moduleCache} = __webpack_module_cache__;`), 
buf.push("")), interceptModuleExecution && (buf.push("// expose the module execution interceptor"), 
buf.push(`${RuntimeGlobals.interceptModuleExecution} = [];`), buf.push("")), runtimeRequirements.has(RuntimeGlobals.startupNoDefault)) (runtimeRequirements.has(RuntimeGlobals.startup) || runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) || runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)) && (result.allowInlineStartup = !1, 
buf.push("// the startup function", "// It's empty as some runtime module handles the default behavior", `${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`), 
startup.push("// run startup"), startup.push(`var __webpack_exports__ = ${RuntimeGlobals.startup}();`)); else if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
const buf2 = [], runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);
buf2.push("// Load entry module and return exports");
let i = chunkGraph.getNumberOfEntryModules(chunk);
for (const [entryModule, entrypoint] of chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)) {
const chunks = entrypoint.chunks.filter((c => c !== chunk));
let data;
if (result.allowInlineStartup && chunks.length > 0 && (buf2.push("// This entry module depends on other loaded chunks and execution need to be delayed"), 
result.allowInlineStartup = !1), result.allowInlineStartup && someInIterable(moduleGraph.getIncomingConnectionsByOriginModule(entryModule), (([originModule, connections]) => originModule && connections.some((c => c.isTargetActive(chunk.runtime))) && someInIterable(chunkGraph.getModuleRuntimes(originModule), (runtime => void 0 !== intersectRuntime(runtime, chunk.runtime))))) && (buf2.push("// This entry module is referenced by other modules so it can't be inlined"), 
result.allowInlineStartup = !1), codeGenerationResults.has(entryModule, chunk.runtime)) {
data = codeGenerationResults.get(entryModule, chunk.runtime).data;
}
if (!result.allowInlineStartup || data && data.get("topLevelDeclarations") || entryModule.buildInfo && entryModule.buildInfo.topLevelDeclarations || (buf2.push("// This entry module doesn't tell about it's top-level declarations so it can't be inlined"), 
result.allowInlineStartup = !1), result.allowInlineStartup) {
const bailout = hooks.inlineInRuntimeBailout.call(entryModule, renderContext);
void 0 !== bailout && (buf2.push(`// This entry module can't be inlined because ${bailout}`), 
result.allowInlineStartup = !1);
}
i--;
const moduleId = chunkGraph.getModuleId(entryModule), entryRuntimeRequirements = chunkGraph.getModuleRuntimeRequirements(entryModule, chunk.runtime);
let moduleIdExpr = JSON.stringify(moduleId);
runtimeRequirements.has(RuntimeGlobals.entryModuleId) && (moduleIdExpr = `${RuntimeGlobals.entryModuleId} = ${moduleIdExpr}`), 
result.allowInlineStartup && entryRuntimeRequirements.has(RuntimeGlobals.module) && (result.allowInlineStartup = !1, 
buf2.push("// This entry module used 'module' so it can't be inlined")), chunks.length > 0 ? buf2.push(`${0 === i ? "var __webpack_exports__ = " : ""}${RuntimeGlobals.onChunksLoaded}(undefined, ${JSON.stringify(chunks.map((c => c.id)))}, ${runtimeTemplate.returningFunction(`__webpack_require__(${moduleIdExpr})`)})`) : useRequire ? buf2.push(`${0 === i ? "var __webpack_exports__ = " : ""}__webpack_require__(${moduleIdExpr});`) : (0 === i && buf2.push("var __webpack_exports__ = {};"), 
requireScopeUsed ? buf2.push(`__webpack_modules__[${moduleIdExpr}](0, ${0 === i ? "__webpack_exports__" : "{}"}, __webpack_require__);`) : entryRuntimeRequirements.has(RuntimeGlobals.exports) ? buf2.push(`__webpack_modules__[${moduleIdExpr}](0, ${0 === i ? "__webpack_exports__" : "{}"});`) : buf2.push(`__webpack_modules__[${moduleIdExpr}]();`));
}
runtimeRequirements.has(RuntimeGlobals.onChunksLoaded) && buf2.push(`__webpack_exports__ = ${RuntimeGlobals.onChunksLoaded}(__webpack_exports__);`), 
runtimeRequirements.has(RuntimeGlobals.startup) || runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) && runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter) ? (result.allowInlineStartup = !1, 
buf.push("// the startup function"), buf.push(`${RuntimeGlobals.startup} = ${runtimeTemplate.basicFunction("", [ ...buf2, "return __webpack_exports__;" ])};`), 
buf.push(""), startup.push("// run startup"), startup.push(`var __webpack_exports__ = ${RuntimeGlobals.startup}();`)) : runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) ? (buf.push("// the startup function"), 
buf.push(`${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`), beforeStartup.push("// run runtime startup"), 
beforeStartup.push(`${RuntimeGlobals.startup}();`), startup.push("// startup"), 
startup.push(Template.asString(buf2))) : runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter) ? (buf.push("// the startup function"), 
buf.push(`${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`), startup.push("// startup"), 
startup.push(Template.asString(buf2)), afterStartup.push("// run runtime startup"), 
afterStartup.push(`${RuntimeGlobals.startup}();`)) : (startup.push("// startup"), 
startup.push(Template.asString(buf2)));
} else (runtimeRequirements.has(RuntimeGlobals.startup) || runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) || runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)) && buf.push("// the startup function", "// It's empty as no entry modules are in this chunk", `${RuntimeGlobals.startup} = ${runtimeTemplate.emptyFunction()};`, "");
return result;
}
renderRequire(renderContext, hooks) {
const {chunk, chunkGraph, runtimeTemplate: {outputOptions}} = renderContext, runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk), moduleExecution = runtimeRequirements.has(RuntimeGlobals.interceptModuleExecution) ? Template.asString([ "var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };", `${RuntimeGlobals.interceptModuleExecution}.forEach(function(handler) { handler(execOptions); });`, "module = execOptions.module;", "execOptions.factory.call(module.exports, module, module.exports, execOptions.require);" ]) : runtimeRequirements.has(RuntimeGlobals.thisAsExports) ? Template.asString([ "__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);" ]) : Template.asString([ "__webpack_modules__[moduleId](module, module.exports, __webpack_require__);" ]), needModuleId = runtimeRequirements.has(RuntimeGlobals.moduleId), needModuleLoaded = runtimeRequirements.has(RuntimeGlobals.moduleLoaded), content = Template.asString([ "// Check if module is in cache", "var cachedModule = __webpack_module_cache__[moduleId];", "if (cachedModule !== undefined) {", outputOptions.strictModuleErrorHandling ? Template.indent([ "if (cachedModule.error !== undefined) throw cachedModule.error;", "return cachedModule.exports;" ]) : Template.indent("return cachedModule.exports;"), "}", "// Create a new module (and put it into the cache)", "var module = __webpack_module_cache__[moduleId] = {", Template.indent([ needModuleId ? "id: moduleId," : "// no module.id needed", needModuleLoaded ? "loaded: false," : "// no module.loaded needed", "exports: {}" ]), "};", "", outputOptions.strictModuleExceptionHandling ? Template.asString([ "// Execute the module function", "var threw = true;", "try {", Template.indent([ moduleExecution, "threw = false;" ]), "} finally {", Template.indent([ "if(threw) delete __webpack_module_cache__[moduleId];" ]), "}" ]) : outputOptions.strictModuleErrorHandling ? Template.asString([ "// Execute the module function", "try {", Template.indent(moduleExecution), "} catch(e) {", Template.indent([ "module.error = e;", "throw e;" ]), "}" ]) : Template.asString([ "// Execute the module function", moduleExecution ]), needModuleLoaded ? Template.asString([ "", "// Flag the module as loaded", "module.loaded = true;", "" ]) : "", "// Return the exports of the module", "return module.exports;" ]);
return tryRunOrWebpackError((() => hooks.renderRequire.call(content, renderContext)), "JavascriptModulesPlugin.getCompilationHooks().renderRequire");
}
}
module.exports = JavascriptModulesPlugin, module.exports.chunkHasJs = chunkHasJs;
},
36793: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {Parser: AcornParser} = __webpack_require__(1234), {importAssertions} = __webpack_require__(99986), {SyncBailHook, HookMap} = __webpack_require__(89991), vm = __webpack_require__(26144), Parser = __webpack_require__(21475), StackedMap = __webpack_require__(33963), binarySearchBounds = __webpack_require__(35704), memoize = __webpack_require__(98216), BasicEvaluatedExpression = __webpack_require__(47789), EMPTY_ARRAY = [], parser = AcornParser.extend(importAssertions);
class VariableInfo {
constructor(declaredScope, freeName, tagInfo) {
this.declaredScope = declaredScope, this.freeName = freeName, this.tagInfo = tagInfo;
}
}
const joinRanges = (startRange, endRange) => endRange ? startRange ? [ startRange[0], endRange[1] ] : endRange : startRange, objectAndMembersToName = (object, membersReversed) => {
let name = object;
for (let i = membersReversed.length - 1; i >= 0; i--) name = name + "." + membersReversed[i];
return name;
}, getRootName = expression => {
switch (expression.type) {
case "Identifier":
return expression.name;

case "ThisExpression":
return "this";

case "MetaProperty":
return `${expression.meta.name}.${expression.property.name}`;

default:
return;
}
}, defaultParserOptions = {
ranges: !0,
locations: !0,
ecmaVersion: "latest",
sourceType: "module",
allowHashBang: !0,
onComment: null
}, webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/), EMPTY_COMMENT_OPTIONS = {
options: null,
errors: null
};
class JavascriptParser extends Parser {
constructor(sourceType = "auto") {
super(), this.hooks = Object.freeze({
evaluateTypeof: new HookMap((() => new SyncBailHook([ "expression" ]))),
evaluate: new HookMap((() => new SyncBailHook([ "expression" ]))),
evaluateIdentifier: new HookMap((() => new SyncBailHook([ "expression" ]))),
evaluateDefinedIdentifier: new HookMap((() => new SyncBailHook([ "expression" ]))),
evaluateNewExpression: new HookMap((() => new SyncBailHook([ "expression" ]))),
evaluateCallExpression: new HookMap((() => new SyncBailHook([ "expression" ]))),
evaluateCallExpressionMember: new HookMap((() => new SyncBailHook([ "expression", "param" ]))),
isPure: new HookMap((() => new SyncBailHook([ "expression", "commentsStartPosition" ]))),
preStatement: new SyncBailHook([ "statement" ]),
blockPreStatement: new SyncBailHook([ "declaration" ]),
statement: new SyncBailHook([ "statement" ]),
statementIf: new SyncBailHook([ "statement" ]),
classExtendsExpression: new SyncBailHook([ "expression", "classDefinition" ]),
classBodyElement: new SyncBailHook([ "element", "classDefinition" ]),
classBodyValue: new SyncBailHook([ "expression", "element", "classDefinition" ]),
label: new HookMap((() => new SyncBailHook([ "statement" ]))),
import: new SyncBailHook([ "statement", "source" ]),
importSpecifier: new SyncBailHook([ "statement", "source", "exportName", "identifierName" ]),
export: new SyncBailHook([ "statement" ]),
exportImport: new SyncBailHook([ "statement", "source" ]),
exportDeclaration: new SyncBailHook([ "statement", "declaration" ]),
exportExpression: new SyncBailHook([ "statement", "declaration" ]),
exportSpecifier: new SyncBailHook([ "statement", "identifierName", "exportName", "index" ]),
exportImportSpecifier: new SyncBailHook([ "statement", "source", "identifierName", "exportName", "index" ]),
preDeclarator: new SyncBailHook([ "declarator", "statement" ]),
declarator: new SyncBailHook([ "declarator", "statement" ]),
varDeclaration: new HookMap((() => new SyncBailHook([ "declaration" ]))),
varDeclarationLet: new HookMap((() => new SyncBailHook([ "declaration" ]))),
varDeclarationConst: new HookMap((() => new SyncBailHook([ "declaration" ]))),
varDeclarationVar: new HookMap((() => new SyncBailHook([ "declaration" ]))),
pattern: new HookMap((() => new SyncBailHook([ "pattern" ]))),
canRename: new HookMap((() => new SyncBailHook([ "initExpression" ]))),
rename: new HookMap((() => new SyncBailHook([ "initExpression" ]))),
assign: new HookMap((() => new SyncBailHook([ "expression" ]))),
assignMemberChain: new HookMap((() => new SyncBailHook([ "expression", "members" ]))),
typeof: new HookMap((() => new SyncBailHook([ "expression" ]))),
importCall: new SyncBailHook([ "expression" ]),
topLevelAwait: new SyncBailHook([ "expression" ]),
call: new HookMap((() => new SyncBailHook([ "expression" ]))),
callMemberChain: new HookMap((() => new SyncBailHook([ "expression", "members", "membersOptionals" ]))),
memberChainOfCallMemberChain: new HookMap((() => new SyncBailHook([ "expression", "calleeMembers", "callExpression", "members" ]))),
callMemberChainOfCallMemberChain: new HookMap((() => new SyncBailHook([ "expression", "calleeMembers", "innerCallExpression", "members" ]))),
optionalChaining: new SyncBailHook([ "optionalChaining" ]),
new: new HookMap((() => new SyncBailHook([ "expression" ]))),
binaryExpression: new SyncBailHook([ "binaryExpression" ]),
expression: new HookMap((() => new SyncBailHook([ "expression" ]))),
expressionMemberChain: new HookMap((() => new SyncBailHook([ "expression", "members", "membersOptionals" ]))),
unhandledExpressionMemberChain: new HookMap((() => new SyncBailHook([ "expression", "members" ]))),
expressionConditionalOperator: new SyncBailHook([ "expression" ]),
expressionLogicalOperator: new SyncBailHook([ "expression" ]),
program: new SyncBailHook([ "ast", "comments" ]),
finish: new SyncBailHook([ "ast", "comments" ])
}), this.sourceType = sourceType, this.scope = void 0, this.state = void 0, this.comments = void 0, 
this.semicolons = void 0, this.statementPath = void 0, this.prevStatement = void 0, 
this.currentTagData = void 0, this._initializeEvaluating();
}
_initializeEvaluating() {
this.hooks.evaluate.for("Literal").tap("JavascriptParser", (_expr => {
const expr = _expr;
switch (typeof expr.value) {
case "number":
return (new BasicEvaluatedExpression).setNumber(expr.value).setRange(expr.range);

case "bigint":
return (new BasicEvaluatedExpression).setBigInt(expr.value).setRange(expr.range);

case "string":
return (new BasicEvaluatedExpression).setString(expr.value).setRange(expr.range);

case "boolean":
return (new BasicEvaluatedExpression).setBoolean(expr.value).setRange(expr.range);
}
return null === expr.value ? (new BasicEvaluatedExpression).setNull().setRange(expr.range) : expr.value instanceof RegExp ? (new BasicEvaluatedExpression).setRegExp(expr.value).setRange(expr.range) : void 0;
})), this.hooks.evaluate.for("NewExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, callee = expr.callee;
if ("Identifier" !== callee.type) return;
if ("RegExp" !== callee.name) return this.callHooksForName(this.hooks.evaluateNewExpression, callee.name, expr);
if (expr.arguments.length > 2 || "RegExp" !== this.getVariableInfo("RegExp")) return;
let regExp, flags;
const arg1 = expr.arguments[0];
if (!arg1) return (new BasicEvaluatedExpression).setRegExp(new RegExp("")).setRange(expr.range);
{
if ("SpreadElement" === arg1.type) return;
const evaluatedRegExp = this.evaluateExpression(arg1);
if (!evaluatedRegExp) return;
if (regExp = evaluatedRegExp.asString(), !regExp) return;
}
const arg2 = expr.arguments[1];
if (arg2) {
if ("SpreadElement" === arg2.type) return;
const evaluatedFlags = this.evaluateExpression(arg2);
if (!evaluatedFlags) return;
if (!evaluatedFlags.isUndefined() && (flags = evaluatedFlags.asString(), void 0 === flags || !BasicEvaluatedExpression.isValidRegExpFlags(flags))) return;
}
return (new BasicEvaluatedExpression).setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp)).setRange(expr.range);
})), this.hooks.evaluate.for("LogicalExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, left = this.evaluateExpression(expr.left);
let allowedRight, returnRight = !1;
if ("&&" === expr.operator) {
const leftAsBool = left.asBool();
if (!1 === leftAsBool) return left.setRange(expr.range);
returnRight = !0 === leftAsBool, allowedRight = !1;
} else if ("||" === expr.operator) {
const leftAsBool = left.asBool();
if (!0 === leftAsBool) return left.setRange(expr.range);
returnRight = !1 === leftAsBool, allowedRight = !0;
} else {
if ("??" !== expr.operator) return;
{
const leftAsNullish = left.asNullish();
if (!1 === leftAsNullish) return left.setRange(expr.range);
if (!0 !== leftAsNullish) return;
returnRight = !0;
}
}
const right = this.evaluateExpression(expr.right);
if (returnRight) return left.couldHaveSideEffects() && right.setSideEffects(), right.setRange(expr.range);
const asBool = right.asBool();
return !0 === allowedRight && !0 === asBool ? (new BasicEvaluatedExpression).setRange(expr.range).setTruthy() : !1 === allowedRight && !1 === asBool ? (new BasicEvaluatedExpression).setRange(expr.range).setFalsy() : void 0;
}));
const valueAsExpression = (value, expr, sideEffects) => {
switch (typeof value) {
case "boolean":
return (new BasicEvaluatedExpression).setBoolean(value).setSideEffects(sideEffects).setRange(expr.range);

case "number":
return (new BasicEvaluatedExpression).setNumber(value).setSideEffects(sideEffects).setRange(expr.range);

case "bigint":
return (new BasicEvaluatedExpression).setBigInt(value).setSideEffects(sideEffects).setRange(expr.range);

case "string":
return (new BasicEvaluatedExpression).setString(value).setSideEffects(sideEffects).setRange(expr.range);
}
};
this.hooks.evaluate.for("BinaryExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, handleConstOperation = fn => {
const left = this.evaluateExpression(expr.left);
if (!left.isCompileTimeValue()) return;
const right = this.evaluateExpression(expr.right);
if (!right.isCompileTimeValue()) return;
const result = fn(left.asCompileTimeValue(), right.asCompileTimeValue());
return valueAsExpression(result, expr, left.couldHaveSideEffects() || right.couldHaveSideEffects());
}, isAlwaysDifferent = (a, b) => !0 === a && !1 === b || !1 === a && !0 === b, handleTemplateStringCompare = (left, right, res, eql) => {
const getPrefix = parts => {
let value = "";
for (const p of parts) {
const v = p.asString();
if (void 0 === v) break;
value += v;
}
return value;
}, getSuffix = parts => {
let value = "";
for (let i = parts.length - 1; i >= 0; i--) {
const v = parts[i].asString();
if (void 0 === v) break;
value = v + value;
}
return value;
}, leftPrefix = getPrefix(left.parts), rightPrefix = getPrefix(right.parts), leftSuffix = getSuffix(left.parts), rightSuffix = getSuffix(right.parts), lenPrefix = Math.min(leftPrefix.length, rightPrefix.length), lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
if (leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix) || leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)) return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());
}, handleStrictEqualityComparison = eql => {
const left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), res = new BasicEvaluatedExpression;
res.setRange(expr.range);
const leftConst = left.isCompileTimeValue(), rightConst = right.isCompileTimeValue();
if (leftConst && rightConst) return res.setBoolean(eql === (left.asCompileTimeValue() === right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());
if (left.isArray() && right.isArray()) return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());
if (left.isTemplateString() && right.isTemplateString()) return handleTemplateStringCompare(left, right, res, eql);
const leftPrimitive = left.isPrimitiveType(), rightPrimitive = right.isPrimitiveType();
return !1 === leftPrimitive && (leftConst || !0 === rightPrimitive) || !1 === rightPrimitive && (rightConst || !0 === leftPrimitive) || isAlwaysDifferent(left.asBool(), right.asBool()) || isAlwaysDifferent(left.asNullish(), right.asNullish()) ? res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects()) : void 0;
}, handleAbstractEqualityComparison = eql => {
const left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), res = new BasicEvaluatedExpression;
res.setRange(expr.range);
const leftConst = left.isCompileTimeValue(), rightConst = right.isCompileTimeValue();
return leftConst && rightConst ? res.setBoolean(eql === (left.asCompileTimeValue() == right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects()) : left.isArray() && right.isArray() ? res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects()) : left.isTemplateString() && right.isTemplateString() ? handleTemplateStringCompare(left, right, res, eql) : void 0;
};
if ("+" === expr.operator) {
const left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), res = new BasicEvaluatedExpression;
if (left.isString()) right.isString() ? res.setString(left.string + right.string) : right.isNumber() ? res.setString(left.string + right.number) : right.isWrapped() && right.prefix && right.prefix.isString() ? res.setWrapped((new BasicEvaluatedExpression).setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions) : right.isWrapped() ? res.setWrapped(left, right.postfix, right.wrappedInnerExpressions) : res.setWrapped(left, null, [ right ]); else if (left.isNumber()) if (right.isString()) res.setString(left.number + right.string); else {
if (!right.isNumber()) return;
res.setNumber(left.number + right.number);
} else if (left.isBigInt()) right.isBigInt() && res.setBigInt(left.bigint + right.bigint); else if (left.isWrapped()) left.postfix && left.postfix.isString() && right.isString() ? res.setWrapped(left.prefix, (new BasicEvaluatedExpression).setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions) : left.postfix && left.postfix.isString() && right.isNumber() ? res.setWrapped(left.prefix, (new BasicEvaluatedExpression).setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions) : right.isString() ? res.setWrapped(left.prefix, right, left.wrappedInnerExpressions) : right.isNumber() ? res.setWrapped(left.prefix, (new BasicEvaluatedExpression).setString(right.number + "").setRange(right.range), left.wrappedInnerExpressions) : right.isWrapped() ? res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [ left.postfix ] : []).concat(right.prefix ? [ right.prefix ] : []).concat(right.wrappedInnerExpressions)) : res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [ left.postfix, right ] : [ right ])); else if (right.isString()) res.setWrapped(null, right, [ left ]); else {
if (!right.isWrapped()) return;
res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [ left, right.prefix ] : [ left ]).concat(right.wrappedInnerExpressions));
}
return (left.couldHaveSideEffects() || right.couldHaveSideEffects()) && res.setSideEffects(), 
res.setRange(expr.range), res;
}
return "-" === expr.operator ? handleConstOperation(((l, r) => l - r)) : "*" === expr.operator ? handleConstOperation(((l, r) => l * r)) : "/" === expr.operator ? handleConstOperation(((l, r) => l / r)) : "**" === expr.operator ? handleConstOperation(((l, r) => l ** r)) : "===" === expr.operator ? handleStrictEqualityComparison(!0) : "==" === expr.operator ? handleAbstractEqualityComparison(!0) : "!==" === expr.operator ? handleStrictEqualityComparison(!1) : "!=" === expr.operator ? handleAbstractEqualityComparison(!1) : "&" === expr.operator ? handleConstOperation(((l, r) => l & r)) : "|" === expr.operator ? handleConstOperation(((l, r) => l | r)) : "^" === expr.operator ? handleConstOperation(((l, r) => l ^ r)) : ">>>" === expr.operator ? handleConstOperation(((l, r) => l >>> r)) : ">>" === expr.operator ? handleConstOperation(((l, r) => l >> r)) : "<<" === expr.operator ? handleConstOperation(((l, r) => l << r)) : "<" === expr.operator ? handleConstOperation(((l, r) => l < r)) : ">" === expr.operator ? handleConstOperation(((l, r) => l > r)) : "<=" === expr.operator ? handleConstOperation(((l, r) => l <= r)) : ">=" === expr.operator ? handleConstOperation(((l, r) => l >= r)) : void 0;
})), this.hooks.evaluate.for("UnaryExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, handleConstOperation = fn => {
const argument = this.evaluateExpression(expr.argument);
if (!argument.isCompileTimeValue()) return;
const result = fn(argument.asCompileTimeValue());
return valueAsExpression(result, expr, argument.couldHaveSideEffects());
};
if ("typeof" === expr.operator) {
switch (expr.argument.type) {
case "Identifier":
{
const res = this.callHooksForName(this.hooks.evaluateTypeof, expr.argument.name, expr);
if (void 0 !== res) return res;
break;
}

case "MetaProperty":
{
const res = this.callHooksForName(this.hooks.evaluateTypeof, getRootName(expr.argument), expr);
if (void 0 !== res) return res;
break;
}

case "MemberExpression":
{
const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument, expr);
if (void 0 !== res) return res;
break;
}

case "ChainExpression":
{
const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument.expression, expr);
if (void 0 !== res) return res;
break;
}

case "FunctionExpression":
return (new BasicEvaluatedExpression).setString("function").setRange(expr.range);
}
const arg = this.evaluateExpression(expr.argument);
if (arg.isUnknown()) return;
if (arg.isString()) return (new BasicEvaluatedExpression).setString("string").setRange(expr.range);
if (arg.isWrapped()) return (new BasicEvaluatedExpression).setString("string").setSideEffects().setRange(expr.range);
if (arg.isUndefined()) return (new BasicEvaluatedExpression).setString("undefined").setRange(expr.range);
if (arg.isNumber()) return (new BasicEvaluatedExpression).setString("number").setRange(expr.range);
if (arg.isBigInt()) return (new BasicEvaluatedExpression).setString("bigint").setRange(expr.range);
if (arg.isBoolean()) return (new BasicEvaluatedExpression).setString("boolean").setRange(expr.range);
if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) return (new BasicEvaluatedExpression).setString("object").setRange(expr.range);
if (arg.isArray()) return (new BasicEvaluatedExpression).setString("object").setSideEffects(arg.couldHaveSideEffects()).setRange(expr.range);
} else {
if ("!" === expr.operator) {
const argument = this.evaluateExpression(expr.argument), bool = argument.asBool();
if ("boolean" != typeof bool) return;
return (new BasicEvaluatedExpression).setBoolean(!bool).setSideEffects(argument.couldHaveSideEffects()).setRange(expr.range);
}
if ("~" === expr.operator) return handleConstOperation((v => ~v));
if ("+" === expr.operator) return handleConstOperation((v => +v));
if ("-" === expr.operator) return handleConstOperation((v => -v));
}
})), this.hooks.evaluateTypeof.for("undefined").tap("JavascriptParser", (expr => (new BasicEvaluatedExpression).setString("undefined").setRange(expr.range))), 
this.hooks.evaluate.for("Identifier").tap("JavascriptParser", (expr => {
if ("undefined" === expr.name) return (new BasicEvaluatedExpression).setUndefined().setRange(expr.range);
}));
const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
let cachedExpression, cachedInfo;
this.hooks.evaluate.for(exprType).tap("JavascriptParser", (expr => {
const expression = expr, info = getInfo(expr);
if (void 0 !== info) return this.callHooksForInfoWithFallback(this.hooks.evaluateIdentifier, info.name, (name => {
cachedExpression = expression, cachedInfo = info;
}), (name => {
const hook = this.hooks.evaluateDefinedIdentifier.get(name);
if (void 0 !== hook) return hook.call(expression);
}), expression);
})), this.hooks.evaluate.for(exprType).tap({
name: "JavascriptParser",
stage: 100
}, (expr => {
const info = cachedExpression === expr ? cachedInfo : getInfo(expr);
if (void 0 !== info) return (new BasicEvaluatedExpression).setIdentifier(info.name, info.rootInfo, info.getMembers, info.getMembersOptionals).setRange(expr.range);
})), this.hooks.finish.tap("JavascriptParser", (() => {
cachedExpression = cachedInfo = void 0;
}));
};
tapEvaluateWithVariableInfo("Identifier", (expr => {
const info = this.getVariableInfo(expr.name);
if ("string" == typeof info || info instanceof VariableInfo && "string" == typeof info.freeName) return {
name: info,
rootInfo: info,
getMembers: () => [],
getMembersOptionals: () => []
};
})), tapEvaluateWithVariableInfo("ThisExpression", (expr => {
const info = this.getVariableInfo("this");
if ("string" == typeof info || info instanceof VariableInfo && "string" == typeof info.freeName) return {
name: info,
rootInfo: info,
getMembers: () => [],
getMembersOptionals: () => []
};
})), this.hooks.evaluate.for("MetaProperty").tap("JavascriptParser", (expr => {
const metaProperty = expr;
return this.callHooksForName(this.hooks.evaluateIdentifier, getRootName(expr), metaProperty);
})), tapEvaluateWithVariableInfo("MemberExpression", (expr => this.getMemberExpressionInfo(expr, 2))), 
this.hooks.evaluate.for("CallExpression").tap("JavascriptParser", (_expr => {
const expr = _expr;
if ("MemberExpression" === expr.callee.type && expr.callee.property.type === (expr.callee.computed ? "Literal" : "Identifier")) {
const param = this.evaluateExpression(expr.callee.object), property = "Literal" === expr.callee.property.type ? `${expr.callee.property.value}` : expr.callee.property.name, hook = this.hooks.evaluateCallExpressionMember.get(property);
if (void 0 !== hook) return hook.call(expr, param);
} else if ("Identifier" === expr.callee.type) return this.callHooksForName(this.hooks.evaluateCallExpression, expr.callee.name, expr);
})), this.hooks.evaluateCallExpressionMember.for("indexOf").tap("JavascriptParser", ((expr, param) => {
if (!param.isString()) return;
if (0 === expr.arguments.length) return;
const [arg1, arg2] = expr.arguments;
if ("SpreadElement" === arg1.type) return;
const arg1Eval = this.evaluateExpression(arg1);
if (!arg1Eval.isString()) return;
const arg1Value = arg1Eval.string;
let result;
if (arg2) {
if ("SpreadElement" === arg2.type) return;
const arg2Eval = this.evaluateExpression(arg2);
if (!arg2Eval.isNumber()) return;
result = param.string.indexOf(arg1Value, arg2Eval.number);
} else result = param.string.indexOf(arg1Value);
return (new BasicEvaluatedExpression).setNumber(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);
})), this.hooks.evaluateCallExpressionMember.for("replace").tap("JavascriptParser", ((expr, param) => {
if (!param.isString()) return;
if (2 !== expr.arguments.length) return;
if ("SpreadElement" === expr.arguments[0].type) return;
if ("SpreadElement" === expr.arguments[1].type) return;
let arg1 = this.evaluateExpression(expr.arguments[0]), arg2 = this.evaluateExpression(expr.arguments[1]);
if (!arg1.isString() && !arg1.isRegExp()) return;
const arg1Value = arg1.regExp || arg1.string;
if (!arg2.isString()) return;
const arg2Value = arg2.string;
return (new BasicEvaluatedExpression).setString(param.string.replace(arg1Value, arg2Value)).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);
})), [ "substr", "substring", "slice" ].forEach((fn => {
this.hooks.evaluateCallExpressionMember.for(fn).tap("JavascriptParser", ((expr, param) => {
if (!param.isString()) return;
let arg1, result, str = param.string;
switch (expr.arguments.length) {
case 1:
if ("SpreadElement" === expr.arguments[0].type) return;
if (arg1 = this.evaluateExpression(expr.arguments[0]), !arg1.isNumber()) return;
result = str[fn](arg1.number);
break;

case 2:
{
if ("SpreadElement" === expr.arguments[0].type) return;
if ("SpreadElement" === expr.arguments[1].type) return;
arg1 = this.evaluateExpression(expr.arguments[0]);
const arg2 = this.evaluateExpression(expr.arguments[1]);
if (!arg1.isNumber()) return;
if (!arg2.isNumber()) return;
result = str[fn](arg1.number, arg2.number);
break;
}

default:
return;
}
return (new BasicEvaluatedExpression).setString(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);
}));
}));
const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
const quasis = [], parts = [];
for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
const quasiExpr = templateLiteralExpr.quasis[i], quasi = quasiExpr.value[kind];
if (i > 0) {
const prevExpr = parts[parts.length - 1], expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]), exprAsString = expr.asString();
if ("string" == typeof exprAsString && !expr.couldHaveSideEffects()) {
prevExpr.setString(prevExpr.string + exprAsString + quasi), prevExpr.setRange([ prevExpr.range[0], quasiExpr.range[1] ]), 
prevExpr.setExpression(void 0);
continue;
}
parts.push(expr);
}
const part = (new BasicEvaluatedExpression).setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);
quasis.push(part), parts.push(part);
}
return {
quasis,
parts
};
};
this.hooks.evaluate.for("TemplateLiteral").tap("JavascriptParser", (_node => {
const node = _node, {quasis, parts} = getSimplifiedTemplateResult("cooked", node);
return 1 === parts.length ? parts[0].setRange(node.range) : (new BasicEvaluatedExpression).setTemplateString(quasis, parts, "cooked").setRange(node.range);
})), this.hooks.evaluate.for("TaggedTemplateExpression").tap("JavascriptParser", (_node => {
const node = _node, tag = this.evaluateExpression(node.tag);
if (tag.isIdentifier() && "String.raw" === tag.identifier) {
const {quasis, parts} = getSimplifiedTemplateResult("raw", node.quasi);
return (new BasicEvaluatedExpression).setTemplateString(quasis, parts, "raw").setRange(node.range);
}
})), this.hooks.evaluateCallExpressionMember.for("concat").tap("JavascriptParser", ((expr, param) => {
if (!param.isString() && !param.isWrapped()) return;
let stringSuffix = null, hasUnknownParams = !1;
const innerExpressions = [];
for (let i = expr.arguments.length - 1; i >= 0; i--) {
const arg = expr.arguments[i];
if ("SpreadElement" === arg.type) return;
const argExpr = this.evaluateExpression(arg);
if (hasUnknownParams || !argExpr.isString() && !argExpr.isNumber()) {
hasUnknownParams = !0, innerExpressions.push(argExpr);
continue;
}
const newString = (argExpr.isString() ? argExpr.string : "" + argExpr.number) + (stringSuffix ? stringSuffix.string : ""), newRange = [ argExpr.range[0], (stringSuffix || argExpr).range[1] ];
stringSuffix = (new BasicEvaluatedExpression).setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || argExpr.couldHaveSideEffects()).setRange(newRange);
}
if (hasUnknownParams) {
const prefix = param.isString() ? param : param.prefix, inner = param.isWrapped() && param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();
return (new BasicEvaluatedExpression).setWrapped(prefix, stringSuffix, inner).setRange(expr.range);
}
if (param.isWrapped()) {
const postfix = stringSuffix || param.postfix, inner = param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();
return (new BasicEvaluatedExpression).setWrapped(param.prefix, postfix, inner).setRange(expr.range);
}
{
const newString = param.string + (stringSuffix ? stringSuffix.string : "");
return (new BasicEvaluatedExpression).setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || param.couldHaveSideEffects()).setRange(expr.range);
}
})), this.hooks.evaluateCallExpressionMember.for("split").tap("JavascriptParser", ((expr, param) => {
if (!param.isString()) return;
if (1 !== expr.arguments.length) return;
if ("SpreadElement" === expr.arguments[0].type) return;
let result;
const arg = this.evaluateExpression(expr.arguments[0]);
if (arg.isString()) result = param.string.split(arg.string); else {
if (!arg.isRegExp()) return;
result = param.string.split(arg.regExp);
}
return (new BasicEvaluatedExpression).setArray(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);
})), this.hooks.evaluate.for("ConditionalExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, condition = this.evaluateExpression(expr.test), conditionValue = condition.asBool();
let res;
if (void 0 === conditionValue) {
const consequent = this.evaluateExpression(expr.consequent), alternate = this.evaluateExpression(expr.alternate);
res = new BasicEvaluatedExpression, consequent.isConditional() ? res.setOptions(consequent.options) : res.setOptions([ consequent ]), 
alternate.isConditional() ? res.addOptions(alternate.options) : res.addOptions([ alternate ]);
} else res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate), 
condition.couldHaveSideEffects() && res.setSideEffects();
return res.setRange(expr.range), res;
})), this.hooks.evaluate.for("ArrayExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, items = expr.elements.map((element => null !== element && "SpreadElement" !== element.type && this.evaluateExpression(element)));
if (items.every(Boolean)) return (new BasicEvaluatedExpression).setItems(items).setRange(expr.range);
})), this.hooks.evaluate.for("ChainExpression").tap("JavascriptParser", (_expr => {
const expr = _expr, optionalExpressionsStack = [];
let next = expr.expression;
for (;"MemberExpression" === next.type || "CallExpression" === next.type; ) "MemberExpression" === next.type ? (next.optional && optionalExpressionsStack.push(next.object), 
next = next.object) : (next.optional && optionalExpressionsStack.push(next.callee), 
next = next.callee);
for (;optionalExpressionsStack.length > 0; ) {
const expression = optionalExpressionsStack.pop(), evaluated = this.evaluateExpression(expression);
if (evaluated.asNullish()) return evaluated.setRange(_expr.range);
}
return this.evaluateExpression(expr.expression);
}));
}
getRenameIdentifier(expr) {
const result = this.evaluateExpression(expr);
if (result.isIdentifier()) return result.identifier;
}
walkClass(classy) {
if (classy.superClass && (this.hooks.classExtendsExpression.call(classy.superClass, classy) || this.walkExpression(classy.superClass)), 
classy.body && "ClassBody" === classy.body.type) for (const classElement of classy.body.body) if (!this.hooks.classBodyElement.call(classElement, classy)) if (classElement.computed && classElement.key && this.walkExpression(classElement.key), 
classElement.value) {
if (!this.hooks.classBodyValue.call(classElement.value, classElement, classy)) {
const wasTopLevel = this.scope.topLevelScope;
this.scope.topLevelScope = !1, this.walkExpression(classElement.value), this.scope.topLevelScope = wasTopLevel;
}
} else if ("StaticBlock" === classElement.type) {
const wasTopLevel = this.scope.topLevelScope;
this.scope.topLevelScope = !1, this.walkBlockStatement(classElement), this.scope.topLevelScope = wasTopLevel;
}
}
preWalkStatements(statements) {
for (let index = 0, len = statements.length; index < len; index++) {
const statement = statements[index];
this.preWalkStatement(statement);
}
}
blockPreWalkStatements(statements) {
for (let index = 0, len = statements.length; index < len; index++) {
const statement = statements[index];
this.blockPreWalkStatement(statement);
}
}
walkStatements(statements) {
for (let index = 0, len = statements.length; index < len; index++) {
const statement = statements[index];
this.walkStatement(statement);
}
}
preWalkStatement(statement) {
if (this.statementPath.push(statement), this.hooks.preStatement.call(statement)) this.prevStatement = this.statementPath.pop(); else {
switch (statement.type) {
case "BlockStatement":
this.preWalkBlockStatement(statement);
break;

case "DoWhileStatement":
this.preWalkDoWhileStatement(statement);
break;

case "ForInStatement":
this.preWalkForInStatement(statement);
break;

case "ForOfStatement":
this.preWalkForOfStatement(statement);
break;

case "ForStatement":
this.preWalkForStatement(statement);
break;

case "FunctionDeclaration":
this.preWalkFunctionDeclaration(statement);
break;

case "IfStatement":
this.preWalkIfStatement(statement);
break;

case "LabeledStatement":
this.preWalkLabeledStatement(statement);
break;

case "SwitchStatement":
this.preWalkSwitchStatement(statement);
break;

case "TryStatement":
this.preWalkTryStatement(statement);
break;

case "VariableDeclaration":
this.preWalkVariableDeclaration(statement);
break;

case "WhileStatement":
this.preWalkWhileStatement(statement);
break;

case "WithStatement":
this.preWalkWithStatement(statement);
}
this.prevStatement = this.statementPath.pop();
}
}
blockPreWalkStatement(statement) {
if (this.statementPath.push(statement), this.hooks.blockPreStatement.call(statement)) this.prevStatement = this.statementPath.pop(); else {
switch (statement.type) {
case "ImportDeclaration":
this.blockPreWalkImportDeclaration(statement);
break;

case "ExportAllDeclaration":
this.blockPreWalkExportAllDeclaration(statement);
break;

case "ExportDefaultDeclaration":
this.blockPreWalkExportDefaultDeclaration(statement);
break;

case "ExportNamedDeclaration":
this.blockPreWalkExportNamedDeclaration(statement);
break;

case "VariableDeclaration":
this.blockPreWalkVariableDeclaration(statement);
break;

case "ClassDeclaration":
this.blockPreWalkClassDeclaration(statement);
}
this.prevStatement = this.statementPath.pop();
}
}
walkStatement(statement) {
if (this.statementPath.push(statement), void 0 === this.hooks.statement.call(statement)) {
switch (statement.type) {
case "BlockStatement":
this.walkBlockStatement(statement);
break;

case "ClassDeclaration":
this.walkClassDeclaration(statement);
break;

case "DoWhileStatement":
this.walkDoWhileStatement(statement);
break;

case "ExportDefaultDeclaration":
this.walkExportDefaultDeclaration(statement);
break;

case "ExportNamedDeclaration":
this.walkExportNamedDeclaration(statement);
break;

case "ExpressionStatement":
this.walkExpressionStatement(statement);
break;

case "ForInStatement":
this.walkForInStatement(statement);
break;

case "ForOfStatement":
this.walkForOfStatement(statement);
break;

case "ForStatement":
this.walkForStatement(statement);
break;

case "FunctionDeclaration":
this.walkFunctionDeclaration(statement);
break;

case "IfStatement":
this.walkIfStatement(statement);
break;

case "LabeledStatement":
this.walkLabeledStatement(statement);
break;

case "ReturnStatement":
this.walkReturnStatement(statement);
break;

case "SwitchStatement":
this.walkSwitchStatement(statement);
break;

case "ThrowStatement":
this.walkThrowStatement(statement);
break;

case "TryStatement":
this.walkTryStatement(statement);
break;

case "VariableDeclaration":
this.walkVariableDeclaration(statement);
break;

case "WhileStatement":
this.walkWhileStatement(statement);
break;

case "WithStatement":
this.walkWithStatement(statement);
}
this.prevStatement = this.statementPath.pop();
} else this.prevStatement = this.statementPath.pop();
}
walkNestedStatement(statement) {
this.prevStatement = void 0, this.walkStatement(statement);
}
preWalkBlockStatement(statement) {
this.preWalkStatements(statement.body);
}
walkBlockStatement(statement) {
this.inBlockScope((() => {
const body = statement.body, prev = this.prevStatement;
this.blockPreWalkStatements(body), this.prevStatement = prev, this.walkStatements(body);
}));
}
walkExpressionStatement(statement) {
this.walkExpression(statement.expression);
}
preWalkIfStatement(statement) {
this.preWalkStatement(statement.consequent), statement.alternate && this.preWalkStatement(statement.alternate);
}
walkIfStatement(statement) {
const result = this.hooks.statementIf.call(statement);
void 0 === result ? (this.walkExpression(statement.test), this.walkNestedStatement(statement.consequent), 
statement.alternate && this.walkNestedStatement(statement.alternate)) : result ? this.walkNestedStatement(statement.consequent) : statement.alternate && this.walkNestedStatement(statement.alternate);
}
preWalkLabeledStatement(statement) {
this.preWalkStatement(statement.body);
}
walkLabeledStatement(statement) {
const hook = this.hooks.label.get(statement.label.name);
if (void 0 !== hook) {
if (!0 === hook.call(statement)) return;
}
this.walkNestedStatement(statement.body);
}
preWalkWithStatement(statement) {
this.preWalkStatement(statement.body);
}
walkWithStatement(statement) {
this.walkExpression(statement.object), this.walkNestedStatement(statement.body);
}
preWalkSwitchStatement(statement) {
this.preWalkSwitchCases(statement.cases);
}
walkSwitchStatement(statement) {
this.walkExpression(statement.discriminant), this.walkSwitchCases(statement.cases);
}
walkTerminatingStatement(statement) {
statement.argument && this.walkExpression(statement.argument);
}
walkReturnStatement(statement) {
this.walkTerminatingStatement(statement);
}
walkThrowStatement(statement) {
this.walkTerminatingStatement(statement);
}
preWalkTryStatement(statement) {
this.preWalkStatement(statement.block), statement.handler && this.preWalkCatchClause(statement.handler), 
statement.finializer && this.preWalkStatement(statement.finializer);
}
walkTryStatement(statement) {
this.scope.inTry ? this.walkStatement(statement.block) : (this.scope.inTry = !0, 
this.walkStatement(statement.block), this.scope.inTry = !1), statement.handler && this.walkCatchClause(statement.handler), 
statement.finalizer && this.walkStatement(statement.finalizer);
}
preWalkWhileStatement(statement) {
this.preWalkStatement(statement.body);
}
walkWhileStatement(statement) {
this.walkExpression(statement.test), this.walkNestedStatement(statement.body);
}
preWalkDoWhileStatement(statement) {
this.preWalkStatement(statement.body);
}
walkDoWhileStatement(statement) {
this.walkNestedStatement(statement.body), this.walkExpression(statement.test);
}
preWalkForStatement(statement) {
statement.init && "VariableDeclaration" === statement.init.type && this.preWalkStatement(statement.init), 
this.preWalkStatement(statement.body);
}
walkForStatement(statement) {
this.inBlockScope((() => {
statement.init && ("VariableDeclaration" === statement.init.type ? (this.blockPreWalkVariableDeclaration(statement.init), 
this.prevStatement = void 0, this.walkStatement(statement.init)) : this.walkExpression(statement.init)), 
statement.test && this.walkExpression(statement.test), statement.update && this.walkExpression(statement.update);
const body = statement.body;
if ("BlockStatement" === body.type) {
const prev = this.prevStatement;
this.blockPreWalkStatements(body.body), this.prevStatement = prev, this.walkStatements(body.body);
} else this.walkNestedStatement(body);
}));
}
preWalkForInStatement(statement) {
"VariableDeclaration" === statement.left.type && this.preWalkVariableDeclaration(statement.left), 
this.preWalkStatement(statement.body);
}
walkForInStatement(statement) {
this.inBlockScope((() => {
"VariableDeclaration" === statement.left.type ? (this.blockPreWalkVariableDeclaration(statement.left), 
this.walkVariableDeclaration(statement.left)) : this.walkPattern(statement.left), 
this.walkExpression(statement.right);
const body = statement.body;
if ("BlockStatement" === body.type) {
const prev = this.prevStatement;
this.blockPreWalkStatements(body.body), this.prevStatement = prev, this.walkStatements(body.body);
} else this.walkNestedStatement(body);
}));
}
preWalkForOfStatement(statement) {
statement.await && !0 === this.scope.topLevelScope && this.hooks.topLevelAwait.call(statement), 
"VariableDeclaration" === statement.left.type && this.preWalkVariableDeclaration(statement.left), 
this.preWalkStatement(statement.body);
}
walkForOfStatement(statement) {
this.inBlockScope((() => {
"VariableDeclaration" === statement.left.type ? (this.blockPreWalkVariableDeclaration(statement.left), 
this.walkVariableDeclaration(statement.left)) : this.walkPattern(statement.left), 
this.walkExpression(statement.right);
const body = statement.body;
if ("BlockStatement" === body.type) {
const prev = this.prevStatement;
this.blockPreWalkStatements(body.body), this.prevStatement = prev, this.walkStatements(body.body);
} else this.walkNestedStatement(body);
}));
}
preWalkFunctionDeclaration(statement) {
statement.id && this.defineVariable(statement.id.name);
}
walkFunctionDeclaration(statement) {
const wasTopLevel = this.scope.topLevelScope;
this.scope.topLevelScope = !1, this.inFunctionScope(!0, statement.params, (() => {
for (const param of statement.params) this.walkPattern(param);
if ("BlockStatement" === statement.body.type) {
this.detectMode(statement.body.body);
const prev = this.prevStatement;
this.preWalkStatement(statement.body), this.prevStatement = prev, this.walkStatement(statement.body);
} else this.walkExpression(statement.body);
})), this.scope.topLevelScope = wasTopLevel;
}
blockPreWalkImportDeclaration(statement) {
const source = statement.source.value;
this.hooks.import.call(statement, source);
for (const specifier of statement.specifiers) {
const name = specifier.local.name;
switch (specifier.type) {
case "ImportDefaultSpecifier":
this.hooks.importSpecifier.call(statement, source, "default", name) || this.defineVariable(name);
break;

case "ImportSpecifier":
this.hooks.importSpecifier.call(statement, source, specifier.imported.name || specifier.imported.value, name) || this.defineVariable(name);
break;

case "ImportNamespaceSpecifier":
this.hooks.importSpecifier.call(statement, source, null, name) || this.defineVariable(name);
break;

default:
this.defineVariable(name);
}
}
}
enterDeclaration(declaration, onIdent) {
switch (declaration.type) {
case "VariableDeclaration":
for (const declarator of declaration.declarations) if ("VariableDeclarator" === declarator.type) this.enterPattern(declarator.id, onIdent);
break;

case "FunctionDeclaration":
case "ClassDeclaration":
this.enterPattern(declaration.id, onIdent);
}
}
blockPreWalkExportNamedDeclaration(statement) {
let source;
if (statement.source ? (source = statement.source.value, this.hooks.exportImport.call(statement, source)) : this.hooks.export.call(statement), 
statement.declaration && !this.hooks.exportDeclaration.call(statement, statement.declaration)) {
const prev = this.prevStatement;
this.preWalkStatement(statement.declaration), this.prevStatement = prev, this.blockPreWalkStatement(statement.declaration);
let index = 0;
this.enterDeclaration(statement.declaration, (def => {
this.hooks.exportSpecifier.call(statement, def, def, index++);
}));
}
if (statement.specifiers) for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {
const specifier = statement.specifiers[specifierIndex];
switch (specifier.type) {
case "ExportSpecifier":
{
const name = specifier.exported.name || specifier.exported.value;
source ? this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex) : this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);
break;
}
}
}
}
walkExportNamedDeclaration(statement) {
statement.declaration && this.walkStatement(statement.declaration);
}
blockPreWalkExportDefaultDeclaration(statement) {
const prev = this.prevStatement;
this.preWalkStatement(statement.declaration), this.prevStatement = prev, this.blockPreWalkStatement(statement.declaration), 
statement.declaration.id && "FunctionExpression" !== statement.declaration.type && "ClassExpression" !== statement.declaration.type && this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, "default", void 0);
}
walkExportDefaultDeclaration(statement) {
this.hooks.export.call(statement), statement.declaration.id && "FunctionExpression" !== statement.declaration.type && "ClassExpression" !== statement.declaration.type ? this.hooks.exportDeclaration.call(statement, statement.declaration) || this.walkStatement(statement.declaration) : ("FunctionDeclaration" === statement.declaration.type || "ClassDeclaration" === statement.declaration.type ? this.walkStatement(statement.declaration) : this.walkExpression(statement.declaration), 
this.hooks.exportExpression.call(statement, statement.declaration) || this.hooks.exportSpecifier.call(statement, statement.declaration, "default", void 0));
}
blockPreWalkExportAllDeclaration(statement) {
const source = statement.source.value, name = statement.exported ? statement.exported.name : null;
this.hooks.exportImport.call(statement, source), this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);
}
preWalkVariableDeclaration(statement) {
"var" === statement.kind && this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);
}
blockPreWalkVariableDeclaration(statement) {
if ("var" === statement.kind) return;
const hookMap = "const" === statement.kind ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;
this._preWalkVariableDeclaration(statement, hookMap);
}
_preWalkVariableDeclaration(statement, hookMap) {
for (const declarator of statement.declarations) if ("VariableDeclarator" === declarator.type) this.hooks.preDeclarator.call(declarator, statement) || this.enterPattern(declarator.id, ((name, decl) => {
let hook = hookMap.get(name);
void 0 !== hook && hook.call(decl) || (hook = this.hooks.varDeclaration.get(name), 
void 0 !== hook && hook.call(decl) || this.defineVariable(name));
}));
}
walkVariableDeclaration(statement) {
for (const declarator of statement.declarations) switch (declarator.type) {
case "VariableDeclarator":
{
const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);
if (renameIdentifier && "Identifier" === declarator.id.type) {
const hook = this.hooks.canRename.get(renameIdentifier);
if (void 0 !== hook && hook.call(declarator.init)) {
const hook = this.hooks.rename.get(renameIdentifier);
void 0 !== hook && hook.call(declarator.init) || this.setVariable(declarator.id.name, renameIdentifier);
break;
}
}
this.hooks.declarator.call(declarator, statement) || (this.walkPattern(declarator.id), 
declarator.init && this.walkExpression(declarator.init));
break;
}
}
}
blockPreWalkClassDeclaration(statement) {
statement.id && this.defineVariable(statement.id.name);
}
walkClassDeclaration(statement) {
this.walkClass(statement);
}
preWalkSwitchCases(switchCases) {
for (let index = 0, len = switchCases.length; index < len; index++) {
const switchCase = switchCases[index];
this.preWalkStatements(switchCase.consequent);
}
}
walkSwitchCases(switchCases) {
this.inBlockScope((() => {
const len = switchCases.length;
for (let index = 0; index < len; index++) {
const switchCase = switchCases[index];
if (switchCase.consequent.length > 0) {
const prev = this.prevStatement;
this.blockPreWalkStatements(switchCase.consequent), this.prevStatement = prev;
}
}
for (let index = 0; index < len; index++) {
const switchCase = switchCases[index];
switchCase.test && this.walkExpression(switchCase.test), switchCase.consequent.length > 0 && this.walkStatements(switchCase.consequent);
}
}));
}
preWalkCatchClause(catchClause) {
this.preWalkStatement(catchClause.body);
}
walkCatchClause(catchClause) {
this.inBlockScope((() => {
null !== catchClause.param && (this.enterPattern(catchClause.param, (ident => {
this.defineVariable(ident);
})), this.walkPattern(catchClause.param));
const prev = this.prevStatement;
this.blockPreWalkStatement(catchClause.body), this.prevStatement = prev, this.walkStatement(catchClause.body);
}));
}
walkPattern(pattern) {
switch (pattern.type) {
case "ArrayPattern":
this.walkArrayPattern(pattern);
break;

case "AssignmentPattern":
this.walkAssignmentPattern(pattern);
break;

case "MemberExpression":
this.walkMemberExpression(pattern);
break;

case "ObjectPattern":
this.walkObjectPattern(pattern);
break;

case "RestElement":
this.walkRestElement(pattern);
}
}
walkAssignmentPattern(pattern) {
this.walkExpression(pattern.right), this.walkPattern(pattern.left);
}
walkObjectPattern(pattern) {
for (let i = 0, len = pattern.properties.length; i < len; i++) {
const prop = pattern.properties[i];
prop && (prop.computed && this.walkExpression(prop.key), prop.value && this.walkPattern(prop.value));
}
}
walkArrayPattern(pattern) {
for (let i = 0, len = pattern.elements.length; i < len; i++) {
const element = pattern.elements[i];
element && this.walkPattern(element);
}
}
walkRestElement(pattern) {
this.walkPattern(pattern.argument);
}
walkExpressions(expressions) {
for (const expression of expressions) expression && this.walkExpression(expression);
}
walkExpression(expression) {
switch (expression.type) {
case "ArrayExpression":
this.walkArrayExpression(expression);
break;

case "ArrowFunctionExpression":
this.walkArrowFunctionExpression(expression);
break;

case "AssignmentExpression":
this.walkAssignmentExpression(expression);
break;

case "AwaitExpression":
this.walkAwaitExpression(expression);
break;

case "BinaryExpression":
this.walkBinaryExpression(expression);
break;

case "CallExpression":
this.walkCallExpression(expression);
break;

case "ChainExpression":
this.walkChainExpression(expression);
break;

case "ClassExpression":
this.walkClassExpression(expression);
break;

case "ConditionalExpression":
this.walkConditionalExpression(expression);
break;

case "FunctionExpression":
this.walkFunctionExpression(expression);
break;

case "Identifier":
this.walkIdentifier(expression);
break;

case "ImportExpression":
this.walkImportExpression(expression);
break;

case "LogicalExpression":
this.walkLogicalExpression(expression);
break;

case "MetaProperty":
this.walkMetaProperty(expression);
break;

case "MemberExpression":
this.walkMemberExpression(expression);
break;

case "NewExpression":
this.walkNewExpression(expression);
break;

case "ObjectExpression":
this.walkObjectExpression(expression);
break;

case "SequenceExpression":
this.walkSequenceExpression(expression);
break;

case "SpreadElement":
this.walkSpreadElement(expression);
break;

case "TaggedTemplateExpression":
this.walkTaggedTemplateExpression(expression);
break;

case "TemplateLiteral":
this.walkTemplateLiteral(expression);
break;

case "ThisExpression":
this.walkThisExpression(expression);
break;

case "UnaryExpression":
this.walkUnaryExpression(expression);
break;

case "UpdateExpression":
this.walkUpdateExpression(expression);
break;

case "YieldExpression":
this.walkYieldExpression(expression);
}
}
walkAwaitExpression(expression) {
!0 === this.scope.topLevelScope && this.hooks.topLevelAwait.call(expression), this.walkExpression(expression.argument);
}
walkArrayExpression(expression) {
expression.elements && this.walkExpressions(expression.elements);
}
walkSpreadElement(expression) {
expression.argument && this.walkExpression(expression.argument);
}
walkObjectExpression(expression) {
for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {
const prop = expression.properties[propIndex];
this.walkProperty(prop);
}
}
walkProperty(prop) {
"SpreadElement" !== prop.type ? (prop.computed && this.walkExpression(prop.key), 
prop.shorthand && prop.value && "Identifier" === prop.value.type ? (this.scope.inShorthand = prop.value.name, 
this.walkIdentifier(prop.value), this.scope.inShorthand = !1) : this.walkExpression(prop.value)) : this.walkExpression(prop.argument);
}
walkFunctionExpression(expression) {
const wasTopLevel = this.scope.topLevelScope;
this.scope.topLevelScope = !1;
const scopeParams = expression.params;
expression.id && scopeParams.push(expression.id.name), this.inFunctionScope(!0, scopeParams, (() => {
for (const param of expression.params) this.walkPattern(param);
if ("BlockStatement" === expression.body.type) {
this.detectMode(expression.body.body);
const prev = this.prevStatement;
this.preWalkStatement(expression.body), this.prevStatement = prev, this.walkStatement(expression.body);
} else this.walkExpression(expression.body);
})), this.scope.topLevelScope = wasTopLevel;
}
walkArrowFunctionExpression(expression) {
const wasTopLevel = this.scope.topLevelScope;
this.scope.topLevelScope = !!wasTopLevel && "arrow", this.inFunctionScope(!1, expression.params, (() => {
for (const param of expression.params) this.walkPattern(param);
if ("BlockStatement" === expression.body.type) {
this.detectMode(expression.body.body);
const prev = this.prevStatement;
this.preWalkStatement(expression.body), this.prevStatement = prev, this.walkStatement(expression.body);
} else this.walkExpression(expression.body);
})), this.scope.topLevelScope = wasTopLevel;
}
walkSequenceExpression(expression) {
if (!expression.expressions) return;
const currentStatement = this.statementPath[this.statementPath.length - 1];
if (currentStatement === expression || "ExpressionStatement" === currentStatement.type && currentStatement.expression === expression) {
const old = this.statementPath.pop();
for (const expr of expression.expressions) this.statementPath.push(expr), this.walkExpression(expr), 
this.statementPath.pop();
this.statementPath.push(old);
} else this.walkExpressions(expression.expressions);
}
walkUpdateExpression(expression) {
this.walkExpression(expression.argument);
}
walkUnaryExpression(expression) {
if ("typeof" === expression.operator) {
if (!0 === this.callHooksForExpression(this.hooks.typeof, expression.argument, expression)) return;
if ("ChainExpression" === expression.argument.type) {
if (!0 === this.callHooksForExpression(this.hooks.typeof, expression.argument.expression, expression)) return;
}
}
this.walkExpression(expression.argument);
}
walkLeftRightExpression(expression) {
this.walkExpression(expression.left), this.walkExpression(expression.right);
}
walkBinaryExpression(expression) {
void 0 === this.hooks.binaryExpression.call(expression) && this.walkLeftRightExpression(expression);
}
walkLogicalExpression(expression) {
const result = this.hooks.expressionLogicalOperator.call(expression);
void 0 === result ? this.walkLeftRightExpression(expression) : result && this.walkExpression(expression.right);
}
walkAssignmentExpression(expression) {
if ("Identifier" === expression.left.type) {
const renameIdentifier = this.getRenameIdentifier(expression.right);
return renameIdentifier && this.callHooksForInfo(this.hooks.canRename, renameIdentifier, expression.right) ? void (this.callHooksForInfo(this.hooks.rename, renameIdentifier, expression.right) || this.setVariable(expression.left.name, "string" == typeof renameIdentifier ? this.getVariableInfo(renameIdentifier) : renameIdentifier)) : (this.walkExpression(expression.right), 
void this.enterPattern(expression.left, ((name, decl) => {
this.callHooksForName(this.hooks.assign, name, expression) || this.walkExpression(expression.left);
})));
}
if (expression.left.type.endsWith("Pattern")) this.walkExpression(expression.right), 
this.enterPattern(expression.left, ((name, decl) => {
this.callHooksForName(this.hooks.assign, name, expression) || this.defineVariable(name);
})), this.walkPattern(expression.left); else if ("MemberExpression" === expression.left.type) {
const exprName = this.getMemberExpressionInfo(expression.left, 2);
if (exprName && this.callHooksForInfo(this.hooks.assignMemberChain, exprName.rootInfo, expression, exprName.getMembers())) return;
this.walkExpression(expression.right), this.walkExpression(expression.left);
} else this.walkExpression(expression.right), this.walkExpression(expression.left);
}
walkConditionalExpression(expression) {
const result = this.hooks.expressionConditionalOperator.call(expression);
void 0 === result ? (this.walkExpression(expression.test), this.walkExpression(expression.consequent), 
expression.alternate && this.walkExpression(expression.alternate)) : result ? this.walkExpression(expression.consequent) : expression.alternate && this.walkExpression(expression.alternate);
}
walkNewExpression(expression) {
!0 !== this.callHooksForExpression(this.hooks.new, expression.callee, expression) && (this.walkExpression(expression.callee), 
expression.arguments && this.walkExpressions(expression.arguments));
}
walkYieldExpression(expression) {
expression.argument && this.walkExpression(expression.argument);
}
walkTemplateLiteral(expression) {
expression.expressions && this.walkExpressions(expression.expressions);
}
walkTaggedTemplateExpression(expression) {
expression.tag && this.walkExpression(expression.tag), expression.quasi && expression.quasi.expressions && this.walkExpressions(expression.quasi.expressions);
}
walkClassExpression(expression) {
this.walkClass(expression);
}
walkChainExpression(expression) {
void 0 === this.hooks.optionalChaining.call(expression) && ("CallExpression" === expression.expression.type ? this.walkCallExpression(expression.expression) : this.walkMemberExpression(expression.expression));
}
_walkIIFE(functionExpression, options, currentThis) {
const getVarInfo = argOrThis => {
const renameIdentifier = this.getRenameIdentifier(argOrThis);
if (renameIdentifier && this.callHooksForInfo(this.hooks.canRename, renameIdentifier, argOrThis) && !this.callHooksForInfo(this.hooks.rename, renameIdentifier, argOrThis)) return "string" == typeof renameIdentifier ? this.getVariableInfo(renameIdentifier) : renameIdentifier;
this.walkExpression(argOrThis);
}, {params, type} = functionExpression, arrow = "ArrowFunctionExpression" === type, renameThis = currentThis ? getVarInfo(currentThis) : null, varInfoForArgs = options.map(getVarInfo), wasTopLevel = this.scope.topLevelScope;
this.scope.topLevelScope = !(!wasTopLevel || !arrow) && "arrow";
const scopeParams = params.filter(((identifier, idx) => !varInfoForArgs[idx]));
functionExpression.id && scopeParams.push(functionExpression.id.name), this.inFunctionScope(!0, scopeParams, (() => {
renameThis && !arrow && this.setVariable("this", renameThis);
for (let i = 0; i < varInfoForArgs.length; i++) {
const varInfo = varInfoForArgs[i];
varInfo && (params[i] && "Identifier" === params[i].type && this.setVariable(params[i].name, varInfo));
}
if ("BlockStatement" === functionExpression.body.type) {
this.detectMode(functionExpression.body.body);
const prev = this.prevStatement;
this.preWalkStatement(functionExpression.body), this.prevStatement = prev, this.walkStatement(functionExpression.body);
} else this.walkExpression(functionExpression.body);
})), this.scope.topLevelScope = wasTopLevel;
}
walkImportExpression(expression) {
!0 !== this.hooks.importCall.call(expression) && this.walkExpression(expression.source);
}
walkCallExpression(expression) {
const isSimpleFunction = fn => fn.params.every((p => "Identifier" === p.type));
if ("MemberExpression" === expression.callee.type && expression.callee.object.type.endsWith("FunctionExpression") && !expression.callee.computed && ("call" === expression.callee.property.name || "bind" === expression.callee.property.name) && expression.arguments.length > 0 && isSimpleFunction(expression.callee.object)) this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]); else if (expression.callee.type.endsWith("FunctionExpression") && isSimpleFunction(expression.callee)) this._walkIIFE(expression.callee, expression.arguments, null); else {
if ("MemberExpression" === expression.callee.type) {
const exprInfo = this.getMemberExpressionInfo(expression.callee, 1);
if (exprInfo && "call" === exprInfo.type) {
if (!0 === this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers())) return;
}
}
const callee = this.evaluateExpression(expression.callee);
if (callee.isIdentifier()) {
if (!0 === this.callHooksForInfo(this.hooks.callMemberChain, callee.rootInfo, expression, callee.getMembers(), callee.getMembersOptionals ? callee.getMembersOptionals() : callee.getMembers().map((() => !1)))) return;
if (!0 === this.callHooksForInfo(this.hooks.call, callee.identifier, expression)) return;
}
expression.callee && ("MemberExpression" === expression.callee.type ? (this.walkExpression(expression.callee.object), 
!0 === expression.callee.computed && this.walkExpression(expression.callee.property)) : this.walkExpression(expression.callee)), 
expression.arguments && this.walkExpressions(expression.arguments);
}
}
walkMemberExpression(expression) {
const exprInfo = this.getMemberExpressionInfo(expression, 3);
if (exprInfo) switch (exprInfo.type) {
case "expression":
{
if (!0 === this.callHooksForInfo(this.hooks.expression, exprInfo.name, expression)) return;
const members = exprInfo.getMembers(), membersOptionals = exprInfo.getMembersOptionals();
if (!0 === this.callHooksForInfo(this.hooks.expressionMemberChain, exprInfo.rootInfo, expression, members, membersOptionals)) return;
return void this.walkMemberExpressionWithExpressionName(expression, exprInfo.name, exprInfo.rootInfo, members.slice(), (() => this.callHooksForInfo(this.hooks.unhandledExpressionMemberChain, exprInfo.rootInfo, expression, members)));
}

case "call":
if (!0 === this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers())) return;
return void this.walkExpression(exprInfo.call);
}
this.walkExpression(expression.object), !0 === expression.computed && this.walkExpression(expression.property);
}
walkMemberExpressionWithExpressionName(expression, name, rootInfo, members, onUnhandled) {
if ("MemberExpression" === expression.object.type) {
const property = expression.property.name || `${expression.property.value}`;
name = name.slice(0, -property.length - 1), members.pop();
if (!0 === this.callHooksForInfo(this.hooks.expression, name, expression.object)) return;
this.walkMemberExpressionWithExpressionName(expression.object, name, rootInfo, members, onUnhandled);
} else onUnhandled && onUnhandled() || this.walkExpression(expression.object);
!0 === expression.computed && this.walkExpression(expression.property);
}
walkThisExpression(expression) {
this.callHooksForName(this.hooks.expression, "this", expression);
}
walkIdentifier(expression) {
this.callHooksForName(this.hooks.expression, expression.name, expression);
}
walkMetaProperty(metaProperty) {
this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);
}
callHooksForExpression(hookMap, expr, ...args) {
return this.callHooksForExpressionWithFallback(hookMap, expr, void 0, void 0, ...args);
}
callHooksForExpressionWithFallback(hookMap, expr, fallback, defined, ...args) {
const exprName = this.getMemberExpressionInfo(expr, 2);
if (void 0 !== exprName) {
const members = exprName.getMembers();
return this.callHooksForInfoWithFallback(hookMap, 0 === members.length ? exprName.rootInfo : exprName.name, fallback && (name => fallback(name, exprName.rootInfo, exprName.getMembers)), defined && (() => defined(exprName.name)), ...args);
}
}
callHooksForName(hookMap, name, ...args) {
return this.callHooksForNameWithFallback(hookMap, name, void 0, void 0, ...args);
}
callHooksForInfo(hookMap, info, ...args) {
return this.callHooksForInfoWithFallback(hookMap, info, void 0, void 0, ...args);
}
callHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {
let name;
if ("string" == typeof info) name = info; else {
if (!(info instanceof VariableInfo)) return void 0 !== defined ? defined() : void 0;
let tagInfo = info.tagInfo;
for (;void 0 !== tagInfo; ) {
const hook = hookMap.get(tagInfo.tag);
if (void 0 !== hook) {
this.currentTagData = tagInfo.data;
const result = hook.call(...args);
if (this.currentTagData = void 0, void 0 !== result) return result;
}
tagInfo = tagInfo.next;
}
if (!0 === info.freeName) return void 0 !== defined ? defined() : void 0;
name = info.freeName;
}
const hook = hookMap.get(name);
if (void 0 !== hook) {
const result = hook.call(...args);
if (void 0 !== result) return result;
}
if (void 0 !== fallback) return fallback(name);
}
callHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {
return this.callHooksForInfoWithFallback(hookMap, this.getVariableInfo(name), fallback, defined, ...args);
}
inScope(params, fn) {
const oldScope = this.scope;
this.scope = {
topLevelScope: oldScope.topLevelScope,
inTry: !1,
inShorthand: !1,
isStrict: oldScope.isStrict,
isAsmJs: oldScope.isAsmJs,
definitions: oldScope.definitions.createChild()
}, this.undefineVariable("this"), this.enterPatterns(params, ((ident, pattern) => {
this.defineVariable(ident);
})), fn(), this.scope = oldScope;
}
inFunctionScope(hasThis, params, fn) {
const oldScope = this.scope;
this.scope = {
topLevelScope: oldScope.topLevelScope,
inTry: !1,
inShorthand: !1,
isStrict: oldScope.isStrict,
isAsmJs: oldScope.isAsmJs,
definitions: oldScope.definitions.createChild()
}, hasThis && this.undefineVariable("this"), this.enterPatterns(params, ((ident, pattern) => {
this.defineVariable(ident);
})), fn(), this.scope = oldScope;
}
inBlockScope(fn) {
const oldScope = this.scope;
this.scope = {
topLevelScope: oldScope.topLevelScope,
inTry: oldScope.inTry,
inShorthand: !1,
isStrict: oldScope.isStrict,
isAsmJs: oldScope.isAsmJs,
definitions: oldScope.definitions.createChild()
}, fn(), this.scope = oldScope;
}
detectMode(statements) {
const isLiteral = statements.length >= 1 && "ExpressionStatement" === statements[0].type && "Literal" === statements[0].expression.type;
isLiteral && "use strict" === statements[0].expression.value && (this.scope.isStrict = !0), 
isLiteral && "use asm" === statements[0].expression.value && (this.scope.isAsmJs = !0);
}
enterPatterns(patterns, onIdent) {
for (const pattern of patterns) "string" != typeof pattern ? this.enterPattern(pattern, onIdent) : pattern && onIdent(pattern);
}
enterPattern(pattern, onIdent) {
if (pattern) switch (pattern.type) {
case "ArrayPattern":
this.enterArrayPattern(pattern, onIdent);
break;

case "AssignmentPattern":
this.enterAssignmentPattern(pattern, onIdent);
break;

case "Identifier":
this.enterIdentifier(pattern, onIdent);
break;

case "ObjectPattern":
this.enterObjectPattern(pattern, onIdent);
break;

case "RestElement":
this.enterRestElement(pattern, onIdent);
break;

case "Property":
pattern.shorthand && "Identifier" === pattern.value.type ? (this.scope.inShorthand = pattern.value.name, 
this.enterIdentifier(pattern.value, onIdent), this.scope.inShorthand = !1) : this.enterPattern(pattern.value, onIdent);
}
}
enterIdentifier(pattern, onIdent) {
this.callHooksForName(this.hooks.pattern, pattern.name, pattern) || onIdent(pattern.name, pattern);
}
enterObjectPattern(pattern, onIdent) {
for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {
const prop = pattern.properties[propIndex];
this.enterPattern(prop, onIdent);
}
}
enterArrayPattern(pattern, onIdent) {
for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {
const element = pattern.elements[elementIndex];
this.enterPattern(element, onIdent);
}
}
enterRestElement(pattern, onIdent) {
this.enterPattern(pattern.argument, onIdent);
}
enterAssignmentPattern(pattern, onIdent) {
this.enterPattern(pattern.left, onIdent);
}
evaluateExpression(expression) {
try {
const hook = this.hooks.evaluate.get(expression.type);
if (void 0 !== hook) {
const result = hook.call(expression);
if (null != result) return result.setExpression(expression), result;
}
} catch (e) {
console.warn(e);
}
return (new BasicEvaluatedExpression).setRange(expression.range).setExpression(expression);
}
parseString(expression) {
switch (expression.type) {
case "BinaryExpression":
if ("+" === expression.operator) return this.parseString(expression.left) + this.parseString(expression.right);
break;

case "Literal":
return expression.value + "";
}
throw new Error(expression.type + " is not supported as parameter for require");
}
parseCalculatedString(expression) {
switch (expression.type) {
case "BinaryExpression":
if ("+" === expression.operator) {
const left = this.parseCalculatedString(expression.left), right = this.parseCalculatedString(expression.right);
return left.code ? {
range: left.range,
value: left.value,
code: !0,
conditional: !1
} : right.code ? {
range: [ left.range[0], right.range ? right.range[1] : left.range[1] ],
value: left.value + right.value,
code: !0,
conditional: !1
} : {
range: [ left.range[0], right.range[1] ],
value: left.value + right.value,
code: !1,
conditional: !1
};
}
break;

case "ConditionalExpression":
{
const consequent = this.parseCalculatedString(expression.consequent), alternate = this.parseCalculatedString(expression.alternate), items = [];
if (consequent.conditional) items.push(...consequent.conditional); else {
if (consequent.code) break;
items.push(consequent);
}
if (alternate.conditional) items.push(...alternate.conditional); else {
if (alternate.code) break;
items.push(alternate);
}
return {
range: void 0,
value: "",
code: !0,
conditional: items
};
}

case "Literal":
return {
range: expression.range,
value: expression.value + "",
code: !1,
conditional: !1
};
}
return {
range: void 0,
value: "",
code: !0,
conditional: !1
};
}
parse(source, state) {
let ast, comments;
const semicolons = new Set;
if (null === source) throw new Error("source must not be null");
Buffer.isBuffer(source) && (source = source.toString("utf-8")), "object" == typeof source ? (ast = source, 
comments = source.comments) : (comments = [], ast = JavascriptParser._parse(source, {
sourceType: this.sourceType,
onComment: comments,
onInsertedSemicolon: pos => semicolons.add(pos)
}));
const oldScope = this.scope, oldState = this.state, oldComments = this.comments, oldSemicolons = this.semicolons, oldStatementPath = this.statementPath, oldPrevStatement = this.prevStatement;
return this.scope = {
topLevelScope: !0,
inTry: !1,
inShorthand: !1,
isStrict: !1,
isAsmJs: !1,
definitions: new StackedMap
}, this.state = state, this.comments = comments, this.semicolons = semicolons, this.statementPath = [], 
this.prevStatement = void 0, void 0 === this.hooks.program.call(ast, comments) && (this.detectMode(ast.body), 
this.preWalkStatements(ast.body), this.prevStatement = void 0, this.blockPreWalkStatements(ast.body), 
this.prevStatement = void 0, this.walkStatements(ast.body)), this.hooks.finish.call(ast, comments), 
this.scope = oldScope, this.state = oldState, this.comments = oldComments, this.semicolons = oldSemicolons, 
this.statementPath = oldStatementPath, this.prevStatement = oldPrevStatement, state;
}
evaluate(source) {
const ast = JavascriptParser._parse("(" + source + ")", {
sourceType: this.sourceType,
locations: !1
});
if (1 !== ast.body.length || "ExpressionStatement" !== ast.body[0].type) throw new Error("evaluate: Source is not a expression");
return this.evaluateExpression(ast.body[0].expression);
}
isPure(expr, commentsStartPos) {
if (!expr) return !0;
const result = this.hooks.isPure.for(expr.type).call(expr, commentsStartPos);
if ("boolean" == typeof result) return result;
switch (expr.type) {
case "ClassDeclaration":
case "ClassExpression":
if ("ClassBody" !== expr.body.type) return !1;
if (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) return !1;
return expr.body.body.every((item => (!item.computed || !item.key || this.isPure(item.key, item.range[0])) && (!item.static || !item.value || this.isPure(item.value, item.key ? item.key.range[1] : item.range[0]))));

case "FunctionDeclaration":
case "FunctionExpression":
case "ArrowFunctionExpression":
case "Literal":
case "PrivateIdentifier":
return !0;

case "VariableDeclaration":
return expr.declarations.every((decl => this.isPure(decl.init, decl.range[0])));

case "ConditionalExpression":
return this.isPure(expr.test, commentsStartPos) && this.isPure(expr.consequent, expr.test.range[1]) && this.isPure(expr.alternate, expr.consequent.range[1]);

case "SequenceExpression":
return expr.expressions.every((expr => {
const pureFlag = this.isPure(expr, commentsStartPos);
return commentsStartPos = expr.range[1], pureFlag;
}));

case "CallExpression":
return !!(expr.range[0] - commentsStartPos > 12 && this.getComments([ commentsStartPos, expr.range[0] ]).some((comment => "Block" === comment.type && /^\s*(#|@)__PURE__\s*$/.test(comment.value)))) && (commentsStartPos = expr.callee.range[1], 
expr.arguments.every((arg => {
if ("SpreadElement" === arg.type) return !1;
const pureFlag = this.isPure(arg, commentsStartPos);
return commentsStartPos = arg.range[1], pureFlag;
})));
}
return !this.evaluateExpression(expr).couldHaveSideEffects();
}
getComments(range) {
const [rangeStart, rangeEnd] = range;
let idx = binarySearchBounds.ge(this.comments, rangeStart, ((comment, needle) => comment.range[0] - needle)), commentsInRange = [];
for (;this.comments[idx] && this.comments[idx].range[1] <= rangeEnd; ) commentsInRange.push(this.comments[idx]), 
idx++;
return commentsInRange;
}
isAsiPosition(pos) {
const currentStatement = this.statementPath[this.statementPath.length - 1];
if (void 0 === currentStatement) throw new Error("Not in statement");
return currentStatement.range[1] === pos && this.semicolons.has(pos) || currentStatement.range[0] === pos && void 0 !== this.prevStatement && this.semicolons.has(this.prevStatement.range[1]);
}
unsetAsiPosition(pos) {
this.semicolons.delete(pos);
}
isStatementLevelExpression(expr) {
const currentStatement = this.statementPath[this.statementPath.length - 1];
return expr === currentStatement || "ExpressionStatement" === currentStatement.type && currentStatement.expression === expr;
}
getTagData(name, tag) {
const info = this.scope.definitions.get(name);
if (info instanceof VariableInfo) {
let tagInfo = info.tagInfo;
for (;void 0 !== tagInfo; ) {
if (tagInfo.tag === tag) return tagInfo.data;
tagInfo = tagInfo.next;
}
}
}
tagVariable(name, tag, data) {
const oldInfo = this.scope.definitions.get(name);
let newInfo;
newInfo = void 0 === oldInfo ? new VariableInfo(this.scope, name, {
tag,
data,
next: void 0
}) : oldInfo instanceof VariableInfo ? new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {
tag,
data,
next: oldInfo.tagInfo
}) : new VariableInfo(oldInfo, !0, {
tag,
data,
next: void 0
}), this.scope.definitions.set(name, newInfo);
}
defineVariable(name) {
const oldInfo = this.scope.definitions.get(name);
oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope || this.scope.definitions.set(name, this.scope);
}
undefineVariable(name) {
this.scope.definitions.delete(name);
}
isVariableDefined(name) {
const info = this.scope.definitions.get(name);
return void 0 !== info && (!(info instanceof VariableInfo) || !0 === info.freeName);
}
getVariableInfo(name) {
const value = this.scope.definitions.get(name);
return void 0 === value ? name : value;
}
setVariable(name, variableInfo) {
"string" == typeof variableInfo ? variableInfo === name ? this.scope.definitions.delete(name) : this.scope.definitions.set(name, new VariableInfo(this.scope, variableInfo, void 0)) : this.scope.definitions.set(name, variableInfo);
}
evaluatedVariable(tagInfo) {
return new VariableInfo(this.scope, void 0, tagInfo);
}
parseCommentOptions(range) {
const comments = this.getComments(range);
if (0 === comments.length) return EMPTY_COMMENT_OPTIONS;
let options = {}, errors = [];
for (const comment of comments) {
const {value} = comment;
if (value && webpackCommentRegExp.test(value)) try {
const val = vm.runInNewContext(`(function(){return {${value}};})()`);
Object.assign(options, val);
} catch (e) {
e.comment = comment, errors.push(e);
}
}
return {
options,
errors
};
}
extractMemberExpressionChain(expression) {
let expr = expression;
const members = [], membersOptionals = [];
for (;"MemberExpression" === expr.type; ) {
if (expr.computed) {
if ("Literal" !== expr.property.type) break;
members.push(`${expr.property.value}`);
} else {
if ("Identifier" !== expr.property.type) break;
members.push(expr.property.name);
}
membersOptionals.push(expr.optional), expr = expr.object;
}
return {
members,
membersOptionals,
object: expr
};
}
getFreeInfoFromVariable(varName) {
const info = this.getVariableInfo(varName);
let name;
if (info instanceof VariableInfo) {
if (name = info.freeName, "string" != typeof name) return;
} else {
if ("string" != typeof info) return;
name = info;
}
return {
info,
name
};
}
getMemberExpressionInfo(expression, allowedTypes) {
const {object, members, membersOptionals} = this.extractMemberExpressionChain(expression);
switch (object.type) {
case "CallExpression":
{
if (0 == (1 & allowedTypes)) return;
let callee = object.callee, rootMembers = EMPTY_ARRAY;
"MemberExpression" === callee.type && ({object: callee, members: rootMembers} = this.extractMemberExpressionChain(callee));
const rootName = getRootName(callee);
if (!rootName) return;
const result = this.getFreeInfoFromVariable(rootName);
if (!result) return;
const {info: rootInfo, name: resolvedRoot} = result, calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
return {
type: "call",
call: object,
calleeName,
rootInfo,
getCalleeMembers: memoize((() => rootMembers.reverse())),
name: objectAndMembersToName(`${calleeName}()`, members),
getMembers: memoize((() => members.reverse())),
getMembersOptionals: memoize((() => membersOptionals.reverse()))
};
}

case "Identifier":
case "MetaProperty":
case "ThisExpression":
{
if (0 == (2 & allowedTypes)) return;
const rootName = getRootName(object);
if (!rootName) return;
const result = this.getFreeInfoFromVariable(rootName);
if (!result) return;
const {info: rootInfo, name: resolvedRoot} = result;
return {
type: "expression",
name: objectAndMembersToName(resolvedRoot, members),
rootInfo,
getMembers: memoize((() => members.reverse())),
getMembersOptionals: memoize((() => membersOptionals.reverse()))
};
}
}
}
getNameForExpression(expression) {
return this.getMemberExpressionInfo(expression, 2);
}
static _parse(code, options) {
const type = options ? options.sourceType : "module", parserOptions = {
...defaultParserOptions,
allowReturnOutsideFunction: "script" === type,
...options,
sourceType: "auto" === type ? "module" : type
};
let ast, error, threw = !1;
try {
ast = parser.parse(code, parserOptions);
} catch (e) {
error = e, threw = !0;
}
if (threw && "auto" === type) {
parserOptions.sourceType = "script", "allowReturnOutsideFunction" in options || (parserOptions.allowReturnOutsideFunction = !0), 
Array.isArray(parserOptions.onComment) && (parserOptions.onComment.length = 0);
try {
ast = parser.parse(code, parserOptions), threw = !1;
} catch (e) {}
}
if (threw) throw error;
return ast;
}
}
module.exports = JavascriptParser, module.exports.ALLOWED_MEMBER_TYPES_ALL = 3, 
module.exports.ALLOWED_MEMBER_TYPES_EXPRESSION = 2, module.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 1;
},
78802: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const UnsupportedFeatureWarning = __webpack_require__(3490), ConstDependency = __webpack_require__(30339), BasicEvaluatedExpression = __webpack_require__(47789);
exports.toConstantDependency = (parser, value, runtimeRequirements) => function(expr) {
const dep = new ConstDependency(value, expr.range, runtimeRequirements);
return dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), 
!0;
}, exports.evaluateToString = value => function(expr) {
return (new BasicEvaluatedExpression).setString(value).setRange(expr.range);
}, exports.evaluateToNumber = value => function(expr) {
return (new BasicEvaluatedExpression).setNumber(value).setRange(expr.range);
}, exports.evaluateToBoolean = value => function(expr) {
return (new BasicEvaluatedExpression).setBoolean(value).setRange(expr.range);
}, exports.evaluateToIdentifier = (identifier, rootInfo, getMembers, truthy) => function(expr) {
let evaluatedExpression = (new BasicEvaluatedExpression).setIdentifier(identifier, rootInfo, getMembers).setSideEffects(!1).setRange(expr.range);
switch (truthy) {
case !0:
evaluatedExpression.setTruthy();
break;

case null:
evaluatedExpression.setNullish(!0);
break;

case !1:
evaluatedExpression.setFalsy();
}
return evaluatedExpression;
}, exports.expressionIsUnsupported = (parser, message) => function(expr) {
const dep = new ConstDependency("(void 0)", expr.range, null);
if (dep.loc = expr.loc, parser.state.module.addPresentationalDependency(dep), parser.state.module) return parser.state.module.addWarning(new UnsupportedFeatureWarning(message, expr.loc)), 
!0;
}, exports.skipTraversal = () => !0, exports.approve = () => !0;
},
19202: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), {isSubset} = __webpack_require__(73974), {getAllChunks} = __webpack_require__(92535), EXPORT_PREFIX = "var __webpack_exports__ = ";
exports.generateEntryStartup = (chunkGraph, runtimeTemplate, entries, chunk, passive) => {
const runtime = [ `var __webpack_exec__ = ${runtimeTemplate.returningFunction(`__webpack_require__(${RuntimeGlobals.entryModuleId} = moduleId)`, "moduleId")}` ], runModule = id => `__webpack_exec__(${JSON.stringify(id)})`, outputCombination = (chunks, moduleIds, final) => {
if (0 === chunks.size) runtime.push(`${final ? EXPORT_PREFIX : ""}(${moduleIds.map(runModule).join(", ")});`); else {
const fn = runtimeTemplate.returningFunction(moduleIds.map(runModule).join(", "));
runtime.push(`${final && !passive ? EXPORT_PREFIX : ""}${passive ? RuntimeGlobals.onChunksLoaded : RuntimeGlobals.startupEntrypoint}(0, ${JSON.stringify(Array.from(chunks, (c => c.id)))}, ${fn});`), 
final && passive && runtime.push(`${EXPORT_PREFIX}${RuntimeGlobals.onChunksLoaded}();`);
}
};
let currentChunks, currentModuleIds;
for (const [module, entrypoint] of entries) {
const runtimeChunk = entrypoint.getRuntimeChunk(), moduleId = chunkGraph.getModuleId(module), chunks = getAllChunks(entrypoint, chunk, runtimeChunk);
currentChunks && currentChunks.size === chunks.size && isSubset(currentChunks, chunks) ? currentModuleIds.push(moduleId) : (currentChunks && outputCombination(currentChunks, currentModuleIds), 
currentChunks = chunks, currentModuleIds = [ moduleId ]);
}
return currentChunks && outputCombination(currentChunks, currentModuleIds, !0), 
runtime.push(""), Template.asString(runtime);
}, exports.updateHashForEntryStartup = (hash, chunkGraph, entries, chunk) => {
for (const [module, entrypoint] of entries) {
const runtimeChunk = entrypoint.getRuntimeChunk(), moduleId = chunkGraph.getModuleId(module);
hash.update(`${moduleId}`);
for (const c of getAllChunks(entrypoint, chunk, runtimeChunk)) hash.update(`${c.id}`);
}
}, exports.getInitialChunkIds = (chunk, chunkGraph, filterFn) => {
const initialChunkIds = new Set(chunk.ids);
for (const c of chunk.getAllInitialChunks()) if (c !== chunk && !filterFn(c, chunkGraph)) for (const id of c.ids) initialChunkIds.add(id);
return initialChunkIds;
};
},
62676: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {register} = __webpack_require__(86601);
class JsonData {
constructor(data) {
this._buffer = void 0, this._data = void 0, Buffer.isBuffer(data) ? this._buffer = data : this._data = data;
}
get() {
return void 0 === this._data && void 0 !== this._buffer && (this._data = JSON.parse(this._buffer.toString())), 
this._data;
}
updateHash(hash) {
if (void 0 === this._buffer && void 0 !== this._data && (this._buffer = Buffer.from(JSON.stringify(this._data))), 
this._buffer) return hash.update(this._buffer);
}
}
register(JsonData, "webpack/lib/json/JsonData", null, {
serialize(obj, {write}) {
void 0 === obj._buffer && void 0 !== obj._data && (obj._buffer = Buffer.from(JSON.stringify(obj._data))), 
write(obj._buffer);
},
deserialize: ({read}) => new JsonData(read())
}), module.exports = JsonData;
},
33392: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), ConcatenationScope = __webpack_require__(87291), {UsageState} = __webpack_require__(74603), Generator = __webpack_require__(70607), RuntimeGlobals = __webpack_require__(50980), stringifySafe = data => {
const stringified = JSON.stringify(data);
if (stringified) return stringified.replace(/\u2028|\u2029/g, (str => "\u2029" === str ? "\\u2029" : "\\u2028"));
}, createObjectForExportsInfo = (data, exportsInfo, runtime) => {
if (exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused) return data;
const isArray = Array.isArray(data), reducedData = isArray ? [] : {};
for (const key of Object.keys(data)) {
const exportInfo = exportsInfo.getReadOnlyExportInfo(key), used = exportInfo.getUsed(runtime);
if (used === UsageState.Unused) continue;
let value;
value = used === UsageState.OnlyPropertiesUsed && exportInfo.exportsInfo ? createObjectForExportsInfo(data[key], exportInfo.exportsInfo, runtime) : data[key];
reducedData[exportInfo.getUsedName(key, runtime)] = value;
}
if (isArray) {
let arrayLengthWhenUsed = exportsInfo.getReadOnlyExportInfo("length").getUsed(runtime) !== UsageState.Unused ? data.length : void 0, sizeObjectMinusArray = 0;
for (let i = 0; i < reducedData.length; i++) void 0 === reducedData[i] ? sizeObjectMinusArray -= 2 : sizeObjectMinusArray += `${i}`.length + 3;
if (void 0 !== arrayLengthWhenUsed && (sizeObjectMinusArray += `${arrayLengthWhenUsed}`.length + 8 - 2 * (arrayLengthWhenUsed - reducedData.length)), 
sizeObjectMinusArray < 0) return Object.assign(void 0 === arrayLengthWhenUsed ? {} : {
length: arrayLengthWhenUsed
}, reducedData);
const generatedLength = void 0 !== arrayLengthWhenUsed ? Math.max(arrayLengthWhenUsed, reducedData.length) : reducedData.length;
for (let i = 0; i < generatedLength; i++) void 0 === reducedData[i] && (reducedData[i] = 0);
}
return reducedData;
}, TYPES = new Set([ "javascript" ]);
module.exports = class extends Generator {
getTypes(module) {
return TYPES;
}
getSize(module, type) {
let data = module.buildInfo && module.buildInfo.jsonData && module.buildInfo.jsonData.get();
return data ? stringifySafe(data).length + 10 : 0;
}
getConcatenationBailoutReason(module, context) {}
generate(module, {moduleGraph, runtimeTemplate, runtimeRequirements, runtime, concatenationScope}) {
const data = module.buildInfo && module.buildInfo.jsonData && module.buildInfo.jsonData.get();
if (void 0 === data) return new RawSource(runtimeTemplate.missingModuleStatement({
request: module.rawRequest
}));
const exportsInfo = moduleGraph.getExportsInfo(module);
let finalJson = "object" == typeof data && data && exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused ? createObjectForExportsInfo(data, exportsInfo, runtime) : data;
const jsonStr = stringifySafe(finalJson), jsonExpr = jsonStr.length > 20 && "object" == typeof finalJson ? `JSON.parse('${jsonStr.replace(/[\\']/g, "\\$&")}')` : jsonStr;
let content;
return concatenationScope ? (content = `${runtimeTemplate.supportsConst() ? "const" : "var"} ${ConcatenationScope.NAMESPACE_OBJECT_EXPORT} = ${jsonExpr};`, 
concatenationScope.registerNamespaceExport(ConcatenationScope.NAMESPACE_OBJECT_EXPORT)) : (runtimeRequirements.add(RuntimeGlobals.module), 
content = `${module.moduleArgument}.exports = ${jsonExpr};`), new RawSource(content);
}
};
},
25175: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const createSchemaValidation = __webpack_require__(59586), JsonGenerator = __webpack_require__(33392), JsonParser = __webpack_require__(48799), validate = createSchemaValidation(__webpack_require__(8395), (() => __webpack_require__(89408)), {
name: "Json Modules Plugin",
baseDataPath: "parser"
});
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("JsonModulesPlugin", ((compilation, {normalModuleFactory}) => {
normalModuleFactory.hooks.createParser.for("json").tap("JsonModulesPlugin", (parserOptions => (validate(parserOptions), 
new JsonParser(parserOptions)))), normalModuleFactory.hooks.createGenerator.for("json").tap("JsonModulesPlugin", (() => new JsonGenerator));
}));
}
};
},
48799: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const parseJson = __webpack_require__(73153), Parser = __webpack_require__(21475), JsonExportsDependency = __webpack_require__(94084), JsonData = __webpack_require__(62676);
module.exports = class extends Parser {
constructor(options) {
super(), this.options = options || {};
}
parse(source, state) {
Buffer.isBuffer(source) && (source = source.toString("utf-8"));
const parseFn = "function" == typeof this.options.parse ? this.options.parse : parseJson, data = "object" == typeof source ? source : parseFn("\ufeff" === source[0] ? source.slice(1) : source), jsonData = new JsonData(data);
return state.module.buildInfo.jsonData = jsonData, state.module.buildInfo.strict = !0, 
state.module.buildMeta.exportsType = "default", state.module.buildMeta.defaultObject = "object" == typeof data && "redirect-warn", 
state.module.addDependency(new JsonExportsDependency(jsonData)), state;
}
};
},
69503: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), JavascriptModulesPlugin = __webpack_require__(18362);
class AbstractLibraryPlugin {
constructor({pluginName, type}) {
this._pluginName = pluginName, this._type = type, this._parseCache = new WeakMap;
}
apply(compiler) {
const {_pluginName} = this;
compiler.hooks.thisCompilation.tap(_pluginName, (compilation => {
compilation.hooks.finishModules.tap({
name: _pluginName,
stage: 10
}, (() => {
for (const [name, {dependencies: deps, options: {library}}] of compilation.entries) {
const options = this._parseOptionsCached(void 0 !== library ? library : compilation.outputOptions.library);
if (!1 !== options) {
const dep = deps[deps.length - 1];
if (dep) {
const module = compilation.moduleGraph.getModule(dep);
module && this.finishEntryModule(module, name, {
options,
compilation,
chunkGraph: compilation.chunkGraph
});
}
}
}
}));
const getOptionsForChunk = chunk => {
if (0 === compilation.chunkGraph.getNumberOfEntryModules(chunk)) return !1;
const options = chunk.getEntryOptions(), library = options && options.library;
return this._parseOptionsCached(void 0 !== library ? library : compilation.outputOptions.library);
};
this.render === AbstractLibraryPlugin.prototype.render && this.runtimeRequirements === AbstractLibraryPlugin.prototype.runtimeRequirements || compilation.hooks.additionalChunkRuntimeRequirements.tap(_pluginName, ((chunk, set, {chunkGraph}) => {
const options = getOptionsForChunk(chunk);
!1 !== options && this.runtimeRequirements(chunk, set, {
options,
compilation,
chunkGraph
});
}));
const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
this.render !== AbstractLibraryPlugin.prototype.render && hooks.render.tap(_pluginName, ((source, renderContext) => {
const options = getOptionsForChunk(renderContext.chunk);
return !1 === options ? source : this.render(source, renderContext, {
options,
compilation,
chunkGraph: compilation.chunkGraph
});
})), this.embedInRuntimeBailout !== AbstractLibraryPlugin.prototype.embedInRuntimeBailout && hooks.embedInRuntimeBailout.tap(_pluginName, ((module, renderContext) => {
const options = getOptionsForChunk(renderContext.chunk);
if (!1 !== options) return this.embedInRuntimeBailout(module, renderContext, {
options,
compilation,
chunkGraph: compilation.chunkGraph
});
})), this.strictRuntimeBailout !== AbstractLibraryPlugin.prototype.strictRuntimeBailout && hooks.strictRuntimeBailout.tap(_pluginName, (renderContext => {
const options = getOptionsForChunk(renderContext.chunk);
if (!1 !== options) return this.strictRuntimeBailout(renderContext, {
options,
compilation,
chunkGraph: compilation.chunkGraph
});
})), this.renderStartup !== AbstractLibraryPlugin.prototype.renderStartup && hooks.renderStartup.tap(_pluginName, ((source, module, renderContext) => {
const options = getOptionsForChunk(renderContext.chunk);
return !1 === options ? source : this.renderStartup(source, module, renderContext, {
options,
compilation,
chunkGraph: compilation.chunkGraph
});
})), hooks.chunkHash.tap(_pluginName, ((chunk, hash, context) => {
const options = getOptionsForChunk(chunk);
!1 !== options && this.chunkHash(chunk, hash, context, {
options,
compilation,
chunkGraph: compilation.chunkGraph
});
}));
}));
}
_parseOptionsCached(library) {
if (!library) return !1;
if (library.type !== this._type) return !1;
const cacheEntry = this._parseCache.get(library);
if (void 0 !== cacheEntry) return cacheEntry;
const result = this.parseOptions(library);
return this._parseCache.set(library, result), result;
}
parseOptions(library) {
throw new (__webpack_require__(91266));
}
finishEntryModule(module, entryName, libraryContext) {}
embedInRuntimeBailout(module, renderContext, libraryContext) {}
strictRuntimeBailout(renderContext, libraryContext) {}
runtimeRequirements(chunk, set, libraryContext) {
this.render !== AbstractLibraryPlugin.prototype.render && set.add(RuntimeGlobals.returnExportsFromRuntime);
}
render(source, renderContext, libraryContext) {
return source;
}
renderStartup(source, module, renderContext, libraryContext) {
return source;
}
chunkHash(chunk, hash, chunkHashContext, libraryContext) {
const options = this._parseOptionsCached(libraryContext.compilation.outputOptions.library);
hash.update(this._pluginName), hash.update(JSON.stringify(options));
}
}
AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE = "Common configuration options that specific library names are 'output.library[.name]', 'entry.xyz.library[.name]', 'ModuleFederationPlugin.name' and 'ModuleFederationPlugin.library[.name]'.", 
module.exports = AbstractLibraryPlugin;
},
85526: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), ExternalModule = __webpack_require__(97056), Template = __webpack_require__(88370), AbstractLibraryPlugin = __webpack_require__(69503);
module.exports = class extends AbstractLibraryPlugin {
constructor(options) {
super({
pluginName: "AmdLibraryPlugin",
type: options.type
}), this.requireAsWrapper = options.requireAsWrapper;
}
parseOptions(library) {
const {name} = library;
if (this.requireAsWrapper) {
if (name) throw new Error(`AMD library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
} else if (name && "string" != typeof name) throw new Error(`AMD library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
return {
name
};
}
render(source, {chunkGraph, chunk, runtimeTemplate}, {options, compilation}) {
const modern = runtimeTemplate.supportsArrowFunction(), externals = chunkGraph.getChunkModules(chunk).filter((m => m instanceof ExternalModule)), externalsDepsArray = JSON.stringify(externals.map((m => "object" != typeof m.request || Array.isArray(m.request) ? m.request : m.request.amd))), externalsArguments = externals.map((m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${chunkGraph.getModuleId(m)}`)}__`)).join(", "), iife = runtimeTemplate.isIIFE(), fnStart = (modern ? `(${externalsArguments}) => {` : `function(${externalsArguments}) {`) + (iife || !chunk.hasRuntime() ? " return " : "\n"), fnEnd = iife ? ";\n}" : "\n}";
if (this.requireAsWrapper) return new ConcatSource(`require(${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);
if (options.name) {
const name = compilation.getPath(options.name, {
chunk
});
return new ConcatSource(`define(${JSON.stringify(name)}, ${externalsDepsArray}, ${fnStart}`, source, `${fnEnd});`);
}
return new ConcatSource(externalsArguments ? `define(${externalsDepsArray}, ${fnStart}` : `define(${fnStart}`, source, `${fnEnd});`);
}
chunkHash(chunk, hash, chunkHashContext, {options, compilation}) {
if (hash.update("AmdLibraryPlugin"), this.requireAsWrapper) hash.update("requireAsWrapper"); else if (options.name) {
hash.update("named");
const name = compilation.getPath(options.name, {
chunk
});
hash.update(name);
}
}
};
},
16410: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), {UsageState} = __webpack_require__(74603), Template = __webpack_require__(88370), propertyAccess = __webpack_require__(10664), {getEntryRuntime} = __webpack_require__(14372), AbstractLibraryPlugin = __webpack_require__(69503), KEYWORD_REGEX = /^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/, IDENTIFIER_REGEX = /^[\p{L}\p{Nl}$_][\p{L}\p{Nl}$\p{Mn}\p{Mc}\p{Nd}\p{Pc}]*$/iu, accessWithInit = (accessor, existingLength, initLast = !1) => {
const base = accessor[0];
if (1 === accessor.length && !initLast) return base;
let propsSoFar, current = existingLength > 0 ? base : `(${base} = typeof ${base} === "undefined" ? {} : ${base})`, i = 1;
existingLength > i ? (propsSoFar = accessor.slice(1, existingLength), i = existingLength, 
current += propertyAccess(propsSoFar)) : propsSoFar = [];
const initUntil = initLast ? accessor.length : accessor.length - 1;
for (;i < initUntil; i++) {
const prop = accessor[i];
propsSoFar.push(prop), current = `(${current}${propertyAccess([ prop ])} = ${base}${propertyAccess(propsSoFar)} || {})`;
}
return i < accessor.length && (current = `${current}${propertyAccess([ accessor[accessor.length - 1] ])}`), 
current;
};
module.exports = class extends AbstractLibraryPlugin {
constructor(options) {
super({
pluginName: "AssignLibraryPlugin",
type: options.type
}), this.prefix = options.prefix, this.declare = options.declare, this.unnamed = options.unnamed, 
this.named = options.named || "assign";
}
parseOptions(library) {
const {name} = library;
if ("error" === this.unnamed) {
if ("string" != typeof name && !Array.isArray(name)) throw new Error(`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
} else if (name && "string" != typeof name && !Array.isArray(name)) throw new Error(`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
return {
name,
export: library.export
};
}
finishEntryModule(module, entryName, {options, compilation, compilation: {moduleGraph}}) {
const runtime = getEntryRuntime(compilation, entryName);
if (options.export) {
const exportsInfo = moduleGraph.getExportInfo(module, Array.isArray(options.export) ? options.export[0] : options.export);
exportsInfo.setUsed(UsageState.Used, runtime), exportsInfo.canMangleUse = !1;
} else {
moduleGraph.getExportsInfo(module).setUsedInUnknownWay(runtime);
}
moduleGraph.addExtraReason(module, "used as library export");
}
_getPrefix(compilation) {
return "global" === this.prefix ? [ compilation.runtimeTemplate.globalObject ] : this.prefix;
}
_getResolvedFullName(options, chunk, compilation) {
const prefix = this._getPrefix(compilation);
return (options.name ? prefix.concat(options.name) : prefix).map((n => compilation.getPath(n, {
chunk
})));
}
render(source, {chunk}, {options, compilation}) {
const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);
if (this.declare) {
const base = fullNameResolved[0];
if (name = base, KEYWORD_REGEX.test(name) || !IDENTIFIER_REGEX.test(name)) throw new Error(`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(base)}) or use a different library type (e. g. 'type: "global"', which assign a property on the global scope instead of declaring a variable). ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
source = new ConcatSource(`${this.declare} ${base};\n`, source);
}
var name;
return source;
}
embedInRuntimeBailout(module, {chunk, codeGenerationResults}, {options, compilation}) {
const {data} = codeGenerationResults.get(module, chunk.runtime), topLevelDeclarations = data && data.get("topLevelDeclarations") || module.buildInfo && module.buildInfo.topLevelDeclarations;
if (!topLevelDeclarations) return "it doesn't tell about top level declarations.";
const base = this._getResolvedFullName(options, chunk, compilation)[0];
return topLevelDeclarations.has(base) ? `it declares '${base}' on top-level, which conflicts with the current library output.` : void 0;
}
strictRuntimeBailout({chunk}, {options, compilation}) {
if (!(this.declare || "global" === this.prefix || this.prefix.length > 0) && options.name) return "a global variable is assign and maybe created";
}
renderStartup(source, module, {moduleGraph, chunk}, {options, compilation}) {
const fullNameResolved = this._getResolvedFullName(options, chunk, compilation), staticExports = "static" === this.unnamed, exportAccess = options.export ? propertyAccess(Array.isArray(options.export) ? options.export : [ options.export ]) : "", result = new ConcatSource(source);
if (staticExports) {
const exportsInfo = moduleGraph.getExportsInfo(module), exportTarget = accessWithInit(fullNameResolved, this._getPrefix(compilation).length, !0);
for (const exportInfo of exportsInfo.orderedExports) {
if (!exportInfo.provided) continue;
const nameAccess = propertyAccess([ exportInfo.name ]);
result.add(`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\n`);
}
result.add(`Object.defineProperty(${exportTarget}, "__esModule", { value: true });\n`);
} else if (options.name ? "copy" === this.named : "copy" === this.unnamed) {
result.add(`var __webpack_export_target__ = ${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, !0)};\n`);
let exports = "__webpack_exports__";
exportAccess && (result.add(`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\n`), 
exports = "__webpack_exports_export__"), result.add(`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\n`), 
result.add(`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });\n`);
} else result.add(`${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, !1)} = __webpack_exports__${exportAccess};\n`);
return result;
}
runtimeRequirements(chunk, set, libraryContext) {}
chunkHash(chunk, hash, chunkHashContext, {options, compilation}) {
hash.update("AssignLibraryPlugin");
const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);
(options.name ? "copy" === this.named : "copy" === this.unnamed) && hash.update("copy"), 
this.declare && hash.update(this.declare), hash.update(fullNameResolved.join(".")), 
options.export && hash.update(`${options.export}`);
}
};
},
30001: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const enabledTypes = new WeakMap, getEnabledTypes = compiler => {
let set = enabledTypes.get(compiler);
return void 0 === set && (set = new Set, enabledTypes.set(compiler, set)), set;
};
module.exports = class {
constructor(type) {
this.type = type;
}
static setEnabled(compiler, type) {
getEnabledTypes(compiler).add(type);
}
static checkEnabled(compiler, type) {
if (!getEnabledTypes(compiler).has(type)) throw new Error(`Library type "${type}" is not enabled. EnableLibraryPlugin need to be used to enable this type of library. This usually happens through the "output.enabledLibraryTypes" option. If you are using a function as entry which sets "library", you need to add all potential library types to "output.enabledLibraryTypes". These types are enabled: ` + Array.from(getEnabledTypes(compiler)).join(", "));
}
apply(compiler) {
const {type} = this, enabled = getEnabledTypes(compiler);
if (!enabled.has(type) && (enabled.add(type), "string" == typeof type)) {
const enableExportProperty = () => {
new (__webpack_require__(98854))({
type,
nsObjectUsed: "module" !== type
}).apply(compiler);
};
switch (type) {
case "var":
new (__webpack_require__(16410))({
type,
prefix: [],
declare: "var",
unnamed: "error"
}).apply(compiler);
break;

case "assign-properties":
new (__webpack_require__(16410))({
type,
prefix: [],
declare: !1,
unnamed: "error",
named: "copy"
}).apply(compiler);
break;

case "assign":
new (__webpack_require__(16410))({
type,
prefix: [],
declare: !1,
unnamed: "error"
}).apply(compiler);
break;

case "this":
new (__webpack_require__(16410))({
type,
prefix: [ "this" ],
declare: !1,
unnamed: "copy"
}).apply(compiler);
break;

case "window":
new (__webpack_require__(16410))({
type,
prefix: [ "window" ],
declare: !1,
unnamed: "copy"
}).apply(compiler);
break;

case "self":
new (__webpack_require__(16410))({
type,
prefix: [ "self" ],
declare: !1,
unnamed: "copy"
}).apply(compiler);
break;

case "global":
new (__webpack_require__(16410))({
type,
prefix: "global",
declare: !1,
unnamed: "copy"
}).apply(compiler);
break;

case "commonjs":
new (__webpack_require__(16410))({
type,
prefix: [ "exports" ],
declare: !1,
unnamed: "copy"
}).apply(compiler);
break;

case "commonjs-static":
new (__webpack_require__(16410))({
type,
prefix: [ "exports" ],
declare: !1,
unnamed: "static"
}).apply(compiler);
break;

case "commonjs2":
case "commonjs-module":
new (__webpack_require__(16410))({
type,
prefix: [ "module", "exports" ],
declare: !1,
unnamed: "assign"
}).apply(compiler);
break;

case "amd":
case "amd-require":
enableExportProperty();
new (__webpack_require__(85526))({
type,
requireAsWrapper: "amd-require" === type
}).apply(compiler);
break;

case "umd":
case "umd2":
enableExportProperty();
new (__webpack_require__(6953))({
type,
optionalAmdExternalAsGlobal: "umd2" === type
}).apply(compiler);
break;

case "system":
enableExportProperty();
new (__webpack_require__(33828))({
type
}).apply(compiler);
break;

case "jsonp":
enableExportProperty();
new (__webpack_require__(12488))({
type
}).apply(compiler);
break;

case "module":
enableExportProperty();
new (__webpack_require__(38653))({
type
}).apply(compiler);
break;

default:
throw new Error(`Unsupported library type ${type}.\nPlugins which provide custom library types must call EnableLibraryPlugin.setEnabled(compiler, type) to disable this error.`);
}
}
}
};
},
98854: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), {UsageState} = __webpack_require__(74603), propertyAccess = __webpack_require__(10664), {getEntryRuntime} = __webpack_require__(14372), AbstractLibraryPlugin = __webpack_require__(69503);
module.exports = class extends AbstractLibraryPlugin {
constructor({type, nsObjectUsed}) {
super({
pluginName: "ExportPropertyLibraryPlugin",
type
}), this.nsObjectUsed = nsObjectUsed;
}
parseOptions(library) {
return {
export: library.export
};
}
finishEntryModule(module, entryName, {options, compilation, compilation: {moduleGraph}}) {
const runtime = getEntryRuntime(compilation, entryName);
if (options.export) {
const exportsInfo = moduleGraph.getExportInfo(module, Array.isArray(options.export) ? options.export[0] : options.export);
exportsInfo.setUsed(UsageState.Used, runtime), exportsInfo.canMangleUse = !1;
} else {
const exportsInfo = moduleGraph.getExportsInfo(module);
this.nsObjectUsed ? exportsInfo.setUsedInUnknownWay(runtime) : exportsInfo.setAllKnownExportsUsed(runtime);
}
moduleGraph.addExtraReason(module, "used as library export");
}
runtimeRequirements(chunk, set, libraryContext) {}
renderStartup(source, module, renderContext, {options}) {
if (!options.export) return source;
const postfix = `__webpack_exports__ = __webpack_exports__${propertyAccess(Array.isArray(options.export) ? options.export : [ options.export ])};\n`;
return new ConcatSource(source, postfix);
}
};
},
12488: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), AbstractLibraryPlugin = __webpack_require__(69503);
module.exports = class extends AbstractLibraryPlugin {
constructor(options) {
super({
pluginName: "JsonpLibraryPlugin",
type: options.type
});
}
parseOptions(library) {
const {name} = library;
if ("string" != typeof name) throw new Error(`Jsonp library name must be a simple string. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
return {
name
};
}
render(source, {chunk}, {options, compilation}) {
const name = compilation.getPath(options.name, {
chunk
});
return new ConcatSource(`${name}(`, source, ")");
}
chunkHash(chunk, hash, chunkHashContext, {options, compilation}) {
hash.update("JsonpLibraryPlugin"), hash.update(compilation.getPath(options.name, {
chunk
}));
}
};
},
38653: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), Template = __webpack_require__(88370), propertyAccess = __webpack_require__(10664), AbstractLibraryPlugin = __webpack_require__(69503);
module.exports = class extends AbstractLibraryPlugin {
constructor(options) {
super({
pluginName: "ModuleLibraryPlugin",
type: options.type
});
}
parseOptions(library) {
const {name} = library;
if (name) throw new Error(`Library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
return {
name
};
}
renderStartup(source, module, {moduleGraph, chunk}, {options, compilation}) {
const result = new ConcatSource(source), exportsInfo = moduleGraph.getExportsInfo(module), exports = [];
moduleGraph.isAsync(module) && result.add("__webpack_exports__ = await __webpack_exports__;\n");
for (const exportInfo of exportsInfo.orderedExports) {
if (!exportInfo.provided) continue;
const varName = `__webpack_exports__${Template.toIdentifier(exportInfo.name)}`;
result.add(`var ${varName} = __webpack_exports__${propertyAccess([ exportInfo.getUsedName(exportInfo.name, chunk.runtime) ])};\n`), 
exports.push(`${varName} as ${exportInfo.name}`);
}
return exports.length > 0 && result.add(`export { ${exports.join(", ")} };\n`), 
result;
}
};
},
33828: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource} = __webpack_require__(37946), {UsageState} = __webpack_require__(74603), ExternalModule = __webpack_require__(97056), Template = __webpack_require__(88370), propertyAccess = __webpack_require__(10664), AbstractLibraryPlugin = __webpack_require__(69503);
module.exports = class extends AbstractLibraryPlugin {
constructor(options) {
super({
pluginName: "SystemLibraryPlugin",
type: options.type
});
}
parseOptions(library) {
const {name} = library;
if (name && "string" != typeof name) throw new Error(`System.js library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);
return {
name
};
}
render(source, {chunkGraph, moduleGraph, chunk}, {options, compilation}) {
const externals = chunkGraph.getChunkModules(chunk).filter((m => m instanceof ExternalModule && "system" === m.externalType)), name = options.name ? `${JSON.stringify(compilation.getPath(options.name, {
chunk
}))}, ` : "", systemDependencies = JSON.stringify(externals.map((m => "object" != typeof m.request || Array.isArray(m.request) ? m.request : m.request.amd))), externalWebpackNames = externals.map((m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${chunkGraph.getModuleId(m)}`)}__`)), externalVarDeclarations = externalWebpackNames.map((name => `var ${name} = {};`)).join("\n"), externalVarInitialization = [], setters = 0 === externalWebpackNames.length ? "" : Template.asString([ "setters: [", Template.indent(externals.map(((module, i) => {
const external = externalWebpackNames[i], exportsInfo = moduleGraph.getExportsInfo(module), otherUnused = exportsInfo.otherExportsInfo.getUsed(chunk.runtime) === UsageState.Unused, instructions = [], handledNames = [];
for (const exportInfo of exportsInfo.orderedExports) {
const used = exportInfo.getUsedName(void 0, chunk.runtime);
used ? (otherUnused || used !== exportInfo.name) && (instructions.push(`${external}${propertyAccess([ used ])} = module${propertyAccess([ exportInfo.name ])};`), 
handledNames.push(exportInfo.name)) : handledNames.push(exportInfo.name);
}
if (!otherUnused) if (Array.isArray(module.request) && 1 !== module.request.length || externalVarInitialization.push(`Object.defineProperty(${external}, "__esModule", { value: true });`), 
handledNames.length > 0) {
const name = `${external}handledNames`;
externalVarInitialization.push(`var ${name} = ${JSON.stringify(handledNames)};`), 
instructions.push(Template.asString([ "Object.keys(module).forEach(function(key) {", Template.indent([ `if(${name}.indexOf(key) >= 0)`, Template.indent(`${external}[key] = module[key];`) ]), "});" ]));
} else instructions.push(Template.asString([ "Object.keys(module).forEach(function(key) {", Template.indent([ `${external}[key] = module[key];` ]), "});" ]));
return 0 === instructions.length ? "function() {}" : Template.asString([ "function(module) {", Template.indent(instructions), "}" ]);
})).join(",\n")), "]," ]);
return new ConcatSource(Template.asString([ `System.register(${name}${systemDependencies}, function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {`, Template.indent([ externalVarDeclarations, Template.asString(externalVarInitialization), "return {", Template.indent([ setters, "execute: function() {", Template.indent("__WEBPACK_DYNAMIC_EXPORT__(") ]) ]), "" ]), source, Template.asString([ "", Template.indent([ Template.indent([ Template.indent([ ");" ]), "}" ]), "};" ]), "})" ]));
}
chunkHash(chunk, hash, chunkHashContext, {options, compilation}) {
hash.update("SystemLibraryPlugin"), options.name && hash.update(compilation.getPath(options.name, {
chunk
}));
}
};
},
6953: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ConcatSource, OriginalSource} = __webpack_require__(37946), ExternalModule = __webpack_require__(97056), Template = __webpack_require__(88370), AbstractLibraryPlugin = __webpack_require__(69503), accessorToObjectAccess = accessor => accessor.map((a => `[${JSON.stringify(a)}]`)).join("");
module.exports = class extends AbstractLibraryPlugin {
constructor(options) {
super({
pluginName: "UmdLibraryPlugin",
type: options.type
}), this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
}
parseOptions(library) {
let name, names;
if ("object" != typeof library.name || Array.isArray(library.name)) {
name = library.name;
const singleName = Array.isArray(name) ? name[0] : name;
names = {
commonjs: singleName,
root: library.name,
amd: singleName
};
} else name = library.name.root || library.name.amd || library.name.commonjs, names = library.name;
return {
name,
names,
auxiliaryComment: library.auxiliaryComment,
namedDefine: library.umdNamedDefine
};
}
render(source, {chunkGraph, runtimeTemplate, chunk, moduleGraph}, {options, compilation}) {
let externals = chunkGraph.getChunkModules(chunk).filter((m => m instanceof ExternalModule && ("umd" === m.externalType || "umd2" === m.externalType)));
const optionalExternals = [];
let requiredExternals = [];
if (this.optionalAmdExternalAsGlobal) {
for (const m of externals) m.isOptional(moduleGraph) ? optionalExternals.push(m) : requiredExternals.push(m);
externals = requiredExternals.concat(optionalExternals);
} else requiredExternals = externals;
const replaceKeys = str => compilation.getPath(str, {
chunk
}), externalsDepsArray = modules => `[${replaceKeys(modules.map((m => JSON.stringify("object" == typeof m.request ? m.request.amd : m.request))).join(", "))}]`, externalsRootArray = modules => replaceKeys(modules.map((m => {
let request = m.request;
return "object" == typeof request && (request = request.root), `root${accessorToObjectAccess([].concat(request))}`;
})).join(", ")), externalsRequireArray = type => replaceKeys(externals.map((m => {
let expr, request = m.request;
if ("object" == typeof request && (request = request[type]), void 0 === request) throw new Error("Missing external configuration for type:" + type);
return expr = Array.isArray(request) ? `require(${JSON.stringify(request[0])})${accessorToObjectAccess(request.slice(1))}` : `require(${JSON.stringify(request)})`, 
m.isOptional(moduleGraph) && (expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr}; } catch(e) {} }())`), 
expr;
})).join(", ")), externalsArguments = modules => modules.map((m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(`${chunkGraph.getModuleId(m)}`)}__`)).join(", "), libraryName = library => JSON.stringify(replaceKeys([].concat(library).pop()));
let amdFactory;
if (optionalExternals.length > 0) {
amdFactory = `function webpackLoadOptionalExternalModuleAmd(${externalsArguments(requiredExternals)}) {\n\t\t\treturn factory(${requiredExternals.length > 0 ? externalsArguments(requiredExternals) + ", " + externalsRootArray(optionalExternals) : externalsRootArray(optionalExternals)});\n\t\t}`;
} else amdFactory = "factory";
const {auxiliaryComment, namedDefine, names} = options, getAuxiliaryComment = type => {
if (auxiliaryComment) {
if ("string" == typeof auxiliaryComment) return "\t//" + auxiliaryComment + "\n";
if (auxiliaryComment[type]) return "\t//" + auxiliaryComment[type] + "\n";
}
return "";
};
return new ConcatSource(new OriginalSource("(function webpackUniversalModuleDefinition(root, factory) {\n" + getAuxiliaryComment("commonjs2") + "\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(" + externalsRequireArray("commonjs2") + ");\n" + getAuxiliaryComment("amd") + "\telse if(typeof define === 'function' && define.amd)\n" + (requiredExternals.length > 0 ? names.amd && !0 === namedDefine ? "\t\tdefine(" + libraryName(names.amd) + ", " + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" : "\t\tdefine(" + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" : names.amd && !0 === namedDefine ? "\t\tdefine(" + libraryName(names.amd) + ", [], " + amdFactory + ");\n" : "\t\tdefine([], " + amdFactory + ");\n") + (names.root || names.commonjs ? getAuxiliaryComment("commonjs") + "\telse if(typeof exports === 'object')\n\t\texports[" + libraryName(names.commonjs || names.root) + "] = factory(" + externalsRequireArray("commonjs") + ");\n" + getAuxiliaryComment("root") + "\telse\n\t\t" + replaceKeys(((base, accessor, joinWith = ", ") => {
const accessors = Array.isArray(accessor) ? accessor : [ accessor ];
return accessors.map(((_, idx) => {
const a = base ? base + accessorToObjectAccess(accessors.slice(0, idx + 1)) : accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
return idx === accessors.length - 1 ? a : 0 === idx && void 0 === base ? `${a} = typeof ${a} === "object" ? ${a} : {}` : `${a} = ${a} || {}`;
})).join(joinWith);
})("root", names.root || names.commonjs)) + " = factory(" + externalsRootArray(externals) + ");\n" : "\telse {\n" + (externals.length > 0 ? "\t\tvar a = typeof exports === 'object' ? factory(" + externalsRequireArray("commonjs") + ") : factory(" + externalsRootArray(externals) + ");\n" : "\t\tvar a = factory();\n") + "\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n") + `})(${runtimeTemplate.outputOptions.globalObject}, ${runtimeTemplate.supportsArrowFunction() ? `(${externalsArguments(externals)}) =>` : `function(${externalsArguments(externals)})`} {\nreturn `, "webpack/universalModuleDefinition"), source, ";\n})");
}
};
},
20097: (__unused_webpack_module, exports) => {
"use strict";
const LogType = Object.freeze({
error: "error",
warn: "warn",
info: "info",
log: "log",
debug: "debug",
trace: "trace",
group: "group",
groupCollapsed: "groupCollapsed",
groupEnd: "groupEnd",
profile: "profile",
profileEnd: "profileEnd",
time: "time",
clear: "clear",
status: "status"
});
exports.LogType = LogType;
const LOG_SYMBOL = Symbol("webpack logger raw log method"), TIMERS_SYMBOL = Symbol("webpack logger times"), TIMERS_AGGREGATES_SYMBOL = Symbol("webpack logger aggregated times");
exports.Logger = class {
constructor(log, getChildLogger) {
this[LOG_SYMBOL] = log, this.getChildLogger = getChildLogger;
}
error(...args) {
this[LOG_SYMBOL](LogType.error, args);
}
warn(...args) {
this[LOG_SYMBOL](LogType.warn, args);
}
info(...args) {
this[LOG_SYMBOL](LogType.info, args);
}
log(...args) {
this[LOG_SYMBOL](LogType.log, args);
}
debug(...args) {
this[LOG_SYMBOL](LogType.debug, args);
}
assert(assertion, ...args) {
assertion || this[LOG_SYMBOL](LogType.error, args);
}
trace() {
this[LOG_SYMBOL](LogType.trace, [ "Trace" ]);
}
clear() {
this[LOG_SYMBOL](LogType.clear);
}
status(...args) {
this[LOG_SYMBOL](LogType.status, args);
}
group(...args) {
this[LOG_SYMBOL](LogType.group, args);
}
groupCollapsed(...args) {
this[LOG_SYMBOL](LogType.groupCollapsed, args);
}
groupEnd(...args) {
this[LOG_SYMBOL](LogType.groupEnd, args);
}
profile(label) {
this[LOG_SYMBOL](LogType.profile, [ label ]);
}
profileEnd(label) {
this[LOG_SYMBOL](LogType.profileEnd, [ label ]);
}
time(label) {
this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map, this[TIMERS_SYMBOL].set(label, process.hrtime());
}
timeLog(label) {
const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
if (!prev) throw new Error(`No such label '${label}' for WebpackLogger.timeLog()`);
const time = process.hrtime(prev);
this[LOG_SYMBOL](LogType.time, [ label, ...time ]);
}
timeEnd(label) {
const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
if (!prev) throw new Error(`No such label '${label}' for WebpackLogger.timeEnd()`);
const time = process.hrtime(prev);
this[TIMERS_SYMBOL].delete(label), this[LOG_SYMBOL](LogType.time, [ label, ...time ]);
}
timeAggregate(label) {
const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
if (!prev) throw new Error(`No such label '${label}' for WebpackLogger.timeAggregate()`);
const time = process.hrtime(prev);
this[TIMERS_SYMBOL].delete(label), this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map;
const current = this[TIMERS_AGGREGATES_SYMBOL].get(label);
void 0 !== current && (time[1] + current[1] > 1e9 ? (time[0] += current[0] + 1, 
time[1] = time[1] - 1e9 + current[1]) : (time[0] += current[0], time[1] += current[1])), 
this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
}
timeAggregateEnd(label) {
if (void 0 === this[TIMERS_AGGREGATES_SYMBOL]) return;
const time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
void 0 !== time && (this[TIMERS_AGGREGATES_SYMBOL].delete(label), this[LOG_SYMBOL](LogType.time, [ label, ...time ]));
}
};
},
54428: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {LogType} = __webpack_require__(20097), filterToFunction = item => {
if ("string" == typeof item) {
const regExp = new RegExp(`[\\\\/]${item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&")}([\\\\/]|$|!|\\?)`);
return ident => regExp.test(ident);
}
return item && "object" == typeof item && "function" == typeof item.test ? ident => item.test(ident) : "function" == typeof item ? item : "boolean" == typeof item ? () => item : void 0;
}, LogLevel = {
none: 6,
false: 6,
error: 5,
warn: 4,
info: 3,
log: 2,
true: 2,
verbose: 1
};
module.exports = ({level = "info", debug = !1, console}) => {
const debugFilters = "boolean" == typeof debug ? [ () => debug ] : [].concat(debug).map(filterToFunction), loglevel = LogLevel[`${level}`] || 0;
return (name, type, args) => {
const labeledArgs = () => Array.isArray(args) ? args.length > 0 && "string" == typeof args[0] ? [ `[${name}] ${args[0]}`, ...args.slice(1) ] : [ `[${name}]`, ...args ] : [], debug = debugFilters.some((f => f(name)));
switch (type) {
case LogType.debug:
if (!debug) return;
"function" == typeof console.debug ? console.debug(...labeledArgs()) : console.log(...labeledArgs());
break;

case LogType.log:
if (!debug && loglevel > LogLevel.log) return;
console.log(...labeledArgs());
break;

case LogType.info:
if (!debug && loglevel > LogLevel.info) return;
console.info(...labeledArgs());
break;

case LogType.warn:
if (!debug && loglevel > LogLevel.warn) return;
console.warn(...labeledArgs());
break;

case LogType.error:
if (!debug && loglevel > LogLevel.error) return;
console.error(...labeledArgs());
break;

case LogType.trace:
if (!debug) return;
console.trace();
break;

case LogType.groupCollapsed:
if (!debug && loglevel > LogLevel.log) return;
if (!debug && loglevel > LogLevel.verbose) {
"function" == typeof console.groupCollapsed ? console.groupCollapsed(...labeledArgs()) : console.log(...labeledArgs());
break;
}

case LogType.group:
if (!debug && loglevel > LogLevel.log) return;
"function" == typeof console.group ? console.group(...labeledArgs()) : console.log(...labeledArgs());
break;

case LogType.groupEnd:
if (!debug && loglevel > LogLevel.log) return;
"function" == typeof console.groupEnd && console.groupEnd();
break;

case LogType.time:
{
if (!debug && loglevel > LogLevel.log) return;
const ms = 1e3 * args[1] + args[2] / 1e6, msg = `[${name}] ${args[0]}: ${ms} ms`;
"function" == typeof console.logTime ? console.logTime(msg) : console.log(msg);
break;
}

case LogType.profile:
"function" == typeof console.profile && console.profile(...labeledArgs());
break;

case LogType.profileEnd:
"function" == typeof console.profileEnd && console.profileEnd(...labeledArgs());
break;

case LogType.clear:
if (!debug && loglevel > LogLevel.log) return;
"function" == typeof console.clear && console.clear();
break;

case LogType.status:
if (!debug && loglevel > LogLevel.info) return;
"function" == typeof console.status ? 0 === args.length ? console.status() : console.status(...labeledArgs()) : 0 !== args.length && console.info(...labeledArgs());
break;

default:
throw new Error(`Unexpected LogType ${type}`);
}
};
};
},
66813: module => {
"use strict";
const arraySum = array => {
let sum = 0;
for (const item of array) sum += item;
return sum;
}, truncateArgs = (args, maxLength) => {
const lengths = args.map((a => `${a}`.length)), availableLength = maxLength - lengths.length + 1;
if (availableLength > 0 && 1 === args.length) return availableLength >= args[0].length ? args : availableLength > 3 ? [ "..." + args[0].slice(3 - availableLength) ] : [ args[0].slice(-availableLength) ];
if (availableLength < arraySum(lengths.map((i => Math.min(i, 6))))) return args.length > 1 ? truncateArgs(args.slice(0, args.length - 1), maxLength) : [];
let currentLength = arraySum(lengths);
if (currentLength <= availableLength) return args;
for (;currentLength > availableLength; ) {
const maxLength = Math.max(...lengths), shorterItems = lengths.filter((l => l !== maxLength)), nextToMaxLength = shorterItems.length > 0 ? Math.max(...shorterItems) : 0, maxReduce = maxLength - nextToMaxLength;
let maxItems = lengths.length - shorterItems.length, overrun = currentLength - availableLength;
for (let i = 0; i < lengths.length; i++) if (lengths[i] === maxLength) {
const reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);
lengths[i] -= reduce, currentLength -= reduce, overrun -= reduce, maxItems--;
}
}
return args.map(((a, i) => {
const str = `${a}`, length = lengths[i];
return str.length === length ? str : length > 5 ? "..." + str.slice(3 - length) : length > 0 ? str.slice(-length) : "";
}));
};
module.exports = truncateArgs;
},
69155: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), StartupChunkDependenciesPlugin = __webpack_require__(40394);
module.exports = class {
constructor(options) {
options = options || {}, this._asyncChunkLoading = options.asyncChunkLoading;
}
apply(compiler) {
const ChunkLoadingRuntimeModule = this._asyncChunkLoading ? __webpack_require__(43724) : __webpack_require__(41433), chunkLoadingValue = this._asyncChunkLoading ? "async-node" : "require";
new StartupChunkDependenciesPlugin({
chunkLoading: chunkLoadingValue,
asyncChunkLoading: this._asyncChunkLoading
}).apply(compiler), compiler.hooks.thisCompilation.tap("CommonJsChunkLoadingPlugin", (compilation => {
const globalChunkLoading = compilation.outputOptions.chunkLoading, isEnabledForChunk = chunk => {
const options = chunk.getEntryOptions();
return (options && void 0 !== options.chunkLoading ? options.chunkLoading : globalChunkLoading) === chunkLoadingValue;
}, onceForChunkSet = new WeakSet, handler = (chunk, set) => {
onceForChunkSet.has(chunk) || (onceForChunkSet.add(chunk), isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.moduleFactoriesAddOnly), 
set.add(RuntimeGlobals.hasOwnProperty), compilation.addRuntimeModule(chunk, new ChunkLoadingRuntimeModule(set))));
};
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("CommonJsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap("CommonJsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadManifest).tap("CommonJsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.baseURI).tap("CommonJsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.externalInstallChunk).tap("CommonJsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.onChunksLoaded).tap("CommonJsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("CommonJsChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && set.add(RuntimeGlobals.getChunkScriptFilename);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap("CommonJsChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.getChunkUpdateScriptFilename), 
set.add(RuntimeGlobals.moduleCache), set.add(RuntimeGlobals.hmrModuleData), set.add(RuntimeGlobals.moduleFactoriesAddOnly));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadManifest).tap("CommonJsChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && set.add(RuntimeGlobals.getUpdateManifestFilename);
}));
}));
}
};
},
25418: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const CachedInputFileSystem = __webpack_require__(38546), fs = __webpack_require__(20077), createConsoleLogger = __webpack_require__(54428), NodeWatchFileSystem = __webpack_require__(36345), nodeConsole = __webpack_require__(23056);
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
const {infrastructureLogging} = this.options;
compiler.infrastructureLogger = createConsoleLogger({
level: infrastructureLogging.level || "info",
debug: infrastructureLogging.debug || !1,
console: infrastructureLogging.console || nodeConsole({
colors: infrastructureLogging.colors,
appendOnly: infrastructureLogging.appendOnly,
stream: infrastructureLogging.stream
})
}), compiler.inputFileSystem = new CachedInputFileSystem(fs, 6e4);
const inputFileSystem = compiler.inputFileSystem;
compiler.outputFileSystem = fs, compiler.intermediateFileSystem = fs, compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem), 
compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", (compiler => {
compiler.inputFileSystem === inputFileSystem && (compiler.fsStartTime = Date.now(), 
inputFileSystem.purge());
}));
}
};
},
425: module => {
"use strict";
module.exports = class {
apply(compiler) {}
};
},
81350: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ExternalsPlugin = __webpack_require__(29301), builtins = [ "assert", "async_hooks", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "diagnostics_channel", "dns", "dns/promises", "domain", "events", "fs", "fs/promises", "http", "http2", "https", "inspector", "module", "net", "os", "path", "path/posix", "path/win32", "perf_hooks", "process", "punycode", "querystring", "readline", "repl", "stream", "stream/promises", "stream/web", "string_decoder", "sys", "timers", "timers/promises", "tls", "trace_events", "tty", "url", "util", "util/types", "v8", "vm", "wasi", "worker_threads", "zlib", /^node:/, "pnpapi" ];
module.exports = class {
apply(compiler) {
new ExternalsPlugin("node-commonjs", builtins).apply(compiler);
}
};
},
62016: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const CommonJsChunkFormatPlugin = __webpack_require__(39074), EnableChunkLoadingPlugin = __webpack_require__(64027);
module.exports = class {
constructor(options) {
this._options = options || {};
}
apply(compiler) {
const chunkLoading = this._options.asyncChunkLoading ? "async-node" : "require";
compiler.options.output.chunkLoading = chunkLoading, (new CommonJsChunkFormatPlugin).apply(compiler), 
new EnableChunkLoadingPlugin(chunkLoading).apply(compiler);
}
};
},
36345: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), Watchpack = __webpack_require__(15722);
module.exports = class {
constructor(inputFileSystem) {
this.inputFileSystem = inputFileSystem, this.watcherOptions = {
aggregateTimeout: 0
}, this.watcher = new Watchpack(this.watcherOptions);
}
watch(files, directories, missing, startTime, options, callback, callbackUndelayed) {
if (!files || "function" != typeof files[Symbol.iterator]) throw new Error("Invalid arguments: 'files'");
if (!directories || "function" != typeof directories[Symbol.iterator]) throw new Error("Invalid arguments: 'directories'");
if (!missing || "function" != typeof missing[Symbol.iterator]) throw new Error("Invalid arguments: 'missing'");
if ("function" != typeof callback) throw new Error("Invalid arguments: 'callback'");
if ("number" != typeof startTime && startTime) throw new Error("Invalid arguments: 'startTime'");
if ("object" != typeof options) throw new Error("Invalid arguments: 'options'");
if ("function" != typeof callbackUndelayed && callbackUndelayed) throw new Error("Invalid arguments: 'callbackUndelayed'");
const oldWatcher = this.watcher;
this.watcher = new Watchpack(options), callbackUndelayed && this.watcher.once("change", callbackUndelayed);
const fetchTimeInfo = () => {
const fileTimeInfoEntries = new Map, contextTimeInfoEntries = new Map;
return this.watcher && this.watcher.collectTimeInfoEntries(fileTimeInfoEntries, contextTimeInfoEntries), 
{
fileTimeInfoEntries,
contextTimeInfoEntries
};
};
return this.watcher.once("aggregated", ((changes, removals) => {
if (this.watcher.pause(), this.inputFileSystem && this.inputFileSystem.purge) {
const fs = this.inputFileSystem;
for (const item of changes) fs.purge(item);
for (const item of removals) fs.purge(item);
}
const {fileTimeInfoEntries, contextTimeInfoEntries} = fetchTimeInfo();
callback(null, fileTimeInfoEntries, contextTimeInfoEntries, changes, removals);
})), this.watcher.watch({
files,
directories,
missing,
startTime
}), oldWatcher && oldWatcher.close(), {
close: () => {
this.watcher && (this.watcher.close(), this.watcher = null);
},
pause: () => {
this.watcher && this.watcher.pause();
},
getAggregatedRemovals: util.deprecate((() => {
const items = this.watcher && this.watcher.aggregatedRemovals;
if (items && this.inputFileSystem && this.inputFileSystem.purge) {
const fs = this.inputFileSystem;
for (const item of items) fs.purge(item);
}
return items;
}), "Watcher.getAggregatedRemovals is deprecated in favor of Watcher.getInfo since that's more performant.", "DEP_WEBPACK_WATCHER_GET_AGGREGATED_REMOVALS"),
getAggregatedChanges: util.deprecate((() => {
const items = this.watcher && this.watcher.aggregatedChanges;
if (items && this.inputFileSystem && this.inputFileSystem.purge) {
const fs = this.inputFileSystem;
for (const item of items) fs.purge(item);
}
return items;
}), "Watcher.getAggregatedChanges is deprecated in favor of Watcher.getInfo since that's more performant.", "DEP_WEBPACK_WATCHER_GET_AGGREGATED_CHANGES"),
getFileTimeInfoEntries: util.deprecate((() => fetchTimeInfo().fileTimeInfoEntries), "Watcher.getFileTimeInfoEntries is deprecated in favor of Watcher.getInfo since that's more performant.", "DEP_WEBPACK_WATCHER_FILE_TIME_INFO_ENTRIES"),
getContextTimeInfoEntries: util.deprecate((() => fetchTimeInfo().contextTimeInfoEntries), "Watcher.getContextTimeInfoEntries is deprecated in favor of Watcher.getInfo since that's more performant.", "DEP_WEBPACK_WATCHER_CONTEXT_TIME_INFO_ENTRIES"),
getInfo: () => {
const removals = this.watcher && this.watcher.aggregatedRemovals, changes = this.watcher && this.watcher.aggregatedChanges;
if (this.inputFileSystem && this.inputFileSystem.purge) {
const fs = this.inputFileSystem;
if (removals) for (const item of removals) fs.purge(item);
if (changes) for (const item of changes) fs.purge(item);
}
const {fileTimeInfoEntries, contextTimeInfoEntries} = fetchTimeInfo();
return {
changes,
removals,
fileTimeInfoEntries,
contextTimeInfoEntries
};
}
};
}
};
},
43724: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {chunkHasJs, getChunkFilenameTemplate} = __webpack_require__(18362), {getInitialChunkIds} = __webpack_require__(19202), compileBooleanMatcher = __webpack_require__(65814), {getUndoPath} = __webpack_require__(63264);
module.exports = class extends RuntimeModule {
constructor(runtimeRequirements) {
super("readFile chunk loading", RuntimeModule.STAGE_ATTACH), this.runtimeRequirements = runtimeRequirements;
}
_generateBaseUri(chunk, rootOutputDir) {
const options = chunk.getEntryOptions();
return options && options.baseUri ? `${RuntimeGlobals.baseURI} = ${JSON.stringify(options.baseUri)};` : `${RuntimeGlobals.baseURI} = require("url").pathToFileURL(${rootOutputDir ? `__dirname + ${JSON.stringify("/" + rootOutputDir)}` : "__filename"});`;
}
generate() {
const {chunkGraph, chunk} = this, {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.ensureChunkHandlers, withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI), withExternalInstallChunk = this.runtimeRequirements.has(RuntimeGlobals.externalInstallChunk), withOnChunkLoad = this.runtimeRequirements.has(RuntimeGlobals.onChunksLoaded), withLoading = this.runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers), withHmr = this.runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), withHmrManifest = this.runtimeRequirements.has(RuntimeGlobals.hmrDownloadManifest), conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs), hasJsMatcher = compileBooleanMatcher(conditionMap), initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs), outputName = this.compilation.getPath(getChunkFilenameTemplate(chunk, this.compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}), rootOutputDir = getUndoPath(outputName, this.compilation.outputOptions.path, !1), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_readFileVm` : void 0;
return Template.asString([ withBaseURI ? this._generateBaseUri(chunk, rootOutputDir) : "// no baseURI", "", "// object to store loaded chunks", '// "0" means "already loaded", Promise means loading', `var installedChunks = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{`, Template.indent(Array.from(initialChunkIds, (id => `${JSON.stringify(id)}: 0`)).join(",\n")), "};", "", withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}.readFileVm = ${runtimeTemplate.returningFunction("installedChunks[chunkId] === 0", "chunkId")};` : "// no on chunks loaded", "", withLoading || withExternalInstallChunk ? `var installChunk = ${runtimeTemplate.basicFunction("chunk", [ "var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;", "for(var moduleId in moreModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(moreModules, moduleId)) {`, Template.indent([ `${RuntimeGlobals.moduleFactories}[moduleId] = moreModules[moduleId];` ]), "}" ]), "}", "if(runtime) runtime(__webpack_require__);", "for(var i = 0; i < chunkIds.length; i++) {", Template.indent([ "if(installedChunks[chunkIds[i]]) {", Template.indent([ "installedChunks[chunkIds[i]][0]();" ]), "}", "installedChunks[chunkIds[i]] = 0;" ]), "}", withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}();` : "" ])};` : "// no chunk install function needed", "", withLoading ? Template.asString([ "// ReadFile + VM.run chunk loading for javascript", `${fn}.readFileVm = function(chunkId, promises) {`, !1 !== hasJsMatcher ? Template.indent([ "", "var installedChunkData = installedChunks[chunkId];", 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent([ '// array of [resolve, reject, promise] means "currently loading"', "if(installedChunkData) {", Template.indent([ "promises.push(installedChunkData[2]);" ]), "} else {", Template.indent([ !0 === hasJsMatcher ? "if(true) { // all chunks have JS" : `if(${hasJsMatcher("chunkId")}) {`, Template.indent([ "// load the chunk and return promise to it", "var promise = new Promise(function(resolve, reject) {", Template.indent([ "installedChunkData = installedChunks[chunkId] = [resolve, reject];", `var filename = require('path').join(__dirname, ${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId));`, "require('fs').readFile(filename, 'utf-8', function(err, content) {", Template.indent([ "if(err) return reject(err);", "var chunk = {};", "require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)(chunk, require, require('path').dirname(filename), filename);", "installChunk(chunk);" ]), "});" ]), "});", "promises.push(installedChunkData[2] = promise);" ]), "} else installedChunks[chunkId] = 0;" ]), "}" ]), "}" ]) : Template.indent([ "installedChunks[chunkId] = 0;" ]), "};" ]) : "// no chunk loading", "", withExternalInstallChunk ? Template.asString([ "module.exports = __webpack_require__;", `${RuntimeGlobals.externalInstallChunk} = installChunk;` ]) : "// no external install chunk", "", withHmr ? Template.asString([ "function loadUpdateChunk(chunkId, updatedModulesList) {", Template.indent([ "return new Promise(function(resolve, reject) {", Template.indent([ `var filename = require('path').join(__dirname, ${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getChunkUpdateScriptFilename}(chunkId));`, "require('fs').readFile(filename, 'utf-8', function(err, content) {", Template.indent([ "if(err) return reject(err);", "var update = {};", "require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)(update, require, require('path').dirname(filename), filename);", "var updatedModules = update.modules;", "var runtime = update.runtime;", "for(var moduleId in updatedModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(updatedModules, moduleId)) {`, Template.indent([ "currentUpdate[moduleId] = updatedModules[moduleId];", "if(updatedModulesList) updatedModulesList.push(moduleId);" ]), "}" ]), "}", "if(runtime) currentUpdateRuntime.push(runtime);", "resolve();" ]), "});" ]), "});" ]), "}", "", Template.getFunctionContent(__webpack_require__(9692)).replace(/\$key\$/g, "readFileVm").replace(/\$installedChunks\$/g, "installedChunks").replace(/\$loadUpdateChunk\$/g, "loadUpdateChunk").replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache).replace(/\$moduleFactories\$/g, RuntimeGlobals.moduleFactories).replace(/\$ensureChunkHandlers\$/g, RuntimeGlobals.ensureChunkHandlers).replace(/\$hasOwnProperty\$/g, RuntimeGlobals.hasOwnProperty).replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData).replace(/\$hmrDownloadUpdateHandlers\$/g, RuntimeGlobals.hmrDownloadUpdateHandlers).replace(/\$hmrInvalidateModuleHandlers\$/g, RuntimeGlobals.hmrInvalidateModuleHandlers) ]) : "// no HMR", "", withHmrManifest ? Template.asString([ `${RuntimeGlobals.hmrDownloadManifest} = function() {`, Template.indent([ "return new Promise(function(resolve, reject) {", Template.indent([ `var filename = require('path').join(__dirname, ${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getUpdateManifestFilename}());`, "require('fs').readFile(filename, 'utf-8', function(err, content) {", Template.indent([ "if(err) {", Template.indent([ 'if(err.code === "ENOENT") return resolve();', "return reject(err);" ]), "}", "try { resolve(JSON.parse(content)); }", "catch(e) { reject(e); }" ]), "});" ]), "});" ]), "}" ]) : "// no HMR manifest" ]);
}
};
},
34237: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), AsyncWasmLoadingRuntimeModule = __webpack_require__(67697);
module.exports = class {
constructor({type = "async-node", import: useImport = !1} = {}) {
this._type = type, this._import = useImport;
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("ReadFileCompileAsyncWasmPlugin", (compilation => {
const globalWasmLoading = compilation.outputOptions.wasmLoading, isEnabledForChunk = chunk => {
const options = chunk.getEntryOptions();
return (options && void 0 !== options.wasmLoading ? options.wasmLoading : globalWasmLoading) === this._type;
}, generateLoadBinaryCode = this._import ? path => Template.asString([ "Promise.all([import('fs'), import('url')]).then(([{ readFile }, { URL }]) => new Promise((resolve, reject) => {", Template.indent([ `readFile(new URL(${path}, import.meta.url), (err, buffer) => {`, Template.indent([ "if (err) return reject(err);", "", "// Fake fetch response", "resolve({", Template.indent([ "arrayBuffer() { return buffer; }" ]), "});" ]), "});" ]), "}))" ]) : path => Template.asString([ "new Promise(function (resolve, reject) {", Template.indent([ "try {", Template.indent([ "var { readFile } = require('fs');", "var { join } = require('path');", "", `readFile(join(__dirname, ${path}), function(err, buffer){`, Template.indent([ "if (err) return reject(err);", "", "// Fake fetch response", "resolve({", Template.indent([ "arrayBuffer() { return buffer; }" ]), "});" ]), "});" ]), "} catch (err) { reject(err); }" ]), "})" ]);
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.instantiateWasm).tap("ReadFileCompileAsyncWasmPlugin", ((chunk, set) => {
if (!isEnabledForChunk(chunk)) return;
compilation.chunkGraph.hasModuleInGraph(chunk, (m => "webassembly/async" === m.type)) && (set.add(RuntimeGlobals.publicPath), 
compilation.addRuntimeModule(chunk, new AsyncWasmLoadingRuntimeModule({
generateLoadBinaryCode,
supportsStreaming: !1
})));
}));
}));
}
};
},
83410: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), WasmChunkLoadingRuntimeModule = __webpack_require__(626);
module.exports = class {
constructor(options) {
this.options = options || {};
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("ReadFileCompileWasmPlugin", (compilation => {
const globalWasmLoading = compilation.outputOptions.wasmLoading, generateLoadBinaryCode = path => Template.asString([ "new Promise(function (resolve, reject) {", Template.indent([ "var { readFile } = require('fs');", "var { join } = require('path');", "", "try {", Template.indent([ `readFile(join(__dirname, ${path}), function(err, buffer){`, Template.indent([ "if (err) return reject(err);", "", "// Fake fetch response", "resolve({", Template.indent([ "arrayBuffer() { return buffer; }" ]), "});" ]), "});" ]), "} catch (err) { reject(err); }" ]), "})" ]);
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("ReadFileCompileWasmPlugin", ((chunk, set) => {
if (!(chunk => {
const options = chunk.getEntryOptions();
return "async-node" === (options && void 0 !== options.wasmLoading ? options.wasmLoading : globalWasmLoading);
})(chunk)) return;
compilation.chunkGraph.hasModuleInGraph(chunk, (m => "webassembly/sync" === m.type)) && (set.add(RuntimeGlobals.moduleCache), 
compilation.addRuntimeModule(chunk, new WasmChunkLoadingRuntimeModule({
generateLoadBinaryCode,
supportsStreaming: !1,
mangleImports: this.options.mangleImports,
runtimeRequirements: set
})));
}));
}));
}
};
},
41433: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {chunkHasJs, getChunkFilenameTemplate} = __webpack_require__(18362), {getInitialChunkIds} = __webpack_require__(19202), compileBooleanMatcher = __webpack_require__(65814), {getUndoPath} = __webpack_require__(63264);
module.exports = class extends RuntimeModule {
constructor(runtimeRequirements) {
super("require chunk loading", RuntimeModule.STAGE_ATTACH), this.runtimeRequirements = runtimeRequirements;
}
_generateBaseUri(chunk, rootOutputDir) {
const options = chunk.getEntryOptions();
return options && options.baseUri ? `${RuntimeGlobals.baseURI} = ${JSON.stringify(options.baseUri)};` : `${RuntimeGlobals.baseURI} = require("url").pathToFileURL(${"./" !== rootOutputDir ? `__dirname + ${JSON.stringify("/" + rootOutputDir)}` : "__filename"});`;
}
generate() {
const {chunkGraph, chunk} = this, {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.ensureChunkHandlers, withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI), withExternalInstallChunk = this.runtimeRequirements.has(RuntimeGlobals.externalInstallChunk), withOnChunkLoad = this.runtimeRequirements.has(RuntimeGlobals.onChunksLoaded), withLoading = this.runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers), withHmr = this.runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), withHmrManifest = this.runtimeRequirements.has(RuntimeGlobals.hmrDownloadManifest), conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs), hasJsMatcher = compileBooleanMatcher(conditionMap), initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs), outputName = this.compilation.getPath(getChunkFilenameTemplate(chunk, this.compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}), rootOutputDir = getUndoPath(outputName, this.compilation.outputOptions.path, !0), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_require` : void 0;
return Template.asString([ withBaseURI ? this._generateBaseUri(chunk, rootOutputDir) : "// no baseURI", "", "// object to store loaded chunks", '// "1" means "loaded", otherwise not loaded yet', `var installedChunks = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{`, Template.indent(Array.from(initialChunkIds, (id => `${JSON.stringify(id)}: 1`)).join(",\n")), "};", "", withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}.require = ${runtimeTemplate.returningFunction("installedChunks[chunkId]", "chunkId")};` : "// no on chunks loaded", "", withLoading || withExternalInstallChunk ? `var installChunk = ${runtimeTemplate.basicFunction("chunk", [ "var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;", "for(var moduleId in moreModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(moreModules, moduleId)) {`, Template.indent([ `${RuntimeGlobals.moduleFactories}[moduleId] = moreModules[moduleId];` ]), "}" ]), "}", "if(runtime) runtime(__webpack_require__);", "for(var i = 0; i < chunkIds.length; i++)", Template.indent("installedChunks[chunkIds[i]] = 1;"), withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}();` : "" ])};` : "// no chunk install function needed", "", withLoading ? Template.asString([ "// require() chunk loading for javascript", `${fn}.require = ${runtimeTemplate.basicFunction("chunkId, promises", !1 !== hasJsMatcher ? [ '// "1" is the signal for "already loaded"', "if(!installedChunks[chunkId]) {", Template.indent([ !0 === hasJsMatcher ? "if(true) { // all chunks have JS" : `if(${hasJsMatcher("chunkId")}) {`, Template.indent([ `installChunk(require(${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId)));` ]), "} else installedChunks[chunkId] = 1;", "" ]), "}" ] : "installedChunks[chunkId] = 1;")};` ]) : "// no chunk loading", "", withExternalInstallChunk ? Template.asString([ "module.exports = __webpack_require__;", `${RuntimeGlobals.externalInstallChunk} = installChunk;` ]) : "// no external install chunk", "", withHmr ? Template.asString([ "function loadUpdateChunk(chunkId, updatedModulesList) {", Template.indent([ `var update = require(${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getChunkUpdateScriptFilename}(chunkId));`, "var updatedModules = update.modules;", "var runtime = update.runtime;", "for(var moduleId in updatedModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(updatedModules, moduleId)) {`, Template.indent([ "currentUpdate[moduleId] = updatedModules[moduleId];", "if(updatedModulesList) updatedModulesList.push(moduleId);" ]), "}" ]), "}", "if(runtime) currentUpdateRuntime.push(runtime);" ]), "}", "", Template.getFunctionContent(__webpack_require__(9692)).replace(/\$key\$/g, "require").replace(/\$installedChunks\$/g, "installedChunks").replace(/\$loadUpdateChunk\$/g, "loadUpdateChunk").replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache).replace(/\$moduleFactories\$/g, RuntimeGlobals.moduleFactories).replace(/\$ensureChunkHandlers\$/g, RuntimeGlobals.ensureChunkHandlers).replace(/\$hasOwnProperty\$/g, RuntimeGlobals.hasOwnProperty).replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData).replace(/\$hmrDownloadUpdateHandlers\$/g, RuntimeGlobals.hmrDownloadUpdateHandlers).replace(/\$hmrInvalidateModuleHandlers\$/g, RuntimeGlobals.hmrInvalidateModuleHandlers) ]) : "// no HMR", "", withHmrManifest ? Template.asString([ `${RuntimeGlobals.hmrDownloadManifest} = function() {`, Template.indent([ "return Promise.resolve().then(function() {", Template.indent([ `return require(${JSON.stringify(rootOutputDir)} + ${RuntimeGlobals.getUpdateManifestFilename}());` ]), "})['catch'](function(err) { if(err.code !== 'MODULE_NOT_FOUND') throw err; });" ]), "}" ]) : "// no HMR manifest" ]);
}
};
},
23056: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), truncateArgs = __webpack_require__(66813);
module.exports = ({colors, appendOnly, stream}) => {
let currentStatusMessage, hasStatusMessage = !1, currentIndent = "", currentCollapsed = 0;
const clearStatusMessage = () => {
hasStatusMessage && (stream.write("[2K\r"), hasStatusMessage = !1);
}, writeStatusMessage = () => {
if (!currentStatusMessage) return;
const l = stream.columns, coloredStr = `[1m${(l ? truncateArgs(currentStatusMessage, l - 1) : currentStatusMessage).join(" ")}[39m[22m`;
stream.write(`[2K\r${coloredStr}`), hasStatusMessage = !0;
}, writeColored = (prefix, colorPrefix, colorSuffix) => (...args) => {
if (currentCollapsed > 0) return;
clearStatusMessage();
const str = ((str, prefix, colorPrefix, colorSuffix) => "" === str ? str : (prefix = currentIndent + prefix, 
colors ? prefix + colorPrefix + str.replace(/\n/g, colorSuffix + "\n" + prefix + colorPrefix) + colorSuffix : prefix + str.replace(/\n/g, "\n" + prefix)))(util.format(...args), prefix, colorPrefix, colorSuffix);
stream.write(str + "\n"), writeStatusMessage();
}, writeGroupMessage = writeColored("<-> ", "[1m[36m", "[39m[22m"), writeGroupCollapsedMessage = writeColored("<+> ", "[1m[36m", "[39m[22m");
return {
log: writeColored("    ", "[1m", "[22m"),
debug: writeColored("    ", "", ""),
trace: writeColored("    ", "", ""),
info: writeColored("<i> ", "[1m[32m", "[39m[22m"),
warn: writeColored("<w> ", "[1m[33m", "[39m[22m"),
error: writeColored("<e> ", "[1m[31m", "[39m[22m"),
logTime: writeColored("<t> ", "[1m[35m", "[39m[22m"),
group: (...args) => {
writeGroupMessage(...args), currentCollapsed > 0 ? currentCollapsed++ : currentIndent += "  ";
},
groupCollapsed: (...args) => {
writeGroupCollapsedMessage(...args), currentCollapsed++;
},
groupEnd: () => {
currentCollapsed > 0 ? currentCollapsed-- : currentIndent.length >= 2 && (currentIndent = currentIndent.slice(0, currentIndent.length - 2));
},
profile: console.profile && (name => console.profile(name)),
profileEnd: console.profileEnd && (name => console.profileEnd(name)),
clear: !appendOnly && console.clear && (() => {
clearStatusMessage(), console.clear(), writeStatusMessage();
}),
status: appendOnly ? writeColored("<s> ", "", "") : (name, ...args) => {
args = args.filter(Boolean), void 0 === name && 0 === args.length ? (clearStatusMessage(), 
currentStatusMessage = void 0) : "string" == typeof name && name.startsWith("[webpack.Progress] ") ? (currentStatusMessage = [ name.slice(19), ...args ], 
writeStatusMessage()) : "[webpack.Progress]" === name ? (currentStatusMessage = [ ...args ], 
writeStatusMessage()) : (currentStatusMessage = [ name, ...args ], writeStatusMessage());
}
};
};
},
66922: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_ADVANCED} = __webpack_require__(60933);
module.exports = class {
constructor(options) {
if (void 0 !== options && "object" != typeof options || Array.isArray(options)) throw new Error("Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https://webpack.js.org/plugins/");
this.options = options || {};
}
apply(compiler) {
const minSizeReduce = this.options.minSizeReduce || 1.5;
compiler.hooks.thisCompilation.tap("AggressiveMergingPlugin", (compilation => {
compilation.hooks.optimizeChunks.tap({
name: "AggressiveMergingPlugin",
stage: STAGE_ADVANCED
}, (chunks => {
const chunkGraph = compilation.chunkGraph;
let combinations = [];
for (const a of chunks) if (!a.canBeInitial()) for (const b of chunks) {
if (b.canBeInitial()) continue;
if (b === a) break;
if (!chunkGraph.canChunksBeIntegrated(a, b)) continue;
const improvement = (chunkGraph.getChunkSize(b, {
chunkOverhead: 0
}) + chunkGraph.getChunkSize(a, {
chunkOverhead: 0
})) / chunkGraph.getIntegratedChunksSize(b, a, {
chunkOverhead: 0
});
combinations.push({
a,
b,
improvement
});
}
combinations.sort(((a, b) => b.improvement - a.improvement));
const pair = combinations[0];
if (pair && !(pair.improvement < minSizeReduce)) return chunkGraph.integrateChunks(pair.b, pair.a), 
compilation.chunks.delete(pair.a), !0;
}));
}));
}
};
},
10085: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_ADVANCED} = __webpack_require__(60933), {intersect} = __webpack_require__(73974), {compareModulesByIdentifier, compareChunks} = __webpack_require__(40028), createSchemaValidation = __webpack_require__(59586), identifierUtils = __webpack_require__(63264), validate = createSchemaValidation(__webpack_require__(65623), (() => __webpack_require__(3484)), {
name: "Aggressive Splitting Plugin",
baseDataPath: "options"
}), moveModuleBetween = (chunkGraph, oldChunk, newChunk) => module => {
chunkGraph.disconnectChunkAndModule(oldChunk, module), chunkGraph.connectChunkAndModule(newChunk, module);
}, isNotAEntryModule = (chunkGraph, chunk) => module => !chunkGraph.isEntryModuleInChunk(module, chunk), recordedChunks = new WeakSet;
module.exports = class {
constructor(options = {}) {
validate(options), this.options = options, "number" != typeof this.options.minSize && (this.options.minSize = 30720), 
"number" != typeof this.options.maxSize && (this.options.maxSize = 51200), "number" != typeof this.options.chunkOverhead && (this.options.chunkOverhead = 0), 
"number" != typeof this.options.entryChunkMultiplicator && (this.options.entryChunkMultiplicator = 1);
}
static wasChunkRecorded(chunk) {
return recordedChunks.has(chunk);
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("AggressiveSplittingPlugin", (compilation => {
let newSplits, fromAggressiveSplittingSet, chunkSplitDataMap, needAdditionalSeal = !1;
compilation.hooks.optimize.tap("AggressiveSplittingPlugin", (() => {
newSplits = [], fromAggressiveSplittingSet = new Set, chunkSplitDataMap = new Map;
})), compilation.hooks.optimizeChunks.tap({
name: "AggressiveSplittingPlugin",
stage: STAGE_ADVANCED
}, (chunks => {
const chunkGraph = compilation.chunkGraph, nameToModuleMap = new Map, moduleToNameMap = new Map, makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);
for (const m of compilation.modules) {
const name = makePathsRelative(m.identifier());
nameToModuleMap.set(name, m), moduleToNameMap.set(m, name);
}
const usedIds = new Set;
for (const chunk of chunks) usedIds.add(chunk.id);
const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [], usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits, minSize = this.options.minSize, maxSize = this.options.maxSize, applySplit = splitData => {
if (void 0 !== splitData.id && usedIds.has(splitData.id)) return !1;
const selectedModules = splitData.modules.map((name => nameToModuleMap.get(name)));
if (!selectedModules.every(Boolean)) return !1;
let size = 0;
for (const m of selectedModules) size += m.size();
if (size !== splitData.size) return !1;
const selectedChunks = intersect(selectedModules.map((m => new Set(chunkGraph.getModuleChunksIterable(m)))));
if (0 === selectedChunks.size) return !1;
if (1 === selectedChunks.size && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {
const chunk = Array.from(selectedChunks)[0];
return !fromAggressiveSplittingSet.has(chunk) && (fromAggressiveSplittingSet.add(chunk), 
chunkSplitDataMap.set(chunk, splitData), !0);
}
const newChunk = compilation.addChunk();
newChunk.chunkReason = "aggressive splitted";
for (const chunk of selectedChunks) selectedModules.forEach(moveModuleBetween(chunkGraph, chunk, newChunk)), 
chunk.split(newChunk), chunk.name = null;
return fromAggressiveSplittingSet.add(newChunk), chunkSplitDataMap.set(newChunk, splitData), 
null !== splitData.id && void 0 !== splitData.id && (newChunk.id = splitData.id, 
newChunk.ids = [ splitData.id ]), !0;
};
let changed = !1;
for (let j = 0; j < usedSplits.length; j++) {
applySplit(usedSplits[j]) && (changed = !0);
}
const cmpFn = compareChunks(chunkGraph), sortedChunks = Array.from(chunks).sort(((a, b) => {
const diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);
if (diff1) return diff1;
const diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);
return diff2 || cmpFn(a, b);
}));
for (const chunk of sortedChunks) {
if (fromAggressiveSplittingSet.has(chunk)) continue;
if (chunkGraph.getChunkModulesSize(chunk) > maxSize && chunkGraph.getNumberOfChunkModules(chunk) > 1) {
const modules = chunkGraph.getOrderedChunkModules(chunk, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, chunk)), selectedModules = [];
let selectedModulesSize = 0;
for (let k = 0; k < modules.length; k++) {
const module = modules[k], newSize = selectedModulesSize + module.size();
if (newSize > maxSize && selectedModulesSize >= minSize) break;
selectedModulesSize = newSize, selectedModules.push(module);
}
if (0 === selectedModules.length) continue;
const splitData = {
modules: selectedModules.map((m => moduleToNameMap.get(m))).sort(),
size: selectedModulesSize
};
applySplit(splitData) && (newSplits = (newSplits || []).concat(splitData), changed = !0);
}
}
if (changed) return !0;
})), compilation.hooks.recordHash.tap("AggressiveSplittingPlugin", (records => {
const allSplits = new Set, invalidSplits = new Set;
for (const chunk of compilation.chunks) {
const splitData = chunkSplitDataMap.get(chunk);
void 0 !== splitData && splitData.hash && chunk.hash !== splitData.hash && invalidSplits.add(splitData);
}
if (invalidSplits.size > 0) records.aggressiveSplits = records.aggressiveSplits.filter((splitData => !invalidSplits.has(splitData))), 
needAdditionalSeal = !0; else {
for (const chunk of compilation.chunks) {
const splitData = chunkSplitDataMap.get(chunk);
void 0 !== splitData && (splitData.hash = chunk.hash, splitData.id = chunk.id, allSplits.add(splitData), 
recordedChunks.add(chunk));
}
const recordedSplits = compilation.records && compilation.records.aggressiveSplits;
if (recordedSplits) for (const splitData of recordedSplits) invalidSplits.has(splitData) || allSplits.add(splitData);
records.aggressiveSplits = Array.from(allSplits), needAdditionalSeal = !1;
}
})), compilation.hooks.needAdditionalSeal.tap("AggressiveSplittingPlugin", (() => {
if (needAdditionalSeal) return needAdditionalSeal = !1, !0;
}));
}));
}
};
},
36005: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const eslintScope = __webpack_require__(25048), Referencer = __webpack_require__(1625), {CachedSource, ConcatSource, ReplaceSource} = __webpack_require__(37946), ConcatenationScope = __webpack_require__(87291), {UsageState} = __webpack_require__(74603), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HarmonyImportDependency = __webpack_require__(75015), JavascriptParser = __webpack_require__(36793), {equals} = __webpack_require__(8579), LazySet = __webpack_require__(92585), {concatComparators} = __webpack_require__(40028), createHash = __webpack_require__(27466), {makePathsRelative} = __webpack_require__(63264), makeSerializable = __webpack_require__(45898), propertyAccess = __webpack_require__(10664), {filterRuntime, intersectRuntime, mergeRuntimeCondition, mergeRuntimeConditionNonFalse, runtimeConditionToString, subtractRuntimeCondition} = __webpack_require__(14372), ReferencerClass = Referencer;
ReferencerClass.prototype.PropertyDefinition || (ReferencerClass.prototype.PropertyDefinition = ReferencerClass.prototype.Property);
const RESERVED_NAMES = new Set([ ConcatenationScope.DEFAULT_EXPORT, ConcatenationScope.NAMESPACE_OBJECT_EXPORT, "abstract,arguments,async,await,boolean,break,byte,case,catch,char,class,const,continue", "debugger,default,delete,do,double,else,enum,eval,export,extends,false,final,finally,float", "for,function,goto,if,implements,import,in,instanceof,int,interface,let,long,native,new,null", "package,private,protected,public,return,short,static,super,switch,synchronized,this,throw", "throws,transient,true,try,typeof,var,void,volatile,while,with,yield", "module,__dirname,__filename,exports,require,define", "Array,Date,eval,function,hasOwnProperty,Infinity,isFinite,isNaN,isPrototypeOf,length,Math", "NaN,name,Number,Object,prototype,String,toString,undefined,valueOf", "alert,all,anchor,anchors,area,assign,blur,button,checkbox,clearInterval,clearTimeout", "clientInformation,close,closed,confirm,constructor,crypto,decodeURI,decodeURIComponent", "defaultStatus,document,element,elements,embed,embeds,encodeURI,encodeURIComponent,escape", "event,fileUpload,focus,form,forms,frame,innerHeight,innerWidth,layer,layers,link,location", "mimeTypes,navigate,navigator,frames,frameRate,hidden,history,image,images,offscreenBuffering", "open,opener,option,outerHeight,outerWidth,packages,pageXOffset,pageYOffset,parent,parseFloat", "parseInt,password,pkcs11,plugin,prompt,propertyIsEnum,radio,reset,screenX,screenY,scroll", "secure,select,self,setInterval,setTimeout,status,submit,taint,text,textarea,top,unescape", "untaint,window", "onblur,onclick,onerror,onfocus,onkeydown,onkeypress,onkeyup,onmouseover,onload,onmouseup,onmousedown,onsubmit" ].join(",").split(",")), createComparator = (property, comparator) => (a, b) => comparator(a[property], b[property]), compareNumbers = (a, b) => {
if (isNaN(a)) {
if (!isNaN(b)) return 1;
} else {
if (isNaN(b)) return -1;
if (a !== b) return a < b ? -1 : 1;
}
return 0;
}, bySourceOrder = createComparator("sourceOrder", compareNumbers), byRangeStart = createComparator("rangeStart", compareNumbers), getFinalBinding = (moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, strictHarmonyModule, asiSafe, alreadyVisited = new Set) => {
const exportsType = info.module.getExportsType(moduleGraph, strictHarmonyModule);
if (0 === exportName.length) switch (exportsType) {
case "default-only":
return info.interopNamespaceObject2Used = !0, {
info,
rawName: info.interopNamespaceObject2Name,
ids: exportName,
exportName
};

case "default-with-named":
return info.interopNamespaceObjectUsed = !0, {
info,
rawName: info.interopNamespaceObjectName,
ids: exportName,
exportName
};

case "namespace":
case "dynamic":
break;

default:
throw new Error(`Unexpected exportsType ${exportsType}`);
} else switch (exportsType) {
case "namespace":
break;

case "default-with-named":
switch (exportName[0]) {
case "default":
exportName = exportName.slice(1);
break;

case "__esModule":
return {
info,
rawName: "/* __esModule */true",
ids: exportName.slice(1),
exportName
};
}
break;

case "default-only":
{
const exportId = exportName[0];
if ("__esModule" === exportId) return {
info,
rawName: "/* __esModule */true",
ids: exportName.slice(1),
exportName
};
if (exportName = exportName.slice(1), "default" !== exportId) return {
info,
rawName: "/* non-default import from default-exporting module */undefined",
ids: exportName,
exportName
};
break;
}

case "dynamic":
switch (exportName[0]) {
case "default":
exportName = exportName.slice(1), info.interopDefaultAccessUsed = !0;
return {
info,
rawName: asCall ? `${info.interopDefaultAccessName}()` : asiSafe ? `(${info.interopDefaultAccessName}())` : !1 === asiSafe ? `;(${info.interopDefaultAccessName}())` : `${info.interopDefaultAccessName}.a`,
ids: exportName,
exportName
};

case "__esModule":
return {
info,
rawName: "/* __esModule */true",
ids: exportName.slice(1),
exportName
};
}
break;

default:
throw new Error(`Unexpected exportsType ${exportsType}`);
}
if (0 === exportName.length) switch (info.type) {
case "concatenated":
return neededNamespaceObjects.add(info), {
info,
rawName: info.namespaceObjectName,
ids: exportName,
exportName
};

case "external":
return {
info,
rawName: info.name,
ids: exportName,
exportName
};
}
const exportsInfo = moduleGraph.getExportsInfo(info.module), exportInfo = exportsInfo.getExportInfo(exportName[0]);
if (alreadyVisited.has(exportInfo)) return {
info,
rawName: "/* circular reexport */ Object(function x() { x() }())",
ids: [],
exportName
};
switch (alreadyVisited.add(exportInfo), info.type) {
case "concatenated":
{
const exportId = exportName[0];
if (!1 === exportInfo.provided) return neededNamespaceObjects.add(info), {
info,
rawName: info.namespaceObjectName,
ids: exportName,
exportName
};
const directExport = info.exportMap && info.exportMap.get(exportId);
if (directExport) {
const usedName = exportsInfo.getUsedName(exportName, runtime);
return usedName ? {
info,
name: directExport,
ids: usedName.slice(1),
exportName
} : {
info,
rawName: "/* unused export */ undefined",
ids: exportName.slice(1),
exportName
};
}
const rawExport = info.rawExportMap && info.rawExportMap.get(exportId);
if (rawExport) return {
info,
rawName: rawExport,
ids: exportName.slice(1),
exportName
};
const reexport = exportInfo.findTarget(moduleGraph, (module => moduleToInfoMap.has(module)));
if (!1 === reexport) throw new Error(`Target module of reexport from '${info.module.readableIdentifier(requestShortener)}' is not part of the concatenation (export '${exportId}')\nModules in the concatenation:\n${Array.from(moduleToInfoMap, (([m, info]) => ` * ${info.type} ${m.readableIdentifier(requestShortener)}`)).join("\n")}`);
if (reexport) {
const refInfo = moduleToInfoMap.get(reexport.module);
return getFinalBinding(moduleGraph, refInfo, reexport.export ? [ ...reexport.export, ...exportName.slice(1) ] : exportName.slice(1), moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, info.module.buildMeta.strictHarmonyModule, asiSafe, alreadyVisited);
}
if (info.namespaceExportSymbol) {
const usedName = exportsInfo.getUsedName(exportName, runtime);
return {
info,
rawName: info.namespaceObjectName,
ids: usedName,
exportName
};
}
throw new Error(`Cannot get final name for export '${exportName.join(".")}' of ${info.module.readableIdentifier(requestShortener)}`);
}

case "external":
{
const used = exportsInfo.getUsedName(exportName, runtime);
if (!used) return {
info,
rawName: "/* unused export */ undefined",
ids: exportName.slice(1),
exportName
};
const comment = equals(used, exportName) ? "" : Template.toNormalComment(`${exportName.join(".")}`);
return {
info,
rawName: info.name + comment,
ids: used,
exportName
};
}
}
}, getFinalName = (moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, callContext, strictHarmonyModule, asiSafe) => {
const binding = getFinalBinding(moduleGraph, info, exportName, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, asCall, strictHarmonyModule, asiSafe);
{
const {ids, comment} = binding;
let reference, isPropertyAccess;
if ("rawName" in binding) reference = `${binding.rawName}${comment || ""}${propertyAccess(ids)}`, 
isPropertyAccess = ids.length > 0; else {
const {info, name: exportId} = binding, name = info.internalNames.get(exportId);
if (!name) throw new Error(`The export "${exportId}" in "${info.module.readableIdentifier(requestShortener)}" has no internal name (existing names: ${Array.from(info.internalNames, (([name, symbol]) => `${name}: ${symbol}`)).join(", ") || "none"})`);
reference = `${name}${comment || ""}${propertyAccess(ids)}`, isPropertyAccess = ids.length > 1;
}
return isPropertyAccess && asCall && !1 === callContext ? asiSafe ? `(0,${reference})` : !1 === asiSafe ? `;(0,${reference})` : `/*#__PURE__*/Object(${reference})` : reference;
}
}, addScopeSymbols = (s, nameSet, scopeSet1, scopeSet2) => {
let scope = s;
for (;scope && !scopeSet1.has(scope) && !scopeSet2.has(scope); ) {
scopeSet1.add(scope);
for (const variable of scope.variables) nameSet.add(variable.name);
scope = scope.upper;
}
}, getAllReferences = variable => {
let set = variable.references;
const identifiers = new Set(variable.identifiers);
for (const scope of variable.scope.childScopes) for (const innerVar of scope.variables) if (innerVar.identifiers.some((id => identifiers.has(id)))) {
set = set.concat(innerVar.references);
break;
}
return set;
}, getPathInAst = (ast, node) => {
if (ast === node) return [];
const nr = node.range, enterNode = n => {
if (!n) return;
const r = n.range;
if (r && r[0] <= nr[0] && r[1] >= nr[1]) {
const path = getPathInAst(n, node);
if (path) return path.push(n), path;
}
};
if (Array.isArray(ast)) for (let i = 0; i < ast.length; i++) {
const enterResult = enterNode(ast[i]);
if (void 0 !== enterResult) return enterResult;
} else if (ast && "object" == typeof ast) {
const keys = Object.keys(ast);
for (let i = 0; i < keys.length; i++) {
const value = ast[keys[i]];
if (Array.isArray(value)) {
const pathResult = getPathInAst(value, node);
if (void 0 !== pathResult) return pathResult;
} else if (value && "object" == typeof value) {
const enterResult = enterNode(value);
if (void 0 !== enterResult) return enterResult;
}
}
}
}, TYPES = new Set([ "javascript" ]);
class ConcatenatedModule extends Module {
static create(rootModule, modules, runtime, associatedObjectForCache, hashFunction = "md4") {
const identifier = ConcatenatedModule._createIdentifier(rootModule, modules, associatedObjectForCache, hashFunction);
return new ConcatenatedModule({
identifier,
rootModule,
modules,
runtime
});
}
constructor({identifier, rootModule, modules, runtime}) {
super("javascript/esm", null, rootModule && rootModule.layer), this._identifier = identifier, 
this.rootModule = rootModule, this._modules = modules, this._runtime = runtime, 
this.factoryMeta = rootModule && rootModule.factoryMeta;
}
updateCacheModule(module) {
throw new Error("Must not be called");
}
getSourceTypes() {
return TYPES;
}
get modules() {
return Array.from(this._modules);
}
identifier() {
return this._identifier;
}
readableIdentifier(requestShortener) {
return this.rootModule.readableIdentifier(requestShortener) + ` + ${this._modules.size - 1} modules`;
}
libIdent(options) {
return this.rootModule.libIdent(options);
}
nameForCondition() {
return this.rootModule.nameForCondition();
}
getSideEffectsConnectionState(moduleGraph) {
return this.rootModule.getSideEffectsConnectionState(moduleGraph);
}
build(options, compilation, resolver, fs, callback) {
const {rootModule} = this;
this.buildInfo = {
strict: !0,
cacheable: !0,
moduleArgument: rootModule.buildInfo.moduleArgument,
exportsArgument: rootModule.buildInfo.exportsArgument,
fileDependencies: new LazySet,
contextDependencies: new LazySet,
missingDependencies: new LazySet,
topLevelDeclarations: new Set,
assets: void 0
}, this.buildMeta = rootModule.buildMeta, this.clearDependenciesAndBlocks(), this.clearWarningsAndErrors();
for (const m of this._modules) {
m.buildInfo.cacheable || (this.buildInfo.cacheable = !1);
for (const d of m.dependencies.filter((dep => !(dep instanceof HarmonyImportDependency && this._modules.has(compilation.moduleGraph.getModule(dep)))))) this.dependencies.push(d);
for (const d of m.blocks) this.blocks.push(d);
const warnings = m.getWarnings();
if (void 0 !== warnings) for (const warning of warnings) this.addWarning(warning);
const errors = m.getErrors();
if (void 0 !== errors) for (const error of errors) this.addError(error);
if (m.buildInfo.topLevelDeclarations) {
const topLevelDeclarations = this.buildInfo.topLevelDeclarations;
if (void 0 !== topLevelDeclarations) for (const decl of m.buildInfo.topLevelDeclarations) topLevelDeclarations.add(decl);
} else this.buildInfo.topLevelDeclarations = void 0;
if (m.buildInfo.assets && (void 0 === this.buildInfo.assets && (this.buildInfo.assets = Object.create(null)), 
Object.assign(this.buildInfo.assets, m.buildInfo.assets)), m.buildInfo.assetsInfo) {
void 0 === this.buildInfo.assetsInfo && (this.buildInfo.assetsInfo = new Map);
for (const [key, value] of m.buildInfo.assetsInfo) this.buildInfo.assetsInfo.set(key, value);
}
}
callback();
}
size(type) {
let size = 0;
for (const module of this._modules) size += module.size(type);
return size;
}
_createConcatenationList(rootModule, modulesSet, runtime, moduleGraph) {
const list = [], existingEntries = new Map, getConcatenatedImports = module => {
let connections = Array.from(moduleGraph.getOutgoingConnections(module));
if (module === rootModule) for (const c of moduleGraph.getOutgoingConnections(this)) connections.push(c);
const references = connections.filter((connection => connection.dependency instanceof HarmonyImportDependency && (connection && connection.resolvedOriginModule === module && connection.module && connection.isTargetActive(runtime)))).map((connection => {
const dep = connection.dependency;
return {
connection,
sourceOrder: dep.sourceOrder,
rangeStart: dep.range && dep.range[0]
};
}));
references.sort(concatComparators(bySourceOrder, byRangeStart));
const referencesMap = new Map;
for (const {connection} of references) {
const runtimeCondition = filterRuntime(runtime, (r => connection.isTargetActive(r)));
if (!1 === runtimeCondition) continue;
const module = connection.module, entry = referencesMap.get(module);
void 0 !== entry ? entry.runtimeCondition = mergeRuntimeConditionNonFalse(entry.runtimeCondition, runtimeCondition, runtime) : referencesMap.set(module, {
connection,
runtimeCondition
});
}
return referencesMap.values();
}, enterModule = (connection, runtimeCondition) => {
const module = connection.module;
if (!module) return;
const existingEntry = existingEntries.get(module);
if (!0 !== existingEntry) if (modulesSet.has(module)) {
if (existingEntries.set(module, !0), !0 !== runtimeCondition) throw new Error(`Cannot runtime-conditional concatenate a module (${module.identifier()} in ${this.rootModule.identifier()}, ${runtimeConditionToString(runtimeCondition)}). This should not happen.`);
const imports = getConcatenatedImports(module);
for (const {connection, runtimeCondition} of imports) enterModule(connection, runtimeCondition);
list.push({
type: "concatenated",
module: connection.module,
runtimeCondition
});
} else {
if (void 0 !== existingEntry) {
const reducedRuntimeCondition = subtractRuntimeCondition(runtimeCondition, existingEntry, runtime);
if (!1 === reducedRuntimeCondition) return;
runtimeCondition = reducedRuntimeCondition, existingEntries.set(connection.module, mergeRuntimeConditionNonFalse(existingEntry, runtimeCondition, runtime));
} else existingEntries.set(connection.module, runtimeCondition);
if (list.length > 0) {
const lastItem = list[list.length - 1];
if ("external" === lastItem.type && lastItem.module === connection.module) return void (lastItem.runtimeCondition = mergeRuntimeCondition(lastItem.runtimeCondition, runtimeCondition, runtime));
}
list.push({
type: "external",
get module() {
return connection.module;
},
runtimeCondition
});
}
};
existingEntries.set(rootModule, !0);
const imports = getConcatenatedImports(rootModule);
for (const {connection, runtimeCondition} of imports) enterModule(connection, runtimeCondition);
return list.push({
type: "concatenated",
module: rootModule,
runtimeCondition: !0
}), list;
}
static _createIdentifier(rootModule, modules, associatedObjectForCache, hashFunction = "md4") {
const cachedMakePathsRelative = makePathsRelative.bindContextCache(rootModule.context, associatedObjectForCache);
let identifiers = [];
for (const module of modules) identifiers.push(cachedMakePathsRelative(module.identifier()));
identifiers.sort();
const hash = createHash(hashFunction);
return hash.update(identifiers.join(" ")), rootModule.identifier() + "|" + hash.digest("hex");
}
addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies) {
for (const module of this._modules) module.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);
}
codeGeneration({dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime: generationRuntime, codeGenerationResults}) {
const runtimeRequirements = new Set, runtime = intersectRuntime(generationRuntime, this._runtime), requestShortener = runtimeTemplate.requestShortener, [modulesWithInfo, moduleToInfoMap] = this._getModulesWithInfo(moduleGraph, runtime), neededNamespaceObjects = new Set;
for (const info of moduleToInfoMap.values()) this._analyseModule(moduleToInfoMap, info, dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, codeGenerationResults);
const allUsedNames = new Set(RESERVED_NAMES), topLevelDeclarations = new Set, usedNamesInScopeInfo = new Map, getUsedNamesInScopeInfo = (module, id) => {
const key = `${module}-${id}`;
let info = usedNamesInScopeInfo.get(key);
return void 0 === info && (info = {
usedNames: new Set,
alreadyCheckedScopes: new Set
}, usedNamesInScopeInfo.set(key, info)), info;
}, ignoredScopes = new Set;
for (const info of modulesWithInfo) if ("concatenated" === info.type) {
info.moduleScope && ignoredScopes.add(info.moduleScope);
const superClassCache = new WeakMap, getSuperClassExpressions = scope => {
const cacheEntry = superClassCache.get(scope);
if (void 0 !== cacheEntry) return cacheEntry;
const superClassExpressions = [];
for (const childScope of scope.childScopes) {
if ("class" !== childScope.type) continue;
const block = childScope.block;
"ClassDeclaration" !== block.type && "ClassExpression" !== block.type || !block.superClass || superClassExpressions.push({
range: block.superClass.range,
variables: childScope.variables
});
}
return superClassCache.set(scope, superClassExpressions), superClassExpressions;
};
if (info.globalScope) for (const reference of info.globalScope.through) {
const name = reference.identifier.name;
if (ConcatenationScope.isModuleReference(name)) {
const match = ConcatenationScope.matchModuleReference(name);
if (!match) continue;
const referencedInfo = modulesWithInfo[match.index];
if ("reference" === referencedInfo.type) throw new Error("Module reference can't point to a reference");
const binding = getFinalBinding(moduleGraph, referencedInfo, match.ids, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, !1, info.module.buildMeta.strictHarmonyModule, !0);
if (!binding.ids) continue;
const {usedNames, alreadyCheckedScopes} = getUsedNamesInScopeInfo(binding.info.module.identifier(), "name" in binding ? binding.name : "");
for (const expr of getSuperClassExpressions(reference.from)) if (expr.range[0] <= reference.identifier.range[0] && expr.range[1] >= reference.identifier.range[1]) for (const variable of expr.variables) usedNames.add(variable.name);
addScopeSymbols(reference.from, usedNames, alreadyCheckedScopes, ignoredScopes);
} else allUsedNames.add(name);
}
}
for (const info of moduleToInfoMap.values()) {
const {usedNames: namespaceObjectUsedNames} = getUsedNamesInScopeInfo(info.module.identifier(), "");
switch (info.type) {
case "concatenated":
{
for (const variable of info.moduleScope.variables) {
const name = variable.name, {usedNames, alreadyCheckedScopes} = getUsedNamesInScopeInfo(info.module.identifier(), name);
if (allUsedNames.has(name) || usedNames.has(name)) {
const references = getAllReferences(variable);
for (const ref of references) addScopeSymbols(ref.from, usedNames, alreadyCheckedScopes, ignoredScopes);
const newName = this.findNewName(name, allUsedNames, usedNames, info.module.readableIdentifier(requestShortener));
allUsedNames.add(newName), info.internalNames.set(name, newName), topLevelDeclarations.add(newName);
const source = info.source, allIdentifiers = new Set(references.map((r => r.identifier)).concat(variable.identifiers));
for (const identifier of allIdentifiers) {
const r = identifier.range, path = getPathInAst(info.ast, identifier);
if (path && path.length > 1) {
const maybeProperty = "AssignmentPattern" === path[1].type && path[1].left === path[0] ? path[2] : path[1];
if ("Property" === maybeProperty.type && maybeProperty.shorthand) {
source.insert(r[1], `: ${newName}`);
continue;
}
}
source.replace(r[0], r[1] - 1, newName);
}
} else allUsedNames.add(name), info.internalNames.set(name, name), topLevelDeclarations.add(name);
}
let namespaceObjectName;
info.namespaceExportSymbol ? namespaceObjectName = info.internalNames.get(info.namespaceExportSymbol) : (namespaceObjectName = this.findNewName("namespaceObject", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener)), 
allUsedNames.add(namespaceObjectName)), info.namespaceObjectName = namespaceObjectName, 
topLevelDeclarations.add(namespaceObjectName);
break;
}

case "external":
{
const externalName = this.findNewName("", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));
allUsedNames.add(externalName), info.name = externalName, topLevelDeclarations.add(externalName);
break;
}
}
if ("namespace" !== info.module.buildMeta.exportsType) {
const externalNameInterop = this.findNewName("namespaceObject", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));
allUsedNames.add(externalNameInterop), info.interopNamespaceObjectName = externalNameInterop, 
topLevelDeclarations.add(externalNameInterop);
}
if ("default" === info.module.buildMeta.exportsType && "redirect" !== info.module.buildMeta.defaultObject) {
const externalNameInterop = this.findNewName("namespaceObject2", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));
allUsedNames.add(externalNameInterop), info.interopNamespaceObject2Name = externalNameInterop, 
topLevelDeclarations.add(externalNameInterop);
}
if ("dynamic" === info.module.buildMeta.exportsType || !info.module.buildMeta.exportsType) {
const externalNameInterop = this.findNewName("default", allUsedNames, namespaceObjectUsedNames, info.module.readableIdentifier(requestShortener));
allUsedNames.add(externalNameInterop), info.interopDefaultAccessName = externalNameInterop, 
topLevelDeclarations.add(externalNameInterop);
}
}
for (const info of moduleToInfoMap.values()) if ("concatenated" === info.type) for (const reference of info.globalScope.through) {
const name = reference.identifier.name, match = ConcatenationScope.matchModuleReference(name);
if (match) {
const referencedInfo = modulesWithInfo[match.index];
if ("reference" === referencedInfo.type) throw new Error("Module reference can't point to a reference");
const finalName = getFinalName(moduleGraph, referencedInfo, match.ids, moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, match.call, !match.directImport, info.module.buildMeta.strictHarmonyModule, match.asiSafe), r = reference.identifier.range;
info.source.replace(r[0], r[1] + 1, finalName);
}
}
const exportsMap = new Map, unusedExports = new Set, rootInfo = moduleToInfoMap.get(this.rootModule), strictHarmonyModule = rootInfo.module.buildMeta.strictHarmonyModule, exportsInfo = moduleGraph.getExportsInfo(rootInfo.module);
for (const exportInfo of exportsInfo.orderedExports) {
const name = exportInfo.name;
if (!1 === exportInfo.provided) continue;
const used = exportInfo.getUsedName(void 0, runtime);
used ? exportsMap.set(used, (requestShortener => {
try {
const finalName = getFinalName(moduleGraph, rootInfo, [ name ], moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, !1, !1, strictHarmonyModule, !0);
return `/* ${exportInfo.isReexport() ? "reexport" : "binding"} */ ${finalName}`;
} catch (e) {
throw e.message += `\nwhile generating the root export '${name}' (used name: '${used}')`, 
e;
}
})) : unusedExports.add(name);
}
const result = new ConcatSource;
if (moduleGraph.getExportsInfo(this).otherExportsInfo.getUsed(runtime) !== UsageState.Unused && (result.add("// ESM COMPAT FLAG\n"), 
result.add(runtimeTemplate.defineEsModuleFlagStatement({
exportsArgument: this.exportsArgument,
runtimeRequirements
}))), exportsMap.size > 0) {
runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
const definitions = [];
for (const [key, value] of exportsMap) definitions.push(`\n  ${JSON.stringify(key)}: ${runtimeTemplate.returningFunction(value(requestShortener))}`);
result.add("\n// EXPORTS\n"), result.add(`${RuntimeGlobals.definePropertyGetters}(${this.exportsArgument}, {${definitions.join(",")}\n});\n`);
}
unusedExports.size > 0 && result.add(`\n// UNUSED EXPORTS: ${(iterable => {
let str = "", first = !0;
for (const item of iterable) first ? first = !1 : str += ", ", str += item;
return str;
})(unusedExports)}\n`);
const namespaceObjectSources = new Map;
for (const info of neededNamespaceObjects) {
if (info.namespaceExportSymbol) continue;
const nsObj = [], exportsInfo = moduleGraph.getExportsInfo(info.module);
for (const exportInfo of exportsInfo.orderedExports) {
if (!1 === exportInfo.provided) continue;
const usedName = exportInfo.getUsedName(void 0, runtime);
if (usedName) {
const finalName = getFinalName(moduleGraph, info, [ exportInfo.name ], moduleToInfoMap, runtime, requestShortener, runtimeTemplate, neededNamespaceObjects, !1, void 0, info.module.buildMeta.strictHarmonyModule, !0);
nsObj.push(`\n  ${JSON.stringify(usedName)}: ${runtimeTemplate.returningFunction(finalName)}`);
}
}
const name = info.namespaceObjectName, defineGetters = nsObj.length > 0 ? `${RuntimeGlobals.definePropertyGetters}(${name}, {${nsObj.join(",")}\n});\n` : "";
nsObj.length > 0 && runtimeRequirements.add(RuntimeGlobals.definePropertyGetters), 
namespaceObjectSources.set(info, `\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}\nvar ${name} = {};\n${RuntimeGlobals.makeNamespaceObject}(${name});\n${defineGetters}`), 
runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);
}
for (const info of modulesWithInfo) if ("concatenated" === info.type) {
const source = namespaceObjectSources.get(info);
if (!source) continue;
result.add(source);
}
const chunkInitFragments = [];
for (const rawInfo of modulesWithInfo) {
let name, isConditional = !1;
const info = "reference" === rawInfo.type ? rawInfo.target : rawInfo;
switch (info.type) {
case "concatenated":
if (result.add(`\n;// CONCATENATED MODULE: ${info.module.readableIdentifier(requestShortener)}\n`), 
result.add(info.source), info.chunkInitFragments) for (const f of info.chunkInitFragments) chunkInitFragments.push(f);
if (info.runtimeRequirements) for (const r of info.runtimeRequirements) runtimeRequirements.add(r);
name = info.namespaceObjectName;
break;

case "external":
{
result.add(`\n// EXTERNAL MODULE: ${info.module.readableIdentifier(requestShortener)}\n`), 
runtimeRequirements.add(RuntimeGlobals.require);
const {runtimeCondition} = rawInfo, condition = runtimeTemplate.runtimeConditionExpression({
chunkGraph,
runtimeCondition,
runtime,
runtimeRequirements
});
"true" !== condition && (isConditional = !0, result.add(`if (${condition}) {\n`)), 
result.add(`var ${info.name} = __webpack_require__(${JSON.stringify(chunkGraph.getModuleId(info.module))});`), 
name = info.name;
break;
}

default:
throw new Error(`Unsupported concatenation entry type ${info.type}`);
}
info.interopNamespaceObjectUsed && (runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), 
result.add(`\nvar ${info.interopNamespaceObjectName} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name}, 2);`)), 
info.interopNamespaceObject2Used && (runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject), 
result.add(`\nvar ${info.interopNamespaceObject2Name} = /*#__PURE__*/${RuntimeGlobals.createFakeNamespaceObject}(${name});`)), 
info.interopDefaultAccessUsed && (runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport), 
result.add(`\nvar ${info.interopDefaultAccessName} = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport}(${name});`)), 
isConditional && result.add("\n}");
}
const data = new Map;
chunkInitFragments.length > 0 && data.set("chunkInitFragments", chunkInitFragments), 
data.set("topLevelDeclarations", topLevelDeclarations);
return {
sources: new Map([ [ "javascript", new CachedSource(result) ] ]),
data,
runtimeRequirements
};
}
_analyseModule(modulesMap, info, dependencyTemplates, runtimeTemplate, moduleGraph, chunkGraph, runtime, codeGenerationResults) {
if ("concatenated" === info.type) {
const m = info.module;
try {
const concatenationScope = new ConcatenationScope(modulesMap, info), codeGenResult = m.codeGeneration({
dependencyTemplates,
runtimeTemplate,
moduleGraph,
chunkGraph,
runtime,
concatenationScope,
codeGenerationResults,
sourceTypes: TYPES
}), source = codeGenResult.sources.get("javascript"), data = codeGenResult.data, chunkInitFragments = data && data.get("chunkInitFragments"), code = source.source().toString();
let ast;
try {
ast = JavascriptParser._parse(code, {
sourceType: "module"
});
} catch (err) {
if (err.loc && "object" == typeof err.loc && "number" == typeof err.loc.line) {
const lineNumber = err.loc.line, lines = code.split("\n");
err.message += "\n| " + lines.slice(Math.max(0, lineNumber - 3), lineNumber + 2).join("\n| ");
}
throw err;
}
const globalScope = eslintScope.analyze(ast, {
ecmaVersion: 6,
sourceType: "module",
optimistic: !0,
ignoreEval: !0,
impliedStrict: !0
}).acquire(ast), moduleScope = globalScope.childScopes[0], resultSource = new ReplaceSource(source);
info.runtimeRequirements = codeGenResult.runtimeRequirements, info.ast = ast, info.internalSource = source, 
info.source = resultSource, info.chunkInitFragments = chunkInitFragments, info.globalScope = globalScope, 
info.moduleScope = moduleScope;
} catch (err) {
throw err.message += `\nwhile analyzing module ${m.identifier()} for concatenation`, 
err;
}
}
}
_getModulesWithInfo(moduleGraph, runtime) {
const orderedConcatenationList = this._createConcatenationList(this.rootModule, this._modules, runtime, moduleGraph), map = new Map;
return [ orderedConcatenationList.map(((info, index) => {
let item = map.get(info.module);
if (void 0 === item) {
switch (info.type) {
case "concatenated":
item = {
type: "concatenated",
module: info.module,
index,
ast: void 0,
internalSource: void 0,
runtimeRequirements: void 0,
source: void 0,
globalScope: void 0,
moduleScope: void 0,
internalNames: new Map,
exportMap: void 0,
rawExportMap: void 0,
namespaceExportSymbol: void 0,
namespaceObjectName: void 0,
interopNamespaceObjectUsed: !1,
interopNamespaceObjectName: void 0,
interopNamespaceObject2Used: !1,
interopNamespaceObject2Name: void 0,
interopDefaultAccessUsed: !1,
interopDefaultAccessName: void 0
};
break;

case "external":
item = {
type: "external",
module: info.module,
runtimeCondition: info.runtimeCondition,
index,
name: void 0,
interopNamespaceObjectUsed: !1,
interopNamespaceObjectName: void 0,
interopNamespaceObject2Used: !1,
interopNamespaceObject2Name: void 0,
interopDefaultAccessUsed: !1,
interopDefaultAccessName: void 0
};
break;

default:
throw new Error(`Unsupported concatenation entry type ${info.type}`);
}
return map.set(item.module, item), item;
}
return {
type: "reference",
runtimeCondition: info.runtimeCondition,
target: item
};
})), map ];
}
findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {
let name = oldName;
name === ConcatenationScope.DEFAULT_EXPORT && (name = ""), name === ConcatenationScope.NAMESPACE_OBJECT_EXPORT && (name = "namespaceObject");
const splittedInfo = (extraInfo = extraInfo.replace(/\.+\/|(\/index)?\.([a-zA-Z0-9]{1,4})($|\s|\?)|\s*\+\s*\d+\s*modules/g, "")).split("/");
for (;splittedInfo.length; ) {
name = splittedInfo.pop() + (name ? "_" + name : "");
const nameIdent = Template.toIdentifier(name);
if (!(usedNamed1.has(nameIdent) || usedNamed2 && usedNamed2.has(nameIdent))) return nameIdent;
}
let i = 0, nameWithNumber = Template.toIdentifier(`${name}_${i}`);
for (;usedNamed1.has(nameWithNumber) || usedNamed2 && usedNamed2.has(nameWithNumber); ) i++, 
nameWithNumber = Template.toIdentifier(`${name}_${i}`);
return nameWithNumber;
}
updateHash(hash, context) {
const {chunkGraph, runtime} = context;
for (const info of this._createConcatenationList(this.rootModule, this._modules, intersectRuntime(runtime, this._runtime), chunkGraph.moduleGraph)) switch (info.type) {
case "concatenated":
info.module.updateHash(hash, context);
break;

case "external":
hash.update(`${chunkGraph.getModuleId(info.module)}`);
}
super.updateHash(hash, context);
}
static deserialize(context) {
const obj = new ConcatenatedModule({
identifier: void 0,
rootModule: void 0,
modules: void 0,
runtime: void 0
});
return obj.deserialize(context), obj;
}
}
makeSerializable(ConcatenatedModule, "webpack/lib/optimize/ConcatenatedModule"), 
module.exports = ConcatenatedModule;
},
60051: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_BASIC} = __webpack_require__(60933);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("EnsureChunkConditionsPlugin", (compilation => {
compilation.hooks.optimizeChunks.tap({
name: "EnsureChunkConditionsPlugin",
stage: STAGE_BASIC
}, (chunks => {
const chunkGraph = compilation.chunkGraph, sourceChunks = new Set, chunkGroups = new Set;
for (const module of compilation.modules) {
if (!module.hasChunkCondition()) continue;
for (const chunk of chunkGraph.getModuleChunksIterable(module)) if (!module.chunkCondition(chunk, compilation)) {
sourceChunks.add(chunk);
for (const group of chunk.groupsIterable) chunkGroups.add(group);
}
if (0 === sourceChunks.size) continue;
const targetChunks = new Set;
chunkGroupLoop: for (const chunkGroup of chunkGroups) {
for (const chunk of chunkGroup.chunks) if (module.chunkCondition(chunk, compilation)) {
targetChunks.add(chunk);
continue chunkGroupLoop;
}
if (chunkGroup.isInitial()) throw new Error("Cannot fullfil chunk condition of " + module.identifier());
for (const group of chunkGroup.parentsIterable) chunkGroups.add(group);
}
for (const sourceChunk of sourceChunks) chunkGraph.disconnectChunkAndModule(sourceChunk, module);
for (const targetChunk of targetChunks) chunkGraph.connectChunkAndModule(targetChunk, module);
sourceChunks.clear(), chunkGroups.clear();
}
}));
}));
}
};
},
88662: module => {
"use strict";
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("FlagIncludedChunksPlugin", (compilation => {
compilation.hooks.optimizeChunkIds.tap("FlagIncludedChunksPlugin", (chunks => {
const chunkGraph = compilation.chunkGraph, moduleBits = new WeakMap, modulesCount = compilation.modules.size, modulo = 1 / Math.pow(1 / modulesCount, 1 / 31), modulos = Array.from({
length: 31
}, ((x, i) => 0 | Math.pow(modulo, i)));
let i = 0;
for (const module of compilation.modules) {
let bit = 30;
for (;i % modulos[bit] != 0; ) bit--;
moduleBits.set(module, 1 << bit), i++;
}
const chunkModulesHash = new WeakMap;
for (const chunk of chunks) {
let hash = 0;
for (const module of chunkGraph.getChunkModulesIterable(chunk)) hash |= moduleBits.get(module);
chunkModulesHash.set(chunk, hash);
}
for (const chunkA of chunks) {
const chunkAHash = chunkModulesHash.get(chunkA), chunkAModulesCount = chunkGraph.getNumberOfChunkModules(chunkA);
if (0 === chunkAModulesCount) continue;
let bestModule;
for (const module of chunkGraph.getChunkModulesIterable(chunkA)) (void 0 === bestModule || chunkGraph.getNumberOfModuleChunks(bestModule) > chunkGraph.getNumberOfModuleChunks(module)) && (bestModule = module);
loopB: for (const chunkB of chunkGraph.getModuleChunksIterable(bestModule)) {
if (chunkA === chunkB) continue;
const chunkBModulesCount = chunkGraph.getNumberOfChunkModules(chunkB);
if (0 === chunkBModulesCount) continue;
if (chunkAModulesCount > chunkBModulesCount) continue;
if ((chunkModulesHash.get(chunkB) & chunkAHash) === chunkAHash) {
for (const m of chunkGraph.getChunkModulesIterable(chunkA)) if (!chunkGraph.isModuleInChunk(m, chunkB)) continue loopB;
chunkB.ids.push(chunkA.id);
}
}
}
}));
}));
}
};
},
93639: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const {UsageState} = __webpack_require__(74603), parserStateMap = new WeakMap, topLevelSymbolTag = Symbol("top level symbol");
function getState(parserState) {
return parserStateMap.get(parserState);
}
exports.bailout = parserState => {
parserStateMap.set(parserState, !1);
}, exports.enable = parserState => {
!1 !== parserStateMap.get(parserState) && parserStateMap.set(parserState, {
innerGraph: new Map,
currentTopLevelSymbol: void 0,
usageCallbackMap: new Map
});
}, exports.isEnabled = parserState => !!parserStateMap.get(parserState), exports.addUsage = (state, symbol, usage) => {
const innerGraphState = getState(state);
if (innerGraphState) {
const {innerGraph} = innerGraphState, info = innerGraph.get(symbol);
!0 === usage ? innerGraph.set(symbol, !0) : void 0 === info ? innerGraph.set(symbol, new Set([ usage ])) : !0 !== info && info.add(usage);
}
}, exports.addVariableUsage = (parser, name, usage) => {
const symbol = parser.getTagData(name, topLevelSymbolTag) || exports.tagTopLevelSymbol(parser, name);
symbol && exports.addUsage(parser.state, symbol, usage);
}, exports.inferDependencyUsage = state => {
const innerGraphState = getState(state);
if (!innerGraphState) return;
const {innerGraph, usageCallbackMap} = innerGraphState, processed = new Map, nonTerminal = new Set(innerGraph.keys());
for (;nonTerminal.size > 0; ) for (const key of nonTerminal) {
let newSet = new Set, isTerminal = !0;
const value = innerGraph.get(key);
let alreadyProcessed = processed.get(key);
if (void 0 === alreadyProcessed && (alreadyProcessed = new Set, processed.set(key, alreadyProcessed)), 
!0 !== value && void 0 !== value) {
for (const item of value) alreadyProcessed.add(item);
for (const item of value) if ("string" == typeof item) newSet.add(item); else {
const itemValue = innerGraph.get(item);
if (!0 === itemValue) {
newSet = !0;
break;
}
if (void 0 !== itemValue) for (const i of itemValue) i !== key && (alreadyProcessed.has(i) || (newSet.add(i), 
"string" != typeof i && (isTerminal = !1)));
}
!0 === newSet ? innerGraph.set(key, !0) : 0 === newSet.size ? innerGraph.set(key, void 0) : innerGraph.set(key, newSet);
}
if (isTerminal && (nonTerminal.delete(key), null === key)) {
const globalValue = innerGraph.get(null);
if (globalValue) for (const [key, value] of innerGraph) if (null !== key && !0 !== value) if (!0 === globalValue) innerGraph.set(key, !0); else {
const newSet = new Set(value);
for (const item of globalValue) newSet.add(item);
innerGraph.set(key, newSet);
}
}
}
for (const [symbol, callbacks] of usageCallbackMap) {
const usage = innerGraph.get(symbol);
for (const callback of callbacks) callback(void 0 !== usage && usage);
}
}, exports.onUsage = (state, onUsageCallback) => {
const innerGraphState = getState(state);
if (innerGraphState) {
const {usageCallbackMap, currentTopLevelSymbol} = innerGraphState;
if (currentTopLevelSymbol) {
let callbacks = usageCallbackMap.get(currentTopLevelSymbol);
void 0 === callbacks && (callbacks = new Set, usageCallbackMap.set(currentTopLevelSymbol, callbacks)), 
callbacks.add(onUsageCallback);
} else onUsageCallback(!0);
} else onUsageCallback(void 0);
}, exports.setTopLevelSymbol = (state, symbol) => {
const innerGraphState = getState(state);
innerGraphState && (innerGraphState.currentTopLevelSymbol = symbol);
}, exports.getTopLevelSymbol = state => {
const innerGraphState = getState(state);
if (innerGraphState) return innerGraphState.currentTopLevelSymbol;
}, exports.tagTopLevelSymbol = (parser, name) => {
if (!getState(parser.state)) return;
parser.defineVariable(name);
const existingTag = parser.getTagData(name, topLevelSymbolTag);
if (existingTag) return existingTag;
const fn = new TopLevelSymbol(name);
return parser.tagVariable(name, topLevelSymbolTag, fn), fn;
}, exports.isDependencyUsedByExports = (dependency, usedByExports, moduleGraph, runtime) => {
if (!1 === usedByExports) return !1;
if (!0 !== usedByExports && void 0 !== usedByExports) {
const selfModule = moduleGraph.getParentModule(dependency), exportsInfo = moduleGraph.getExportsInfo(selfModule);
let used = !1;
for (const exportName of usedByExports) exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused && (used = !0);
if (!used) return !1;
}
return !0;
}, exports.getDependencyUsedByExportsCondition = (dependency, usedByExports, moduleGraph) => {
if (!1 === usedByExports) return !1;
if (!0 !== usedByExports && void 0 !== usedByExports) {
const selfModule = moduleGraph.getParentModule(dependency), exportsInfo = moduleGraph.getExportsInfo(selfModule);
return (connections, runtime) => {
for (const exportName of usedByExports) if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return !0;
return !1;
};
}
return null;
};
class TopLevelSymbol {
constructor(name) {
this.name = name;
}
}
exports.TopLevelSymbol = TopLevelSymbol, exports.topLevelSymbolTag = topLevelSymbolTag;
},
97335: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const PureExpressionDependency = __webpack_require__(3988), InnerGraph = __webpack_require__(93639), {topLevelSymbolTag} = InnerGraph;
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("InnerGraphPlugin", ((compilation, {normalModuleFactory}) => {
const logger = compilation.getLogger("webpack.InnerGraphPlugin");
compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template);
const handler = (parser, parserOptions) => {
const onUsageSuper = sup => {
InnerGraph.onUsage(parser.state, (usedByExports => {
switch (usedByExports) {
case void 0:
case !0:
return;

default:
{
const dep = new PureExpressionDependency(sup.range);
dep.loc = sup.loc, dep.usedByExports = usedByExports, parser.state.module.addDependency(dep);
break;
}
}
}));
};
parser.hooks.program.tap("InnerGraphPlugin", (() => {
InnerGraph.enable(parser.state);
})), parser.hooks.finish.tap("InnerGraphPlugin", (() => {
InnerGraph.isEnabled(parser.state) && (logger.time("infer dependency usage"), InnerGraph.inferDependencyUsage(parser.state), 
logger.timeAggregate("infer dependency usage"));
}));
const statementWithTopLevelSymbol = new WeakMap, statementPurePart = new WeakMap, classWithTopLevelSymbol = new WeakMap, declWithTopLevelSymbol = new WeakMap, pureDeclarators = new WeakSet;
parser.hooks.preStatement.tap("InnerGraphPlugin", (statement => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope && "FunctionDeclaration" === statement.type) {
const name = statement.id ? statement.id.name : "*default*", fn = InnerGraph.tagTopLevelSymbol(parser, name);
return statementWithTopLevelSymbol.set(statement, fn), !0;
}
})), parser.hooks.blockPreStatement.tap("InnerGraphPlugin", (statement => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope) {
if ("ClassDeclaration" === statement.type) {
const name = statement.id ? statement.id.name : "*default*", fn = InnerGraph.tagTopLevelSymbol(parser, name);
return classWithTopLevelSymbol.set(statement, fn), !0;
}
if ("ExportDefaultDeclaration" === statement.type) {
const name = "*default*", fn = InnerGraph.tagTopLevelSymbol(parser, name), decl = statement.declaration;
"ClassExpression" === decl.type || "ClassDeclaration" === decl.type ? classWithTopLevelSymbol.set(decl, fn) : parser.isPure(decl, statement.range[0]) && (statementWithTopLevelSymbol.set(statement, fn), 
decl.type.endsWith("FunctionExpression") || decl.type.endsWith("Declaration") || "Literal" === decl.type || statementPurePart.set(statement, decl));
}
}
})), parser.hooks.preDeclarator.tap("InnerGraphPlugin", ((decl, statement) => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope && decl.init && "Identifier" === decl.id.type) {
const name = decl.id.name;
if ("ClassExpression" === decl.init.type) {
const fn = InnerGraph.tagTopLevelSymbol(parser, name);
classWithTopLevelSymbol.set(decl.init, fn);
} else if (parser.isPure(decl.init, decl.id.range[1])) {
const fn = InnerGraph.tagTopLevelSymbol(parser, name);
return declWithTopLevelSymbol.set(decl, fn), decl.init.type.endsWith("FunctionExpression") || "Literal" === decl.init.type || pureDeclarators.add(decl), 
!0;
}
}
})), parser.hooks.statement.tap("InnerGraphPlugin", (statement => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope) {
InnerGraph.setTopLevelSymbol(parser.state, void 0);
const fn = statementWithTopLevelSymbol.get(statement);
if (fn) {
InnerGraph.setTopLevelSymbol(parser.state, fn);
const purePart = statementPurePart.get(statement);
purePart && InnerGraph.onUsage(parser.state, (usedByExports => {
switch (usedByExports) {
case void 0:
case !0:
return;

default:
{
const dep = new PureExpressionDependency(purePart.range);
dep.loc = statement.loc, dep.usedByExports = usedByExports, parser.state.module.addDependency(dep);
break;
}
}
}));
}
}
})), parser.hooks.classExtendsExpression.tap("InnerGraphPlugin", ((expr, statement) => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope) {
const fn = classWithTopLevelSymbol.get(statement);
fn && parser.isPure(expr, statement.id ? statement.id.range[1] : statement.range[0]) && (InnerGraph.setTopLevelSymbol(parser.state, fn), 
onUsageSuper(expr));
}
})), parser.hooks.classBodyElement.tap("InnerGraphPlugin", ((element, classDefinition) => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope) {
classWithTopLevelSymbol.get(classDefinition) && InnerGraph.setTopLevelSymbol(parser.state, void 0);
}
})), parser.hooks.classBodyValue.tap("InnerGraphPlugin", ((expression, element, classDefinition) => {
if (InnerGraph.isEnabled(parser.state) && !0 === parser.scope.topLevelScope) {
const fn = classWithTopLevelSymbol.get(classDefinition);
fn && (!element.static || parser.isPure(expression, element.key ? element.key.range[1] : element.range[0]) ? (InnerGraph.setTopLevelSymbol(parser.state, fn), 
"MethodDefinition" !== element.type && element.static && InnerGraph.onUsage(parser.state, (usedByExports => {
switch (usedByExports) {
case void 0:
case !0:
return;

default:
{
const dep = new PureExpressionDependency(expression.range);
dep.loc = expression.loc, dep.usedByExports = usedByExports, parser.state.module.addDependency(dep);
break;
}
}
}))) : InnerGraph.setTopLevelSymbol(parser.state, void 0));
}
})), parser.hooks.declarator.tap("InnerGraphPlugin", ((decl, statement) => {
if (!InnerGraph.isEnabled(parser.state)) return;
const fn = declWithTopLevelSymbol.get(decl);
return fn ? (InnerGraph.setTopLevelSymbol(parser.state, fn), pureDeclarators.has(decl) && ("ClassExpression" === decl.init.type ? decl.init.superClass && onUsageSuper(decl.init.superClass) : InnerGraph.onUsage(parser.state, (usedByExports => {
switch (usedByExports) {
case void 0:
case !0:
return;

default:
{
const dep = new PureExpressionDependency(decl.init.range);
dep.loc = decl.loc, dep.usedByExports = usedByExports, parser.state.module.addDependency(dep);
break;
}
}
}))), parser.walkExpression(decl.init), InnerGraph.setTopLevelSymbol(parser.state, void 0), 
!0) : void 0;
})), parser.hooks.expression.for(topLevelSymbolTag).tap("InnerGraphPlugin", (() => {
const topLevelSymbol = parser.currentTagData, currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);
InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || !0);
})), parser.hooks.assign.for(topLevelSymbolTag).tap("InnerGraphPlugin", (expr => {
if (InnerGraph.isEnabled(parser.state)) return "=" === expr.operator || void 0;
}));
};
normalModuleFactory.hooks.parser.for("javascript/auto").tap("InnerGraphPlugin", handler), 
normalModuleFactory.hooks.parser.for("javascript/esm").tap("InnerGraphPlugin", handler), 
compilation.hooks.finishModules.tap("InnerGraphPlugin", (() => {
logger.timeAggregateEnd("infer dependency usage");
}));
}));
}
};
},
48646: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_ADVANCED} = __webpack_require__(60933), LazyBucketSortedSet = __webpack_require__(76104), {compareChunks} = __webpack_require__(40028), validate = __webpack_require__(59586)(__webpack_require__(87810), (() => __webpack_require__(10692)), {
name: "Limit Chunk Count Plugin",
baseDataPath: "options"
}), addToSetMap = (map, key, value) => {
const set = map.get(key);
void 0 === set ? map.set(key, new Set([ value ])) : set.add(value);
};
module.exports = class {
constructor(options) {
validate(options), this.options = options;
}
apply(compiler) {
const options = this.options;
compiler.hooks.compilation.tap("LimitChunkCountPlugin", (compilation => {
compilation.hooks.optimizeChunks.tap({
name: "LimitChunkCountPlugin",
stage: STAGE_ADVANCED
}, (chunks => {
const chunkGraph = compilation.chunkGraph, maxChunks = options.maxChunks;
if (!maxChunks) return;
if (maxChunks < 1) return;
if (compilation.chunks.size <= maxChunks) return;
let remainingChunksToMerge = compilation.chunks.size - maxChunks;
const compareChunksWithGraph = compareChunks(chunkGraph), orderedChunks = Array.from(chunks).sort(compareChunksWithGraph), combinations = new LazyBucketSortedSet((c => c.sizeDiff), ((a, b) => b - a), (c => c.integratedSize), ((a, b) => a - b), (c => c.bIdx - c.aIdx), ((a, b) => a - b), ((a, b) => a.bIdx - b.bIdx)), combinationsByChunk = new Map;
orderedChunks.forEach(((b, bIdx) => {
for (let aIdx = 0; aIdx < bIdx; aIdx++) {
const a = orderedChunks[aIdx];
if (!chunkGraph.canChunksBeIntegrated(a, b)) continue;
const integratedSize = chunkGraph.getIntegratedChunksSize(a, b, options), aSize = chunkGraph.getChunkSize(a, options), bSize = chunkGraph.getChunkSize(b, options), c = {
deleted: !1,
sizeDiff: aSize + bSize - integratedSize,
integratedSize,
a,
b,
aIdx,
bIdx,
aSize,
bSize
};
combinations.add(c), addToSetMap(combinationsByChunk, a, c), addToSetMap(combinationsByChunk, b, c);
}
return combinations;
}));
const modifiedChunks = new Set;
let changed = !1;
loop: for (;;) {
const combination = combinations.popFirst();
if (void 0 === combination) break;
combination.deleted = !0;
const {a, b, integratedSize} = combination;
if (modifiedChunks.size > 0) {
const queue = new Set(a.groupsIterable);
for (const group of b.groupsIterable) queue.add(group);
for (const group of queue) {
for (const mChunk of modifiedChunks) if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {
if (remainingChunksToMerge--, remainingChunksToMerge <= 0) break loop;
modifiedChunks.add(a), modifiedChunks.add(b);
continue loop;
}
for (const parent of group.parentsIterable) queue.add(parent);
}
}
if (chunkGraph.canChunksBeIntegrated(a, b)) {
if (chunkGraph.integrateChunks(a, b), compilation.chunks.delete(b), modifiedChunks.add(a), 
changed = !0, remainingChunksToMerge--, remainingChunksToMerge <= 0) break;
for (const combination of combinationsByChunk.get(a)) combination.deleted || (combination.deleted = !0, 
combinations.delete(combination));
for (const combination of combinationsByChunk.get(b)) if (!combination.deleted) if (combination.a === b) {
if (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {
combination.deleted = !0, combinations.delete(combination);
continue;
}
const newIntegratedSize = chunkGraph.getIntegratedChunksSize(a, combination.b, options), finishUpdate = combinations.startUpdate(combination);
combination.a = a, combination.integratedSize = newIntegratedSize, combination.aSize = integratedSize, 
combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize, finishUpdate();
} else if (combination.b === b) {
if (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {
combination.deleted = !0, combinations.delete(combination);
continue;
}
const newIntegratedSize = chunkGraph.getIntegratedChunksSize(combination.a, a, options), finishUpdate = combinations.startUpdate(combination);
combination.b = a, combination.integratedSize = newIntegratedSize, combination.bSize = integratedSize, 
combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize, finishUpdate();
}
combinationsByChunk.set(a, combinationsByChunk.get(b)), combinationsByChunk.delete(b);
}
}
return !!changed || void 0;
}));
}));
}
};
},
75016: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {UsageState} = __webpack_require__(74603), {numberToIdentifier, NUMBER_OF_IDENTIFIER_START_CHARS, NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS} = __webpack_require__(88370), {assignDeterministicIds} = __webpack_require__(89945), {compareSelect, compareStringsNumeric} = __webpack_require__(40028), comparator = compareSelect((e => e.name), compareStringsNumeric), mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {
if (!(exportsInfo => {
if (exportsInfo.otherExportsInfo.getUsed(void 0) !== UsageState.Unused) return !1;
let hasSomethingToMangle = !1;
for (const exportInfo of exportsInfo.exports) !0 === exportInfo.canMangle && (hasSomethingToMangle = !0);
return hasSomethingToMangle;
})(exportsInfo)) return;
const usedNames = new Set, mangleableExports = [];
let avoidMangleNonProvided = !isNamespace;
if (!avoidMangleNonProvided && deterministic) for (const exportInfo of exportsInfo.ownedExports) if (!1 !== exportInfo.provided) {
avoidMangleNonProvided = !0;
break;
}
for (const exportInfo of exportsInfo.ownedExports) {
const name = exportInfo.name;
if (exportInfo.hasUsedName() || (!0 !== exportInfo.canMangle || 1 === name.length && /^[a-zA-Z0-9_$]/.test(name) || deterministic && 2 === name.length && /^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name) || avoidMangleNonProvided && !0 !== exportInfo.provided ? (exportInfo.setUsedName(name), 
usedNames.add(name)) : mangleableExports.push(exportInfo)), exportInfo.exportsInfoOwned) {
const used = exportInfo.getUsed(void 0);
used !== UsageState.OnlyPropertiesUsed && used !== UsageState.Unused || mangleExportsInfo(deterministic, exportInfo.exportsInfo, !1);
}
}
if (deterministic) assignDeterministicIds(mangleableExports, (e => e.name), comparator, ((e, id) => {
const name = numberToIdentifier(id), size = usedNames.size;
return usedNames.add(name), size !== usedNames.size && (e.setUsedName(name), !0);
}), [ NUMBER_OF_IDENTIFIER_START_CHARS, NUMBER_OF_IDENTIFIER_START_CHARS * NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS ], NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS, usedNames.size); else {
const usedExports = [], unusedExports = [];
for (const exportInfo of mangleableExports) exportInfo.getUsed(void 0) === UsageState.Unused ? unusedExports.push(exportInfo) : usedExports.push(exportInfo);
usedExports.sort(comparator), unusedExports.sort(comparator);
let i = 0;
for (const list of [ usedExports, unusedExports ]) for (const exportInfo of list) {
let name;
do {
name = numberToIdentifier(i++);
} while (usedNames.has(name));
exportInfo.setUsedName(name);
}
}
};
module.exports = class {
constructor(deterministic) {
this._deterministic = deterministic;
}
apply(compiler) {
const {_deterministic: deterministic} = this;
compiler.hooks.compilation.tap("MangleExportsPlugin", (compilation => {
const moduleGraph = compilation.moduleGraph;
compilation.hooks.optimizeCodeGeneration.tap("MangleExportsPlugin", (modules => {
if (compilation.moduleMemCaches) throw new Error("optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect");
for (const module of modules) {
const isNamespace = module.buildMeta && "namespace" === module.buildMeta.exportsType, exportsInfo = moduleGraph.getExportsInfo(module);
mangleExportsInfo(deterministic, exportsInfo, isNamespace);
}
}));
}));
}
};
},
16152: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_BASIC} = __webpack_require__(60933), {runtimeEqual} = __webpack_require__(14372);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("MergeDuplicateChunksPlugin", (compilation => {
compilation.hooks.optimizeChunks.tap({
name: "MergeDuplicateChunksPlugin",
stage: STAGE_BASIC
}, (chunks => {
const {chunkGraph, moduleGraph} = compilation, notDuplicates = new Set;
for (const chunk of chunks) {
let possibleDuplicates;
for (const module of chunkGraph.getChunkModulesIterable(chunk)) if (void 0 === possibleDuplicates) {
for (const dup of chunkGraph.getModuleChunksIterable(module)) dup === chunk || chunkGraph.getNumberOfChunkModules(chunk) !== chunkGraph.getNumberOfChunkModules(dup) || notDuplicates.has(dup) || (void 0 === possibleDuplicates && (possibleDuplicates = new Set), 
possibleDuplicates.add(dup));
if (void 0 === possibleDuplicates) break;
} else {
for (const dup of possibleDuplicates) chunkGraph.isModuleInChunk(module, dup) || possibleDuplicates.delete(dup);
if (0 === possibleDuplicates.size) break;
}
if (void 0 !== possibleDuplicates && possibleDuplicates.size > 0) outer: for (const otherChunk of possibleDuplicates) if (otherChunk.hasRuntime() === chunk.hasRuntime() && !(chunkGraph.getNumberOfEntryModules(chunk) > 0 || chunkGraph.getNumberOfEntryModules(otherChunk) > 0)) {
if (!runtimeEqual(chunk.runtime, otherChunk.runtime)) for (const module of chunkGraph.getChunkModulesIterable(chunk)) {
if (!moduleGraph.getExportsInfo(module).isEquallyUsed(chunk.runtime, otherChunk.runtime)) continue outer;
}
chunkGraph.canChunksBeIntegrated(chunk, otherChunk) && (chunkGraph.integrateChunks(chunk, otherChunk), 
compilation.chunks.delete(otherChunk));
}
notDuplicates.add(chunk);
}
}));
}));
}
};
},
32020: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_ADVANCED} = __webpack_require__(60933), validate = __webpack_require__(59586)(__webpack_require__(12383), (() => __webpack_require__(84638)), {
name: "Min Chunk Size Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options) {
validate(options), this.options = options;
}
apply(compiler) {
const options = this.options, minChunkSize = options.minChunkSize;
compiler.hooks.compilation.tap("MinChunkSizePlugin", (compilation => {
compilation.hooks.optimizeChunks.tap({
name: "MinChunkSizePlugin",
stage: STAGE_ADVANCED
}, (chunks => {
const chunkGraph = compilation.chunkGraph, equalOptions = {
chunkOverhead: 1,
entryChunkMultiplicator: 1
}, chunkSizesMap = new Map, combinations = [], smallChunks = [], visitedChunks = [];
for (const a of chunks) {
if (chunkGraph.getChunkSize(a, equalOptions) < minChunkSize) {
smallChunks.push(a);
for (const b of visitedChunks) chunkGraph.canChunksBeIntegrated(b, a) && combinations.push([ b, a ]);
} else for (const b of smallChunks) chunkGraph.canChunksBeIntegrated(b, a) && combinations.push([ b, a ]);
chunkSizesMap.set(a, chunkGraph.getChunkSize(a, options)), visitedChunks.push(a);
}
const sortedSizeFilteredExtendedPairCombinations = combinations.map((pair => {
const a = chunkSizesMap.get(pair[0]), b = chunkSizesMap.get(pair[1]), ab = chunkGraph.getIntegratedChunksSize(pair[0], pair[1], options);
return [ a + b - ab, ab, pair[0], pair[1] ];
})).sort(((a, b) => {
const diff = b[0] - a[0];
return 0 !== diff ? diff : a[1] - b[1];
}));
if (0 === sortedSizeFilteredExtendedPairCombinations.length) return;
const pair = sortedSizeFilteredExtendedPairCombinations[0];
return chunkGraph.integrateChunks(pair[2], pair[3]), compilation.chunks.delete(pair[3]), 
!0;
}));
}));
}
};
},
38605: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const SizeFormatHelpers = __webpack_require__(9568), WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(keys, minSize, maxSize) {
let keysMessage = "Fallback cache group";
keys && (keysMessage = keys.length > 1 ? `Cache groups ${keys.sort().join(", ")}` : `Cache group ${keys[0]}`), 
super(`SplitChunksPlugin\n${keysMessage}\nConfigured minSize (${SizeFormatHelpers.formatSize(minSize)}) is bigger than maxSize (${SizeFormatHelpers.formatSize(maxSize)}).\nThis seem to be a invalid optimization.splitChunks configuration.`);
}
};
},
13682: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const asyncLib = __webpack_require__(76947), ChunkGraph = __webpack_require__(15888), ModuleGraph = __webpack_require__(2197), {STAGE_DEFAULT} = __webpack_require__(60933), HarmonyImportDependency = __webpack_require__(75015), {compareModulesByIdentifier} = __webpack_require__(40028), {intersectRuntime, mergeRuntimeOwned, filterRuntime, runtimeToString, mergeRuntime} = __webpack_require__(14372), ConcatenatedModule = __webpack_require__(36005), formatBailoutReason = msg => "ModuleConcatenation bailout: " + msg;
class ConcatConfiguration {
constructor(rootModule, runtime) {
this.rootModule = rootModule, this.runtime = runtime, this.modules = new Set, this.modules.add(rootModule), 
this.warnings = new Map;
}
add(module) {
this.modules.add(module);
}
has(module) {
return this.modules.has(module);
}
isEmpty() {
return 1 === this.modules.size;
}
addWarning(module, problem) {
this.warnings.set(module, problem);
}
getWarningsSorted() {
return new Map(Array.from(this.warnings).sort(((a, b) => {
const ai = a[0].identifier(), bi = b[0].identifier();
return ai < bi ? -1 : ai > bi ? 1 : 0;
})));
}
getModules() {
return this.modules;
}
snapshot() {
return this.modules.size;
}
rollback(snapshot) {
const modules = this.modules;
for (const m of modules) 0 === snapshot ? modules.delete(m) : snapshot--;
}
}
module.exports = class {
constructor(options) {
"object" != typeof options && (options = {}), this.options = options;
}
apply(compiler) {
const {_backCompat: backCompat} = compiler;
compiler.hooks.compilation.tap("ModuleConcatenationPlugin", (compilation => {
if (compilation.moduleMemCaches) throw new Error("optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect");
const moduleGraph = compilation.moduleGraph, bailoutReasonMap = new Map, setBailoutReason = (module, reason) => {
setInnerBailoutReason(module, reason), moduleGraph.getOptimizationBailout(module).push("function" == typeof reason ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));
}, setInnerBailoutReason = (module, reason) => {
bailoutReasonMap.set(module, reason);
}, formatBailoutWarning = (module, problem) => requestShortener => {
if ("function" == typeof problem) return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}: ${problem(requestShortener)}`);
const reason = ((module, requestShortener) => {
const reason = bailoutReasonMap.get(module);
return "function" == typeof reason ? reason(requestShortener) : reason;
})(module, requestShortener), reasonWithPrefix = reason ? `: ${reason}` : "";
return formatBailoutReason(module === problem ? `Cannot concat with ${module.readableIdentifier(requestShortener)}${reasonWithPrefix}` : `Cannot concat with ${module.readableIdentifier(requestShortener)} because of ${problem.readableIdentifier(requestShortener)}${reasonWithPrefix}`);
};
compilation.hooks.optimizeChunkModules.tapAsync({
name: "ModuleConcatenationPlugin",
stage: STAGE_DEFAULT
}, ((allChunks, modules, callback) => {
const logger = compilation.getLogger("webpack.ModuleConcatenationPlugin"), {chunkGraph, moduleGraph} = compilation, relevantModules = [], possibleInners = new Set, context = {
chunkGraph,
moduleGraph
};
logger.time("select relevant modules");
for (const module of modules) {
let canBeRoot = !0, canBeInner = !0;
const bailoutReason = module.getConcatenationBailoutReason(context);
if (bailoutReason) {
setBailoutReason(module, bailoutReason);
continue;
}
if (moduleGraph.isAsync(module)) {
setBailoutReason(module, "Module is async");
continue;
}
if (!module.buildInfo.strict) {
setBailoutReason(module, "Module is not in strict mode");
continue;
}
if (0 === chunkGraph.getNumberOfModuleChunks(module)) {
setBailoutReason(module, "Module is not in any chunk");
continue;
}
const relevantExports = moduleGraph.getExportsInfo(module).getRelevantExports(void 0), unknownReexports = relevantExports.filter((exportInfo => exportInfo.isReexport() && !exportInfo.getTarget(moduleGraph)));
if (unknownReexports.length > 0) {
setBailoutReason(module, `Reexports in this module do not have a static target (${Array.from(unknownReexports, (exportInfo => `${exportInfo.name || "other exports"}: ${exportInfo.getUsedInfo()}`)).join(", ")})`);
continue;
}
const unknownProvidedExports = relevantExports.filter((exportInfo => !0 !== exportInfo.provided));
unknownProvidedExports.length > 0 && (setBailoutReason(module, `List of module exports is dynamic (${Array.from(unknownProvidedExports, (exportInfo => `${exportInfo.name || "other exports"}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`)).join(", ")})`), 
canBeRoot = !1), chunkGraph.isEntryModule(module) && (setInnerBailoutReason(module, "Module is an entry point"), 
canBeInner = !1), canBeRoot && relevantModules.push(module), canBeInner && possibleInners.add(module);
}
logger.timeEnd("select relevant modules"), logger.debug(`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`), 
logger.time("sort relevant modules"), relevantModules.sort(((a, b) => moduleGraph.getDepth(a) - moduleGraph.getDepth(b))), 
logger.timeEnd("sort relevant modules");
const stats = {
cached: 0,
alreadyInConfig: 0,
invalidModule: 0,
incorrectChunks: 0,
incorrectDependency: 0,
incorrectModuleDependency: 0,
incorrectChunksOfImporter: 0,
incorrectRuntimeCondition: 0,
importerFailed: 0,
added: 0
};
let statsCandidates = 0, statsSizeSum = 0, statsEmptyConfigurations = 0;
logger.time("find modules to concatenate");
const concatConfigurations = [], usedAsInner = new Set;
for (const currentRoot of relevantModules) {
if (usedAsInner.has(currentRoot)) continue;
let chunkRuntime;
for (const r of chunkGraph.getModuleRuntimes(currentRoot)) chunkRuntime = mergeRuntimeOwned(chunkRuntime, r);
const exportsInfo = moduleGraph.getExportsInfo(currentRoot), filteredRuntime = filterRuntime(chunkRuntime, (r => exportsInfo.isModuleUsed(r))), activeRuntime = !0 === filteredRuntime ? chunkRuntime : !1 === filteredRuntime ? void 0 : filteredRuntime, currentConfiguration = new ConcatConfiguration(currentRoot, activeRuntime), failureCache = new Map, candidates = new Set;
for (const imp of this._getImports(compilation, currentRoot, activeRuntime)) candidates.add(imp);
for (const imp of candidates) {
const impCandidates = new Set, problem = this._tryToAdd(compilation, currentConfiguration, imp, chunkRuntime, activeRuntime, possibleInners, impCandidates, failureCache, chunkGraph, !0, stats);
if (problem) failureCache.set(imp, problem), currentConfiguration.addWarning(imp, problem); else for (const c of impCandidates) candidates.add(c);
}
if (statsCandidates += candidates.size, currentConfiguration.isEmpty()) {
statsEmptyConfigurations++;
const optimizationBailouts = moduleGraph.getOptimizationBailout(currentRoot);
for (const warning of currentConfiguration.getWarningsSorted()) optimizationBailouts.push(formatBailoutWarning(warning[0], warning[1]));
} else {
const modules = currentConfiguration.getModules();
statsSizeSum += modules.size, concatConfigurations.push(currentConfiguration);
for (const module of modules) module !== currentConfiguration.rootModule && usedAsInner.add(module);
}
}
logger.timeEnd("find modules to concatenate"), logger.debug(`${concatConfigurations.length} successful concat configurations (avg size: ${statsSizeSum / concatConfigurations.length}), ${statsEmptyConfigurations} bailed out completely`), 
logger.debug(`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`), 
logger.time("sort concat configurations"), concatConfigurations.sort(((a, b) => b.modules.size - a.modules.size)), 
logger.timeEnd("sort concat configurations");
const usedModules = new Set;
logger.time("create concatenated modules"), asyncLib.each(concatConfigurations, ((concatConfiguration, callback) => {
const rootModule = concatConfiguration.rootModule;
if (usedModules.has(rootModule)) return callback();
const modules = concatConfiguration.getModules();
for (const m of modules) usedModules.add(m);
let newModule = ConcatenatedModule.create(rootModule, modules, concatConfiguration.runtime, compiler.root, compilation.outputOptions.hashFunction);
const integrate = () => {
backCompat && (ChunkGraph.setChunkGraphForModule(newModule, chunkGraph), ModuleGraph.setModuleGraphForModule(newModule, moduleGraph));
for (const warning of concatConfiguration.getWarningsSorted()) moduleGraph.getOptimizationBailout(newModule).push(formatBailoutWarning(warning[0], warning[1]));
moduleGraph.cloneModuleAttributes(rootModule, newModule);
for (const m of modules) if (compilation.builtModules.has(m) && compilation.builtModules.add(newModule), 
m !== rootModule) {
moduleGraph.copyOutgoingModuleConnections(m, newModule, (c => c.originModule === m && !(c.dependency instanceof HarmonyImportDependency && modules.has(c.module))));
for (const chunk of chunkGraph.getModuleChunksIterable(rootModule)) {
const sourceTypes = chunkGraph.getChunkModuleSourceTypes(chunk, m);
if (1 === sourceTypes.size) chunkGraph.disconnectChunkAndModule(chunk, m); else {
const newSourceTypes = new Set(sourceTypes);
newSourceTypes.delete("javascript"), chunkGraph.setChunkModuleSourceTypes(chunk, m, newSourceTypes);
}
}
}
compilation.modules.delete(rootModule), ChunkGraph.clearChunkGraphForModule(rootModule), 
ModuleGraph.clearModuleGraphForModule(rootModule), chunkGraph.replaceModule(rootModule, newModule), 
moduleGraph.moveModuleConnections(rootModule, newModule, (c => {
const otherModule = c.module === rootModule ? c.originModule : c.module;
return !(c.dependency instanceof HarmonyImportDependency && modules.has(otherModule));
})), compilation.modules.add(newModule), callback();
};
newModule.build(compiler.options, compilation, null, null, (err => {
if (err) return err.module || (err.module = newModule), callback(err);
integrate();
}));
}), (err => {
logger.timeEnd("create concatenated modules"), process.nextTick(callback.bind(null, err));
}));
}));
}));
}
_getImports(compilation, module, runtime) {
const moduleGraph = compilation.moduleGraph, set = new Set;
for (const dep of module.dependencies) {
if (!(dep instanceof HarmonyImportDependency)) continue;
const connection = moduleGraph.getConnection(dep);
if (!connection || !connection.module || !connection.isTargetActive(runtime)) continue;
(compilation.getDependencyReferencedExports(dep, void 0).every((i => Array.isArray(i) ? i.length > 0 : i.name.length > 0)) || Array.isArray(moduleGraph.getProvidedExports(module))) && set.add(connection.module);
}
return set;
}
_tryToAdd(compilation, config, module, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, avoidMutateOnFailure, statistics) {
const cacheEntry = failureCache.get(module);
if (cacheEntry) return statistics.cached++, cacheEntry;
if (config.has(module)) return statistics.alreadyInConfig++, null;
if (!possibleModules.has(module)) return statistics.invalidModule++, failureCache.set(module, module), 
module;
const missingChunks = Array.from(chunkGraph.getModuleChunksIterable(config.rootModule)).filter((chunk => !chunkGraph.isModuleInChunk(module, chunk)));
if (missingChunks.length > 0) {
const problem = requestShortener => {
const missingChunksList = Array.from(new Set(missingChunks.map((chunk => chunk.name || "unnamed chunk(s)")))).sort(), chunks = Array.from(new Set(Array.from(chunkGraph.getModuleChunksIterable(module)).map((chunk => chunk.name || "unnamed chunk(s)")))).sort();
return `Module ${module.readableIdentifier(requestShortener)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(", ")}, module is in chunk(s) ${chunks.join(", ")})`;
};
return statistics.incorrectChunks++, failureCache.set(module, problem), problem;
}
const incomingConnections = compilation.moduleGraph.getIncomingConnectionsByOriginModule(module), incomingConnectionsFromNonModules = incomingConnections.get(null) || incomingConnections.get(void 0);
if (incomingConnectionsFromNonModules) {
const activeNonModulesConnections = incomingConnectionsFromNonModules.filter((connection => connection.isActive(runtime)));
if (activeNonModulesConnections.length > 0) {
const problem = requestShortener => {
const importingExplanations = new Set(activeNonModulesConnections.map((c => c.explanation)).filter(Boolean)), explanations = Array.from(importingExplanations).sort();
return `Module ${module.readableIdentifier(requestShortener)} is referenced ${explanations.length > 0 ? `by: ${explanations.join(", ")}` : "in an unsupported way"}`;
};
return statistics.incorrectDependency++, failureCache.set(module, problem), problem;
}
}
const incomingConnectionsFromModules = new Map;
for (const [originModule, connections] of incomingConnections) if (originModule) {
if (0 === chunkGraph.getNumberOfModuleChunks(originModule)) continue;
let originRuntime;
for (const r of chunkGraph.getModuleRuntimes(originModule)) originRuntime = mergeRuntimeOwned(originRuntime, r);
if (!intersectRuntime(runtime, originRuntime)) continue;
const activeConnections = connections.filter((connection => connection.isActive(runtime)));
activeConnections.length > 0 && incomingConnectionsFromModules.set(originModule, activeConnections);
}
const incomingModules = Array.from(incomingConnectionsFromModules.keys()), otherChunkModules = incomingModules.filter((originModule => {
for (const chunk of chunkGraph.getModuleChunksIterable(config.rootModule)) if (!chunkGraph.isModuleInChunk(originModule, chunk)) return !0;
return !1;
}));
if (otherChunkModules.length > 0) {
const problem = requestShortener => {
const names = otherChunkModules.map((m => m.readableIdentifier(requestShortener))).sort();
return `Module ${module.readableIdentifier(requestShortener)} is referenced from different chunks by these modules: ${names.join(", ")}`;
};
return statistics.incorrectChunksOfImporter++, failureCache.set(module, problem), 
problem;
}
const nonHarmonyConnections = new Map;
for (const [originModule, connections] of incomingConnectionsFromModules) {
connections.filter((connection => !(connection.dependency && connection.dependency instanceof HarmonyImportDependency))).length > 0 && nonHarmonyConnections.set(originModule, connections);
}
if (nonHarmonyConnections.size > 0) {
const problem = requestShortener => {
const names = Array.from(nonHarmonyConnections).map((([originModule, connections]) => `${originModule.readableIdentifier(requestShortener)} (referenced with ${Array.from(new Set(connections.map((c => c.dependency && c.dependency.type)).filter(Boolean))).sort().join(", ")})`)).sort();
return `Module ${module.readableIdentifier(requestShortener)} is referenced from these modules with unsupported syntax: ${names.join(", ")}`;
};
return statistics.incorrectModuleDependency++, failureCache.set(module, problem), 
problem;
}
if (void 0 !== runtime && "string" != typeof runtime) {
const otherRuntimeConnections = [];
outer: for (const [originModule, connections] of incomingConnectionsFromModules) {
let currentRuntimeCondition = !1;
for (const connection of connections) {
const runtimeCondition = filterRuntime(runtime, (runtime => connection.isTargetActive(runtime)));
if (!1 !== runtimeCondition) {
if (!0 === runtimeCondition) continue outer;
currentRuntimeCondition = !1 !== currentRuntimeCondition ? mergeRuntime(currentRuntimeCondition, runtimeCondition) : runtimeCondition;
}
}
!1 !== currentRuntimeCondition && otherRuntimeConnections.push({
originModule,
runtimeCondition: currentRuntimeCondition
});
}
if (otherRuntimeConnections.length > 0) {
const problem = requestShortener => `Module ${module.readableIdentifier(requestShortener)} is runtime-dependent referenced by these modules: ${Array.from(otherRuntimeConnections, (({originModule, runtimeCondition}) => `${originModule.readableIdentifier(requestShortener)} (expected runtime ${runtimeToString(runtime)}, module is only referenced in ${runtimeToString(runtimeCondition)})`)).join(", ")}`;
return statistics.incorrectRuntimeCondition++, failureCache.set(module, problem), 
problem;
}
}
let backup;
avoidMutateOnFailure && (backup = config.snapshot()), config.add(module), incomingModules.sort(compareModulesByIdentifier);
for (const originModule of incomingModules) {
const problem = this._tryToAdd(compilation, config, originModule, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, !1, statistics);
if (problem) return void 0 !== backup && config.rollback(backup), statistics.importerFailed++, 
failureCache.set(module, problem), problem;
}
for (const imp of this._getImports(compilation, module, runtime)) candidates.add(imp);
return statistics.added++, null;
}
};
},
83582: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncBailHook} = __webpack_require__(89991), {RawSource, CachedSource, CompatSource} = __webpack_require__(37946), Compilation = __webpack_require__(62843), WebpackError = __webpack_require__(64326), {compareSelect, compareStrings} = __webpack_require__(40028), createHash = __webpack_require__(27466), EMPTY_SET = new Set, addToList = (itemOrItems, list) => {
if (Array.isArray(itemOrItems)) for (const item of itemOrItems) list.add(item); else itemOrItems && list.add(itemOrItems);
}, mapAndDeduplicateBuffers = (input, fn) => {
const result = [];
outer: for (const value of input) {
const buf = fn(value);
for (const other of result) if (buf.equals(other)) continue outer;
result.push(buf);
}
return result;
}, quoteMeta = str => str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&"), cachedSourceMap = new WeakMap, toCachedSource = source => {
if (source instanceof CachedSource) return source;
const entry = cachedSourceMap.get(source);
if (void 0 !== entry) return entry;
const newSource = new CachedSource(CompatSource.from(source));
return cachedSourceMap.set(source, newSource), newSource;
}, compilationHooksMap = new WeakMap;
class RealContentHashPlugin {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
updateHash: new SyncBailHook([ "content", "oldHash" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor({hashFunction, hashDigest}) {
this._hashFunction = hashFunction, this._hashDigest = hashDigest;
}
apply(compiler) {
compiler.hooks.compilation.tap("RealContentHashPlugin", (compilation => {
const cacheAnalyse = compilation.getCache("RealContentHashPlugin|analyse"), cacheGenerate = compilation.getCache("RealContentHashPlugin|generate"), hooks = RealContentHashPlugin.getCompilationHooks(compilation);
compilation.hooks.processAssets.tapPromise({
name: "RealContentHashPlugin",
stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH
}, (async () => {
const assets = compilation.getAssets(), assetsWithInfo = [], hashToAssets = new Map;
for (const {source, info, name} of assets) {
const cachedSource = toCachedSource(source), content = cachedSource.source(), hashes = new Set;
addToList(info.contenthash, hashes);
const data = {
name,
info,
source: cachedSource,
newSource: void 0,
newSourceWithoutOwn: void 0,
content,
ownHashes: void 0,
contentComputePromise: void 0,
contentComputeWithoutOwnPromise: void 0,
referencedHashes: void 0,
hashes
};
assetsWithInfo.push(data);
for (const hash of hashes) {
const list = hashToAssets.get(hash);
void 0 === list ? hashToAssets.set(hash, [ data ]) : list.push(data);
}
}
if (0 === hashToAssets.size) return;
const hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join("|"), "g");
await Promise.all(assetsWithInfo.map((async asset => {
const {name, source, content, hashes} = asset;
if (Buffer.isBuffer(content)) return asset.referencedHashes = EMPTY_SET, void (asset.ownHashes = EMPTY_SET);
const etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join("|"));
[asset.referencedHashes, asset.ownHashes] = await cacheAnalyse.providePromise(name, etag, (() => {
const referencedHashes = new Set;
let ownHashes = new Set;
const inContent = content.match(hashRegExp);
if (inContent) for (const hash of inContent) hashes.has(hash) ? ownHashes.add(hash) : referencedHashes.add(hash);
return [ referencedHashes, ownHashes ];
}));
})));
const getDependencies = hash => {
const assets = hashToAssets.get(hash);
if (!assets) {
const referencingAssets = assetsWithInfo.filter((asset => asset.referencedHashes.has(hash))), err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets.map((a => {
const match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(a.content);
return ` - ${a.name}: ...${match ? match[0] : "???"}...`;
})).join("\n")}`);
return void compilation.errors.push(err);
}
const hashes = new Set;
for (const {referencedHashes, ownHashes} of assets) {
if (!ownHashes.has(hash)) for (const hash of ownHashes) hashes.add(hash);
for (const hash of referencedHashes) hashes.add(hash);
}
return hashes;
}, hashInfo = hash => {
const assets = hashToAssets.get(hash);
return `${hash} (${Array.from(assets, (a => a.name))})`;
}, hashesInOrder = new Set;
for (const hash of hashToAssets.keys()) {
const add = (hash, stack) => {
const deps = getDependencies(hash);
if (deps) {
stack.add(hash);
for (const dep of deps) if (!hashesInOrder.has(dep)) {
if (stack.has(dep)) throw new Error(`Circular hash dependency ${Array.from(stack, hashInfo).join(" -> ")} -> ${hashInfo(dep)}`);
add(dep, stack);
}
hashesInOrder.add(hash), stack.delete(hash);
}
};
hashesInOrder.has(hash) || add(hash, new Set);
}
const hashToNewHash = new Map, getEtag = asset => cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, (hash => hashToNewHash.get(hash))).join("|")), computeNewContent = asset => asset.contentComputePromise ? asset.contentComputePromise : asset.contentComputePromise = (async () => {
if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some((hash => hashToNewHash.get(hash) !== hash))) {
const identifier = asset.name, etag = getEtag(asset);
asset.newSource = await cacheGenerate.providePromise(identifier, etag, (() => {
const newContent = asset.content.replace(hashRegExp, (hash => hashToNewHash.get(hash)));
return new RawSource(newContent);
}));
}
})(), computeNewContentWithoutOwn = asset => asset.contentComputeWithoutOwnPromise ? asset.contentComputeWithoutOwnPromise : asset.contentComputeWithoutOwnPromise = (async () => {
if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some((hash => hashToNewHash.get(hash) !== hash))) {
const identifier = asset.name + "|without-own", etag = getEtag(asset);
asset.newSourceWithoutOwn = await cacheGenerate.providePromise(identifier, etag, (() => {
const newContent = asset.content.replace(hashRegExp, (hash => asset.ownHashes.has(hash) ? "" : hashToNewHash.get(hash)));
return new RawSource(newContent);
}));
}
})(), comparator = compareSelect((a => a.name), compareStrings);
for (const oldHash of hashesInOrder) {
const assets = hashToAssets.get(oldHash);
assets.sort(comparator);
const hash = createHash(this._hashFunction);
await Promise.all(assets.map((asset => asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset))));
const assetsContent = mapAndDeduplicateBuffers(assets, (asset => asset.ownHashes.has(oldHash) ? asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer() : asset.newSource ? asset.newSource.buffer() : asset.source.buffer()));
let newHash = hooks.updateHash.call(assetsContent, oldHash);
if (!newHash) {
for (const content of assetsContent) hash.update(content);
newHash = hash.digest(this._hashDigest).slice(0, oldHash.length);
}
hashToNewHash.set(oldHash, newHash);
}
await Promise.all(assetsWithInfo.map((async asset => {
await computeNewContent(asset);
const newName = asset.name.replace(hashRegExp, (hash => hashToNewHash.get(hash))), infoUpdate = {}, hash = asset.info.contenthash;
infoUpdate.contenthash = Array.isArray(hash) ? hash.map((hash => hashToNewHash.get(hash))) : hashToNewHash.get(hash), 
void 0 !== asset.newSource ? compilation.updateAsset(asset.name, asset.newSource, infoUpdate) : compilation.updateAsset(asset.name, asset.source, infoUpdate), 
asset.name !== newName && compilation.renameAsset(asset.name, newName);
})));
}));
}));
}
}
module.exports = RealContentHashPlugin;
},
64656: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_BASIC, STAGE_ADVANCED} = __webpack_require__(60933);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RemoveEmptyChunksPlugin", (compilation => {
const handler = chunks => {
const chunkGraph = compilation.chunkGraph;
for (const chunk of chunks) 0 !== chunkGraph.getNumberOfChunkModules(chunk) || chunk.hasRuntime() || 0 !== chunkGraph.getNumberOfEntryModules(chunk) || (compilation.chunkGraph.disconnectChunk(chunk), 
compilation.chunks.delete(chunk));
};
compilation.hooks.optimizeChunks.tap({
name: "RemoveEmptyChunksPlugin",
stage: STAGE_BASIC
}, handler), compilation.hooks.optimizeChunks.tap({
name: "RemoveEmptyChunksPlugin",
stage: STAGE_ADVANCED
}, handler);
}));
}
};
},
78888: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {STAGE_BASIC} = __webpack_require__(60933), Queue = __webpack_require__(77274), {intersect} = __webpack_require__(73974);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("RemoveParentModulesPlugin", (compilation => {
compilation.hooks.optimizeChunks.tap({
name: "RemoveParentModulesPlugin",
stage: STAGE_BASIC
}, ((chunks, chunkGroups) => {
const chunkGraph = compilation.chunkGraph, queue = new Queue, availableModulesMap = new WeakMap;
for (const chunkGroup of compilation.entrypoints.values()) {
availableModulesMap.set(chunkGroup, new Set);
for (const child of chunkGroup.childrenIterable) queue.enqueue(child);
}
for (const chunkGroup of compilation.asyncEntrypoints) {
availableModulesMap.set(chunkGroup, new Set);
for (const child of chunkGroup.childrenIterable) queue.enqueue(child);
}
for (;queue.length > 0; ) {
const chunkGroup = queue.dequeue();
let availableModules = availableModulesMap.get(chunkGroup), changed = !1;
for (const parent of chunkGroup.parentsIterable) {
const availableModulesInParent = availableModulesMap.get(parent);
if (void 0 !== availableModulesInParent) if (void 0 === availableModules) {
availableModules = new Set(availableModulesInParent);
for (const chunk of parent.chunks) for (const m of chunkGraph.getChunkModulesIterable(chunk)) availableModules.add(m);
availableModulesMap.set(chunkGroup, availableModules), changed = !0;
} else for (const m of availableModules) chunkGraph.isModuleInChunkGroup(m, parent) || availableModulesInParent.has(m) || (availableModules.delete(m), 
changed = !0);
}
if (changed) for (const child of chunkGroup.childrenIterable) queue.enqueue(child);
}
for (const chunk of chunks) {
const availableModulesSets = Array.from(chunk.groupsIterable, (chunkGroup => availableModulesMap.get(chunkGroup)));
if (availableModulesSets.some((s => void 0 === s))) continue;
const availableModules = 1 === availableModulesSets.length ? availableModulesSets[0] : intersect(availableModulesSets), numberOfModules = chunkGraph.getNumberOfChunkModules(chunk), toRemove = new Set;
if (numberOfModules < availableModules.size) for (const m of chunkGraph.getChunkModulesIterable(chunk)) availableModules.has(m) && toRemove.add(m); else for (const m of availableModules) chunkGraph.isModuleInChunk(m, chunk) && toRemove.add(m);
for (const module of toRemove) chunkGraph.disconnectChunkAndModule(chunk, module);
}
}));
}));
}
};
},
1058: module => {
"use strict";
module.exports = class {
constructor(options) {
this.options = {
name: entrypoint => `runtime~${entrypoint.name}`,
...options
};
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("RuntimeChunkPlugin", (compilation => {
compilation.hooks.addEntry.tap("RuntimeChunkPlugin", ((_, {name: entryName}) => {
if (void 0 === entryName) return;
const data = compilation.entries.get(entryName);
if (void 0 === data.options.runtime && !data.options.dependOn) {
let name = this.options.name;
"function" == typeof name && (name = name({
name: entryName
})), data.options.runtime = name;
}
}));
}));
}
};
},
72708: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const glob2regexp = __webpack_require__(81700), {STAGE_DEFAULT} = __webpack_require__(60933), HarmonyExportImportedSpecifierDependency = __webpack_require__(59411), HarmonyImportSpecifierDependency = __webpack_require__(68081), formatLocation = __webpack_require__(78509), globToRegexpCache = new WeakMap;
class SideEffectsFlagPlugin {
constructor(analyseSource = !0) {
this._analyseSource = analyseSource;
}
apply(compiler) {
let cache = globToRegexpCache.get(compiler.root);
void 0 === cache && (cache = new Map, globToRegexpCache.set(compiler.root, cache)), 
compiler.hooks.compilation.tap("SideEffectsFlagPlugin", ((compilation, {normalModuleFactory}) => {
const moduleGraph = compilation.moduleGraph;
if (normalModuleFactory.hooks.module.tap("SideEffectsFlagPlugin", ((module, data) => {
const resolveData = data.resourceResolveData;
if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {
const sideEffects = resolveData.descriptionFileData.sideEffects;
if (void 0 !== sideEffects) {
void 0 === module.factoryMeta && (module.factoryMeta = {});
const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects, cache);
module.factoryMeta.sideEffectFree = !hasSideEffects;
}
}
return module;
})), normalModuleFactory.hooks.module.tap("SideEffectsFlagPlugin", ((module, data) => ("boolean" == typeof data.settings.sideEffects && (void 0 === module.factoryMeta && (module.factoryMeta = {}), 
module.factoryMeta.sideEffectFree = !data.settings.sideEffects), module))), this._analyseSource) {
const parserHandler = parser => {
let sideEffectsStatement;
parser.hooks.program.tap("SideEffectsFlagPlugin", (() => {
sideEffectsStatement = void 0;
})), parser.hooks.statement.tap({
name: "SideEffectsFlagPlugin",
stage: -100
}, (statement => {
if (!sideEffectsStatement && !0 === parser.scope.topLevelScope) switch (statement.type) {
case "ExpressionStatement":
parser.isPure(statement.expression, statement.range[0]) || (sideEffectsStatement = statement);
break;

case "IfStatement":
case "WhileStatement":
case "DoWhileStatement":
parser.isPure(statement.test, statement.range[0]) || (sideEffectsStatement = statement);
break;

case "ForStatement":
parser.isPure(statement.init, statement.range[0]) && parser.isPure(statement.test, statement.init ? statement.init.range[1] : statement.range[0]) && parser.isPure(statement.update, statement.test ? statement.test.range[1] : statement.init ? statement.init.range[1] : statement.range[0]) || (sideEffectsStatement = statement);
break;

case "SwitchStatement":
parser.isPure(statement.discriminant, statement.range[0]) || (sideEffectsStatement = statement);
break;

case "VariableDeclaration":
case "ClassDeclaration":
case "FunctionDeclaration":
parser.isPure(statement, statement.range[0]) || (sideEffectsStatement = statement);
break;

case "ExportNamedDeclaration":
case "ExportDefaultDeclaration":
parser.isPure(statement.declaration, statement.range[0]) || (sideEffectsStatement = statement);
break;

case "LabeledStatement":
case "BlockStatement":
case "EmptyStatement":
case "ExportAllDeclaration":
case "ImportDeclaration":
break;

default:
sideEffectsStatement = statement;
}
})), parser.hooks.finish.tap("SideEffectsFlagPlugin", (() => {
if (void 0 === sideEffectsStatement) parser.state.module.buildMeta.sideEffectFree = !0; else {
const {loc, type} = sideEffectsStatement;
moduleGraph.getOptimizationBailout(parser.state.module).push((() => `Statement (${type}) with side effects in source code at ${formatLocation(loc)}`));
}
}));
};
for (const key of [ "javascript/auto", "javascript/esm", "javascript/dynamic" ]) normalModuleFactory.hooks.parser.for(key).tap("SideEffectsFlagPlugin", parserHandler);
}
compilation.hooks.optimizeDependencies.tap({
name: "SideEffectsFlagPlugin",
stage: STAGE_DEFAULT
}, (modules => {
const logger = compilation.getLogger("webpack.SideEffectsFlagPlugin");
logger.time("update dependencies");
for (const module of modules) if (!1 === module.getSideEffectsConnectionState(moduleGraph)) {
const exportsInfo = moduleGraph.getExportsInfo(module);
for (const connection of moduleGraph.getIncomingConnections(module)) {
const dep = connection.dependency;
let isReexport;
if ((isReexport = dep instanceof HarmonyExportImportedSpecifierDependency) || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) {
if (isReexport && dep.name) {
moduleGraph.getExportInfo(connection.originModule, dep.name).moveTarget(moduleGraph, (({module}) => !1 === module.getSideEffectsConnectionState(moduleGraph)), (({module: newModule, export: exportName}) => {
moduleGraph.updateModule(dep, newModule), moduleGraph.addExplanation(dep, "(skipped side-effect-free modules)");
const ids = dep.getIds(moduleGraph);
return dep.setIds(moduleGraph, exportName ? [ ...exportName, ...ids.slice(1) ] : ids.slice(1)), 
moduleGraph.getConnection(dep);
}));
continue;
}
const ids = dep.getIds(moduleGraph);
if (ids.length > 0) {
const target = exportsInfo.getExportInfo(ids[0]).getTarget(moduleGraph, (({module}) => !1 === module.getSideEffectsConnectionState(moduleGraph)));
if (!target) continue;
moduleGraph.updateModule(dep, target.module), moduleGraph.addExplanation(dep, "(skipped side-effect-free modules)"), 
dep.setIds(moduleGraph, target.export ? [ ...target.export, ...ids.slice(1) ] : ids.slice(1));
}
}
}
}
logger.timeEnd("update dependencies");
}));
}));
}
static moduleHasSideEffects(moduleName, flagValue, cache) {
switch (typeof flagValue) {
case "undefined":
return !0;

case "boolean":
return flagValue;

case "string":
return ((glob, cache) => {
const cacheEntry = cache.get(glob);
if (void 0 !== cacheEntry) return cacheEntry;
glob.includes("/") || (glob = `**/${glob}`);
const regexpSource = glob2regexp(glob, {
globstar: !0,
extended: !0
}).source, regexp = new RegExp("^(\\./)?" + regexpSource.slice(1));
return cache.set(glob, regexp), regexp;
})(flagValue, cache).test(moduleName);

case "object":
return flagValue.some((glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache)));
}
}
}
module.exports = SideEffectsFlagPlugin;
},
222: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Chunk = __webpack_require__(76034), {STAGE_ADVANCED} = __webpack_require__(60933), WebpackError = __webpack_require__(64326), {requestToId} = __webpack_require__(89945), {isSubset} = __webpack_require__(73974), SortableSet = __webpack_require__(72451), {compareModulesByIdentifier, compareIterables} = __webpack_require__(40028), createHash = __webpack_require__(27466), deterministicGrouping = __webpack_require__(2948), {makePathsRelative} = __webpack_require__(63264), memoize = __webpack_require__(98216), MinMaxSizeWarning = __webpack_require__(38605), defaultGetName = () => {}, deterministicGroupingForModules = deterministicGrouping, getKeyCache = new WeakMap, hashFilename = (name, outputOptions) => createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest).slice(0, 8), getRequests = chunk => {
let requests = 0;
for (const chunkGroup of chunk.groupsIterable) requests = Math.max(requests, chunkGroup.chunks.length);
return requests;
}, mapObject = (obj, fn) => {
const newObj = Object.create(null);
for (const key of Object.keys(obj)) newObj[key] = fn(obj[key], key);
return newObj;
}, isOverlap = (a, b) => {
for (const item of a) if (b.has(item)) return !0;
return !1;
}, compareModuleIterables = compareIterables(compareModulesByIdentifier), compareEntries = (a, b) => {
const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;
if (diffPriority) return diffPriority;
const diffCount = a.chunks.size - b.chunks.size;
if (diffCount) return diffCount;
const diffSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1) - totalSize(b.sizes) * (b.chunks.size - 1);
if (diffSizeReduce) return diffSizeReduce;
const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;
if (indexDiff) return indexDiff;
const modulesA = a.modules, modulesB = b.modules, diff = modulesA.size - modulesB.size;
return diff || (modulesA.sort(), modulesB.sort(), compareModuleIterables(modulesA, modulesB));
}, INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial(), ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial(), ALL_CHUNK_FILTER = chunk => !0, normalizeSizes = (value, defaultSizeTypes) => {
if ("number" == typeof value) {
const o = {};
for (const sizeType of defaultSizeTypes) o[sizeType] = value;
return o;
}
return "object" == typeof value && null !== value ? {
...value
} : {};
}, mergeSizes = (...sizes) => {
let merged = {};
for (let i = sizes.length - 1; i >= 0; i--) merged = Object.assign(merged, sizes[i]);
return merged;
}, hasNonZeroSizes = sizes => {
for (const key of Object.keys(sizes)) if (sizes[key] > 0) return !0;
return !1;
}, combineSizes = (a, b, combine) => {
const aKeys = new Set(Object.keys(a)), bKeys = new Set(Object.keys(b)), result = {};
for (const key of aKeys) bKeys.has(key) ? result[key] = combine(a[key], b[key]) : result[key] = a[key];
for (const key of bKeys) aKeys.has(key) || (result[key] = b[key]);
return result;
}, checkMinSize = (sizes, minSize) => {
for (const key of Object.keys(minSize)) {
const size = sizes[key];
if (void 0 !== size && 0 !== size && size < minSize[key]) return !1;
}
return !0;
}, checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {
for (const key of Object.keys(minSizeReduction)) {
const size = sizes[key];
if (void 0 !== size && 0 !== size && size * chunkCount < minSizeReduction[key]) return !1;
}
return !0;
}, getViolatingMinSizes = (sizes, minSize) => {
let list;
for (const key of Object.keys(minSize)) {
const size = sizes[key];
void 0 !== size && 0 !== size && (size < minSize[key] && (void 0 === list ? list = [ key ] : list.push(key)));
}
return list;
}, totalSize = sizes => {
let size = 0;
for (const key of Object.keys(sizes)) size += sizes[key];
return size;
}, normalizeName = name => "string" == typeof name ? () => name : "function" == typeof name ? name : void 0, normalizeChunksFilter = chunks => "initial" === chunks ? INITIAL_CHUNK_FILTER : "async" === chunks ? ASYNC_CHUNK_FILTER : "all" === chunks ? ALL_CHUNK_FILTER : "function" == typeof chunks ? chunks : void 0, normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {
if ("function" == typeof cacheGroups) return cacheGroups;
if ("object" == typeof cacheGroups && null !== cacheGroups) {
const handlers = [];
for (const key of Object.keys(cacheGroups)) {
const option = cacheGroups[key];
if (!1 !== option) if ("string" == typeof option || option instanceof RegExp) {
const source = createCacheGroupSource({}, key, defaultSizeTypes);
handlers.push(((module, context, results) => {
checkTest(option, module, context) && results.push(source);
}));
} else if ("function" == typeof option) {
const cache = new WeakMap;
handlers.push(((module, context, results) => {
const result = option(module);
if (result) {
const groups = Array.isArray(result) ? result : [ result ];
for (const group of groups) {
const cachedSource = cache.get(group);
if (void 0 !== cachedSource) results.push(cachedSource); else {
const source = createCacheGroupSource(group, key, defaultSizeTypes);
cache.set(group, source), results.push(source);
}
}
}
}));
} else {
const source = createCacheGroupSource(option, key, defaultSizeTypes);
handlers.push(((module, context, results) => {
checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module) && results.push(source);
}));
}
}
const fn = (module, context) => {
let results = [];
for (const fn of handlers) fn(module, context, results);
return results;
};
return fn;
}
return () => null;
}, checkTest = (test, module, context) => {
if (void 0 === test) return !0;
if ("function" == typeof test) return test(module, context);
if ("boolean" == typeof test) return test;
if ("string" == typeof test) {
const name = module.nameForCondition();
return name && name.startsWith(test);
}
if (test instanceof RegExp) {
const name = module.nameForCondition();
return name && test.test(name);
}
return !1;
}, checkModuleType = (test, module) => {
if (void 0 === test) return !0;
if ("function" == typeof test) return test(module.type);
if ("string" == typeof test) {
return test === module.type;
}
if (test instanceof RegExp) {
const type = module.type;
return test.test(type);
}
return !1;
}, checkModuleLayer = (test, module) => {
if (void 0 === test) return !0;
if ("function" == typeof test) return test(module.layer);
if ("string" == typeof test) {
const layer = module.layer;
return "" === test ? !layer : layer && layer.startsWith(test);
}
if (test instanceof RegExp) {
const layer = module.layer;
return test.test(layer);
}
return !1;
}, createCacheGroupSource = (options, key, defaultSizeTypes) => {
const minSize = normalizeSizes(options.minSize, defaultSizeTypes), minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes), maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);
return {
key,
priority: options.priority,
getName: normalizeName(options.name),
chunksFilter: normalizeChunksFilter(options.chunks),
enforce: options.enforce,
minSize,
minSizeReduction,
minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),
enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),
maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),
maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),
minChunks: options.minChunks,
maxAsyncRequests: options.maxAsyncRequests,
maxInitialRequests: options.maxInitialRequests,
filename: options.filename,
idHint: options.idHint,
automaticNameDelimiter: options.automaticNameDelimiter,
reuseExistingChunk: options.reuseExistingChunk,
usedExports: options.usedExports
};
};
module.exports = class {
constructor(options = {}) {
const defaultSizeTypes = options.defaultSizeTypes || [ "javascript", "unknown" ], fallbackCacheGroup = options.fallbackCacheGroup || {}, minSize = normalizeSizes(options.minSize, defaultSizeTypes), minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes), maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);
this.options = {
chunksFilter: normalizeChunksFilter(options.chunks || "all"),
defaultSizeTypes,
minSize,
minSizeReduction,
minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),
enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),
maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),
maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),
minChunks: options.minChunks || 1,
maxAsyncRequests: options.maxAsyncRequests || 1,
maxInitialRequests: options.maxInitialRequests || 1,
hidePathInfo: options.hidePathInfo || !1,
filename: options.filename || void 0,
getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),
getName: options.name ? normalizeName(options.name) : defaultGetName,
automaticNameDelimiter: options.automaticNameDelimiter,
usedExports: options.usedExports,
fallbackCacheGroup: {
chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || "all"),
minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),
maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),
maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),
automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || "~"
}
}, this._cacheGroupCache = new WeakMap;
}
_getCacheGroup(cacheGroupSource) {
const cacheEntry = this._cacheGroupCache.get(cacheGroupSource);
if (void 0 !== cacheEntry) return cacheEntry;
const minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? void 0 : this.options.minSize), minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? void 0 : this.options.minSizeReduction), minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? void 0 : this.options.minRemainingSize), enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? void 0 : this.options.enforceSizeThreshold), cacheGroup = {
key: cacheGroupSource.key,
priority: cacheGroupSource.priority || 0,
chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,
minSize,
minSizeReduction,
minRemainingSize,
enforceSizeThreshold,
maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? void 0 : this.options.maxAsyncSize),
maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? void 0 : this.options.maxInitialSize),
minChunks: void 0 !== cacheGroupSource.minChunks ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,
maxAsyncRequests: void 0 !== cacheGroupSource.maxAsyncRequests ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? 1 / 0 : this.options.maxAsyncRequests,
maxInitialRequests: void 0 !== cacheGroupSource.maxInitialRequests ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? 1 / 0 : this.options.maxInitialRequests,
getName: void 0 !== cacheGroupSource.getName ? cacheGroupSource.getName : this.options.getName,
usedExports: void 0 !== cacheGroupSource.usedExports ? cacheGroupSource.usedExports : this.options.usedExports,
filename: void 0 !== cacheGroupSource.filename ? cacheGroupSource.filename : this.options.filename,
automaticNameDelimiter: void 0 !== cacheGroupSource.automaticNameDelimiter ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,
idHint: void 0 !== cacheGroupSource.idHint ? cacheGroupSource.idHint : cacheGroupSource.key,
reuseExistingChunk: cacheGroupSource.reuseExistingChunk || !1,
_validateSize: hasNonZeroSizes(minSize),
_validateRemainingSize: hasNonZeroSizes(minRemainingSize),
_minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),
_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)
};
return this._cacheGroupCache.set(cacheGroupSource, cacheGroup), cacheGroup;
}
apply(compiler) {
const cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);
compiler.hooks.thisCompilation.tap("SplitChunksPlugin", (compilation => {
const logger = compilation.getLogger("webpack.SplitChunksPlugin");
let alreadyOptimized = !1;
compilation.hooks.unseal.tap("SplitChunksPlugin", (() => {
alreadyOptimized = !1;
})), compilation.hooks.optimizeChunks.tap({
name: "SplitChunksPlugin",
stage: STAGE_ADVANCED
}, (chunks => {
if (alreadyOptimized) return;
alreadyOptimized = !0, logger.time("prepare");
const chunkGraph = compilation.chunkGraph, moduleGraph = compilation.moduleGraph, chunkIndexMap = new Map, ZERO = BigInt("0"), ONE = BigInt("1");
let index = ONE << BigInt("31");
for (const chunk of chunks) chunkIndexMap.set(chunk, index | BigInt(2147483647 * Math.random() | 0)), 
index <<= ONE;
const getKey = chunks => {
const iterator = chunks[Symbol.iterator]();
let result = iterator.next();
if (result.done) return ZERO;
const first = result.value;
if (result = iterator.next(), result.done) return first;
let key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);
for (;!(result = iterator.next()).done; ) {
key ^= chunkIndexMap.get(result.value);
}
return key;
}, getChunkSetsInGraph = memoize((() => {
const chunkSetsInGraph = new Map, singleChunkSets = new Set;
for (const module of compilation.modules) {
const chunks = chunkGraph.getModuleChunksIterable(module), chunksKey = getKey(chunks);
"bigint" == typeof chunksKey ? chunkSetsInGraph.has(chunksKey) || chunkSetsInGraph.set(chunksKey, new Set(chunks)) : singleChunkSets.add(chunksKey);
}
return {
chunkSetsInGraph,
singleChunkSets
};
})), groupChunksByExports = module => {
const exportsInfo = moduleGraph.getExportsInfo(module), groupedByUsedExports = new Map;
for (const chunk of chunkGraph.getModuleChunksIterable(module)) {
const key = exportsInfo.getUsageKey(chunk.runtime), list = groupedByUsedExports.get(key);
void 0 !== list ? list.push(chunk) : groupedByUsedExports.set(key, [ chunk ]);
}
return groupedByUsedExports.values();
}, groupedByExportsMap = new Map, getExportsChunkSetsInGraph = memoize((() => {
const chunkSetsInGraph = new Map, singleChunkSets = new Set;
for (const module of compilation.modules) {
const groupedChunks = Array.from(groupChunksByExports(module));
groupedByExportsMap.set(module, groupedChunks);
for (const chunks of groupedChunks) if (1 === chunks.length) singleChunkSets.add(chunks[0]); else {
const chunksKey = getKey(chunks);
chunkSetsInGraph.has(chunksKey) || chunkSetsInGraph.set(chunksKey, new Set(chunks));
}
}
return {
chunkSetsInGraph,
singleChunkSets
};
})), groupChunkSetsByCount = chunkSets => {
const chunkSetsByCount = new Map;
for (const chunksSet of chunkSets) {
const count = chunksSet.size;
let array = chunkSetsByCount.get(count);
void 0 === array && (array = [], chunkSetsByCount.set(count, array)), array.push(chunksSet);
}
return chunkSetsByCount;
}, getChunkSetsByCount = memoize((() => groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values()))), getExportsChunkSetsByCount = memoize((() => groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values()))), createGetCombinations = (chunkSets, singleChunkSets, chunkSetsByCount) => {
const combinationsCache = new Map;
return key => {
const cacheEntry = combinationsCache.get(key);
if (void 0 !== cacheEntry) return cacheEntry;
if (key instanceof Chunk) {
const result = [ key ];
return combinationsCache.set(key, result), result;
}
const chunksSet = chunkSets.get(key), array = [ chunksSet ];
for (const [count, setArray] of chunkSetsByCount) if (count < chunksSet.size) for (const set of setArray) isSubset(chunksSet, set) && array.push(set);
for (const chunk of singleChunkSets) chunksSet.has(chunk) && array.push(chunk);
return combinationsCache.set(key, array), array;
};
}, getCombinationsFactory = memoize((() => {
const {chunkSetsInGraph, singleChunkSets} = getChunkSetsInGraph();
return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());
})), getExportsCombinationsFactory = memoize((() => {
const {chunkSetsInGraph, singleChunkSets} = getExportsChunkSetsInGraph();
return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());
})), selectedChunksCacheByChunksSet = new WeakMap, getSelectedChunks = (chunks, chunkFilter) => {
let entry = selectedChunksCacheByChunksSet.get(chunks);
void 0 === entry && (entry = new WeakMap, selectedChunksCacheByChunksSet.set(chunks, entry));
let entry2 = entry.get(chunkFilter);
if (void 0 === entry2) {
const selectedChunks = [];
if (chunks instanceof Chunk) chunkFilter(chunks) && selectedChunks.push(chunks); else for (const chunk of chunks) chunkFilter(chunk) && selectedChunks.push(chunk);
entry2 = {
chunks: selectedChunks,
key: getKey(selectedChunks)
}, entry.set(chunkFilter, entry2);
}
return entry2;
}, alreadyValidatedParents = new Map, alreadyReportedErrors = new Set, chunksInfoMap = new Map, addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {
if (selectedChunks.length < cacheGroup.minChunks) return;
const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key), existingChunk = compilation.namedChunks.get(name);
if (existingChunk) {
const parentValidationKey = `${name}|${"bigint" == typeof selectedChunksKey ? selectedChunksKey : selectedChunksKey.debugId}`, valid = alreadyValidatedParents.get(parentValidationKey);
if (!1 === valid) return;
if (void 0 === valid) {
let isInAllParents = !0;
const queue = new Set;
for (const chunk of selectedChunks) for (const group of chunk.groupsIterable) queue.add(group);
for (const group of queue) {
if (existingChunk.isInGroup(group)) continue;
let hasParent = !1;
for (const parent of group.parentsIterable) hasParent = !0, queue.add(parent);
hasParent || (isInAllParents = !1);
}
const valid = isInAllParents;
if (alreadyValidatedParents.set(parentValidationKey, valid), !valid) return void (alreadyReportedErrors.has(name) || (alreadyReportedErrors.add(name), 
compilation.errors.push(new WebpackError(`SplitChunksPlugin\nCache group "${cacheGroup.key}" conflicts with existing chunk.\nBoth have the same name "${name}" and existing chunk is not a parent of the selected modules.\nUse a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\nHINT: You can omit "name" to automatically create a name.\nBREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. This is no longer allowed when the entrypoint is not a parent of the selected modules.\nRemove this entrypoint and add modules to cache group's 'test' instead. If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). See migration guide of more info.`))));
}
}
const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${(key => "bigint" == typeof key ? key.toString(16) : chunkIndexMap.get(key).toString(16))(selectedChunksKey)}`);
let info = chunksInfoMap.get(key);
void 0 === info && chunksInfoMap.set(key, info = {
modules: new SortableSet(void 0, compareModulesByIdentifier),
cacheGroup,
cacheGroupIndex,
name,
sizes: {},
chunks: new Set,
reuseableChunks: new Set,
chunksKeys: new Set
});
const oldSize = info.modules.size;
if (info.modules.add(module), info.modules.size !== oldSize) for (const type of module.getSourceTypes()) info.sizes[type] = (info.sizes[type] || 0) + module.size(type);
const oldChunksKeysSize = info.chunksKeys.size;
if (info.chunksKeys.add(selectedChunksKey), oldChunksKeysSize !== info.chunksKeys.size) for (const chunk of selectedChunks) info.chunks.add(chunk);
}, context = {
moduleGraph,
chunkGraph
};
logger.timeEnd("prepare"), logger.time("modules");
for (const module of compilation.modules) {
let cacheGroups = this.options.getCacheGroups(module, context);
if (!Array.isArray(cacheGroups) || 0 === cacheGroups.length) continue;
const getCombs = memoize((() => {
const chunks = chunkGraph.getModuleChunksIterable(module), chunksKey = getKey(chunks);
return key = chunksKey, getCombinationsFactory()(key);
var key;
})), getCombsByUsedExports = memoize((() => {
getExportsChunkSetsInGraph();
const set = new Set, groupedByUsedExports = groupedByExportsMap.get(module);
for (const chunks of groupedByUsedExports) {
const chunksKey = getKey(chunks);
for (const comb of (key = chunksKey, getExportsCombinationsFactory()(key))) set.add(comb);
}
var key;
return set;
}));
let cacheGroupIndex = 0;
for (const cacheGroupSource of cacheGroups) {
const cacheGroup = this._getCacheGroup(cacheGroupSource), combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs();
for (const chunkCombination of combs) {
if ((chunkCombination instanceof Chunk ? 1 : chunkCombination.size) < cacheGroup.minChunks) continue;
const {chunks: selectedChunks, key: selectedChunksKey} = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);
addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);
}
cacheGroupIndex++;
}
}
logger.timeEnd("modules"), logger.time("queue");
const removeModulesWithSourceType = (info, sourceTypes) => {
for (const module of info.modules) {
const types = module.getSourceTypes();
if (sourceTypes.some((type => types.has(type)))) {
info.modules.delete(module);
for (const type of types) info.sizes[type] -= module.size(type);
}
}
}, removeMinSizeViolatingModules = info => {
if (!info.cacheGroup._validateSize) return !1;
const violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);
return void 0 !== violatingSizes && (removeModulesWithSourceType(info, violatingSizes), 
0 === info.modules.size);
};
for (const [key, info] of chunksInfoMap) removeMinSizeViolatingModules(info) ? chunksInfoMap.delete(key) : checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size) || chunksInfoMap.delete(key);
const maxSizeQueueMap = new Map;
for (;chunksInfoMap.size > 0; ) {
let bestEntryKey, bestEntry;
for (const pair of chunksInfoMap) {
const key = pair[0], info = pair[1];
(void 0 === bestEntry || compareEntries(bestEntry, info) < 0) && (bestEntry = info, 
bestEntryKey = key);
}
const item = bestEntry;
chunksInfoMap.delete(bestEntryKey);
let newChunk, chunkName = item.name, isExistingChunk = !1, isReusedWithAllModules = !1;
if (chunkName) {
const chunkByName = compilation.namedChunks.get(chunkName);
if (void 0 !== chunkByName) {
newChunk = chunkByName;
const oldSize = item.chunks.size;
item.chunks.delete(newChunk), isExistingChunk = item.chunks.size !== oldSize;
}
} else if (item.cacheGroup.reuseExistingChunk) {
outer: for (const chunk of item.chunks) if (chunkGraph.getNumberOfChunkModules(chunk) === item.modules.size && !(item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0)) {
for (const module of item.modules) if (!chunkGraph.isModuleInChunk(module, chunk)) continue outer;
newChunk && newChunk.name ? (chunk.name && chunk.name.length < newChunk.name.length || chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) && (newChunk = chunk) : newChunk = chunk;
}
newChunk && (item.chunks.delete(newChunk), chunkName = void 0, isExistingChunk = !0, 
isReusedWithAllModules = !0);
}
const enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold), usedChunks = new Set(item.chunks);
if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) for (const chunk of usedChunks) {
const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;
isFinite(maxRequests) && getRequests(chunk) >= maxRequests && usedChunks.delete(chunk);
}
outer: for (const chunk of usedChunks) {
for (const module of item.modules) if (chunkGraph.isModuleInChunk(module, chunk)) continue outer;
usedChunks.delete(chunk);
}
if (usedChunks.size < item.chunks.size) {
if (isExistingChunk && usedChunks.add(newChunk), usedChunks.size >= item.cacheGroup.minChunks) {
const chunksArr = Array.from(usedChunks);
for (const module of item.modules) addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);
}
} else {
if (!enforced && item.cacheGroup._validateRemainingSize && 1 === usedChunks.size) {
const [chunk] = usedChunks;
let chunkSizes = Object.create(null);
for (const module of chunkGraph.getChunkModulesIterable(chunk)) if (!item.modules.has(module)) for (const type of module.getSourceTypes()) chunkSizes[type] = (chunkSizes[type] || 0) + module.size(type);
const violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);
if (void 0 !== violatingSizes) {
const oldModulesSize = item.modules.size;
removeModulesWithSourceType(item, violatingSizes), item.modules.size > 0 && item.modules.size !== oldModulesSize && chunksInfoMap.set(bestEntryKey, item);
continue;
}
}
void 0 === newChunk && (newChunk = compilation.addChunk(chunkName));
for (const chunk of usedChunks) chunk.split(newChunk);
if (newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + ", " : "") + (isReusedWithAllModules ? "reused as split chunk" : "split chunk"), 
item.cacheGroup.key && (newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`), 
chunkName && (newChunk.chunkReason += ` (name: ${chunkName})`), item.cacheGroup.filename && (newChunk.filenameTemplate = item.cacheGroup.filename), 
item.cacheGroup.idHint && newChunk.idNameHints.add(item.cacheGroup.idHint), isReusedWithAllModules) for (const module of item.modules) for (const chunk of usedChunks) chunkGraph.disconnectChunkAndModule(chunk, module); else for (const module of item.modules) if (module.chunkCondition(newChunk, compilation)) {
chunkGraph.connectChunkAndModule(newChunk, module);
for (const chunk of usedChunks) chunkGraph.disconnectChunkAndModule(chunk, module);
}
if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {
const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);
maxSizeQueueMap.set(newChunk, {
minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,
maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,
maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,
automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,
keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [ item.cacheGroup.key ]
});
}
for (const [key, info] of chunksInfoMap) if (isOverlap(info.chunks, usedChunks)) {
let updated = !1;
for (const module of item.modules) if (info.modules.has(module)) {
info.modules.delete(module);
for (const key of module.getSourceTypes()) info.sizes[key] -= module.size(key);
updated = !0;
}
if (updated) {
if (0 === info.modules.size) {
chunksInfoMap.delete(key);
continue;
}
if (removeMinSizeViolatingModules(info) || !checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {
chunksInfoMap.delete(key);
continue;
}
}
}
}
}
logger.timeEnd("queue"), logger.time("maxSize");
const incorrectMinMaxSizeSet = new Set, {outputOptions} = compilation, {fallbackCacheGroup} = this.options;
for (const chunk of Array.from(compilation.chunks)) {
const chunkConfig = maxSizeQueueMap.get(chunk), {minSize, maxAsyncSize, maxInitialSize, automaticNameDelimiter} = chunkConfig || fallbackCacheGroup;
if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) continue;
let maxSize;
if (maxSize = chunk.isOnlyInitial() ? maxInitialSize : chunk.canBeInitial() ? combineSizes(maxAsyncSize, maxInitialSize, Math.min) : maxAsyncSize, 
0 === Object.keys(maxSize).length) continue;
for (const key of Object.keys(maxSize)) {
const maxSizeValue = maxSize[key], minSizeValue = minSize[key];
if ("number" == typeof minSizeValue && minSizeValue > maxSizeValue) {
const keys = chunkConfig && chunkConfig.keys, warningKey = `${keys && keys.join()} ${minSizeValue} ${maxSizeValue}`;
incorrectMinMaxSizeSet.has(warningKey) || (incorrectMinMaxSizeSet.add(warningKey), 
compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)));
}
}
const results = deterministicGroupingForModules({
minSize,
maxSize: mapObject(maxSize, ((value, key) => {
const minSizeValue = minSize[key];
return "number" == typeof minSizeValue ? Math.max(value, minSizeValue) : value;
})),
items: chunkGraph.getChunkModulesIterable(chunk),
getKey(module) {
const cache = getKeyCache.get(module);
if (void 0 !== cache) return cache;
const ident = cachedMakePathsRelative(module.identifier()), nameForCondition = module.nameForCondition && module.nameForCondition(), fullKey = (nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\?[^?!]*$/g, "")) + automaticNameDelimiter + hashFilename(ident, outputOptions), key = requestToId(fullKey);
return getKeyCache.set(module, key), key;
},
getSize(module) {
const size = Object.create(null);
for (const key of module.getSourceTypes()) size[key] = module.size(key);
return size;
}
});
if (!(results.length <= 1)) for (let i = 0; i < results.length; i++) {
const group = results[i], key = this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;
let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;
if (name && name.length > 100 && (name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions)), 
i !== results.length - 1) {
const newPart = compilation.addChunk(name);
chunk.split(newPart), newPart.chunkReason = chunk.chunkReason;
for (const module of group.items) module.chunkCondition(newPart, compilation) && (chunkGraph.connectChunkAndModule(newPart, module), 
chunkGraph.disconnectChunkAndModule(chunk, module));
} else chunk.name = name;
}
}
logger.timeEnd("maxSize");
}));
}));
}
};
},
95777: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {formatSize} = __webpack_require__(9568), WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(assetsOverSizeLimit, assetLimit) {
const assetLists = assetsOverSizeLimit.map((asset => `\n  ${asset.name} (${formatSize(asset.size)})`)).join("");
super(`asset size limit: The following asset(s) exceed the recommended size limit (${formatSize(assetLimit)}).\nThis can impact web performance.\nAssets: ${assetLists}`), 
this.name = "AssetsOverSizeLimitWarning", this.assets = assetsOverSizeLimit;
}
};
},
20947: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {formatSize} = __webpack_require__(9568), WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(entrypoints, entrypointLimit) {
const entrypointList = entrypoints.map((entrypoint => `\n  ${entrypoint.name} (${formatSize(entrypoint.size)})\n${entrypoint.files.map((asset => `      ${asset}`)).join("\n")}`)).join("");
super(`entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (${formatSize(entrypointLimit)}). This can impact web performance.\nEntrypoints:${entrypointList}\n`), 
this.name = "EntrypointsOverSizeLimitWarning", this.entrypoints = entrypoints;
}
};
},
37462: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor() {
super("webpack performance recommendations: \nYou can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/"), 
this.name = "NoAsyncChunksWarning";
}
};
},
16725: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {find} = __webpack_require__(73974), AssetsOverSizeLimitWarning = __webpack_require__(95777), EntrypointsOverSizeLimitWarning = __webpack_require__(20947), NoAsyncChunksWarning = __webpack_require__(37462), isOverSizeLimitSet = new WeakSet, excludeSourceMap = (name, source, info) => !info.development;
module.exports = class {
constructor(options) {
this.hints = options.hints, this.maxAssetSize = options.maxAssetSize, this.maxEntrypointSize = options.maxEntrypointSize, 
this.assetFilter = options.assetFilter;
}
static isOverSizeLimit(thing) {
return isOverSizeLimitSet.has(thing);
}
apply(compiler) {
const entrypointSizeLimit = this.maxEntrypointSize, assetSizeLimit = this.maxAssetSize, hints = this.hints, assetFilter = this.assetFilter || excludeSourceMap;
compiler.hooks.afterEmit.tap("SizeLimitsPlugin", (compilation => {
const warnings = [], getEntrypointSize = entrypoint => {
let size = 0;
for (const file of entrypoint.getFiles()) {
const asset = compilation.getAsset(file);
asset && assetFilter(asset.name, asset.source, asset.info) && asset.source && (size += asset.info.size || asset.source.size());
}
return size;
}, assetsOverSizeLimit = [];
for (const {name, source, info} of compilation.getAssets()) {
if (!assetFilter(name, source, info) || !source) continue;
const size = info.size || source.size();
size > assetSizeLimit && (assetsOverSizeLimit.push({
name,
size
}), isOverSizeLimitSet.add(source));
}
const fileFilter = name => {
const asset = compilation.getAsset(name);
return asset && assetFilter(asset.name, asset.source, asset.info);
}, entrypointsOverLimit = [];
for (const [name, entry] of compilation.entrypoints) {
const size = getEntrypointSize(entry);
size > entrypointSizeLimit && (entrypointsOverLimit.push({
name,
size,
files: entry.getFiles().filter(fileFilter)
}), isOverSizeLimitSet.add(entry));
}
if (hints && (assetsOverSizeLimit.length > 0 && warnings.push(new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit)), 
entrypointsOverLimit.length > 0 && warnings.push(new EntrypointsOverSizeLimitWarning(entrypointsOverLimit, entrypointSizeLimit)), 
warnings.length > 0)) {
find(compilation.chunks, (chunk => !chunk.canBeInitial())) || warnings.push(new NoAsyncChunksWarning), 
"error" === hints ? compilation.errors.push(...warnings) : compilation.warnings.push(...warnings);
}
}));
}
};
},
93416: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(childType, runtimeFunction, runtimeHandlers) {
super(`chunk ${childType} function`), this.childType = childType, this.runtimeFunction = runtimeFunction, 
this.runtimeHandlers = runtimeHandlers;
}
generate() {
const {runtimeFunction, runtimeHandlers} = this, {runtimeTemplate} = this.compilation;
return Template.asString([ `${runtimeHandlers} = {};`, `${runtimeFunction} = ${runtimeTemplate.basicFunction("chunkId", [ `Object.keys(${runtimeHandlers}).map(${runtimeTemplate.basicFunction("key", `${runtimeHandlers}[key](chunkId);`)});` ])}` ]);
}
};
},
42770: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), ChunkPrefetchFunctionRuntimeModule = __webpack_require__(93416), ChunkPrefetchStartupRuntimeModule = __webpack_require__(79838), ChunkPrefetchTriggerRuntimeModule = __webpack_require__(94250), ChunkPreloadTriggerRuntimeModule = __webpack_require__(8778);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("ChunkPrefetchPreloadPlugin", (compilation => {
compilation.hooks.additionalChunkRuntimeRequirements.tap("ChunkPrefetchPreloadPlugin", ((chunk, set, {chunkGraph}) => {
if (0 === chunkGraph.getNumberOfEntryModules(chunk)) return;
const startupChildChunks = chunk.getChildrenOfTypeInOrder(chunkGraph, "prefetchOrder");
startupChildChunks && (set.add(RuntimeGlobals.prefetchChunk), set.add(RuntimeGlobals.onChunksLoaded), 
compilation.addRuntimeModule(chunk, new ChunkPrefetchStartupRuntimeModule(startupChildChunks)));
})), compilation.hooks.additionalTreeRuntimeRequirements.tap("ChunkPrefetchPreloadPlugin", ((chunk, set, {chunkGraph}) => {
const chunkMap = chunk.getChildIdsByOrdersMap(chunkGraph, !1);
chunkMap.prefetch && (set.add(RuntimeGlobals.prefetchChunk), compilation.addRuntimeModule(chunk, new ChunkPrefetchTriggerRuntimeModule(chunkMap.prefetch))), 
chunkMap.preload && (set.add(RuntimeGlobals.preloadChunk), compilation.addRuntimeModule(chunk, new ChunkPreloadTriggerRuntimeModule(chunkMap.preload)));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.prefetchChunk).tap("ChunkPrefetchPreloadPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new ChunkPrefetchFunctionRuntimeModule("prefetch", RuntimeGlobals.prefetchChunk, RuntimeGlobals.prefetchChunkHandlers)), 
set.add(RuntimeGlobals.prefetchChunkHandlers);
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.preloadChunk).tap("ChunkPrefetchPreloadPlugin", ((chunk, set) => {
compilation.addRuntimeModule(chunk, new ChunkPrefetchFunctionRuntimeModule("preload", RuntimeGlobals.preloadChunk, RuntimeGlobals.preloadChunkHandlers)), 
set.add(RuntimeGlobals.preloadChunkHandlers);
}));
}));
}
};
},
79838: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(startupChunks) {
super("startup prefetch", RuntimeModule.STAGE_TRIGGER), this.startupChunks = startupChunks;
}
generate() {
const {startupChunks, chunk} = this, {runtimeTemplate} = this.compilation;
return Template.asString(startupChunks.map((({onChunks, chunks}) => `${RuntimeGlobals.onChunksLoaded}(0, ${JSON.stringify(onChunks.filter((c => c === chunk)).map((c => c.id)))}, ${runtimeTemplate.basicFunction("", chunks.size < 3 ? Array.from(chunks, (c => `${RuntimeGlobals.prefetchChunk}(${JSON.stringify(c.id)});`)) : `${JSON.stringify(Array.from(chunks, (c => c.id)))}.map(${RuntimeGlobals.prefetchChunk});`)}, 5);`)));
}
};
},
94250: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(chunkMap) {
super("chunk prefetch trigger", RuntimeModule.STAGE_TRIGGER), this.chunkMap = chunkMap;
}
generate() {
const {chunkMap} = this, {runtimeTemplate} = this.compilation, body = [ "var chunks = chunkToChildrenMap[chunkId];", `Array.isArray(chunks) && chunks.map(${RuntimeGlobals.prefetchChunk});` ];
return Template.asString([ Template.asString([ `var chunkToChildrenMap = ${JSON.stringify(chunkMap, null, "\t")};`, `${RuntimeGlobals.ensureChunkHandlers}.prefetch = ${runtimeTemplate.expressionFunction(`Promise.all(promises).then(${runtimeTemplate.basicFunction("", body)})`, "chunkId, promises")};` ]) ]);
}
};
},
8778: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(chunkMap) {
super("chunk preload trigger", RuntimeModule.STAGE_TRIGGER), this.chunkMap = chunkMap;
}
generate() {
const {chunkMap} = this, {runtimeTemplate} = this.compilation, body = [ "var chunks = chunkToChildrenMap[chunkId];", `Array.isArray(chunks) && chunks.map(${RuntimeGlobals.preloadChunk});` ];
return Template.asString([ Template.asString([ `var chunkToChildrenMap = ${JSON.stringify(chunkMap, null, "\t")};`, `${RuntimeGlobals.ensureChunkHandlers}.preload = ${runtimeTemplate.basicFunction("chunkId", body)};` ]) ]);
}
};
},
94743: module => {
"use strict";
module.exports = class {
constructor(ruleProperty, effectType) {
this.ruleProperty = ruleProperty, this.effectType = effectType || ruleProperty;
}
apply(ruleSetCompiler) {
ruleSetCompiler.hooks.rule.tap("BasicEffectRulePlugin", ((path, rule, unhandledProperties, result, references) => {
if (unhandledProperties.has(this.ruleProperty)) {
unhandledProperties.delete(this.ruleProperty);
const value = rule[this.ruleProperty];
result.effects.push({
type: this.effectType,
value
});
}
}));
}
};
},
30581: module => {
"use strict";
module.exports = class {
constructor(ruleProperty, dataProperty, invert) {
this.ruleProperty = ruleProperty, this.dataProperty = dataProperty || ruleProperty, 
this.invert = invert || !1;
}
apply(ruleSetCompiler) {
ruleSetCompiler.hooks.rule.tap("BasicMatcherRulePlugin", ((path, rule, unhandledProperties, result) => {
if (unhandledProperties.has(this.ruleProperty)) {
unhandledProperties.delete(this.ruleProperty);
const value = rule[this.ruleProperty], condition = ruleSetCompiler.compileCondition(`${path}.${this.ruleProperty}`, value), fn = condition.fn;
result.conditions.push({
property: this.dataProperty,
matchWhenEmpty: this.invert ? !condition.matchWhenEmpty : condition.matchWhenEmpty,
fn: this.invert ? v => !fn(v) : fn
});
}
}));
}
};
},
75540: module => {
"use strict";
module.exports = class {
constructor(ruleProperty, dataProperty) {
this.ruleProperty = ruleProperty, this.dataProperty = dataProperty || ruleProperty;
}
apply(ruleSetCompiler) {
const {ruleProperty, dataProperty} = this;
ruleSetCompiler.hooks.rule.tap("ObjectMatcherRulePlugin", ((path, rule, unhandledProperties, result) => {
if (unhandledProperties.has(ruleProperty)) {
unhandledProperties.delete(ruleProperty);
const value = rule[ruleProperty];
for (const property of Object.keys(value)) {
const nestedDataProperties = property.split("."), condition = ruleSetCompiler.compileCondition(`${path}.${ruleProperty}.${property}`, value[property]);
result.conditions.push({
property: [ dataProperty, ...nestedDataProperties ],
matchWhenEmpty: condition.matchWhenEmpty,
fn: condition.fn
});
}
}
}));
}
};
},
42530: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncHook} = __webpack_require__(89991);
module.exports = class {
constructor(plugins) {
if (this.hooks = Object.freeze({
rule: new SyncHook([ "path", "rule", "unhandledProperties", "compiledRule", "references" ])
}), plugins) for (const plugin of plugins) plugin.apply(this);
}
compile(ruleSet) {
const refs = new Map, rules = this.compileRules("ruleSet", ruleSet, refs), execRule = (data, rule, effects) => {
for (const condition of rule.conditions) {
const p = condition.property;
if (Array.isArray(p)) {
let current = data;
for (const subProperty of p) {
if (!current || "object" != typeof current || !Object.prototype.hasOwnProperty.call(current, subProperty)) {
current = void 0;
break;
}
current = current[subProperty];
}
if (void 0 !== current) {
if (!condition.fn(current)) return !1;
continue;
}
} else if (p in data) {
const value = data[p];
if (void 0 !== value) {
if (!condition.fn(value)) return !1;
continue;
}
}
if (!condition.matchWhenEmpty) return !1;
}
for (const effect of rule.effects) if ("function" == typeof effect) {
const returnedEffects = effect(data);
for (const effect of returnedEffects) effects.push(effect);
} else effects.push(effect);
if (rule.rules) for (const childRule of rule.rules) execRule(data, childRule, effects);
if (rule.oneOf) for (const childRule of rule.oneOf) if (execRule(data, childRule, effects)) break;
return !0;
};
return {
references: refs,
exec: data => {
const effects = [];
for (const rule of rules) execRule(data, rule, effects);
return effects;
}
};
}
compileRules(path, rules, refs) {
return rules.map(((rule, i) => this.compileRule(`${path}[${i}]`, rule, refs)));
}
compileRule(path, rule, refs) {
const unhandledProperties = new Set(Object.keys(rule).filter((key => void 0 !== rule[key]))), compiledRule = {
conditions: [],
effects: [],
rules: void 0,
oneOf: void 0
};
if (this.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs), unhandledProperties.has("rules")) {
unhandledProperties.delete("rules");
const rules = rule.rules;
if (!Array.isArray(rules)) throw this.error(path, rules, "Rule.rules must be an array of rules");
compiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);
}
if (unhandledProperties.has("oneOf")) {
unhandledProperties.delete("oneOf");
const oneOf = rule.oneOf;
if (!Array.isArray(oneOf)) throw this.error(path, oneOf, "Rule.oneOf must be an array of rules");
compiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);
}
if (unhandledProperties.size > 0) throw this.error(path, rule, `Properties ${Array.from(unhandledProperties).join(", ")} are unknown`);
return compiledRule;
}
compileCondition(path, condition) {
if ("" === condition) return {
matchWhenEmpty: !0,
fn: str => "" === str
};
if (!condition) throw this.error(path, condition, "Expected condition but got falsy value");
if ("string" == typeof condition) return {
matchWhenEmpty: 0 === condition.length,
fn: str => "string" == typeof str && str.startsWith(condition)
};
if ("function" == typeof condition) try {
return {
matchWhenEmpty: condition(""),
fn: condition
};
} catch (err) {
throw this.error(path, condition, "Evaluation of condition function threw error");
}
if (condition instanceof RegExp) return {
matchWhenEmpty: condition.test(""),
fn: v => "string" == typeof v && condition.test(v)
};
if (Array.isArray(condition)) {
const items = condition.map(((c, i) => this.compileCondition(`${path}[${i}]`, c)));
return this.combineConditionsOr(items);
}
if ("object" != typeof condition) throw this.error(path, condition, `Unexpected ${typeof condition} when condition was expected`);
const conditions = [];
for (const key of Object.keys(condition)) {
const value = condition[key];
switch (key) {
case "or":
if (value) {
if (!Array.isArray(value)) throw this.error(`${path}.or`, condition.and, "Expected array of conditions");
conditions.push(this.compileCondition(`${path}.or`, value));
}
break;

case "and":
if (value) {
if (!Array.isArray(value)) throw this.error(`${path}.and`, condition.and, "Expected array of conditions");
let i = 0;
for (const item of value) conditions.push(this.compileCondition(`${path}.and[${i}]`, item)), 
i++;
}
break;

case "not":
if (value) {
const matcher = this.compileCondition(`${path}.not`, value), fn = matcher.fn;
conditions.push({
matchWhenEmpty: !matcher.matchWhenEmpty,
fn: v => !fn(v)
});
}
break;

default:
throw this.error(`${path}.${key}`, condition[key], `Unexpected property ${key} in condition`);
}
}
if (0 === conditions.length) throw this.error(path, condition, "Expected condition, but got empty thing");
return this.combineConditionsAnd(conditions);
}
combineConditionsOr(conditions) {
return 0 === conditions.length ? {
matchWhenEmpty: !1,
fn: () => !1
} : 1 === conditions.length ? conditions[0] : {
matchWhenEmpty: conditions.some((c => c.matchWhenEmpty)),
fn: v => conditions.some((c => c.fn(v)))
};
}
combineConditionsAnd(conditions) {
return 0 === conditions.length ? {
matchWhenEmpty: !1,
fn: () => !1
} : 1 === conditions.length ? conditions[0] : {
matchWhenEmpty: conditions.every((c => c.matchWhenEmpty)),
fn: v => conditions.every((c => c.fn(v)))
};
}
error(path, value, message) {
return new Error(`Compiling RuleSet failed: ${message} (at ${path}: ${value})`);
}
};
},
51942: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837);
module.exports = class {
apply(ruleSetCompiler) {
ruleSetCompiler.hooks.rule.tap("UseEffectRulePlugin", ((path, rule, unhandledProperties, result, references) => {
const conflictWith = (property, correctProperty) => {
if (unhandledProperties.has(property)) throw ruleSetCompiler.error(`${path}.${property}`, rule[property], `A Rule must not have a '${property}' property when it has a '${correctProperty}' property`);
};
if (unhandledProperties.has("use")) {
unhandledProperties.delete("use"), unhandledProperties.delete("enforce"), conflictWith("loader", "use"), 
conflictWith("options", "use");
const use = rule.use, enforce = rule.enforce, type = enforce ? `use-${enforce}` : "use", useToEffect = (path, defaultIdent, item) => "function" == typeof item ? data => useToEffectsWithoutIdent(path, item(data)) : useToEffectRaw(path, defaultIdent, item), useToEffectRaw = (path, defaultIdent, item) => {
if ("string" == typeof item) return {
type,
value: {
loader: item,
options: void 0,
ident: void 0
}
};
{
const loader = item.loader, options = item.options;
let ident = item.ident;
return options && "object" == typeof options && (ident || (ident = defaultIdent), 
references.set(ident, options)), "string" == typeof options && util.deprecate((() => {}), `Using a string as loader options is deprecated (${path}.options)`, "DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING")(), 
{
type: enforce ? `use-${enforce}` : "use",
value: {
loader,
options,
ident
}
};
}
}, useToEffectsWithoutIdent = (path, items) => Array.isArray(items) ? items.map(((item, idx) => useToEffectRaw(`${path}[${idx}]`, "[[missing ident]]", item))) : [ useToEffectRaw(path, "[[missing ident]]", items) ], useToEffects = (path, items) => Array.isArray(items) ? items.map(((item, idx) => {
const subPath = `${path}[${idx}]`;
return useToEffect(subPath, subPath, item);
})) : [ useToEffect(path, path, items) ];
if ("function" == typeof use) result.effects.push((data => useToEffectsWithoutIdent(`${path}.use`, use(data)))); else for (const effect of useToEffects(`${path}.use`, use)) result.effects.push(effect);
}
if (unhandledProperties.has("loader")) {
unhandledProperties.delete("loader"), unhandledProperties.delete("options"), unhandledProperties.delete("enforce");
const loader = rule.loader, options = rule.options, enforce = rule.enforce;
if (loader.includes("!")) throw ruleSetCompiler.error(`${path}.loader`, loader, "Exclamation mark separated loader lists has been removed in favor of the 'use' property with arrays");
if (loader.includes("?")) throw ruleSetCompiler.error(`${path}.loader`, loader, "Query arguments on 'loader' has been removed in favor of the 'options' property");
"string" == typeof options && util.deprecate((() => {}), `Using a string as loader options is deprecated (${path}.options)`, "DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING")();
const ident = options && "object" == typeof options ? path : void 0;
references.set(ident, options), result.effects.push({
type: enforce ? `use-${enforce}` : "use",
value: {
loader,
options,
ident
}
});
}
}));
}
useItemToEffects(path, item) {}
};
},
71740: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("async module");
}
generate() {
const {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.asyncModule;
return Template.asString([ 'var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";', 'var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";', 'var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";', `var resolveQueue = ${runtimeTemplate.basicFunction("queue", [ "if(queue && !queue.d) {", Template.indent([ "queue.d = 1;", `queue.forEach(${runtimeTemplate.expressionFunction("fn.r--", "fn")});`, `queue.forEach(${runtimeTemplate.expressionFunction("fn.r-- ? fn.r++ : fn()", "fn")});` ]), "}" ])}`, `var wrapDeps = ${runtimeTemplate.returningFunction(`deps.map(${runtimeTemplate.basicFunction("dep", [ 'if(dep !== null && typeof dep === "object") {', Template.indent([ "if(dep[webpackQueues]) return dep;", "if(dep.then) {", Template.indent([ "var queue = [];", "queue.d = 0;", `dep.then(${runtimeTemplate.basicFunction("r", [ "obj[webpackExports] = r;", "resolveQueue(queue);" ])}, ${runtimeTemplate.basicFunction("e", [ "obj[webpackError] = e;", "resolveQueue(queue);" ])});`, "var obj = {};", `obj[webpackQueues] = ${runtimeTemplate.expressionFunction("fn(queue)", "fn")};`, "return obj;" ]), "}" ]), "}", "var ret = {};", `ret[webpackQueues] = ${runtimeTemplate.emptyFunction()};`, "ret[webpackExports] = dep;", "return ret;" ])})`, "deps")};`, `${fn} = ${runtimeTemplate.basicFunction("module, body, hasAwait", [ "var queue;", "hasAwait && ((queue = []).d = 1);", "var depQueues = new Set();", "var exports = module.exports;", "var currentDeps;", "var outerResolve;", "var reject;", `var promise = new Promise(${runtimeTemplate.basicFunction("resolve, rej", [ "reject = rej;", "outerResolve = resolve;" ])});`, "promise[webpackExports] = exports;", `promise[webpackQueues] = ${runtimeTemplate.expressionFunction(`queue && fn(queue), depQueues.forEach(fn), promise["catch"](${runtimeTemplate.emptyFunction()})`, "fn")};`, "module.exports = promise;", `body(${runtimeTemplate.basicFunction("deps", [ "currentDeps = wrapDeps(deps);", "var fn;", `var getResult = ${runtimeTemplate.returningFunction(`currentDeps.map(${runtimeTemplate.basicFunction("d", [ "if(d[webpackError]) throw d[webpackError];", "return d[webpackExports];" ])})`)}`, `var promise = new Promise(${runtimeTemplate.basicFunction("resolve", [ `fn = ${runtimeTemplate.expressionFunction("resolve(getResult)", "")};`, "fn.r = 0;", `var fnQueue = ${runtimeTemplate.expressionFunction("q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn)))", "q")};`, `currentDeps.map(${runtimeTemplate.expressionFunction("dep[webpackQueues](fnQueue)", "dep")});` ])});`, "return fn.r ? promise : getResult();" ])}, ${runtimeTemplate.expressionFunction("(err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)", "err")});`, "queue && (queue.d = 0);" ])};` ]);
}
};
},
16343: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), JavascriptModulesPlugin = __webpack_require__(18362), {getUndoPath} = __webpack_require__(63264);
module.exports = class extends RuntimeModule {
constructor() {
super("publicPath", RuntimeModule.STAGE_BASIC);
}
generate() {
const {compilation} = this, {scriptType, importMetaName, path} = compilation.outputOptions, chunkName = compilation.getPath(JavascriptModulesPlugin.getChunkFilenameTemplate(this.chunk, compilation.outputOptions), {
chunk: this.chunk,
contentHashType: "javascript"
}), undoPath = getUndoPath(chunkName, path, !1);
return Template.asString([ "var scriptUrl;", "module" === scriptType ? `if (typeof ${importMetaName}.url === "string") scriptUrl = ${importMetaName}.url` : Template.asString([ `if (${RuntimeGlobals.global}.importScripts) scriptUrl = ${RuntimeGlobals.global}.location + "";`, `var document = ${RuntimeGlobals.global}.document;`, "if (!scriptUrl && document) {", Template.indent([ "if (document.currentScript)", Template.indent("scriptUrl = document.currentScript.src"), "if (!scriptUrl) {", Template.indent([ 'var scripts = document.getElementsByTagName("script");', "if(scripts.length) scriptUrl = scripts[scripts.length - 1].src" ]), "}" ]), "}" ]), "// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration", '// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.', 'if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");', 'scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\\?.*$/, "").replace(/\\/[^\\/]+$/, "/");', undoPath ? `${RuntimeGlobals.publicPath} = scriptUrl + ${JSON.stringify(undoPath)};` : `${RuntimeGlobals.publicPath} = scriptUrl;` ]);
}
};
},
6598: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("base uri", RuntimeModule.STAGE_ATTACH);
}
generate() {
const {chunk} = this, options = chunk.getEntryOptions();
return `${RuntimeGlobals.baseURI} = ${void 0 === options.baseUri ? "undefined" : JSON.stringify(options.baseUri)};`;
}
};
},
74460: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor(chunkName) {
super("chunkName"), this.chunkName = chunkName;
}
generate() {
return `${RuntimeGlobals.chunkName} = ${JSON.stringify(this.chunkName)};`;
}
};
},
60950: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("compat get default export");
}
generate() {
const {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.compatGetDefaultExport;
return Template.asString([ "// getDefaultExport function for compatibility with non-harmony modules", `${fn} = ${runtimeTemplate.basicFunction("module", [ "var getter = module && module.__esModule ?", Template.indent([ `${runtimeTemplate.returningFunction("module['default']")} :`, `${runtimeTemplate.returningFunction("module")};` ]), `${RuntimeGlobals.definePropertyGetters}(getter, { a: getter });`, "return getter;" ])};` ]);
}
};
},
59909: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("compat", RuntimeModule.STAGE_ATTACH), this.fullHash = !0;
}
generate() {
const {chunkGraph, chunk, compilation} = this, {runtimeTemplate, mainTemplate, moduleTemplates, dependencyTemplates} = compilation, bootstrap = mainTemplate.hooks.bootstrap.call("", chunk, compilation.hash || "XXXX", moduleTemplates.javascript, dependencyTemplates), localVars = mainTemplate.hooks.localVars.call("", chunk, compilation.hash || "XXXX"), requireExtensions = mainTemplate.hooks.requireExtensions.call("", chunk, compilation.hash || "XXXX");
let requireEnsure = "";
if (chunkGraph.getTreeRuntimeRequirements(chunk).has(RuntimeGlobals.ensureChunk)) {
const requireEnsureHandler = mainTemplate.hooks.requireEnsure.call("", chunk, compilation.hash || "XXXX", "chunkId");
requireEnsureHandler && (requireEnsure = `${RuntimeGlobals.ensureChunkHandlers}.compat = ${runtimeTemplate.basicFunction("chunkId, promises", requireEnsureHandler)};`);
}
return [ bootstrap, localVars, requireEnsure, requireExtensions ].filter(Boolean).join("\n");
}
shouldIsolate() {
return !1;
}
};
},
7947: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("create fake namespace object");
}
generate() {
const {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.createFakeNamespaceObject;
return Template.asString([ `var getProto = Object.getPrototypeOf ? ${runtimeTemplate.returningFunction("Object.getPrototypeOf(obj)", "obj")} : ${runtimeTemplate.returningFunction("obj.__proto__", "obj")};`, "var leafPrototypes;", "// create a fake namespace object", "// mode & 1: value is a module id, require it", "// mode & 2: merge all properties of value into the ns", "// mode & 4: return value when already ns object", "// mode & 16: return value when it's Promise-like", "// mode & 8|1: behave like require", `${fn} = function(value, mode) {`, Template.indent([ "if(mode & 1) value = this(value);", "if(mode & 8) return value;", "if(typeof value === 'object' && value) {", Template.indent([ "if((mode & 4) && value.__esModule) return value;", "if((mode & 16) && typeof value.then === 'function') return value;" ]), "}", "var ns = Object.create(null);", `${RuntimeGlobals.makeNamespaceObject}(ns);`, "var def = {};", "leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];", "for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {", Template.indent([ `Object.getOwnPropertyNames(current).forEach(${runtimeTemplate.expressionFunction(`def[key] = ${runtimeTemplate.returningFunction("value[key]", "")}`, "key")});` ]), "}", `def['default'] = ${runtimeTemplate.returningFunction("value", "")};`, `${RuntimeGlobals.definePropertyGetters}(ns, def);`, "return ns;" ]), "};" ]);
}
};
},
64035: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("trusted types script");
}
generate() {
const {compilation} = this, {runtimeTemplate, outputOptions} = compilation, {trustedTypes} = outputOptions, fn = RuntimeGlobals.createScript;
return Template.asString(`${fn} = ${runtimeTemplate.returningFunction(trustedTypes ? `${RuntimeGlobals.getTrustedTypesPolicy}().createScript(script)` : "script", "script")};`);
}
};
},
61946: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("trusted types script url");
}
generate() {
const {compilation} = this, {runtimeTemplate, outputOptions} = compilation, {trustedTypes} = outputOptions, fn = RuntimeGlobals.createScriptUrl;
return Template.asString(`${fn} = ${runtimeTemplate.returningFunction(trustedTypes ? `${RuntimeGlobals.getTrustedTypesPolicy}().createScriptURL(url)` : "url", "url")};`);
}
};
},
41616: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("define property getters");
}
generate() {
const {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.definePropertyGetters;
return Template.asString([ "// define getter functions for harmony exports", `${fn} = ${runtimeTemplate.basicFunction("exports, definition", [ "for(var key in definition) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(definition, key) && !${RuntimeGlobals.hasOwnProperty}(exports, key)) {`, Template.indent([ "Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });" ]), "}" ]), "}" ])};` ]);
}
};
},
50427: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(runtimeRequirements) {
super("ensure chunk"), this.runtimeRequirements = runtimeRequirements;
}
generate() {
const {runtimeTemplate} = this.compilation;
if (this.runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers)) {
const handlers = RuntimeGlobals.ensureChunkHandlers;
return Template.asString([ `${handlers} = {};`, "// This file contains only the entry chunk.", "// The chunk loading function for additional chunks", `${RuntimeGlobals.ensureChunk} = ${runtimeTemplate.basicFunction("chunkId", [ `return Promise.all(Object.keys(${handlers}).reduce(${runtimeTemplate.basicFunction("promises, key", [ `${handlers}[key](chunkId, promises);`, "return promises;" ])}, []));` ])};` ]);
}
return Template.asString([ "// The chunk loading function for additional chunks", "// Since all referenced chunks are already included", "// in this file, this function is empty here.", `${RuntimeGlobals.ensureChunk} = ${runtimeTemplate.returningFunction("Promise.resolve()")};` ]);
}
};
},
34429: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {first} = __webpack_require__(73974);
module.exports = class extends RuntimeModule {
constructor(contentType, name, global, getFilenameForChunk, allChunks) {
super(`get ${name} chunk filename`), this.contentType = contentType, this.global = global, 
this.getFilenameForChunk = getFilenameForChunk, this.allChunks = allChunks, this.dependentHash = !0;
}
generate() {
const {global, chunk, chunkGraph, contentType, getFilenameForChunk, allChunks, compilation} = this, {runtimeTemplate} = compilation, chunkFilenames = new Map;
let dynamicFilename, maxChunks = 0;
const addChunk = c => {
const chunkFilename = getFilenameForChunk(c);
if (chunkFilename) {
let set = chunkFilenames.get(chunkFilename);
if (void 0 === set && chunkFilenames.set(chunkFilename, set = new Set), set.add(c), 
"string" == typeof chunkFilename) {
if (set.size < maxChunks) return;
if (set.size === maxChunks) {
if (chunkFilename.length < dynamicFilename.length) return;
if (chunkFilename.length === dynamicFilename.length && chunkFilename < dynamicFilename) return;
}
maxChunks = set.size, dynamicFilename = chunkFilename;
}
}
}, includedChunksMessages = [];
if (allChunks) {
includedChunksMessages.push("all chunks");
for (const c of chunk.getAllReferencedChunks()) addChunk(c);
} else {
includedChunksMessages.push("async chunks");
for (const c of chunk.getAllAsyncChunks()) addChunk(c);
if (chunkGraph.getTreeRuntimeRequirements(chunk).has(RuntimeGlobals.ensureChunkIncludeEntries)) {
includedChunksMessages.push("sibling chunks for the entrypoint");
for (const c of chunkGraph.getChunkEntryDependentChunksIterable(chunk)) addChunk(c);
}
}
for (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) addChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);
const staticUrls = new Map, dynamicUrlChunks = new Set, addStaticUrl = (c, chunkFilename) => {
const unquotedStringify = value => {
const str = `${value}`;
if (str.length >= 5 && str === `${c.id}`) return '" + chunkId + "';
const s = JSON.stringify(str);
return s.slice(1, s.length - 1);
}, unquotedStringifyWithLength = value => length => unquotedStringify(`${value}`.slice(0, length)), chunkFilenameValue = "function" == typeof chunkFilename ? JSON.stringify(chunkFilename({
chunk: c,
contentHashType: contentType
})) : JSON.stringify(chunkFilename), staticChunkFilename = compilation.getPath(chunkFilenameValue, {
hash: `" + ${RuntimeGlobals.getFullHash}() + "`,
hashWithLength: length => `" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + "`,
chunk: {
id: unquotedStringify(c.id),
hash: unquotedStringify(c.renderedHash),
hashWithLength: unquotedStringifyWithLength(c.renderedHash),
name: unquotedStringify(c.name || c.id),
contentHash: {
[contentType]: unquotedStringify(c.contentHash[contentType])
},
contentHashWithLength: {
[contentType]: unquotedStringifyWithLength(c.contentHash[contentType])
}
},
contentHashType: contentType
});
let set = staticUrls.get(staticChunkFilename);
void 0 === set && staticUrls.set(staticChunkFilename, set = new Set), set.add(c.id);
};
for (const [filename, chunks] of chunkFilenames) if (filename !== dynamicFilename) for (const c of chunks) addStaticUrl(c, filename); else for (const c of chunks) dynamicUrlChunks.add(c);
const createMap = fn => {
const obj = {};
let lastKey, useId = !1, entries = 0;
for (const c of dynamicUrlChunks) {
const value = fn(c);
value === c.id ? useId = !0 : (obj[c.id] = value, lastKey = c.id, entries++);
}
return 0 === entries ? "chunkId" : 1 === entries ? useId ? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(obj[lastKey])} : chunkId)` : JSON.stringify(obj[lastKey]) : useId ? `(${JSON.stringify(obj)}[chunkId] || chunkId)` : `${JSON.stringify(obj)}[chunkId]`;
}, mapExpr = fn => `" + ${createMap(fn)} + "`, mapExprWithLength = fn => length => `" + ${createMap((c => `${fn(c)}`.slice(0, length)))} + "`, url = dynamicFilename && compilation.getPath(JSON.stringify(dynamicFilename), {
hash: `" + ${RuntimeGlobals.getFullHash}() + "`,
hashWithLength: length => `" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + "`,
chunk: {
id: '" + chunkId + "',
hash: mapExpr((c => c.renderedHash)),
hashWithLength: mapExprWithLength((c => c.renderedHash)),
name: mapExpr((c => c.name || c.id)),
contentHash: {
[contentType]: mapExpr((c => c.contentHash[contentType]))
},
contentHashWithLength: {
[contentType]: mapExprWithLength((c => c.contentHash[contentType]))
}
},
contentHashType: contentType
});
return Template.asString([ `// This function allow to reference ${includedChunksMessages.join(" and ")}`, `${global} = ${runtimeTemplate.basicFunction("chunkId", staticUrls.size > 0 ? [ "// return url for filenames not based on template", Template.asString(Array.from(staticUrls, (([url, ids]) => `if (${1 === ids.size ? `chunkId === ${JSON.stringify(first(ids))}` : `{${Array.from(ids, (id => `${JSON.stringify(id)}:1`)).join(",")}}[chunkId]`}) return ${url};`))), "// return url for filenames based on template", `return ${url};` ] : [ "// return url for filenames based on template", `return ${url};` ])};` ]);
}
};
},
42491: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("getFullHash"), this.fullHash = !0;
}
generate() {
const {runtimeTemplate} = this.compilation;
return `${RuntimeGlobals.getFullHash} = ${runtimeTemplate.returningFunction(JSON.stringify(this.compilation.hash || "XXXX"))}`;
}
};
},
99191: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(name, global, filename) {
super(`get ${name} filename`), this.global = global, this.filename = filename;
}
generate() {
const {global, filename, compilation, chunk} = this, {runtimeTemplate} = compilation, url = compilation.getPath(JSON.stringify(filename), {
hash: `" + ${RuntimeGlobals.getFullHash}() + "`,
hashWithLength: length => `" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + "`,
chunk,
runtime: chunk.runtime
});
return Template.asString([ `${global} = ${runtimeTemplate.returningFunction(url)};` ]);
}
};
},
21578: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor(runtimeRequirements) {
super("trusted types policy"), this.runtimeRequirements = runtimeRequirements;
}
generate() {
const {compilation} = this, {runtimeTemplate, outputOptions} = compilation, {trustedTypes} = outputOptions, fn = RuntimeGlobals.getTrustedTypesPolicy;
return Template.asString([ "var policy;", `${fn} = ${runtimeTemplate.basicFunction("", [ "// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.", "if (policy === undefined) {", Template.indent([ "policy = {", Template.indent([ ...this.runtimeRequirements.has(RuntimeGlobals.createScript) ? [ `createScript: ${runtimeTemplate.returningFunction("script", "script")}` ] : [], ...this.runtimeRequirements.has(RuntimeGlobals.createScriptUrl) ? [ `createScriptURL: ${runtimeTemplate.returningFunction("url", "url")}` ] : [] ].join(",\n")), "};", ...trustedTypes ? [ 'if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {', Template.indent([ `policy = trustedTypes.createPolicy(${JSON.stringify(trustedTypes.policyName)}, policy);` ]), "}" ] : [] ]), "}", "return policy;" ])};` ]);
}
};
},
88206: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor() {
super("global");
}
generate() {
return Template.asString([ `${RuntimeGlobals.global} = (function() {`, Template.indent([ "if (typeof globalThis === 'object') return globalThis;", "try {", Template.indent("return this || new Function('return this')();"), "} catch (e) {", Template.indent("if (typeof window === 'object') return window;"), "}" ]), "})();" ]);
}
};
},
12271: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor() {
super("hasOwnProperty shorthand");
}
generate() {
const {runtimeTemplate} = this.compilation;
return Template.asString([ `${RuntimeGlobals.hasOwnProperty} = ${runtimeTemplate.returningFunction("Object.prototype.hasOwnProperty.call(obj, prop)", "obj, prop")}` ]);
}
};
},
23674: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor(name) {
super(name);
}
};
},
84914: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook} = __webpack_require__(89991), Compilation = __webpack_require__(62843), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674), compilationHooksMap = new WeakMap;
class LoadScriptRuntimeModule extends HelperRuntimeModule {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
createScript: new SyncWaterfallHook([ "source", "chunk" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(withCreateScriptUrl) {
super("load script"), this._withCreateScriptUrl = withCreateScriptUrl;
}
generate() {
const {compilation} = this, {runtimeTemplate, outputOptions} = compilation, {scriptType, chunkLoadTimeout: loadTimeout, crossOriginLoading, uniqueName, charset} = outputOptions, fn = RuntimeGlobals.loadScript, {createScript} = LoadScriptRuntimeModule.getCompilationHooks(compilation), code = Template.asString([ "script = document.createElement('script');", scriptType ? `script.type = ${JSON.stringify(scriptType)};` : "", charset ? "script.charset = 'utf-8';" : "", `script.timeout = ${loadTimeout / 1e3};`, `if (${RuntimeGlobals.scriptNonce}) {`, Template.indent(`script.setAttribute("nonce", ${RuntimeGlobals.scriptNonce});`), "}", uniqueName ? 'script.setAttribute("data-webpack", dataWebpackPrefix + key);' : "", `script.src = ${this._withCreateScriptUrl ? `${RuntimeGlobals.createScriptUrl}(url)` : "url"};`, crossOriginLoading ? "use-credentials" === crossOriginLoading ? 'script.crossOrigin = "use-credentials";' : Template.asString([ "if (script.src.indexOf(window.location.origin + '/') !== 0) {", Template.indent(`script.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), "}" ]) : "" ]);
return Template.asString([ "var inProgress = {};", uniqueName ? `var dataWebpackPrefix = ${JSON.stringify(uniqueName + ":")};` : "// data-webpack is not used as build has no uniqueName", "// loadScript function to load a script via script tag", `${fn} = ${runtimeTemplate.basicFunction("url, done, key, chunkId", [ "if(inProgress[url]) { inProgress[url].push(done); return; }", "var script, needAttach;", "if(key !== undefined) {", Template.indent([ 'var scripts = document.getElementsByTagName("script");', "for(var i = 0; i < scripts.length; i++) {", Template.indent([ "var s = scripts[i];", `if(s.getAttribute("src") == url${uniqueName ? ' || s.getAttribute("data-webpack") == dataWebpackPrefix + key' : ""}) { script = s; break; }` ]), "}" ]), "}", "if(!script) {", Template.indent([ "needAttach = true;", createScript.call(code, this.chunk) ]), "}", "inProgress[url] = [done];", "var onScriptComplete = " + runtimeTemplate.basicFunction("prev, event", Template.asString([ "// avoid mem leaks in IE.", "script.onerror = script.onload = null;", "clearTimeout(timeout);", "var doneFns = inProgress[url];", "delete inProgress[url];", "script.parentNode && script.parentNode.removeChild(script);", `doneFns && doneFns.forEach(${runtimeTemplate.returningFunction("fn(event)", "fn")});`, "if(prev) return prev(event);" ])), ";", `var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), ${loadTimeout});`, "script.onerror = onScriptComplete.bind(null, script.onerror);", "script.onload = onScriptComplete.bind(null, script.onload);", "needAttach && document.head.appendChild(script);" ])};` ]);
}
}
module.exports = LoadScriptRuntimeModule;
},
45796: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("make namespace object");
}
generate() {
const {runtimeTemplate} = this.compilation, fn = RuntimeGlobals.makeNamespaceObject;
return Template.asString([ "// define __esModule on exports", `${fn} = ${runtimeTemplate.basicFunction("exports", [ "if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {", Template.indent([ "Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });" ]), "}", "Object.defineProperty(exports, '__esModule', { value: true });" ])};` ]);
}
};
},
99719: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("nonce", RuntimeModule.STAGE_ATTACH);
}
generate() {
return `${RuntimeGlobals.scriptNonce} = undefined;`;
}
};
},
36892: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor() {
super("chunk loaded");
}
generate() {
const {compilation} = this, {runtimeTemplate} = compilation;
return Template.asString([ "var deferred = [];", `${RuntimeGlobals.onChunksLoaded} = ${runtimeTemplate.basicFunction("result, chunkIds, fn, priority", [ "if(chunkIds) {", Template.indent([ "priority = priority || 0;", "for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];", "deferred[i] = [chunkIds, fn, priority];", "return;" ]), "}", "var notFulfilled = Infinity;", "for (var i = 0; i < deferred.length; i++) {", Template.indent([ runtimeTemplate.destructureArray([ "chunkIds", "fn", "priority" ], "deferred[i]"), "var fulfilled = true;", "for (var j = 0; j < chunkIds.length; j++) {", Template.indent([ `if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(${RuntimeGlobals.onChunksLoaded}).every(${runtimeTemplate.returningFunction(`${RuntimeGlobals.onChunksLoaded}[key](chunkIds[j])`, "key")})) {`, Template.indent([ "chunkIds.splice(j--, 1);" ]), "} else {", Template.indent([ "fulfilled = false;", "if(priority < notFulfilled) notFulfilled = priority;" ]), "}" ]), "}", "if(fulfilled) {", Template.indent([ "deferred.splice(i--, 1)", "var r = fn();", "if (r !== undefined) result = r;" ]), "}" ]), "}", "return result;" ])};` ]);
}
};
},
18165: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor(publicPath) {
super("publicPath", RuntimeModule.STAGE_BASIC), this.publicPath = publicPath;
}
generate() {
const {compilation, publicPath} = this;
return `${RuntimeGlobals.publicPath} = ${JSON.stringify(compilation.getPath(publicPath || "", {
hash: compilation.hash || "XXXX"
}))};`;
}
};
},
1041: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), HelperRuntimeModule = __webpack_require__(23674);
module.exports = class extends HelperRuntimeModule {
constructor() {
super("relative url");
}
generate() {
const {runtimeTemplate} = this.compilation;
return Template.asString([ `${RuntimeGlobals.relativeUrl} = function RelativeURL(url) {`, Template.indent([ 'var realUrl = new URL(url, "x:/");', "var values = {};", "for (var key in realUrl) values[key] = realUrl[key];", "values.href = url;", 'values.pathname = url.replace(/[?#].*/, "");', 'values.origin = values.protocol = "";', `values.toString = values.toJSON = ${runtimeTemplate.returningFunction("url")};`, "for (var key in values) Object.defineProperty(this, key, { enumerable: true, configurable: true, value: values[key] });" ]), "};", `${RuntimeGlobals.relativeUrl}.prototype = URL.prototype;` ]);
}
};
},
38062: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("runtimeId");
}
generate() {
const {chunkGraph, chunk} = this, runtime = chunk.runtime;
if ("string" != typeof runtime) throw new Error("RuntimeIdRuntimeModule must be in a single runtime");
const id = chunkGraph.getRuntimeId(runtime);
return `${RuntimeGlobals.runtimeId} = ${JSON.stringify(id)};`;
}
};
},
40394: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), StartupChunkDependenciesRuntimeModule = __webpack_require__(74877), StartupEntrypointRuntimeModule = __webpack_require__(57910);
module.exports = class {
constructor(options) {
this.chunkLoading = options.chunkLoading, this.asyncChunkLoading = "boolean" != typeof options.asyncChunkLoading || options.asyncChunkLoading;
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("StartupChunkDependenciesPlugin", (compilation => {
const globalChunkLoading = compilation.outputOptions.chunkLoading, isEnabledForChunk = chunk => {
const options = chunk.getEntryOptions();
return (options && void 0 !== options.chunkLoading ? options.chunkLoading : globalChunkLoading) === this.chunkLoading;
};
compilation.hooks.additionalTreeRuntimeRequirements.tap("StartupChunkDependenciesPlugin", ((chunk, set, {chunkGraph}) => {
isEnabledForChunk(chunk) && chunkGraph.hasChunkEntryDependentChunks(chunk) && (set.add(RuntimeGlobals.startup), 
set.add(RuntimeGlobals.ensureChunk), set.add(RuntimeGlobals.ensureChunkIncludeEntries), 
compilation.addRuntimeModule(chunk, new StartupChunkDependenciesRuntimeModule(this.asyncChunkLoading)));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.startupEntrypoint).tap("StartupChunkDependenciesPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.require), set.add(RuntimeGlobals.ensureChunk), 
set.add(RuntimeGlobals.ensureChunkIncludeEntries), compilation.addRuntimeModule(chunk, new StartupEntrypointRuntimeModule(this.asyncChunkLoading)));
}));
}));
}
};
},
74877: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor(asyncChunkLoading) {
super("startup chunk dependencies", RuntimeModule.STAGE_TRIGGER), this.asyncChunkLoading = asyncChunkLoading;
}
generate() {
const {chunkGraph, chunk, compilation} = this, {runtimeTemplate} = compilation, chunkIds = Array.from(chunkGraph.getChunkEntryDependentChunksIterable(chunk)).map((chunk => chunk.id));
return Template.asString([ `var next = ${RuntimeGlobals.startup};`, `${RuntimeGlobals.startup} = ${runtimeTemplate.basicFunction("", this.asyncChunkLoading ? 1 === chunkIds.length ? `return ${RuntimeGlobals.ensureChunk}(${JSON.stringify(chunkIds[0])}).then(next);` : chunkIds.length > 2 ? [ `return Promise.all(${JSON.stringify(chunkIds)}.map(${RuntimeGlobals.ensureChunk}, __webpack_require__)).then(next);` ] : [ "return Promise.all([", Template.indent(chunkIds.map((id => `${RuntimeGlobals.ensureChunk}(${JSON.stringify(id)})`)).join(",\n")), "]).then(next);" ] : chunkIds.map((id => `${RuntimeGlobals.ensureChunk}(${JSON.stringify(id)});`)).concat("return next();"))};` ]);
}
};
},
57910: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor(asyncChunkLoading) {
super("startup entrypoint"), this.asyncChunkLoading = asyncChunkLoading;
}
generate() {
const {compilation} = this, {runtimeTemplate} = compilation;
return `${RuntimeGlobals.startupEntrypoint} = ${runtimeTemplate.basicFunction("result, chunkIds, fn", [ "// arguments: chunkIds, moduleId are deprecated", "var moduleId = chunkIds;", `if(!fn) chunkIds = result, fn = ${runtimeTemplate.returningFunction(`__webpack_require__(${RuntimeGlobals.entryModuleId} = moduleId)`)};`, ...this.asyncChunkLoading ? [ `return Promise.all(chunkIds.map(${RuntimeGlobals.ensureChunk}, __webpack_require__)).then(${runtimeTemplate.basicFunction("", [ "var r = fn();", "return r === undefined ? result : r;" ])})` ] : [ `chunkIds.map(${RuntimeGlobals.ensureChunk}, __webpack_require__)`, "var r = fn();", "return r === undefined ? result : r;" ] ])}`;
}
};
},
71138: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823);
module.exports = class extends RuntimeModule {
constructor() {
super("__system_context__");
}
generate() {
return `${RuntimeGlobals.systemContext} = __system_context__;`;
}
};
},
41643: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const NormalModule = __webpack_require__(3213), URIRegEx = /^data:([^;,]+)?((?:;[^;,]+)*?)(?:;(base64))?,(.*)$/i;
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("DataUriPlugin", ((compilation, {normalModuleFactory}) => {
normalModuleFactory.hooks.resolveForScheme.for("data").tap("DataUriPlugin", (resourceData => {
const match = URIRegEx.exec(resourceData.resource);
match && (resourceData.data.mimetype = match[1] || "", resourceData.data.parameters = match[2] || "", 
resourceData.data.encoding = match[3] || !1, resourceData.data.encodedContent = match[4] || "");
})), NormalModule.getCompilationHooks(compilation).readResourceForScheme.for("data").tap("DataUriPlugin", (resource => (uri => {
const match = URIRegEx.exec(uri);
if (!match) return null;
const isBase64 = match[3], body = match[4];
return isBase64 ? Buffer.from(body, "base64") : Buffer.from(decodeURIComponent(body), "ascii");
})(resource)));
}));
}
};
},
62399: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {URL, fileURLToPath} = __webpack_require__(57310), {NormalModule} = __webpack_require__(91459);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("FileUriPlugin", ((compilation, {normalModuleFactory}) => {
normalModuleFactory.hooks.resolveForScheme.for("file").tap("FileUriPlugin", (resourceData => {
const url = new URL(resourceData.resource), path = fileURLToPath(url), query = url.search, fragment = url.hash;
return resourceData.path = path, resourceData.query = query, resourceData.fragment = fragment, 
resourceData.resource = path + query + fragment, !0;
}));
NormalModule.getCompilationHooks(compilation).readResource.for(void 0).tapAsync("FileUriPlugin", ((loaderContext, callback) => {
const {resourcePath} = loaderContext;
loaderContext.addDependency(resourcePath), loaderContext.fs.readFile(resourcePath, callback);
}));
}));
}
};
},
9420: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const EventEmitter = __webpack_require__(82361), {extname, basename} = __webpack_require__(71017), {URL} = __webpack_require__(57310), {createGunzip, createBrotliDecompress, createInflate} = __webpack_require__(59796), NormalModule = __webpack_require__(3213), createSchemaValidation = __webpack_require__(59586), createHash = __webpack_require__(27466), {mkdirp, dirname, join} = __webpack_require__(57075), memoize = __webpack_require__(98216), getHttp = memoize((() => __webpack_require__(13685))), getHttps = memoize((() => __webpack_require__(95687))), proxyFetch = (request, proxy) => (url, options, callback) => {
const eventEmitter = new EventEmitter, doRequest = socket => request.get(url, {
...options,
...socket && {
socket
}
}, callback).on("error", eventEmitter.emit.bind(eventEmitter, "error"));
if (proxy) {
const {hostname: host, port} = new URL(proxy);
getHttp().request({
host,
port,
method: "CONNECT",
path: url.host
}).on("connect", ((res, socket) => {
200 === res.statusCode && doRequest(socket);
})).on("error", (err => {
eventEmitter.emit("error", new Error(`Failed to connect to proxy server "${proxy}": ${err.message}`));
})).end();
} else doRequest();
return eventEmitter;
};
let inProgressWrite;
const validate = createSchemaValidation(__webpack_require__(4485), (() => __webpack_require__(5404)), {
name: "Http Uri Plugin",
baseDataPath: "options"
}), toSafePath = str => str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, "").replace(/[^a-zA-Z0-9._-]+/g, "_"), computeIntegrity = content => {
const hash = createHash("sha512");
hash.update(content);
return "sha512-" + hash.digest("base64");
}, verifyIntegrity = (content, integrity) => "ignore" === integrity || computeIntegrity(content) === integrity, parseCacheControl = (cacheControl, requestTime) => {
let storeCache = !0, storeLock = !0, validUntil = 0;
if (cacheControl) {
const parsed = (str => {
const result = {};
for (const item of str.split(",")) {
const i = item.indexOf("=");
if (i >= 0) {
const key = item.slice(0, i).trim(), value = item.slice(i + 1).trim();
result[key] = value;
} else {
const key = item.trim();
if (!key) continue;
result[key] = key;
}
}
return result;
})(cacheControl);
parsed["no-cache"] && (storeCache = storeLock = !1), parsed["max-age"] && !isNaN(+parsed["max-age"]) && (validUntil = requestTime + 1e3 * +parsed["max-age"]), 
parsed["must-revalidate"] && (validUntil = 0);
}
return {
storeLock,
storeCache,
validUntil
};
}, entryToString = entry => `resolved: ${entry.resolved}, integrity: ${entry.integrity}, contentType: ${entry.contentType}`;
class Lockfile {
constructor() {
this.version = 1, this.entries = new Map;
}
static parse(content) {
const data = JSON.parse(content);
if (1 !== data.version) throw new Error(`Unsupported lockfile version ${data.version}`);
const lockfile = new Lockfile;
for (const key of Object.keys(data)) {
if ("version" === key) continue;
const entry = data[key];
lockfile.entries.set(key, "string" == typeof entry ? entry : {
resolved: key,
...entry
});
}
return lockfile;
}
toString() {
let str = "{\n";
const entries = Array.from(this.entries).sort((([a], [b]) => a < b ? -1 : 1));
for (const [key, entry] of entries) "string" == typeof entry ? str += `  ${JSON.stringify(key)}: ${JSON.stringify(entry)},\n` : (str += `  ${JSON.stringify(key)}: { `, 
entry.resolved !== key && (str += `"resolved": ${JSON.stringify(entry.resolved)}, `), 
str += `"integrity": ${JSON.stringify(entry.integrity)}, "contentType": ${JSON.stringify(entry.contentType)} },\n`);
return str += `  "version": ${this.version}\n}\n`, str;
}
}
const cachedWithKey = (fn, forceFn = fn) => {
const cache = new Map, resultFn = (arg, callback) => {
const cacheEntry = cache.get(arg);
if (void 0 !== cacheEntry) return void 0 !== cacheEntry.result ? callback(null, cacheEntry.result) : void 0 !== cacheEntry.error ? callback(cacheEntry.error) : void (void 0 === cacheEntry.callbacks ? cacheEntry.callbacks = [ callback ] : cacheEntry.callbacks.push(callback));
const newCacheEntry = {
result: void 0,
error: void 0,
callbacks: void 0
};
cache.set(arg, newCacheEntry), fn(arg, ((err, result) => {
err ? newCacheEntry.error = err : newCacheEntry.result = result;
const callbacks = newCacheEntry.callbacks;
if (newCacheEntry.callbacks = void 0, callback(err, result), void 0 !== callbacks) for (const cb of callbacks) cb(err, result);
}));
};
return resultFn.force = (arg, callback) => {
const cacheEntry = cache.get(arg);
if (void 0 !== cacheEntry && cacheEntry.force) return void 0 !== cacheEntry.result ? callback(null, cacheEntry.result) : void 0 !== cacheEntry.error ? callback(cacheEntry.error) : void (void 0 === cacheEntry.callbacks ? cacheEntry.callbacks = [ callback ] : cacheEntry.callbacks.push(callback));
const newCacheEntry = {
result: void 0,
error: void 0,
callbacks: void 0,
force: !0
};
cache.set(arg, newCacheEntry), forceFn(arg, ((err, result) => {
err ? newCacheEntry.error = err : newCacheEntry.result = result;
const callbacks = newCacheEntry.callbacks;
if (newCacheEntry.callbacks = void 0, callback(err, result), void 0 !== callbacks) for (const cb of callbacks) cb(err, result);
}));
}, resultFn;
};
module.exports = class {
constructor(options) {
validate(options), this._lockfileLocation = options.lockfileLocation, this._cacheLocation = options.cacheLocation, 
this._upgrade = options.upgrade, this._frozen = options.frozen, this._allowedUris = options.allowedUris, 
this._proxy = options.proxy;
}
apply(compiler) {
const proxy = this._proxy || process.env.http_proxy || process.env.HTTP_PROXY, schemes = [ {
scheme: "http",
fetch: proxyFetch(getHttp(), proxy)
}, {
scheme: "https",
fetch: proxyFetch(getHttps(), proxy)
} ];
let lockfileCache;
compiler.hooks.compilation.tap("HttpUriPlugin", ((compilation, {normalModuleFactory}) => {
const intermediateFs = compiler.intermediateFileSystem, fs = compilation.inputFileSystem, cache = compilation.getCache("webpack.HttpUriPlugin"), logger = compilation.getLogger("webpack.HttpUriPlugin"), lockfileLocation = this._lockfileLocation || join(intermediateFs, compiler.context, compiler.name ? `${toSafePath(compiler.name)}.webpack.lock` : "webpack.lock"), cacheLocation = void 0 !== this._cacheLocation ? this._cacheLocation : lockfileLocation + ".data", upgrade = this._upgrade || !1, frozen = this._frozen || !1, allowedUris = this._allowedUris;
let warnedAboutEol = !1;
const cacheKeyCache = new Map, getCacheKey = url => {
const cachedResult = cacheKeyCache.get(url);
if (void 0 !== cachedResult) return cachedResult;
const result = _getCacheKey(url);
return cacheKeyCache.set(url, result), result;
}, _getCacheKey = url => {
const parsedUrl = new URL(url), folder = toSafePath(parsedUrl.origin), name = toSafePath(parsedUrl.pathname), query = toSafePath(parsedUrl.search);
let ext = extname(name);
ext.length > 20 && (ext = "");
const basename = ext ? name.slice(0, -ext.length) : name, hash = createHash("sha512");
hash.update(url);
const digest = hash.digest("hex").slice(0, 20);
return `${folder.slice(-50)}/${`${basename}${query ? `_${query}` : ""}`.slice(0, 150)}_${digest}${ext}`;
}, getLockfile = (fn => {
let cachedError, cachedResult, cachedCallbacks, inFlight = !1;
return callback => {
if (inFlight) return void 0 !== cachedResult ? callback(null, cachedResult) : void 0 !== cachedError ? callback(cachedError) : void (void 0 === cachedCallbacks ? cachedCallbacks = [ callback ] : cachedCallbacks.push(callback));
inFlight = !0, fn(((err, result) => {
err ? cachedError = err : cachedResult = result;
const callbacks = cachedCallbacks;
if (cachedCallbacks = void 0, callback(err, result), void 0 !== callbacks) for (const cb of callbacks) cb(err, result);
}));
};
})((callback => {
const readLockfile = () => {
intermediateFs.readFile(lockfileLocation, ((err, buffer) => {
if (err && "ENOENT" !== err.code) return compilation.missingDependencies.add(lockfileLocation), 
callback(err);
compilation.fileDependencies.add(lockfileLocation), compilation.fileSystemInfo.createSnapshot(compiler.fsStartTime, buffer ? [ lockfileLocation ] : [], [], buffer ? [] : [ lockfileLocation ], {
timestamp: !0
}, ((err, snapshot) => {
if (err) return callback(err);
const lockfile = buffer ? Lockfile.parse(buffer.toString("utf-8")) : new Lockfile;
lockfileCache = {
lockfile,
snapshot
}, callback(null, lockfile);
}));
}));
};
lockfileCache ? compilation.fileSystemInfo.checkSnapshotValid(lockfileCache.snapshot, ((err, valid) => err ? callback(err) : valid ? void callback(null, lockfileCache.lockfile) : readLockfile())) : readLockfile();
}));
let lockfileUpdates;
const storeLockEntry = (lockfile, url, entry) => {
const oldEntry = lockfile.entries.get(url);
void 0 === lockfileUpdates && (lockfileUpdates = new Map), lockfileUpdates.set(url, entry), 
lockfile.entries.set(url, entry), oldEntry ? "string" == typeof oldEntry ? "string" == typeof entry ? logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`) : logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`) : "string" == typeof entry ? logger.log(`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`) : oldEntry.resolved !== entry.resolved ? logger.log(`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`) : oldEntry.integrity !== entry.integrity ? logger.log(`${url} updated in lockfile: content changed`) : oldEntry.contentType !== entry.contentType ? logger.log(`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`) : logger.log(`${url} updated in lockfile`) : logger.log(`${url} added to lockfile`);
}, storeResult = (lockfile, url, result, callback) => {
if (result.storeLock) {
if (storeLockEntry(lockfile, url, result.entry), !cacheLocation || !result.content) return callback(null, result);
const key = getCacheKey(result.entry.resolved), filePath = join(intermediateFs, cacheLocation, key);
mkdirp(intermediateFs, dirname(intermediateFs, filePath), (err => {
if (err) return callback(err);
intermediateFs.writeFile(filePath, result.content, (err => {
if (err) return callback(err);
callback(null, result);
}));
}));
} else storeLockEntry(lockfile, url, "no-cache"), callback(null, result);
};
for (const {scheme, fetch} of schemes) {
const resolveContent = (url, integrity, callback) => {
const handleResult = (err, result) => err ? callback(err) : "location" in result ? resolveContent(result.location, integrity, ((err, innerResult) => {
if (err) return callback(err);
callback(null, {
entry: innerResult.entry,
content: innerResult.content,
storeLock: innerResult.storeLock && result.storeLock
});
})) : result.fresh || !integrity || result.entry.integrity === integrity || verifyIntegrity(result.content, integrity) ? callback(null, {
entry: result.entry,
content: result.content,
storeLock: result.storeLock
}) : fetchContent.force(url, handleResult);
fetchContent(url, handleResult);
}, fetchContentRaw = (url, cachedResult, callback) => {
const requestTime = Date.now();
fetch(new URL(url), {
headers: {
"accept-encoding": "gzip, deflate, br",
"user-agent": "webpack",
"if-none-match": cachedResult && cachedResult.etag || null
}
}, (res => {
const etag = res.headers.etag, location = res.headers.location, cacheControl = res.headers["cache-control"], {storeLock, storeCache, validUntil} = parseCacheControl(cacheControl, requestTime), finishWith = partialResult => {
"location" in partialResult ? logger.debug(`GET ${url} [${res.statusCode}] -> ${partialResult.location}`) : logger.debug(`GET ${url} [${res.statusCode}] ${Math.ceil(partialResult.content.length / 1024)} kB${storeLock ? "" : " no-cache"}`);
const result = {
...partialResult,
fresh: !0,
storeLock,
storeCache,
validUntil,
etag
};
if (!storeCache) return logger.log(`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`), 
callback(null, result);
cache.store(url, null, {
...result,
fresh: !1
}, (err => {
err && (logger.warn(`${url} can't be stored in cache: ${err.message}`), logger.debug(err.stack)), 
callback(null, result);
}));
};
if (304 === res.statusCode) return cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag ? finishWith(cachedResult) : (logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`), 
callback(null, {
...cachedResult,
fresh: !0
}));
if (location && res.statusCode >= 301 && res.statusCode <= 308) {
const result = {
location: new URL(location, url).href
};
return !cachedResult || !("location" in cachedResult) || cachedResult.location !== result.location || cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag ? finishWith(result) : (logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`), 
callback(null, {
...result,
fresh: !0,
storeLock,
storeCache,
validUntil,
etag
}));
}
const contentType = res.headers["content-type"] || "", bufferArr = [], contentEncoding = res.headers["content-encoding"];
let stream = res;
"gzip" === contentEncoding ? stream = stream.pipe(createGunzip()) : "br" === contentEncoding ? stream = stream.pipe(createBrotliDecompress()) : "deflate" === contentEncoding && (stream = stream.pipe(createInflate())), 
stream.on("data", (chunk => {
bufferArr.push(chunk);
})), stream.on("end", (() => {
if (!res.complete) return logger.log(`GET ${url} [${res.statusCode}] (terminated)`), 
callback(new Error(`${url} request was terminated`));
const content = Buffer.concat(bufferArr);
if (200 !== res.statusCode) return logger.log(`GET ${url} [${res.statusCode}]`), 
callback(new Error(`${url} request status code = ${res.statusCode}\n${content.toString("utf-8")}`));
const integrity = computeIntegrity(content);
finishWith({
entry: {
resolved: url,
integrity,
contentType
},
content
});
}));
})).on("error", (err => {
logger.log(`GET ${url} (error)`), err.message += `\nwhile fetching ${url}`, callback(err);
}));
}, fetchContent = cachedWithKey(((url, callback) => {
cache.get(url, null, ((err, cachedResult) => {
if (err) return callback(err);
if (cachedResult) {
if (cachedResult.validUntil >= Date.now()) return callback(null, cachedResult);
}
fetchContentRaw(url, cachedResult, callback);
}));
}), ((url, callback) => fetchContentRaw(url, void 0, callback))), isAllowed = uri => {
for (const allowed of allowedUris) if ("string" == typeof allowed) {
if (uri.startsWith(allowed)) return !0;
} else if ("function" == typeof allowed) {
if (allowed(uri)) return !0;
} else if (allowed.test(uri)) return !0;
return !1;
}, getInfo = cachedWithKey(((url, callback) => {
if (!isAllowed(url)) return callback(new Error(`${url} doesn't match the allowedUris policy. These URIs are allowed:\n${allowedUris.map((uri => ` - ${uri}`)).join("\n")}`));
getLockfile(((err, lockfile) => {
if (err) return callback(err);
const entryOrString = lockfile.entries.get(url);
if (!entryOrString) return frozen ? callback(new Error(`${url} has no lockfile entry and lockfile is frozen`)) : void resolveContent(url, null, ((err, result) => {
if (err) return callback(err);
storeResult(lockfile, url, result, callback);
}));
if ("string" == typeof entryOrString) {
const entryTag = entryOrString;
return void resolveContent(url, null, ((err, result) => err ? callback(err) : result.storeLock && "ignore" !== entryTag ? frozen ? callback(new Error(`${url} used to have ${entryTag} lockfile entry and has content now, but lockfile is frozen`)) : upgrade ? void storeResult(lockfile, url, result, callback) : callback(new Error(`${url} used to have ${entryTag} lockfile entry and has content now.\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\nRemove this line from the lockfile to force upgrading.`)) : callback(null, result)));
}
let entry = entryOrString;
const doFetch = lockedContent => {
resolveContent(url, entry.integrity, ((err, result) => {
return err ? lockedContent ? (logger.warn(`Upgrade request to ${url} failed: ${err.message}`), 
logger.debug(err.stack), callback(null, {
entry,
content: lockedContent
})) : callback(err) : result.storeLock ? (a = result.entry, b = entry, a.resolved !== b.resolved || a.integrity !== b.integrity || a.contentType !== b.contentType ? frozen ? callback(new Error(`${url} has an outdated lockfile entry, but lockfile is frozen\nLockfile: ${entryToString(entry)}\nExpected: ${entryToString(result.entry)}`)) : void storeResult(lockfile, url, result, callback) : !lockedContent && cacheLocation ? frozen ? callback(new Error(`${url} is missing content in the lockfile cache, but lockfile is frozen\nLockfile: ${entryToString(entry)}`)) : void storeResult(lockfile, url, result, callback) : callback(null, result)) : frozen ? callback(new Error(`${url} has a lockfile entry and is no-cache now, but lockfile is frozen\nLockfile: ${entryToString(entry)}`)) : void storeResult(lockfile, url, result, callback);
var a, b;
}));
};
if (cacheLocation) {
const key = getCacheKey(entry.resolved), filePath = join(intermediateFs, cacheLocation, key);
fs.readFile(filePath, ((err, result) => {
const content = result;
if (err) return "ENOENT" === err.code ? doFetch() : callback(err);
const continueWithCachedContent = result => upgrade ? doFetch(content) : callback(null, {
entry,
content
});
if (!verifyIntegrity(content, entry.integrity)) {
let contentWithChangedEol, isEolChanged = !1;
try {
contentWithChangedEol = Buffer.from(content.toString("utf-8").replace(/\r\n/g, "\n")), 
isEolChanged = verifyIntegrity(contentWithChangedEol, entry.integrity);
} catch (e) {}
if (isEolChanged) {
if (!warnedAboutEol) {
const explainer = "Incorrect end of line sequence was detected in the lockfile cache.\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\n  **/*webpack.lock.data/** -text\nThis will avoid that the end of line sequence is changed by git on Windows.";
frozen ? logger.error(explainer) : (logger.warn(explainer), logger.info("Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.")), 
warnedAboutEol = !0;
}
if (!frozen) return logger.log(`${filePath} fixed end of line sequence (\\r\\n instead of \\n).`), 
void intermediateFs.writeFile(filePath, contentWithChangedEol, (err => {
if (err) return callback(err);
continueWithCachedContent();
}));
}
if (frozen) return callback(new Error(`${entry.resolved} integrity mismatch, expected content with integrity ${entry.integrity} but got ${computeIntegrity(content)}.\nLockfile corrupted (${isEolChanged ? "end of line sequence was unexpectedly changed" : "incorrectly merged? changed by other tools?"}).\nRun build with un-frozen lockfile to automatically fix lockfile.`));
entry = {
...entry,
integrity: computeIntegrity(content)
}, storeLockEntry(lockfile, url, entry);
}
continueWithCachedContent();
}));
} else doFetch();
}));
})), respondWithUrlModule = (url, resourceData, callback) => {
getInfo(url.href, ((err, result) => {
if (err) return callback(err);
resourceData.resource = url.href, resourceData.path = url.origin + url.pathname, 
resourceData.query = url.search, resourceData.fragment = url.hash, resourceData.context = new URL(".", result.entry.resolved).href.slice(0, -1), 
resourceData.data.mimetype = result.entry.contentType, callback(null, !0);
}));
};
normalModuleFactory.hooks.resolveForScheme.for(scheme).tapAsync("HttpUriPlugin", ((resourceData, resolveData, callback) => {
respondWithUrlModule(new URL(resourceData.resource), resourceData, callback);
})), normalModuleFactory.hooks.resolveInScheme.for(scheme).tapAsync("HttpUriPlugin", ((resourceData, data, callback) => {
if ("url" !== data.dependencyType && !/^\.{0,2}\//.test(resourceData.resource)) return callback();
respondWithUrlModule(new URL(resourceData.resource, data.context + "/"), resourceData, callback);
}));
const hooks = NormalModule.getCompilationHooks(compilation);
hooks.readResourceForScheme.for(scheme).tapAsync("HttpUriPlugin", ((resource, module, callback) => getInfo(resource, ((err, result) => {
if (err) return callback(err);
module.buildInfo.resourceIntegrity = result.entry.integrity, callback(null, result.content);
})))), hooks.needBuild.tapAsync("HttpUriPlugin", ((module, context, callback) => {
if (!module.resource || !module.resource.startsWith(`${scheme}://`)) return callback();
getInfo(module.resource, ((err, result) => err ? callback(err) : result.entry.integrity !== module.buildInfo.resourceIntegrity ? callback(null, !0) : void callback()));
}));
}
compilation.hooks.finishModules.tapAsync("HttpUriPlugin", ((modules, callback) => {
if (!lockfileUpdates) return callback();
const ext = extname(lockfileLocation), tempFile = join(intermediateFs, dirname(intermediateFs, lockfileLocation), `.${basename(lockfileLocation, ext)}.${1e4 * Math.random() | 0}${ext}`), writeDone = () => {
const nextOperation = inProgressWrite.shift();
nextOperation ? nextOperation() : inProgressWrite = void 0;
}, runWrite = () => {
intermediateFs.readFile(lockfileLocation, ((err, buffer) => {
if (err && "ENOENT" !== err.code) return writeDone(), callback(err);
const lockfile = buffer ? Lockfile.parse(buffer.toString("utf-8")) : new Lockfile;
for (const [key, value] of lockfileUpdates) lockfile.entries.set(key, value);
intermediateFs.writeFile(tempFile, lockfile.toString(), (err => {
if (err) return writeDone(), intermediateFs.unlink(tempFile, (() => callback(err)));
intermediateFs.rename(tempFile, lockfileLocation, (err => {
if (err) return writeDone(), intermediateFs.unlink(tempFile, (() => callback(err)));
writeDone(), callback();
}));
}));
}));
};
inProgressWrite ? inProgressWrite.push(runWrite) : (inProgressWrite = [], runWrite());
}));
}));
}
};
},
75790: module => {
"use strict";
module.exports = class {
serialize(array, {write}) {
write(array.length);
for (const item of array) write(item);
}
deserialize({read}) {
const length = read(), array = [];
for (let i = 0; i < length; i++) array.push(read());
return array;
}
};
},
88594: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const memoize = __webpack_require__(98216), SerializerMiddleware = __webpack_require__(66852), MEASURE_START_OPERATION = Symbol("MEASURE_START_OPERATION"), MEASURE_END_OPERATION = Symbol("MEASURE_END_OPERATION"), identifyNumber = n => {
if (n === (0 | n)) {
if (n <= 127 && n >= -128) return 0;
if (n <= 2147483647 && n >= -2147483648) return 1;
}
return 2;
};
module.exports = class extends SerializerMiddleware {
serialize(data, context) {
return this._serialize(data, context);
}
_serializeLazy(fn, context) {
return SerializerMiddleware.serializeLazy(fn, (data => this._serialize(data, context)));
}
_serialize(data, context, allocationScope = {
allocationSize: 1024,
increaseCounter: 0,
leftOverBuffer: null
}) {
let leftOverBuffer = null, buffers = [], currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;
allocationScope.leftOverBuffer = null;
let currentPosition = 0;
null === currentBuffer && (currentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize));
const allocate = bytesNeeded => {
if (null !== currentBuffer) {
if (currentBuffer.length - currentPosition >= bytesNeeded) return;
flush();
}
leftOverBuffer && leftOverBuffer.length >= bytesNeeded ? (currentBuffer = leftOverBuffer, 
leftOverBuffer = null) : (currentBuffer = Buffer.allocUnsafe(Math.max(bytesNeeded, allocationScope.allocationSize)), 
!(allocationScope.increaseCounter = (allocationScope.increaseCounter + 1) % 4) && allocationScope.allocationSize < 16777216 && (allocationScope.allocationSize = allocationScope.allocationSize << 1));
}, flush = () => {
null !== currentBuffer && (currentPosition > 0 && buffers.push(Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset, currentPosition)), 
(!leftOverBuffer || leftOverBuffer.length < currentBuffer.length - currentPosition) && (leftOverBuffer = Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset + currentPosition, currentBuffer.byteLength - currentPosition)), 
currentBuffer = null, currentPosition = 0);
}, writeU8 = byte => {
currentBuffer.writeUInt8(byte, currentPosition++);
}, writeU32 = ui32 => {
currentBuffer.writeUInt32LE(ui32, currentPosition), currentPosition += 4;
}, measureStack = [], measureEnd = () => {
const oldPos = measureStack.pop(), buffersIndex = measureStack.pop();
let size = currentPosition - oldPos;
for (let i = buffersIndex; i < buffers.length; i++) size += buffers[i].length;
return size;
};
for (let i = 0; i < data.length; i++) {
const thing = data[i];
switch (typeof thing) {
case "function":
{
if (!SerializerMiddleware.isLazy(thing)) throw new Error("Unexpected function " + thing);
let serializedData = SerializerMiddleware.getLazySerializedValue(thing);
if (void 0 === serializedData) {
if (!SerializerMiddleware.isLazy(thing, this)) {
serializedData = this._serializeLazy(thing, context), flush(), buffers.push(serializedData);
break;
}
{
flush(), allocationScope.leftOverBuffer = leftOverBuffer;
const result = thing(), data = this._serialize(result, context, allocationScope);
leftOverBuffer = allocationScope.leftOverBuffer, allocationScope.leftOverBuffer = null, 
SerializerMiddleware.setLazySerializedValue(thing, data), serializedData = data;
}
} else if ("function" == typeof serializedData) {
flush(), buffers.push(serializedData);
break;
}
const lengths = [];
for (const item of serializedData) {
let last;
if ("function" == typeof item) lengths.push(0); else if (0 === item.length) ; else if (lengths.length > 0 && 0 !== (last = lengths[lengths.length - 1])) {
const remaining = 4294967295 - last;
remaining >= item.length ? lengths[lengths.length - 1] += item.length : (lengths.push(item.length - remaining), 
lengths[lengths.length - 2] = 4294967295);
} else lengths.push(item.length);
}
allocate(5 + 4 * lengths.length), writeU8(11), writeU32(lengths.length);
for (const l of lengths) writeU32(l);
flush();
for (const item of serializedData) buffers.push(item);
break;
}

case "string":
{
const len = Buffer.byteLength(thing);
if (len >= 128 || len !== thing.length) allocate(len + 1 + 4), writeU8(30), writeU32(len), 
currentBuffer.write(thing, currentPosition), currentPosition += len; else if (len >= 70) allocate(len + 1), 
writeU8(128 | len), currentBuffer.write(thing, currentPosition, "latin1"), currentPosition += len; else {
allocate(len + 1), writeU8(128 | len);
for (let i = 0; i < len; i++) currentBuffer[currentPosition++] = thing.charCodeAt(i);
}
break;
}

case "number":
{
const type = identifyNumber(thing);
if (0 === type && thing >= 0 && thing <= 10) {
allocate(1), writeU8(thing);
break;
}
let n = 1;
for (;n < 32 && i + n < data.length; n++) {
const item = data[i + n];
if ("number" != typeof item) break;
if (identifyNumber(item) !== type) break;
}
switch (type) {
case 0:
for (allocate(1 + 1 * n), writeU8(96 | n - 1); n > 0; ) currentBuffer.writeInt8(data[i], currentPosition), 
currentPosition += 1, n--, i++;
break;

case 1:
for (allocate(1 + 4 * n), writeU8(64 | n - 1); n > 0; ) currentBuffer.writeInt32LE(data[i], currentPosition), 
currentPosition += 4, n--, i++;
break;

case 2:
for (allocate(1 + 8 * n), writeU8(32 | n - 1); n > 0; ) currentBuffer.writeDoubleLE(data[i], currentPosition), 
currentPosition += 8, n--, i++;
}
i--;
break;
}

case "boolean":
{
let lastByte = !0 === thing ? 1 : 0;
const bytes = [];
let n, count = 1;
for (n = 1; n < 4294967295 && i + n < data.length; n++) {
const item = data[i + n];
if ("boolean" != typeof item) break;
const pos = 7 & count;
0 === pos ? (bytes.push(lastByte), lastByte = !0 === item ? 1 : 0) : !0 === item && (lastByte |= 1 << pos), 
count++;
}
if (i += count - 1, 1 === count) allocate(1), writeU8(1 === lastByte ? 12 : 13); else if (2 === count) allocate(2), 
writeU8(1 & lastByte ? 12 : 13), writeU8(2 & lastByte ? 12 : 13); else if (count <= 6) allocate(2), 
writeU8(14), writeU8(1 << count | lastByte); else if (count <= 133) {
allocate(2 + 1 * bytes.length + 1), writeU8(14), writeU8(128 | count - 7);
for (const byte of bytes) writeU8(byte);
writeU8(lastByte);
} else {
allocate(6 + 1 * bytes.length + 1), writeU8(14), writeU8(255), writeU32(count);
for (const byte of bytes) writeU8(byte);
writeU8(lastByte);
}
break;
}

case "object":
if (null === thing) {
let n;
for (n = 1; n < 4294967556 && i + n < data.length; n++) {
if (null !== data[i + n]) break;
}
if (i += n - 1, 1 === n) if (i + 1 < data.length) {
const next = data[i + 1];
if (!0 === next) allocate(1), writeU8(23), i++; else if (!1 === next) allocate(1), 
writeU8(24), i++; else if ("number" == typeof next) {
const type = identifyNumber(next);
0 === type ? (allocate(2), writeU8(21), currentBuffer.writeInt8(next, currentPosition), 
currentPosition += 1, i++) : 1 === type ? (allocate(5), writeU8(22), currentBuffer.writeInt32LE(next, currentPosition), 
currentPosition += 4, i++) : (allocate(1), writeU8(16));
} else allocate(1), writeU8(16);
} else allocate(1), writeU8(16); else 2 === n ? (allocate(1), writeU8(17)) : 3 === n ? (allocate(1), 
writeU8(18)) : n < 260 ? (allocate(2), writeU8(19), writeU8(n - 4)) : (allocate(5), 
writeU8(20), writeU32(n - 260));
} else Buffer.isBuffer(thing) && (thing.length < 8192 ? (allocate(5 + thing.length), 
writeU8(31), writeU32(thing.length), thing.copy(currentBuffer, currentPosition), 
currentPosition += thing.length) : (allocate(5), writeU8(31), writeU32(thing.length), 
flush(), buffers.push(thing)));
break;

case "symbol":
if (thing === MEASURE_START_OPERATION) measureStack.push(buffers.length, currentPosition); else if (thing === MEASURE_END_OPERATION) {
const size = measureEnd();
allocate(5), writeU8(64), currentBuffer.writeInt32LE(size, currentPosition), currentPosition += 4;
}
}
}
flush(), allocationScope.leftOverBuffer = leftOverBuffer, currentBuffer = null, 
leftOverBuffer = null, allocationScope = void 0;
const _buffers = buffers;
return buffers = void 0, _buffers;
}
deserialize(data, context) {
return this._deserialize(data, context);
}
_createLazyDeserialized(content, context) {
return SerializerMiddleware.createLazy(memoize((() => this._deserialize(content, context))), this, void 0, content);
}
_deserializeLazy(fn, context) {
return SerializerMiddleware.deserializeLazy(fn, (data => this._deserialize(data, context)));
}
_deserialize(data, context) {
let currentDataItem = 0, currentBuffer = data[0], currentIsBuffer = Buffer.isBuffer(currentBuffer), currentPosition = 0;
const retainedBuffer = context.retainedBuffer || (x => x), checkOverflow = () => {
currentPosition >= currentBuffer.length && (currentPosition = 0, currentDataItem++, 
currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null, currentIsBuffer = Buffer.isBuffer(currentBuffer));
}, isInCurrentBuffer = n => currentIsBuffer && n + currentPosition <= currentBuffer.length, ensureBuffer = () => {
if (!currentIsBuffer) throw new Error(null === currentBuffer ? "Unexpected end of stream" : "Unexpected lazy element in stream");
}, read = n => {
ensureBuffer();
const rem = currentBuffer.length - currentPosition;
if (rem < n) {
const buffers = [ read(rem) ];
for (n -= rem, ensureBuffer(); currentBuffer.length < n; ) {
const b = currentBuffer;
buffers.push(b), n -= b.length, currentDataItem++, currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null, 
currentIsBuffer = Buffer.isBuffer(currentBuffer), ensureBuffer();
}
return buffers.push(read(n)), Buffer.concat(buffers);
}
const b = currentBuffer, res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);
return currentPosition += n, checkOverflow(), res;
}, readUpTo = n => {
ensureBuffer();
const rem = currentBuffer.length - currentPosition;
rem < n && (n = rem);
const b = currentBuffer, res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);
return currentPosition += n, checkOverflow(), res;
}, readU8 = () => {
ensureBuffer();
const byte = currentBuffer.readUInt8(currentPosition);
return currentPosition += 1, checkOverflow(), byte;
}, readU32 = () => read(4).readUInt32LE(0), readBits = (data, n) => {
let mask = 1;
for (;0 !== n; ) result.push(0 != (data & mask)), mask <<= 1, n--;
}, dispatchTable = Array.from({
length: 256
}).map(((_, header) => {
switch (header) {
case 11:
return () => {
const count = readU32(), lengths = Array.from({
length: count
}).map((() => readU32())), content = [];
for (let l of lengths) if (0 === l) {
if ("function" != typeof currentBuffer) throw new Error("Unexpected non-lazy element in stream");
content.push(currentBuffer), currentDataItem++, currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null, 
currentIsBuffer = Buffer.isBuffer(currentBuffer);
} else do {
const buf = readUpTo(l);
l -= buf.length, content.push(retainedBuffer(buf));
} while (l > 0);
result.push(this._createLazyDeserialized(content, context));
};

case 31:
return () => {
const len = readU32();
result.push(retainedBuffer(read(len)));
};

case 12:
return () => result.push(!0);

case 13:
return () => result.push(!1);

case 18:
return () => result.push(null, null, null);

case 17:
return () => result.push(null, null);

case 16:
return () => result.push(null);

case 23:
return () => result.push(null, !0);

case 24:
return () => result.push(null, !1);

case 21:
return () => {
currentIsBuffer ? (result.push(null, currentBuffer.readInt8(currentPosition)), currentPosition += 1, 
checkOverflow()) : result.push(null, read(1).readInt8(0));
};

case 22:
return () => {
result.push(null), isInCurrentBuffer(4) ? (result.push(currentBuffer.readInt32LE(currentPosition)), 
currentPosition += 4, checkOverflow()) : result.push(read(4).readInt32LE(0));
};

case 19:
return () => {
const len = readU8() + 4;
for (let i = 0; i < len; i++) result.push(null);
};

case 20:
return () => {
const len = readU32() + 260;
for (let i = 0; i < len; i++) result.push(null);
};

case 14:
return () => {
const innerHeader = readU8();
if (0 == (240 & innerHeader)) readBits(innerHeader, 3); else if (0 == (224 & innerHeader)) readBits(innerHeader, 4); else if (0 == (192 & innerHeader)) readBits(innerHeader, 5); else if (0 == (128 & innerHeader)) readBits(innerHeader, 6); else if (255 !== innerHeader) {
let count = 7 + (127 & innerHeader);
for (;count > 8; ) readBits(readU8(), 8), count -= 8;
readBits(readU8(), count);
} else {
let count = readU32();
for (;count > 8; ) readBits(readU8(), 8), count -= 8;
readBits(readU8(), count);
}
};

case 30:
return () => {
const len = readU32();
isInCurrentBuffer(len) && currentPosition + len < 2147483647 ? (result.push(currentBuffer.toString(void 0, currentPosition, currentPosition + len)), 
currentPosition += len, checkOverflow()) : result.push(read(len).toString());
};

case 128:
return () => result.push("");

case 129:
return () => {
currentIsBuffer && currentPosition < 2147483646 ? (result.push(currentBuffer.toString("latin1", currentPosition, currentPosition + 1)), 
currentPosition++, checkOverflow()) : result.push(read(1).toString("latin1"));
};

case 96:
return () => {
currentIsBuffer ? (result.push(currentBuffer.readInt8(currentPosition)), currentPosition++, 
checkOverflow()) : result.push(read(1).readInt8(0));
};

default:
if (header <= 10) return () => result.push(header);
if (128 == (128 & header)) {
const len = 127 & header;
return () => {
isInCurrentBuffer(len) && currentPosition + len < 2147483647 ? (result.push(currentBuffer.toString("latin1", currentPosition, currentPosition + len)), 
currentPosition += len, checkOverflow()) : result.push(read(len).toString("latin1"));
};
}
if (32 == (224 & header)) {
const len = 1 + (31 & header);
return () => {
const need = 8 * len;
if (isInCurrentBuffer(need)) {
for (let i = 0; i < len; i++) result.push(currentBuffer.readDoubleLE(currentPosition)), 
currentPosition += 8;
checkOverflow();
} else {
const buf = read(need);
for (let i = 0; i < len; i++) result.push(buf.readDoubleLE(8 * i));
}
};
}
if (64 == (224 & header)) {
const len = 1 + (31 & header);
return () => {
const need = 4 * len;
if (isInCurrentBuffer(need)) {
for (let i = 0; i < len; i++) result.push(currentBuffer.readInt32LE(currentPosition)), 
currentPosition += 4;
checkOverflow();
} else {
const buf = read(need);
for (let i = 0; i < len; i++) result.push(buf.readInt32LE(4 * i));
}
};
}
if (96 == (224 & header)) {
const len = 1 + (31 & header);
return () => {
const need = 1 * len;
if (isInCurrentBuffer(need)) {
for (let i = 0; i < len; i++) result.push(currentBuffer.readInt8(currentPosition)), 
currentPosition += 1;
checkOverflow();
} else {
const buf = read(need);
for (let i = 0; i < len; i++) result.push(buf.readInt8(1 * i));
}
};
}
return () => {
throw new Error(`Unexpected header byte 0x${header.toString(16)}`);
};
}
}));
let result = [];
for (;null !== currentBuffer; ) if ("function" == typeof currentBuffer) result.push(this._deserializeLazy(currentBuffer, context)), 
currentDataItem++, currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null, 
currentIsBuffer = Buffer.isBuffer(currentBuffer); else {
dispatchTable[readU8()]();
}
let _result = result;
return result = void 0, _result;
}
}, module.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION, module.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;
},
91196: module => {
"use strict";
module.exports = class {
serialize(obj, {write}) {
write(obj.getTime());
}
deserialize({read}) {
return new Date(read());
}
};
},
82475: module => {
"use strict";
module.exports = class {
constructor(Type) {
this.Type = Type;
}
serialize(obj, {write}) {
write(obj.message), write(obj.stack);
}
deserialize({read}) {
const err = new this.Type;
return err.message = read(), err.stack = read(), err;
}
};
},
38030: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {constants} = __webpack_require__(14300), {pipeline} = __webpack_require__(12781), {createBrotliCompress, createBrotliDecompress, createGzip, createGunzip, constants: zConstants} = __webpack_require__(59796), createHash = __webpack_require__(27466), {dirname, join, mkdirp} = __webpack_require__(57075), memoize = __webpack_require__(98216), SerializerMiddleware = __webpack_require__(66852), writeUInt64LE = Buffer.prototype.writeBigUInt64LE ? (buf, value, offset) => {
buf.writeBigUInt64LE(BigInt(value), offset);
} : (buf, value, offset) => {
const low = value % 4294967296, high = (value - low) / 4294967296;
buf.writeUInt32LE(low, offset), buf.writeUInt32LE(high, offset + 4);
}, readUInt64LE = Buffer.prototype.readBigUInt64LE ? (buf, offset) => Number(buf.readBigUInt64LE(offset)) : (buf, offset) => {
const low = buf.readUInt32LE(offset);
return 4294967296 * buf.readUInt32LE(offset + 4) + low;
}, serialize = async (middleware, data, name, writeFile, hashFunction = "md4") => {
const processedData = [], resultToLazy = new WeakMap;
let lastBuffers;
for (const item of await data) if ("function" == typeof item) {
if (!SerializerMiddleware.isLazy(item)) throw new Error("Unexpected function");
if (!SerializerMiddleware.isLazy(item, middleware)) throw new Error("Unexpected lazy value with non-this target (can't pass through lazy values)");
lastBuffers = void 0;
const serializedInfo = SerializerMiddleware.getLazySerializedValue(item);
if (serializedInfo) {
if ("function" == typeof serializedInfo) throw new Error("Unexpected lazy value with non-this target (can't pass through lazy values)");
processedData.push(serializedInfo);
} else {
const content = item();
if (!content) throw new Error("Unexpected falsy value returned by lazy value function");
{
const options = SerializerMiddleware.getLazyOptions(item);
processedData.push(serialize(middleware, content, options && options.name || !0, writeFile, hashFunction).then((result => (item.options.size = result.size, 
resultToLazy.set(result, item), result))));
}
}
} else {
if (!item) throw new Error("Unexpected falsy value in items array");
lastBuffers ? lastBuffers.push(item) : (lastBuffers = [ item ], processedData.push(lastBuffers));
}
const backgroundJobs = [], resolvedData = (await Promise.all(processedData)).map((item => {
if (Array.isArray(item) || Buffer.isBuffer(item)) return item;
backgroundJobs.push(item.backgroundJob);
const name = item.name, nameBuffer = Buffer.from(name), buf = Buffer.allocUnsafe(8 + nameBuffer.length);
writeUInt64LE(buf, item.size, 0), nameBuffer.copy(buf, 8, 0);
const lazy = resultToLazy.get(item);
return SerializerMiddleware.setLazySerializedValue(lazy, buf), buf;
})), lengths = [];
for (const item of resolvedData) if (Array.isArray(item)) {
let l = 0;
for (const b of item) l += b.length;
for (;l > 2147483647; ) lengths.push(2147483647), l -= 2147483647;
lengths.push(l);
} else {
if (!item) throw new Error("Unexpected falsy value in resolved data " + item);
lengths.push(-item.length);
}
const header = Buffer.allocUnsafe(8 + 4 * lengths.length);
header.writeUInt32LE(23294071, 0), header.writeUInt32LE(lengths.length, 4);
for (let i = 0; i < lengths.length; i++) header.writeInt32LE(lengths[i], 8 + 4 * i);
const buf = [ header ];
for (const item of resolvedData) if (Array.isArray(item)) for (const b of item) buf.push(b); else item && buf.push(item);
!0 === name && (name = ((buffers, hashFunction) => {
const hash = createHash(hashFunction);
for (const buf of buffers) hash.update(buf);
return hash.digest("hex");
})(buf, hashFunction));
let size = 0;
for (const b of buf) size += b.length;
return backgroundJobs.push(writeFile(name, buf, size)), {
size,
name,
backgroundJob: 1 === backgroundJobs.length ? backgroundJobs[0] : Promise.all(backgroundJobs)
};
}, deserialize = async (middleware, name, readFile) => {
const contents = await readFile(name);
if (0 === contents.length) throw new Error("Empty file " + name);
let contentsIndex = 0, contentItem = contents[0], contentItemLength = contentItem.length, contentPosition = 0;
if (0 === contentItemLength) throw new Error("Empty file " + name);
const nextContent = () => {
contentsIndex++, contentItem = contents[contentsIndex], contentItemLength = contentItem.length, 
contentPosition = 0;
}, ensureData = n => {
for (contentPosition === contentItemLength && nextContent(); contentItemLength - contentPosition < n; ) {
const remaining = contentItem.slice(contentPosition);
let lengthFromNext = n - remaining.length;
const buffers = [ remaining ];
for (let i = contentsIndex + 1; i < contents.length; i++) {
const l = contents[i].length;
if (l > lengthFromNext) {
buffers.push(contents[i].slice(0, lengthFromNext)), contents[i] = contents[i].slice(lengthFromNext), 
lengthFromNext = 0;
break;
}
buffers.push(contents[i]), contentsIndex = i, lengthFromNext -= l;
}
if (lengthFromNext > 0) throw new Error("Unexpected end of data");
contentItem = Buffer.concat(buffers, n), contentItemLength = n, contentPosition = 0;
}
}, readUInt32LE = () => {
ensureData(4);
const value = contentItem.readUInt32LE(contentPosition);
return contentPosition += 4, value;
}, readInt32LE = () => {
ensureData(4);
const value = contentItem.readInt32LE(contentPosition);
return contentPosition += 4, value;
}, readSlice = l => {
if (ensureData(l), 0 === contentPosition && contentItemLength === l) {
const result = contentItem;
return contentsIndex + 1 < contents.length ? nextContent() : contentPosition = l, 
result;
}
const result = contentItem.slice(contentPosition, contentPosition + l);
return contentPosition += l, 2 * l < contentItem.buffer.byteLength ? Buffer.from(result) : result;
};
if (23294071 !== readUInt32LE()) throw new Error("Invalid file version");
const sectionCount = readUInt32LE(), lengths = [];
let lastLengthPositive = !1;
for (let i = 0; i < sectionCount; i++) {
const value = readInt32LE(), valuePositive = value >= 0;
lastLengthPositive && valuePositive ? lengths[lengths.length - 1] += value : (lengths.push(value), 
lastLengthPositive = valuePositive);
}
const result = [];
for (let length of lengths) if (length < 0) {
const slice = readSlice(-length), size = Number(readUInt64LE(slice, 0)), name = slice.slice(8).toString();
result.push(SerializerMiddleware.createLazy(memoize((() => deserialize(middleware, name, readFile))), middleware, {
name,
size
}, slice));
} else {
if (contentPosition === contentItemLength) nextContent(); else if (0 !== contentPosition) if (length <= contentItemLength - contentPosition) result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, length)), 
contentPosition += length, length = 0; else {
const l = contentItemLength - contentPosition;
result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, l)), 
length -= l, contentPosition = contentItemLength;
} else length >= contentItemLength ? (result.push(contentItem), length -= contentItemLength, 
contentPosition = contentItemLength) : (result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length)), 
contentPosition += length, length = 0);
for (;length > 0; ) nextContent(), length >= contentItemLength ? (result.push(contentItem), 
length -= contentItemLength, contentPosition = contentItemLength) : (result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length)), 
contentPosition += length, length = 0);
}
return result;
};
module.exports = class extends SerializerMiddleware {
constructor(fs, hashFunction = "md4") {
super(), this.fs = fs, this._hashFunction = hashFunction;
}
serialize(data, context) {
const {filename, extension = ""} = context;
return new Promise(((resolve, reject) => {
mkdirp(this.fs, dirname(this.fs, filename), (err => {
if (err) return reject(err);
const allWrittenFiles = new Set;
resolve(serialize(this, data, !1, (async (name, content, size) => {
const file = name ? join(this.fs, filename, `../${name}${extension}`) : filename;
await new Promise(((resolve, reject) => {
let compression, stream = this.fs.createWriteStream(file + "_");
file.endsWith(".gz") ? compression = createGzip({
chunkSize: 104857600,
level: zConstants.Z_BEST_SPEED
}) : file.endsWith(".br") && (compression = createBrotliCompress({
chunkSize: 104857600,
params: {
[zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,
[zConstants.BROTLI_PARAM_QUALITY]: 2,
[zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: !0,
[zConstants.BROTLI_PARAM_SIZE_HINT]: size
}
})), compression ? (pipeline(compression, stream, reject), stream = compression, 
stream.on("finish", (() => resolve()))) : (stream.on("error", (err => reject(err))), 
stream.on("finish", (() => resolve())));
const chunks = [];
for (const b of content) if (b.length < 535822336) chunks.push(b); else for (let i = 0; i < b.length; i += 535822336) chunks.push(b.slice(i, i + 535822336));
const len = chunks.length;
let i = 0;
const batchWrite = err => {
if (err) return;
if (i === len) return void stream.end();
let end = i, sum = chunks[end++].length;
for (;end < len && (sum += chunks[end].length, !(sum > 2147418112)); ) end++;
for (;i < end - 1; ) stream.write(chunks[i++]);
stream.write(chunks[i++], batchWrite);
};
batchWrite();
})), name && allWrittenFiles.add(file);
}), this._hashFunction).then((async ({backgroundJob}) => (await backgroundJob, await new Promise((resolve => this.fs.rename(filename, filename + ".old", (err => {
resolve();
})))), await Promise.all(Array.from(allWrittenFiles, (file => new Promise(((resolve, reject) => {
this.fs.rename(file + "_", file, (err => {
if (err) return reject(err);
resolve();
}));
}))))), await new Promise((resolve => {
this.fs.rename(filename + "_", filename, (err => {
if (err) return reject(err);
resolve();
}));
})), !0))));
}));
}));
}
deserialize(data, context) {
const {filename, extension = ""} = context;
return deserialize(this, !1, (name => new Promise(((resolve, reject) => {
const file = name ? join(this.fs, filename, `../${name}${extension}`) : filename;
this.fs.stat(file, ((err, stats) => {
if (err) return void reject(err);
let currentBuffer, currentBufferUsed, remaining = stats.size;
const buf = [];
let decompression;
if (file.endsWith(".gz") ? decompression = createGunzip({
chunkSize: 104857600
}) : file.endsWith(".br") && (decompression = createBrotliDecompress({
chunkSize: 104857600
})), decompression) {
let newResolve, newReject;
resolve(Promise.all([ new Promise(((rs, rj) => {
newResolve = rs, newReject = rj;
})), new Promise(((resolve, reject) => {
decompression.on("data", (chunk => buf.push(chunk))), decompression.on("end", (() => resolve())), 
decompression.on("error", (err => reject(err)));
})) ]).then((() => buf))), resolve = newResolve, reject = newReject;
}
this.fs.open(file, "r", ((err, fd) => {
if (err) return void reject(err);
const read = () => {
void 0 === currentBuffer && (currentBuffer = Buffer.allocUnsafeSlow(Math.min(constants.MAX_LENGTH, remaining, decompression ? 104857600 : 1 / 0)), 
currentBufferUsed = 0);
let readBuffer = currentBuffer, readOffset = currentBufferUsed, readLength = currentBuffer.length - currentBufferUsed;
readOffset > 2147483647 && (readBuffer = currentBuffer.slice(readOffset), readOffset = 0), 
readLength > 2147483647 && (readLength = 2147483647), this.fs.read(fd, readBuffer, readOffset, readLength, null, ((err, bytesRead) => {
if (err) this.fs.close(fd, (() => {
reject(err);
})); else {
if (currentBufferUsed += bytesRead, remaining -= bytesRead, currentBufferUsed === currentBuffer.length && (decompression ? decompression.write(currentBuffer) : buf.push(currentBuffer), 
currentBuffer = void 0, 0 === remaining)) return decompression && decompression.end(), 
void this.fs.close(fd, (err => {
err ? reject(err) : resolve(buf);
}));
read();
}
}));
};
read();
}));
}));
}))));
}
};
},
99368: module => {
"use strict";
module.exports = class {
serialize(obj, {write}) {
write(obj.size);
for (const key of obj.keys()) write(key);
for (const value of obj.values()) write(value);
}
deserialize({read}) {
let size = read();
const map = new Map, keys = [];
for (let i = 0; i < size; i++) keys.push(read());
for (let i = 0; i < size; i++) map.set(keys[i], read());
return map;
}
};
},
13294: module => {
"use strict";
module.exports = class {
serialize(obj, {write}) {
const keys = Object.keys(obj);
for (const key of keys) write(key);
write(null);
for (const key of keys) write(obj[key]);
}
deserialize({read}) {
const obj = Object.create(null), keys = [];
let key = read();
for (;null !== key; ) keys.push(key), key = read();
for (const key of keys) obj[key] = read();
return obj;
}
};
},
40744: module => {
"use strict";
const cache = new WeakMap;
class ObjectStructure {
constructor() {
this.keys = void 0, this.children = void 0;
}
getKeys(keys) {
return void 0 === this.keys && (this.keys = keys), this.keys;
}
key(key) {
void 0 === this.children && (this.children = new Map);
const child = this.children.get(key);
if (void 0 !== child) return child;
const newChild = new ObjectStructure;
return this.children.set(key, newChild), newChild;
}
}
module.exports = class {
serialize(obj, {write}) {
const keys = Object.keys(obj);
if (keys.length > 128) {
write(keys);
for (const key of keys) write(obj[key]);
} else if (keys.length > 1) {
write(((keys, cacheAssoc) => {
let root = cache.get(cacheAssoc);
void 0 === root && (root = new ObjectStructure, cache.set(cacheAssoc, root));
let current = root;
for (const key of keys) current = current.key(key);
return current.getKeys(keys);
})(keys, write));
for (const key of keys) write(obj[key]);
} else if (1 === keys.length) {
const key = keys[0];
write(key), write(obj[key]);
} else write(null);
}
deserialize({read}) {
const keys = read(), obj = {};
if (Array.isArray(keys)) for (const key of keys) obj[key] = read(); else null !== keys && (obj[keys] = read());
return obj;
}
};
},
27005: module => {
"use strict";
module.exports = class {
serialize(obj, {write}) {
write(obj.source), write(obj.flags);
}
deserialize({read}) {
return new RegExp(read(), read());
}
};
},
50307: module => {
"use strict";
module.exports = class {
constructor(middlewares, context) {
this.serializeMiddlewares = middlewares.slice(), this.deserializeMiddlewares = middlewares.slice().reverse(), 
this.context = context;
}
serialize(obj, context) {
const ctx = {
...context,
...this.context
};
let current = obj;
for (const middleware of this.serializeMiddlewares) if (current && "function" == typeof current.then) current = current.then((data => data && middleware.serialize(data, ctx))); else {
if (!current) break;
try {
current = middleware.serialize(current, ctx);
} catch (err) {
current = Promise.reject(err);
}
}
return current;
}
deserialize(value, context) {
const ctx = {
...context,
...this.context
};
let current = value;
for (const middleware of this.deserializeMiddlewares) current = current && "function" == typeof current.then ? current.then((data => middleware.deserialize(data, ctx))) : middleware.deserialize(current, ctx);
return current;
}
};
},
66852: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const memoize = __webpack_require__(98216), LAZY_TARGET = Symbol("lazy serialization target"), LAZY_SERIALIZED_VALUE = Symbol("lazy serialization data");
class SerializerMiddleware {
serialize(data, context) {
throw new (__webpack_require__(91266));
}
deserialize(data, context) {
throw new (__webpack_require__(91266));
}
static createLazy(value, target, options = {}, serializedValue) {
if (SerializerMiddleware.isLazy(value, target)) return value;
const fn = "function" == typeof value ? value : () => value;
return fn[LAZY_TARGET] = target, fn.options = options, fn[LAZY_SERIALIZED_VALUE] = serializedValue, 
fn;
}
static isLazy(fn, target) {
if ("function" != typeof fn) return !1;
const t = fn[LAZY_TARGET];
return target ? t === target : !!t;
}
static getLazyOptions(fn) {
if ("function" == typeof fn) return fn.options;
}
static getLazySerializedValue(fn) {
if ("function" == typeof fn) return fn[LAZY_SERIALIZED_VALUE];
}
static setLazySerializedValue(fn, value) {
fn[LAZY_SERIALIZED_VALUE] = value;
}
static serializeLazy(lazy, serialize) {
const fn = memoize((() => {
const r = lazy();
return r && "function" == typeof r.then ? r.then((data => data && serialize(data))) : serialize(r);
}));
return fn[LAZY_TARGET] = lazy[LAZY_TARGET], fn.options = lazy.options, lazy[LAZY_SERIALIZED_VALUE] = fn, 
fn;
}
static deserializeLazy(lazy, deserialize) {
const fn = memoize((() => {
const r = lazy();
return r && "function" == typeof r.then ? r.then((data => deserialize(data))) : deserialize(r);
}));
return fn[LAZY_TARGET] = lazy[LAZY_TARGET], fn.options = lazy.options, fn[LAZY_SERIALIZED_VALUE] = lazy, 
fn;
}
static unMemoizeLazy(lazy) {
if (!SerializerMiddleware.isLazy(lazy)) return lazy;
const fn = () => {
throw new Error("A lazy value that has been unmemorized can't be called again");
};
return fn[LAZY_SERIALIZED_VALUE] = SerializerMiddleware.unMemoizeLazy(lazy[LAZY_SERIALIZED_VALUE]), 
fn[LAZY_TARGET] = lazy[LAZY_TARGET], fn.options = lazy.options, fn;
}
}
module.exports = SerializerMiddleware;
},
55432: module => {
"use strict";
module.exports = class {
serialize(obj, {write}) {
write(obj.size);
for (const value of obj) write(value);
}
deserialize({read}) {
let size = read();
const set = new Set;
for (let i = 0; i < size; i++) set.add(read());
return set;
}
};
},
7014: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const SerializerMiddleware = __webpack_require__(66852);
module.exports = class extends SerializerMiddleware {
serialize(data, context) {
return [ data ];
}
deserialize(data, context) {
return data[0];
}
};
},
89143: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216), makeSerializable = __webpack_require__(45898);
class ConsumeSharedFallbackDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "consume shared fallback";
}
get category() {
return "esm";
}
}
makeSerializable(ConsumeSharedFallbackDependency, "webpack/lib/sharing/ConsumeSharedFallbackDependency"), 
module.exports = ConsumeSharedFallbackDependency;
},
60029: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), AsyncDependenciesBlock = __webpack_require__(89353), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), {rangeToString, stringifyHoley} = __webpack_require__(46617), ConsumeSharedFallbackDependency = __webpack_require__(89143), TYPES = new Set([ "consume-shared" ]);
class ConsumeSharedModule extends Module {
constructor(context, options) {
super("consume-shared-module", context), this.options = options;
}
identifier() {
const {shareKey, shareScope, importResolved, requiredVersion, strictVersion, singleton, eager} = this.options;
return `consume-shared-module|${shareScope}|${shareKey}|${requiredVersion && rangeToString(requiredVersion)}|${strictVersion}|${importResolved}|${singleton}|${eager}`;
}
readableIdentifier(requestShortener) {
const {shareKey, shareScope, importResolved, requiredVersion, strictVersion, singleton, eager} = this.options;
return `consume shared module (${shareScope}) ${shareKey}@${requiredVersion ? rangeToString(requiredVersion) : "*"}${strictVersion ? " (strict)" : ""}${singleton ? " (singleton)" : ""}${importResolved ? ` (fallback: ${requestShortener.shorten(importResolved)})` : ""}${eager ? " (eager)" : ""}`;
}
libIdent(options) {
const {shareKey, shareScope, import: request} = this.options;
return `${this.layer ? `(${this.layer})/` : ""}webpack/sharing/consume/${shareScope}/${shareKey}${request ? `/${request}` : ""}`;
}
needBuild(context, callback) {
callback(null, !this.buildInfo);
}
build(options, compilation, resolver, fs, callback) {
if (this.buildMeta = {}, this.buildInfo = {}, this.options.import) {
const dep = new ConsumeSharedFallbackDependency(this.options.import);
if (this.options.eager) this.addDependency(dep); else {
const block = new AsyncDependenciesBlock({});
block.addDependency(dep), this.addBlock(block);
}
}
callback();
}
getSourceTypes() {
return TYPES;
}
size(type) {
return 42;
}
updateHash(hash, context) {
hash.update(JSON.stringify(this.options)), super.updateHash(hash, context);
}
codeGeneration({chunkGraph, moduleGraph, runtimeTemplate}) {
const runtimeRequirements = new Set([ RuntimeGlobals.shareScopeMap ]), {shareScope, shareKey, strictVersion, requiredVersion, import: request, singleton, eager} = this.options;
let fallbackCode;
if (request) if (eager) {
const dep = this.dependencies[0];
fallbackCode = runtimeTemplate.syncModuleFactory({
dependency: dep,
chunkGraph,
runtimeRequirements,
request: this.options.import
});
} else {
const block = this.blocks[0];
fallbackCode = runtimeTemplate.asyncModuleFactory({
block,
chunkGraph,
runtimeRequirements,
request: this.options.import
});
}
let fn = "load";
const args = [ JSON.stringify(shareScope), JSON.stringify(shareKey) ];
requiredVersion ? (strictVersion && (fn += "Strict"), singleton && (fn += "Singleton"), 
args.push(stringifyHoley(requiredVersion)), fn += "VersionCheck") : singleton && (fn += "Singleton"), 
fallbackCode && (fn += "Fallback", args.push(fallbackCode));
const code = runtimeTemplate.returningFunction(`${fn}(${args.join(", ")})`), sources = new Map;
return sources.set("consume-shared", new RawSource(code)), {
runtimeRequirements,
sources
};
}
serialize(context) {
const {write} = context;
write(this.options), super.serialize(context);
}
deserialize(context) {
const {read} = context;
this.options = read(), super.deserialize(context);
}
}
makeSerializable(ConsumeSharedModule, "webpack/lib/sharing/ConsumeSharedModule"), 
module.exports = ConsumeSharedModule;
},
86075: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleNotFoundError = __webpack_require__(98674), RuntimeGlobals = __webpack_require__(50980), WebpackError = __webpack_require__(64326), {parseOptions} = __webpack_require__(20912), LazySet = __webpack_require__(92585), createSchemaValidation = __webpack_require__(59586), {parseRange} = __webpack_require__(46617), ConsumeSharedFallbackDependency = __webpack_require__(89143), ConsumeSharedModule = __webpack_require__(60029), ConsumeSharedRuntimeModule = __webpack_require__(36217), ProvideForSharedDependency = __webpack_require__(13720), {resolveMatchedConfigs} = __webpack_require__(81657), {isRequiredVersion, getDescriptionFile, getRequiredVersionFromDescriptionFile} = __webpack_require__(57480), validate = createSchemaValidation(__webpack_require__(35842), (() => __webpack_require__(52021)), {
name: "Consume Shared Plugin",
baseDataPath: "options"
}), RESOLVE_OPTIONS = {
dependencyType: "esm"
}, PLUGIN_NAME = "ConsumeSharedPlugin";
module.exports = class {
constructor(options) {
"string" != typeof options && validate(options), this._consumes = parseOptions(options.consumes, ((item, key) => {
if (Array.isArray(item)) throw new Error("Unexpected array in options");
return item !== key && isRequiredVersion(item) ? {
import: key,
shareScope: options.shareScope || "default",
shareKey: key,
requiredVersion: parseRange(item),
strictVersion: !0,
packageName: void 0,
singleton: !1,
eager: !1
} : {
import: key,
shareScope: options.shareScope || "default",
shareKey: key,
requiredVersion: void 0,
packageName: void 0,
strictVersion: !1,
singleton: !1,
eager: !1
};
}), ((item, key) => ({
import: !1 === item.import ? void 0 : item.import || key,
shareScope: item.shareScope || options.shareScope || "default",
shareKey: item.shareKey || key,
requiredVersion: "string" == typeof item.requiredVersion ? parseRange(item.requiredVersion) : item.requiredVersion,
strictVersion: "boolean" == typeof item.strictVersion ? item.strictVersion : !1 !== item.import && !item.singleton,
packageName: item.packageName,
singleton: !!item.singleton,
eager: !!item.eager
})));
}
apply(compiler) {
compiler.hooks.thisCompilation.tap(PLUGIN_NAME, ((compilation, {normalModuleFactory}) => {
let unresolvedConsumes, resolvedConsumes, prefixedConsumes;
compilation.dependencyFactories.set(ConsumeSharedFallbackDependency, normalModuleFactory);
const promise = resolveMatchedConfigs(compilation, this._consumes).then((({resolved, unresolved, prefixed}) => {
resolvedConsumes = resolved, unresolvedConsumes = unresolved, prefixedConsumes = prefixed;
})), resolver = compilation.resolverFactory.get("normal", RESOLVE_OPTIONS), createConsumeSharedModule = (context, request, config) => {
const requiredVersionWarning = details => {
const error = new WebpackError(`No required version specified and unable to automatically determine one. ${details}`);
error.file = `shared module ${request}`, compilation.warnings.push(error);
}, directFallback = config.import && /^(\.\.?(\/|$)|\/|[A-Za-z]:|\\\\)/.test(config.import);
return Promise.all([ new Promise((resolve => {
if (!config.import) return resolve();
const resolveContext = {
fileDependencies: new LazySet,
contextDependencies: new LazySet,
missingDependencies: new LazySet
};
resolver.resolve({}, directFallback ? compiler.context : context, config.import, resolveContext, ((err, result) => {
if (compilation.contextDependencies.addAll(resolveContext.contextDependencies), 
compilation.fileDependencies.addAll(resolveContext.fileDependencies), compilation.missingDependencies.addAll(resolveContext.missingDependencies), 
err) return compilation.errors.push(new ModuleNotFoundError(null, err, {
name: `resolving fallback for shared module ${request}`
})), resolve();
resolve(result);
}));
})), new Promise((resolve => {
if (void 0 !== config.requiredVersion) return resolve(config.requiredVersion);
let packageName = config.packageName;
if (void 0 === packageName) {
if (/^(\/|[A-Za-z]:|\\\\)/.test(request)) return resolve();
const match = /^((?:@[^\\/]+[\\/])?[^\\/]+)/.exec(request);
if (!match) return requiredVersionWarning("Unable to extract the package name from request."), 
resolve();
packageName = match[0];
}
getDescriptionFile(compilation.inputFileSystem, context, [ "package.json" ], ((err, result) => {
if (err) return requiredVersionWarning(`Unable to read description file: ${err}`), 
resolve();
const {data, path: descriptionPath} = result;
if (!data) return requiredVersionWarning(`Unable to find description file in ${context}.`), 
resolve();
const requiredVersion = getRequiredVersionFromDescriptionFile(data, packageName);
if ("string" != typeof requiredVersion) return requiredVersionWarning(`Unable to find required version for "${packageName}" in description file (${descriptionPath}). It need to be in dependencies, devDependencies or peerDependencies.`), 
resolve();
resolve(parseRange(requiredVersion));
}));
})) ]).then((([importResolved, requiredVersion]) => new ConsumeSharedModule(directFallback ? compiler.context : context, {
...config,
importResolved,
import: importResolved ? config.import : void 0,
requiredVersion
})));
};
normalModuleFactory.hooks.factorize.tapPromise(PLUGIN_NAME, (({context, request, dependencies}) => promise.then((() => {
if (dependencies[0] instanceof ConsumeSharedFallbackDependency || dependencies[0] instanceof ProvideForSharedDependency) return;
const match = unresolvedConsumes.get(request);
if (void 0 !== match) return createConsumeSharedModule(context, request, match);
for (const [prefix, options] of prefixedConsumes) if (request.startsWith(prefix)) {
const remainder = request.slice(prefix.length);
return createConsumeSharedModule(context, request, {
...options,
import: options.import ? options.import + remainder : void 0,
shareKey: options.shareKey + remainder
});
}
})))), normalModuleFactory.hooks.createModule.tapPromise(PLUGIN_NAME, (({resource}, {context, dependencies}) => {
if (dependencies[0] instanceof ConsumeSharedFallbackDependency || dependencies[0] instanceof ProvideForSharedDependency) return Promise.resolve();
const options = resolvedConsumes.get(resource);
return void 0 !== options ? createConsumeSharedModule(context, resource, options) : Promise.resolve();
})), compilation.hooks.additionalTreeRuntimeRequirements.tap(PLUGIN_NAME, ((chunk, set) => {
set.add(RuntimeGlobals.module), set.add(RuntimeGlobals.moduleCache), set.add(RuntimeGlobals.moduleFactoriesAddOnly), 
set.add(RuntimeGlobals.shareScopeMap), set.add(RuntimeGlobals.initializeSharing), 
set.add(RuntimeGlobals.hasOwnProperty), compilation.addRuntimeModule(chunk, new ConsumeSharedRuntimeModule(set));
}));
}));
}
};
},
36217: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {parseVersionRuntimeCode, versionLtRuntimeCode, rangeToStringRuntimeCode, satisfyRuntimeCode} = __webpack_require__(46617);
module.exports = class extends RuntimeModule {
constructor(runtimeRequirements) {
super("consumes", RuntimeModule.STAGE_ATTACH), this._runtimeRequirements = runtimeRequirements;
}
generate() {
const {compilation, chunkGraph} = this, {runtimeTemplate, codeGenerationResults} = compilation, chunkToModuleMapping = {}, moduleIdToSourceMapping = new Map, initialConsumes = [], addModules = (modules, chunk, list) => {
for (const m of modules) {
const module = m, id = chunkGraph.getModuleId(module);
list.push(id), moduleIdToSourceMapping.set(id, codeGenerationResults.getSource(module, chunk.runtime, "consume-shared"));
}
};
for (const chunk of this.chunk.getAllAsyncChunks()) {
const modules = chunkGraph.getChunkModulesIterableBySourceType(chunk, "consume-shared");
modules && addModules(modules, chunk, chunkToModuleMapping[chunk.id] = []);
}
for (const chunk of this.chunk.getAllInitialChunks()) {
const modules = chunkGraph.getChunkModulesIterableBySourceType(chunk, "consume-shared");
modules && addModules(modules, chunk, initialConsumes);
}
return 0 === moduleIdToSourceMapping.size ? null : Template.asString([ parseVersionRuntimeCode(runtimeTemplate), versionLtRuntimeCode(runtimeTemplate), rangeToStringRuntimeCode(runtimeTemplate), satisfyRuntimeCode(runtimeTemplate), `var ensureExistence = ${runtimeTemplate.basicFunction("scopeName, key", [ `var scope = ${RuntimeGlobals.shareScopeMap}[scopeName];`, `if(!scope || !${RuntimeGlobals.hasOwnProperty}(scope, key)) throw new Error("Shared module " + key + " doesn't exist in shared scope " + scopeName);`, "return scope;" ])};`, `var findVersion = ${runtimeTemplate.basicFunction("scope, key", [ "var versions = scope[key];", `var key = Object.keys(versions).reduce(${runtimeTemplate.basicFunction("a, b", [ "return !a || versionLt(a, b) ? b : a;" ])}, 0);`, "return key && versions[key]" ])};`, `var findSingletonVersionKey = ${runtimeTemplate.basicFunction("scope, key", [ "var versions = scope[key];", `return Object.keys(versions).reduce(${runtimeTemplate.basicFunction("a, b", [ "return !a || (!versions[a].loaded && versionLt(a, b)) ? b : a;" ])}, 0);` ])};`, `var getInvalidSingletonVersionMessage = ${runtimeTemplate.basicFunction("scope, key, version, requiredVersion", [ 'return "Unsatisfied version " + version + " from " + (version && scope[key][version].from) + " of shared singleton module " + key + " (required " + rangeToString(requiredVersion) + ")"' ])};`, `var getSingleton = ${runtimeTemplate.basicFunction("scope, scopeName, key, requiredVersion", [ "var version = findSingletonVersionKey(scope, key);", "return get(scope[key][version]);" ])};`, `var getSingletonVersion = ${runtimeTemplate.basicFunction("scope, scopeName, key, requiredVersion", [ "var version = findSingletonVersionKey(scope, key);", 'if (!satisfy(requiredVersion, version)) typeof console !== "undefined" && console.warn && console.warn(getInvalidSingletonVersionMessage(scope, key, version, requiredVersion));', "return get(scope[key][version]);" ])};`, `var getStrictSingletonVersion = ${runtimeTemplate.basicFunction("scope, scopeName, key, requiredVersion", [ "var version = findSingletonVersionKey(scope, key);", "if (!satisfy(requiredVersion, version)) throw new Error(getInvalidSingletonVersionMessage(scope, key, version, requiredVersion));", "return get(scope[key][version]);" ])};`, `var findValidVersion = ${runtimeTemplate.basicFunction("scope, key, requiredVersion", [ "var versions = scope[key];", `var key = Object.keys(versions).reduce(${runtimeTemplate.basicFunction("a, b", [ "if (!satisfy(requiredVersion, b)) return a;", "return !a || versionLt(a, b) ? b : a;" ])}, 0);`, "return key && versions[key]" ])};`, `var getInvalidVersionMessage = ${runtimeTemplate.basicFunction("scope, scopeName, key, requiredVersion", [ "var versions = scope[key];", 'return "No satisfying version (" + rangeToString(requiredVersion) + ") of shared module " + key + " found in shared scope " + scopeName + ".\\n" +', `\t"Available versions: " + Object.keys(versions).map(${runtimeTemplate.basicFunction("key", [ 'return key + " from " + versions[key].from;' ])}).join(", ");` ])};`, `var getValidVersion = ${runtimeTemplate.basicFunction("scope, scopeName, key, requiredVersion", [ "var entry = findValidVersion(scope, key, requiredVersion);", "if(entry) return get(entry);", "throw new Error(getInvalidVersionMessage(scope, scopeName, key, requiredVersion));" ])};`, `var warnInvalidVersion = ${runtimeTemplate.basicFunction("scope, scopeName, key, requiredVersion", [ 'typeof console !== "undefined" && console.warn && console.warn(getInvalidVersionMessage(scope, scopeName, key, requiredVersion));' ])};`, `var get = ${runtimeTemplate.basicFunction("entry", [ "entry.loaded = 1;", "return entry.get()" ])};`, `var init = ${runtimeTemplate.returningFunction(Template.asString([ "function(scopeName, a, b, c) {", Template.indent([ `var promise = ${RuntimeGlobals.initializeSharing}(scopeName);`, `if (promise && promise.then) return promise.then(fn.bind(fn, scopeName, ${RuntimeGlobals.shareScopeMap}[scopeName], a, b, c));`, `return fn(scopeName, ${RuntimeGlobals.shareScopeMap}[scopeName], a, b, c);` ]), "}" ]), "fn")};`, "", `var load = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key", [ "ensureExistence(scopeName, key);", "return get(findVersion(scope, key));" ])});`, `var loadFallback = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, fallback", [ `return scope && ${RuntimeGlobals.hasOwnProperty}(scope, key) ? get(findVersion(scope, key)) : fallback();` ])});`, `var loadVersionCheck = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version", [ "ensureExistence(scopeName, key);", "return get(findValidVersion(scope, key, version) || warnInvalidVersion(scope, scopeName, key, version) || findVersion(scope, key));" ])});`, `var loadSingleton = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key", [ "ensureExistence(scopeName, key);", "return getSingleton(scope, scopeName, key);" ])});`, `var loadSingletonVersionCheck = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version", [ "ensureExistence(scopeName, key);", "return getSingletonVersion(scope, scopeName, key, version);" ])});`, `var loadStrictVersionCheck = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version", [ "ensureExistence(scopeName, key);", "return getValidVersion(scope, scopeName, key, version);" ])});`, `var loadStrictSingletonVersionCheck = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version", [ "ensureExistence(scopeName, key);", "return getStrictSingletonVersion(scope, scopeName, key, version);" ])});`, `var loadVersionCheckFallback = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version, fallback", [ `if(!scope || !${RuntimeGlobals.hasOwnProperty}(scope, key)) return fallback();`, "return get(findValidVersion(scope, key, version) || warnInvalidVersion(scope, scopeName, key, version) || findVersion(scope, key));" ])});`, `var loadSingletonFallback = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, fallback", [ `if(!scope || !${RuntimeGlobals.hasOwnProperty}(scope, key)) return fallback();`, "return getSingleton(scope, scopeName, key);" ])});`, `var loadSingletonVersionCheckFallback = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version, fallback", [ `if(!scope || !${RuntimeGlobals.hasOwnProperty}(scope, key)) return fallback();`, "return getSingletonVersion(scope, scopeName, key, version);" ])});`, `var loadStrictVersionCheckFallback = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version, fallback", [ `var entry = scope && ${RuntimeGlobals.hasOwnProperty}(scope, key) && findValidVersion(scope, key, version);`, "return entry ? get(entry) : fallback();" ])});`, `var loadStrictSingletonVersionCheckFallback = /*#__PURE__*/ init(${runtimeTemplate.basicFunction("scopeName, scope, key, version, fallback", [ `if(!scope || !${RuntimeGlobals.hasOwnProperty}(scope, key)) return fallback();`, "return getStrictSingletonVersion(scope, scopeName, key, version);" ])});`, "var installedModules = {};", "var moduleToHandlerMapping = {", Template.indent(Array.from(moduleIdToSourceMapping, (([key, source]) => `${JSON.stringify(key)}: ${source.source()}`)).join(",\n")), "};", initialConsumes.length > 0 ? Template.asString([ `var initialConsumes = ${JSON.stringify(initialConsumes)};`, `initialConsumes.forEach(${runtimeTemplate.basicFunction("id", [ `${RuntimeGlobals.moduleFactories}[id] = ${runtimeTemplate.basicFunction("module", [ "// Handle case when module is used sync", "installedModules[id] = 0;", `delete ${RuntimeGlobals.moduleCache}[id];`, "var factory = moduleToHandlerMapping[id]();", 'if(typeof factory !== "function") throw new Error("Shared module is not available for eager consumption: " + id);', "module.exports = factory();" ])}` ])});` ]) : "// no consumes in initial chunks", this._runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers) ? Template.asString([ `var chunkMapping = ${JSON.stringify(chunkToModuleMapping, null, "\t")};`, `${RuntimeGlobals.ensureChunkHandlers}.consumes = ${runtimeTemplate.basicFunction("chunkId, promises", [ `if(${RuntimeGlobals.hasOwnProperty}(chunkMapping, chunkId)) {`, Template.indent([ `chunkMapping[chunkId].forEach(${runtimeTemplate.basicFunction("id", [ `if(${RuntimeGlobals.hasOwnProperty}(installedModules, id)) return promises.push(installedModules[id]);`, `var onFactory = ${runtimeTemplate.basicFunction("factory", [ "installedModules[id] = 0;", `${RuntimeGlobals.moduleFactories}[id] = ${runtimeTemplate.basicFunction("module", [ `delete ${RuntimeGlobals.moduleCache}[id];`, "module.exports = factory();" ])}` ])};`, `var onError = ${runtimeTemplate.basicFunction("error", [ "delete installedModules[id];", `${RuntimeGlobals.moduleFactories}[id] = ${runtimeTemplate.basicFunction("module", [ `delete ${RuntimeGlobals.moduleCache}[id];`, "throw error;" ])}` ])};`, "try {", Template.indent([ "var promise = moduleToHandlerMapping[id]();", "if(promise.then) {", Template.indent("promises.push(installedModules[id] = promise.then(onFactory)['catch'](onError));"), "} else onFactory(promise);" ]), "} catch(e) { onError(e); }" ])});` ]), "}" ])}` ]) : "// no chunk loading of consumes" ]);
}
};
},
13720: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleDependency = __webpack_require__(15216), makeSerializable = __webpack_require__(45898);
class ProvideForSharedDependency extends ModuleDependency {
constructor(request) {
super(request);
}
get type() {
return "provide module for shared";
}
get category() {
return "esm";
}
}
makeSerializable(ProvideForSharedDependency, "webpack/lib/sharing/ProvideForSharedDependency"), 
module.exports = ProvideForSharedDependency;
},
70631: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Dependency = __webpack_require__(14926), makeSerializable = __webpack_require__(45898);
class ProvideSharedDependency extends Dependency {
constructor(shareScope, name, version, request, eager) {
super(), this.shareScope = shareScope, this.name = name, this.version = version, 
this.request = request, this.eager = eager;
}
get type() {
return "provide shared module";
}
getResourceIdentifier() {
return `provide module (${this.shareScope}) ${this.request} as ${this.name} @ ${this.version}${this.eager ? " (eager)" : ""}`;
}
serialize(context) {
context.write(this.shareScope), context.write(this.name), context.write(this.request), 
context.write(this.version), context.write(this.eager), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new ProvideSharedDependency(read(), read(), read(), read(), read());
return this.shareScope = context.read(), obj.deserialize(context), obj;
}
}
makeSerializable(ProvideSharedDependency, "webpack/lib/sharing/ProvideSharedDependency"), 
module.exports = ProvideSharedDependency;
},
96652: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const AsyncDependenciesBlock = __webpack_require__(89353), Module = __webpack_require__(36797), RuntimeGlobals = __webpack_require__(50980), makeSerializable = __webpack_require__(45898), ProvideForSharedDependency = __webpack_require__(13720), TYPES = new Set([ "share-init" ]);
class ProvideSharedModule extends Module {
constructor(shareScope, name, version, request, eager) {
super("provide-module"), this._shareScope = shareScope, this._name = name, this._version = version, 
this._request = request, this._eager = eager;
}
identifier() {
return `provide module (${this._shareScope}) ${this._name}@${this._version} = ${this._request}`;
}
readableIdentifier(requestShortener) {
return `provide shared module (${this._shareScope}) ${this._name}@${this._version} = ${requestShortener.shorten(this._request)}`;
}
libIdent(options) {
return `${this.layer ? `(${this.layer})/` : ""}webpack/sharing/provide/${this._shareScope}/${this._name}`;
}
needBuild(context, callback) {
callback(null, !this.buildInfo);
}
build(options, compilation, resolver, fs, callback) {
this.buildMeta = {}, this.buildInfo = {
strict: !0
}, this.clearDependenciesAndBlocks();
const dep = new ProvideForSharedDependency(this._request);
if (this._eager) this.addDependency(dep); else {
const block = new AsyncDependenciesBlock({});
block.addDependency(dep), this.addBlock(block);
}
callback();
}
size(type) {
return 42;
}
getSourceTypes() {
return TYPES;
}
codeGeneration({runtimeTemplate, moduleGraph, chunkGraph}) {
const runtimeRequirements = new Set([ RuntimeGlobals.initializeSharing ]), code = `register(${JSON.stringify(this._name)}, ${JSON.stringify(this._version || "0")}, ${this._eager ? runtimeTemplate.syncModuleFactory({
dependency: this.dependencies[0],
chunkGraph,
request: this._request,
runtimeRequirements
}) : runtimeTemplate.asyncModuleFactory({
block: this.blocks[0],
chunkGraph,
request: this._request,
runtimeRequirements
})}${this._eager ? ", 1" : ""});`, sources = new Map, data = new Map;
return data.set("share-init", [ {
shareScope: this._shareScope,
initStage: 10,
init: code
} ]), {
sources,
data,
runtimeRequirements
};
}
serialize(context) {
const {write} = context;
write(this._shareScope), write(this._name), write(this._version), write(this._request), 
write(this._eager), super.serialize(context);
}
static deserialize(context) {
const {read} = context, obj = new ProvideSharedModule(read(), read(), read(), read(), read());
return obj.deserialize(context), obj;
}
}
makeSerializable(ProvideSharedModule, "webpack/lib/sharing/ProvideSharedModule"), 
module.exports = ProvideSharedModule;
},
42228: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ModuleFactory = __webpack_require__(37019), ProvideSharedModule = __webpack_require__(96652);
module.exports = class extends ModuleFactory {
create(data, callback) {
const dep = data.dependencies[0];
callback(null, {
module: new ProvideSharedModule(dep.shareScope, dep.name, dep.version, dep.request, dep.eager)
});
}
};
},
83685: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326), {parseOptions} = __webpack_require__(20912), createSchemaValidation = __webpack_require__(59586), ProvideForSharedDependency = __webpack_require__(13720), ProvideSharedDependency = __webpack_require__(70631), ProvideSharedModuleFactory = __webpack_require__(42228), validate = createSchemaValidation(__webpack_require__(34355), (() => __webpack_require__(97295)), {
name: "Provide Shared Plugin",
baseDataPath: "options"
});
module.exports = class {
constructor(options) {
validate(options), this._provides = parseOptions(options.provides, (item => {
if (Array.isArray(item)) throw new Error("Unexpected array of provides");
return {
shareKey: item,
version: void 0,
shareScope: options.shareScope || "default",
eager: !1
};
}), (item => ({
shareKey: item.shareKey,
version: item.version,
shareScope: item.shareScope || options.shareScope || "default",
eager: !!item.eager
}))), this._provides.sort((([a], [b]) => a < b ? -1 : b < a ? 1 : 0));
}
apply(compiler) {
const compilationData = new WeakMap;
compiler.hooks.compilation.tap("ProvideSharedPlugin", ((compilation, {normalModuleFactory}) => {
const resolvedProvideMap = new Map, matchProvides = new Map, prefixMatchProvides = new Map;
for (const [request, config] of this._provides) /^(\/|[A-Za-z]:\\|\\\\|\.\.?(\/|$))/.test(request) || /^(\/|[A-Za-z]:\\|\\\\)/.test(request) ? resolvedProvideMap.set(request, {
config,
version: config.version
}) : request.endsWith("/") ? prefixMatchProvides.set(request, config) : matchProvides.set(request, config);
compilationData.set(compilation, resolvedProvideMap);
const provideSharedModule = (key, config, resource, resourceResolveData) => {
let version = config.version;
if (void 0 === version) {
let details = "";
if (resourceResolveData) {
const descriptionFileData = resourceResolveData.descriptionFileData;
descriptionFileData ? descriptionFileData.version ? version = descriptionFileData.version : details = `No version in description file (usually package.json). Add version to description file ${resourceResolveData.descriptionFilePath}, or manually specify version in shared config.` : details = "No description file (usually package.json) found. Add description file with name and version, or manually specify version in shared config.";
} else details = "No resolve data provided from resolver.";
if (!version) {
const error = new WebpackError(`No version specified and unable to automatically determine one. ${details}`);
error.file = `shared module ${key} -> ${resource}`, compilation.warnings.push(error);
}
}
resolvedProvideMap.set(resource, {
config,
version
});
};
normalModuleFactory.hooks.module.tap("ProvideSharedPlugin", ((module, {resource, resourceResolveData}, resolveData) => {
if (resolvedProvideMap.has(resource)) return module;
const {request} = resolveData;
{
const config = matchProvides.get(request);
void 0 !== config && (provideSharedModule(request, config, resource, resourceResolveData), 
resolveData.cacheable = !1);
}
for (const [prefix, config] of prefixMatchProvides) if (request.startsWith(prefix)) {
const remainder = request.slice(prefix.length);
provideSharedModule(resource, {
...config,
shareKey: config.shareKey + remainder
}, resource, resourceResolveData), resolveData.cacheable = !1;
}
return module;
}));
})), compiler.hooks.finishMake.tapPromise("ProvideSharedPlugin", (compilation => {
const resolvedProvideMap = compilationData.get(compilation);
return resolvedProvideMap ? Promise.all(Array.from(resolvedProvideMap, (([resource, {config, version}]) => new Promise(((resolve, reject) => {
compilation.addInclude(compiler.context, new ProvideSharedDependency(config.shareScope, config.shareKey, version || !1, resource, config.eager), {
name: void 0
}, (err => {
if (err) return reject(err);
resolve();
}));
}))))).then((() => {})) : Promise.resolve();
})), compiler.hooks.compilation.tap("ProvideSharedPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(ProvideForSharedDependency, normalModuleFactory), 
compilation.dependencyFactories.set(ProvideSharedDependency, new ProvideSharedModuleFactory);
}));
}
};
},
5979: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {parseOptions} = __webpack_require__(20912), ConsumeSharedPlugin = __webpack_require__(86075), ProvideSharedPlugin = __webpack_require__(83685), {isRequiredVersion} = __webpack_require__(57480);
module.exports = class {
constructor(options) {
const sharedOptions = parseOptions(options.shared, ((item, key) => {
if ("string" != typeof item) throw new Error("Unexpected array in shared");
return item !== key && isRequiredVersion(item) ? {
import: key,
requiredVersion: item
} : {
import: item
};
}), (item => item)), consumes = sharedOptions.map((([key, options]) => ({
[key]: {
import: options.import,
shareKey: options.shareKey || key,
shareScope: options.shareScope,
requiredVersion: options.requiredVersion,
strictVersion: options.strictVersion,
singleton: options.singleton,
packageName: options.packageName,
eager: options.eager
}
}))), provides = sharedOptions.filter((([, options]) => !1 !== options.import)).map((([key, options]) => ({
[options.import || key]: {
shareKey: options.shareKey || key,
shareScope: options.shareScope,
version: options.version,
eager: options.eager
}
})));
this._shareScope = options.shareScope, this._consumes = consumes, this._provides = provides;
}
apply(compiler) {
new ConsumeSharedPlugin({
shareScope: this._shareScope,
consumes: this._consumes
}).apply(compiler), new ProvideSharedPlugin({
shareScope: this._shareScope,
provides: this._provides
}).apply(compiler);
}
};
},
59931: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {compareModulesByIdentifier, compareStrings} = __webpack_require__(40028);
module.exports = class extends RuntimeModule {
constructor() {
super("sharing");
}
generate() {
const {compilation, chunkGraph} = this, {runtimeTemplate, codeGenerationResults, outputOptions: {uniqueName}} = compilation, initCodePerScope = new Map;
for (const chunk of this.chunk.getAllReferencedChunks()) {
const modules = chunkGraph.getOrderedChunkModulesIterableBySourceType(chunk, "share-init", compareModulesByIdentifier);
if (modules) for (const m of modules) {
const data = codeGenerationResults.getData(m, chunk.runtime, "share-init");
if (data) for (const item of data) {
const {shareScope, initStage, init} = item;
let stages = initCodePerScope.get(shareScope);
void 0 === stages && initCodePerScope.set(shareScope, stages = new Map);
let list = stages.get(initStage || 0);
void 0 === list && stages.set(initStage || 0, list = new Set), list.add(init);
}
}
}
return Template.asString([ `${RuntimeGlobals.shareScopeMap} = {};`, "var initPromises = {};", "var initTokens = {};", `${RuntimeGlobals.initializeSharing} = ${runtimeTemplate.basicFunction("name, initScope", [ "if(!initScope) initScope = [];", "// handling circular init calls", "var initToken = initTokens[name];", "if(!initToken) initToken = initTokens[name] = {};", "if(initScope.indexOf(initToken) >= 0) return;", "initScope.push(initToken);", "// only runs once", "if(initPromises[name]) return initPromises[name];", "// creates a new share scope if needed", `if(!${RuntimeGlobals.hasOwnProperty}(${RuntimeGlobals.shareScopeMap}, name)) ${RuntimeGlobals.shareScopeMap}[name] = {};`, "// runs all init snippets from all modules reachable", `var scope = ${RuntimeGlobals.shareScopeMap}[name];`, `var warn = ${runtimeTemplate.returningFunction('typeof console !== "undefined" && console.warn && console.warn(msg)', "msg")};`, `var uniqueName = ${JSON.stringify(uniqueName || void 0)};`, `var register = ${runtimeTemplate.basicFunction("name, version, factory, eager", [ "var versions = scope[name] = scope[name] || {};", "var activeVersion = versions[version];", "if(!activeVersion || (!activeVersion.loaded && (!eager != !activeVersion.eager ? eager : uniqueName > activeVersion.from))) versions[version] = { get: factory, from: uniqueName, eager: !!eager };" ])};`, `var initExternal = ${runtimeTemplate.basicFunction("id", [ `var handleError = ${runtimeTemplate.expressionFunction('warn("Initialization of sharing external failed: " + err)', "err")};`, "try {", Template.indent([ "var module = __webpack_require__(id);", "if(!module) return;", `var initFn = ${runtimeTemplate.returningFunction(`module && module.init && module.init(${RuntimeGlobals.shareScopeMap}[name], initScope)`, "module")}`, "if(module.then) return promises.push(module.then(initFn, handleError));", "var initResult = initFn(module);", "if(initResult && initResult.then) return promises.push(initResult['catch'](handleError));" ]), "} catch(err) { handleError(err); }" ])}`, "var promises = [];", "switch(name) {", ...Array.from(initCodePerScope).sort((([a], [b]) => compareStrings(a, b))).map((([name, stages]) => Template.indent([ `case ${JSON.stringify(name)}: {`, Template.indent(Array.from(stages).sort((([a], [b]) => a - b)).map((([, initCode]) => Template.asString(Array.from(initCode))))), "}", "break;" ]))), "}", "if(!promises.length) return initPromises[name] = 1;", `return initPromises[name] = Promise.all(promises).then(${runtimeTemplate.returningFunction("initPromises[name] = 1")});` ])};` ]);
}
};
},
81657: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const ModuleNotFoundError = __webpack_require__(98674), LazySet = __webpack_require__(92585), RESOLVE_OPTIONS = {
dependencyType: "esm"
};
exports.resolveMatchedConfigs = (compilation, configs) => {
const resolved = new Map, unresolved = new Map, prefixed = new Map, resolveContext = {
fileDependencies: new LazySet,
contextDependencies: new LazySet,
missingDependencies: new LazySet
}, resolver = compilation.resolverFactory.get("normal", RESOLVE_OPTIONS), context = compilation.compiler.context;
return Promise.all(configs.map((([request, config]) => {
if (/^\.\.?(\/|$)/.test(request)) return new Promise((resolve => {
resolver.resolve({}, context, request, resolveContext, ((err, result) => {
if (err || !1 === result) return err = err || new Error(`Can't resolve ${request}`), 
compilation.errors.push(new ModuleNotFoundError(null, err, {
name: `shared module ${request}`
})), resolve();
resolved.set(result, config), resolve();
}));
}));
/^(\/|[A-Za-z]:\\|\\\\)/.test(request) ? resolved.set(request, config) : request.endsWith("/") ? prefixed.set(request, config) : unresolved.set(request, config);
}))).then((() => (compilation.contextDependencies.addAll(resolveContext.contextDependencies), 
compilation.fileDependencies.addAll(resolveContext.fileDependencies), compilation.missingDependencies.addAll(resolveContext.missingDependencies), 
{
resolved,
unresolved,
prefixed
})));
};
},
57480: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const {join, dirname, readJson} = __webpack_require__(57075);
exports.isRequiredVersion = str => /^([\d^=v<>~]|[*xX]$)/.test(str);
const getDescriptionFile = (fs, directory, descriptionFiles, callback) => {
let i = 0;
const tryLoadCurrent = () => {
if (i >= descriptionFiles.length) {
const parentDirectory = dirname(fs, directory);
return parentDirectory && parentDirectory !== directory ? getDescriptionFile(fs, parentDirectory, descriptionFiles, callback) : callback();
}
const filePath = join(fs, directory, descriptionFiles[i]);
readJson(fs, filePath, ((err, data) => err ? "code" in err && "ENOENT" === err.code ? (i++, 
tryLoadCurrent()) : callback(err) : !data || "object" != typeof data || Array.isArray(data) ? callback(new Error(`Description file ${filePath} is not an object`)) : void callback(null, {
data,
path: filePath
})));
};
tryLoadCurrent();
};
exports.getDescriptionFile = getDescriptionFile, exports.getRequiredVersionFromDescriptionFile = (data, packageName) => data.optionalDependencies && "object" == typeof data.optionalDependencies && packageName in data.optionalDependencies ? data.optionalDependencies[packageName] : data.dependencies && "object" == typeof data.dependencies && packageName in data.dependencies ? data.dependencies[packageName] : data.peerDependencies && "object" == typeof data.peerDependencies && packageName in data.peerDependencies ? data.peerDependencies[packageName] : data.devDependencies && "object" == typeof data.devDependencies && packageName in data.devDependencies ? data.devDependencies[packageName] : void 0;
},
41860: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), ModuleDependency = __webpack_require__(15216), formatLocation = __webpack_require__(78509), {LogType} = __webpack_require__(20097), AggressiveSplittingPlugin = __webpack_require__(10085), SizeLimitsPlugin = __webpack_require__(16725), {countIterable} = __webpack_require__(30416), {compareLocations, compareChunksById, compareNumbers, compareIds, concatComparators, compareSelect, compareModulesByIdentifier} = __webpack_require__(40028), {makePathsRelative, parseResource} = __webpack_require__(63264), uniqueArray = (items, selector) => {
const set = new Set;
for (const item of items) for (const i of selector(item)) set.add(i);
return Array.from(set);
}, uniqueOrderedArray = (items, selector, comparator) => uniqueArray(items, selector).sort(comparator), mapObject = (obj, fn) => {
const newObj = Object.create(null);
for (const key of Object.keys(obj)) newObj[key] = fn(obj[key], key);
return newObj;
}, countWithChildren = (compilation, getItems) => {
let count = getItems(compilation, "").length;
for (const child of compilation.children) count += countWithChildren(child, ((c, type) => getItems(c, `.children[].compilation${type}`)));
return count;
}, EXTRACT_ERROR = {
_: (object, error, context, {requestShortener}) => {
"string" == typeof error ? object.message = error : (error.chunk && (object.chunkName = error.chunk.name, 
object.chunkEntry = error.chunk.hasRuntime(), object.chunkInitial = error.chunk.canBeInitial()), 
error.file && (object.file = error.file), error.module && (object.moduleIdentifier = error.module.identifier(), 
object.moduleName = error.module.readableIdentifier(requestShortener)), error.loc && (object.loc = formatLocation(error.loc)), 
object.message = error.message);
},
ids: (object, error, {compilation: {chunkGraph}}) => {
"string" != typeof error && (error.chunk && (object.chunkId = error.chunk.id), error.module && (object.moduleId = chunkGraph.getModuleId(error.module)));
},
moduleTrace: (object, error, context, options, factory) => {
if ("string" != typeof error && error.module) {
const {type, compilation: {moduleGraph}} = context, visitedModules = new Set, moduleTrace = [];
let current = error.module;
for (;current && !visitedModules.has(current); ) {
visitedModules.add(current);
const origin = moduleGraph.getIssuer(current);
if (!origin) break;
moduleTrace.push({
origin,
module: current
}), current = origin;
}
object.moduleTrace = factory.create(`${type}.moduleTrace`, moduleTrace, context);
}
},
errorDetails: (object, error, {type, compilation, cachedGetErrors, cachedGetWarnings}, {errorDetails}) => {
"string" != typeof error && (!0 === errorDetails || type.endsWith(".error") && cachedGetErrors(compilation).length < 3) && (object.details = error.details);
},
errorStack: (object, error) => {
"string" != typeof error && (object.stack = error.stack);
}
}, SIMPLE_EXTRACTORS = {
compilation: {
_: (object, compilation, context, options) => {
if (context.makePathsRelative || (context.makePathsRelative = makePathsRelative.bindContextCache(compilation.compiler.context, compilation.compiler.root)), 
!context.cachedGetErrors) {
const map = new WeakMap;
context.cachedGetErrors = compilation => {
return map.get(compilation) || (errors = compilation.getErrors(), map.set(compilation, errors), 
errors);
var errors;
};
}
if (!context.cachedGetWarnings) {
const map = new WeakMap;
context.cachedGetWarnings = compilation => {
return map.get(compilation) || (warnings = compilation.getWarnings(), map.set(compilation, warnings), 
warnings);
var warnings;
};
}
compilation.name && (object.name = compilation.name), compilation.needAdditionalPass && (object.needAdditionalPass = !0);
const {logging, loggingDebug, loggingTrace} = options;
if (logging || loggingDebug && loggingDebug.length > 0) {
const util = __webpack_require__(73837);
let acceptedTypes;
object.logging = {};
let collapsedGroups = !1;
switch (logging) {
default:
acceptedTypes = new Set;
break;

case "error":
acceptedTypes = new Set([ LogType.error ]);
break;

case "warn":
acceptedTypes = new Set([ LogType.error, LogType.warn ]);
break;

case "info":
acceptedTypes = new Set([ LogType.error, LogType.warn, LogType.info ]);
break;

case "log":
acceptedTypes = new Set([ LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.clear ]);
break;

case "verbose":
acceptedTypes = new Set([ LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.profile, LogType.profileEnd, LogType.time, LogType.status, LogType.clear ]), 
collapsedGroups = !0;
}
const cachedMakePathsRelative = makePathsRelative.bindContextCache(options.context, compilation.compiler.root);
let depthInCollapsedGroup = 0;
for (const [origin, logEntries] of compilation.logging) {
const debugMode = loggingDebug.some((fn => fn(origin)));
if (!1 === logging && !debugMode) continue;
const groupStack = [], rootList = [];
let currentList = rootList, processedLogEntries = 0;
for (const entry of logEntries) {
let message, type = entry.type;
if (!debugMode && !acceptedTypes.has(type)) continue;
if (type === LogType.groupCollapsed && (debugMode || collapsedGroups) && (type = LogType.group), 
0 === depthInCollapsedGroup && processedLogEntries++, type === LogType.groupEnd) {
groupStack.pop(), currentList = groupStack.length > 0 ? groupStack[groupStack.length - 1].children : rootList, 
depthInCollapsedGroup > 0 && depthInCollapsedGroup--;
continue;
}
entry.type === LogType.time ? message = `${entry.args[0]}: ${1e3 * entry.args[1] + entry.args[2] / 1e6} ms` : entry.args && entry.args.length > 0 && (message = util.format(entry.args[0], ...entry.args.slice(1)));
const newEntry = {
...entry,
type,
message,
trace: loggingTrace ? entry.trace : void 0,
children: type === LogType.group || type === LogType.groupCollapsed ? [] : void 0
};
currentList.push(newEntry), newEntry.children && (groupStack.push(newEntry), currentList = newEntry.children, 
depthInCollapsedGroup > 0 ? depthInCollapsedGroup++ : type === LogType.groupCollapsed && (depthInCollapsedGroup = 1));
}
let name = cachedMakePathsRelative(origin).replace(/\|/g, " ");
if (name in object.logging) {
let i = 1;
for (;`${name}#${i}` in object.logging; ) i++;
name = `${name}#${i}`;
}
object.logging[name] = {
entries: rootList,
filteredEntries: logEntries.length - processedLogEntries,
debug: debugMode
};
}
}
},
hash: (object, compilation) => {
object.hash = compilation.hash;
},
version: object => {
object.version = __webpack_require__(37589).i8;
},
env: (object, compilation, context, {_env}) => {
object.env = _env;
},
timings: (object, compilation) => {
object.time = compilation.endTime - compilation.startTime;
},
builtAt: (object, compilation) => {
object.builtAt = compilation.endTime;
},
publicPath: (object, compilation) => {
object.publicPath = compilation.getPath(compilation.outputOptions.publicPath);
},
outputPath: (object, compilation) => {
object.outputPath = compilation.outputOptions.path;
},
assets: (object, compilation, context, options, factory) => {
const {type} = context, compilationFileToChunks = new Map, compilationAuxiliaryFileToChunks = new Map;
for (const chunk of compilation.chunks) {
for (const file of chunk.files) {
let array = compilationFileToChunks.get(file);
void 0 === array && (array = [], compilationFileToChunks.set(file, array)), array.push(chunk);
}
for (const file of chunk.auxiliaryFiles) {
let array = compilationAuxiliaryFileToChunks.get(file);
void 0 === array && (array = [], compilationAuxiliaryFileToChunks.set(file, array)), 
array.push(chunk);
}
}
const assetMap = new Map, assets = new Set;
for (const asset of compilation.getAssets()) {
const item = {
...asset,
type: "asset",
related: void 0
};
assets.add(item), assetMap.set(asset.name, item);
}
for (const item of assetMap.values()) {
const related = item.info.related;
if (related) for (const type of Object.keys(related)) {
const relatedEntry = related[type], deps = Array.isArray(relatedEntry) ? relatedEntry : [ relatedEntry ];
for (const dep of deps) {
const depItem = assetMap.get(dep);
depItem && (assets.delete(depItem), depItem.type = type, item.related = item.related || [], 
item.related.push(depItem));
}
}
}
object.assetsByChunkName = {};
for (const [file, chunks] of compilationFileToChunks) for (const chunk of chunks) {
const name = chunk.name;
name && (Object.prototype.hasOwnProperty.call(object.assetsByChunkName, name) || (object.assetsByChunkName[name] = []), 
object.assetsByChunkName[name].push(file));
}
const groupedAssets = factory.create(`${type}.assets`, Array.from(assets), {
...context,
compilationFileToChunks,
compilationAuxiliaryFileToChunks
}), limited = spaceLimited(groupedAssets, options.assetsSpace);
object.assets = limited.children, object.filteredAssets = limited.filteredChildren;
},
chunks: (object, compilation, context, options, factory) => {
const {type} = context;
object.chunks = factory.create(`${type}.chunks`, Array.from(compilation.chunks), context);
},
modules: (object, compilation, context, options, factory) => {
const {type} = context, array = Array.from(compilation.modules), groupedModules = factory.create(`${type}.modules`, array, context), limited = spaceLimited(groupedModules, options.modulesSpace);
object.modules = limited.children, object.filteredModules = limited.filteredChildren;
},
entrypoints: (object, compilation, context, {entrypoints, chunkGroups, chunkGroupAuxiliary, chunkGroupChildren}, factory) => {
const {type} = context, array = Array.from(compilation.entrypoints, (([key, value]) => ({
name: key,
chunkGroup: value
})));
if ("auto" === entrypoints && !chunkGroups) {
if (array.length > 5) return;
if (!chunkGroupChildren && array.every((({chunkGroup}) => {
if (1 !== chunkGroup.chunks.length) return !1;
const chunk = chunkGroup.chunks[0];
return 1 === chunk.files.size && (!chunkGroupAuxiliary || 0 === chunk.auxiliaryFiles.size);
}))) return;
}
object.entrypoints = factory.create(`${type}.entrypoints`, array, context);
},
chunkGroups: (object, compilation, context, options, factory) => {
const {type} = context, array = Array.from(compilation.namedChunkGroups, (([key, value]) => ({
name: key,
chunkGroup: value
})));
object.namedChunkGroups = factory.create(`${type}.namedChunkGroups`, array, context);
},
errors: (object, compilation, context, options, factory) => {
const {type, cachedGetErrors} = context;
object.errors = factory.create(`${type}.errors`, cachedGetErrors(compilation), context);
},
errorsCount: (object, compilation, {cachedGetErrors}) => {
object.errorsCount = countWithChildren(compilation, (c => cachedGetErrors(c)));
},
warnings: (object, compilation, context, options, factory) => {
const {type, cachedGetWarnings} = context;
object.warnings = factory.create(`${type}.warnings`, cachedGetWarnings(compilation), context);
},
warningsCount: (object, compilation, context, {warningsFilter}, factory) => {
const {type, cachedGetWarnings} = context;
object.warningsCount = countWithChildren(compilation, ((c, childType) => warningsFilter || 0 !== warningsFilter.length ? factory.create(`${type}${childType}.warnings`, cachedGetWarnings(c), context).filter((warning => {
const warningString = Object.keys(warning).map((key => `${warning[key]}`)).join("\n");
return !warningsFilter.some((filter => filter(warning, warningString)));
})) : cachedGetWarnings(c)));
},
errorDetails: (object, compilation, {cachedGetErrors, cachedGetWarnings}, {errorDetails, errors, warnings}) => {
if ("auto" === errorDetails) {
if (warnings) {
const warnings = cachedGetWarnings(compilation);
object.filteredWarningDetailsCount = warnings.map((e => "string" != typeof e && e.details)).filter(Boolean).length;
}
if (errors) {
const errors = cachedGetErrors(compilation);
errors.length >= 3 && (object.filteredErrorDetailsCount = errors.map((e => "string" != typeof e && e.details)).filter(Boolean).length);
}
}
},
children: (object, compilation, context, options, factory) => {
const {type} = context;
object.children = factory.create(`${type}.children`, compilation.children, context);
}
},
asset: {
_: (object, asset, context, options, factory) => {
const {compilation} = context;
object.type = asset.type, object.name = asset.name, object.size = asset.source.size(), 
object.emitted = compilation.emittedAssets.has(asset.name), object.comparedForEmit = compilation.comparedForEmitAssets.has(asset.name);
const cached = !object.emitted && !object.comparedForEmit;
object.cached = cached, object.info = asset.info, cached && !options.cachedAssets || Object.assign(object, factory.create(`${context.type}$visible`, asset, context));
}
},
asset$visible: {
_: (object, asset, {compilation, compilationFileToChunks, compilationAuxiliaryFileToChunks}) => {
const chunks = compilationFileToChunks.get(asset.name) || [], auxiliaryChunks = compilationAuxiliaryFileToChunks.get(asset.name) || [];
object.chunkNames = uniqueOrderedArray(chunks, (c => c.name ? [ c.name ] : []), compareIds), 
object.chunkIdHints = uniqueOrderedArray(chunks, (c => Array.from(c.idNameHints)), compareIds), 
object.auxiliaryChunkNames = uniqueOrderedArray(auxiliaryChunks, (c => c.name ? [ c.name ] : []), compareIds), 
object.auxiliaryChunkIdHints = uniqueOrderedArray(auxiliaryChunks, (c => Array.from(c.idNameHints)), compareIds), 
object.filteredRelated = asset.related ? asset.related.length : void 0;
},
relatedAssets: (object, asset, context, options, factory) => {
const {type} = context;
object.related = factory.create(`${type.slice(0, -8)}.related`, asset.related, context), 
object.filteredRelated = asset.related ? asset.related.length - object.related.length : void 0;
},
ids: (object, asset, {compilationFileToChunks, compilationAuxiliaryFileToChunks}) => {
const chunks = compilationFileToChunks.get(asset.name) || [], auxiliaryChunks = compilationAuxiliaryFileToChunks.get(asset.name) || [];
object.chunks = uniqueOrderedArray(chunks, (c => c.ids), compareIds), object.auxiliaryChunks = uniqueOrderedArray(auxiliaryChunks, (c => c.ids), compareIds);
},
performance: (object, asset) => {
object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(asset.source);
}
},
chunkGroup: {
_: (object, {name, chunkGroup}, {compilation, compilation: {moduleGraph, chunkGraph}}, {ids, chunkGroupAuxiliary, chunkGroupChildren, chunkGroupMaxAssets}) => {
const children = chunkGroupChildren && chunkGroup.getChildrenByOrders(moduleGraph, chunkGraph), toAsset = name => {
const asset = compilation.getAsset(name);
return {
name,
size: asset ? asset.info.size : -1
};
}, sizeReducer = (total, {size}) => total + size, assets = uniqueArray(chunkGroup.chunks, (c => c.files)).map(toAsset), auxiliaryAssets = uniqueOrderedArray(chunkGroup.chunks, (c => c.auxiliaryFiles), compareIds).map(toAsset), assetsSize = assets.reduce(sizeReducer, 0), auxiliaryAssetsSize = auxiliaryAssets.reduce(sizeReducer, 0), statsChunkGroup = {
name,
chunks: ids ? chunkGroup.chunks.map((c => c.id)) : void 0,
assets: assets.length <= chunkGroupMaxAssets ? assets : void 0,
filteredAssets: assets.length <= chunkGroupMaxAssets ? 0 : assets.length,
assetsSize,
auxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? auxiliaryAssets : void 0,
filteredAuxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? 0 : auxiliaryAssets.length,
auxiliaryAssetsSize,
children: children ? mapObject(children, (groups => groups.map((group => {
const assets = uniqueArray(group.chunks, (c => c.files)).map(toAsset), auxiliaryAssets = uniqueOrderedArray(group.chunks, (c => c.auxiliaryFiles), compareIds).map(toAsset);
return {
name: group.name,
chunks: ids ? group.chunks.map((c => c.id)) : void 0,
assets: assets.length <= chunkGroupMaxAssets ? assets : void 0,
filteredAssets: assets.length <= chunkGroupMaxAssets ? 0 : assets.length,
auxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? auxiliaryAssets : void 0,
filteredAuxiliaryAssets: chunkGroupAuxiliary && auxiliaryAssets.length <= chunkGroupMaxAssets ? 0 : auxiliaryAssets.length
};
})))) : void 0,
childAssets: children ? mapObject(children, (groups => {
const set = new Set;
for (const group of groups) for (const chunk of group.chunks) for (const asset of chunk.files) set.add(asset);
return Array.from(set);
})) : void 0
};
Object.assign(object, statsChunkGroup);
},
performance: (object, {chunkGroup}) => {
object.isOverSizeLimit = SizeLimitsPlugin.isOverSizeLimit(chunkGroup);
}
},
module: {
_: (object, module, context, options, factory) => {
const {compilation, type} = context, built = compilation.builtModules.has(module), codeGenerated = compilation.codeGeneratedModules.has(module), buildTimeExecuted = compilation.buildTimeExecutedModules.has(module), sizes = {};
for (const sourceType of module.getSourceTypes()) sizes[sourceType] = module.size(sourceType);
const statsModule = {
type: "module",
moduleType: module.type,
layer: module.layer,
size: module.size(),
sizes,
built,
codeGenerated,
buildTimeExecuted,
cached: !built && !codeGenerated
};
Object.assign(object, statsModule), (built || codeGenerated || options.cachedModules) && Object.assign(object, factory.create(`${type}$visible`, module, context));
}
},
module$visible: {
_: (object, module, context, {requestShortener}, factory) => {
const {compilation, type, rootModules} = context, {moduleGraph} = compilation, path = [], issuer = moduleGraph.getIssuer(module);
let current = issuer;
for (;current; ) path.push(current), current = moduleGraph.getIssuer(current);
path.reverse();
const profile = moduleGraph.getProfile(module), errors = module.getErrors(), errorsCount = void 0 !== errors ? countIterable(errors) : 0, warnings = module.getWarnings(), warningsCount = void 0 !== warnings ? countIterable(warnings) : 0, sizes = {};
for (const sourceType of module.getSourceTypes()) sizes[sourceType] = module.size(sourceType);
const statsModule = {
identifier: module.identifier(),
name: module.readableIdentifier(requestShortener),
nameForCondition: module.nameForCondition(),
index: moduleGraph.getPreOrderIndex(module),
preOrderIndex: moduleGraph.getPreOrderIndex(module),
index2: moduleGraph.getPostOrderIndex(module),
postOrderIndex: moduleGraph.getPostOrderIndex(module),
cacheable: module.buildInfo.cacheable,
optional: module.isOptional(moduleGraph),
orphan: !type.endsWith("module.modules[].module$visible") && 0 === compilation.chunkGraph.getNumberOfModuleChunks(module),
dependent: rootModules ? !rootModules.has(module) : void 0,
issuer: issuer && issuer.identifier(),
issuerName: issuer && issuer.readableIdentifier(requestShortener),
issuerPath: issuer && factory.create(`${type.slice(0, -8)}.issuerPath`, path, context),
failed: errorsCount > 0,
errors: errorsCount,
warnings: warningsCount
};
Object.assign(object, statsModule), profile && (object.profile = factory.create(`${type.slice(0, -8)}.profile`, profile, context));
},
ids: (object, module, {compilation: {chunkGraph, moduleGraph}}) => {
object.id = chunkGraph.getModuleId(module);
const issuer = moduleGraph.getIssuer(module);
object.issuerId = issuer && chunkGraph.getModuleId(issuer), object.chunks = Array.from(chunkGraph.getOrderedModuleChunksIterable(module, compareChunksById), (chunk => chunk.id));
},
moduleAssets: (object, module) => {
object.assets = module.buildInfo.assets ? Object.keys(module.buildInfo.assets) : [];
},
reasons: (object, module, context, options, factory) => {
const {type, compilation: {moduleGraph}} = context, groupsReasons = factory.create(`${type.slice(0, -8)}.reasons`, Array.from(moduleGraph.getIncomingConnections(module)), context), limited = spaceLimited(groupsReasons, options.reasonsSpace);
object.reasons = limited.children, object.filteredReasons = limited.filteredChildren;
},
usedExports: (object, module, {runtime, compilation: {moduleGraph}}) => {
const usedExports = moduleGraph.getUsedExports(module, runtime);
object.usedExports = null === usedExports ? null : "boolean" == typeof usedExports ? usedExports : Array.from(usedExports);
},
providedExports: (object, module, {compilation: {moduleGraph}}) => {
const providedExports = moduleGraph.getProvidedExports(module);
object.providedExports = Array.isArray(providedExports) ? providedExports : null;
},
optimizationBailout: (object, module, {compilation: {moduleGraph}}, {requestShortener}) => {
object.optimizationBailout = moduleGraph.getOptimizationBailout(module).map((item => "function" == typeof item ? item(requestShortener) : item));
},
depth: (object, module, {compilation: {moduleGraph}}) => {
object.depth = moduleGraph.getDepth(module);
},
nestedModules: (object, module, context, options, factory) => {
const {type} = context, innerModules = module.modules;
if (Array.isArray(innerModules)) {
const groupedModules = factory.create(`${type.slice(0, -8)}.modules`, innerModules, context), limited = spaceLimited(groupedModules, options.nestedModulesSpace);
object.modules = limited.children, object.filteredModules = limited.filteredChildren;
}
},
source: (object, module) => {
const originalSource = module.originalSource();
originalSource && (object.source = originalSource.source());
}
},
profile: {
_: (object, profile) => {
const statsProfile = {
total: profile.factory + profile.restoring + profile.integration + profile.building + profile.storing,
resolving: profile.factory,
restoring: profile.restoring,
building: profile.building,
integration: profile.integration,
storing: profile.storing,
additionalResolving: profile.additionalFactories,
additionalIntegration: profile.additionalIntegration,
factory: profile.factory,
dependencies: profile.additionalFactories
};
Object.assign(object, statsProfile);
}
},
moduleIssuer: {
_: (object, module, context, {requestShortener}, factory) => {
const {compilation, type} = context, {moduleGraph} = compilation, profile = moduleGraph.getProfile(module), statsModuleIssuer = {
identifier: module.identifier(),
name: module.readableIdentifier(requestShortener)
};
Object.assign(object, statsModuleIssuer), profile && (object.profile = factory.create(`${type}.profile`, profile, context));
},
ids: (object, module, {compilation: {chunkGraph}}) => {
object.id = chunkGraph.getModuleId(module);
}
},
moduleReason: {
_: (object, reason, {runtime}, {requestShortener}) => {
const dep = reason.dependency, moduleDep = dep && dep instanceof ModuleDependency ? dep : void 0, statsModuleReason = {
moduleIdentifier: reason.originModule ? reason.originModule.identifier() : null,
module: reason.originModule ? reason.originModule.readableIdentifier(requestShortener) : null,
moduleName: reason.originModule ? reason.originModule.readableIdentifier(requestShortener) : null,
resolvedModuleIdentifier: reason.resolvedOriginModule ? reason.resolvedOriginModule.identifier() : null,
resolvedModule: reason.resolvedOriginModule ? reason.resolvedOriginModule.readableIdentifier(requestShortener) : null,
type: reason.dependency ? reason.dependency.type : null,
active: reason.isActive(runtime),
explanation: reason.explanation,
userRequest: moduleDep && moduleDep.userRequest || null
};
if (Object.assign(object, statsModuleReason), reason.dependency) {
const locInfo = formatLocation(reason.dependency.loc);
locInfo && (object.loc = locInfo);
}
},
ids: (object, reason, {compilation: {chunkGraph}}) => {
object.moduleId = reason.originModule ? chunkGraph.getModuleId(reason.originModule) : null, 
object.resolvedModuleId = reason.resolvedOriginModule ? chunkGraph.getModuleId(reason.resolvedOriginModule) : null;
}
},
chunk: {
_: (object, chunk, {makePathsRelative, compilation: {chunkGraph}}) => {
const childIdByOrder = chunk.getChildIdsByOrders(chunkGraph), statsChunk = {
rendered: chunk.rendered,
initial: chunk.canBeInitial(),
entry: chunk.hasRuntime(),
recorded: AggressiveSplittingPlugin.wasChunkRecorded(chunk),
reason: chunk.chunkReason,
size: chunkGraph.getChunkModulesSize(chunk),
sizes: chunkGraph.getChunkModulesSizes(chunk),
names: chunk.name ? [ chunk.name ] : [],
idHints: Array.from(chunk.idNameHints),
runtime: void 0 === chunk.runtime ? void 0 : "string" == typeof chunk.runtime ? [ makePathsRelative(chunk.runtime) ] : Array.from(chunk.runtime.sort(), makePathsRelative),
files: Array.from(chunk.files),
auxiliaryFiles: Array.from(chunk.auxiliaryFiles).sort(compareIds),
hash: chunk.renderedHash,
childrenByOrder: childIdByOrder
};
Object.assign(object, statsChunk);
},
ids: (object, chunk) => {
object.id = chunk.id;
},
chunkRelations: (object, chunk, {compilation: {chunkGraph}}) => {
const parents = new Set, children = new Set, siblings = new Set;
for (const chunkGroup of chunk.groupsIterable) {
for (const parentGroup of chunkGroup.parentsIterable) for (const chunk of parentGroup.chunks) parents.add(chunk.id);
for (const childGroup of chunkGroup.childrenIterable) for (const chunk of childGroup.chunks) children.add(chunk.id);
for (const sibling of chunkGroup.chunks) sibling !== chunk && siblings.add(sibling.id);
}
object.siblings = Array.from(siblings).sort(compareIds), object.parents = Array.from(parents).sort(compareIds), 
object.children = Array.from(children).sort(compareIds);
},
chunkModules: (object, chunk, context, options, factory) => {
const {type, compilation: {chunkGraph}} = context, array = chunkGraph.getChunkModules(chunk), groupedModules = factory.create(`${type}.modules`, array, {
...context,
runtime: chunk.runtime,
rootModules: new Set(chunkGraph.getChunkRootModules(chunk))
}), limited = spaceLimited(groupedModules, options.chunkModulesSpace);
object.modules = limited.children, object.filteredModules = limited.filteredChildren;
},
chunkOrigins: (object, chunk, context, options, factory) => {
const {type, compilation: {chunkGraph}} = context, originsKeySet = new Set, origins = [];
for (const g of chunk.groupsIterable) origins.push(...g.origins);
const array = origins.filter((origin => {
const key = [ origin.module ? chunkGraph.getModuleId(origin.module) : void 0, formatLocation(origin.loc), origin.request ].join();
return !originsKeySet.has(key) && (originsKeySet.add(key), !0);
}));
object.origins = factory.create(`${type}.origins`, array, context);
}
},
chunkOrigin: {
_: (object, origin, context, {requestShortener}) => {
const statsChunkOrigin = {
module: origin.module ? origin.module.identifier() : "",
moduleIdentifier: origin.module ? origin.module.identifier() : "",
moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : "",
loc: formatLocation(origin.loc),
request: origin.request
};
Object.assign(object, statsChunkOrigin);
},
ids: (object, origin, {compilation: {chunkGraph}}) => {
object.moduleId = origin.module ? chunkGraph.getModuleId(origin.module) : void 0;
}
},
error: EXTRACT_ERROR,
warning: EXTRACT_ERROR,
moduleTraceItem: {
_: (object, {origin, module}, context, {requestShortener}, factory) => {
const {type, compilation: {moduleGraph}} = context;
object.originIdentifier = origin.identifier(), object.originName = origin.readableIdentifier(requestShortener), 
object.moduleIdentifier = module.identifier(), object.moduleName = module.readableIdentifier(requestShortener);
const dependencies = Array.from(moduleGraph.getIncomingConnections(module)).filter((c => c.resolvedOriginModule === origin && c.dependency)).map((c => c.dependency));
object.dependencies = factory.create(`${type}.dependencies`, Array.from(new Set(dependencies)), context);
},
ids: (object, {origin, module}, {compilation: {chunkGraph}}) => {
object.originId = chunkGraph.getModuleId(origin), object.moduleId = chunkGraph.getModuleId(module);
}
},
moduleTraceDependency: {
_: (object, dependency) => {
object.loc = formatLocation(dependency.loc);
}
}
}, FILTER = {
"module.reasons": {
"!orphanModules": (reason, {compilation: {chunkGraph}}) => {
if (reason.originModule && 0 === chunkGraph.getNumberOfModuleChunks(reason.originModule)) return !1;
}
}
}, FILTER_RESULTS = {
"compilation.warnings": {
warningsFilter: util.deprecate(((warning, context, {warningsFilter}) => {
const warningString = Object.keys(warning).map((key => `${warning[key]}`)).join("\n");
return !warningsFilter.some((filter => filter(warning, warningString)));
}), "config.stats.warningsFilter is deprecated in favor of config.ignoreWarnings", "DEP_WEBPACK_STATS_WARNINGS_FILTER")
}
}, MODULES_SORTER = {
_: (comparators, {compilation: {moduleGraph}}) => {
comparators.push(compareSelect((m => moduleGraph.getDepth(m)), compareNumbers), compareSelect((m => moduleGraph.getPreOrderIndex(m)), compareNumbers), compareSelect((m => m.identifier()), compareIds));
}
}, SORTERS = {
"compilation.chunks": {
_: comparators => {
comparators.push(compareSelect((c => c.id), compareIds));
}
},
"compilation.modules": MODULES_SORTER,
"chunk.rootModules": MODULES_SORTER,
"chunk.modules": MODULES_SORTER,
"module.modules": MODULES_SORTER,
"module.reasons": {
_: (comparators, {compilation: {chunkGraph}}) => {
comparators.push(compareSelect((x => x.originModule), compareModulesByIdentifier)), 
comparators.push(compareSelect((x => x.resolvedOriginModule), compareModulesByIdentifier)), 
comparators.push(compareSelect((x => x.dependency), concatComparators(compareSelect((x => x.loc), compareLocations), compareSelect((x => x.type), compareIds))));
}
},
"chunk.origins": {
_: (comparators, {compilation: {chunkGraph}}) => {
comparators.push(compareSelect((origin => origin.module ? chunkGraph.getModuleId(origin.module) : void 0), compareIds), compareSelect((origin => formatLocation(origin.loc)), compareIds), compareSelect((origin => origin.request), compareIds));
}
}
}, getItemSize = item => item.children ? item.filteredChildren ? 2 + getTotalSize(item.children) : 1 + getTotalSize(item.children) : 1, getTotalSize = children => {
let size = 0;
for (const child of children) size += getItemSize(child);
return size;
}, getTotalItems = children => {
let count = 0;
for (const child of children) child.children || child.filteredChildren ? (child.children && (count += getTotalItems(child.children)), 
child.filteredChildren && (count += child.filteredChildren)) : count++;
return count;
}, spaceLimited = (itemsAndGroups, max, filteredChildrenLineReserved = !1) => {
if (max < 1) return {
children: void 0,
filteredChildren: getTotalItems(itemsAndGroups)
};
let children, filteredChildren;
const groups = [], groupSizes = [], items = [];
let groupsSize = 0;
for (const itemOrGroup of itemsAndGroups) if (itemOrGroup.children || itemOrGroup.filteredChildren) {
groups.push(itemOrGroup);
const size = getItemSize(itemOrGroup);
groupSizes.push(size), groupsSize += size;
} else items.push(itemOrGroup);
if (groupsSize + items.length <= max) children = groups.length > 0 ? groups.concat(items) : items; else if (0 === groups.length) {
const limit = max - (filteredChildrenLineReserved ? 0 : 1);
filteredChildren = items.length - limit, items.length = limit, children = items;
} else {
const limit = groups.length + (filteredChildrenLineReserved || 0 === items.length ? 0 : 1);
if (limit < max) {
let oversize;
for (;(oversize = groupsSize + items.length + (filteredChildren && !filteredChildrenLineReserved ? 1 : 0) - max) > 0; ) {
const maxGroupSize = Math.max(...groupSizes);
if (maxGroupSize < items.length) filteredChildren = items.length, items.length = 0; else for (let i = 0; i < groups.length; i++) if (groupSizes[i] === maxGroupSize) {
const group = groups[i], headerSize = group.filteredChildren ? 2 : 1, limited = spaceLimited(group.children, maxGroupSize - Math.ceil(oversize / groups.length) - headerSize, 2 === headerSize);
groups[i] = {
...group,
children: limited.children,
filteredChildren: limited.filteredChildren ? (group.filteredChildren || 0) + limited.filteredChildren : group.filteredChildren
};
const newSize = getItemSize(groups[i]);
groupsSize -= maxGroupSize - newSize, groupSizes[i] = newSize;
break;
}
}
children = groups.concat(items);
} else limit === max ? (children = (children => {
const newChildren = [];
for (const child of children) if (child.children) {
let filteredChildren = child.filteredChildren || 0;
filteredChildren += getTotalItems(child.children), newChildren.push({
...child,
children: void 0,
filteredChildren
});
} else newChildren.push(child);
return newChildren;
})(groups), filteredChildren = items.length) : filteredChildren = getTotalItems(itemsAndGroups);
}
return {
children,
filteredChildren
};
}, assetGroup = (children, assets) => {
let size = 0;
for (const asset of children) size += asset.size;
return {
size
};
}, moduleGroup = (children, modules) => {
let size = 0;
const sizes = {};
for (const module of children) {
size += module.size;
for (const key of Object.keys(module.sizes)) sizes[key] = (sizes[key] || 0) + module.sizes[key];
}
return {
size,
sizes
};
}, reasonGroup = (children, reasons) => {
let active = !1;
for (const reason of children) active = active || reason.active;
return {
active
};
}, GROUP_EXTENSION_REGEXP = /(\.[^.]+?)(?:\?|(?: \+ \d+ modules?)?$)/, GROUP_PATH_REGEXP = /(.+)[/\\][^/\\]+?(?:\?|(?: \+ \d+ modules?)?$)/, ASSETS_GROUPERS = {
_: (groupConfigs, context, options) => {
const groupByFlag = (name, exclude) => {
groupConfigs.push({
getKeys: asset => asset[name] ? [ "1" ] : void 0,
getOptions: () => ({
groupChildren: !exclude,
force: exclude
}),
createGroup: (key, children, assets) => exclude ? {
type: "assets by status",
[name]: !!key,
filteredChildren: assets.length,
...assetGroup(children)
} : {
type: "assets by status",
[name]: !!key,
children,
...assetGroup(children)
}
});
}, {groupAssetsByEmitStatus, groupAssetsByPath, groupAssetsByExtension} = options;
groupAssetsByEmitStatus && (groupByFlag("emitted"), groupByFlag("comparedForEmit"), 
groupByFlag("isOverSizeLimit")), !groupAssetsByEmitStatus && options.cachedAssets || groupByFlag("cached", !options.cachedAssets), 
(groupAssetsByPath || groupAssetsByExtension) && groupConfigs.push({
getKeys: asset => {
const extensionMatch = groupAssetsByExtension && GROUP_EXTENSION_REGEXP.exec(asset.name), extension = extensionMatch ? extensionMatch[1] : "", pathMatch = groupAssetsByPath && GROUP_PATH_REGEXP.exec(asset.name), path = pathMatch ? pathMatch[1].split(/[/\\]/) : [], keys = [];
if (groupAssetsByPath) for (keys.push("."), extension && keys.push(path.length ? `${path.join("/")}/*${extension}` : `*${extension}`); path.length > 0; ) keys.push(path.join("/") + "/"), 
path.pop(); else extension && keys.push(`*${extension}`);
return keys;
},
createGroup: (key, children, assets) => ({
type: groupAssetsByPath ? "assets by path" : "assets by extension",
name: key,
children,
...assetGroup(children)
})
});
},
groupAssetsByInfo: (groupConfigs, context, options) => {
const groupByAssetInfoFlag = name => {
groupConfigs.push({
getKeys: asset => asset.info && asset.info[name] ? [ "1" ] : void 0,
createGroup: (key, children, assets) => ({
type: "assets by info",
info: {
[name]: !!key
},
children,
...assetGroup(children)
})
});
};
groupByAssetInfoFlag("immutable"), groupByAssetInfoFlag("development"), groupByAssetInfoFlag("hotModuleReplacement");
},
groupAssetsByChunk: (groupConfigs, context, options) => {
const groupByNames = name => {
groupConfigs.push({
getKeys: asset => asset[name],
createGroup: (key, children, assets) => ({
type: "assets by chunk",
[name]: [ key ],
children,
...assetGroup(children)
})
});
};
groupByNames("chunkNames"), groupByNames("auxiliaryChunkNames"), groupByNames("chunkIdHints"), 
groupByNames("auxiliaryChunkIdHints");
},
excludeAssets: (groupConfigs, context, {excludeAssets}) => {
groupConfigs.push({
getKeys: asset => {
const ident = asset.name;
if (excludeAssets.some((fn => fn(ident, asset)))) return [ "excluded" ];
},
getOptions: () => ({
groupChildren: !1,
force: !0
}),
createGroup: (key, children, assets) => ({
type: "hidden assets",
filteredChildren: assets.length,
...assetGroup(children)
})
});
}
}, MODULES_GROUPERS = type => ({
_: (groupConfigs, context, options) => {
const groupByFlag = (name, type, exclude) => {
groupConfigs.push({
getKeys: module => module[name] ? [ "1" ] : void 0,
getOptions: () => ({
groupChildren: !exclude,
force: exclude
}),
createGroup: (key, children, modules) => ({
type,
[name]: !!key,
...exclude ? {
filteredChildren: modules.length
} : {
children
},
...moduleGroup(children)
})
});
}, {groupModulesByCacheStatus, groupModulesByLayer, groupModulesByAttributes, groupModulesByType, groupModulesByPath, groupModulesByExtension} = options;
groupModulesByAttributes && (groupByFlag("errors", "modules with errors"), groupByFlag("warnings", "modules with warnings"), 
groupByFlag("assets", "modules with assets"), groupByFlag("optional", "optional modules")), 
groupModulesByCacheStatus && (groupByFlag("cacheable", "cacheable modules"), groupByFlag("built", "built modules"), 
groupByFlag("codeGenerated", "code generated modules")), !groupModulesByCacheStatus && options.cachedModules || groupByFlag("cached", "cached modules", !options.cachedModules), 
!groupModulesByAttributes && options.orphanModules || groupByFlag("orphan", "orphan modules", !options.orphanModules), 
!groupModulesByAttributes && options.dependentModules || groupByFlag("dependent", "dependent modules", !options.dependentModules), 
!groupModulesByType && options.runtimeModules || groupConfigs.push({
getKeys: module => {
if (module.moduleType) return groupModulesByType ? [ module.moduleType.split("/", 1)[0] ] : "runtime" === module.moduleType ? [ "runtime" ] : void 0;
},
getOptions: key => {
const exclude = "runtime" === key && !options.runtimeModules;
return {
groupChildren: !exclude,
force: exclude
};
},
createGroup: (key, children, modules) => ({
type: `${key} modules`,
moduleType: key,
..."runtime" === key && !options.runtimeModules ? {
filteredChildren: modules.length
} : {
children
},
...moduleGroup(children)
})
}), groupModulesByLayer && groupConfigs.push({
getKeys: module => [ module.layer ],
createGroup: (key, children, modules) => ({
type: "modules by layer",
layer: key,
children,
...moduleGroup(children)
})
}), (groupModulesByPath || groupModulesByExtension) && groupConfigs.push({
getKeys: module => {
if (!module.name) return;
const resource = parseResource(module.name.split("!").pop()).path, dataUrl = /^data:[^,;]+/.exec(resource);
if (dataUrl) return [ dataUrl[0] ];
const extensionMatch = groupModulesByExtension && GROUP_EXTENSION_REGEXP.exec(resource), extension = extensionMatch ? extensionMatch[1] : "", pathMatch = groupModulesByPath && GROUP_PATH_REGEXP.exec(resource), path = pathMatch ? pathMatch[1].split(/[/\\]/) : [], keys = [];
if (groupModulesByPath) for (extension && keys.push(path.length ? `${path.join("/")}/*${extension}` : `*${extension}`); path.length > 0; ) keys.push(path.join("/") + "/"), 
path.pop(); else extension && keys.push(`*${extension}`);
return keys;
},
createGroup: (key, children, modules) => {
const isDataUrl = key.startsWith("data:");
return {
type: isDataUrl ? "modules by mime type" : groupModulesByPath ? "modules by path" : "modules by extension",
name: isDataUrl ? key.slice(5) : key,
children,
...moduleGroup(children)
};
}
});
},
excludeModules: (groupConfigs, context, {excludeModules}) => {
groupConfigs.push({
getKeys: module => {
const name = module.name;
if (name) {
if (excludeModules.some((fn => fn(name, module, type)))) return [ "1" ];
}
},
getOptions: () => ({
groupChildren: !1,
force: !0
}),
createGroup: (key, children, modules) => ({
type: "hidden modules",
filteredChildren: children.length,
...moduleGroup(children)
})
});
}
}), RESULT_GROUPERS = {
"compilation.assets": ASSETS_GROUPERS,
"asset.related": ASSETS_GROUPERS,
"compilation.modules": MODULES_GROUPERS("module"),
"chunk.modules": MODULES_GROUPERS("chunk"),
"chunk.rootModules": MODULES_GROUPERS("root-of-chunk"),
"module.modules": MODULES_GROUPERS("nested"),
"module.reasons": {
groupReasonsByOrigin: groupConfigs => {
groupConfigs.push({
getKeys: reason => [ reason.module ],
createGroup: (key, children, reasons) => ({
type: "from origin",
module: key,
children,
...reasonGroup(children)
})
});
}
}
}, sortByField = field => {
if (!field) {
return (a, b) => 0;
}
const fieldKey = (field => "!" === field[0] ? field.slice(1) : field)(field);
let sortFn = compareSelect((m => m[fieldKey]), compareIds);
const sortIsRegular = (field => "!" !== field[0])(field);
if (!sortIsRegular) {
const oldSortFn = sortFn;
sortFn = (a, b) => oldSortFn(b, a);
}
return sortFn;
}, ASSET_SORTERS = {
assetsSort: (comparators, context, {assetsSort}) => {
comparators.push(sortByField(assetsSort));
},
_: comparators => {
comparators.push(compareSelect((a => a.name), compareIds));
}
}, RESULT_SORTERS = {
"compilation.chunks": {
chunksSort: (comparators, context, {chunksSort}) => {
comparators.push(sortByField(chunksSort));
}
},
"compilation.modules": {
modulesSort: (comparators, context, {modulesSort}) => {
comparators.push(sortByField(modulesSort));
}
},
"chunk.modules": {
chunkModulesSort: (comparators, context, {chunkModulesSort}) => {
comparators.push(sortByField(chunkModulesSort));
}
},
"module.modules": {
nestedModulesSort: (comparators, context, {nestedModulesSort}) => {
comparators.push(sortByField(nestedModulesSort));
}
},
"compilation.assets": ASSET_SORTERS,
"asset.related": ASSET_SORTERS
}, iterateConfig = (config, options, fn) => {
for (const hookFor of Object.keys(config)) {
const subConfig = config[hookFor];
for (const option of Object.keys(subConfig)) {
if ("_" !== option) if (option.startsWith("!")) {
if (options[option.slice(1)]) continue;
} else {
const value = options[option];
if (!1 === value || void 0 === value || Array.isArray(value) && 0 === value.length) continue;
}
fn(hookFor, subConfig[option]);
}
}
}, ITEM_NAMES = {
"compilation.children[]": "compilation",
"compilation.modules[]": "module",
"compilation.entrypoints[]": "chunkGroup",
"compilation.namedChunkGroups[]": "chunkGroup",
"compilation.errors[]": "error",
"compilation.warnings[]": "warning",
"chunk.modules[]": "module",
"chunk.rootModules[]": "module",
"chunk.origins[]": "chunkOrigin",
"compilation.chunks[]": "chunk",
"compilation.assets[]": "asset",
"asset.related[]": "asset",
"module.issuerPath[]": "moduleIssuer",
"module.reasons[]": "moduleReason",
"module.modules[]": "module",
"module.children[]": "module",
"moduleTrace[]": "moduleTraceItem",
"moduleTraceItem.dependencies[]": "moduleTraceDependency"
}, mergeToObject = items => {
const obj = Object.create(null);
for (const item of items) obj[item.name] = item;
return obj;
}, MERGER = {
"compilation.entrypoints": mergeToObject,
"compilation.namedChunkGroups": mergeToObject
};
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("DefaultStatsFactoryPlugin", (compilation => {
compilation.hooks.statsFactory.tap("DefaultStatsFactoryPlugin", ((stats, options, context) => {
iterateConfig(SIMPLE_EXTRACTORS, options, ((hookFor, fn) => {
stats.hooks.extract.for(hookFor).tap("DefaultStatsFactoryPlugin", ((obj, data, ctx) => fn(obj, data, ctx, options, stats)));
})), iterateConfig(FILTER, options, ((hookFor, fn) => {
stats.hooks.filter.for(hookFor).tap("DefaultStatsFactoryPlugin", ((item, ctx, idx, i) => fn(item, ctx, options, idx, i)));
})), iterateConfig(FILTER_RESULTS, options, ((hookFor, fn) => {
stats.hooks.filterResults.for(hookFor).tap("DefaultStatsFactoryPlugin", ((item, ctx, idx, i) => fn(item, ctx, options, idx, i)));
})), iterateConfig(SORTERS, options, ((hookFor, fn) => {
stats.hooks.sort.for(hookFor).tap("DefaultStatsFactoryPlugin", ((comparators, ctx) => fn(comparators, ctx, options)));
})), iterateConfig(RESULT_SORTERS, options, ((hookFor, fn) => {
stats.hooks.sortResults.for(hookFor).tap("DefaultStatsFactoryPlugin", ((comparators, ctx) => fn(comparators, ctx, options)));
})), iterateConfig(RESULT_GROUPERS, options, ((hookFor, fn) => {
stats.hooks.groupResults.for(hookFor).tap("DefaultStatsFactoryPlugin", ((groupConfigs, ctx) => fn(groupConfigs, ctx, options)));
}));
for (const key of Object.keys(ITEM_NAMES)) {
const itemName = ITEM_NAMES[key];
stats.hooks.getItemName.for(key).tap("DefaultStatsFactoryPlugin", (() => itemName));
}
for (const key of Object.keys(MERGER)) {
const merger = MERGER[key];
stats.hooks.merge.for(key).tap("DefaultStatsFactoryPlugin", merger);
}
if (options.children) if (Array.isArray(options.children)) stats.hooks.getItemFactory.for("compilation.children[].compilation").tap("DefaultStatsFactoryPlugin", ((comp, {_index: idx}) => {
if (idx < options.children.length) return compilation.createStatsFactory(compilation.createStatsOptions(options.children[idx], context));
})); else if (!0 !== options.children) {
const childFactory = compilation.createStatsFactory(compilation.createStatsOptions(options.children, context));
stats.hooks.getItemFactory.for("compilation.children[].compilation").tap("DefaultStatsFactoryPlugin", (() => childFactory));
}
}));
}));
}
};
},
11388: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RequestShortener = __webpack_require__(91190), applyDefaults = (options, defaults) => {
for (const key of Object.keys(defaults)) void 0 === options[key] && (options[key] = defaults[key]);
}, NAMED_PRESETS = {
verbose: {
hash: !0,
builtAt: !0,
relatedAssets: !0,
entrypoints: !0,
chunkGroups: !0,
ids: !0,
modules: !1,
chunks: !0,
chunkRelations: !0,
chunkModules: !0,
dependentModules: !0,
chunkOrigins: !0,
depth: !0,
env: !0,
reasons: !0,
usedExports: !0,
providedExports: !0,
optimizationBailout: !0,
errorDetails: !0,
errorStack: !0,
publicPath: !0,
logging: "verbose",
orphanModules: !0,
runtimeModules: !0,
exclude: !1,
modulesSpace: 1 / 0,
chunkModulesSpace: 1 / 0,
assetsSpace: 1 / 0,
reasonsSpace: 1 / 0,
children: !0
},
detailed: {
hash: !0,
builtAt: !0,
relatedAssets: !0,
entrypoints: !0,
chunkGroups: !0,
ids: !0,
chunks: !0,
chunkRelations: !0,
chunkModules: !1,
chunkOrigins: !0,
depth: !0,
usedExports: !0,
providedExports: !0,
optimizationBailout: !0,
errorDetails: !0,
publicPath: !0,
logging: !0,
runtimeModules: !0,
exclude: !1,
modulesSpace: 1e3,
assetsSpace: 1e3,
reasonsSpace: 1e3
},
minimal: {
all: !1,
version: !0,
timings: !0,
modules: !0,
modulesSpace: 0,
assets: !0,
assetsSpace: 0,
errors: !0,
errorsCount: !0,
warnings: !0,
warningsCount: !0,
logging: "warn"
},
"errors-only": {
all: !1,
errors: !0,
errorsCount: !0,
moduleTrace: !0,
logging: "error"
},
"errors-warnings": {
all: !1,
errors: !0,
errorsCount: !0,
warnings: !0,
warningsCount: !0,
logging: "warn"
},
summary: {
all: !1,
version: !0,
errorsCount: !0,
warningsCount: !0
},
none: {
all: !1
}
}, NORMAL_ON = ({all}) => !1 !== all, NORMAL_OFF = ({all}) => !0 === all, ON_FOR_TO_STRING = ({all}, {forToString}) => forToString ? !1 !== all : !0 === all, OFF_FOR_TO_STRING = ({all}, {forToString}) => forToString ? !0 === all : !1 !== all, AUTO_FOR_TO_STRING = ({all}, {forToString}) => !1 !== all && (!0 === all || (!forToString || "auto")), DEFAULTS = {
context: (options, context, compilation) => compilation.compiler.context,
requestShortener: (options, context, compilation) => compilation.compiler.context === options.context ? compilation.requestShortener : new RequestShortener(options.context, compilation.compiler.root),
performance: NORMAL_ON,
hash: OFF_FOR_TO_STRING,
env: NORMAL_OFF,
version: NORMAL_ON,
timings: NORMAL_ON,
builtAt: OFF_FOR_TO_STRING,
assets: NORMAL_ON,
entrypoints: AUTO_FOR_TO_STRING,
chunkGroups: OFF_FOR_TO_STRING,
chunkGroupAuxiliary: OFF_FOR_TO_STRING,
chunkGroupChildren: OFF_FOR_TO_STRING,
chunkGroupMaxAssets: (o, {forToString}) => forToString ? 5 : 1 / 0,
chunks: OFF_FOR_TO_STRING,
chunkRelations: OFF_FOR_TO_STRING,
chunkModules: ({all, modules}) => !1 !== all && (!0 === all || !modules),
dependentModules: OFF_FOR_TO_STRING,
chunkOrigins: OFF_FOR_TO_STRING,
ids: OFF_FOR_TO_STRING,
modules: ({all, chunks, chunkModules}, {forToString}) => !1 !== all && (!0 === all || !(forToString && chunks && chunkModules)),
nestedModules: OFF_FOR_TO_STRING,
groupModulesByType: ON_FOR_TO_STRING,
groupModulesByCacheStatus: ON_FOR_TO_STRING,
groupModulesByLayer: ON_FOR_TO_STRING,
groupModulesByAttributes: ON_FOR_TO_STRING,
groupModulesByPath: ON_FOR_TO_STRING,
groupModulesByExtension: ON_FOR_TO_STRING,
modulesSpace: (o, {forToString}) => forToString ? 15 : 1 / 0,
chunkModulesSpace: (o, {forToString}) => forToString ? 10 : 1 / 0,
nestedModulesSpace: (o, {forToString}) => forToString ? 10 : 1 / 0,
relatedAssets: OFF_FOR_TO_STRING,
groupAssetsByEmitStatus: ON_FOR_TO_STRING,
groupAssetsByInfo: ON_FOR_TO_STRING,
groupAssetsByPath: ON_FOR_TO_STRING,
groupAssetsByExtension: ON_FOR_TO_STRING,
groupAssetsByChunk: ON_FOR_TO_STRING,
assetsSpace: (o, {forToString}) => forToString ? 15 : 1 / 0,
orphanModules: OFF_FOR_TO_STRING,
runtimeModules: ({all, runtime}, {forToString}) => void 0 !== runtime ? runtime : forToString ? !0 === all : !1 !== all,
cachedModules: ({all, cached}, {forToString}) => void 0 !== cached ? cached : forToString ? !0 === all : !1 !== all,
moduleAssets: OFF_FOR_TO_STRING,
depth: OFF_FOR_TO_STRING,
cachedAssets: OFF_FOR_TO_STRING,
reasons: OFF_FOR_TO_STRING,
reasonsSpace: (o, {forToString}) => forToString ? 15 : 1 / 0,
groupReasonsByOrigin: ON_FOR_TO_STRING,
usedExports: OFF_FOR_TO_STRING,
providedExports: OFF_FOR_TO_STRING,
optimizationBailout: OFF_FOR_TO_STRING,
children: OFF_FOR_TO_STRING,
source: NORMAL_OFF,
moduleTrace: NORMAL_ON,
errors: NORMAL_ON,
errorsCount: NORMAL_ON,
errorDetails: AUTO_FOR_TO_STRING,
errorStack: OFF_FOR_TO_STRING,
warnings: NORMAL_ON,
warningsCount: NORMAL_ON,
publicPath: OFF_FOR_TO_STRING,
logging: ({all}, {forToString}) => !(!forToString || !1 === all) && "info",
loggingDebug: () => [],
loggingTrace: OFF_FOR_TO_STRING,
excludeModules: () => [],
excludeAssets: () => [],
modulesSort: () => "depth",
chunkModulesSort: () => "name",
nestedModulesSort: () => !1,
chunksSort: () => !1,
assetsSort: () => "!size",
outputPath: OFF_FOR_TO_STRING,
colors: () => !1
}, normalizeFilter = item => {
if ("string" == typeof item) {
const regExp = new RegExp(`[\\\\/]${item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&")}([\\\\/]|$|!|\\?)`);
return ident => regExp.test(ident);
}
return item && "object" == typeof item && "function" == typeof item.test ? ident => item.test(ident) : "function" == typeof item ? item : "boolean" == typeof item ? () => item : void 0;
}, NORMALIZER = {
excludeModules: value => (Array.isArray(value) || (value = value ? [ value ] : []), 
value.map(normalizeFilter)),
excludeAssets: value => (Array.isArray(value) || (value = value ? [ value ] : []), 
value.map(normalizeFilter)),
warningsFilter: value => (Array.isArray(value) || (value = value ? [ value ] : []), 
value.map((filter => {
if ("string" == typeof filter) return (warning, warningString) => warningString.includes(filter);
if (filter instanceof RegExp) return (warning, warningString) => filter.test(warningString);
if ("function" == typeof filter) return filter;
throw new Error(`Can only filter warnings with Strings or RegExps. (Given: ${filter})`);
}))),
logging: value => (!0 === value && (value = "log"), value),
loggingDebug: value => (Array.isArray(value) || (value = value ? [ value ] : []), 
value.map(normalizeFilter))
};
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("DefaultStatsPresetPlugin", (compilation => {
for (const key of Object.keys(NAMED_PRESETS)) {
const defaults = NAMED_PRESETS[key];
compilation.hooks.statsPreset.for(key).tap("DefaultStatsPresetPlugin", ((options, context) => {
applyDefaults(options, defaults);
}));
}
compilation.hooks.statsNormalize.tap("DefaultStatsPresetPlugin", ((options, context) => {
for (const key of Object.keys(DEFAULTS)) void 0 === options[key] && (options[key] = DEFAULTS[key](options, context, compilation));
for (const key of Object.keys(NORMALIZER)) options[key] = NORMALIZER[key](options[key]);
}));
}));
}
};
},
6004: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const plural = (n, singular, plural) => 1 === n ? singular : plural, printSizes = (sizes, {formatSize = n => `${n}`}) => {
const keys = Object.keys(sizes);
return keys.length > 1 ? keys.map((key => `${formatSize(sizes[key])} (${key})`)).join(" ") : 1 === keys.length ? formatSize(sizes[keys[0]]) : void 0;
}, getResourceName = resource => {
const dataUrl = /^data:[^,]+,/.exec(resource);
if (!dataUrl) return resource;
const len = dataUrl[0].length + 16;
return resource.length < len ? resource : `${resource.slice(0, Math.min(resource.length - 2, len))}..`;
}, mapLines = (str, fn) => str.split("\n").map(fn).join("\n"), twoDigit = n => n >= 10 ? `${n}` : `0${n}`, isValidId = id => "number" == typeof id || id, moreCount = (list, count) => list && list.length > 0 ? `+ ${count}` : `${count}`, SIMPLE_PRINTERS = {
"compilation.summary!": (_, {type, bold, green, red, yellow, formatDateTime, formatTime, compilation: {name, hash, version, time, builtAt, errorsCount, warningsCount}}) => {
const root = "compilation.summary!" === type, warningsMessage = warningsCount > 0 ? yellow(`${warningsCount} ${plural(warningsCount, "warning", "warnings")}`) : "", errorsMessage = errorsCount > 0 ? red(`${errorsCount} ${plural(errorsCount, "error", "errors")}`) : "", timeMessage = root && time ? ` in ${formatTime(time)}` : "", hashMessage = hash ? ` (${hash})` : "", builtAtMessage = root && builtAt ? `${formatDateTime(builtAt)}: ` : "", versionMessage = root && version ? `webpack ${version}` : "", nameMessage = root && name ? bold(name) : name ? `Child ${bold(name)}` : root ? "" : "Child", subjectMessage = nameMessage && versionMessage ? `${nameMessage} (${versionMessage})` : versionMessage || nameMessage || "webpack";
let statusMessage;
if (statusMessage = errorsMessage && warningsMessage ? `compiled with ${errorsMessage} and ${warningsMessage}` : errorsMessage ? `compiled with ${errorsMessage}` : warningsMessage ? `compiled with ${warningsMessage}` : 0 === errorsCount && 0 === warningsCount ? `compiled ${green("successfully")}` : "compiled", 
builtAtMessage || versionMessage || errorsMessage || warningsMessage || 0 === errorsCount && 0 === warningsCount || timeMessage || hashMessage) return `${builtAtMessage}${subjectMessage} ${statusMessage}${timeMessage}${hashMessage}`;
},
"compilation.filteredWarningDetailsCount": count => count ? `${count} ${plural(count, "warning has", "warnings have")} detailed information that is not shown.\nUse 'stats.errorDetails: true' resp. '--stats-error-details' to show it.` : void 0,
"compilation.filteredErrorDetailsCount": (count, {yellow}) => count ? yellow(`${count} ${plural(count, "error has", "errors have")} detailed information that is not shown.\nUse 'stats.errorDetails: true' resp. '--stats-error-details' to show it.`) : void 0,
"compilation.env": (env, {bold}) => env ? `Environment (--env): ${bold(JSON.stringify(env, null, 2))}` : void 0,
"compilation.publicPath": (publicPath, {bold}) => `PublicPath: ${bold(publicPath || "(none)")}`,
"compilation.entrypoints": (entrypoints, context, printer) => Array.isArray(entrypoints) ? void 0 : printer.print(context.type, Object.values(entrypoints), {
...context,
chunkGroupKind: "Entrypoint"
}),
"compilation.namedChunkGroups": (namedChunkGroups, context, printer) => {
if (!Array.isArray(namedChunkGroups)) {
const {compilation: {entrypoints}} = context;
let chunkGroups = Object.values(namedChunkGroups);
return entrypoints && (chunkGroups = chunkGroups.filter((group => !Object.prototype.hasOwnProperty.call(entrypoints, group.name)))), 
printer.print(context.type, chunkGroups, {
...context,
chunkGroupKind: "Chunk Group"
});
}
},
"compilation.assetsByChunkName": () => "",
"compilation.filteredModules": (filteredModules, {compilation: {modules}}) => filteredModules > 0 ? `${moreCount(modules, filteredModules)} ${plural(filteredModules, "module", "modules")}` : void 0,
"compilation.filteredAssets": (filteredAssets, {compilation: {assets}}) => filteredAssets > 0 ? `${moreCount(assets, filteredAssets)} ${plural(filteredAssets, "asset", "assets")}` : void 0,
"compilation.logging": (logging, context, printer) => Array.isArray(logging) ? void 0 : printer.print(context.type, Object.entries(logging).map((([name, value]) => ({
...value,
name
}))), context),
"compilation.warningsInChildren!": (_, {yellow, compilation}) => {
if (!compilation.children && compilation.warningsCount > 0 && compilation.warnings) {
const childWarnings = compilation.warningsCount - compilation.warnings.length;
if (childWarnings > 0) return yellow(`${childWarnings} ${plural(childWarnings, "WARNING", "WARNINGS")} in child compilations${compilation.children ? "" : " (Use 'stats.children: true' resp. '--stats-children' for more details)"}`);
}
},
"compilation.errorsInChildren!": (_, {red, compilation}) => {
if (!compilation.children && compilation.errorsCount > 0 && compilation.errors) {
const childErrors = compilation.errorsCount - compilation.errors.length;
if (childErrors > 0) return red(`${childErrors} ${plural(childErrors, "ERROR", "ERRORS")} in child compilations${compilation.children ? "" : " (Use 'stats.children: true' resp. '--stats-children' for more details)"}`);
}
},
"asset.type": type => type,
"asset.name": (name, {formatFilename, asset: {isOverSizeLimit}}) => formatFilename(name, isOverSizeLimit),
"asset.size": (size, {asset: {isOverSizeLimit}, yellow, green, formatSize}) => isOverSizeLimit ? yellow(formatSize(size)) : formatSize(size),
"asset.emitted": (emitted, {green, formatFlag}) => emitted ? green(formatFlag("emitted")) : void 0,
"asset.comparedForEmit": (comparedForEmit, {yellow, formatFlag}) => comparedForEmit ? yellow(formatFlag("compared for emit")) : void 0,
"asset.cached": (cached, {green, formatFlag}) => cached ? green(formatFlag("cached")) : void 0,
"asset.isOverSizeLimit": (isOverSizeLimit, {yellow, formatFlag}) => isOverSizeLimit ? yellow(formatFlag("big")) : void 0,
"asset.info.immutable": (immutable, {green, formatFlag}) => immutable ? green(formatFlag("immutable")) : void 0,
"asset.info.javascriptModule": (javascriptModule, {formatFlag}) => javascriptModule ? formatFlag("javascript module") : void 0,
"asset.info.sourceFilename": (sourceFilename, {formatFlag}) => sourceFilename ? formatFlag(!0 === sourceFilename ? "from source file" : `from: ${sourceFilename}`) : void 0,
"asset.info.development": (development, {green, formatFlag}) => development ? green(formatFlag("dev")) : void 0,
"asset.info.hotModuleReplacement": (hotModuleReplacement, {green, formatFlag}) => hotModuleReplacement ? green(formatFlag("hmr")) : void 0,
"asset.separator!": () => "\n",
"asset.filteredRelated": (filteredRelated, {asset: {related}}) => filteredRelated > 0 ? `${moreCount(related, filteredRelated)} related ${plural(filteredRelated, "asset", "assets")}` : void 0,
"asset.filteredChildren": (filteredChildren, {asset: {children}}) => filteredChildren > 0 ? `${moreCount(children, filteredChildren)} ${plural(filteredChildren, "asset", "assets")}` : void 0,
assetChunk: (id, {formatChunkId}) => formatChunkId(id),
assetChunkName: name => name,
assetChunkIdHint: name => name,
"module.type": type => "module" !== type ? type : void 0,
"module.id": (id, {formatModuleId}) => isValidId(id) ? formatModuleId(id) : void 0,
"module.name": (name, {bold}) => {
const [prefix, resource] = (name => {
const [, prefix, resource] = /^(.*!)?([^!]*)$/.exec(name);
return [ prefix, getResourceName(resource) ];
})(name);
return `${prefix || ""}${bold(resource || "")}`;
},
"module.identifier": identifier => {},
"module.layer": (layer, {formatLayer}) => layer ? formatLayer(layer) : void 0,
"module.sizes": printSizes,
"module.chunks[]": (id, {formatChunkId}) => formatChunkId(id),
"module.depth": (depth, {formatFlag}) => null !== depth ? formatFlag(`depth ${depth}`) : void 0,
"module.cacheable": (cacheable, {formatFlag, red}) => !1 === cacheable ? red(formatFlag("not cacheable")) : void 0,
"module.orphan": (orphan, {formatFlag, yellow}) => orphan ? yellow(formatFlag("orphan")) : void 0,
"module.runtime": (runtime, {formatFlag, yellow}) => runtime ? yellow(formatFlag("runtime")) : void 0,
"module.optional": (optional, {formatFlag, yellow}) => optional ? yellow(formatFlag("optional")) : void 0,
"module.dependent": (dependent, {formatFlag, cyan}) => dependent ? cyan(formatFlag("dependent")) : void 0,
"module.built": (built, {formatFlag, yellow}) => built ? yellow(formatFlag("built")) : void 0,
"module.codeGenerated": (codeGenerated, {formatFlag, yellow}) => codeGenerated ? yellow(formatFlag("code generated")) : void 0,
"module.buildTimeExecuted": (buildTimeExecuted, {formatFlag, green}) => buildTimeExecuted ? green(formatFlag("build time executed")) : void 0,
"module.cached": (cached, {formatFlag, green}) => cached ? green(formatFlag("cached")) : void 0,
"module.assets": (assets, {formatFlag, magenta}) => assets && assets.length ? magenta(formatFlag(`${assets.length} ${plural(assets.length, "asset", "assets")}`)) : void 0,
"module.warnings": (warnings, {formatFlag, yellow}) => !0 === warnings ? yellow(formatFlag("warnings")) : warnings ? yellow(formatFlag(`${warnings} ${plural(warnings, "warning", "warnings")}`)) : void 0,
"module.errors": (errors, {formatFlag, red}) => !0 === errors ? red(formatFlag("errors")) : errors ? red(formatFlag(`${errors} ${plural(errors, "error", "errors")}`)) : void 0,
"module.providedExports": (providedExports, {formatFlag, cyan}) => {
if (Array.isArray(providedExports)) return 0 === providedExports.length ? cyan(formatFlag("no exports")) : cyan(formatFlag(`exports: ${providedExports.join(", ")}`));
},
"module.usedExports": (usedExports, {formatFlag, cyan, module}) => {
if (!0 !== usedExports) {
if (null === usedExports) return cyan(formatFlag("used exports unknown"));
if (!1 === usedExports) return cyan(formatFlag("module unused"));
if (Array.isArray(usedExports)) {
if (0 === usedExports.length) return cyan(formatFlag("no exports used"));
const providedExportsCount = Array.isArray(module.providedExports) ? module.providedExports.length : null;
return null !== providedExportsCount && providedExportsCount === usedExports.length ? cyan(formatFlag("all exports used")) : cyan(formatFlag(`only some exports used: ${usedExports.join(", ")}`));
}
}
},
"module.optimizationBailout[]": (optimizationBailout, {yellow}) => yellow(optimizationBailout),
"module.issuerPath": (issuerPath, {module}) => module.profile ? void 0 : "",
"module.profile": profile => {},
"module.filteredModules": (filteredModules, {module: {modules}}) => filteredModules > 0 ? `${moreCount(modules, filteredModules)} nested ${plural(filteredModules, "module", "modules")}` : void 0,
"module.filteredReasons": (filteredReasons, {module: {reasons}}) => filteredReasons > 0 ? `${moreCount(reasons, filteredReasons)} ${plural(filteredReasons, "reason", "reasons")}` : void 0,
"module.filteredChildren": (filteredChildren, {module: {children}}) => filteredChildren > 0 ? `${moreCount(children, filteredChildren)} ${plural(filteredChildren, "module", "modules")}` : void 0,
"module.separator!": () => "\n",
"moduleIssuer.id": (id, {formatModuleId}) => formatModuleId(id),
"moduleIssuer.profile.total": (value, {formatTime}) => formatTime(value),
"moduleReason.type": type => type,
"moduleReason.userRequest": (userRequest, {cyan}) => cyan(getResourceName(userRequest)),
"moduleReason.moduleId": (moduleId, {formatModuleId}) => isValidId(moduleId) ? formatModuleId(moduleId) : void 0,
"moduleReason.module": (module, {magenta}) => magenta(module),
"moduleReason.loc": loc => loc,
"moduleReason.explanation": (explanation, {cyan}) => cyan(explanation),
"moduleReason.active": (active, {formatFlag}) => active ? void 0 : formatFlag("inactive"),
"moduleReason.resolvedModule": (module, {magenta}) => magenta(module),
"moduleReason.filteredChildren": (filteredChildren, {moduleReason: {children}}) => filteredChildren > 0 ? `${moreCount(children, filteredChildren)} ${plural(filteredChildren, "reason", "reasons")}` : void 0,
"module.profile.total": (value, {formatTime}) => formatTime(value),
"module.profile.resolving": (value, {formatTime}) => `resolving: ${formatTime(value)}`,
"module.profile.restoring": (value, {formatTime}) => `restoring: ${formatTime(value)}`,
"module.profile.integration": (value, {formatTime}) => `integration: ${formatTime(value)}`,
"module.profile.building": (value, {formatTime}) => `building: ${formatTime(value)}`,
"module.profile.storing": (value, {formatTime}) => `storing: ${formatTime(value)}`,
"module.profile.additionalResolving": (value, {formatTime}) => value ? `additional resolving: ${formatTime(value)}` : void 0,
"module.profile.additionalIntegration": (value, {formatTime}) => value ? `additional integration: ${formatTime(value)}` : void 0,
"chunkGroup.kind!": (_, {chunkGroupKind}) => chunkGroupKind,
"chunkGroup.separator!": () => "\n",
"chunkGroup.name": (name, {bold}) => bold(name),
"chunkGroup.isOverSizeLimit": (isOverSizeLimit, {formatFlag, yellow}) => isOverSizeLimit ? yellow(formatFlag("big")) : void 0,
"chunkGroup.assetsSize": (size, {formatSize}) => size ? formatSize(size) : void 0,
"chunkGroup.auxiliaryAssetsSize": (size, {formatSize}) => size ? `(${formatSize(size)})` : void 0,
"chunkGroup.filteredAssets": (n, {chunkGroup: {assets}}) => n > 0 ? `${moreCount(assets, n)} ${plural(n, "asset", "assets")}` : void 0,
"chunkGroup.filteredAuxiliaryAssets": (n, {chunkGroup: {auxiliaryAssets}}) => n > 0 ? `${moreCount(auxiliaryAssets, n)} auxiliary ${plural(n, "asset", "assets")}` : void 0,
"chunkGroup.is!": () => "=",
"chunkGroupAsset.name": (asset, {green}) => green(asset),
"chunkGroupAsset.size": (size, {formatSize, chunkGroup}) => chunkGroup.assets.length > 1 || chunkGroup.auxiliaryAssets && chunkGroup.auxiliaryAssets.length > 0 ? formatSize(size) : void 0,
"chunkGroup.children": (children, context, printer) => Array.isArray(children) ? void 0 : printer.print(context.type, Object.keys(children).map((key => ({
type: key,
children: children[key]
}))), context),
"chunkGroupChildGroup.type": type => `${type}:`,
"chunkGroupChild.assets[]": (file, {formatFilename}) => formatFilename(file),
"chunkGroupChild.chunks[]": (id, {formatChunkId}) => formatChunkId(id),
"chunkGroupChild.name": name => name ? `(name: ${name})` : void 0,
"chunk.id": (id, {formatChunkId}) => formatChunkId(id),
"chunk.files[]": (file, {formatFilename}) => formatFilename(file),
"chunk.names[]": name => name,
"chunk.idHints[]": name => name,
"chunk.runtime[]": name => name,
"chunk.sizes": (sizes, context) => printSizes(sizes, context),
"chunk.parents[]": (parents, context) => context.formatChunkId(parents, "parent"),
"chunk.siblings[]": (siblings, context) => context.formatChunkId(siblings, "sibling"),
"chunk.children[]": (children, context) => context.formatChunkId(children, "child"),
"chunk.childrenByOrder": (childrenByOrder, context, printer) => Array.isArray(childrenByOrder) ? void 0 : printer.print(context.type, Object.keys(childrenByOrder).map((key => ({
type: key,
children: childrenByOrder[key]
}))), context),
"chunk.childrenByOrder[].type": type => `${type}:`,
"chunk.childrenByOrder[].children[]": (id, {formatChunkId}) => isValidId(id) ? formatChunkId(id) : void 0,
"chunk.entry": (entry, {formatFlag, yellow}) => entry ? yellow(formatFlag("entry")) : void 0,
"chunk.initial": (initial, {formatFlag, yellow}) => initial ? yellow(formatFlag("initial")) : void 0,
"chunk.rendered": (rendered, {formatFlag, green}) => rendered ? green(formatFlag("rendered")) : void 0,
"chunk.recorded": (recorded, {formatFlag, green}) => recorded ? green(formatFlag("recorded")) : void 0,
"chunk.reason": (reason, {yellow}) => reason ? yellow(reason) : void 0,
"chunk.filteredModules": (filteredModules, {chunk: {modules}}) => filteredModules > 0 ? `${moreCount(modules, filteredModules)} chunk ${plural(filteredModules, "module", "modules")}` : void 0,
"chunk.separator!": () => "\n",
"chunkOrigin.request": request => request,
"chunkOrigin.moduleId": (moduleId, {formatModuleId}) => isValidId(moduleId) ? formatModuleId(moduleId) : void 0,
"chunkOrigin.moduleName": (moduleName, {bold}) => bold(moduleName),
"chunkOrigin.loc": loc => loc,
"error.compilerPath": (compilerPath, {bold}) => compilerPath ? bold(`(${compilerPath})`) : void 0,
"error.chunkId": (chunkId, {formatChunkId}) => isValidId(chunkId) ? formatChunkId(chunkId) : void 0,
"error.chunkEntry": (chunkEntry, {formatFlag}) => chunkEntry ? formatFlag("entry") : void 0,
"error.chunkInitial": (chunkInitial, {formatFlag}) => chunkInitial ? formatFlag("initial") : void 0,
"error.file": (file, {bold}) => bold(file),
"error.moduleName": (moduleName, {bold}) => moduleName.includes("!") ? `${bold(moduleName.replace(/^(\s|\S)*!/, ""))} (${moduleName})` : `${bold(moduleName)}`,
"error.loc": (loc, {green}) => green(loc),
"error.message": (message, {bold, formatError}) => message.includes("[") ? message : bold(formatError(message)),
"error.details": (details, {formatError}) => formatError(details),
"error.stack": stack => stack,
"error.moduleTrace": moduleTrace => {},
"error.separator!": () => "\n",
"loggingEntry(error).loggingEntry.message": (message, {red}) => mapLines(message, (x => `<e> ${red(x)}`)),
"loggingEntry(warn).loggingEntry.message": (message, {yellow}) => mapLines(message, (x => `<w> ${yellow(x)}`)),
"loggingEntry(info).loggingEntry.message": (message, {green}) => mapLines(message, (x => `<i> ${green(x)}`)),
"loggingEntry(log).loggingEntry.message": (message, {bold}) => mapLines(message, (x => `    ${bold(x)}`)),
"loggingEntry(debug).loggingEntry.message": message => mapLines(message, (x => `    ${x}`)),
"loggingEntry(trace).loggingEntry.message": message => mapLines(message, (x => `    ${x}`)),
"loggingEntry(status).loggingEntry.message": (message, {magenta}) => mapLines(message, (x => `<s> ${magenta(x)}`)),
"loggingEntry(profile).loggingEntry.message": (message, {magenta}) => mapLines(message, (x => `<p> ${magenta(x)}`)),
"loggingEntry(profileEnd).loggingEntry.message": (message, {magenta}) => mapLines(message, (x => `</p> ${magenta(x)}`)),
"loggingEntry(time).loggingEntry.message": (message, {magenta}) => mapLines(message, (x => `<t> ${magenta(x)}`)),
"loggingEntry(group).loggingEntry.message": (message, {cyan}) => mapLines(message, (x => `<-> ${cyan(x)}`)),
"loggingEntry(groupCollapsed).loggingEntry.message": (message, {cyan}) => mapLines(message, (x => `<+> ${cyan(x)}`)),
"loggingEntry(clear).loggingEntry": () => "    -------",
"loggingEntry(groupCollapsed).loggingEntry.children": () => "",
"loggingEntry.trace[]": trace => trace ? mapLines(trace, (x => `| ${x}`)) : void 0,
"moduleTraceItem.originName": originName => originName,
loggingGroup: loggingGroup => 0 === loggingGroup.entries.length ? "" : void 0,
"loggingGroup.debug": (flag, {red}) => flag ? red("DEBUG") : void 0,
"loggingGroup.name": (name, {bold}) => bold(`LOG from ${name}`),
"loggingGroup.separator!": () => "\n",
"loggingGroup.filteredEntries": filteredEntries => filteredEntries > 0 ? `+ ${filteredEntries} hidden lines` : void 0,
"moduleTraceDependency.loc": loc => loc
}, ITEM_NAMES = {
"compilation.assets[]": "asset",
"compilation.modules[]": "module",
"compilation.chunks[]": "chunk",
"compilation.entrypoints[]": "chunkGroup",
"compilation.namedChunkGroups[]": "chunkGroup",
"compilation.errors[]": "error",
"compilation.warnings[]": "error",
"compilation.logging[]": "loggingGroup",
"compilation.children[]": "compilation",
"asset.related[]": "asset",
"asset.children[]": "asset",
"asset.chunks[]": "assetChunk",
"asset.auxiliaryChunks[]": "assetChunk",
"asset.chunkNames[]": "assetChunkName",
"asset.chunkIdHints[]": "assetChunkIdHint",
"asset.auxiliaryChunkNames[]": "assetChunkName",
"asset.auxiliaryChunkIdHints[]": "assetChunkIdHint",
"chunkGroup.assets[]": "chunkGroupAsset",
"chunkGroup.auxiliaryAssets[]": "chunkGroupAsset",
"chunkGroupChild.assets[]": "chunkGroupAsset",
"chunkGroupChild.auxiliaryAssets[]": "chunkGroupAsset",
"chunkGroup.children[]": "chunkGroupChildGroup",
"chunkGroupChildGroup.children[]": "chunkGroupChild",
"module.modules[]": "module",
"module.children[]": "module",
"module.reasons[]": "moduleReason",
"moduleReason.children[]": "moduleReason",
"module.issuerPath[]": "moduleIssuer",
"chunk.origins[]": "chunkOrigin",
"chunk.modules[]": "module",
"loggingGroup.entries[]": logEntry => `loggingEntry(${logEntry.type}).loggingEntry`,
"loggingEntry.children[]": logEntry => `loggingEntry(${logEntry.type}).loggingEntry`,
"error.moduleTrace[]": "moduleTraceItem",
"moduleTraceItem.dependencies[]": "moduleTraceDependency"
}, ERROR_PREFERRED_ORDER = [ "compilerPath", "chunkId", "chunkEntry", "chunkInitial", "file", "separator!", "moduleName", "loc", "separator!", "message", "separator!", "details", "separator!", "stack", "separator!", "missing", "separator!", "moduleTrace" ], PREFERRED_ORDERS = {
compilation: [ "name", "hash", "version", "time", "builtAt", "env", "publicPath", "assets", "filteredAssets", "entrypoints", "namedChunkGroups", "chunks", "modules", "filteredModules", "children", "logging", "warnings", "warningsInChildren!", "filteredWarningDetailsCount", "errors", "errorsInChildren!", "filteredErrorDetailsCount", "summary!", "needAdditionalPass" ],
asset: [ "type", "name", "size", "chunks", "auxiliaryChunks", "emitted", "comparedForEmit", "cached", "info", "isOverSizeLimit", "chunkNames", "auxiliaryChunkNames", "chunkIdHints", "auxiliaryChunkIdHints", "related", "filteredRelated", "children", "filteredChildren" ],
"asset.info": [ "immutable", "sourceFilename", "javascriptModule", "development", "hotModuleReplacement" ],
chunkGroup: [ "kind!", "name", "isOverSizeLimit", "assetsSize", "auxiliaryAssetsSize", "is!", "assets", "filteredAssets", "auxiliaryAssets", "filteredAuxiliaryAssets", "separator!", "children" ],
chunkGroupAsset: [ "name", "size" ],
chunkGroupChildGroup: [ "type", "children" ],
chunkGroupChild: [ "assets", "chunks", "name" ],
module: [ "type", "name", "identifier", "id", "layer", "sizes", "chunks", "depth", "cacheable", "orphan", "runtime", "optional", "dependent", "built", "codeGenerated", "cached", "assets", "failed", "warnings", "errors", "children", "filteredChildren", "providedExports", "usedExports", "optimizationBailout", "reasons", "filteredReasons", "issuerPath", "profile", "modules", "filteredModules" ],
moduleReason: [ "active", "type", "userRequest", "moduleId", "module", "resolvedModule", "loc", "explanation", "children", "filteredChildren" ],
"module.profile": [ "total", "separator!", "resolving", "restoring", "integration", "building", "storing", "additionalResolving", "additionalIntegration" ],
chunk: [ "id", "runtime", "files", "names", "idHints", "sizes", "parents", "siblings", "children", "childrenByOrder", "entry", "initial", "rendered", "recorded", "reason", "separator!", "origins", "separator!", "modules", "separator!", "filteredModules" ],
chunkOrigin: [ "request", "moduleId", "moduleName", "loc" ],
error: ERROR_PREFERRED_ORDER,
warning: ERROR_PREFERRED_ORDER,
"chunk.childrenByOrder[]": [ "type", "children" ],
loggingGroup: [ "debug", "name", "separator!", "entries", "separator!", "filteredEntries" ],
loggingEntry: [ "message", "trace", "children" ]
}, itemsJoinOneLine = items => items.filter(Boolean).join(" "), itemsJoinOneLineBrackets = items => items.length > 0 ? `(${items.filter(Boolean).join(" ")})` : void 0, itemsJoinMoreSpacing = items => items.filter(Boolean).join("\n\n"), itemsJoinComma = items => items.filter(Boolean).join(", "), itemsJoinCommaBrackets = items => items.length > 0 ? `(${items.filter(Boolean).join(", ")})` : void 0, itemsJoinCommaBracketsWithName = name => items => items.length > 0 ? `(${name}: ${items.filter(Boolean).join(", ")})` : void 0, SIMPLE_ITEMS_JOINER = {
"chunk.parents": itemsJoinOneLine,
"chunk.siblings": itemsJoinOneLine,
"chunk.children": itemsJoinOneLine,
"chunk.names": itemsJoinCommaBrackets,
"chunk.idHints": itemsJoinCommaBracketsWithName("id hint"),
"chunk.runtime": itemsJoinCommaBracketsWithName("runtime"),
"chunk.files": itemsJoinComma,
"chunk.childrenByOrder": itemsJoinOneLine,
"chunk.childrenByOrder[].children": itemsJoinOneLine,
"chunkGroup.assets": itemsJoinOneLine,
"chunkGroup.auxiliaryAssets": itemsJoinOneLineBrackets,
"chunkGroupChildGroup.children": itemsJoinComma,
"chunkGroupChild.assets": itemsJoinOneLine,
"chunkGroupChild.auxiliaryAssets": itemsJoinOneLineBrackets,
"asset.chunks": itemsJoinComma,
"asset.auxiliaryChunks": itemsJoinCommaBrackets,
"asset.chunkNames": itemsJoinCommaBracketsWithName("name"),
"asset.auxiliaryChunkNames": itemsJoinCommaBracketsWithName("auxiliary name"),
"asset.chunkIdHints": itemsJoinCommaBracketsWithName("id hint"),
"asset.auxiliaryChunkIdHints": itemsJoinCommaBracketsWithName("auxiliary id hint"),
"module.chunks": itemsJoinOneLine,
"module.issuerPath": items => items.filter(Boolean).map((item => `${item} ->`)).join(" "),
"compilation.errors": itemsJoinMoreSpacing,
"compilation.warnings": itemsJoinMoreSpacing,
"compilation.logging": itemsJoinMoreSpacing,
"compilation.children": items => indent(itemsJoinMoreSpacing(items), "  "),
"moduleTraceItem.dependencies": itemsJoinOneLine,
"loggingEntry.children": items => indent(items.filter(Boolean).join("\n"), "  ", !1)
}, joinOneLine = items => items.map((item => item.content)).filter(Boolean).join(" "), indent = (str, prefix, noPrefixInFirstLine) => {
const rem = str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
if (noPrefixInFirstLine) return rem;
return ("\n" === str[0] ? "" : prefix) + rem;
}, joinExplicitNewLine = (items, indenter) => {
let firstInLine = !0, first = !0;
return items.map((item => {
if (!item || !item.content) return;
let content = indent(item.content, first ? "" : indenter, !firstInLine);
if (firstInLine && (content = content.replace(/^\n+/, "")), !content) return;
first = !1;
const noJoiner = firstInLine || content.startsWith("\n");
return firstInLine = content.endsWith("\n"), noJoiner ? content : " " + content;
})).filter(Boolean).join("").trim();
}, joinError = error => (items, {red, yellow}) => `${error ? red("ERROR") : yellow("WARNING")} in ${joinExplicitNewLine(items, "")}`, SIMPLE_ELEMENT_JOINERS = {
compilation: items => {
const result = [];
let lastNeedMore = !1;
for (const item of items) {
if (!item.content) continue;
const needMoreSpace = "warnings" === item.element || "filteredWarningDetailsCount" === item.element || "errors" === item.element || "filteredErrorDetailsCount" === item.element || "logging" === item.element;
0 !== result.length && result.push(needMoreSpace || lastNeedMore ? "\n\n" : "\n"), 
result.push(item.content), lastNeedMore = needMoreSpace;
}
return lastNeedMore && result.push("\n"), result.join("");
},
asset: items => joinExplicitNewLine(items.map((item => "related" !== item.element && "children" !== item.element || !item.content ? item : {
...item,
content: `\n${item.content}\n`
})), "  "),
"asset.info": joinOneLine,
module: (items, {module}) => {
let hasName = !1;
return joinExplicitNewLine(items.map((item => {
switch (item.element) {
case "id":
if (module.id === module.name) {
if (hasName) return !1;
item.content && (hasName = !0);
}
break;

case "name":
if (hasName) return !1;
item.content && (hasName = !0);
break;

case "providedExports":
case "usedExports":
case "optimizationBailout":
case "reasons":
case "issuerPath":
case "profile":
case "children":
case "modules":
if (item.content) return {
...item,
content: `\n${item.content}\n`
};
}
return item;
})), "  ");
},
chunk: items => {
let hasEntry = !1;
return "chunk " + joinExplicitNewLine(items.filter((item => {
switch (item.element) {
case "entry":
item.content && (hasEntry = !0);
break;

case "initial":
if (hasEntry) return !1;
}
return !0;
})), "  ");
},
"chunk.childrenByOrder[]": items => `(${joinOneLine(items)})`,
chunkGroup: items => joinExplicitNewLine(items, "  "),
chunkGroupAsset: joinOneLine,
chunkGroupChildGroup: joinOneLine,
chunkGroupChild: joinOneLine,
moduleReason: (items, {moduleReason}) => {
let hasName = !1;
return joinExplicitNewLine(items.map((item => {
switch (item.element) {
case "moduleId":
moduleReason.moduleId === moduleReason.module && item.content && (hasName = !0);
break;

case "module":
if (hasName) return !1;
break;

case "resolvedModule":
if (moduleReason.module === moduleReason.resolvedModule) return !1;
break;

case "children":
if (item.content) return {
...item,
content: `\n${item.content}\n`
};
}
return item;
})), "  ");
},
"module.profile": items => {
const res = [];
let mode = 0;
for (const item of items) {
if ("separator!" === item.element) switch (mode) {
case 0:
case 1:
mode += 2;
break;

case 4:
res.push(")"), mode = 3;
}
if (item.content) {
switch (mode) {
case 0:
mode = 1;
break;

case 1:
res.push(" ");
break;

case 2:
res.push("("), mode = 4;
break;

case 3:
res.push(" ("), mode = 4;
break;

case 4:
res.push(", ");
}
res.push(item.content);
}
}
return 4 === mode && res.push(")"), res.join("");
},
moduleIssuer: joinOneLine,
chunkOrigin: items => "> " + joinOneLine(items),
"errors[].error": joinError(!0),
"warnings[].error": joinError(!1),
loggingGroup: items => joinExplicitNewLine(items, "").trimRight(),
moduleTraceItem: items => " @ " + joinOneLine(items),
moduleTraceDependency: joinOneLine
}, AVAILABLE_COLORS = {
bold: "[1m",
yellow: "[1m[33m",
red: "[1m[31m",
green: "[1m[32m",
cyan: "[1m[36m",
magenta: "[1m[35m"
}, AVAILABLE_FORMATS = {
formatChunkId: (id, {yellow}, direction) => {
switch (direction) {
case "parent":
return `<{${yellow(id)}}>`;

case "sibling":
return `={${yellow(id)}}=`;

case "child":
return `>{${yellow(id)}}<`;

default:
return `{${yellow(id)}}`;
}
},
formatModuleId: id => `[${id}]`,
formatFilename: (filename, {green, yellow}, oversize) => (oversize ? yellow : green)(filename),
formatFlag: flag => `[${flag}]`,
formatLayer: layer => `(in ${layer})`,
formatSize: __webpack_require__(9568).formatSize,
formatDateTime: (dateTime, {bold}) => {
const d = new Date(dateTime), x = twoDigit;
return `${`${d.getFullYear()}-${x(d.getMonth() + 1)}-${x(d.getDate())}`} ${bold(`${x(d.getHours())}:${x(d.getMinutes())}:${x(d.getSeconds())}`)}`;
},
formatTime: (time, {timeReference, bold, green, yellow, red}, boldQuantity) => {
if (timeReference && time !== timeReference) {
const times = [ timeReference / 2, timeReference / 4, timeReference / 8, timeReference / 16 ];
return time < times[3] ? `${time} ms` : time < times[2] ? bold(`${time} ms`) : time < times[1] ? green(`${time} ms`) : time < times[0] ? yellow(`${time} ms`) : red(`${time} ms`);
}
return `${boldQuantity ? bold(time) : time} ms`;
},
formatError: (message, {green, yellow, red}) => {
if (message.includes("[")) return message;
const highlights = [ {
regExp: /(Did you mean .+)/g,
format: green
}, {
regExp: /(Set 'mode' option to 'development' or 'production')/g,
format: green
}, {
regExp: /(\(module has no exports\))/g,
format: red
}, {
regExp: /\(possible exports: (.+)\)/g,
format: green
}, {
regExp: /(?:^|\n)(.* doesn't exist)/g,
format: red
}, {
regExp: /('\w+' option has not been set)/g,
format: red
}, {
regExp: /(Emitted value instead of an instance of Error)/g,
format: yellow
}, {
regExp: /(Used? .+ instead)/gi,
format: yellow
}, {
regExp: /\b(deprecated|must|required)\b/g,
format: yellow
}, {
regExp: /\b(BREAKING CHANGE)\b/gi,
format: red
}, {
regExp: /\b(error|failed|unexpected|invalid|not found|not supported|not available|not possible|not implemented|doesn't support|conflict|conflicting|not existing|duplicate)\b/gi,
format: red
} ];
for (const {regExp, format} of highlights) message = message.replace(regExp, ((match, content) => match.replace(content, format(content))));
return message;
}
}, RESULT_MODIFIER = {
"module.modules": result => indent(result, "| ")
}, createOrder = (array, preferredOrder) => {
const originalArray = array.slice(), set = new Set(array), usedSet = new Set;
array.length = 0;
for (const element of preferredOrder) (element.endsWith("!") || set.has(element)) && (array.push(element), 
usedSet.add(element));
for (const element of originalArray) usedSet.has(element) || array.push(element);
return array;
};
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("DefaultStatsPrinterPlugin", (compilation => {
compilation.hooks.statsPrinter.tap("DefaultStatsPrinterPlugin", ((stats, options, context) => {
stats.hooks.print.for("compilation").tap("DefaultStatsPrinterPlugin", ((compilation, context) => {
for (const color of Object.keys(AVAILABLE_COLORS)) {
let start;
options.colors && (start = "object" == typeof options.colors && "string" == typeof options.colors[color] ? options.colors[color] : AVAILABLE_COLORS[color]), 
context[color] = start ? str => `${start}${"string" == typeof str ? str.replace(/((\u001b\[39m|\u001b\[22m|\u001b\[0m)+)/g, `$1${start}`) : str}[39m[22m` : str => str;
}
for (const format of Object.keys(AVAILABLE_FORMATS)) context[format] = (content, ...args) => AVAILABLE_FORMATS[format](content, context, ...args);
context.timeReference = compilation.time;
}));
for (const key of Object.keys(SIMPLE_PRINTERS)) stats.hooks.print.for(key).tap("DefaultStatsPrinterPlugin", ((obj, ctx) => SIMPLE_PRINTERS[key](obj, ctx, stats)));
for (const key of Object.keys(PREFERRED_ORDERS)) {
const preferredOrder = PREFERRED_ORDERS[key];
stats.hooks.sortElements.for(key).tap("DefaultStatsPrinterPlugin", ((elements, context) => {
createOrder(elements, preferredOrder);
}));
}
for (const key of Object.keys(ITEM_NAMES)) {
const itemName = ITEM_NAMES[key];
stats.hooks.getItemName.for(key).tap("DefaultStatsPrinterPlugin", "string" == typeof itemName ? () => itemName : itemName);
}
for (const key of Object.keys(SIMPLE_ITEMS_JOINER)) {
const joiner = SIMPLE_ITEMS_JOINER[key];
stats.hooks.printItems.for(key).tap("DefaultStatsPrinterPlugin", joiner);
}
for (const key of Object.keys(SIMPLE_ELEMENT_JOINERS)) {
const joiner = SIMPLE_ELEMENT_JOINERS[key];
stats.hooks.printElements.for(key).tap("DefaultStatsPrinterPlugin", joiner);
}
for (const key of Object.keys(RESULT_MODIFIER)) {
const modifier = RESULT_MODIFIER[key];
stats.hooks.result.for(key).tap("DefaultStatsPrinterPlugin", modifier);
}
}));
}));
}
};
},
98119: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {HookMap, SyncBailHook, SyncWaterfallHook} = __webpack_require__(89991), {concatComparators, keepOriginalOrder} = __webpack_require__(40028), smartGrouping = __webpack_require__(29501);
module.exports = class {
constructor() {
this.hooks = Object.freeze({
extract: new HookMap((() => new SyncBailHook([ "object", "data", "context" ]))),
filter: new HookMap((() => new SyncBailHook([ "item", "context", "index", "unfilteredIndex" ]))),
sort: new HookMap((() => new SyncBailHook([ "comparators", "context" ]))),
filterSorted: new HookMap((() => new SyncBailHook([ "item", "context", "index", "unfilteredIndex" ]))),
groupResults: new HookMap((() => new SyncBailHook([ "groupConfigs", "context" ]))),
sortResults: new HookMap((() => new SyncBailHook([ "comparators", "context" ]))),
filterResults: new HookMap((() => new SyncBailHook([ "item", "context", "index", "unfilteredIndex" ]))),
merge: new HookMap((() => new SyncBailHook([ "items", "context" ]))),
result: new HookMap((() => new SyncWaterfallHook([ "result", "context" ]))),
getItemName: new HookMap((() => new SyncBailHook([ "item", "context" ]))),
getItemFactory: new HookMap((() => new SyncBailHook([ "item", "context" ])))
});
const hooks = this.hooks;
this._caches = {};
for (const key of Object.keys(hooks)) this._caches[key] = new Map;
this._inCreate = !1;
}
_getAllLevelHooks(hookMap, cache, type) {
const cacheEntry = cache.get(type);
if (void 0 !== cacheEntry) return cacheEntry;
const hooks = [], typeParts = type.split(".");
for (let i = 0; i < typeParts.length; i++) {
const hook = hookMap.get(typeParts.slice(i).join("."));
hook && hooks.push(hook);
}
return cache.set(type, hooks), hooks;
}
_forEachLevel(hookMap, cache, type, fn) {
for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {
const result = fn(hook);
if (void 0 !== result) return result;
}
}
_forEachLevelWaterfall(hookMap, cache, type, data, fn) {
for (const hook of this._getAllLevelHooks(hookMap, cache, type)) data = fn(hook, data);
return data;
}
_forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {
const hooks = this._getAllLevelHooks(hookMap, cache, type);
if (0 === hooks.length) return forceClone ? items.slice() : items;
let i = 0;
return items.filter(((item, idx) => {
for (const hook of hooks) {
const r = fn(hook, item, idx, i);
if (void 0 !== r) return r && i++, r;
}
return i++, !0;
}));
}
create(type, data, baseContext) {
if (this._inCreate) return this._create(type, data, baseContext);
try {
return this._inCreate = !0, this._create(type, data, baseContext);
} finally {
for (const key of Object.keys(this._caches)) this._caches[key].clear();
this._inCreate = !1;
}
}
_create(type, data, baseContext) {
const context = {
...baseContext,
type,
[type]: data
};
if (Array.isArray(data)) {
const items = this._forEachLevelFilter(this.hooks.filter, this._caches.filter, type, data, ((h, r, idx, i) => h.call(r, context, idx, i)), !0), comparators = [];
this._forEachLevel(this.hooks.sort, this._caches.sort, type, (h => h.call(comparators, context))), 
comparators.length > 0 && items.sort(concatComparators(...comparators, keepOriginalOrder(items)));
let resultItems = this._forEachLevelFilter(this.hooks.filterSorted, this._caches.filterSorted, type, items, ((h, r, idx, i) => h.call(r, context, idx, i)), !1).map(((item, i) => {
const itemContext = {
...context,
_index: i
}, itemName = this._forEachLevel(this.hooks.getItemName, this._caches.getItemName, `${type}[]`, (h => h.call(item, itemContext)));
itemName && (itemContext[itemName] = item);
const innerType = itemName ? `${type}[].${itemName}` : `${type}[]`;
return (this._forEachLevel(this.hooks.getItemFactory, this._caches.getItemFactory, innerType, (h => h.call(item, itemContext))) || this).create(innerType, item, itemContext);
}));
const comparators2 = [];
this._forEachLevel(this.hooks.sortResults, this._caches.sortResults, type, (h => h.call(comparators2, context))), 
comparators2.length > 0 && resultItems.sort(concatComparators(...comparators2, keepOriginalOrder(resultItems)));
const groupConfigs = [];
this._forEachLevel(this.hooks.groupResults, this._caches.groupResults, type, (h => h.call(groupConfigs, context))), 
groupConfigs.length > 0 && (resultItems = smartGrouping(resultItems, groupConfigs));
const finalResultItems = this._forEachLevelFilter(this.hooks.filterResults, this._caches.filterResults, type, resultItems, ((h, r, idx, i) => h.call(r, context, idx, i)), !1);
let result = this._forEachLevel(this.hooks.merge, this._caches.merge, type, (h => h.call(finalResultItems, context)));
return void 0 === result && (result = finalResultItems), this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, result, ((h, r) => h.call(r, context)));
}
{
const object = {};
return this._forEachLevel(this.hooks.extract, this._caches.extract, type, (h => h.call(object, data, context))), 
this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, object, ((h, r) => h.call(r, context)));
}
}
};
},
43e3: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {HookMap, SyncWaterfallHook, SyncBailHook} = __webpack_require__(89991);
module.exports = class {
constructor() {
this.hooks = Object.freeze({
sortElements: new HookMap((() => new SyncBailHook([ "elements", "context" ]))),
printElements: new HookMap((() => new SyncBailHook([ "printedElements", "context" ]))),
sortItems: new HookMap((() => new SyncBailHook([ "items", "context" ]))),
getItemName: new HookMap((() => new SyncBailHook([ "item", "context" ]))),
printItems: new HookMap((() => new SyncBailHook([ "printedItems", "context" ]))),
print: new HookMap((() => new SyncBailHook([ "object", "context" ]))),
result: new HookMap((() => new SyncWaterfallHook([ "result", "context" ])))
}), this._levelHookCache = new Map, this._inPrint = !1;
}
_getAllLevelHooks(hookMap, type) {
let cache = this._levelHookCache.get(hookMap);
void 0 === cache && (cache = new Map, this._levelHookCache.set(hookMap, cache));
const cacheEntry = cache.get(type);
if (void 0 !== cacheEntry) return cacheEntry;
const hooks = [], typeParts = type.split(".");
for (let i = 0; i < typeParts.length; i++) {
const hook = hookMap.get(typeParts.slice(i).join("."));
hook && hooks.push(hook);
}
return cache.set(type, hooks), hooks;
}
_forEachLevel(hookMap, type, fn) {
for (const hook of this._getAllLevelHooks(hookMap, type)) {
const result = fn(hook);
if (void 0 !== result) return result;
}
}
_forEachLevelWaterfall(hookMap, type, data, fn) {
for (const hook of this._getAllLevelHooks(hookMap, type)) data = fn(hook, data);
return data;
}
print(type, object, baseContext) {
if (this._inPrint) return this._print(type, object, baseContext);
try {
return this._inPrint = !0, this._print(type, object, baseContext);
} finally {
this._levelHookCache.clear(), this._inPrint = !1;
}
}
_print(type, object, baseContext) {
const context = {
...baseContext,
type,
[type]: object
};
let printResult = this._forEachLevel(this.hooks.print, type, (hook => hook.call(object, context)));
if (void 0 === printResult) if (Array.isArray(object)) {
const sortedItems = object.slice();
this._forEachLevel(this.hooks.sortItems, type, (h => h.call(sortedItems, context)));
const printedItems = sortedItems.map(((item, i) => {
const itemContext = {
...context,
_index: i
}, itemName = this._forEachLevel(this.hooks.getItemName, `${type}[]`, (h => h.call(item, itemContext)));
return itemName && (itemContext[itemName] = item), this.print(itemName ? `${type}[].${itemName}` : `${type}[]`, item, itemContext);
}));
if (printResult = this._forEachLevel(this.hooks.printItems, type, (h => h.call(printedItems, context))), 
void 0 === printResult) {
const result = printedItems.filter(Boolean);
result.length > 0 && (printResult = result.join("\n"));
}
} else if (null !== object && "object" == typeof object) {
const elements = Object.keys(object).filter((key => void 0 !== object[key]));
this._forEachLevel(this.hooks.sortElements, type, (h => h.call(elements, context)));
const printedElements = elements.map((element => ({
element,
content: this.print(`${type}.${element}`, object[element], {
...context,
_parent: object,
_element: element,
[element]: object[element]
})
})));
if (printResult = this._forEachLevel(this.hooks.printElements, type, (h => h.call(printedElements, context))), 
void 0 === printResult) {
const result = printedElements.map((e => e.content)).filter(Boolean);
result.length > 0 && (printResult = result.join("\n"));
}
}
return this._forEachLevelWaterfall(this.hooks.result, type, printResult, ((h, r) => h.call(r, context)));
}
};
},
8579: (__unused_webpack_module, exports) => {
"use strict";
exports.equals = (a, b) => {
if (a.length !== b.length) return !1;
for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
return !0;
}, exports.groupBy = (arr = [], fn) => arr.reduce(((groups, value) => (groups[fn(value) ? 0 : 1].push(value), 
groups)), [ [], [] ]);
},
3216: module => {
"use strict";
class ArrayQueue {
constructor(items) {
this._list = items ? Array.from(items) : [], this._listReversed = [];
}
get length() {
return this._list.length + this._listReversed.length;
}
clear() {
this._list.length = 0, this._listReversed.length = 0;
}
enqueue(item) {
this._list.push(item);
}
dequeue() {
if (0 === this._listReversed.length) {
if (0 === this._list.length) return;
if (1 === this._list.length) return this._list.pop();
if (this._list.length < 16) return this._list.shift();
const temp = this._listReversed;
this._listReversed = this._list, this._listReversed.reverse(), this._list = temp;
}
return this._listReversed.pop();
}
delete(item) {
const i = this._list.indexOf(item);
if (i >= 0) this._list.splice(i, 1); else {
const i = this._listReversed.indexOf(item);
i >= 0 && this._listReversed.splice(i, 1);
}
}
[Symbol.iterator]() {
let i = -1, reversed = !1;
return {
next: () => {
if (!reversed) {
if (i++, i < this._list.length) return {
done: !1,
value: this._list[i]
};
reversed = !0, i = this._listReversed.length;
}
return i--, i < 0 ? {
done: !0,
value: void 0
} : {
done: !1,
value: this._listReversed[i]
};
}
};
}
}
module.exports = ArrayQueue;
},
90756: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncHook, AsyncSeriesHook} = __webpack_require__(89991), {makeWebpackError} = __webpack_require__(44741), WebpackError = __webpack_require__(64326), ArrayQueue = __webpack_require__(3216);
let inHandleResult = 0;
class AsyncQueueEntry {
constructor(item, callback) {
this.item = item, this.state = 0, this.callback = callback, this.callbacks = void 0, 
this.result = void 0, this.error = void 0;
}
}
module.exports = class {
constructor({name, parallelism, parent, processor, getKey}) {
this._name = name, this._parallelism = parallelism || 1, this._processor = processor, 
this._getKey = getKey || (item => item), this._entries = new Map, this._queued = new ArrayQueue, 
this._children = void 0, this._activeTasks = 0, this._willEnsureProcessing = !1, 
this._needProcessing = !1, this._stopped = !1, this._root = parent ? parent._root : this, 
parent && (void 0 === this._root._children ? this._root._children = [ this ] : this._root._children.push(this)), 
this.hooks = {
beforeAdd: new AsyncSeriesHook([ "item" ]),
added: new SyncHook([ "item" ]),
beforeStart: new AsyncSeriesHook([ "item" ]),
started: new SyncHook([ "item" ]),
result: new SyncHook([ "item", "error", "result" ])
}, this._ensureProcessing = this._ensureProcessing.bind(this);
}
add(item, callback) {
if (this._stopped) return callback(new WebpackError("Queue was stopped"));
this.hooks.beforeAdd.callAsync(item, (err => {
if (err) return void callback(makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`));
const key = this._getKey(item), entry = this._entries.get(key);
if (void 0 !== entry) return void (2 === entry.state ? (inHandleResult++ > 3 ? process.nextTick((() => callback(entry.error, entry.result))) : callback(entry.error, entry.result), 
inHandleResult--) : void 0 === entry.callbacks ? entry.callbacks = [ callback ] : entry.callbacks.push(callback));
const newEntry = new AsyncQueueEntry(item, callback);
if (this._stopped) this.hooks.added.call(item), this._root._activeTasks++, process.nextTick((() => this._handleResult(newEntry, new WebpackError("Queue was stopped")))); else {
this._entries.set(key, newEntry), this._queued.enqueue(newEntry);
const root = this._root;
root._needProcessing = !0, !1 === root._willEnsureProcessing && (root._willEnsureProcessing = !0, 
setImmediate(root._ensureProcessing)), this.hooks.added.call(item);
}
}));
}
invalidate(item) {
const key = this._getKey(item), entry = this._entries.get(key);
this._entries.delete(key), 0 === entry.state && this._queued.delete(entry);
}
waitFor(item, callback) {
const key = this._getKey(item), entry = this._entries.get(key);
if (void 0 === entry) return callback(new WebpackError("waitFor can only be called for an already started item"));
2 === entry.state ? process.nextTick((() => callback(entry.error, entry.result))) : void 0 === entry.callbacks ? entry.callbacks = [ callback ] : entry.callbacks.push(callback);
}
stop() {
this._stopped = !0;
const queue = this._queued;
this._queued = new ArrayQueue;
const root = this._root;
for (const entry of queue) this._entries.delete(this._getKey(entry.item)), root._activeTasks++, 
this._handleResult(entry, new WebpackError("Queue was stopped"));
}
increaseParallelism() {
const root = this._root;
root._parallelism++, !1 === root._willEnsureProcessing && root._needProcessing && (root._willEnsureProcessing = !0, 
setImmediate(root._ensureProcessing));
}
decreaseParallelism() {
this._root._parallelism--;
}
isProcessing(item) {
const key = this._getKey(item), entry = this._entries.get(key);
return void 0 !== entry && 1 === entry.state;
}
isQueued(item) {
const key = this._getKey(item), entry = this._entries.get(key);
return void 0 !== entry && 0 === entry.state;
}
isDone(item) {
const key = this._getKey(item), entry = this._entries.get(key);
return void 0 !== entry && 2 === entry.state;
}
_ensureProcessing() {
for (;this._activeTasks < this._parallelism; ) {
const entry = this._queued.dequeue();
if (void 0 === entry) break;
this._activeTasks++, entry.state = 1, this._startProcessing(entry);
}
if (this._willEnsureProcessing = !1, !(this._queued.length > 0)) {
if (void 0 !== this._children) for (const child of this._children) {
for (;this._activeTasks < this._parallelism; ) {
const entry = child._queued.dequeue();
if (void 0 === entry) break;
this._activeTasks++, entry.state = 1, child._startProcessing(entry);
}
if (child._queued.length > 0) return;
}
this._willEnsureProcessing || (this._needProcessing = !1);
}
}
_startProcessing(entry) {
this.hooks.beforeStart.callAsync(entry.item, (err => {
if (err) return void this._handleResult(entry, makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`));
let inCallback = !1;
try {
this._processor(entry.item, ((e, r) => {
inCallback = !0, this._handleResult(entry, e, r);
}));
} catch (err) {
if (inCallback) throw err;
this._handleResult(entry, err, null);
}
this.hooks.started.call(entry.item);
}));
}
_handleResult(entry, err, result) {
this.hooks.result.callAsync(entry.item, err, result, (hookError => {
const error = hookError ? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`) : err, callback = entry.callback, callbacks = entry.callbacks;
entry.state = 2, entry.callback = void 0, entry.callbacks = void 0, entry.result = result, 
entry.error = error;
const root = this._root;
if (root._activeTasks--, !1 === root._willEnsureProcessing && root._needProcessing && (root._willEnsureProcessing = !0, 
setImmediate(root._ensureProcessing)), inHandleResult++ > 3) process.nextTick((() => {
if (callback(error, result), void 0 !== callbacks) for (const callback of callbacks) callback(error, result);
})); else if (callback(error, result), void 0 !== callbacks) for (const callback of callbacks) callback(error, result);
inHandleResult--;
}));
}
clear() {
this._entries.clear(), this._queued.clear(), this._activeTasks = 0, this._willEnsureProcessing = !1, 
this._needProcessing = !1, this._stopped = !1;
}
};
},
99432: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
module.exports = class {
update(data, inputEncoding) {
throw new (__webpack_require__(91266));
}
digest(encoding) {
throw new (__webpack_require__(91266));
}
};
},
30416: (__unused_webpack_module, exports) => {
"use strict";
exports.last = set => {
let last;
for (const item of set) last = item;
return last;
}, exports.someInIterable = (iterable, filter) => {
for (const item of iterable) if (filter(item)) return !0;
return !1;
}, exports.countIterable = iterable => {
let i = 0;
for (const _ of iterable) i++;
return i;
};
},
76104: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {first} = __webpack_require__(73974), SortableSet = __webpack_require__(72451);
class LazyBucketSortedSet {
constructor(getKey, comparator, ...args) {
this._getKey = getKey, this._innerArgs = args, this._leaf = args.length <= 1, this._keys = new SortableSet(void 0, comparator), 
this._map = new Map, this._unsortedItems = new Set, this.size = 0;
}
add(item) {
this.size++, this._unsortedItems.add(item);
}
_addInternal(key, item) {
let entry = this._map.get(key);
void 0 === entry && (entry = this._leaf ? new SortableSet(void 0, this._innerArgs[0]) : new LazyBucketSortedSet(...this._innerArgs), 
this._keys.add(key), this._map.set(key, entry)), entry.add(item);
}
delete(item) {
if (this.size--, this._unsortedItems.has(item)) return void this._unsortedItems.delete(item);
const key = this._getKey(item), entry = this._map.get(key);
entry.delete(item), 0 === entry.size && this._deleteKey(key);
}
_deleteKey(key) {
this._keys.delete(key), this._map.delete(key);
}
popFirst() {
if (0 === this.size) return;
if (this.size--, this._unsortedItems.size > 0) {
for (const item of this._unsortedItems) {
const key = this._getKey(item);
this._addInternal(key, item);
}
this._unsortedItems.clear();
}
this._keys.sort();
const key = first(this._keys), entry = this._map.get(key);
if (this._leaf) {
const leafEntry = entry;
leafEntry.sort();
const item = first(leafEntry);
return leafEntry.delete(item), 0 === leafEntry.size && this._deleteKey(key), item;
}
{
const nodeEntry = entry, item = nodeEntry.popFirst();
return 0 === nodeEntry.size && this._deleteKey(key), item;
}
}
startUpdate(item) {
if (this._unsortedItems.has(item)) return remove => {
if (remove) return this._unsortedItems.delete(item), void this.size--;
};
const key = this._getKey(item);
if (this._leaf) {
const oldEntry = this._map.get(key);
return remove => {
if (remove) return this.size--, oldEntry.delete(item), void (0 === oldEntry.size && this._deleteKey(key));
const newKey = this._getKey(item);
key === newKey ? oldEntry.add(item) : (oldEntry.delete(item), 0 === oldEntry.size && this._deleteKey(key), 
this._addInternal(newKey, item));
};
}
{
const oldEntry = this._map.get(key), finishUpdate = oldEntry.startUpdate(item);
return remove => {
if (remove) return this.size--, finishUpdate(!0), void (0 === oldEntry.size && this._deleteKey(key));
const newKey = this._getKey(item);
key === newKey ? finishUpdate() : (finishUpdate(!0), 0 === oldEntry.size && this._deleteKey(key), 
this._addInternal(newKey, item));
};
}
}
_appendIterators(iterators) {
this._unsortedItems.size > 0 && iterators.push(this._unsortedItems[Symbol.iterator]());
for (const key of this._keys) {
const entry = this._map.get(key);
if (this._leaf) {
const iterator = entry[Symbol.iterator]();
iterators.push(iterator);
} else {
entry._appendIterators(iterators);
}
}
}
[Symbol.iterator]() {
const iterators = [];
this._appendIterators(iterators), iterators.reverse();
let currentIterator = iterators.pop();
return {
next: () => {
const res = currentIterator.next();
return res.done ? 0 === iterators.length ? res : (currentIterator = iterators.pop(), 
currentIterator.next()) : res;
}
};
}
}
module.exports = LazyBucketSortedSet;
},
92585: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const makeSerializable = __webpack_require__(45898), flatten = (targetSet, toDeepMerge) => {
for (const set of toDeepMerge) if (set._set.size > 0 && targetSet.add(set._set), 
set._needMerge) {
for (const mergedSet of set._toMerge) targetSet.add(mergedSet);
flatten(targetSet, set._toDeepMerge);
}
};
class LazySet {
constructor(iterable) {
this._set = new Set(iterable), this._toMerge = new Set, this._toDeepMerge = [], 
this._needMerge = !1, this._deopt = !1;
}
_flatten() {
flatten(this._toMerge, this._toDeepMerge), this._toDeepMerge.length = 0;
}
_merge() {
this._flatten(), ((targetSet, toMerge) => {
for (const set of toMerge) for (const item of set) targetSet.add(item);
})(this._set, this._toMerge), this._toMerge.clear(), this._needMerge = !1;
}
_isEmpty() {
return 0 === this._set.size && 0 === this._toMerge.size && 0 === this._toDeepMerge.length;
}
get size() {
return this._needMerge && this._merge(), this._set.size;
}
add(item) {
return this._set.add(item), this;
}
addAll(iterable) {
if (this._deopt) {
const _set = this._set;
for (const item of iterable) _set.add(item);
} else {
if (iterable instanceof LazySet) {
if (iterable._isEmpty()) return this;
this._toDeepMerge.push(iterable), this._needMerge = !0, this._toDeepMerge.length > 1e5 && this._flatten();
} else this._toMerge.add(iterable), this._needMerge = !0;
this._toMerge.size > 1e5 && this._merge();
}
return this;
}
clear() {
this._set.clear(), this._toMerge.clear(), this._toDeepMerge.length = 0, this._needMerge = !1, 
this._deopt = !1;
}
delete(value) {
return this._needMerge && this._merge(), this._set.delete(value);
}
entries() {
return this._deopt = !0, this._needMerge && this._merge(), this._set.entries();
}
forEach(callbackFn, thisArg) {
this._deopt = !0, this._needMerge && this._merge(), this._set.forEach(callbackFn, thisArg);
}
has(item) {
return this._needMerge && this._merge(), this._set.has(item);
}
keys() {
return this._deopt = !0, this._needMerge && this._merge(), this._set.keys();
}
values() {
return this._deopt = !0, this._needMerge && this._merge(), this._set.values();
}
[Symbol.iterator]() {
return this._deopt = !0, this._needMerge && this._merge(), this._set[Symbol.iterator]();
}
get [Symbol.toStringTag]() {
return "LazySet";
}
serialize({write}) {
this._needMerge && this._merge(), write(this._set.size);
for (const item of this._set) write(item);
}
static deserialize({read}) {
const count = read(), items = [];
for (let i = 0; i < count; i++) items.push(read());
return new LazySet(items);
}
}
makeSerializable(LazySet, "webpack/lib/util/LazySet"), module.exports = LazySet;
},
65783: (__unused_webpack_module, exports) => {
"use strict";
exports.provide = (map, key, computer) => {
const value = map.get(key);
if (void 0 !== value) return value;
const newValue = computer();
return map.set(key, newValue), newValue;
};
},
51252: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const binarySearchBounds = __webpack_require__(35704);
module.exports = class {
constructor() {
this._rangePoints = [], this._rangeCallbacks = [];
}
range(start, end, callback) {
if (start === end) return callback(1);
this._rangePoints.push(start), this._rangePoints.push(end), this._rangeCallbacks.push(callback);
}
calculate() {
const segments = Array.from(new Set(this._rangePoints)).sort(((a, b) => a < b ? -1 : 1)), parallelism = segments.map((() => 0)), rangeStartIndices = [];
for (let i = 0; i < this._rangePoints.length; i += 2) {
const start = this._rangePoints[i], end = this._rangePoints[i + 1];
let idx = binarySearchBounds.eq(segments, start);
rangeStartIndices.push(idx);
do {
parallelism[idx]++, idx++;
} while (segments[idx] < end);
}
for (let i = 0; i < this._rangeCallbacks.length; i++) {
const start = this._rangePoints[2 * i], end = this._rangePoints[2 * i + 1];
let idx = rangeStartIndices[i], sum = 0, totalDuration = 0, current = start;
do {
const p = parallelism[idx];
idx++;
const duration = segments[idx] - current;
totalDuration += duration, current = segments[idx], sum += p * duration;
} while (current < end);
this._rangeCallbacks[i](sum / totalDuration);
}
}
};
},
77274: module => {
"use strict";
module.exports = class {
constructor(items) {
this._set = new Set(items), this._iterator = this._set[Symbol.iterator]();
}
get length() {
return this._set.size;
}
enqueue(item) {
this._set.add(item);
}
dequeue() {
const result = this._iterator.next();
if (!result.done) return this._set.delete(result.value), result.value;
}
};
},
73974: (__unused_webpack_module, exports) => {
"use strict";
exports.intersect = sets => {
if (0 === sets.length) return new Set;
if (1 === sets.length) return new Set(sets[0]);
let minSize = 1 / 0, minIndex = -1;
for (let i = 0; i < sets.length; i++) {
const size = sets[i].size;
size < minSize && (minIndex = i, minSize = size);
}
const current = new Set(sets[minIndex]);
for (let i = 0; i < sets.length; i++) {
if (i === minIndex) continue;
const set = sets[i];
for (const item of current) set.has(item) || current.delete(item);
}
return current;
}, exports.isSubset = (bigSet, smallSet) => {
if (bigSet.size < smallSet.size) return !1;
for (const item of smallSet) if (!bigSet.has(item)) return !1;
return !0;
}, exports.find = (set, fn) => {
for (const item of set) if (fn(item)) return item;
}, exports.first = set => {
const entry = set.values().next();
return entry.done ? void 0 : entry.value;
}, exports.combine = (a, b) => {
if (0 === b.size) return a;
if (0 === a.size) return b;
const set = new Set(a);
for (const item of b) set.add(item);
return set;
};
},
72451: module => {
"use strict";
const NONE = Symbol("not sorted");
class SortableSet extends Set {
constructor(initialIterable, defaultSort) {
super(initialIterable), this._sortFn = defaultSort, this._lastActiveSortFn = NONE, 
this._cache = void 0, this._cacheOrderIndependent = void 0;
}
add(value) {
return this._lastActiveSortFn = NONE, this._invalidateCache(), this._invalidateOrderedCache(), 
super.add(value), this;
}
delete(value) {
return this._invalidateCache(), this._invalidateOrderedCache(), super.delete(value);
}
clear() {
return this._invalidateCache(), this._invalidateOrderedCache(), super.clear();
}
sortWith(sortFn) {
if (this.size <= 1 || sortFn === this._lastActiveSortFn) return;
const sortedArray = Array.from(this).sort(sortFn);
super.clear();
for (let i = 0; i < sortedArray.length; i += 1) super.add(sortedArray[i]);
this._lastActiveSortFn = sortFn, this._invalidateCache();
}
sort() {
return this.sortWith(this._sortFn), this;
}
getFromCache(fn) {
if (void 0 === this._cache) this._cache = new Map; else {
const data = this._cache.get(fn);
if (void 0 !== data) return data;
}
const newData = fn(this);
return this._cache.set(fn, newData), newData;
}
getFromUnorderedCache(fn) {
if (void 0 === this._cacheOrderIndependent) this._cacheOrderIndependent = new Map; else {
const data = this._cacheOrderIndependent.get(fn);
if (void 0 !== data) return data;
}
const newData = fn(this);
return this._cacheOrderIndependent.set(fn, newData), newData;
}
_invalidateCache() {
void 0 !== this._cache && this._cache.clear();
}
_invalidateOrderedCache() {
void 0 !== this._cacheOrderIndependent && this._cacheOrderIndependent.clear();
}
toJSON() {
return Array.from(this);
}
}
module.exports = SortableSet;
},
65929: module => {
"use strict";
class StackedCacheMap {
constructor() {
this.map = new Map, this.stack = [];
}
addAll(map, immutable) {
if (immutable) {
this.stack.push(map);
for (let i = this.stack.length - 1; i > 0; i--) {
const beforeLast = this.stack[i - 1];
if (beforeLast.size >= map.size) break;
this.stack[i] = beforeLast, this.stack[i - 1] = map;
}
} else for (const [key, value] of map) this.map.set(key, value);
}
set(item, value) {
this.map.set(item, value);
}
delete(item) {
throw new Error("Items can't be deleted from a StackedCacheMap");
}
has(item) {
throw new Error("Checking StackedCacheMap.has before reading is inefficient, use StackedCacheMap.get and check for undefined");
}
get(item) {
for (const map of this.stack) {
const value = map.get(item);
if (void 0 !== value) return value;
}
return this.map.get(item);
}
clear() {
this.stack.length = 0, this.map.clear();
}
get size() {
let size = this.map.size;
for (const map of this.stack) size += map.size;
return size;
}
[Symbol.iterator]() {
const iterators = this.stack.map((map => map[Symbol.iterator]()));
let current = this.map[Symbol.iterator]();
return {
next() {
let result = current.next();
for (;result.done && iterators.length > 0; ) current = iterators.pop(), result = current.next();
return result;
}
};
}
}
module.exports = StackedCacheMap;
},
33963: module => {
"use strict";
const TOMBSTONE = Symbol("tombstone"), UNDEFINED_MARKER = Symbol("undefined"), extractPair = pair => {
const key = pair[0], val = pair[1];
return val === UNDEFINED_MARKER || val === TOMBSTONE ? [ key, void 0 ] : pair;
};
class StackedMap {
constructor(parentStack) {
this.map = new Map, this.stack = void 0 === parentStack ? [] : parentStack.slice(), 
this.stack.push(this.map);
}
set(item, value) {
this.map.set(item, void 0 === value ? UNDEFINED_MARKER : value);
}
delete(item) {
this.stack.length > 1 ? this.map.set(item, TOMBSTONE) : this.map.delete(item);
}
has(item) {
const topValue = this.map.get(item);
if (void 0 !== topValue) return topValue !== TOMBSTONE;
if (this.stack.length > 1) {
for (let i = this.stack.length - 2; i >= 0; i--) {
const value = this.stack[i].get(item);
if (void 0 !== value) return this.map.set(item, value), value !== TOMBSTONE;
}
this.map.set(item, TOMBSTONE);
}
return !1;
}
get(item) {
const topValue = this.map.get(item);
if (void 0 !== topValue) return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? void 0 : topValue;
if (this.stack.length > 1) {
for (let i = this.stack.length - 2; i >= 0; i--) {
const value = this.stack[i].get(item);
if (void 0 !== value) return this.map.set(item, value), value === TOMBSTONE || value === UNDEFINED_MARKER ? void 0 : value;
}
this.map.set(item, TOMBSTONE);
}
}
_compress() {
if (1 !== this.stack.length) {
this.map = new Map;
for (const data of this.stack) for (const pair of data) pair[1] === TOMBSTONE ? this.map.delete(pair[0]) : this.map.set(pair[0], pair[1]);
this.stack = [ this.map ];
}
}
asArray() {
return this._compress(), Array.from(this.map.keys());
}
asSet() {
return this._compress(), new Set(this.map.keys());
}
asPairArray() {
return this._compress(), Array.from(this.map.entries(), extractPair);
}
asMap() {
return new Map(this.asPairArray());
}
get size() {
return this._compress(), this.map.size;
}
createChild() {
return new StackedMap(this.stack);
}
}
module.exports = StackedMap;
},
81664: module => {
"use strict";
module.exports = class {
constructor() {
this._value = void 0;
}
add(str) {
const len = str.length, value = this._value;
if (void 0 === value) {
const newValue = this._value = Buffer.allocUnsafe(len);
for (let i = 0; i < len; i++) newValue[i] = str.charCodeAt(i);
return;
}
const valueLen = value.length;
if (valueLen < len) {
const newValue = this._value = Buffer.allocUnsafe(len);
let i;
for (i = 0; i < valueLen; i++) newValue[i] = value[i] ^ str.charCodeAt(i);
for (;i < len; i++) newValue[i] = str.charCodeAt(i);
} else for (let i = 0; i < len; i++) value[i] = value[i] ^ str.charCodeAt(i);
}
toString() {
const value = this._value;
return void 0 === value ? "" : value.toString("latin1");
}
updateHash(hash) {
const value = this._value;
void 0 !== value && hash.update(value);
}
};
},
74368: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const TupleSet = __webpack_require__(99235);
module.exports = class {
constructor(items) {
this._set = new TupleSet(items), this._iterator = this._set[Symbol.iterator]();
}
get length() {
return this._set.size;
}
enqueue(...item) {
this._set.add(...item);
}
dequeue() {
const result = this._iterator.next();
if (!result.done) return this._set.delete(...result.value), result.value;
if (this._set.size > 0) {
this._iterator = this._set[Symbol.iterator]();
const value = this._iterator.next().value;
return this._set.delete(...value), value;
}
}
};
},
99235: module => {
"use strict";
class TupleSet {
constructor(init) {
if (this._map = new Map, this.size = 0, init) for (const tuple of init) this.add(...tuple);
}
add(...args) {
let map = this._map;
for (let i = 0; i < args.length - 2; i++) {
const arg = args[i], innerMap = map.get(arg);
void 0 === innerMap ? map.set(arg, map = new Map) : map = innerMap;
}
const beforeLast = args[args.length - 2];
let set = map.get(beforeLast);
void 0 === set && map.set(beforeLast, set = new Set);
const last = args[args.length - 1];
this.size -= set.size, set.add(last), this.size += set.size;
}
has(...args) {
let map = this._map;
for (let i = 0; i < args.length - 2; i++) {
const arg = args[i];
if (map = map.get(arg), void 0 === map) return !1;
}
const beforeLast = args[args.length - 2];
let set = map.get(beforeLast);
if (void 0 === set) return !1;
const last = args[args.length - 1];
return set.has(last);
}
delete(...args) {
let map = this._map;
for (let i = 0; i < args.length - 2; i++) {
const arg = args[i];
if (map = map.get(arg), void 0 === map) return;
}
const beforeLast = args[args.length - 2];
let set = map.get(beforeLast);
if (void 0 === set) return;
const last = args[args.length - 1];
this.size -= set.size, set.delete(last), this.size += set.size;
}
[Symbol.iterator]() {
const iteratorStack = [], tuple = [];
let currentSetIterator;
const next = it => {
const result = it.next();
if (result.done) return 0 !== iteratorStack.length && (tuple.pop(), next(iteratorStack.pop()));
const [key, value] = result.value;
return iteratorStack.push(it), tuple.push(key), value instanceof Set ? (currentSetIterator = value[Symbol.iterator](), 
!0) : next(value[Symbol.iterator]());
};
return next(this._map[Symbol.iterator]()), {
next() {
for (;currentSetIterator; ) {
const result = currentSetIterator.next();
if (!result.done) return {
done: !1,
value: tuple.concat(result.value)
};
tuple.pop(), next(iteratorStack.pop()) || (currentSetIterator = void 0);
}
return {
done: !0,
value: void 0
};
}
};
}
}
module.exports = TupleSet;
},
15686: (__unused_webpack_module, exports) => {
"use strict";
const backSlashCharCode = "\\".charCodeAt(0), slashCharCode = "/".charCodeAt(0), aLowerCaseCharCode = "a".charCodeAt(0), zLowerCaseCharCode = "z".charCodeAt(0), aUpperCaseCharCode = "A".charCodeAt(0), zUpperCaseCharCode = "Z".charCodeAt(0), _0CharCode = "0".charCodeAt(0), _9CharCode = "9".charCodeAt(0), plusCharCode = "+".charCodeAt(0), hyphenCharCode = "-".charCodeAt(0), colonCharCode = ":".charCodeAt(0), hashCharCode = "#".charCodeAt(0), queryCharCode = "?".charCodeAt(0);
function getScheme(specifier) {
const start = specifier.charCodeAt(0);
if ((start < aLowerCaseCharCode || start > zLowerCaseCharCode) && (start < aUpperCaseCharCode || start > zUpperCaseCharCode)) return;
let i = 1, ch = specifier.charCodeAt(i);
for (;ch >= aLowerCaseCharCode && ch <= zLowerCaseCharCode || ch >= aUpperCaseCharCode && ch <= zUpperCaseCharCode || ch >= _0CharCode && ch <= _9CharCode || ch === plusCharCode || ch === hyphenCharCode; ) {
if (++i === specifier.length) return;
ch = specifier.charCodeAt(i);
}
if (ch === colonCharCode) {
if (1 === i) {
const nextChar = i + 1 < specifier.length ? specifier.charCodeAt(i + 1) : 0;
if (0 === nextChar || nextChar === backSlashCharCode || nextChar === slashCharCode || nextChar === hashCharCode || nextChar === queryCharCode) return;
}
return specifier.slice(0, i).toLowerCase();
}
}
exports.getScheme = getScheme, exports.getProtocol = function(specifier) {
const scheme = getScheme(specifier);
return void 0 === scheme ? void 0 : scheme + ":";
};
},
39132: module => {
"use strict";
const isWeakKey = thing => "object" == typeof thing && null !== thing;
class WeakTupleMap {
constructor() {
this.f = 0, this.v = void 0, this.m = void 0, this.w = void 0;
}
set(...args) {
let node = this;
for (let i = 0; i < args.length - 1; i++) node = node._get(args[i]);
node._setValue(args[args.length - 1]);
}
has(...args) {
let node = this;
for (let i = 0; i < args.length; i++) if (node = node._peek(args[i]), void 0 === node) return !1;
return node._hasValue();
}
get(...args) {
let node = this;
for (let i = 0; i < args.length; i++) if (node = node._peek(args[i]), void 0 === node) return;
return node._getValue();
}
provide(...args) {
let node = this;
for (let i = 0; i < args.length - 1; i++) node = node._get(args[i]);
if (node._hasValue()) return node._getValue();
const newValue = (0, args[args.length - 1])(...args.slice(0, -1));
return node._setValue(newValue), newValue;
}
delete(...args) {
let node = this;
for (let i = 0; i < args.length; i++) if (node = node._peek(args[i]), void 0 === node) return;
node._deleteValue();
}
clear() {
this.f = 0, this.v = void 0, this.w = void 0, this.m = void 0;
}
_getValue() {
return this.v;
}
_hasValue() {
return 1 == (1 & this.f);
}
_setValue(v) {
this.f |= 1, this.v = v;
}
_deleteValue() {
this.f &= 6, this.v = void 0;
}
_peek(thing) {
if (isWeakKey(thing)) {
if (4 != (4 & this.f)) return;
return this.w.get(thing);
}
if (2 == (2 & this.f)) return this.m.get(thing);
}
_get(thing) {
if (isWeakKey(thing)) {
if (4 != (4 & this.f)) {
const newMap = new WeakMap;
this.f |= 4;
const newNode = new WeakTupleMap;
return (this.w = newMap).set(thing, newNode), newNode;
}
const entry = this.w.get(thing);
if (void 0 !== entry) return entry;
const newNode = new WeakTupleMap;
return this.w.set(thing, newNode), newNode;
}
{
if (2 != (2 & this.f)) {
const newMap = new Map;
this.f |= 2;
const newNode = new WeakTupleMap;
return (this.m = newMap).set(thing, newNode), newNode;
}
const entry = this.m.get(thing);
if (void 0 !== entry) return entry;
const newNode = new WeakTupleMap;
return this.m.set(thing, newNode), newNode;
}
}
}
module.exports = WeakTupleMap;
},
35704: module => {
"use strict";
const compileSearch = (funcName, predicate, reversed, extraArgs, earlyOut) => {
const code = [ "function ", funcName, "(a,l,h,", extraArgs.join(","), "){", earlyOut ? "" : "var i=", reversed ? "l-1" : "h+1", ";while(l<=h){var m=(l+h)>>>1,x=a[m]" ];
return earlyOut ? predicate.indexOf("c") < 0 ? code.push(";if(x===y){return m}else if(x<=y){") : code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){") : code.push(";if(", predicate, "){i=m;"), 
reversed ? code.push("l=m+1}else{h=m-1}") : code.push("h=m-1}else{l=m+1}"), code.push("}"), 
earlyOut ? code.push("return -1};") : code.push("return i};"), code.join("");
}, compileBoundsSearch = (predicate, reversed, suffix, earlyOut) => {
const fnSource = [ compileSearch("A", "x" + predicate + "y", reversed, [ "y" ], earlyOut), compileSearch("P", "c(x,y)" + predicate + "0", reversed, [ "y", "c" ], earlyOut), "function dispatchBinarySearch", suffix, "(a,y,c,l,h){if(typeof(c)==='function'){return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)}else{return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)}}return dispatchBinarySearch", suffix ].join("");
return new Function(fnSource)();
};
module.exports = {
ge: compileBoundsSearch(">=", !1, "GE"),
gt: compileBoundsSearch(">", !1, "GT"),
lt: compileBoundsSearch("<", !0, "LT"),
le: compileBoundsSearch("<=", !0, "LE"),
eq: compileBoundsSearch("-", !0, "EQ", !0)
};
},
8639: (__unused_webpack_module, exports) => {
"use strict";
const mergeCache = new WeakMap, setPropertyCache = new WeakMap, DELETE = Symbol("DELETE"), DYNAMIC_INFO = Symbol("cleverMerge dynamic info"), cachedCleverMerge = (first, second) => {
if (void 0 === second) return first;
if (void 0 === first) return second;
if ("object" != typeof second || null === second) return second;
if ("object" != typeof first || null === first) return first;
let innerCache = mergeCache.get(first);
void 0 === innerCache && (innerCache = new WeakMap, mergeCache.set(first, innerCache));
const prevMerge = innerCache.get(second);
if (void 0 !== prevMerge) return prevMerge;
const newMerge = _cleverMerge(first, second, !0);
return innerCache.set(second, newMerge), newMerge;
}, parseCache = new WeakMap, cachedParseObject = obj => {
const entry = parseCache.get(obj);
if (void 0 !== entry) return entry;
const result = parseObject(obj);
return parseCache.set(obj, result), result;
}, parseObject = obj => {
const info = new Map;
let dynamicInfo;
const getInfo = p => {
const entry = info.get(p);
if (void 0 !== entry) return entry;
const newEntry = {
base: void 0,
byProperty: void 0,
byValues: void 0
};
return info.set(p, newEntry), newEntry;
};
for (const key of Object.keys(obj)) if (key.startsWith("by")) {
const byProperty = key, byObj = obj[byProperty];
if ("object" == typeof byObj) for (const byValue of Object.keys(byObj)) {
const obj = byObj[byValue];
for (const key of Object.keys(obj)) {
const entry = getInfo(key);
if (void 0 === entry.byProperty) entry.byProperty = byProperty, entry.byValues = new Map; else if (entry.byProperty !== byProperty) throw new Error(`${byProperty} and ${entry.byProperty} for a single property is not supported`);
if (entry.byValues.set(byValue, obj[key]), "default" === byValue) for (const otherByValue of Object.keys(byObj)) entry.byValues.has(otherByValue) || entry.byValues.set(otherByValue, void 0);
}
} else if ("function" == typeof byObj) {
if (void 0 !== dynamicInfo) throw new Error(`${key} and ${dynamicInfo.byProperty} when both are functions is not supported`);
dynamicInfo = {
byProperty: key,
fn: byObj
};
} else {
getInfo(key).base = obj[key];
}
} else {
getInfo(key).base = obj[key];
}
return {
static: info,
dynamic: dynamicInfo
};
}, serializeObject = (info, dynamicInfo) => {
const obj = {};
for (const entry of info.values()) if (void 0 !== entry.byProperty) {
const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};
for (const byValue of entry.byValues.keys()) byObj[byValue] = byObj[byValue] || {};
}
for (const [key, entry] of info) if (void 0 !== entry.base && (obj[key] = entry.base), 
void 0 !== entry.byProperty) {
const byObj = obj[entry.byProperty] = obj[entry.byProperty] || {};
for (const byValue of Object.keys(byObj)) {
const value = getFromByValues(entry.byValues, byValue);
void 0 !== value && (byObj[byValue][key] = value);
}
}
return void 0 !== dynamicInfo && (obj[dynamicInfo.byProperty] = dynamicInfo.fn), 
obj;
}, getValueType = value => void 0 === value ? 0 : value === DELETE ? 4 : Array.isArray(value) ? -1 !== value.lastIndexOf("...") ? 2 : 1 : "object" != typeof value || null === value || value.constructor && value.constructor !== Object ? 1 : 3, cleverMerge = (first, second) => void 0 === second ? first : void 0 === first || "object" != typeof second || null === second ? second : "object" != typeof first || null === first ? first : _cleverMerge(first, second, !1), _cleverMerge = (first, second, internalCaching = !1) => {
const firstObject = internalCaching ? cachedParseObject(first) : parseObject(first), {static: firstInfo, dynamic: firstDynamicInfo} = firstObject;
if (void 0 !== firstDynamicInfo) {
let {byProperty, fn} = firstDynamicInfo;
const fnInfo = fn[DYNAMIC_INFO];
fnInfo && (second = internalCaching ? cachedCleverMerge(fnInfo[1], second) : cleverMerge(fnInfo[1], second), 
fn = fnInfo[0]);
const newFn = (...args) => {
const fnResult = fn(...args);
return internalCaching ? cachedCleverMerge(fnResult, second) : cleverMerge(fnResult, second);
};
return newFn[DYNAMIC_INFO] = [ fn, second ], serializeObject(firstObject.static, {
byProperty,
fn: newFn
});
}
const secondObject = internalCaching ? cachedParseObject(second) : parseObject(second), {static: secondInfo, dynamic: secondDynamicInfo} = secondObject, resultInfo = new Map;
for (const [key, firstEntry] of firstInfo) {
const secondEntry = secondInfo.get(key), entry = void 0 !== secondEntry ? mergeEntries(firstEntry, secondEntry, internalCaching) : firstEntry;
resultInfo.set(key, entry);
}
for (const [key, secondEntry] of secondInfo) firstInfo.has(key) || resultInfo.set(key, secondEntry);
return serializeObject(resultInfo, secondDynamicInfo);
}, mergeEntries = (firstEntry, secondEntry, internalCaching) => {
switch (getValueType(secondEntry.base)) {
case 1:
case 4:
return secondEntry;

case 0:
if (firstEntry.byProperty) {
if (firstEntry.byProperty !== secondEntry.byProperty) throw new Error(`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`);
{
const newByValues = new Map(firstEntry.byValues);
for (const [key, value] of secondEntry.byValues) {
const firstValue = getFromByValues(firstEntry.byValues, key);
newByValues.set(key, mergeSingleValue(firstValue, value, internalCaching));
}
return {
base: firstEntry.base,
byProperty: firstEntry.byProperty,
byValues: newByValues
};
}
}
return {
base: firstEntry.base,
byProperty: secondEntry.byProperty,
byValues: secondEntry.byValues
};

default:
{
if (!firstEntry.byProperty) return {
base: mergeSingleValue(firstEntry.base, secondEntry.base, internalCaching),
byProperty: secondEntry.byProperty,
byValues: secondEntry.byValues
};
let newBase;
const intermediateByValues = new Map(firstEntry.byValues);
for (const [key, value] of intermediateByValues) intermediateByValues.set(key, mergeSingleValue(value, secondEntry.base, internalCaching));
if (Array.from(firstEntry.byValues.values()).every((value => {
const type = getValueType(value);
return 1 === type || 4 === type;
})) ? newBase = mergeSingleValue(firstEntry.base, secondEntry.base, internalCaching) : (newBase = firstEntry.base, 
intermediateByValues.has("default") || intermediateByValues.set("default", secondEntry.base)), 
!secondEntry.byProperty) return {
base: newBase,
byProperty: firstEntry.byProperty,
byValues: intermediateByValues
};
if (firstEntry.byProperty !== secondEntry.byProperty) throw new Error(`${firstEntry.byProperty} and ${secondEntry.byProperty} for a single property is not supported`);
const newByValues = new Map(intermediateByValues);
for (const [key, value] of secondEntry.byValues) {
const firstValue = getFromByValues(intermediateByValues, key);
newByValues.set(key, mergeSingleValue(firstValue, value, internalCaching));
}
return {
base: newBase,
byProperty: firstEntry.byProperty,
byValues: newByValues
};
}
}
}, getFromByValues = (byValues, key) => "default" !== key && byValues.has(key) ? byValues.get(key) : byValues.get("default"), mergeSingleValue = (a, b, internalCaching) => {
const bType = getValueType(b), aType = getValueType(a);
switch (bType) {
case 4:
case 1:
return b;

case 3:
return 3 !== aType ? b : internalCaching ? cachedCleverMerge(a, b) : cleverMerge(a, b);

case 0:
return a;

case 2:
switch (1 !== aType ? aType : Array.isArray(a) ? 2 : 3) {
case 0:
return b;

case 4:
return b.filter((item => "..." !== item));

case 2:
{
const newArray = [];
for (const item of b) if ("..." === item) for (const item of a) newArray.push(item); else newArray.push(item);
return newArray;
}

case 3:
return b.map((item => "..." === item ? a : item));

default:
throw new Error("Not implemented");
}

default:
throw new Error("Not implemented");
}
}, removeOperations = obj => {
const newObj = {};
for (const key of Object.keys(obj)) {
const value = obj[key];
switch (getValueType(value)) {
case 0:
case 4:
break;

case 3:
newObj[key] = removeOperations(value);
break;

case 2:
newObj[key] = value.filter((i => "..." !== i));
break;

default:
newObj[key] = value;
}
}
return newObj;
}, resolveByProperty = (obj, byProperty, ...values) => {
if ("object" != typeof obj || null === obj || !(byProperty in obj)) return obj;
const {[byProperty]: _byValue, ..._remaining} = obj, remaining = _remaining, byValue = _byValue;
if ("object" == typeof byValue) {
const key = values[0];
return key in byValue ? cachedCleverMerge(remaining, byValue[key]) : "default" in byValue ? cachedCleverMerge(remaining, byValue.default) : remaining;
}
if ("function" == typeof byValue) {
const result = byValue.apply(null, values);
return cachedCleverMerge(remaining, resolveByProperty(result, byProperty, ...values));
}
};
exports.cachedSetProperty = (obj, property, value) => {
let mapByProperty = setPropertyCache.get(obj);
void 0 === mapByProperty && (mapByProperty = new Map, setPropertyCache.set(obj, mapByProperty));
let mapByValue = mapByProperty.get(property);
void 0 === mapByValue && (mapByValue = new Map, mapByProperty.set(property, mapByValue));
let result = mapByValue.get(value);
return result || (result = {
...obj,
[property]: value
}, mapByValue.set(value, result), result);
}, exports.cachedCleverMerge = cachedCleverMerge, exports.cleverMerge = cleverMerge, 
exports.resolveByProperty = resolveByProperty, exports.removeOperations = removeOperations, 
exports.DELETE = DELETE;
},
40028: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const {compareRuntime} = __webpack_require__(14372), createCachedParameterizedComparator = fn => {
const map = new WeakMap;
return arg => {
const cachedResult = map.get(arg);
if (void 0 !== cachedResult) return cachedResult;
const result = fn.bind(null, arg);
return map.set(arg, result), result;
};
};
exports.compareChunksById = (a, b) => compareIds(a.id, b.id), exports.compareModulesByIdentifier = (a, b) => compareIds(a.identifier(), b.identifier());
exports.compareModulesById = createCachedParameterizedComparator(((chunkGraph, a, b) => compareIds(chunkGraph.getModuleId(a), chunkGraph.getModuleId(b))));
const compareNumbers = (a, b) => typeof a != typeof b ? typeof a < typeof b ? -1 : 1 : a < b ? -1 : a > b ? 1 : 0;
exports.compareNumbers = compareNumbers;
exports.compareStringsNumeric = (a, b) => {
const partsA = a.split(/(\d+)/), partsB = b.split(/(\d+)/), len = Math.min(partsA.length, partsB.length);
for (let i = 0; i < len; i++) {
const pA = partsA[i], pB = partsB[i];
if (i % 2 == 0) {
if (pA.length > pB.length) return pA.slice(0, pB.length) > pB ? 1 : -1;
if (pB.length > pA.length) return pB.slice(0, pA.length) > pA ? -1 : 1;
if (pA < pB) return -1;
if (pA > pB) return 1;
} else {
const nA = +pA, nB = +pB;
if (nA < nB) return -1;
if (nA > nB) return 1;
}
}
return partsB.length < partsA.length ? 1 : partsB.length > partsA.length ? -1 : 0;
};
exports.compareModulesByPostOrderIndexOrIdentifier = createCachedParameterizedComparator(((moduleGraph, a, b) => {
const cmp = compareNumbers(moduleGraph.getPostOrderIndex(a), moduleGraph.getPostOrderIndex(b));
return 0 !== cmp ? cmp : compareIds(a.identifier(), b.identifier());
}));
exports.compareModulesByPreOrderIndexOrIdentifier = createCachedParameterizedComparator(((moduleGraph, a, b) => {
const cmp = compareNumbers(moduleGraph.getPreOrderIndex(a), moduleGraph.getPreOrderIndex(b));
return 0 !== cmp ? cmp : compareIds(a.identifier(), b.identifier());
}));
exports.compareModulesByIdOrIdentifier = createCachedParameterizedComparator(((chunkGraph, a, b) => {
const cmp = compareIds(chunkGraph.getModuleId(a), chunkGraph.getModuleId(b));
return 0 !== cmp ? cmp : compareIds(a.identifier(), b.identifier());
}));
exports.compareChunks = createCachedParameterizedComparator(((chunkGraph, a, b) => chunkGraph.compareChunks(a, b)));
const compareIds = (a, b) => typeof a != typeof b ? typeof a < typeof b ? -1 : 1 : a < b ? -1 : a > b ? 1 : 0;
exports.compareIds = compareIds;
exports.compareStrings = (a, b) => a < b ? -1 : a > b ? 1 : 0;
exports.compareChunkGroupsByIndex = (a, b) => a.index < b.index ? -1 : 1;
class TwoKeyWeakMap {
constructor() {
this._map = new WeakMap;
}
get(key1, key2) {
const childMap = this._map.get(key1);
if (void 0 !== childMap) return childMap.get(key2);
}
set(key1, key2, value) {
let childMap = this._map.get(key1);
void 0 === childMap && (childMap = new WeakMap, this._map.set(key1, childMap)), 
childMap.set(key2, value);
}
}
const concatComparatorsCache = new TwoKeyWeakMap, concatComparators = (c1, c2, ...cRest) => {
if (cRest.length > 0) {
const [c3, ...cRest2] = cRest;
return concatComparators(c1, concatComparators(c2, c3, ...cRest2));
}
const cacheEntry = concatComparatorsCache.get(c1, c2);
if (void 0 !== cacheEntry) return cacheEntry;
const result = (a, b) => {
const res = c1(a, b);
return 0 !== res ? res : c2(a, b);
};
return concatComparatorsCache.set(c1, c2, result), result;
};
exports.concatComparators = concatComparators;
const compareSelectCache = new TwoKeyWeakMap, compareSelect = (getter, comparator) => {
const cacheEntry = compareSelectCache.get(getter, comparator);
if (void 0 !== cacheEntry) return cacheEntry;
const result = (a, b) => {
const aValue = getter(a), bValue = getter(b);
return null != aValue ? null != bValue ? comparator(aValue, bValue) : -1 : null != bValue ? 1 : 0;
};
return compareSelectCache.set(getter, comparator, result), result;
};
exports.compareSelect = compareSelect;
const compareIteratorsCache = new WeakMap, compareIterables = elementComparator => {
const cacheEntry = compareIteratorsCache.get(elementComparator);
if (void 0 !== cacheEntry) return cacheEntry;
const result = (a, b) => {
const aI = a[Symbol.iterator](), bI = b[Symbol.iterator]();
for (;;) {
const aItem = aI.next(), bItem = bI.next();
if (aItem.done) return bItem.done ? 0 : -1;
if (bItem.done) return 1;
const res = elementComparator(aItem.value, bItem.value);
if (0 !== res) return res;
}
};
return compareIteratorsCache.set(elementComparator, result), result;
};
exports.compareIterables = compareIterables, exports.keepOriginalOrder = iterable => {
const map = new Map;
let i = 0;
for (const item of iterable) map.set(item, i++);
return (a, b) => compareNumbers(map.get(a), map.get(b));
}, exports.compareChunksNatural = chunkGraph => {
const cmpFn = exports.compareModulesById(chunkGraph), cmpIterableFn = compareIterables(cmpFn);
return concatComparators(compareSelect((chunk => chunk.name), compareIds), compareSelect((chunk => chunk.runtime), compareRuntime), compareSelect((chunk => chunkGraph.getOrderedChunkModulesIterable(chunk, cmpFn)), cmpIterableFn));
}, exports.compareLocations = (a, b) => {
let isObjectA = "object" == typeof a && null !== a, isObjectB = "object" == typeof b && null !== b;
if (!isObjectA || !isObjectB) return isObjectA ? 1 : isObjectB ? -1 : 0;
if ("start" in a) {
if (!("start" in b)) return -1;
{
const ap = a.start, bp = b.start;
if (ap.line < bp.line) return -1;
if (ap.line > bp.line) return 1;
if (ap.column < bp.column) return -1;
if (ap.column > bp.column) return 1;
}
} else if ("start" in b) return 1;
if ("name" in a) {
if (!("name" in b)) return -1;
if (a.name < b.name) return -1;
if (a.name > b.name) return 1;
} else if ("name" in b) return 1;
if ("index" in a) {
if (!("index" in b)) return -1;
if (a.index < b.index) return -1;
if (a.index > b.index) return 1;
} else if ("index" in b) return 1;
return 0;
};
},
65814: module => {
"use strict";
const quoteMeta = str => str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&"), toSimpleString = str => "" + +str === str ? str : JSON.stringify(str), compileBooleanMatcher = map => {
const positiveItems = Object.keys(map).filter((i => map[i])), negativeItems = Object.keys(map).filter((i => !map[i]));
return 0 !== positiveItems.length && (0 === negativeItems.length || compileBooleanMatcherFromLists(positiveItems, negativeItems));
}, compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {
if (0 === positiveItems.length) return () => "false";
if (0 === negativeItems.length) return () => "true";
if (1 === positiveItems.length) return value => `${toSimpleString(positiveItems[0])} == ${value}`;
if (1 === negativeItems.length) return value => `${toSimpleString(negativeItems[0])} != ${value}`;
const positiveRegexp = itemsToRegexp(positiveItems), negativeRegexp = itemsToRegexp(negativeItems);
return positiveRegexp.length <= negativeRegexp.length ? value => `/^${positiveRegexp}$/.test(${value})` : value => `!/^${negativeRegexp}$/.test(${value})`;
}, popCommonItems = (itemsSet, getKey, condition) => {
const map = new Map;
for (const item of itemsSet) {
const key = getKey(item);
if (key) {
let list = map.get(key);
void 0 === list && (list = [], map.set(key, list)), list.push(item);
}
}
const result = [];
for (const list of map.values()) if (condition(list)) {
for (const item of list) itemsSet.delete(item);
result.push(list);
}
return result;
}, getCommonPrefix = items => {
let prefix = items[0];
for (let i = 1; i < items.length; i++) {
const item = items[i];
for (let p = 0; p < prefix.length; p++) if (item[p] !== prefix[p]) {
prefix = prefix.slice(0, p);
break;
}
}
return prefix;
}, getCommonSuffix = items => {
let suffix = items[0];
for (let i = 1; i < items.length; i++) {
const item = items[i];
for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) if (item[p] !== suffix[s]) {
suffix = suffix.slice(s + 1);
break;
}
}
return suffix;
}, itemsToRegexp = itemsArr => {
if (1 === itemsArr.length) return quoteMeta(itemsArr[0]);
const finishedItems = [];
let countOfSingleCharItems = 0;
for (const item of itemsArr) 1 === item.length && countOfSingleCharItems++;
if (countOfSingleCharItems === itemsArr.length) return `[${quoteMeta(itemsArr.sort().join(""))}]`;
const items = new Set(itemsArr.sort());
if (countOfSingleCharItems > 2) {
let singleCharItems = "";
for (const item of items) 1 === item.length && (singleCharItems += item, items.delete(item));
finishedItems.push(`[${quoteMeta(singleCharItems)}]`);
}
if (0 === finishedItems.length && 2 === items.size) {
const prefix = getCommonPrefix(itemsArr), suffix = getCommonSuffix(itemsArr.map((item => item.slice(prefix.length))));
if (prefix.length > 0 || suffix.length > 0) return `${quoteMeta(prefix)}${itemsToRegexp(itemsArr.map((i => i.slice(prefix.length, -suffix.length || void 0))))}${quoteMeta(suffix)}`;
}
if (0 === finishedItems.length && 2 === items.size) {
const it = items[Symbol.iterator](), a = it.next().value, b = it.next().value;
if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) return `${itemsToRegexp([ a.slice(0, -1), b.slice(0, -1) ])}${quoteMeta(a.slice(-1))}`;
}
const prefixed = popCommonItems(items, (item => item.length >= 1 && item[0]), (list => list.length >= 3 || !(list.length <= 1) && list[0][1] === list[1][1]));
for (const prefixedItems of prefixed) {
const prefix = getCommonPrefix(prefixedItems);
finishedItems.push(`${quoteMeta(prefix)}${itemsToRegexp(prefixedItems.map((i => i.slice(prefix.length))))}`);
}
const suffixed = popCommonItems(items, (item => item.length >= 1 && item.slice(-1)), (list => list.length >= 3 || !(list.length <= 1) && list[0].slice(-2) === list[1].slice(-2)));
for (const suffixedItems of suffixed) {
const suffix = getCommonSuffix(suffixedItems);
finishedItems.push(`${itemsToRegexp(suffixedItems.map((i => i.slice(0, -suffix.length))))}${quoteMeta(suffix)}`);
}
const conditional = finishedItems.concat(Array.from(items, quoteMeta));
return 1 === conditional.length ? conditional[0] : `(${conditional.join("|")})`;
};
compileBooleanMatcher.fromLists = compileBooleanMatcherFromLists, compileBooleanMatcher.itemsToRegexp = itemsToRegexp, 
module.exports = compileBooleanMatcher;
},
59586: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const memoize = __webpack_require__(98216), getValidate = memoize((() => __webpack_require__(33842).validate));
module.exports = (check, getSchema, options) => (getSchema = memoize(getSchema), 
value => {
check && !check(value) && (getValidate()(getSchema(), value, options), check && __webpack_require__(73837).deprecate((() => {}), "webpack bug: Pre-compiled schema reports error while real schema is happy. This has performance drawbacks.", "DEP_WEBPACK_PRE_COMPILED_SCHEMA_INVALID")());
});
},
27466: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hash = __webpack_require__(99432), digestCaches = {};
class BulkUpdateDecorator extends Hash {
constructor(hashOrFactory, hashKey) {
super(), this.hashKey = hashKey, "function" == typeof hashOrFactory ? (this.hashFactory = hashOrFactory, 
this.hash = void 0) : (this.hashFactory = void 0, this.hash = hashOrFactory), this.buffer = "";
}
update(data, inputEncoding) {
return void 0 !== inputEncoding || "string" != typeof data || data.length > 2e3 ? (void 0 === this.hash && (this.hash = this.hashFactory()), 
this.buffer.length > 0 && (this.hash.update(this.buffer), this.buffer = ""), this.hash.update(data, inputEncoding)) : (this.buffer += data, 
this.buffer.length > 2e3 && (void 0 === this.hash && (this.hash = this.hashFactory()), 
this.hash.update(this.buffer), this.buffer = "")), this;
}
digest(encoding) {
let digestCache;
const buffer = this.buffer;
if (void 0 === this.hash) {
const cacheKey = `${this.hashKey}-${encoding}`;
digestCache = digestCaches[cacheKey], void 0 === digestCache && (digestCache = digestCaches[cacheKey] = new Map);
const cacheEntry = digestCache.get(buffer);
if (void 0 !== cacheEntry) return cacheEntry;
this.hash = this.hashFactory();
}
buffer.length > 0 && this.hash.update(buffer);
const digestResult = this.hash.digest(encoding), result = "string" == typeof digestResult ? digestResult : digestResult.toString();
return void 0 !== digestCache && digestCache.set(buffer, result), result;
}
}
class DebugHash extends Hash {
constructor() {
super(), this.string = "";
}
update(data, inputEncoding) {
return "string" != typeof data && (data = data.toString("utf-8")), data.startsWith("debug-digest-") && (data = Buffer.from(data.slice("debug-digest-".length), "hex").toString()), 
this.string += `[${data}](${(new Error).stack.split("\n", 3)[2]})\n`, this;
}
digest(encoding) {
return "debug-digest-" + Buffer.from(this.string).toString("hex");
}
}
let crypto, createXXHash64, createMd4, BatchedHash;
module.exports = algorithm => {
if ("function" == typeof algorithm) return new BulkUpdateDecorator((() => new algorithm));
switch (algorithm) {
case "debug":
return new DebugHash;

case "xxhash64":
return void 0 === createXXHash64 && (createXXHash64 = __webpack_require__(54816), 
void 0 === BatchedHash && (BatchedHash = __webpack_require__(4902))), new BatchedHash(createXXHash64());

case "md4":
return void 0 === createMd4 && (createMd4 = __webpack_require__(29088), void 0 === BatchedHash && (BatchedHash = __webpack_require__(4902))), 
new BatchedHash(createMd4());

case "native-md4":
return void 0 === crypto && (crypto = __webpack_require__(6113)), new BulkUpdateDecorator((() => crypto.createHash("md4")), "md4");

default:
return void 0 === crypto && (crypto = __webpack_require__(6113)), new BulkUpdateDecorator((() => crypto.createHash(algorithm)), algorithm);
}
};
},
33469: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), deprecationCache = new Map, createDeprecation = (message, code) => {
const cached = deprecationCache.get(message);
if (void 0 !== cached) return cached;
const fn = util.deprecate((() => {}), message, "DEP_WEBPACK_DEPRECATION_" + code);
return deprecationCache.set(message, fn), fn;
}, COPY_METHODS = [ "concat", "entry", "filter", "find", "findIndex", "includes", "indexOf", "join", "lastIndexOf", "map", "reduce", "reduceRight", "slice", "some" ], DISABLED_METHODS = [ "copyWithin", "entries", "fill", "keys", "pop", "reverse", "shift", "splice", "sort", "unshift" ];
exports.arrayToSetDeprecation = (set, name) => {
for (const method of COPY_METHODS) {
if (set[method]) continue;
const d = createDeprecation(`${name} was changed from Array to Set (using Array method '${method}' is deprecated)`, "ARRAY_TO_SET");
set[method] = function() {
d();
const array = Array.from(this);
return Array.prototype[method].apply(array, arguments);
};
}
const dPush = createDeprecation(`${name} was changed from Array to Set (using Array method 'push' is deprecated)`, "ARRAY_TO_SET_PUSH"), dLength = createDeprecation(`${name} was changed from Array to Set (using Array property 'length' is deprecated)`, "ARRAY_TO_SET_LENGTH"), dIndexer = createDeprecation(`${name} was changed from Array to Set (indexing Array is deprecated)`, "ARRAY_TO_SET_INDEXER");
set.push = function() {
dPush();
for (const item of Array.from(arguments)) this.add(item);
return this.size;
};
for (const method of DISABLED_METHODS) set[method] || (set[method] = () => {
throw new Error(`${name} was changed from Array to Set (using Array method '${method}' is not possible)`);
});
const createIndexGetter = index => function() {
dIndexer();
let i = 0;
for (const item of this) if (i++ === index) return item;
}, defineIndexGetter = index => {
Object.defineProperty(set, index, {
get: createIndexGetter(index),
set(value) {
throw new Error(`${name} was changed from Array to Set (indexing Array with write is not possible)`);
}
});
};
defineIndexGetter(0);
let indexerDefined = 1;
Object.defineProperty(set, "length", {
get() {
dLength();
const length = this.size;
for (;indexerDefined < length + 1; indexerDefined++) defineIndexGetter(indexerDefined);
return length;
},
set(value) {
throw new Error(`${name} was changed from Array to Set (writing to Array property 'length' is not possible)`);
}
}), set[Symbol.isConcatSpreadable] = !0;
}, exports.createArrayToSetDeprecationSet = name => {
let initialized = !1;
class SetDeprecatedArray extends Set {
constructor(items) {
super(items), initialized || (initialized = !0, exports.arrayToSetDeprecation(SetDeprecatedArray.prototype, name));
}
}
return SetDeprecatedArray;
}, exports.soonFrozenObjectDeprecation = (obj, name, code, note = "") => {
const message = `${name} will be frozen in future, all modifications are deprecated.${note && `\n${note}`}`;
return new Proxy(obj, {
set: util.deprecate(((target, property, value, receiver) => Reflect.set(target, property, value, receiver)), message, code),
defineProperty: util.deprecate(((target, property, descriptor) => Reflect.defineProperty(target, property, descriptor)), message, code),
deleteProperty: util.deprecate(((target, property) => Reflect.deleteProperty(target, property)), message, code),
setPrototypeOf: util.deprecate(((target, proto) => Reflect.setPrototypeOf(target, proto)), message, code)
});
};
const deprecateAllProperties = (obj, message, code) => {
const newObj = {}, descriptors = Object.getOwnPropertyDescriptors(obj);
for (const name of Object.keys(descriptors)) {
const descriptor = descriptors[name];
if ("function" == typeof descriptor.value) Object.defineProperty(newObj, name, {
...descriptor,
value: util.deprecate(descriptor.value, message, code)
}); else if (descriptor.get || descriptor.set) Object.defineProperty(newObj, name, {
...descriptor,
get: descriptor.get && util.deprecate(descriptor.get, message, code),
set: descriptor.set && util.deprecate(descriptor.set, message, code)
}); else {
let value = descriptor.value;
Object.defineProperty(newObj, name, {
configurable: descriptor.configurable,
enumerable: descriptor.enumerable,
get: util.deprecate((() => value), message, code),
set: descriptor.writable ? util.deprecate((v => value = v), message, code) : void 0
});
}
}
return newObj;
};
exports.deprecateAllProperties = deprecateAllProperties, exports.createFakeHook = (fakeHook, message, code) => (message && code && (fakeHook = deprecateAllProperties(fakeHook, message, code)), 
Object.freeze(Object.assign(fakeHook, {
_fakeHook: !0
})));
},
2948: module => {
"use strict";
const similarity = (a, b) => {
const l = Math.min(a.length, b.length);
let dist = 0;
for (let i = 0; i < l; i++) {
const ca = a.charCodeAt(i), cb = b.charCodeAt(i);
dist += Math.max(0, 10 - Math.abs(ca - cb));
}
return dist;
}, getName = (a, b, usedNames) => {
const l = Math.min(a.length, b.length);
let i = 0;
for (;i < l; ) {
if (a.charCodeAt(i) !== b.charCodeAt(i)) {
i++;
break;
}
i++;
}
for (;i < l; ) {
const name = a.slice(0, i), lowerName = name.toLowerCase();
if (!usedNames.has(lowerName)) return usedNames.add(lowerName), name;
i++;
}
return a;
}, addSizeTo = (total, size) => {
for (const key of Object.keys(size)) total[key] = (total[key] || 0) + size[key];
}, subtractSizeFrom = (total, size) => {
for (const key of Object.keys(size)) total[key] -= size[key];
}, sumSize = nodes => {
const sum = Object.create(null);
for (const node of nodes) addSizeTo(sum, node.size);
return sum;
}, isTooBig = (size, maxSize) => {
for (const key of Object.keys(size)) {
const s = size[key];
if (0 === s) continue;
const maxSizeValue = maxSize[key];
if ("number" == typeof maxSizeValue && s > maxSizeValue) return !0;
}
return !1;
}, isTooSmall = (size, minSize) => {
for (const key of Object.keys(size)) {
const s = size[key];
if (0 === s) continue;
const minSizeValue = minSize[key];
if ("number" == typeof minSizeValue && s < minSizeValue) return !0;
}
return !1;
}, getNumberOfMatchingSizeTypes = (size, types) => {
let i = 0;
for (const key of Object.keys(size)) 0 !== size[key] && types.has(key) && i++;
return i;
}, selectiveSizeSum = (size, types) => {
let sum = 0;
for (const key of Object.keys(size)) 0 !== size[key] && types.has(key) && (sum += size[key]);
return sum;
};
class Node {
constructor(item, key, size) {
this.item = item, this.key = key, this.size = size;
}
}
class Group {
constructor(nodes, similarities, size) {
this.nodes = nodes, this.similarities = similarities, this.size = size || sumSize(nodes), 
this.key = void 0;
}
popNodes(filter) {
const newNodes = [], newSimilarities = [], resultNodes = [];
let lastNode;
for (let i = 0; i < this.nodes.length; i++) {
const node = this.nodes[i];
filter(node) ? resultNodes.push(node) : (newNodes.length > 0 && newSimilarities.push(lastNode === this.nodes[i - 1] ? this.similarities[i - 1] : similarity(lastNode.key, node.key)), 
newNodes.push(node), lastNode = node);
}
if (resultNodes.length !== this.nodes.length) return this.nodes = newNodes, this.similarities = newSimilarities, 
this.size = sumSize(newNodes), resultNodes;
}
}
module.exports = ({maxSize, minSize, items, getSize, getKey}) => {
const result = [], nodes = Array.from(items, (item => new Node(item, getKey(item), getSize(item)))), initialNodes = [];
nodes.sort(((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0));
for (const node of nodes) isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize) ? result.push(new Group([ node ], [])) : initialNodes.push(node);
if (initialNodes.length > 0) {
const initialGroup = new Group(initialNodes, (nodes => {
const similarities = [];
let last;
for (const node of nodes) void 0 !== last && similarities.push(similarity(last.key, node.key)), 
last = node;
return similarities;
})(initialNodes)), removeProblematicNodes = (group, consideredSize = group.size) => {
const problemTypes = ((size, minSize) => {
const types = new Set;
for (const key of Object.keys(size)) {
const s = size[key];
if (0 === s) continue;
const minSizeValue = minSize[key];
"number" == typeof minSizeValue && s < minSizeValue && types.add(key);
}
return types;
})(consideredSize, minSize);
if (problemTypes.size > 0) {
const problemNodes = group.popNodes((n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0));
if (void 0 === problemNodes) return !1;
const possibleResultGroups = result.filter((n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0));
if (possibleResultGroups.length > 0) {
const bestGroup = possibleResultGroups.reduce(((min, group) => {
const minMatches = getNumberOfMatchingSizeTypes(min, problemTypes), groupMatches = getNumberOfMatchingSizeTypes(group, problemTypes);
return minMatches !== groupMatches ? minMatches < groupMatches ? group : min : selectiveSizeSum(min.size, problemTypes) > selectiveSizeSum(group.size, problemTypes) ? group : min;
}));
for (const node of problemNodes) bestGroup.nodes.push(node);
bestGroup.nodes.sort(((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0));
} else result.push(new Group(problemNodes, null));
return !0;
}
return !1;
};
if (initialGroup.nodes.length > 0) {
const queue = [ initialGroup ];
for (;queue.length; ) {
const group = queue.pop();
if (!isTooBig(group.size, maxSize)) {
result.push(group);
continue;
}
if (removeProblematicNodes(group)) {
queue.push(group);
continue;
}
let left = 1, leftSize = Object.create(null);
for (addSizeTo(leftSize, group.nodes[0].size); left < group.nodes.length && isTooSmall(leftSize, minSize); ) addSizeTo(leftSize, group.nodes[left].size), 
left++;
let right = group.nodes.length - 2, rightSize = Object.create(null);
for (addSizeTo(rightSize, group.nodes[group.nodes.length - 1].size); right >= 0 && isTooSmall(rightSize, minSize); ) addSizeTo(rightSize, group.nodes[right].size), 
right--;
if (left - 1 > right) {
let prevSize;
if (right < group.nodes.length - left ? (subtractSizeFrom(rightSize, group.nodes[right + 1].size), 
prevSize = rightSize) : (subtractSizeFrom(leftSize, group.nodes[left - 1].size), 
prevSize = leftSize), removeProblematicNodes(group, prevSize)) {
queue.push(group);
continue;
}
result.push(group);
continue;
}
if (left <= right) {
let best = -1, bestSimilarity = 1 / 0, pos = left, rightSize = sumSize(group.nodes.slice(pos));
for (;pos <= right + 1; ) {
const similarity = group.similarities[pos - 1];
similarity < bestSimilarity && !isTooSmall(leftSize, minSize) && !isTooSmall(rightSize, minSize) && (best = pos, 
bestSimilarity = similarity), addSizeTo(leftSize, group.nodes[pos].size), subtractSizeFrom(rightSize, group.nodes[pos].size), 
pos++;
}
if (best < 0) {
result.push(group);
continue;
}
left = best, right = best - 1;
}
const rightNodes = [ group.nodes[right + 1] ], rightSimilarities = [];
for (let i = right + 2; i < group.nodes.length; i++) rightSimilarities.push(group.similarities[i - 1]), 
rightNodes.push(group.nodes[i]);
queue.push(new Group(rightNodes, rightSimilarities));
const leftNodes = [ group.nodes[0] ], leftSimilarities = [];
for (let i = 1; i < left; i++) leftSimilarities.push(group.similarities[i - 1]), 
leftNodes.push(group.nodes[i]);
queue.push(new Group(leftNodes, leftSimilarities));
}
}
}
result.sort(((a, b) => a.nodes[0].key < b.nodes[0].key ? -1 : a.nodes[0].key > b.nodes[0].key ? 1 : 0));
const usedNames = new Set;
for (let i = 0; i < result.length; i++) {
const group = result[i];
if (1 === group.nodes.length) group.key = group.nodes[0].key; else {
const first = group.nodes[0], last = group.nodes[group.nodes.length - 1], name = getName(first.key, last.key, usedNames);
group.key = name;
}
}
return result.map((group => ({
key: group.key,
items: group.nodes.map((node => node.item)),
size: group.size
})));
};
},
5599: module => {
"use strict";
module.exports = function(urlAndGlobal) {
const index = urlAndGlobal.indexOf("@");
if (index <= 0 || index === urlAndGlobal.length - 1) throw new Error(`Invalid request "${urlAndGlobal}"`);
return [ urlAndGlobal.substring(index + 1), urlAndGlobal.substring(0, index) ];
};
},
78739: module => {
"use strict";
class Node {
constructor(item) {
this.item = item, this.dependencies = new Set, this.marker = 0, this.cycle = void 0, 
this.incoming = 0;
}
}
class Cycle {
constructor() {
this.nodes = new Set;
}
}
module.exports = (items, getDependencies) => {
const itemToNode = new Map;
for (const item of items) {
const node = new Node(item);
itemToNode.set(item, node);
}
if (itemToNode.size <= 1) return items;
for (const node of itemToNode.values()) for (const dep of getDependencies(node.item)) {
const depNode = itemToNode.get(dep);
void 0 !== depNode && node.dependencies.add(depNode);
}
const roots = new Set, rootCycles = new Set;
for (const selectedNode of itemToNode.values()) if (0 === selectedNode.marker) {
selectedNode.marker = 1;
const stack = [ {
node: selectedNode,
openEdges: Array.from(selectedNode.dependencies)
} ];
for (;stack.length > 0; ) {
const topOfStack = stack[stack.length - 1];
if (topOfStack.openEdges.length > 0) {
const dependency = topOfStack.openEdges.pop();
switch (dependency.marker) {
case 0:
stack.push({
node: dependency,
openEdges: Array.from(dependency.dependencies)
}), dependency.marker = 1;
break;

case 1:
{
let cycle = dependency.cycle;
cycle || (cycle = new Cycle, cycle.nodes.add(dependency), dependency.cycle = cycle);
for (let i = stack.length - 1; stack[i].node !== dependency; i--) {
const node = stack[i].node;
if (node.cycle) {
if (node.cycle !== cycle) for (const cycleNode of node.cycle.nodes) cycleNode.cycle = cycle, 
cycle.nodes.add(cycleNode);
} else node.cycle = cycle, cycle.nodes.add(node);
}
break;
}

case 4:
dependency.marker = 2, roots.delete(dependency);
break;

case 3:
rootCycles.delete(dependency.cycle), dependency.marker = 2;
}
} else stack.pop(), topOfStack.node.marker = 2;
}
const cycle = selectedNode.cycle;
if (cycle) {
for (const node of cycle.nodes) node.marker = 3;
rootCycles.add(cycle);
} else selectedNode.marker = 4, roots.add(selectedNode);
}
for (const cycle of rootCycles) {
let max = 0;
const cycleRoots = new Set, nodes = cycle.nodes;
for (const node of nodes) for (const dep of node.dependencies) if (nodes.has(dep)) {
if (dep.incoming++, dep.incoming < max) continue;
dep.incoming > max && (cycleRoots.clear(), max = dep.incoming), cycleRoots.add(dep);
}
for (const cycleRoot of cycleRoots) roots.add(cycleRoot);
}
if (roots.size > 0) return Array.from(roots, (r => r.item));
throw new Error("Implementation of findGraphRoots is broken");
};
},
57075: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017);
exports.relative = (fs, rootPath, targetPath) => {
if (fs && fs.relative) return fs.relative(rootPath, targetPath);
if (path.posix.isAbsolute(rootPath)) return path.posix.relative(rootPath, targetPath);
if (path.win32.isAbsolute(rootPath)) return path.win32.relative(rootPath, targetPath);
throw new Error(`${rootPath} is neither a posix nor a windows path, and there is no 'relative' method defined in the file system`);
};
const join = (fs, rootPath, filename) => {
if (fs && fs.join) return fs.join(rootPath, filename);
if (path.posix.isAbsolute(rootPath)) return path.posix.join(rootPath, filename);
if (path.win32.isAbsolute(rootPath)) return path.win32.join(rootPath, filename);
throw new Error(`${rootPath} is neither a posix nor a windows path, and there is no 'join' method defined in the file system`);
};
exports.join = join;
const dirname = (fs, absPath) => {
if (fs && fs.dirname) return fs.dirname(absPath);
if (path.posix.isAbsolute(absPath)) return path.posix.dirname(absPath);
if (path.win32.isAbsolute(absPath)) return path.win32.dirname(absPath);
throw new Error(`${absPath} is neither a posix nor a windows path, and there is no 'dirname' method defined in the file system`);
};
exports.dirname = dirname;
const mkdirp = (fs, p, callback) => {
fs.mkdir(p, (err => {
if (err) {
if ("ENOENT" === err.code) {
const dir = dirname(fs, p);
return dir === p ? void callback(err) : void mkdirp(fs, dir, (err => {
err ? callback(err) : fs.mkdir(p, (err => {
if (err) return "EEXIST" === err.code ? void callback() : void callback(err);
callback();
}));
}));
}
return "EEXIST" === err.code ? void callback() : void callback(err);
}
callback();
}));
};
exports.mkdirp = mkdirp;
const mkdirpSync = (fs, p) => {
try {
fs.mkdirSync(p);
} catch (err) {
if (err) {
if ("ENOENT" === err.code) {
const dir = dirname(fs, p);
if (dir === p) throw err;
return mkdirpSync(fs, dir), void fs.mkdirSync(p);
}
if ("EEXIST" === err.code) return;
throw err;
}
}
};
exports.mkdirpSync = mkdirpSync;
exports.readJson = (fs, p, callback) => {
if ("readJson" in fs) return fs.readJson(p, callback);
fs.readFile(p, ((err, buf) => {
if (err) return callback(err);
let data;
try {
data = JSON.parse(buf.toString("utf-8"));
} catch (e) {
return callback(e);
}
return callback(null, data);
}));
};
exports.lstatReadlinkAbsolute = (fs, p, callback) => {
let i = 3;
const doReadLink = () => {
fs.readlink(p, ((err, target) => {
if (err && --i > 0) return doStat();
if (err || !target) return doStat();
const value = target.toString();
callback(null, join(fs, dirname(fs, p), value));
}));
}, doStat = () => "lstat" in fs ? fs.lstat(p, ((err, stats) => err ? callback(err) : stats.isSymbolicLink() ? doReadLink() : void callback(null, stats))) : fs.stat(p, callback);
if ("lstat" in fs) return doStat();
doReadLink();
};
},
4902: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Hash = __webpack_require__(99432), MAX_SHORT_STRING = __webpack_require__(71175).MAX_SHORT_STRING;
module.exports = class extends Hash {
constructor(hash) {
super(), this.string = void 0, this.encoding = void 0, this.hash = hash;
}
update(data, inputEncoding) {
if (void 0 !== this.string) {
if ("string" == typeof data && inputEncoding === this.encoding && this.string.length + data.length < MAX_SHORT_STRING) return this.string += data, 
this;
this.hash.update(this.string, this.encoding), this.string = void 0;
}
return "string" == typeof data ? !(data.length < MAX_SHORT_STRING) || inputEncoding && inputEncoding.startsWith("ba") ? this.hash.update(data, inputEncoding) : (this.string = data, 
this.encoding = inputEncoding) : this.hash.update(data), this;
}
digest(encoding) {
return void 0 !== this.string && this.hash.update(this.string, this.encoding), this.hash.digest(encoding);
}
};
},
29088: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const create = __webpack_require__(71175), md4 = new WebAssembly.Module(Buffer.from("AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqLEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvSCgEZfyMBIQUjAiECIwMhAyMEIQQDQCAAIAFLBEAgASgCJCISIAEoAiAiEyABKAIcIgkgASgCGCIIIAEoAhQiByABKAIQIg4gASgCDCIGIAEoAggiDyABKAIEIhAgASgCACIRIAMgBHMgAnEgBHMgBWpqQQN3IgogAiADc3EgA3MgBGpqQQd3IgsgAiAKc3EgAnMgA2pqQQt3IgwgCiALc3EgCnMgAmpqQRN3Ig0gCyAMc3EgC3MgCmpqQQN3IgogDCANc3EgDHMgC2pqQQd3IgsgCiANc3EgDXMgDGpqQQt3IgwgCiALc3EgCnMgDWpqQRN3Ig0gCyAMc3EgC3MgCmpqQQN3IhQgDCANc3EgDHMgC2pqQQd3IRUgASgCLCILIAEoAigiCiAMIA0gDSAUcyAVcXNqakELdyIWIBQgFXNxIBRzIA1qakETdyEXIAEoAjQiGCABKAIwIhkgFSAWcyAXcSAVcyAUampBA3ciFCAWIBdzcSAWcyAVampBB3chFSABKAI8Ig0gASgCOCIMIBQgF3MgFXEgF3MgFmpqQQt3IhYgFCAVc3EgFHMgF2pqQRN3IRcgEyAOIBEgFCAVIBZyIBdxIBUgFnFyampBmfOJ1AVqQQN3IhQgFiAXcnEgFiAXcXIgFWpqQZnzidQFakEFdyIVIBQgF3JxIBQgF3FyIBZqakGZ84nUBWpBCXchFiAPIBggEiAWIAcgFSAQIBQgGSAUIBVyIBZxIBQgFXFyIBdqakGZ84nUBWpBDXciFCAVIBZycSAVIBZxcmpqQZnzidQFakEDdyIVIBQgFnJxIBQgFnFyampBmfOJ1AVqQQV3IhcgFCAVcnEgFCAVcXJqakGZ84nUBWpBCXciFiAVIBdycSAVIBdxciAUampBmfOJ1AVqQQ13IhQgFiAXcnEgFiAXcXIgFWpqQZnzidQFakEDdyEVIBEgBiAVIAwgFCAKIBYgCCAUIBZyIBVxIBQgFnFyIBdqakGZ84nUBWpBBXciFyAUIBVycSAUIBVxcmpqQZnzidQFakEJdyIWIBUgF3JxIBUgF3FyampBmfOJ1AVqQQ13IhQgFiAXcnEgFiAXcXJqakGZ84nUBWpBA3ciFSALIBYgCSAUIBZyIBVxIBQgFnFyIBdqakGZ84nUBWpBBXciFiAUIBVycSAUIBVxcmpqQZnzidQFakEJdyIXIA0gFSAWciAXcSAVIBZxciAUampBmfOJ1AVqQQ13IhRzIBZzampBodfn9gZqQQN3IREgByAIIA4gFCARIBcgESAUc3MgFmogE2pBodfn9gZqQQl3IhNzcyAXampBodfn9gZqQQt3Ig4gDyARIBMgDiARIA4gE3NzIBRqIBlqQaHX5/YGakEPdyIRc3NqakGh1+f2BmpBA3ciDyAOIA8gEXNzIBNqIApqQaHX5/YGakEJdyIKcyARc2pqQaHX5/YGakELdyIIIBAgDyAKIAggDCAPIAggCnNzIBFqakGh1+f2BmpBD3ciDHNzampBodfn9gZqQQN3Ig4gEiAIIAwgDnNzIApqakGh1+f2BmpBCXciCHMgDHNqakGh1+f2BmpBC3chByAFIAYgCCAHIBggDiAHIAhzcyAMampBodfn9gZqQQ93IgpzcyAOampBodfn9gZqQQN3IgZqIQUgDSAGIAkgByAGIAsgByAGIApzcyAIampBodfn9gZqQQl3IgdzIApzampBodfn9gZqQQt3IgYgB3NzIApqakGh1+f2BmpBD3cgAmohAiADIAZqIQMgBCAHaiEEIAFBQGshAQwBCwsgBSQBIAIkAiADJAMgBCQECw0AIAAQASAAIwBqJAAL/wQCA38BfiAAIwBqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=", "base64"));
module.exports = create.bind(null, md4, [], 64, 32);
},
71175: module => {
"use strict";
const MAX_SHORT_STRING = -4 & Math.floor(16368);
class WasmHash {
constructor(instance, instancesPool, chunkSize, digestSize) {
const exports = instance.exports;
exports.init(), this.exports = exports, this.mem = Buffer.from(exports.memory.buffer, 0, 65536), 
this.buffered = 0, this.instancesPool = instancesPool, this.chunkSize = chunkSize, 
this.digestSize = digestSize;
}
reset() {
this.buffered = 0, this.exports.init();
}
update(data, encoding) {
if ("string" == typeof data) {
for (;data.length > MAX_SHORT_STRING; ) this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding), 
data = data.slice(MAX_SHORT_STRING);
return this._updateWithShortString(data, encoding), this;
}
return this._updateWithBuffer(data), this;
}
_updateWithShortString(data, encoding) {
const {exports, buffered, mem, chunkSize} = this;
let endPos;
if (data.length < 70) if (encoding && "utf-8" !== encoding && "utf8" !== encoding) if ("latin1" === encoding) {
endPos = buffered;
for (let i = 0; i < data.length; i++) {
const cc = data.charCodeAt(i);
mem[endPos++] = cc;
}
} else endPos = buffered + mem.write(data, buffered, encoding); else {
endPos = buffered;
for (let i = 0; i < data.length; i++) {
const cc = data.charCodeAt(i);
if (cc < 128) mem[endPos++] = cc; else {
if (!(cc < 2048)) {
endPos += mem.write(data.slice(i), endPos, encoding);
break;
}
mem[endPos] = cc >> 6 | 192, mem[endPos + 1] = 63 & cc | 128, endPos += 2;
}
}
} else endPos = buffered + mem.write(data, buffered, encoding);
if (endPos < chunkSize) this.buffered = endPos; else {
const l = endPos & ~(this.chunkSize - 1);
exports.update(l);
const newBuffered = endPos - l;
this.buffered = newBuffered, newBuffered > 0 && mem.copyWithin(0, l, endPos);
}
}
_updateWithBuffer(data) {
const {exports, buffered, mem} = this, length = data.length;
if (buffered + length < this.chunkSize) data.copy(mem, buffered, 0, length), this.buffered += length; else {
const l = buffered + length & ~(this.chunkSize - 1);
if (l > 65536) {
let i = 65536 - buffered;
data.copy(mem, buffered, 0, i), exports.update(65536);
const stop = l - buffered - 65536;
for (;i < stop; ) data.copy(mem, 0, i, i + 65536), exports.update(65536), i += 65536;
data.copy(mem, 0, i, l - buffered), exports.update(l - buffered - i);
} else data.copy(mem, buffered, 0, l - buffered), exports.update(l);
const newBuffered = length + buffered - l;
this.buffered = newBuffered, newBuffered > 0 && data.copy(mem, 0, length - newBuffered, length);
}
}
digest(type) {
const {exports, buffered, mem, digestSize} = this;
exports.final(buffered), this.instancesPool.push(this);
const hex = mem.toString("latin1", 0, digestSize);
return "hex" === type ? hex : "binary" !== type && type ? Buffer.from(hex, "hex").toString(type) : Buffer.from(hex, "hex");
}
}
module.exports = (wasmModule, instancesPool, chunkSize, digestSize) => {
if (instancesPool.length > 0) {
const old = instancesPool.pop();
return old.reset(), old;
}
return new WasmHash(new WebAssembly.Instance(wasmModule), instancesPool, chunkSize, digestSize);
}, module.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;
},
54816: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const create = __webpack_require__(71175), xxhash64 = new WebAssembly.Module(Buffer.from("AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrIIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqAYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEAgAiABNQIAQoeVr6+Ytt6bnn9+hUIXiULP1tO+0ser2UJ+Qvnz3fGZ9pmrFnwhAiABQQRqIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAkIdiCAChUL5893xmfaZqxZ+IgJCIIggAoUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL", "base64"));
module.exports = create.bind(null, xxhash64, [], 32, 16);
},
63264: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const path = __webpack_require__(71017), WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\/]/, SEGMENTS_SPLIT_REGEXP = /([|!])/, WINDOWS_PATH_SEPARATOR_REGEXP = /\\/g, relativePathToRequest = relativePath => "" === relativePath ? "./." : ".." === relativePath ? "../." : relativePath.startsWith("../") ? relativePath : `./${relativePath}`, absoluteToRequest = (context, maybeAbsolutePath) => {
if ("/" === maybeAbsolutePath[0]) {
if (maybeAbsolutePath.length > 1 && "/" === maybeAbsolutePath[maybeAbsolutePath.length - 1]) return maybeAbsolutePath;
const querySplitPos = maybeAbsolutePath.indexOf("?");
let resource = -1 === querySplitPos ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);
return resource = relativePathToRequest(path.posix.relative(context, resource)), 
-1 === querySplitPos ? resource : resource + maybeAbsolutePath.slice(querySplitPos);
}
if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {
const querySplitPos = maybeAbsolutePath.indexOf("?");
let resource = -1 === querySplitPos ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);
return resource = path.win32.relative(context, resource), WINDOWS_ABS_PATH_REGEXP.test(resource) || (resource = relativePathToRequest(resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, "/"))), 
-1 === querySplitPos ? resource : resource + maybeAbsolutePath.slice(querySplitPos);
}
return maybeAbsolutePath;
}, requestToAbsolute = (context, relativePath) => relativePath.startsWith("./") || relativePath.startsWith("../") ? path.join(context, relativePath) : relativePath, makeCacheable = realFn => {
const cache = new WeakMap, getCache = associatedObjectForCache => {
const entry = cache.get(associatedObjectForCache);
if (void 0 !== entry) return entry;
const map = new Map;
return cache.set(associatedObjectForCache, map), map;
}, fn = (str, associatedObjectForCache) => {
if (!associatedObjectForCache) return realFn(str);
const cache = getCache(associatedObjectForCache), entry = cache.get(str);
if (void 0 !== entry) return entry;
const result = realFn(str);
return cache.set(str, result), result;
};
return fn.bindCache = associatedObjectForCache => {
const cache = getCache(associatedObjectForCache);
return str => {
const entry = cache.get(str);
if (void 0 !== entry) return entry;
const result = realFn(str);
return cache.set(str, result), result;
};
}, fn;
}, makeCacheableWithContext = fn => {
const cache = new WeakMap, cachedFn = (context, identifier, associatedObjectForCache) => {
if (!associatedObjectForCache) return fn(context, identifier);
let cachedResult, innerCache = cache.get(associatedObjectForCache);
void 0 === innerCache && (innerCache = new Map, cache.set(associatedObjectForCache, innerCache));
let innerSubCache = innerCache.get(context);
if (void 0 === innerSubCache ? innerCache.set(context, innerSubCache = new Map) : cachedResult = innerSubCache.get(identifier), 
void 0 !== cachedResult) return cachedResult;
{
const result = fn(context, identifier);
return innerSubCache.set(identifier, result), result;
}
};
return cachedFn.bindCache = associatedObjectForCache => {
let innerCache;
associatedObjectForCache ? (innerCache = cache.get(associatedObjectForCache), void 0 === innerCache && (innerCache = new Map, 
cache.set(associatedObjectForCache, innerCache))) : innerCache = new Map;
return (context, identifier) => {
let cachedResult, innerSubCache = innerCache.get(context);
if (void 0 === innerSubCache ? innerCache.set(context, innerSubCache = new Map) : cachedResult = innerSubCache.get(identifier), 
void 0 !== cachedResult) return cachedResult;
{
const result = fn(context, identifier);
return innerSubCache.set(identifier, result), result;
}
};
}, cachedFn.bindContextCache = (context, associatedObjectForCache) => {
let innerSubCache;
if (associatedObjectForCache) {
let innerCache = cache.get(associatedObjectForCache);
void 0 === innerCache && (innerCache = new Map, cache.set(associatedObjectForCache, innerCache)), 
innerSubCache = innerCache.get(context), void 0 === innerSubCache && innerCache.set(context, innerSubCache = new Map);
} else innerSubCache = new Map;
return identifier => {
const cachedResult = innerSubCache.get(identifier);
if (void 0 !== cachedResult) return cachedResult;
{
const result = fn(context, identifier);
return innerSubCache.set(identifier, result), result;
}
};
}, cachedFn;
};
exports.makePathsRelative = makeCacheableWithContext(((context, identifier) => identifier.split(SEGMENTS_SPLIT_REGEXP).map((str => absoluteToRequest(context, str))).join("")));
exports.makePathsAbsolute = makeCacheableWithContext(((context, identifier) => identifier.split(SEGMENTS_SPLIT_REGEXP).map((str => requestToAbsolute(context, str))).join("")));
const contextify = makeCacheableWithContext(((context, request) => request.split("!").map((r => absoluteToRequest(context, r))).join("!")));
exports.contextify = contextify;
const absolutify = makeCacheableWithContext(((context, request) => request.split("!").map((r => requestToAbsolute(context, r))).join("!")));
exports.absolutify = absolutify;
const PATH_QUERY_FRAGMENT_REGEXP = /^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/, PATH_QUERY_REGEXP = /^((?:\0.|[^?\0])*)(\?.*)?$/;
exports.parseResource = makeCacheable((str => {
const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);
return {
resource: str,
path: match[1].replace(/\0(.)/g, "$1"),
query: match[2] ? match[2].replace(/\0(.)/g, "$1") : "",
fragment: match[3] || ""
};
}));
exports.parseResourceWithoutFragment = makeCacheable((str => {
const match = PATH_QUERY_REGEXP.exec(str);
return {
resource: str,
path: match[1].replace(/\0(.)/g, "$1"),
query: match[2] ? match[2].replace(/\0(.)/g, "$1") : ""
};
})), exports.getUndoPath = (filename, outputPath, enforceRelative) => {
let depth = -1, append = "";
outputPath = outputPath.replace(/[\\/]$/, "");
for (const part of filename.split(/[/\\]+/)) if (".." === part) if (depth > -1) depth--; else {
const i = outputPath.lastIndexOf("/"), j = outputPath.lastIndexOf("\\"), pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);
if (pos < 0) return outputPath + "/";
append = outputPath.slice(pos + 1) + "/" + append, outputPath = outputPath.slice(0, pos);
} else "." !== part && depth++;
return depth > 0 ? `${"../".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;
};
},
56423: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
module.exports = {
AsyncDependenciesBlock: () => __webpack_require__(89353),
CommentCompilationWarning: () => __webpack_require__(35931),
ContextModule: () => __webpack_require__(11627),
"cache/PackFileCacheStrategy": () => __webpack_require__(49634),
"cache/ResolverCachePlugin": () => __webpack_require__(65324),
"container/ContainerEntryDependency": () => __webpack_require__(49545),
"container/ContainerEntryModule": () => __webpack_require__(63687),
"container/ContainerExposedDependency": () => __webpack_require__(23693),
"container/FallbackDependency": () => __webpack_require__(34196),
"container/FallbackItemDependency": () => __webpack_require__(60996),
"container/FallbackModule": () => __webpack_require__(35600),
"container/RemoteModule": () => __webpack_require__(653),
"container/RemoteToExternalDependency": () => __webpack_require__(18969),
"dependencies/AMDDefineDependency": () => __webpack_require__(80147),
"dependencies/AMDRequireArrayDependency": () => __webpack_require__(98773),
"dependencies/AMDRequireContextDependency": () => __webpack_require__(35974),
"dependencies/AMDRequireDependenciesBlock": () => __webpack_require__(64887),
"dependencies/AMDRequireDependency": () => __webpack_require__(70479),
"dependencies/AMDRequireItemDependency": () => __webpack_require__(39744),
"dependencies/CachedConstDependency": () => __webpack_require__(26919),
"dependencies/CreateScriptUrlDependency": () => __webpack_require__(66869),
"dependencies/CommonJsRequireContextDependency": () => __webpack_require__(92890),
"dependencies/CommonJsExportRequireDependency": () => __webpack_require__(98893),
"dependencies/CommonJsExportsDependency": () => __webpack_require__(78247),
"dependencies/CommonJsFullRequireDependency": () => __webpack_require__(76523),
"dependencies/CommonJsRequireDependency": () => __webpack_require__(26777),
"dependencies/CommonJsSelfReferenceDependency": () => __webpack_require__(3256),
"dependencies/ConstDependency": () => __webpack_require__(30339),
"dependencies/ContextDependency": () => __webpack_require__(97818),
"dependencies/ContextElementDependency": () => __webpack_require__(84407),
"dependencies/CriticalDependencyWarning": () => __webpack_require__(14663),
"dependencies/CssImportDependency": () => __webpack_require__(55754),
"dependencies/CssLocalIdentifierDependency": () => __webpack_require__(1995),
"dependencies/CssSelfLocalIdentifierDependency": () => __webpack_require__(87027),
"dependencies/CssExportDependency": () => __webpack_require__(32037),
"dependencies/CssUrlDependency": () => __webpack_require__(22058),
"dependencies/DelegatedSourceDependency": () => __webpack_require__(10307),
"dependencies/DllEntryDependency": () => __webpack_require__(59968),
"dependencies/EntryDependency": () => __webpack_require__(74989),
"dependencies/ExportsInfoDependency": () => __webpack_require__(14525),
"dependencies/HarmonyAcceptDependency": () => __webpack_require__(29549),
"dependencies/HarmonyAcceptImportDependency": () => __webpack_require__(77337),
"dependencies/HarmonyCompatibilityDependency": () => __webpack_require__(35285),
"dependencies/HarmonyExportExpressionDependency": () => __webpack_require__(30146),
"dependencies/HarmonyExportHeaderDependency": () => __webpack_require__(40366),
"dependencies/HarmonyExportImportedSpecifierDependency": () => __webpack_require__(59411),
"dependencies/HarmonyExportSpecifierDependency": () => __webpack_require__(61750),
"dependencies/HarmonyImportSideEffectDependency": () => __webpack_require__(39052),
"dependencies/HarmonyImportSpecifierDependency": () => __webpack_require__(68081),
"dependencies/HarmonyEvaluatedImportSpecifierDependency": () => __webpack_require__(43613),
"dependencies/ImportContextDependency": () => __webpack_require__(99554),
"dependencies/ImportDependency": () => __webpack_require__(75035),
"dependencies/ImportEagerDependency": () => __webpack_require__(76636),
"dependencies/ImportWeakDependency": () => __webpack_require__(1),
"dependencies/JsonExportsDependency": () => __webpack_require__(94084),
"dependencies/LocalModule": () => __webpack_require__(37937),
"dependencies/LocalModuleDependency": () => __webpack_require__(7306),
"dependencies/ModuleDecoratorDependency": () => __webpack_require__(90331),
"dependencies/ModuleHotAcceptDependency": () => __webpack_require__(50994),
"dependencies/ModuleHotDeclineDependency": () => __webpack_require__(60219),
"dependencies/ImportMetaHotAcceptDependency": () => __webpack_require__(35606),
"dependencies/ImportMetaHotDeclineDependency": () => __webpack_require__(15234),
"dependencies/ImportMetaContextDependency": () => __webpack_require__(68385),
"dependencies/ProvidedDependency": () => __webpack_require__(37386),
"dependencies/PureExpressionDependency": () => __webpack_require__(3988),
"dependencies/RequireContextDependency": () => __webpack_require__(71051),
"dependencies/RequireEnsureDependenciesBlock": () => __webpack_require__(47603),
"dependencies/RequireEnsureDependency": () => __webpack_require__(43286),
"dependencies/RequireEnsureItemDependency": () => __webpack_require__(69567),
"dependencies/RequireHeaderDependency": () => __webpack_require__(24547),
"dependencies/RequireIncludeDependency": () => __webpack_require__(79788),
"dependencies/RequireIncludeDependencyParserPlugin": () => __webpack_require__(14713),
"dependencies/RequireResolveContextDependency": () => __webpack_require__(31572),
"dependencies/RequireResolveDependency": () => __webpack_require__(92551),
"dependencies/RequireResolveHeaderDependency": () => __webpack_require__(4637),
"dependencies/RuntimeRequirementsDependency": () => __webpack_require__(40680),
"dependencies/StaticExportsDependency": () => __webpack_require__(21776),
"dependencies/SystemPlugin": () => __webpack_require__(99334),
"dependencies/UnsupportedDependency": () => __webpack_require__(7615),
"dependencies/URLDependency": () => __webpack_require__(25105),
"dependencies/WebAssemblyExportImportedDependency": () => __webpack_require__(66847),
"dependencies/WebAssemblyImportDependency": () => __webpack_require__(68953),
"dependencies/WebpackIsIncludedDependency": () => __webpack_require__(19981),
"dependencies/WorkerDependency": () => __webpack_require__(41399),
"json/JsonData": () => __webpack_require__(62676),
"optimize/ConcatenatedModule": () => __webpack_require__(36005),
DelegatedModule: () => __webpack_require__(98943),
DependenciesBlock: () => __webpack_require__(17461),
DllModule: () => __webpack_require__(46469),
ExternalModule: () => __webpack_require__(97056),
FileSystemInfo: () => __webpack_require__(91664),
InitFragment: () => __webpack_require__(95328),
InvalidDependenciesModuleWarning: () => __webpack_require__(37748),
Module: () => __webpack_require__(36797),
ModuleBuildError: () => __webpack_require__(2386),
ModuleDependencyWarning: () => __webpack_require__(50020),
ModuleError: () => __webpack_require__(96063),
ModuleGraph: () => __webpack_require__(2197),
ModuleParseError: () => __webpack_require__(35452),
ModuleWarning: () => __webpack_require__(99622),
NormalModule: () => __webpack_require__(3213),
RawDataUrlModule: () => __webpack_require__(89779),
RawModule: () => __webpack_require__(85315),
"sharing/ConsumeSharedModule": () => __webpack_require__(60029),
"sharing/ConsumeSharedFallbackDependency": () => __webpack_require__(89143),
"sharing/ProvideSharedModule": () => __webpack_require__(96652),
"sharing/ProvideSharedDependency": () => __webpack_require__(70631),
"sharing/ProvideForSharedDependency": () => __webpack_require__(13720),
UnsupportedFeatureWarning: () => __webpack_require__(3490),
"util/LazySet": () => __webpack_require__(92585),
UnhandledSchemeError: () => __webpack_require__(48590),
NodeStuffInWebError: () => __webpack_require__(78160),
WebpackError: () => __webpack_require__(64326),
"util/registerExternalSerializer": () => {}
};
},
45898: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {register} = __webpack_require__(86601);
class ClassSerializer {
constructor(Constructor) {
this.Constructor = Constructor;
}
serialize(obj, context) {
obj.serialize(context);
}
deserialize(context) {
if ("function" == typeof this.Constructor.deserialize) return this.Constructor.deserialize(context);
const obj = new this.Constructor;
return obj.deserialize(context), obj;
}
}
module.exports = (Constructor, request, name = null) => {
register(Constructor, request, name, new ClassSerializer(Constructor));
};
},
98216: module => {
"use strict";
module.exports = fn => {
let result, cache = !1;
return () => (cache || (result = fn(), cache = !0, fn = void 0), result);
};
},
23388: module => {
"use strict";
const A_CODE = "a".charCodeAt(0);
module.exports = (hash, hashLength) => {
if (hashLength < 1) return "";
const slice = hash.slice(0, hashLength);
return slice.match(/[^\d]/) ? slice : `${String.fromCharCode(A_CODE + parseInt(hash[0], 10) % 6)}${slice.slice(1)}`;
};
},
42731: module => {
"use strict";
const arr = [ 0, 0, 0, 0, 0 ], primes = [ 3, 7, 17, 19 ];
module.exports = (str, range) => {
arr.fill(0);
for (let i = 0; i < str.length; i++) {
const c = str.charCodeAt(i);
for (let j = 0; j < 4; j++) {
const p = (j + 4 - 1) % 4;
arr[j] = arr[j] + c * primes[j] + arr[p] & 2147483647;
}
for (let j = 0; j < 4; j++) {
const q = arr[j] % 4;
arr[j] = arr[j] ^ arr[q] >> 1;
}
}
if (range <= 2147483647) {
let sum = 0;
for (let j = 0; j < 4; j++) sum = (sum + arr[j]) % range;
return sum;
}
{
let sum1 = 0, sum2 = 0;
const rangeExt = Math.floor(range / 2147483648);
for (let j = 0; j < 4; j += 2) sum1 = sum1 + arr[j] & 2147483647;
for (let j = 1; j < 4; j += 2) sum2 = (sum2 + arr[j]) % rangeExt;
return (2147483648 * sum2 + sum1) % range;
}
};
},
21869: module => {
"use strict";
module.exports = (items, concurrency, processor, callback) => {
const queue = Array.from(items);
if (0 === queue.length) return callback();
let processing = 0, finished = !1, processScheduled = !0;
const push = item => {
queue.push(item), !processScheduled && processing < concurrency && (processScheduled = !0, 
process.nextTick(processQueue));
}, processorCallback = err => {
if (processing--, err && !finished) return finished = !0, void callback(err);
processScheduled || (processScheduled = !0, process.nextTick(processQueue));
}, processQueue = () => {
if (!finished) {
for (;processing < concurrency && queue.length > 0; ) {
processing++;
const item = queue.pop();
processor(item, push, processorCallback);
}
processScheduled = !1, 0 !== queue.length || 0 !== processing || finished || (finished = !0, 
callback());
}
};
processQueue();
};
},
10664: module => {
"use strict";
const SAFE_IDENTIFIER = /^[_a-zA-Z$][_a-zA-Z$0-9]*$/, RESERVED_IDENTIFIER = new Set([ "break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "return", "super", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "enum", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "yield", "await", "null", "true", "false" ]);
module.exports = (properties, start = 0) => {
let str = "";
for (let i = start; i < properties.length; i++) {
const p = properties[i];
"" + +p === p ? str += `[${p}]` : SAFE_IDENTIFIER.test(p) && !RESERVED_IDENTIFIER.has(p) ? str += `.${p}` : str += `[${JSON.stringify(p)}]`;
}
return str;
};
},
18371: (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {register} = __webpack_require__(86601), Position = __webpack_require__(1234).Position, SourceLocation = __webpack_require__(1234).SourceLocation, ValidationError = __webpack_require__(40537).Z, {CachedSource, ConcatSource, OriginalSource, PrefixSource, RawSource, ReplaceSource, SourceMapSource} = __webpack_require__(37946), CURRENT_MODULE = "webpack/lib/util/registerExternalSerializer";
register(CachedSource, CURRENT_MODULE, "webpack-sources/CachedSource", new class {
serialize(source, {write, writeLazy}) {
writeLazy ? writeLazy(source.originalLazy()) : write(source.original()), write(source.getCachedData());
}
deserialize({read}) {
const source = read(), cachedData = read();
return new CachedSource(source, cachedData);
}
}), register(RawSource, CURRENT_MODULE, "webpack-sources/RawSource", new class {
serialize(source, {write}) {
write(source.buffer()), write(!source.isBuffer());
}
deserialize({read}) {
const source = read(), convertToString = read();
return new RawSource(source, convertToString);
}
}), register(ConcatSource, CURRENT_MODULE, "webpack-sources/ConcatSource", new class {
serialize(source, {write}) {
write(source.getChildren());
}
deserialize({read}) {
const source = new ConcatSource;
return source.addAllSkipOptimizing(read()), source;
}
}), register(PrefixSource, CURRENT_MODULE, "webpack-sources/PrefixSource", new class {
serialize(source, {write}) {
write(source.getPrefix()), write(source.original());
}
deserialize({read}) {
return new PrefixSource(read(), read());
}
}), register(ReplaceSource, CURRENT_MODULE, "webpack-sources/ReplaceSource", new class {
serialize(source, {write}) {
write(source.original()), write(source.getName());
const replacements = source.getReplacements();
write(replacements.length);
for (const repl of replacements) write(repl.start), write(repl.end);
for (const repl of replacements) write(repl.content), write(repl.name);
}
deserialize({read}) {
const source = new ReplaceSource(read(), read()), len = read(), startEndBuffer = [];
for (let i = 0; i < len; i++) startEndBuffer.push(read(), read());
let j = 0;
for (let i = 0; i < len; i++) source.replace(startEndBuffer[j++], startEndBuffer[j++], read(), read());
return source;
}
}), register(OriginalSource, CURRENT_MODULE, "webpack-sources/OriginalSource", new class {
serialize(source, {write}) {
write(source.buffer()), write(source.getName());
}
deserialize({read}) {
const buffer = read(), name = read();
return new OriginalSource(buffer, name);
}
}), register(SourceLocation, CURRENT_MODULE, "acorn/SourceLocation", new class {
serialize(loc, {write}) {
write(loc.start.line), write(loc.start.column), write(loc.end.line), write(loc.end.column);
}
deserialize({read}) {
return {
start: {
line: read(),
column: read()
},
end: {
line: read(),
column: read()
}
};
}
}), register(Position, CURRENT_MODULE, "acorn/Position", new class {
serialize(pos, {write}) {
write(pos.line), write(pos.column);
}
deserialize({read}) {
return {
line: read(),
column: read()
};
}
}), register(SourceMapSource, CURRENT_MODULE, "webpack-sources/SourceMapSource", new class {
serialize(source, {write}) {
write(source.getArgsAsBuffers());
}
deserialize({read}) {
return new SourceMapSource(...read());
}
}), register(ValidationError, CURRENT_MODULE, "schema-utils/ValidationError", new class {
serialize(error, {write}) {
write(error.errors), write(error.schema), write({
name: error.headerName,
baseDataPath: error.baseDataPath,
postFormatter: error.postFormatter
});
}
deserialize({read}) {
return new ValidationError(read(), read(), read());
}
});
},
14372: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const SortableSet = __webpack_require__(72451);
exports.getEntryRuntime = (compilation, name, options) => {
let dependOn, runtime;
if (options) ({dependOn, runtime} = options); else {
const entry = compilation.entries.get(name);
if (!entry) return name;
({dependOn, runtime} = entry.options);
}
if (dependOn) {
let result;
const queue = new Set(dependOn);
for (const name of queue) {
const dep = compilation.entries.get(name);
if (!dep) continue;
const {dependOn, runtime} = dep.options;
if (dependOn) for (const name of dependOn) queue.add(name); else result = mergeRuntimeOwned(result, runtime || name);
}
return result || name;
}
return runtime || name;
}, exports.forEachRuntime = (runtime, fn, deterministicOrder = !1) => {
if (void 0 === runtime) fn(void 0); else if ("string" == typeof runtime) fn(runtime); else {
deterministicOrder && runtime.sort();
for (const r of runtime) fn(r);
}
};
const getRuntimesKey = set => (set.sort(), Array.from(set).join("\n")), getRuntimeKey = runtime => void 0 === runtime ? "*" : "string" == typeof runtime ? runtime : runtime.getFromUnorderedCache(getRuntimesKey);
exports.getRuntimeKey = getRuntimeKey;
const keyToRuntime = key => {
if ("*" === key) return;
const items = key.split("\n");
return 1 === items.length ? items[0] : new SortableSet(items);
};
exports.keyToRuntime = keyToRuntime;
const getRuntimesString = set => (set.sort(), Array.from(set).join("+")), runtimeToString = runtime => void 0 === runtime ? "*" : "string" == typeof runtime ? runtime : runtime.getFromUnorderedCache(getRuntimesString);
exports.runtimeToString = runtimeToString, exports.runtimeConditionToString = runtimeCondition => !0 === runtimeCondition ? "true" : !1 === runtimeCondition ? "false" : runtimeToString(runtimeCondition);
const runtimeEqual = (a, b) => {
if (a === b) return !0;
if (void 0 === a || void 0 === b || "string" == typeof a || "string" == typeof b) return !1;
if (a.size !== b.size) return !1;
{
a.sort(), b.sort();
const aIt = a[Symbol.iterator](), bIt = b[Symbol.iterator]();
for (;;) {
const aV = aIt.next();
if (aV.done) return !0;
const bV = bIt.next();
if (aV.value !== bV.value) return !1;
}
}
};
exports.runtimeEqual = runtimeEqual, exports.compareRuntime = (a, b) => {
if (a === b) return 0;
if (void 0 === a) return -1;
if (void 0 === b) return 1;
{
const aKey = getRuntimeKey(a), bKey = getRuntimeKey(b);
return aKey < bKey ? -1 : aKey > bKey ? 1 : 0;
}
};
const mergeRuntime = (a, b) => {
if (void 0 === a) return b;
if (void 0 === b) return a;
if (a === b) return a;
if ("string" == typeof a) {
if ("string" == typeof b) {
const set = new SortableSet;
return set.add(a), set.add(b), set;
}
if (b.has(a)) return b;
{
const set = new SortableSet(b);
return set.add(a), set;
}
}
if ("string" == typeof b) {
if (a.has(b)) return a;
const set = new SortableSet(a);
return set.add(b), set;
}
{
const set = new SortableSet(a);
for (const item of b) set.add(item);
return set.size === a.size ? a : set;
}
};
exports.mergeRuntime = mergeRuntime, exports.mergeRuntimeCondition = (a, b, runtime) => {
if (!1 === a) return b;
if (!1 === b) return a;
if (!0 === a || !0 === b) return !0;
const merged = mergeRuntime(a, b);
return void 0 !== merged ? "string" == typeof merged ? "string" == typeof runtime && merged === runtime || merged : "string" == typeof runtime || void 0 === runtime ? merged : merged.size === runtime.size || merged : void 0;
}, exports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {
if (!0 === a || !0 === b) return !0;
const merged = mergeRuntime(a, b);
return void 0 !== merged ? "string" == typeof merged ? "string" == typeof runtime && merged === runtime || merged : "string" == typeof runtime || void 0 === runtime ? merged : merged.size === runtime.size || merged : void 0;
};
const mergeRuntimeOwned = (a, b) => {
if (void 0 === b) return a;
if (a === b) return a;
if (void 0 === a) return "string" == typeof b ? b : new SortableSet(b);
if ("string" == typeof a) {
if ("string" == typeof b) {
const set = new SortableSet;
return set.add(a), set.add(b), set;
}
{
const set = new SortableSet(b);
return set.add(a), set;
}
}
if ("string" == typeof b) return a.add(b), a;
for (const item of b) a.add(item);
return a;
};
exports.mergeRuntimeOwned = mergeRuntimeOwned, exports.intersectRuntime = (a, b) => {
if (void 0 === a) return b;
if (void 0 === b) return a;
if (a === b) return a;
if ("string" == typeof a) return "string" == typeof b ? void 0 : b.has(a) ? a : void 0;
if ("string" == typeof b) return a.has(b) ? b : void 0;
{
const set = new SortableSet;
for (const item of b) a.has(item) && set.add(item);
if (0 === set.size) return;
if (1 === set.size) for (const item of set) return item;
return set;
}
};
const subtractRuntime = (a, b) => {
if (void 0 !== a) {
if (void 0 === b) return a;
if (a !== b) {
if ("string" == typeof a) return "string" == typeof b ? a : b.has(a) ? void 0 : a;
if ("string" != typeof b) {
const set = new SortableSet;
for (const item of a) b.has(item) || set.add(item);
if (0 === set.size) return;
if (1 === set.size) for (const item of set) return item;
return set;
}
if (!a.has(b)) return a;
if (2 === a.size) for (const item of a) if (item !== b) return item;
new SortableSet(a).delete(b);
}
}
};
exports.subtractRuntime = subtractRuntime, exports.subtractRuntimeCondition = (a, b, runtime) => {
if (!0 === b) return !1;
if (!1 === b) return a;
if (!1 === a) return !1;
const result = subtractRuntime(!0 === a ? runtime : a, b);
return void 0 !== result && result;
}, exports.filterRuntime = (runtime, filter) => {
if (void 0 === runtime) return filter(void 0);
if ("string" == typeof runtime) return filter(runtime);
let result, some = !1, every = !0;
for (const r of runtime) {
filter(r) ? (some = !0, result = mergeRuntimeOwned(result, r)) : every = !1;
}
return !!some && (!!every || result);
};
exports.RuntimeSpecMap = class {
constructor(clone) {
this._mode = clone ? clone._mode : 0, this._singleRuntime = clone ? clone._singleRuntime : void 0, 
this._singleValue = clone ? clone._singleValue : void 0, this._map = clone && clone._map ? new Map(clone._map) : void 0;
}
get(runtime) {
switch (this._mode) {
case 0:
return;

case 1:
return runtimeEqual(this._singleRuntime, runtime) ? this._singleValue : void 0;

default:
return this._map.get(getRuntimeKey(runtime));
}
}
has(runtime) {
switch (this._mode) {
case 0:
return !1;

case 1:
return runtimeEqual(this._singleRuntime, runtime);

default:
return this._map.has(getRuntimeKey(runtime));
}
}
set(runtime, value) {
switch (this._mode) {
case 0:
this._mode = 1, this._singleRuntime = runtime, this._singleValue = value;
break;

case 1:
if (runtimeEqual(this._singleRuntime, runtime)) {
this._singleValue = value;
break;
}
this._mode = 2, this._map = new Map, this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue), 
this._singleRuntime = void 0, this._singleValue = void 0;

default:
this._map.set(getRuntimeKey(runtime), value);
}
}
provide(runtime, computer) {
switch (this._mode) {
case 0:
return this._mode = 1, this._singleRuntime = runtime, this._singleValue = computer();

case 1:
{
if (runtimeEqual(this._singleRuntime, runtime)) return this._singleValue;
this._mode = 2, this._map = new Map, this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue), 
this._singleRuntime = void 0, this._singleValue = void 0;
const newValue = computer();
return this._map.set(getRuntimeKey(runtime), newValue), newValue;
}

default:
{
const key = getRuntimeKey(runtime), value = this._map.get(key);
if (void 0 !== value) return value;
const newValue = computer();
return this._map.set(key, newValue), newValue;
}
}
}
delete(runtime) {
switch (this._mode) {
case 0:
return;

case 1:
return void (runtimeEqual(this._singleRuntime, runtime) && (this._mode = 0, this._singleRuntime = void 0, 
this._singleValue = void 0));

default:
this._map.delete(getRuntimeKey(runtime));
}
}
update(runtime, fn) {
switch (this._mode) {
case 0:
throw new Error("runtime passed to update must exist");

case 1:
{
if (runtimeEqual(this._singleRuntime, runtime)) {
this._singleValue = fn(this._singleValue);
break;
}
const newValue = fn(void 0);
void 0 !== newValue && (this._mode = 2, this._map = new Map, this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue), 
this._singleRuntime = void 0, this._singleValue = void 0, this._map.set(getRuntimeKey(runtime), newValue));
break;
}

default:
{
const key = getRuntimeKey(runtime), oldValue = this._map.get(key), newValue = fn(oldValue);
newValue !== oldValue && this._map.set(key, newValue);
}
}
}
keys() {
switch (this._mode) {
case 0:
return [];

case 1:
return [ this._singleRuntime ];

default:
return Array.from(this._map.keys(), keyToRuntime);
}
}
values() {
switch (this._mode) {
case 0:
return [][Symbol.iterator]();

case 1:
return [ this._singleValue ][Symbol.iterator]();

default:
return this._map.values();
}
}
get size() {
return this._mode <= 1 ? this._mode : this._map.size;
}
};
class RuntimeSpecSet {
constructor(iterable) {
if (this._map = new Map, iterable) for (const item of iterable) this.add(item);
}
add(runtime) {
this._map.set(getRuntimeKey(runtime), runtime);
}
has(runtime) {
return this._map.has(getRuntimeKey(runtime));
}
[Symbol.iterator]() {
return this._map.values();
}
get size() {
return this._map.size;
}
}
exports.RuntimeSpecSet = RuntimeSpecSet;
},
46617: function(__unused_webpack_module, exports) {
"use strict";
const parseVersion = str => {
var splitAndConvert = function(str) {
return str.split(".").map((function(item) {
return +item == item ? +item : item;
}));
}, match = /^([^-+]+)?(?:-([^+]+))?(?:\+(.+))?$/.exec(str), ver = match[1] ? splitAndConvert(match[1]) : [];
return match[2] && (ver.length++, ver.push.apply(ver, splitAndConvert(match[2]))), 
match[3] && (ver.push([]), ver.push.apply(ver, splitAndConvert(match[3]))), ver;
};
exports.parseVersion = parseVersion;
exports.versionLt = (a, b) => {
a = parseVersion(a), b = parseVersion(b);
for (var i = 0; ;) {
if (i >= a.length) return i < b.length && "u" != (typeof b[i])[0];
var aValue = a[i], aType = (typeof aValue)[0];
if (i >= b.length) return "u" == aType;
var bValue = b[i], bType = (typeof bValue)[0];
if (aType != bType) return "o" == aType && "n" == bType || ("s" == bType || "u" == aType);
if ("o" != aType && "u" != aType && aValue != bValue) return aValue < bValue;
i++;
}
}, exports.parseRange = str => {
const splitAndConvert = str => str.split(".").map((item => "NaN" !== item && "" + +item === item ? +item : item)), parsePartial = str => {
const match = /^([^-+]+)?(?:-([^+]+))?(?:\+(.+))?$/.exec(str), ver = match[1] ? [ 0, ...splitAndConvert(match[1]) ] : [ 0 ];
match[2] && (ver.length++, ver.push.apply(ver, splitAndConvert(match[2])));
let last = ver[ver.length - 1];
for (;ver.length && (void 0 === last || /^[*xX]$/.test(last)); ) ver.pop(), last = ver[ver.length - 1];
return ver;
}, toFixed = range => 1 === range.length ? [ 0 ] : 2 === range.length ? [ 1, ...range.slice(1) ] : 3 === range.length ? [ 2, ...range.slice(1) ] : [ range.length, ...range.slice(1) ], negate = range => [ -range[0] - 1, ...range.slice(1) ], parseSimple = str => {
const match = /^(\^|~|<=|<|>=|>|=|v|!)/.exec(str), start = match ? match[0] : "", remainder = parsePartial(start.length ? str.slice(start.length).trim() : str.trim());
switch (start) {
case "^":
return remainder.length > 1 && 0 === remainder[1] ? remainder.length > 2 && 0 === remainder[2] ? [ 3, ...remainder.slice(1) ] : [ 2, ...remainder.slice(1) ] : [ 1, ...remainder.slice(1) ];

case "~":
return [ 2, ...remainder.slice(1) ];

case ">=":
return remainder;

case "=":
case "v":
case "":
return toFixed(remainder);

case "<":
return negate(remainder);

case ">":
return [ , toFixed(remainder), 0, remainder, 2 ];

case "<=":
return [ , toFixed(remainder), negate(remainder), 1 ];

case "!":
return [ , toFixed(remainder), 0 ];

default:
throw new Error("Unexpected start value");
}
}, combine = (items, fn) => {
if (1 === items.length) return items[0];
const arr = [];
for (const item of items.slice().reverse()) 0 in item ? arr.push(item) : arr.push(...item.slice(1));
return [ , ...arr, ...items.slice(1).map((() => fn)) ];
}, parseRange = str => {
const items = str.split(/\s+-\s+/);
if (1 === items.length) {
const items = str.trim().split(/(?<=[-0-9A-Za-z])\s+/g).map(parseSimple);
return combine(items, 2);
}
const a = parsePartial(items[0]), b = parsePartial(items[1]);
return [ , toFixed(b), negate(b), 1, a, 2 ];
};
return (str => {
const items = str.split(/\s*\|\|\s*/).map(parseRange);
return combine(items, 1);
})(str);
};
const rangeToString = range => {
var fixCount = range[0], str = "";
if (1 === range.length) return "*";
if (fixCount + .5) {
str += 0 == fixCount ? ">=" : -1 == fixCount ? "<" : 1 == fixCount ? "^" : 2 == fixCount ? "~" : fixCount > 0 ? "=" : "!=";
for (var needDot = 1, i = 1; i < range.length; i++) {
needDot--, str += "u" == (typeof (item = range[i]))[0] ? "-" : (needDot > 0 ? "." : "") + (needDot = 2, 
item);
}
return str;
}
var stack = [];
for (i = 1; i < range.length; i++) {
var item = range[i];
stack.push(0 === item ? "not(" + pop() + ")" : 1 === item ? "(" + pop() + " || " + pop() + ")" : 2 === item ? stack.pop() + " " + stack.pop() : rangeToString(item));
}
return pop();
function pop() {
return stack.pop().replace(/^\((.+)\)$/, "$1");
}
};
exports.rangeToString = rangeToString;
const satisfy = (range, version) => {
if (0 in range) {
version = parseVersion(version);
var fixCount = range[0], negated = fixCount < 0;
negated && (fixCount = -fixCount - 1);
for (var i = 0, j = 1, isEqual = !0; ;j++, i++) {
var versionValue, versionType, rangeType = j < range.length ? (typeof range[j])[0] : "";
if (i >= version.length || "o" == (versionType = (typeof (versionValue = version[i]))[0])) return !isEqual || ("u" == rangeType ? j > fixCount && !negated : "" == rangeType != negated);
if ("u" == versionType) {
if (!isEqual || "u" != rangeType) return !1;
} else if (isEqual) if (rangeType == versionType) if (j <= fixCount) {
if (versionValue != range[j]) return !1;
} else {
if (negated ? versionValue > range[j] : versionValue < range[j]) return !1;
versionValue != range[j] && (isEqual = !1);
} else if ("s" != rangeType && "n" != rangeType) {
if (negated || j <= fixCount) return !1;
isEqual = !1, j--;
} else {
if (j <= fixCount || versionType < rangeType != negated) return !1;
isEqual = !1;
} else "s" != rangeType && "n" != rangeType && (isEqual = !1, j--);
}
}
var stack = [], p = stack.pop.bind(stack);
for (i = 1; i < range.length; i++) {
var item = range[i];
stack.push(1 == item ? p() | p() : 2 == item ? p() & p() : item ? satisfy(item, version) : !p());
}
return !!p();
};
exports.satisfy = satisfy, exports.stringifyHoley = json => {
switch (typeof json) {
case "undefined":
return "";

case "object":
if (Array.isArray(json)) {
let str = "[";
for (let i = 0; i < json.length; i++) 0 !== i && (str += ","), str += this.stringifyHoley(json[i]);
return str += "]", str;
}
return JSON.stringify(json);

default:
return JSON.stringify(json);
}
}, exports.parseVersionRuntimeCode = runtimeTemplate => `var parseVersion = ${runtimeTemplate.basicFunction("str", [ "// see webpack/lib/util/semver.js for original code", `var p=${runtimeTemplate.supportsArrowFunction() ? "p=>" : "function(p)"}{return p.split(".").map((${runtimeTemplate.supportsArrowFunction() ? "p=>" : "function(p)"}{return+p==p?+p:p}))},n=/^([^-+]+)?(?:-([^+]+))?(?:\\+(.+))?$/.exec(str),r=n[1]?p(n[1]):[];return n[2]&&(r.length++,r.push.apply(r,p(n[2]))),n[3]&&(r.push([]),r.push.apply(r,p(n[3]))),r;` ])}`, 
exports.versionLtRuntimeCode = runtimeTemplate => `var versionLt = ${runtimeTemplate.basicFunction("a, b", [ "// see webpack/lib/util/semver.js for original code", 'a=parseVersion(a),b=parseVersion(b);for(var r=0;;){if(r>=a.length)return r<b.length&&"u"!=(typeof b[r])[0];var e=a[r],n=(typeof e)[0];if(r>=b.length)return"u"==n;var t=b[r],f=(typeof t)[0];if(n!=f)return"o"==n&&"n"==f||("s"==f||"u"==n);if("o"!=n&&"u"!=n&&e!=t)return e<t;r++}' ])}`, 
exports.rangeToStringRuntimeCode = runtimeTemplate => `var rangeToString = ${runtimeTemplate.basicFunction("range", [ "// see webpack/lib/util/semver.js for original code", 'var r=range[0],n="";if(1===range.length)return"*";if(r+.5){n+=0==r?">=":-1==r?"<":1==r?"^":2==r?"~":r>0?"=":"!=";for(var e=1,a=1;a<range.length;a++){e--,n+="u"==(typeof(t=range[a]))[0]?"-":(e>0?".":"")+(e=2,t)}return n}var g=[];for(a=1;a<range.length;a++){var t=range[a];g.push(0===t?"not("+o()+")":1===t?"("+o()+" || "+o()+")":2===t?g.pop()+" "+g.pop():rangeToString(t))}return o();function o(){return g.pop().replace(/^\\((.+)\\)$/,"$1")}' ])}`, 
exports.satisfyRuntimeCode = runtimeTemplate => `var satisfy = ${runtimeTemplate.basicFunction("range, version", [ "// see webpack/lib/util/semver.js for original code", 'if(0 in range){version=parseVersion(version);var e=range[0],r=e<0;r&&(e=-e-1);for(var n=0,i=1,a=!0;;i++,n++){var f,s,g=i<range.length?(typeof range[i])[0]:"";if(n>=version.length||"o"==(s=(typeof(f=version[n]))[0]))return!a||("u"==g?i>e&&!r:""==g!=r);if("u"==s){if(!a||"u"!=g)return!1}else if(a)if(g==s)if(i<=e){if(f!=range[i])return!1}else{if(r?f>range[i]:f<range[i])return!1;f!=range[i]&&(a=!1)}else if("s"!=g&&"n"!=g){if(r||i<=e)return!1;a=!1,i--}else{if(i<=e||s<g!=r)return!1;a=!1}else"s"!=g&&"n"!=g&&(a=!1,i--)}}var t=[],o=t.pop.bind(t);for(n=1;n<range.length;n++){var u=range[n];t.push(1==u?o()|o():2==u?o()&o():u?satisfy(u,version):!o())}return!!o();' ])}`;
},
86601: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const memoize = __webpack_require__(98216), getBinaryMiddleware = memoize((() => __webpack_require__(88594))), getObjectMiddleware = memoize((() => __webpack_require__(80763))), getSingleItemMiddleware = memoize((() => __webpack_require__(7014))), getSerializer = memoize((() => __webpack_require__(50307))), getSerializerMiddleware = memoize((() => __webpack_require__(66852))), getBinaryMiddlewareInstance = memoize((() => new (getBinaryMiddleware()))), registerSerializers = memoize((() => {
__webpack_require__(18371);
const internalSerializables = __webpack_require__(56423);
getObjectMiddleware().registerLoader(/^webpack\/lib\//, (req => {
const loader = internalSerializables[req.slice("webpack/lib/".length)];
return loader ? loader() : console.warn(`${req} not found in internalSerializables`), 
!0;
}));
}));
let buffersSerializer;
module.exports = {
get register() {
return getObjectMiddleware().register;
},
get registerLoader() {
return getObjectMiddleware().registerLoader;
},
get registerNotSerializable() {
return getObjectMiddleware().registerNotSerializable;
},
get NOT_SERIALIZABLE() {
return getObjectMiddleware().NOT_SERIALIZABLE;
},
get MEASURE_START_OPERATION() {
return getBinaryMiddleware().MEASURE_START_OPERATION;
},
get MEASURE_END_OPERATION() {
return getBinaryMiddleware().MEASURE_END_OPERATION;
},
get buffersSerializer() {
if (void 0 !== buffersSerializer) return buffersSerializer;
registerSerializers();
const Serializer = getSerializer(), binaryMiddleware = getBinaryMiddlewareInstance(), SerializerMiddleware = getSerializerMiddleware(), SingleItemMiddleware = getSingleItemMiddleware();
return buffersSerializer = new Serializer([ new SingleItemMiddleware, new (getObjectMiddleware())((context => {
context.write && (context.writeLazy = value => {
context.write(SerializerMiddleware.createLazy(value, binaryMiddleware));
});
}), "md4"), binaryMiddleware ]);
},
createFileSerializer: (fs, hashFunction) => {
registerSerializers();
const Serializer = getSerializer(), fileMiddleware = new (__webpack_require__(38030))(fs, hashFunction), binaryMiddleware = getBinaryMiddlewareInstance(), SerializerMiddleware = getSerializerMiddleware();
return new Serializer([ new (getSingleItemMiddleware()), new (getObjectMiddleware())((context => {
context.write && (context.writeLazy = value => {
context.write(SerializerMiddleware.createLazy(value, binaryMiddleware));
}, context.writeSeparate = (value, options) => {
const lazy = SerializerMiddleware.createLazy(value, fileMiddleware, options);
return context.write(lazy), lazy;
});
}), hashFunction), binaryMiddleware, fileMiddleware ]);
}
};
},
29501: module => {
"use strict";
module.exports = (items, groupConfigs) => {
const itemsWithGroups = new Set, allGroups = new Map;
for (const item of items) {
const groups = new Set;
for (let i = 0; i < groupConfigs.length; i++) {
const groupConfig = groupConfigs[i], keys = groupConfig.getKeys(item);
if (keys) for (const name of keys) {
const key = `${i}:${name}`;
let group = allGroups.get(key);
void 0 === group && allGroups.set(key, group = {
config: groupConfig,
name,
alreadyGrouped: !1,
items: void 0
}), groups.add(group);
}
}
itemsWithGroups.add({
item,
groups
});
}
const runGrouping = itemsWithGroups => {
const totalSize = itemsWithGroups.size;
for (const entry of itemsWithGroups) for (const group of entry.groups) {
if (group.alreadyGrouped) continue;
const items = group.items;
void 0 === items ? group.items = new Set([ entry ]) : items.add(entry);
}
const groupMap = new Map;
for (const group of allGroups.values()) if (group.items) {
const items = group.items;
group.items = void 0, groupMap.set(group, {
items,
options: void 0,
used: !1
});
}
const results = [];
for (;;) {
let bestGroup, bestGroupItems, bestGroupOptions, bestGroupSize = -1;
for (const [group, state] of groupMap) {
const {items, used} = state;
let options = state.options;
if (void 0 === options) {
const groupConfig = group.config;
state.options = options = groupConfig.getOptions && groupConfig.getOptions(group.name, Array.from(items, (({item}) => item))) || !1;
}
const force = options && options.force;
if (!force) {
if (bestGroupOptions && bestGroupOptions.force) continue;
if (used) continue;
if (items.size <= 1 || totalSize - items.size <= 1) continue;
}
const targetGroupCount = options && options.targetGroupCount || 4;
let sizeValue = force ? items.size : Math.min(items.size, 2 * totalSize / targetGroupCount + itemsWithGroups.size - items.size);
(sizeValue > bestGroupSize || force && (!bestGroupOptions || !bestGroupOptions.force)) && (bestGroup = group, 
bestGroupSize = sizeValue, bestGroupItems = items, bestGroupOptions = options);
}
if (void 0 === bestGroup) break;
const items = new Set(bestGroupItems), options = bestGroupOptions, groupChildren = !options || !1 !== options.groupChildren;
for (const item of items) {
itemsWithGroups.delete(item);
for (const group of item.groups) {
const state = groupMap.get(group);
void 0 !== state && (state.items.delete(item), 0 === state.items.size ? groupMap.delete(group) : (state.options = void 0, 
groupChildren && (state.used = !0)));
}
}
groupMap.delete(bestGroup);
const key = bestGroup.name, groupConfig = bestGroup.config, allItems = Array.from(items, (({item}) => item));
bestGroup.alreadyGrouped = !0;
const children = groupChildren ? runGrouping(items) : allItems;
bestGroup.alreadyGrouped = !1, results.push(groupConfig.createGroup(key, children, allItems));
}
for (const {item} of itemsWithGroups) results.push(item);
return results;
};
return runGrouping(itemsWithGroups);
};
},
7519: (__unused_webpack_module, exports) => {
"use strict";
const equalityCache = new WeakMap;
exports.isSourceEqual = (a, b) => {
if (a === b) return !0;
const cache1 = equalityCache.get(a);
if (void 0 !== cache1) {
const result = cache1.get(b);
if (void 0 !== result) return result;
}
const result = ((a, b) => {
let aSource = "function" == typeof a.buffer ? a.buffer() : a.source(), bSource = "function" == typeof b.buffer ? b.buffer() : b.source();
return aSource === bSource || ("string" != typeof aSource || "string" != typeof bSource) && (Buffer.isBuffer(aSource) || (aSource = Buffer.from(aSource, "utf-8")), 
Buffer.isBuffer(bSource) || (bSource = Buffer.from(bSource, "utf-8")), aSource.equals(bSource));
})(a, b);
if (void 0 !== cache1) cache1.set(b, result); else {
const map = new WeakMap;
map.set(b, result), equalityCache.set(a, map);
}
const cache2 = equalityCache.get(b);
if (void 0 !== cache2) cache2.set(a, result); else {
const map = new WeakMap;
map.set(a, result), equalityCache.set(b, map);
}
return result;
};
},
69353: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {validate} = __webpack_require__(33842), DID_YOU_MEAN = {
rules: "module.rules",
loaders: "module.rules or module.rules.*.use",
query: "module.rules.*.options (BREAKING CHANGE since webpack 5)",
noParse: "module.noParse",
filename: "output.filename or module.rules.*.generator.filename",
file: "output.filename",
chunkFilename: "output.chunkFilename",
chunkfilename: "output.chunkFilename",
ecmaVersion: "output.environment (output.ecmaVersion was a temporary configuration option during webpack 5 beta)",
ecmaversion: "output.environment (output.ecmaVersion was a temporary configuration option during webpack 5 beta)",
ecma: "output.environment (output.ecmaVersion was a temporary configuration option during webpack 5 beta)",
path: "output.path",
pathinfo: "output.pathinfo",
pathInfo: "output.pathinfo",
jsonpFunction: "output.chunkLoadingGlobal (BREAKING CHANGE since webpack 5)",
chunkCallbackName: "output.chunkLoadingGlobal (BREAKING CHANGE since webpack 5)",
jsonpScriptType: "output.scriptType (BREAKING CHANGE since webpack 5)",
hotUpdateFunction: "output.hotUpdateGlobal (BREAKING CHANGE since webpack 5)",
splitChunks: "optimization.splitChunks",
immutablePaths: "snapshot.immutablePaths",
managedPaths: "snapshot.managedPaths",
maxModules: "stats.modulesSpace (BREAKING CHANGE since webpack 5)",
hashedModuleIds: 'optimization.moduleIds: "hashed" (BREAKING CHANGE since webpack 5)',
namedChunks: 'optimization.chunkIds: "named" (BREAKING CHANGE since webpack 5)',
namedModules: 'optimization.moduleIds: "named" (BREAKING CHANGE since webpack 5)',
occurrenceOrder: 'optimization.chunkIds: "size" and optimization.moduleIds: "size" (BREAKING CHANGE since webpack 5)',
automaticNamePrefix: "optimization.splitChunks.[cacheGroups.*].idHint (BREAKING CHANGE since webpack 5)",
noEmitOnErrors: "optimization.emitOnErrors (BREAKING CHANGE since webpack 5: logic is inverted to avoid negative flags)",
Buffer: 'to use the ProvidePlugin to process the Buffer variable to modules as polyfill\nBREAKING CHANGE: webpack 5 no longer provided Node.js polyfills by default.\nNote: if you are using \'node.Buffer: false\', you can just remove that as this is the default behavior now.\nTo provide a polyfill to modules use:\nnew ProvidePlugin({ Buffer: ["buffer", "Buffer"] }) and npm install buffer.',
process: "to use the ProvidePlugin to process the process variable to modules as polyfill\nBREAKING CHANGE: webpack 5 no longer provided Node.js polyfills by default.\nNote: if you are using 'node.process: false', you can just remove that as this is the default behavior now.\nTo provide a polyfill to modules use:\nnew ProvidePlugin({ process: \"process\" }) and npm install buffer."
}, REMOVED = {
concord: "BREAKING CHANGE: resolve.concord has been removed and is no longer available.",
devtoolLineToLine: "BREAKING CHANGE: output.devtoolLineToLine has been removed and is no longer available."
};
module.exports = (schema, options, validationConfiguration) => {
validate(schema, options, validationConfiguration || {
name: "Webpack",
postFormatter: (formattedError, error) => {
const children = error.children;
if (children && children.some((child => "absolutePath" === child.keyword && ".output.filename" === child.dataPath))) return `${formattedError}\nPlease use output.path to specify absolute path and output.filename for the file name.`;
if (children && children.some((child => "pattern" === child.keyword && ".devtool" === child.dataPath))) return `${formattedError}\nBREAKING CHANGE since webpack 5: The devtool option is more strict.\nPlease strictly follow the order of the keywords in the pattern.`;
if ("additionalProperties" === error.keyword) {
const params = error.params;
if (Object.prototype.hasOwnProperty.call(DID_YOU_MEAN, params.additionalProperty)) return `${formattedError}\nDid you mean ${DID_YOU_MEAN[params.additionalProperty]}?`;
if (Object.prototype.hasOwnProperty.call(REMOVED, params.additionalProperty)) return `${formattedError}\n${REMOVED[params.additionalProperty]}?`;
if (!error.dataPath) {
if ("debug" === params.additionalProperty) return `${formattedError}\nThe 'debug' property was removed in webpack 2.0.0.\nLoaders should be updated to allow passing this option via loader options in module.rules.\nUntil loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\nplugins: [\n  new webpack.LoaderOptionsPlugin({\n    debug: true\n  })\n]`;
if (params.additionalProperty) return `${formattedError}\nFor typos: please correct them.\nFor loader options: webpack >= v2.0.0 no longer allows custom properties in configuration.\n  Loaders should be updated to allow passing options via loader options in module.rules.\n  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n  plugins: [\n    new webpack.LoaderOptionsPlugin({\n      // test: /\\.xxx$/, // may apply this only for some modules\n      options: {\n        ${params.additionalProperty}: …\n      }\n    })\n  ]`;
}
}
return formattedError;
}
});
};
},
67697: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370);
module.exports = class extends RuntimeModule {
constructor({generateLoadBinaryCode, supportsStreaming}) {
super("wasm loading", RuntimeModule.STAGE_NORMAL), this.generateLoadBinaryCode = generateLoadBinaryCode, 
this.supportsStreaming = supportsStreaming;
}
generate() {
const {compilation, chunk} = this, {outputOptions, runtimeTemplate} = compilation, fn = RuntimeGlobals.instantiateWasm, wasmModuleSrcPath = compilation.getPath(JSON.stringify(outputOptions.webassemblyModuleFilename), {
hash: `" + ${RuntimeGlobals.getFullHash}() + "`,
hashWithLength: length => `" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + "`,
module: {
id: '" + wasmModuleId + "',
hash: '" + wasmModuleHash + "',
hashWithLength: length => `" + wasmModuleHash.slice(0, ${length}) + "`
},
runtime: chunk.runtime
});
return `${fn} = ${runtimeTemplate.basicFunction("exports, wasmModuleId, wasmModuleHash, importsObj", [ `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, this.supportsStreaming ? Template.asString([ "if (typeof WebAssembly.instantiateStreaming === 'function') {", Template.indent([ "return WebAssembly.instantiateStreaming(req, importsObj)", Template.indent([ `.then(${runtimeTemplate.returningFunction("Object.assign(exports, res.instance.exports)", "res")});` ]) ]), "}" ]) : "// no support for streaming compilation", "return req", Template.indent([ `.then(${runtimeTemplate.returningFunction("x.arrayBuffer()", "x")})`, `.then(${runtimeTemplate.returningFunction("WebAssembly.instantiate(bytes, importsObj)", "bytes")})`, `.then(${runtimeTemplate.returningFunction("Object.assign(exports, res.instance.exports)", "res")});` ]) ])};`;
}
};
},
72212: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Generator = __webpack_require__(70607), TYPES = new Set([ "webassembly" ]);
module.exports = class extends Generator {
constructor(options) {
super(), this.options = options;
}
getTypes(module) {
return TYPES;
}
getSize(module, type) {
const originalSource = module.originalSource();
return originalSource ? originalSource.size() : 0;
}
generate(module, generateContext) {
return module.originalSource();
}
};
},
4290: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), Generator = __webpack_require__(70607), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), WebAssemblyImportDependency = __webpack_require__(68953), TYPES = new Set([ "webassembly" ]);
module.exports = class extends Generator {
constructor(filenameTemplate) {
super(), this.filenameTemplate = filenameTemplate;
}
getTypes(module) {
return TYPES;
}
getSize(module, type) {
return 40 + 10 * module.dependencies.length;
}
generate(module, generateContext) {
const {runtimeTemplate, chunkGraph, moduleGraph, runtimeRequirements, runtime} = generateContext;
runtimeRequirements.add(RuntimeGlobals.module), runtimeRequirements.add(RuntimeGlobals.moduleId), 
runtimeRequirements.add(RuntimeGlobals.exports), runtimeRequirements.add(RuntimeGlobals.instantiateWasm);
const initFragments = [], depModules = new Map, wasmDepsByRequest = new Map;
for (const dep of module.dependencies) if (dep instanceof WebAssemblyImportDependency) {
const module = moduleGraph.getModule(dep);
depModules.has(module) || depModules.set(module, {
request: dep.request,
importVar: `WEBPACK_IMPORTED_MODULE_${depModules.size}`
});
let list = wasmDepsByRequest.get(dep.request);
void 0 === list && (list = [], wasmDepsByRequest.set(dep.request, list)), list.push(dep);
}
const promises = [], importStatements = Array.from(depModules, (([importedModule, {request, importVar}]) => (moduleGraph.isAsync(importedModule) && promises.push(importVar), 
runtimeTemplate.importStatement({
update: !1,
module: importedModule,
chunkGraph,
request,
originModule: module,
importVar,
runtimeRequirements
})))), importsCode = importStatements.map((([x]) => x)).join(""), importsCompatCode = importStatements.map((([_, x]) => x)).join(""), importObjRequestItems = Array.from(wasmDepsByRequest, (([request, deps]) => {
const exportItems = deps.map((dep => {
const importedModule = moduleGraph.getModule(dep), importVar = depModules.get(importedModule).importVar;
return `${JSON.stringify(dep.name)}: ${runtimeTemplate.exportFromImport({
moduleGraph,
module: importedModule,
request,
exportName: dep.name,
originModule: module,
asiSafe: !0,
isCall: !1,
callContext: !1,
defaultInterop: !0,
importVar,
initFragments,
runtime,
runtimeRequirements
})}`;
}));
return Template.asString([ `${JSON.stringify(request)}: {`, Template.indent(exportItems.join(",\n")), "}" ]);
})), importsObj = importObjRequestItems.length > 0 ? Template.asString([ "{", Template.indent(importObjRequestItems.join(",\n")), "}" ]) : void 0, instantiateCall = `${RuntimeGlobals.instantiateWasm}(${module.exportsArgument}, ${module.moduleArgument}.id, ${JSON.stringify(chunkGraph.getRenderedModuleHash(module, runtime))}` + (importsObj ? `, ${importsObj})` : ")");
promises.length > 0 && runtimeRequirements.add(RuntimeGlobals.asyncModule);
const source = new RawSource(promises.length > 0 ? Template.asString([ `var __webpack_instantiate__ = ${runtimeTemplate.basicFunction(`[${promises.join(", ")}]`, `${importsCompatCode}return ${instantiateCall};`)}`, `${RuntimeGlobals.asyncModule}(${module.moduleArgument}, async ${runtimeTemplate.basicFunction("__webpack_handle_async_dependencies__, __webpack_async_result__", [ "try {", importsCode, `var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([${promises.join(", ")}]);`, `var [${promises.join(", ")}] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__;`, `${importsCompatCode}await ${instantiateCall};`, "__webpack_async_result__();", "} catch(e) { __webpack_async_result__(e); }" ])}, 1);` ]) : `${importsCode}${importsCompatCode}module.exports = ${instantiateCall};`);
return InitFragment.addToSource(source, initFragments, generateContext);
}
};
},
61986: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook} = __webpack_require__(89991), Compilation = __webpack_require__(62843), Generator = __webpack_require__(70607), {tryRunOrWebpackError} = __webpack_require__(44741), WebAssemblyImportDependency = __webpack_require__(68953), {compareModulesByIdentifier} = __webpack_require__(40028), memoize = __webpack_require__(98216), getAsyncWebAssemblyGenerator = memoize((() => __webpack_require__(72212))), getAsyncWebAssemblyJavascriptGenerator = memoize((() => __webpack_require__(4290))), getAsyncWebAssemblyParser = memoize((() => __webpack_require__(83343))), compilationHooksMap = new WeakMap;
class AsyncWebAssemblyModulesPlugin {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
renderModuleContent: new SyncWaterfallHook([ "source", "module", "renderContext" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(options) {
this.options = options;
}
apply(compiler) {
compiler.hooks.compilation.tap("AsyncWebAssemblyModulesPlugin", ((compilation, {normalModuleFactory}) => {
const hooks = AsyncWebAssemblyModulesPlugin.getCompilationHooks(compilation);
compilation.dependencyFactories.set(WebAssemblyImportDependency, normalModuleFactory), 
normalModuleFactory.hooks.createParser.for("webassembly/async").tap("AsyncWebAssemblyModulesPlugin", (() => new (getAsyncWebAssemblyParser()))), 
normalModuleFactory.hooks.createGenerator.for("webassembly/async").tap("AsyncWebAssemblyModulesPlugin", (() => {
const AsyncWebAssemblyJavascriptGenerator = getAsyncWebAssemblyJavascriptGenerator(), AsyncWebAssemblyGenerator = getAsyncWebAssemblyGenerator();
return Generator.byType({
javascript: new AsyncWebAssemblyJavascriptGenerator(compilation.outputOptions.webassemblyModuleFilename),
webassembly: new AsyncWebAssemblyGenerator(this.options)
});
})), compilation.hooks.renderManifest.tap("WebAssemblyModulesPlugin", ((result, options) => {
const {moduleGraph, chunkGraph, runtimeTemplate} = compilation, {chunk, outputOptions, dependencyTemplates, codeGenerationResults} = options;
for (const module of chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier)) if ("webassembly/async" === module.type) {
const filenameTemplate = outputOptions.webassemblyModuleFilename;
result.push({
render: () => this.renderModule(module, {
chunk,
dependencyTemplates,
runtimeTemplate,
moduleGraph,
chunkGraph,
codeGenerationResults
}, hooks),
filenameTemplate,
pathOptions: {
module,
runtime: chunk.runtime,
chunkGraph
},
auxiliary: !0,
identifier: `webassemblyAsyncModule${chunkGraph.getModuleId(module)}`,
hash: chunkGraph.getModuleHash(module, chunk.runtime)
});
}
return result;
}));
}));
}
renderModule(module, renderContext, hooks) {
const {codeGenerationResults, chunk} = renderContext;
try {
const moduleSource = codeGenerationResults.getSource(module, chunk.runtime, "webassembly");
return tryRunOrWebpackError((() => hooks.renderModuleContent.call(moduleSource, module, renderContext)), "AsyncWebAssemblyModulesPlugin.getCompilationHooks().renderModuleContent");
} catch (e) {
throw e.module = module, e;
}
}
}
module.exports = AsyncWebAssemblyModulesPlugin;
},
83343: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const t = __webpack_require__(75971), {decode} = __webpack_require__(64812), Parser = __webpack_require__(21475), StaticExportsDependency = __webpack_require__(21776), WebAssemblyImportDependency = __webpack_require__(68953), decoderOpts = {
ignoreCodeSection: !0,
ignoreDataSection: !0,
ignoreCustomNameSection: !0
};
module.exports = class extends Parser {
constructor(options) {
super(), this.hooks = Object.freeze({}), this.options = options;
}
parse(source, state) {
if (!Buffer.isBuffer(source)) throw new Error("WebAssemblyParser input must be a Buffer");
state.module.buildInfo.strict = !0, state.module.buildMeta.exportsType = "namespace", 
state.module.buildMeta.async = !0;
const module = decode(source, decoderOpts).body[0], exports = [];
return t.traverse(module, {
ModuleExport({node}) {
exports.push(node.name);
},
ModuleImport({node}) {
const dep = new WebAssemblyImportDependency(node.module, node.name, node.descr, !1);
state.module.addDependency(dep);
}
}), state.module.addDependency(new StaticExportsDependency(exports, !1)), state;
}
};
},
45676: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(message) {
super(message), this.name = "UnsupportedWebAssemblyFeatureError", this.hideStack = !0;
}
};
},
626: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {compareModulesByIdentifier} = __webpack_require__(40028), WebAssemblyUtils = __webpack_require__(79657);
module.exports = class extends RuntimeModule {
constructor({generateLoadBinaryCode, supportsStreaming, mangleImports, runtimeRequirements}) {
super("wasm chunk loading", RuntimeModule.STAGE_ATTACH), this.generateLoadBinaryCode = generateLoadBinaryCode, 
this.supportsStreaming = supportsStreaming, this.mangleImports = mangleImports, 
this._runtimeRequirements = runtimeRequirements;
}
generate() {
const {chunkGraph, compilation, chunk, mangleImports} = this, {moduleGraph, outputOptions} = compilation, fn = RuntimeGlobals.ensureChunkHandlers, withHmr = this._runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), wasmModules = ((moduleGraph, chunkGraph, chunk) => {
const wasmModules = chunk.getAllAsyncChunks(), array = [];
for (const chunk of wasmModules) for (const m of chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier)) m.type.startsWith("webassembly") && array.push(m);
return array;
})(0, chunkGraph, chunk), declarations = [], importObjects = wasmModules.map((module => ((chunkGraph, module, mangle, declarations, runtime) => {
const moduleGraph = chunkGraph.moduleGraph, waitForInstances = new Map, properties = [], usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle);
for (const usedDep of usedWasmDependencies) {
const dep = usedDep.dependency, importedModule = moduleGraph.getModule(dep), exportName = dep.name, usedName = importedModule && moduleGraph.getExportsInfo(importedModule).getUsedName(exportName, runtime), description = dep.description, direct = dep.onlyDirectImport, module = usedDep.module, name = usedDep.name;
if (direct) {
const instanceVar = `m${waitForInstances.size}`;
waitForInstances.set(instanceVar, chunkGraph.getModuleId(importedModule)), properties.push({
module,
name,
value: `${instanceVar}[${JSON.stringify(usedName)}]`
});
} else {
const params = description.signature.params.map(((param, k) => "p" + k + param.valtype)), mod = `${RuntimeGlobals.moduleCache}[${JSON.stringify(chunkGraph.getModuleId(importedModule))}]`, modExports = `${mod}.exports`, cache = `wasmImportedFuncCache${declarations.length}`;
declarations.push(`var ${cache};`), properties.push({
module,
name,
value: Template.asString([ (importedModule.type.startsWith("webassembly") ? `${mod} ? ${modExports}[${JSON.stringify(usedName)}] : ` : "") + `function(${params}) {`, Template.indent([ `if(${cache} === undefined) ${cache} = ${modExports};`, `return ${cache}[${JSON.stringify(usedName)}](${params});` ]), "}" ])
});
}
}
let importObject;
if (mangle) importObject = [ "return {", Template.indent([ properties.map((p => `${JSON.stringify(p.name)}: ${p.value}`)).join(",\n") ]), "};" ]; else {
const propertiesByModule = new Map;
for (const p of properties) {
let list = propertiesByModule.get(p.module);
void 0 === list && propertiesByModule.set(p.module, list = []), list.push(p);
}
importObject = [ "return {", Template.indent([ Array.from(propertiesByModule, (([module, list]) => Template.asString([ `${JSON.stringify(module)}: {`, Template.indent([ list.map((p => `${JSON.stringify(p.name)}: ${p.value}`)).join(",\n") ]), "}" ]))).join(",\n") ]), "};" ];
}
const moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));
if (1 === waitForInstances.size) {
const moduleId = Array.from(waitForInstances.values())[0], promise = `installedWasmModules[${JSON.stringify(moduleId)}]`, variable = Array.from(waitForInstances.keys())[0];
return Template.asString([ `${moduleIdStringified}: function() {`, Template.indent([ `return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), "});" ]), "}," ]);
}
if (waitForInstances.size > 0) {
const promises = Array.from(waitForInstances.values(), (id => `installedWasmModules[${JSON.stringify(id)}]`)).join(", "), variables = Array.from(waitForInstances.keys(), ((name, i) => `${name} = array[${i}]`)).join(", ");
return Template.asString([ `${moduleIdStringified}: function() {`, Template.indent([ `return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([ `var ${variables};`, ...importObject ]), "});" ]), "}," ]);
}
return Template.asString([ `${moduleIdStringified}: function() {`, Template.indent(importObject), "}," ]);
})(chunkGraph, module, this.mangleImports, declarations, chunk.runtime))), chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, (m => m.type.startsWith("webassembly"))), createImportObject = content => mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content, wasmModuleSrcPath = compilation.getPath(JSON.stringify(outputOptions.webassemblyModuleFilename), {
hash: `" + ${RuntimeGlobals.getFullHash}() + "`,
hashWithLength: length => `" + ${RuntimeGlobals.getFullHash}}().slice(0, ${length}) + "`,
module: {
id: '" + wasmModuleId + "',
hash: `" + ${JSON.stringify(chunkGraph.getChunkModuleRenderedHashMap(chunk, (m => m.type.startsWith("webassembly"))))}[chunkId][wasmModuleId] + "`,
hashWithLength: length => `" + ${JSON.stringify(chunkGraph.getChunkModuleRenderedHashMap(chunk, (m => m.type.startsWith("webassembly")), length))}[chunkId][wasmModuleId] + "`
},
runtime: chunk.runtime
}), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_wasm` : void 0;
return Template.asString([ "// object to store loaded and loading wasm modules", `var installedWasmModules = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{};`, "", "function promiseResolve() { return Promise.resolve(); }", "", Template.asString(declarations), "var wasmImportObjects = {", Template.indent(importObjects), "};", "", `var wasmModuleMap = ${JSON.stringify(chunkModuleIdMap, void 0, "\t")};`, "", "// object with all WebAssembly.instance exports", `${RuntimeGlobals.wasmInstances} = {};`, "", "// Fetch + compile chunk loading for webassembly", `${fn}.wasm = function(chunkId, promises) {`, Template.indent([ "", "var wasmModules = wasmModuleMap[chunkId] || [];", "", "wasmModules.forEach(function(wasmModuleId, idx) {", Template.indent([ "var installedWasmModuleData = installedWasmModules[wasmModuleId];", "", '// a Promise means "currently loading" or "already loaded".', "if(installedWasmModuleData)", Template.indent([ "promises.push(installedWasmModuleData);" ]), "else {", Template.indent([ "var importObject = wasmImportObjects[wasmModuleId]();", `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, "var promise;", this.supportsStreaming ? Template.asString([ "if(importObject && typeof importObject.then === 'function' && typeof WebAssembly.compileStreaming === 'function') {", Template.indent([ "promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {", Template.indent([ `return WebAssembly.instantiate(items[0], ${createImportObject("items[1]")});` ]), "});" ]), "} else if(typeof WebAssembly.instantiateStreaming === 'function') {", Template.indent([ `promise = WebAssembly.instantiateStreaming(req, ${createImportObject("importObject")});` ]) ]) : Template.asString([ "if(importObject && typeof importObject.then === 'function') {", Template.indent([ "var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });", "promise = Promise.all([", Template.indent([ "bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),", "importObject" ]), "]).then(function(items) {", Template.indent([ `return WebAssembly.instantiate(items[0], ${createImportObject("items[1]")});` ]), "});" ]) ]), "} else {", Template.indent([ "var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });", "promise = bytesPromise.then(function(bytes) {", Template.indent([ `return WebAssembly.instantiate(bytes, ${createImportObject("importObject")});` ]), "});" ]), "}", "promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {", Template.indent([ `return ${RuntimeGlobals.wasmInstances}[wasmModuleId] = (res.instance || res).exports;` ]), "}));" ]), "}" ]), "});" ]), "};" ]);
}
};
},
81833: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const formatLocation = __webpack_require__(78509), UnsupportedWebAssemblyFeatureError = __webpack_require__(45676);
module.exports = class {
apply(compiler) {
compiler.hooks.compilation.tap("WasmFinalizeExportsPlugin", (compilation => {
compilation.hooks.finishModules.tap("WasmFinalizeExportsPlugin", (modules => {
for (const module of modules) if (!0 === module.type.startsWith("webassembly")) {
const jsIncompatibleExports = module.buildMeta.jsIncompatibleExports;
if (void 0 === jsIncompatibleExports) continue;
for (const connection of compilation.moduleGraph.getIncomingConnections(module)) if (connection.isTargetActive(void 0) && !1 === connection.originModule.type.startsWith("webassembly")) {
const referencedExports = compilation.getDependencyReferencedExports(connection.dependency, void 0);
for (const info of referencedExports) {
const names = Array.isArray(info) ? info : info.name;
if (0 === names.length) continue;
const name = names[0];
if ("object" != typeof name && Object.prototype.hasOwnProperty.call(jsIncompatibleExports, name)) {
const error = new UnsupportedWebAssemblyFeatureError(`Export "${name}" with ${jsIncompatibleExports[name]} can only be used for direct wasm to wasm dependencies\nIt's used from ${connection.originModule.readableIdentifier(compilation.requestShortener)} at ${formatLocation(connection.dependency.loc)}.`);
error.module = module, compilation.errors.push(error);
}
}
}
}
}));
}));
}
};
},
31183: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), Generator = __webpack_require__(70607), WebAssemblyUtils = __webpack_require__(79657), t = __webpack_require__(75971), {moduleContextFromModuleAST} = __webpack_require__(75971), {editWithAST, addWithAST} = __webpack_require__(4898), {decode} = __webpack_require__(64812), WebAssemblyExportImportedDependency = __webpack_require__(66847), createDefaultInitForGlobal = globalType => {
if ("i" === globalType.valtype[0]) return t.objectInstruction("const", globalType.valtype, [ t.numberLiteralFromRaw(66) ]);
if ("f" === globalType.valtype[0]) return t.objectInstruction("const", globalType.valtype, [ t.floatLiteral(66, !1, !1, "66") ]);
throw new Error("unknown type: " + globalType.valtype);
}, TYPES = new Set([ "webassembly" ]);
module.exports = class extends Generator {
constructor(options) {
super(), this.options = options;
}
getTypes(module) {
return TYPES;
}
getSize(module, type) {
const originalSource = module.originalSource();
return originalSource ? originalSource.size() : 0;
}
generate(module, {moduleGraph, runtime}) {
const bin = module.originalSource().source(), initFuncId = t.identifier(""), ast = decode(bin, {
ignoreDataSection: !0,
ignoreCodeSection: !0,
ignoreCustomNameSection: !0
}), moduleContext = moduleContextFromModuleAST(ast.body[0]), importedGlobals = (ast => {
const importedGlobals = [];
return t.traverse(ast, {
ModuleImport({node}) {
t.isGlobalType(node.descr) && importedGlobals.push(node);
}
}), importedGlobals;
})(ast), countImportedFunc = (ast => {
let count = 0;
return t.traverse(ast, {
ModuleImport({node}) {
t.isFuncImportDescr(node.descr) && count++;
}
}), count;
})(ast), startAtFuncOffset = moduleContext.getStart(), nextFuncIndex = ((ast, countImportedFunc) => {
const funcSectionMetadata = t.getSectionMetadata(ast, "func");
if (void 0 === funcSectionMetadata) return t.indexLiteral(0 + countImportedFunc);
const vectorOfSize = funcSectionMetadata.vectorOfSize.value;
return t.indexLiteral(vectorOfSize + countImportedFunc);
})(ast, countImportedFunc), nextTypeIndex = (ast => {
const typeSectionMetadata = t.getSectionMetadata(ast, "type");
return void 0 === typeSectionMetadata ? t.indexLiteral(0) : t.indexLiteral(typeSectionMetadata.vectorOfSize.value);
})(ast), usedDependencyMap = ((moduleGraph, module, mangle) => {
const map = new Map;
for (const usedDep of WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle)) {
const dep = usedDep.dependency, request = dep.request, exportName = dep.name;
map.set(request + ":" + exportName, usedDep);
}
return map;
})(moduleGraph, module, this.options.mangleImports), externalExports = new Set(module.dependencies.filter((d => d instanceof WebAssemblyExportImportedDependency)).map((d => d.exportName))), additionalInitCode = [], transform = ((...fns) => fns.reduce(((prevFn, nextFn) => value => nextFn(prevFn(value))), (value => value)))((({ast, moduleGraph, module, externalExports, runtime}) => bin => editWithAST(ast, bin, {
ModuleExport(path) {
if (externalExports.has(path.node.name)) return void path.remove();
const usedName = moduleGraph.getExportsInfo(module).getUsedName(path.node.name, runtime);
usedName ? path.node.name = usedName : path.remove();
}
}))({
ast,
moduleGraph,
module,
externalExports,
runtime
}), (state = {
ast
}, bin => editWithAST(state.ast, bin, {
Start(path) {
path.remove();
}
})), (state => bin => {
const additionalInitCode = state.additionalInitCode, newGlobals = [];
return bin = editWithAST(state.ast, bin, {
ModuleImport(path) {
if (t.isGlobalType(path.node.descr)) {
const globalType = path.node.descr;
globalType.mutability = "var";
const init = [ createDefaultInitForGlobal(globalType), t.instruction("end") ];
newGlobals.push(t.global(globalType, init)), path.remove();
}
},
Global(path) {
const {node} = path, [init] = node.init;
if ("get_global" === init.id) {
node.globalType.mutability = "var";
const initialGlobalIdx = init.args[0];
node.init = [ createDefaultInitForGlobal(node.globalType), t.instruction("end") ], 
additionalInitCode.push(t.instruction("get_local", [ initialGlobalIdx ]), t.instruction("set_global", [ t.indexLiteral(newGlobals.length) ]));
}
newGlobals.push(node), path.remove();
}
}), addWithAST(state.ast, bin, newGlobals);
})({
ast,
additionalInitCode
}), (({ast, usedDependencyMap}) => bin => editWithAST(ast, bin, {
ModuleImport(path) {
const result = usedDependencyMap.get(path.node.module + ":" + path.node.name);
void 0 !== result && (path.node.module = result.module, path.node.name = result.name);
}
}))({
ast,
usedDependencyMap
}), (({ast, initFuncId, startAtFuncOffset, importedGlobals, additionalInitCode, nextFuncIndex, nextTypeIndex}) => bin => {
const funcParams = importedGlobals.map((importedGlobal => {
const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);
return t.funcParam(importedGlobal.descr.valtype, id);
})), funcBody = [];
importedGlobals.forEach(((importedGlobal, index) => {
const args = [ t.indexLiteral(index) ], body = [ t.instruction("get_local", args), t.instruction("set_global", args) ];
funcBody.push(...body);
})), "number" == typeof startAtFuncOffset && funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));
for (const instr of additionalInitCode) funcBody.push(instr);
funcBody.push(t.instruction("end"));
const funcSignature = t.signature(funcParams, []), func = t.func(initFuncId, funcSignature, funcBody), functype = t.typeInstruction(void 0, funcSignature), funcindex = t.indexInFuncSection(nextTypeIndex), moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr("Func", nextFuncIndex));
return addWithAST(ast, bin, [ func, moduleExport, funcindex, functype ]);
})({
ast,
initFuncId,
importedGlobals,
additionalInitCode,
startAtFuncOffset,
nextFuncIndex,
nextTypeIndex
}));
var state;
const newBin = transform(bin), newBuf = Buffer.from(newBin);
return new RawSource(newBuf);
}
};
},
76428: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const WebpackError = __webpack_require__(64326);
module.exports = class extends WebpackError {
constructor(module, moduleGraph, chunkGraph, requestShortener) {
const moduleChains = ((module, moduleGraph, chunkGraph, requestShortener) => {
const queue = [ {
head: module,
message: module.readableIdentifier(requestShortener)
} ], results = new Set, incompleteResults = new Set, visitedModules = new Set;
for (const chain of queue) {
const {head, message} = chain;
let final = !0;
const alreadyReferencedModules = new Set;
for (const connection of moduleGraph.getIncomingConnections(head)) {
const newHead = connection.originModule;
if (newHead) {
if (!chunkGraph.getModuleChunks(newHead).some((c => c.canBeInitial()))) continue;
if (final = !1, alreadyReferencedModules.has(newHead)) continue;
alreadyReferencedModules.add(newHead);
const newMessage = `${newHead.readableIdentifier(requestShortener)}${connection.explanation ? ` (${connection.explanation})` : ""} --\x3e ${message}`;
if (visitedModules.has(newHead)) {
incompleteResults.add(`... --\x3e ${newMessage}`);
continue;
}
visitedModules.add(newHead), queue.push({
head: newHead,
message: newMessage
});
} else {
final = !1;
const newMessage = connection.explanation ? `(${connection.explanation}) --\x3e ${message}` : message;
results.add(newMessage);
}
}
final && results.add(message);
}
for (const result of incompleteResults) results.add(result);
return Array.from(results);
})(module, moduleGraph, chunkGraph, requestShortener);
super(`WebAssembly module is included in initial chunk.\nThis is not allowed, because WebAssembly download and compilation must happen asynchronous.\nAdd an async split point (i. e. import()) somewhere between your entrypoint and the WebAssembly module:\n${moduleChains.map((s => `* ${s}`)).join("\n")}`), 
this.name = "WebAssemblyInInitialChunkError", this.hideStack = !0, this.module = module;
}
};
},
84909: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {RawSource} = __webpack_require__(37946), {UsageState} = __webpack_require__(74603), Generator = __webpack_require__(70607), InitFragment = __webpack_require__(95328), RuntimeGlobals = __webpack_require__(50980), Template = __webpack_require__(88370), ModuleDependency = __webpack_require__(15216), WebAssemblyExportImportedDependency = __webpack_require__(66847), WebAssemblyImportDependency = __webpack_require__(68953), TYPES = new Set([ "webassembly" ]);
module.exports = class extends Generator {
getTypes(module) {
return TYPES;
}
getSize(module, type) {
return 95 + 5 * module.dependencies.length;
}
generate(module, generateContext) {
const {runtimeTemplate, moduleGraph, chunkGraph, runtimeRequirements, runtime} = generateContext, initFragments = [], exportsInfo = moduleGraph.getExportsInfo(module);
let needExportsCopy = !1;
const importedModules = new Map, initParams = [];
let index = 0;
for (const dep of module.dependencies) {
const moduleDep = dep && dep instanceof ModuleDependency ? dep : void 0;
if (moduleGraph.getModule(dep)) {
let importData = importedModules.get(moduleGraph.getModule(dep));
if (void 0 === importData && (importedModules.set(moduleGraph.getModule(dep), importData = {
importVar: `m${index}`,
index,
request: moduleDep && moduleDep.userRequest || void 0,
names: new Set,
reexports: []
}), index++), dep instanceof WebAssemblyImportDependency && (importData.names.add(dep.name), 
"GlobalType" === dep.description.type)) {
const exportName = dep.name, importedModule = moduleGraph.getModule(dep);
if (importedModule) {
moduleGraph.getExportsInfo(importedModule).getUsedName(exportName, runtime) && initParams.push(runtimeTemplate.exportFromImport({
moduleGraph,
module: importedModule,
request: dep.request,
importVar: importData.importVar,
originModule: module,
exportName: dep.name,
asiSafe: !0,
isCall: !1,
callContext: null,
defaultInterop: !0,
initFragments,
runtime,
runtimeRequirements
}));
}
}
if (dep instanceof WebAssemblyExportImportedDependency) {
importData.names.add(dep.name);
const usedName = moduleGraph.getExportsInfo(module).getUsedName(dep.exportName, runtime);
if (usedName) {
runtimeRequirements.add(RuntimeGlobals.exports);
const exportProp = `${module.exportsArgument}[${JSON.stringify(usedName)}]`, defineStatement = Template.asString([ `${exportProp} = ${runtimeTemplate.exportFromImport({
moduleGraph,
module: moduleGraph.getModule(dep),
request: dep.request,
importVar: importData.importVar,
originModule: module,
exportName: dep.name,
asiSafe: !0,
isCall: !1,
callContext: null,
defaultInterop: !0,
initFragments,
runtime,
runtimeRequirements
})};`, `if(WebAssembly.Global) ${exportProp} = new WebAssembly.Global({ value: ${JSON.stringify(dep.valueType)} }, ${exportProp});` ]);
importData.reexports.push(defineStatement), needExportsCopy = !0;
}
}
}
}
const importsCode = Template.asString(Array.from(importedModules, (([module, {importVar, request, reexports}]) => {
const importStatement = runtimeTemplate.importStatement({
module,
chunkGraph,
request,
importVar,
originModule: module,
runtimeRequirements
});
return importStatement[0] + importStatement[1] + reexports.join("\n");
}))), copyAllExports = exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused && !needExportsCopy;
runtimeRequirements.add(RuntimeGlobals.module), runtimeRequirements.add(RuntimeGlobals.moduleId), 
runtimeRequirements.add(RuntimeGlobals.wasmInstances), exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused && (runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject), 
runtimeRequirements.add(RuntimeGlobals.exports)), copyAllExports || runtimeRequirements.add(RuntimeGlobals.exports);
const source = new RawSource([ '"use strict";', "// Instantiate WebAssembly module", `var wasmExports = ${RuntimeGlobals.wasmInstances}[${module.moduleArgument}.id];`, exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused ? `${RuntimeGlobals.makeNamespaceObject}(${module.exportsArgument});` : "", "// export exports from WebAssembly module", copyAllExports ? `${module.moduleArgument}.exports = wasmExports;` : `for(var name in wasmExports) if(name) ${module.exportsArgument}[name] = wasmExports[name];`, "// exec imports from WebAssembly module (for esm order)", importsCode, "", "// exec wasm module", `wasmExports[""](${initParams.join(", ")})` ].join("\n"));
return InitFragment.addToSource(source, initFragments, generateContext);
}
};
},
24698: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const Generator = __webpack_require__(70607), WebAssemblyExportImportedDependency = __webpack_require__(66847), WebAssemblyImportDependency = __webpack_require__(68953), {compareModulesByIdentifier} = __webpack_require__(40028), memoize = __webpack_require__(98216), WebAssemblyInInitialChunkError = __webpack_require__(76428), getWebAssemblyGenerator = memoize((() => __webpack_require__(31183))), getWebAssemblyJavascriptGenerator = memoize((() => __webpack_require__(84909))), getWebAssemblyParser = memoize((() => __webpack_require__(47895)));
module.exports = class {
constructor(options) {
this.options = options;
}
apply(compiler) {
compiler.hooks.compilation.tap("WebAssemblyModulesPlugin", ((compilation, {normalModuleFactory}) => {
compilation.dependencyFactories.set(WebAssemblyImportDependency, normalModuleFactory), 
compilation.dependencyFactories.set(WebAssemblyExportImportedDependency, normalModuleFactory), 
normalModuleFactory.hooks.createParser.for("webassembly/sync").tap("WebAssemblyModulesPlugin", (() => new (getWebAssemblyParser()))), 
normalModuleFactory.hooks.createGenerator.for("webassembly/sync").tap("WebAssemblyModulesPlugin", (() => {
const WebAssemblyJavascriptGenerator = getWebAssemblyJavascriptGenerator(), WebAssemblyGenerator = getWebAssemblyGenerator();
return Generator.byType({
javascript: new WebAssemblyJavascriptGenerator,
webassembly: new WebAssemblyGenerator(this.options)
});
})), compilation.hooks.renderManifest.tap("WebAssemblyModulesPlugin", ((result, options) => {
const {chunkGraph} = compilation, {chunk, outputOptions, codeGenerationResults} = options;
for (const module of chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier)) if ("webassembly/sync" === module.type) {
const filenameTemplate = outputOptions.webassemblyModuleFilename;
result.push({
render: () => codeGenerationResults.getSource(module, chunk.runtime, "webassembly"),
filenameTemplate,
pathOptions: {
module,
runtime: chunk.runtime,
chunkGraph
},
auxiliary: !0,
identifier: `webassemblyModule${chunkGraph.getModuleId(module)}`,
hash: chunkGraph.getModuleHash(module, chunk.runtime)
});
}
return result;
})), compilation.hooks.afterChunks.tap("WebAssemblyModulesPlugin", (() => {
const chunkGraph = compilation.chunkGraph, initialWasmModules = new Set;
for (const chunk of compilation.chunks) if (chunk.canBeInitial()) for (const module of chunkGraph.getChunkModulesIterable(chunk)) "webassembly/sync" === module.type && initialWasmModules.add(module);
for (const module of initialWasmModules) compilation.errors.push(new WebAssemblyInInitialChunkError(module, compilation.moduleGraph, compilation.chunkGraph, compilation.requestShortener));
}));
}));
}
};
},
47895: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const t = __webpack_require__(75971), {moduleContextFromModuleAST} = __webpack_require__(75971), {decode} = __webpack_require__(64812), Parser = __webpack_require__(21475), StaticExportsDependency = __webpack_require__(21776), WebAssemblyExportImportedDependency = __webpack_require__(66847), WebAssemblyImportDependency = __webpack_require__(68953), JS_COMPAT_TYPES = new Set([ "i32", "f32", "f64" ]), decoderOpts = {
ignoreCodeSection: !0,
ignoreDataSection: !0,
ignoreCustomNameSection: !0
};
module.exports = class extends Parser {
constructor(options) {
super(), this.hooks = Object.freeze({}), this.options = options;
}
parse(source, state) {
if (!Buffer.isBuffer(source)) throw new Error("WebAssemblyParser input must be a Buffer");
state.module.buildInfo.strict = !0, state.module.buildMeta.exportsType = "namespace";
const module = decode(source, decoderOpts).body[0], moduleContext = moduleContextFromModuleAST(module), exports = [];
let jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = void 0;
const importedGlobals = [];
return t.traverse(module, {
ModuleExport({node}) {
const descriptor = node.descr;
if ("Func" === descriptor.exportType) {
const funcIdx = descriptor.id.value, incompatibleType = (signature => {
for (const param of signature.args) if (!JS_COMPAT_TYPES.has(param)) return `${param} as parameter`;
for (const type of signature.result) if (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;
return null;
})(moduleContext.getFunction(funcIdx));
incompatibleType && (void 0 === jsIncompatibleExports && (jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = {}), 
jsIncompatibleExports[node.name] = incompatibleType);
}
if (exports.push(node.name), node.descr && "Global" === node.descr.exportType) {
const refNode = importedGlobals[node.descr.id.value];
if (refNode) {
const dep = new WebAssemblyExportImportedDependency(node.name, refNode.module, refNode.name, refNode.descr.valtype);
state.module.addDependency(dep);
}
}
},
Global({node}) {
const init = node.init[0];
let importNode = null;
if ("get_global" === init.id) {
const globalIdx = init.args[0].value;
globalIdx < importedGlobals.length && (importNode = importedGlobals[globalIdx]);
}
importedGlobals.push(importNode);
},
ModuleImport({node}) {
let onlyDirectImport = !1;
if (!0 === t.isMemory(node.descr)) onlyDirectImport = "Memory"; else if (!0 === t.isTable(node.descr)) onlyDirectImport = "Table"; else if (!0 === t.isFuncImportDescr(node.descr)) {
const incompatibleType = (signature => {
for (const param of signature.params) if (!JS_COMPAT_TYPES.has(param.valtype)) return `${param.valtype} as parameter`;
for (const type of signature.results) if (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;
return null;
})(node.descr.signature);
incompatibleType && (onlyDirectImport = `Non-JS-compatible Func Signature (${incompatibleType})`);
} else if (!0 === t.isGlobalType(node.descr)) {
const type = node.descr.valtype;
JS_COMPAT_TYPES.has(type) || (onlyDirectImport = `Non-JS-compatible Global Type (${type})`);
}
const dep = new WebAssemblyImportDependency(node.module, node.name, node.descr, onlyDirectImport);
state.module.addDependency(dep), t.isGlobalType(node.descr) && importedGlobals.push(node);
}
}), state.module.addDependency(new StaticExportsDependency(exports, !1)), state;
}
};
},
79657: (__unused_webpack_module, exports, __webpack_require__) => {
"use strict";
const Template = __webpack_require__(88370), WebAssemblyImportDependency = __webpack_require__(68953);
exports.getUsedDependencies = (moduleGraph, module, mangle) => {
const array = [];
let importIndex = 0;
for (const dep of module.dependencies) if (dep instanceof WebAssemblyImportDependency) {
if ("GlobalType" === dep.description.type || null === moduleGraph.getModule(dep)) continue;
const exportName = dep.name;
mangle ? array.push({
dependency: dep,
name: Template.numberToIdentifier(importIndex++),
module: "a"
}) : array.push({
dependency: dep,
name: exportName,
module: dep.request
});
}
return array;
}, exports.MANGLED_MODULE = "a";
},
44362: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const enabledTypes = new WeakMap, getEnabledTypes = compiler => {
let set = enabledTypes.get(compiler);
return void 0 === set && (set = new Set, enabledTypes.set(compiler, set)), set;
};
module.exports = class {
constructor(type) {
this.type = type;
}
static setEnabled(compiler, type) {
getEnabledTypes(compiler).add(type);
}
static checkEnabled(compiler, type) {
if (!getEnabledTypes(compiler).has(type)) throw new Error(`Library type "${type}" is not enabled. EnableWasmLoadingPlugin need to be used to enable this type of wasm loading. This usually happens through the "output.enabledWasmLoadingTypes" option. If you are using a function as entry which sets "wasmLoading", you need to add all potential library types to "output.enabledWasmLoadingTypes". These types are enabled: ` + Array.from(getEnabledTypes(compiler)).join(", "));
}
apply(compiler) {
const {type} = this, enabled = getEnabledTypes(compiler);
if (!enabled.has(type) && (enabled.add(type), "string" == typeof type)) switch (type) {
case "fetch":
{
const FetchCompileWasmPlugin = __webpack_require__(17903), FetchCompileAsyncWasmPlugin = __webpack_require__(75679);
new FetchCompileWasmPlugin({
mangleImports: compiler.options.optimization.mangleWasmImports
}).apply(compiler), (new FetchCompileAsyncWasmPlugin).apply(compiler);
break;
}

case "async-node":
{
const ReadFileCompileWasmPlugin = __webpack_require__(83410), ReadFileCompileAsyncWasmPlugin = __webpack_require__(34237);
new ReadFileCompileWasmPlugin({
mangleImports: compiler.options.optimization.mangleWasmImports
}).apply(compiler), new ReadFileCompileAsyncWasmPlugin({
type
}).apply(compiler);
break;
}

case "async-node-module":
new (__webpack_require__(34237))({
type,
import: !0
}).apply(compiler);
break;

case "universal":
throw new Error("Universal WebAssembly Loading is not implemented yet");

default:
throw new Error(`Unsupported wasm loading type ${type}.\nPlugins which provide custom wasm loading types must call EnableWasmLoadingPlugin.setEnabled(compiler, type) to disable this error.`);
}
}
};
},
75679: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), AsyncWasmLoadingRuntimeModule = __webpack_require__(67697);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("FetchCompileAsyncWasmPlugin", (compilation => {
const globalWasmLoading = compilation.outputOptions.wasmLoading, generateLoadBinaryCode = path => `fetch(${RuntimeGlobals.publicPath} + ${path})`;
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.instantiateWasm).tap("FetchCompileAsyncWasmPlugin", ((chunk, set) => {
if (!(chunk => {
const options = chunk.getEntryOptions();
return "fetch" === (options && void 0 !== options.wasmLoading ? options.wasmLoading : globalWasmLoading);
})(chunk)) return;
compilation.chunkGraph.hasModuleInGraph(chunk, (m => "webassembly/async" === m.type)) && (set.add(RuntimeGlobals.publicPath), 
compilation.addRuntimeModule(chunk, new AsyncWasmLoadingRuntimeModule({
generateLoadBinaryCode,
supportsStreaming: !0
})));
}));
}));
}
};
},
17903: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), WasmChunkLoadingRuntimeModule = __webpack_require__(626);
module.exports = class {
constructor(options) {
this.options = options || {};
}
apply(compiler) {
compiler.hooks.thisCompilation.tap("FetchCompileWasmPlugin", (compilation => {
const globalWasmLoading = compilation.outputOptions.wasmLoading, generateLoadBinaryCode = path => `fetch(${RuntimeGlobals.publicPath} + ${path})`;
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("FetchCompileWasmPlugin", ((chunk, set) => {
if (!(chunk => {
const options = chunk.getEntryOptions();
return "fetch" === (options && void 0 !== options.wasmLoading ? options.wasmLoading : globalWasmLoading);
})(chunk)) return;
compilation.chunkGraph.hasModuleInGraph(chunk, (m => "webassembly/sync" === m.type)) && (set.add(RuntimeGlobals.moduleCache), 
set.add(RuntimeGlobals.publicPath), compilation.addRuntimeModule(chunk, new WasmChunkLoadingRuntimeModule({
generateLoadBinaryCode,
supportsStreaming: !0,
mangleImports: this.options.mangleImports,
runtimeRequirements: set
})));
}));
}));
}
};
},
31333: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), JsonpChunkLoadingRuntimeModule = __webpack_require__(68431);
module.exports = class {
apply(compiler) {
compiler.hooks.thisCompilation.tap("JsonpChunkLoadingPlugin", (compilation => {
const globalChunkLoading = compilation.outputOptions.chunkLoading, isEnabledForChunk = chunk => {
const options = chunk.getEntryOptions();
return "jsonp" === (options && void 0 !== options.chunkLoading ? options.chunkLoading : globalChunkLoading);
}, onceForChunkSet = new WeakSet, handler = (chunk, set) => {
onceForChunkSet.has(chunk) || (onceForChunkSet.add(chunk), isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.moduleFactoriesAddOnly), 
set.add(RuntimeGlobals.hasOwnProperty), compilation.addRuntimeModule(chunk, new JsonpChunkLoadingRuntimeModule(set))));
};
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("JsonpChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap("JsonpChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadManifest).tap("JsonpChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.baseURI).tap("JsonpChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.onChunksLoaded).tap("JsonpChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("JsonpChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.loadScript), 
set.add(RuntimeGlobals.getChunkScriptFilename));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap("JsonpChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.loadScript), 
set.add(RuntimeGlobals.getChunkUpdateScriptFilename), set.add(RuntimeGlobals.moduleCache), 
set.add(RuntimeGlobals.hmrModuleData), set.add(RuntimeGlobals.moduleFactoriesAddOnly));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadManifest).tap("JsonpChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.getUpdateManifestFilename));
}));
}));
}
};
},
68431: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {SyncWaterfallHook} = __webpack_require__(89991), Compilation = __webpack_require__(62843), RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), chunkHasJs = __webpack_require__(18362).chunkHasJs, {getInitialChunkIds} = __webpack_require__(19202), compileBooleanMatcher = __webpack_require__(65814), compilationHooksMap = new WeakMap;
class JsonpChunkLoadingRuntimeModule extends RuntimeModule {
static getCompilationHooks(compilation) {
if (!(compilation instanceof Compilation)) throw new TypeError("The 'compilation' argument must be an instance of Compilation");
let hooks = compilationHooksMap.get(compilation);
return void 0 === hooks && (hooks = {
linkPreload: new SyncWaterfallHook([ "source", "chunk" ]),
linkPrefetch: new SyncWaterfallHook([ "source", "chunk" ])
}, compilationHooksMap.set(compilation, hooks)), hooks;
}
constructor(runtimeRequirements) {
super("jsonp chunk loading", RuntimeModule.STAGE_ATTACH), this._runtimeRequirements = runtimeRequirements;
}
_generateBaseUri(chunk) {
const options = chunk.getEntryOptions();
return options && options.baseUri ? `${RuntimeGlobals.baseURI} = ${JSON.stringify(options.baseUri)};` : `${RuntimeGlobals.baseURI} = document.baseURI || self.location.href;`;
}
generate() {
const {chunkGraph, compilation, chunk} = this, {runtimeTemplate, outputOptions: {chunkLoadingGlobal, hotUpdateGlobal, crossOriginLoading, scriptType}} = compilation, globalObject = runtimeTemplate.globalObject, {linkPreload, linkPrefetch} = JsonpChunkLoadingRuntimeModule.getCompilationHooks(compilation), fn = RuntimeGlobals.ensureChunkHandlers, withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI), withLoading = this._runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers), withCallback = this._runtimeRequirements.has(RuntimeGlobals.chunkCallback), withOnChunkLoad = this._runtimeRequirements.has(RuntimeGlobals.onChunksLoaded), withHmr = this._runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), withHmrManifest = this._runtimeRequirements.has(RuntimeGlobals.hmrDownloadManifest), withPrefetch = this._runtimeRequirements.has(RuntimeGlobals.prefetchChunkHandlers), withPreload = this._runtimeRequirements.has(RuntimeGlobals.preloadChunkHandlers), chunkLoadingGlobalExpr = `${globalObject}[${JSON.stringify(chunkLoadingGlobal)}]`, conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs), hasJsMatcher = compileBooleanMatcher(conditionMap), initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_jsonp` : void 0;
return Template.asString([ withBaseURI ? this._generateBaseUri(chunk) : "// no baseURI", "", "// object to store loaded and loading chunks", "// undefined = chunk not loaded, null = chunk preloaded/prefetched", "// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded", `var installedChunks = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{`, Template.indent(Array.from(initialChunkIds, (id => `${JSON.stringify(id)}: 0`)).join(",\n")), "};", "", withLoading ? Template.asString([ `${fn}.j = ${runtimeTemplate.basicFunction("chunkId, promises", !1 !== hasJsMatcher ? Template.indent([ "// JSONP chunk loading for javascript", `var installedChunkData = ${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`, 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent([ "", '// a Promise means "currently loading".', "if(installedChunkData) {", Template.indent([ "promises.push(installedChunkData[2]);" ]), "} else {", Template.indent([ !0 === hasJsMatcher ? "if(true) { // all chunks have JS" : `if(${hasJsMatcher("chunkId")}) {`, Template.indent([ "// setup Promise in chunk cache", `var promise = new Promise(${runtimeTemplate.expressionFunction("installedChunkData = installedChunks[chunkId] = [resolve, reject]", "resolve, reject")});`, "promises.push(installedChunkData[2] = promise);", "", "// start chunk loading", `var url = ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId);`, "// create error before stack unwound to get useful stacktrace later", "var error = new Error();", `var loadingEnded = ${runtimeTemplate.basicFunction("event", [ `if(${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId)) {`, Template.indent([ "installedChunkData = installedChunks[chunkId];", "if(installedChunkData !== 0) installedChunks[chunkId] = undefined;", "if(installedChunkData) {", Template.indent([ "var errorType = event && (event.type === 'load' ? 'missing' : event.type);", "var realSrc = event && event.target && event.target.src;", "error.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';", "error.name = 'ChunkLoadError';", "error.type = errorType;", "error.request = realSrc;", "installedChunkData[1](error);" ]), "}" ]), "}" ])};`, `${RuntimeGlobals.loadScript}(url, loadingEnded, "chunk-" + chunkId, chunkId);` ]), "} else installedChunks[chunkId] = 0;" ]), "}" ]), "}" ]) : Template.indent([ "installedChunks[chunkId] = 0;" ]))};` ]) : "// no chunk on demand loading", "", withPrefetch && !1 !== hasJsMatcher ? `${RuntimeGlobals.prefetchChunkHandlers}.j = ${runtimeTemplate.basicFunction("chunkId", [ `if((!${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${!0 === hasJsMatcher ? "true" : hasJsMatcher("chunkId")}) {`, Template.indent([ "installedChunks[chunkId] = null;", linkPrefetch.call(Template.asString([ "var link = document.createElement('link');", crossOriginLoading ? `link.crossOrigin = ${JSON.stringify(crossOriginLoading)};` : "", `if (${RuntimeGlobals.scriptNonce}) {`, Template.indent(`link.setAttribute("nonce", ${RuntimeGlobals.scriptNonce});`), "}", 'link.rel = "prefetch";', 'link.as = "script";', `link.href = ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId);` ]), chunk), "document.head.appendChild(link);" ]), "}" ])};` : "// no prefetching", "", withPreload && !1 !== hasJsMatcher ? `${RuntimeGlobals.preloadChunkHandlers}.j = ${runtimeTemplate.basicFunction("chunkId", [ `if((!${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${!0 === hasJsMatcher ? "true" : hasJsMatcher("chunkId")}) {`, Template.indent([ "installedChunks[chunkId] = null;", linkPreload.call(Template.asString([ "var link = document.createElement('link');", scriptType ? `link.type = ${JSON.stringify(scriptType)};` : "", "link.charset = 'utf-8';", `if (${RuntimeGlobals.scriptNonce}) {`, Template.indent(`link.setAttribute("nonce", ${RuntimeGlobals.scriptNonce});`), "}", 'link.rel = "preload";', 'link.as = "script";', `link.href = ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId);`, crossOriginLoading ? "use-credentials" === crossOriginLoading ? 'link.crossOrigin = "use-credentials";' : Template.asString([ "if (link.href.indexOf(window.location.origin + '/') !== 0) {", Template.indent(`link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), "}" ]) : "" ]), chunk), "document.head.appendChild(link);" ]), "}" ])};` : "// no preloaded", "", withHmr ? Template.asString([ "var currentUpdatedModulesList;", "var waitingUpdateResolves = {};", "function loadUpdateChunk(chunkId, updatedModulesList) {", Template.indent([ "currentUpdatedModulesList = updatedModulesList;", `return new Promise(${runtimeTemplate.basicFunction("resolve, reject", [ "waitingUpdateResolves[chunkId] = resolve;", "// start update chunk loading", `var url = ${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkUpdateScriptFilename}(chunkId);`, "// create error before stack unwound to get useful stacktrace later", "var error = new Error();", `var loadingEnded = ${runtimeTemplate.basicFunction("event", [ "if(waitingUpdateResolves[chunkId]) {", Template.indent([ "waitingUpdateResolves[chunkId] = undefined", "var errorType = event && (event.type === 'load' ? 'missing' : event.type);", "var realSrc = event && event.target && event.target.src;", "error.message = 'Loading hot update chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';", "error.name = 'ChunkLoadError';", "error.type = errorType;", "error.request = realSrc;", "reject(error);" ]), "}" ])};`, `${RuntimeGlobals.loadScript}(url, loadingEnded);` ])});` ]), "}", "", `${globalObject}[${JSON.stringify(hotUpdateGlobal)}] = ${runtimeTemplate.basicFunction("chunkId, moreModules, runtime", [ "for(var moduleId in moreModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(moreModules, moduleId)) {`, Template.indent([ "currentUpdate[moduleId] = moreModules[moduleId];", "if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);" ]), "}" ]), "}", "if(runtime) currentUpdateRuntime.push(runtime);", "if(waitingUpdateResolves[chunkId]) {", Template.indent([ "waitingUpdateResolves[chunkId]();", "waitingUpdateResolves[chunkId] = undefined;" ]), "}" ])};`, "", Template.getFunctionContent(__webpack_require__(9692)).replace(/\$key\$/g, "jsonp").replace(/\$installedChunks\$/g, "installedChunks").replace(/\$loadUpdateChunk\$/g, "loadUpdateChunk").replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache).replace(/\$moduleFactories\$/g, RuntimeGlobals.moduleFactories).replace(/\$ensureChunkHandlers\$/g, RuntimeGlobals.ensureChunkHandlers).replace(/\$hasOwnProperty\$/g, RuntimeGlobals.hasOwnProperty).replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData).replace(/\$hmrDownloadUpdateHandlers\$/g, RuntimeGlobals.hmrDownloadUpdateHandlers).replace(/\$hmrInvalidateModuleHandlers\$/g, RuntimeGlobals.hmrInvalidateModuleHandlers) ]) : "// no HMR", "", withHmrManifest ? Template.asString([ `${RuntimeGlobals.hmrDownloadManifest} = ${runtimeTemplate.basicFunction("", [ 'if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");', `return fetch(${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getUpdateManifestFilename}()).then(${runtimeTemplate.basicFunction("response", [ "if(response.status === 404) return; // no update available", 'if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);', "return response.json();" ])});` ])};` ]) : "// no HMR manifest", "", withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded}.j = ${runtimeTemplate.returningFunction("installedChunks[chunkId] === 0", "chunkId")};` : "// no on chunks loaded", "", withCallback || withLoading ? Template.asString([ "// install a JSONP callback for chunk loading", `var webpackJsonpCallback = ${runtimeTemplate.basicFunction("parentChunkLoadingFunction, data", [ runtimeTemplate.destructureArray([ "chunkIds", "moreModules", "runtime" ], "data"), '// add "moreModules" to the modules object,', '// then flag all "chunkIds" as loaded and fire callback', "var moduleId, chunkId, i = 0;", `if(chunkIds.some(${runtimeTemplate.returningFunction("installedChunks[id] !== 0", "id")})) {`, Template.indent([ "for(moduleId in moreModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(moreModules, moduleId)) {`, Template.indent(`${RuntimeGlobals.moduleFactories}[moduleId] = moreModules[moduleId];`), "}" ]), "}", "if(runtime) var result = runtime(__webpack_require__);" ]), "}", "if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);", "for(;i < chunkIds.length; i++) {", Template.indent([ "chunkId = chunkIds[i];", `if(${RuntimeGlobals.hasOwnProperty}(installedChunks, chunkId) && installedChunks[chunkId]) {`, Template.indent("installedChunks[chunkId][0]();"), "}", "installedChunks[chunkId] = 0;" ]), "}", withOnChunkLoad ? `return ${RuntimeGlobals.onChunksLoaded}(result);` : "" ])}`, "", `var chunkLoadingGlobal = ${chunkLoadingGlobalExpr} = ${chunkLoadingGlobalExpr} || [];`, "chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));", "chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));" ]) : "// no jsonp function" ]);
}
}
module.exports = JsonpChunkLoadingRuntimeModule;
},
2025: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ArrayPushCallbackChunkFormatPlugin = __webpack_require__(33978), EnableChunkLoadingPlugin = __webpack_require__(64027), JsonpChunkLoadingRuntimeModule = __webpack_require__(68431);
module.exports = class {
static getCompilationHooks(compilation) {
return JsonpChunkLoadingRuntimeModule.getCompilationHooks(compilation);
}
apply(compiler) {
compiler.options.output.chunkLoading = "jsonp", (new ArrayPushCallbackChunkFormatPlugin).apply(compiler), 
new EnableChunkLoadingPlugin("jsonp").apply(compiler);
}
};
},
27142: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const util = __webpack_require__(73837), webpackOptionsSchemaCheck = __webpack_require__(51825), webpackOptionsSchema = __webpack_require__(46312), Compiler = __webpack_require__(88799), MultiCompiler = __webpack_require__(95400), WebpackOptionsApply = __webpack_require__(94890), {applyWebpackOptionsDefaults, applyWebpackOptionsBaseDefaults} = __webpack_require__(73054), {getNormalizedWebpackOptions} = __webpack_require__(70884), NodeEnvironmentPlugin = __webpack_require__(25418), getValidateSchema = __webpack_require__(98216)((() => __webpack_require__(69353))), createCompiler = rawOptions => {
const options = getNormalizedWebpackOptions(rawOptions);
applyWebpackOptionsBaseDefaults(options);
const compiler = new Compiler(options.context, options);
if (new NodeEnvironmentPlugin({
infrastructureLogging: options.infrastructureLogging
}).apply(compiler), Array.isArray(options.plugins)) for (const plugin of options.plugins) "function" == typeof plugin ? plugin.call(compiler, compiler) : plugin.apply(compiler);
return applyWebpackOptionsDefaults(options), compiler.hooks.environment.call(), 
compiler.hooks.afterEnvironment.call(), (new WebpackOptionsApply).process(options, compiler), 
compiler.hooks.initialize.call(), compiler;
};
module.exports = (options, callback) => {
const create = () => {
let compiler;
(options => Array.isArray(options) ? Array.from(options) : [ options ])(options).every(webpackOptionsSchemaCheck) || (getValidateSchema()(webpackOptionsSchema, options), 
util.deprecate((() => {}), "webpack bug: Pre-compiled schema reports error while real schema is happy. This has performance drawbacks.", "DEP_WEBPACK_PRE_COMPILED_SCHEMA_INVALID")());
let watchOptions, watch = !1;
if (Array.isArray(options)) compiler = ((childOptions, options) => {
const compilers = childOptions.map((options => createCompiler(options))), compiler = new MultiCompiler(compilers, options);
for (const childCompiler of compilers) childCompiler.options.dependencies && compiler.setDependencies(childCompiler, childCompiler.options.dependencies);
return compiler;
})(options, options), watch = options.some((options => options.watch)), watchOptions = options.map((options => options.watchOptions || {})); else {
const webpackOptions = options;
compiler = createCompiler(webpackOptions), watch = webpackOptions.watch, watchOptions = webpackOptions.watchOptions || {};
}
return {
compiler,
watch,
watchOptions
};
};
if (!callback) {
const {compiler, watch} = create();
return watch && util.deprecate((() => {}), "A 'callback' argument needs to be provided to the 'webpack(options, callback)' function when the 'watch' option is set. There is no way to handle the 'watch' option without a callback.", "DEP_WEBPACK_WATCH_WITHOUT_CALLBACK")(), 
compiler;
}
try {
const {compiler, watch, watchOptions} = create();
return watch ? compiler.watch(watchOptions, callback) : compiler.run(((err, stats) => {
compiler.close((err2 => {
callback(err || err2, stats);
}));
})), compiler;
} catch (err) {
return process.nextTick((() => callback(err))), null;
}
};
},
80594: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), StartupChunkDependenciesPlugin = __webpack_require__(40394), ImportScriptsChunkLoadingRuntimeModule = __webpack_require__(20996);
module.exports = class {
apply(compiler) {
new StartupChunkDependenciesPlugin({
chunkLoading: "import-scripts",
asyncChunkLoading: !0
}).apply(compiler), compiler.hooks.thisCompilation.tap("ImportScriptsChunkLoadingPlugin", (compilation => {
const globalChunkLoading = compilation.outputOptions.chunkLoading, isEnabledForChunk = chunk => {
const options = chunk.getEntryOptions();
return "import-scripts" === (options && void 0 !== options.chunkLoading ? options.chunkLoading : globalChunkLoading);
}, onceForChunkSet = new WeakSet, handler = (chunk, set) => {
if (onceForChunkSet.has(chunk)) return;
if (onceForChunkSet.add(chunk), !isEnabledForChunk(chunk)) return;
const withCreateScriptUrl = !!compilation.outputOptions.trustedTypes;
set.add(RuntimeGlobals.moduleFactoriesAddOnly), set.add(RuntimeGlobals.hasOwnProperty), 
withCreateScriptUrl && set.add(RuntimeGlobals.createScriptUrl), compilation.addRuntimeModule(chunk, new ImportScriptsChunkLoadingRuntimeModule(set, withCreateScriptUrl));
};
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("ImportScriptsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap("ImportScriptsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadManifest).tap("ImportScriptsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.baseURI).tap("ImportScriptsChunkLoadingPlugin", handler), 
compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap("ImportScriptsChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.getChunkScriptFilename));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap("ImportScriptsChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.getChunkUpdateScriptFilename), 
set.add(RuntimeGlobals.moduleCache), set.add(RuntimeGlobals.hmrModuleData), set.add(RuntimeGlobals.moduleFactoriesAddOnly));
})), compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadManifest).tap("ImportScriptsChunkLoadingPlugin", ((chunk, set) => {
isEnabledForChunk(chunk) && (set.add(RuntimeGlobals.publicPath), set.add(RuntimeGlobals.getUpdateManifestFilename));
}));
}));
}
};
},
20996: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const RuntimeGlobals = __webpack_require__(50980), RuntimeModule = __webpack_require__(30823), Template = __webpack_require__(88370), {getChunkFilenameTemplate, chunkHasJs} = __webpack_require__(18362), {getInitialChunkIds} = __webpack_require__(19202), compileBooleanMatcher = __webpack_require__(65814), {getUndoPath} = __webpack_require__(63264);
module.exports = class extends RuntimeModule {
constructor(runtimeRequirements, withCreateScriptUrl) {
super("importScripts chunk loading", RuntimeModule.STAGE_ATTACH), this.runtimeRequirements = runtimeRequirements, 
this._withCreateScriptUrl = withCreateScriptUrl;
}
_generateBaseUri(chunk) {
const options = chunk.getEntryOptions();
if (options && options.baseUri) return `${RuntimeGlobals.baseURI} = ${JSON.stringify(options.baseUri)};`;
const outputName = this.compilation.getPath(getChunkFilenameTemplate(chunk, this.compilation.outputOptions), {
chunk,
contentHashType: "javascript"
}), rootOutputDir = getUndoPath(outputName, this.compilation.outputOptions.path, !1);
return `${RuntimeGlobals.baseURI} = self.location + ${JSON.stringify(rootOutputDir ? "/../" + rootOutputDir : "")};`;
}
generate() {
const {chunk, chunkGraph, compilation: {runtimeTemplate, outputOptions: {chunkLoadingGlobal, hotUpdateGlobal}}, _withCreateScriptUrl: withCreateScriptUrl} = this, globalObject = runtimeTemplate.globalObject, fn = RuntimeGlobals.ensureChunkHandlers, withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI), withLoading = this.runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers), withHmr = this.runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers), withHmrManifest = this.runtimeRequirements.has(RuntimeGlobals.hmrDownloadManifest), chunkLoadingGlobalExpr = `${globalObject}[${JSON.stringify(chunkLoadingGlobal)}]`, hasJsMatcher = compileBooleanMatcher(chunkGraph.getChunkConditionMap(chunk, chunkHasJs)), initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs), stateExpression = withHmr ? `${RuntimeGlobals.hmrRuntimeStatePrefix}_importScripts` : void 0;
return Template.asString([ withBaseURI ? this._generateBaseUri(chunk) : "// no baseURI", "", "// object to store loaded chunks", '// "1" means "already loaded"', `var installedChunks = ${stateExpression ? `${stateExpression} = ${stateExpression} || ` : ""}{`, Template.indent(Array.from(initialChunkIds, (id => `${JSON.stringify(id)}: 1`)).join(",\n")), "};", "", withLoading ? Template.asString([ "// importScripts chunk loading", `var installChunk = ${runtimeTemplate.basicFunction("data", [ runtimeTemplate.destructureArray([ "chunkIds", "moreModules", "runtime" ], "data"), "for(var moduleId in moreModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(moreModules, moduleId)) {`, Template.indent(`${RuntimeGlobals.moduleFactories}[moduleId] = moreModules[moduleId];`), "}" ]), "}", "if(runtime) runtime(__webpack_require__);", "while(chunkIds.length)", Template.indent("installedChunks[chunkIds.pop()] = 1;"), "parentChunkLoadingFunction(data);" ])};` ]) : "// no chunk install function needed", withLoading ? Template.asString([ `${fn}.i = ${runtimeTemplate.basicFunction("chunkId, promises", !1 !== hasJsMatcher ? [ '// "1" is the signal for "already loaded"', "if(!installedChunks[chunkId]) {", Template.indent([ !0 === hasJsMatcher ? "if(true) { // all chunks have JS" : `if(${hasJsMatcher("chunkId")}) {`, Template.indent(`importScripts(${withCreateScriptUrl ? `${RuntimeGlobals.createScriptUrl}(${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId))` : `${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkScriptFilename}(chunkId)`});`), "}" ]), "}" ] : "installedChunks[chunkId] = 1;")};`, "", `var chunkLoadingGlobal = ${chunkLoadingGlobalExpr} = ${chunkLoadingGlobalExpr} || [];`, "var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);", "chunkLoadingGlobal.push = installChunk;" ]) : "// no chunk loading", "", withHmr ? Template.asString([ "function loadUpdateChunk(chunkId, updatedModulesList) {", Template.indent([ "var success = false;", `${globalObject}[${JSON.stringify(hotUpdateGlobal)}] = ${runtimeTemplate.basicFunction("_, moreModules, runtime", [ "for(var moduleId in moreModules) {", Template.indent([ `if(${RuntimeGlobals.hasOwnProperty}(moreModules, moduleId)) {`, Template.indent([ "currentUpdate[moduleId] = moreModules[moduleId];", "if(updatedModulesList) updatedModulesList.push(moduleId);" ]), "}" ]), "}", "if(runtime) currentUpdateRuntime.push(runtime);", "success = true;" ])};`, "// start update chunk loading", `importScripts(${withCreateScriptUrl ? `${RuntimeGlobals.createScriptUrl}(${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkUpdateScriptFilename}(chunkId))` : `${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getChunkUpdateScriptFilename}(chunkId)`});`, 'if(!success) throw new Error("Loading update chunk failed for unknown reason");' ]), "}", "", Template.getFunctionContent(__webpack_require__(9692)).replace(/\$key\$/g, "importScrips").replace(/\$installedChunks\$/g, "installedChunks").replace(/\$loadUpdateChunk\$/g, "loadUpdateChunk").replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache).replace(/\$moduleFactories\$/g, RuntimeGlobals.moduleFactories).replace(/\$ensureChunkHandlers\$/g, RuntimeGlobals.ensureChunkHandlers).replace(/\$hasOwnProperty\$/g, RuntimeGlobals.hasOwnProperty).replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData).replace(/\$hmrDownloadUpdateHandlers\$/g, RuntimeGlobals.hmrDownloadUpdateHandlers).replace(/\$hmrInvalidateModuleHandlers\$/g, RuntimeGlobals.hmrInvalidateModuleHandlers) ]) : "// no HMR", "", withHmrManifest ? Template.asString([ `${RuntimeGlobals.hmrDownloadManifest} = ${runtimeTemplate.basicFunction("", [ 'if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");', `return fetch(${RuntimeGlobals.publicPath} + ${RuntimeGlobals.getUpdateManifestFilename}()).then(${runtimeTemplate.basicFunction("response", [ "if(response.status === 404) return; // no update available", 'if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);', "return response.json();" ])});` ])};` ]) : "// no HMR manifest" ]);
}
};
},
87263: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const ArrayPushCallbackChunkFormatPlugin = __webpack_require__(33978), EnableChunkLoadingPlugin = __webpack_require__(64027);
module.exports = class {
apply(compiler) {
compiler.options.output.chunkLoading = "import-scripts", (new ArrayPushCallbackChunkFormatPlugin).apply(compiler), 
new EnableChunkLoadingPlugin("import-scripts").apply(compiler);
}
};
},
51825: module => {
const e = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
module.exports = we, module.exports.default = we;
const t = {
amd: {
$ref: "#/definitions/Amd"
},
bail: {
$ref: "#/definitions/Bail"
},
cache: {
$ref: "#/definitions/CacheOptions"
},
context: {
$ref: "#/definitions/Context"
},
dependencies: {
$ref: "#/definitions/Dependencies"
},
devServer: {
$ref: "#/definitions/DevServer"
},
devtool: {
$ref: "#/definitions/DevTool"
},
entry: {
$ref: "#/definitions/Entry"
},
experiments: {
$ref: "#/definitions/Experiments"
},
externals: {
$ref: "#/definitions/Externals"
},
externalsPresets: {
$ref: "#/definitions/ExternalsPresets"
},
externalsType: {
$ref: "#/definitions/ExternalsType"
},
ignoreWarnings: {
$ref: "#/definitions/IgnoreWarnings"
},
infrastructureLogging: {
$ref: "#/definitions/InfrastructureLogging"
},
loader: {
$ref: "#/definitions/Loader"
},
mode: {
$ref: "#/definitions/Mode"
},
module: {
$ref: "#/definitions/ModuleOptions"
},
name: {
$ref: "#/definitions/Name"
},
node: {
$ref: "#/definitions/Node"
},
optimization: {
$ref: "#/definitions/Optimization"
},
output: {
$ref: "#/definitions/Output"
},
parallelism: {
$ref: "#/definitions/Parallelism"
},
performance: {
$ref: "#/definitions/Performance"
},
plugins: {
$ref: "#/definitions/Plugins"
},
profile: {
$ref: "#/definitions/Profile"
},
recordsInputPath: {
$ref: "#/definitions/RecordsInputPath"
},
recordsOutputPath: {
$ref: "#/definitions/RecordsOutputPath"
},
recordsPath: {
$ref: "#/definitions/RecordsPath"
},
resolve: {
$ref: "#/definitions/Resolve"
},
resolveLoader: {
$ref: "#/definitions/ResolveLoader"
},
snapshot: {
$ref: "#/definitions/SnapshotOptions"
},
stats: {
$ref: "#/definitions/StatsValue"
},
target: {
$ref: "#/definitions/Target"
},
watch: {
$ref: "#/definitions/Watch"
},
watchOptions: {
$ref: "#/definitions/WatchOptions"
}
}, n = Object.prototype.hasOwnProperty, r = {
allowCollectingMemory: {
type: "boolean"
},
buildDependencies: {
type: "object",
additionalProperties: {
type: "array",
items: {
type: "string",
minLength: 1
}
}
},
cacheDirectory: {
type: "string",
absolutePath: !0
},
cacheLocation: {
type: "string",
absolutePath: !0
},
compression: {
enum: [ !1, "gzip", "brotli" ]
},
hashAlgorithm: {
type: "string"
},
idleTimeout: {
type: "number",
minimum: 0
},
idleTimeoutAfterLargeChanges: {
type: "number",
minimum: 0
},
idleTimeoutForInitialStore: {
type: "number",
minimum: 0
},
immutablePaths: {
type: "array",
items: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string",
absolutePath: !0,
minLength: 1
} ]
}
},
managedPaths: {
type: "array",
items: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string",
absolutePath: !0,
minLength: 1
} ]
}
},
maxAge: {
type: "number",
minimum: 0
},
maxMemoryGenerations: {
type: "number",
minimum: 0
},
memoryCacheUnaffected: {
type: "boolean"
},
name: {
type: "string"
},
profile: {
type: "boolean"
},
store: {
enum: [ "pack" ]
},
type: {
enum: [ "filesystem" ]
},
version: {
type: "string"
}
};
function s(t, {instancePath: o = "", parentData: a, parentDataProperty: i, rootData: l = t} = {}) {
let p = null, u = 0;
const f = u;
let c = !1;
const m = u;
if (!1 !== t) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var y = m === u;
if (c = c || y, !c) {
const s = u;
if (u == u) if (t && "object" == typeof t && !Array.isArray(t)) {
let e;
if (void 0 === t.type && (e = "type")) {
const t = {
params: {
missingProperty: e
}
};
null === p ? p = [ t ] : p.push(t), u++;
} else {
const e = u;
for (const e in t) if ("cacheUnaffected" !== e && "maxGenerations" !== e && "type" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === p ? p = [ t ] : p.push(t), u++;
break;
}
if (e === u) {
if (void 0 !== t.cacheUnaffected) {
const e = u;
if ("boolean" != typeof t.cacheUnaffected) {
const e = {
params: {
type: "boolean"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var h = e === u;
} else h = !0;
if (h) {
if (void 0 !== t.maxGenerations) {
let e = t.maxGenerations;
const n = u;
if (u === n) if ("number" == typeof e) {
if (e < 1 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 1
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
h = n === u;
} else h = !0;
if (h) if (void 0 !== t.type) {
const e = u;
if ("memory" !== t.type) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
h = e === u;
} else h = !0;
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (y = s === u, c = c || y, !c) {
const s = u;
if (u == u) if (t && "object" == typeof t && !Array.isArray(t)) {
let s;
if (void 0 === t.type && (s = "type")) {
const e = {
params: {
missingProperty: s
}
};
null === p ? p = [ e ] : p.push(e), u++;
} else {
const s = u;
for (const e in t) if (!n.call(r, e)) {
const t = {
params: {
additionalProperty: e
}
};
null === p ? p = [ t ] : p.push(t), u++;
break;
}
if (s === u) {
if (void 0 !== t.allowCollectingMemory) {
const e = u;
if ("boolean" != typeof t.allowCollectingMemory) {
const e = {
params: {
type: "boolean"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.buildDependencies) {
let e = t.buildDependencies;
const n = u;
if (u === n) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
let n = e[t];
const r = u;
if (u === r) if (Array.isArray(n)) {
const e = n.length;
for (let t = 0; t < e; t++) {
let e = n[t];
const r = u;
if (u === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (r !== u) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (r !== u) break;
} else {
const e = {
params: {
type: "object"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.cacheDirectory) {
let n = t.cacheDirectory;
const r = u;
if (u === r) if ("string" == typeof n) {
if (n.includes("!") || !0 !== e.test(n)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = r === u;
} else d = !0;
if (d) {
if (void 0 !== t.cacheLocation) {
let n = t.cacheLocation;
const r = u;
if (u === r) if ("string" == typeof n) {
if (n.includes("!") || !0 !== e.test(n)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = r === u;
} else d = !0;
if (d) {
if (void 0 !== t.compression) {
let e = t.compression;
const n = u;
if (!1 !== e && "gzip" !== e && "brotli" !== e) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.hashAlgorithm) {
const e = u;
if ("string" != typeof t.hashAlgorithm) {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.idleTimeout) {
let e = t.idleTimeout;
const n = u;
if (u === n) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.idleTimeoutAfterLargeChanges) {
let e = t.idleTimeoutAfterLargeChanges;
const n = u;
if (u === n) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.idleTimeoutForInitialStore) {
let e = t.idleTimeoutForInitialStore;
const n = u;
if (u === n) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.immutablePaths) {
let n = t.immutablePaths;
const r = u;
if (u === r) if (Array.isArray(n)) {
const t = n.length;
for (let r = 0; r < t; r++) {
let t = n[r];
const s = u, o = u;
let a = !1;
const i = u;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var g = i === u;
if (a = a || g, !a) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
g = n === u, a = a || g;
}
if (a) u = o, null !== p && (o ? p.length = o : p = null); else {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (s !== u) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = r === u;
} else d = !0;
if (d) {
if (void 0 !== t.managedPaths) {
let n = t.managedPaths;
const r = u;
if (u === r) if (Array.isArray(n)) {
const t = n.length;
for (let r = 0; r < t; r++) {
let t = n[r];
const s = u, o = u;
let a = !1;
const i = u;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var b = i === u;
if (a = a || b, !a) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
b = n === u, a = a || b;
}
if (a) u = o, null !== p && (o ? p.length = o : p = null); else {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (s !== u) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = r === u;
} else d = !0;
if (d) {
if (void 0 !== t.maxAge) {
let e = t.maxAge;
const n = u;
if (u === n) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.maxMemoryGenerations) {
let e = t.maxMemoryGenerations;
const n = u;
if (u === n) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = n === u;
} else d = !0;
if (d) {
if (void 0 !== t.memoryCacheUnaffected) {
const e = u;
if ("boolean" != typeof t.memoryCacheUnaffected) {
const e = {
params: {
type: "boolean"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.name) {
const e = u;
if ("string" != typeof t.name) {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.profile) {
const e = u;
if ("boolean" != typeof t.profile) {
const e = {
params: {
type: "boolean"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.store) {
const e = u;
if ("pack" !== t.store) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.type) {
const e = u;
if ("filesystem" !== t.type) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) if (void 0 !== t.version) {
const e = u;
if ("string" != typeof t.version) {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
y = s === u, c = c || y;
}
}
if (!c) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, s.errors = p, !1;
}
return u = f, null !== p && (f ? p.length = f : p = null), s.errors = p, 0 === u;
}
function o(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: a = e} = {}) {
let i = null, l = 0;
const p = l;
let u = !1;
const f = l;
if (!0 !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var c = f === l;
if (u = u || c, !u) {
const o = l;
s(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: a
}) || (i = null === i ? s.errors : i.concat(s.errors), l = i.length), c = o === l, 
u = u || c;
}
if (!u) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, o.errors = i, !1;
}
return l = p, null !== i && (p ? i.length = p : i = null), o.errors = i, 0 === l;
}
const a = {
asyncChunks: {
type: "boolean"
},
baseUri: {
type: "string"
},
chunkLoading: {
$ref: "#/definitions/ChunkLoading"
},
dependOn: {
anyOf: [ {
type: "array",
items: {
type: "string",
minLength: 1
},
minItems: 1,
uniqueItems: !0
}, {
type: "string",
minLength: 1
} ]
},
filename: {
$ref: "#/definitions/EntryFilename"
},
import: {
$ref: "#/definitions/EntryItem"
},
layer: {
$ref: "#/definitions/Layer"
},
library: {
$ref: "#/definitions/LibraryOptions"
},
publicPath: {
$ref: "#/definitions/PublicPath"
},
runtime: {
$ref: "#/definitions/EntryRuntime"
},
wasmLoading: {
$ref: "#/definitions/WasmLoading"
}
};
function i(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const l = a;
let p = !1;
const u = a;
if (!1 !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = u === a;
if (p = p || f, !p) {
const t = a, n = a;
let r = !1;
const s = a;
if ("jsonp" !== e && "import-scripts" !== e && "require" !== e && "async-node" !== e && "import" !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = s === a;
if (r = r || c, !r) {
const t = a;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = t === a, r = r || c;
}
if (r) a = n, null !== o && (n ? o.length = n : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, p = p || f;
}
if (!p) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, i.errors = o, !1;
}
return a = l, null !== o && (l ? o.length = l : o = null), i.errors = o, 0 === a;
}
function l(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const p = i;
let u = !1, f = null;
const c = i, m = i;
let y = !1;
const h = i;
if (i === h) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var d = h === i;
if (y = y || d, !y) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
d = e === i, y = y || d;
}
if (y) i = m, null !== a && (m ? a.length = m : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (c === i && (u = !0, f = 0), !u) {
const e = {
params: {
passingSchemas: f
}
};
return null === a ? a = [ e ] : a.push(e), i++, l.errors = a, !1;
}
return i = p, null !== a && (p ? a.length = p : a = null), l.errors = a, 0 === i;
}
function p(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const u = a;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = u === a;
if (l = l || f, !l) {
const t = a;
if (a == a) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = a;
for (const t in e) if ("amd" !== t && "commonjs" !== t && "commonjs2" !== t && "root" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
if (t === a) {
if (void 0 !== e.amd) {
const t = a;
if ("string" != typeof e.amd) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = t === a;
} else c = !0;
if (c) {
if (void 0 !== e.commonjs) {
const t = a;
if ("string" != typeof e.commonjs) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = t === a;
} else c = !0;
if (c) {
if (void 0 !== e.commonjs2) {
const t = a;
if ("string" != typeof e.commonjs2) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = t === a;
} else c = !0;
if (c) if (void 0 !== e.root) {
const t = a;
if ("string" != typeof e.root) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = t === a;
} else c = !0;
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, l = l || f;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, p.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), p.errors = o, 0 === a;
}
function u(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (a === p) if (Array.isArray(e)) if (e.length < 1) {
const e = {
params: {
limit: 1
}
};
null === o ? o = [ e ] : o.push(e), a++;
} else {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a;
if (a === r) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = p === a;
if (l = l || f, !l) {
const t = a;
if (a === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (f = t === a, l = l || f, !l) {
const t = a;
if (a == a) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = a;
for (const t in e) if ("amd" !== t && "commonjs" !== t && "root" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
if (t === a) {
if (void 0 !== e.amd) {
let t = e.amd;
const n = a;
if (a === n) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = n === a;
} else c = !0;
if (c) {
if (void 0 !== e.commonjs) {
let t = e.commonjs;
const n = a;
if (a === n) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = n === a;
} else c = !0;
if (c) if (void 0 !== e.root) {
let t = e.root;
const n = a, r = a;
let s = !1;
const i = a;
if (a === i) if (Array.isArray(t)) {
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = a;
if (a === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var m = i === a;
if (s = s || m, !s) {
const e = a;
if (a === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
m = e === a, s = s || m;
}
if (s) a = r, null !== o && (r ? o.length = r : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = n === a;
} else c = !0;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, l = l || f;
}
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, u.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), u.errors = o, 0 === a;
}
function f(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return f.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let n;
if (void 0 === e.type && (n = "type")) return f.errors = [ {
params: {
missingProperty: n
}
} ], !1;
{
const n = a;
for (const t in e) if ("auxiliaryComment" !== t && "export" !== t && "name" !== t && "type" !== t && "umdNamedDefine" !== t) return f.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (n === a) {
if (void 0 !== e.auxiliaryComment) {
const n = a;
p(e.auxiliaryComment, {
instancePath: t + "/auxiliaryComment",
parentData: e,
parentDataProperty: "auxiliaryComment",
rootData: s
}) || (o = null === o ? p.errors : o.concat(p.errors), a = o.length);
var i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.export) {
let t = e.export;
const n = a, r = a;
let s = !1;
const p = a;
if (a === p) if (Array.isArray(t)) {
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = a;
if (a === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var l = p === a;
if (s = s || l, !s) {
const e = a;
if (a === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
l = e === a, s = s || l;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, f.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.name) {
const n = a;
u(e.name, {
instancePath: t + "/name",
parentData: e,
parentDataProperty: "name",
rootData: s
}) || (o = null === o ? u.errors : o.concat(u.errors), a = o.length), i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.type) {
let t = e.type;
const n = a, r = a;
let s = !1;
const l = a;
if ("var" !== t && "module" !== t && "assign" !== t && "assign-properties" !== t && "this" !== t && "window" !== t && "self" !== t && "global" !== t && "commonjs" !== t && "commonjs2" !== t && "commonjs-module" !== t && "commonjs-static" !== t && "amd" !== t && "amd-require" !== t && "umd" !== t && "umd2" !== t && "jsonp" !== t && "system" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = l === a;
if (s = s || c, !s) {
const e = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = e === a, s = s || c;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, f.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), i = n === a;
} else i = !0;
if (i) if (void 0 !== e.umdNamedDefine) {
const t = a;
if ("boolean" != typeof e.umdNamedDefine) return f.errors = [ {
params: {
type: "boolean"
}
} ], !1;
i = t === a;
} else i = !0;
}
}
}
}
}
}
}
return f.errors = o, 0 === a;
}
function c(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if ("auto" !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const t = a, n = a;
let r = !1;
const s = a;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = s === a;
if (r = r || f, !r) {
const t = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, r = r || f;
}
if (r) a = n, null !== o && (n ? o.length = n : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a, l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, c.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), c.errors = o, 0 === a;
}
function m(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (!1 !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const t = a, n = a;
let r = !1;
const s = a;
if ("fetch-streaming" !== e && "fetch" !== e && "async-node" !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = s === a;
if (r = r || f, !r) {
const t = a;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, r = r || f;
}
if (r) a = n, null !== o && (n ? o.length = n : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a, l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, m.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), m.errors = o, 0 === a;
}
function y(e, {instancePath: t = "", parentData: r, parentDataProperty: s, rootData: o = e} = {}) {
let p = null, u = 0;
if (0 === u) {
if (!e || "object" != typeof e || Array.isArray(e)) return y.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let r;
if (void 0 === e.import && (r = "import")) return y.errors = [ {
params: {
missingProperty: r
}
} ], !1;
{
const r = u;
for (const t in e) if (!n.call(a, t)) return y.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (r === u) {
if (void 0 !== e.asyncChunks) {
const t = u;
if ("boolean" != typeof e.asyncChunks) return y.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var h = t === u;
} else h = !0;
if (h) {
if (void 0 !== e.baseUri) {
const t = u;
if ("string" != typeof e.baseUri) return y.errors = [ {
params: {
type: "string"
}
} ], !1;
h = t === u;
} else h = !0;
if (h) {
if (void 0 !== e.chunkLoading) {
const n = u;
i(e.chunkLoading, {
instancePath: t + "/chunkLoading",
parentData: e,
parentDataProperty: "chunkLoading",
rootData: o
}) || (p = null === p ? i.errors : p.concat(i.errors), u = p.length), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.dependOn) {
let t = e.dependOn;
const n = u, r = u;
let s = !1;
const o = u;
if (u === o) if (Array.isArray(t)) if (t.length < 1) {
const e = {
params: {
limit: 1
}
};
null === p ? p = [ e ] : p.push(e), u++;
} else {
var d = !0;
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = u;
if (u === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (!(d = r === u)) break;
}
if (d) {
let e, n = t.length;
if (n > 1) {
const r = {};
for (;n--; ) {
let s = t[n];
if ("string" == typeof s) {
if ("number" == typeof r[s]) {
e = r[s];
const t = {
params: {
i: n,
j: e
}
};
null === p ? p = [ t ] : p.push(t), u++;
break;
}
r[s] = n;
}
}
}
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var g = o === u;
if (s = s || g, !s) {
const e = u;
if (u === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
g = e === u, s = s || g;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, y.errors = p, !1;
}
u = r, null !== p && (r ? p.length = r : p = null), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.filename) {
const n = u;
l(e.filename, {
instancePath: t + "/filename",
parentData: e,
parentDataProperty: "filename",
rootData: o
}) || (p = null === p ? l.errors : p.concat(l.errors), u = p.length), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.import) {
let t = e.import;
const n = u, r = u;
let s = !1;
const o = u;
if (u === o) if (Array.isArray(t)) if (t.length < 1) {
const e = {
params: {
limit: 1
}
};
null === p ? p = [ e ] : p.push(e), u++;
} else {
var b = !0;
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = u;
if (u === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (!(b = r === u)) break;
}
if (b) {
let e, n = t.length;
if (n > 1) {
const r = {};
for (;n--; ) {
let s = t[n];
if ("string" == typeof s) {
if ("number" == typeof r[s]) {
e = r[s];
const t = {
params: {
i: n,
j: e
}
};
null === p ? p = [ t ] : p.push(t), u++;
break;
}
r[s] = n;
}
}
}
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var v = o === u;
if (s = s || v, !s) {
const e = u;
if (u === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
v = e === u, s = s || v;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, y.errors = p, !1;
}
u = r, null !== p && (r ? p.length = r : p = null), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.layer) {
let t = e.layer;
const n = u, r = u;
let s = !1;
const o = u;
if (null !== t) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var D = o === u;
if (s = s || D, !s) {
const e = u;
if (u === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
D = e === u, s = s || D;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, y.errors = p, !1;
}
u = r, null !== p && (r ? p.length = r : p = null), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.library) {
const n = u;
f(e.library, {
instancePath: t + "/library",
parentData: e,
parentDataProperty: "library",
rootData: o
}) || (p = null === p ? f.errors : p.concat(f.errors), u = p.length), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.publicPath) {
const n = u;
c(e.publicPath, {
instancePath: t + "/publicPath",
parentData: e,
parentDataProperty: "publicPath",
rootData: o
}) || (p = null === p ? c.errors : p.concat(c.errors), u = p.length), h = n === u;
} else h = !0;
if (h) {
if (void 0 !== e.runtime) {
let t = e.runtime;
const n = u, r = u;
let s = !1;
const o = u;
if (!1 !== t) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var P = o === u;
if (s = s || P, !s) {
const e = u;
if (u === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
P = e === u, s = s || P;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, y.errors = p, !1;
}
u = r, null !== p && (r ? p.length = r : p = null), h = n === u;
} else h = !0;
if (h) if (void 0 !== e.wasmLoading) {
const n = u;
m(e.wasmLoading, {
instancePath: t + "/wasmLoading",
parentData: e,
parentDataProperty: "wasmLoading",
rootData: o
}) || (p = null === p ? m.errors : p.concat(m.errors), u = p.length), h = n === u;
} else h = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
return y.errors = p, 0 === u;
}
function h(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return h.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const n in e) {
let r = e[n];
const u = a, f = a;
let c = !1;
const m = a, d = a;
let g = !1;
const b = a;
if (a === b) if (Array.isArray(r)) if (r.length < 1) {
const e = {
params: {
limit: 1
}
};
null === o ? o = [ e ] : o.push(e), a++;
} else {
var i = !0;
const e = r.length;
for (let t = 0; t < e; t++) {
let e = r[t];
const n = a;
if (a === n) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (!(i = n === a)) break;
}
if (i) {
let e, t = r.length;
if (t > 1) {
const n = {};
for (;t--; ) {
let s = r[t];
if ("string" == typeof s) {
if ("number" == typeof n[s]) {
e = n[s];
const r = {
params: {
i: t,
j: e
}
};
null === o ? o = [ r ] : o.push(r), a++;
break;
}
n[s] = t;
}
}
}
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var l = b === a;
if (g = g || l, !g) {
const e = a;
if (a === e) if ("string" == typeof r) {
if (r.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
l = e === a, g = g || l;
}
if (g) a = d, null !== o && (d ? o.length = d : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var p = m === a;
if (c = c || p, !c) {
const i = a;
y(r, {
instancePath: t + "/" + n.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: e,
parentDataProperty: n,
rootData: s
}) || (o = null === o ? y.errors : o.concat(y.errors), a = o.length), p = i === a, 
c = c || p;
}
if (!c) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, h.errors = o, !1;
}
if (a = f, null !== o && (f ? o.length = f : o = null), u !== a) break;
}
}
return h.errors = o, 0 === a;
}
function d(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1, p = null;
const u = a, f = a;
let c = !1;
const m = a;
if (a === m) if (Array.isArray(e)) if (e.length < 1) {
const e = {
params: {
limit: 1
}
};
null === o ? o = [ e ] : o.push(e), a++;
} else {
var y = !0;
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a;
if (a === r) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (!(y = r === a)) break;
}
if (y) {
let t, n = e.length;
if (n > 1) {
const r = {};
for (;n--; ) {
let s = e[n];
if ("string" == typeof s) {
if ("number" == typeof r[s]) {
t = r[s];
const e = {
params: {
i: n,
j: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
r[s] = n;
}
}
}
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var h = m === a;
if (c = c || h, !c) {
const t = a;
if (a === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
h = t === a, c = c || h;
}
if (c) a = f, null !== o && (f ? o.length = f : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u === a && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, d.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), d.errors = o, 0 === a;
}
function g(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
h(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? h.errors : o.concat(h.errors), a = o.length);
var u = p === a;
if (l = l || u, !l) {
const i = a;
d(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? d.errors : o.concat(d.errors), a = o.length), u = i === a, 
l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, g.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), g.errors = o, 0 === a;
}
function b(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const i = a;
g(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? g.errors : o.concat(g.errors), a = o.length), u = i === a, 
l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, b.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), b.errors = o, 0 === a;
}
const v = {
asyncWebAssembly: {
type: "boolean"
},
backCompat: {
type: "boolean"
},
buildHttp: {
anyOf: [ {
$ref: "#/definitions/HttpUriAllowedUris"
}, {
$ref: "#/definitions/HttpUriOptions"
} ]
},
cacheUnaffected: {
type: "boolean"
},
css: {
anyOf: [ {
type: "boolean"
}, {
$ref: "#/definitions/CssExperimentOptions"
} ]
},
futureDefaults: {
type: "boolean"
},
layers: {
type: "boolean"
},
lazyCompilation: {
anyOf: [ {
type: "boolean"
}, {
$ref: "#/definitions/LazyCompilationOptions"
} ]
},
outputModule: {
type: "boolean"
},
syncWebAssembly: {
type: "boolean"
},
topLevelAwait: {
type: "boolean"
}
}, D = new RegExp("^https?://", "u");
function P(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1, p = null;
const u = a;
if (a == a) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a, s = a;
let i = !1;
const l = a;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = l === a;
if (i = i || f, !i) {
const e = a;
if (a === e) if ("string" == typeof t) {
if (!D.test(t)) {
const e = {
params: {
pattern: "^https?://"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (f = e === a, i = i || f, !i) {
const e = a;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = e === a, i = i || f;
}
}
if (i) a = s, null !== o && (s ? o.length = s : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u === a && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, P.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), P.errors = o, 0 === a;
}
function A(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
if (0 === i) {
if (!t || "object" != typeof t || Array.isArray(t)) return A.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let n;
if (void 0 === t.allowedUris && (n = "allowedUris")) return A.errors = [ {
params: {
missingProperty: n
}
} ], !1;
{
const n = i;
for (const e in t) if ("allowedUris" !== e && "cacheLocation" !== e && "frozen" !== e && "lockfileLocation" !== e && "proxy" !== e && "upgrade" !== e) return A.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (n === i) {
if (void 0 !== t.allowedUris) {
let e = t.allowedUris;
const n = i;
if (i == i) {
if (!Array.isArray(e)) return A.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = i, s = i;
let o = !1;
const p = i;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var l = p === i;
if (o = o || l, !o) {
const e = i;
if (i === e) if ("string" == typeof t) {
if (!D.test(t)) {
const e = {
params: {
pattern: "^https?://"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (l = e === i, o = o || l, !o) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
l = e === i, o = o || l;
}
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, A.errors = a, !1;
}
if (i = s, null !== a && (s ? a.length = s : a = null), r !== i) break;
}
}
}
var p = n === i;
} else p = !0;
if (p) {
if (void 0 !== t.cacheLocation) {
let n = t.cacheLocation;
const r = i, s = i;
let o = !1;
const l = i;
if (!1 !== n) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var u = l === i;
if (o = o || u, !o) {
const t = i;
if (i === t) if ("string" == typeof n) {
if (n.includes("!") || !0 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
u = t === i, o = o || u;
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, A.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), p = r === i;
} else p = !0;
if (p) {
if (void 0 !== t.frozen) {
const e = i;
if ("boolean" != typeof t.frozen) return A.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === i;
} else p = !0;
if (p) {
if (void 0 !== t.lockfileLocation) {
let n = t.lockfileLocation;
const r = i;
if (i === r) {
if ("string" != typeof n) return A.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !0 !== e.test(n)) return A.errors = [ {
params: {}
} ], !1;
}
p = r === i;
} else p = !0;
if (p) {
if (void 0 !== t.proxy) {
const e = i;
if ("string" != typeof t.proxy) return A.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === i;
} else p = !0;
if (p) if (void 0 !== t.upgrade) {
const e = i;
if ("boolean" != typeof t.upgrade) return A.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === i;
} else p = !0;
}
}
}
}
}
}
}
}
return A.errors = a, 0 === i;
}
function x(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return x.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = a;
for (const t in e) if ("backend" !== t && "entries" !== t && "imports" !== t && "test" !== t) return x.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === a) {
if (void 0 !== e.backend) {
let t = e.backend;
const n = a, r = a;
let s = !1;
const m = a;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = m === a;
if (s = s || i, !s) {
const e = a;
if (a == a) if (t && "object" == typeof t && !Array.isArray(t)) {
const e = a;
for (const e in t) if ("client" !== e && "listen" !== e && "protocol" !== e && "server" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === o ? o = [ t ] : o.push(t), a++;
break;
}
if (e === a) {
if (void 0 !== t.client) {
const e = a;
if ("string" != typeof t.client) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var l = e === a;
} else l = !0;
if (l) {
if (void 0 !== t.listen) {
let e = t.listen;
const n = a, r = a;
let s = !1;
const i = a;
if ("number" != typeof e) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var p = i === a;
if (s = s || p, !s) {
const t = a;
if (a === t) if (e && "object" == typeof e && !Array.isArray(e)) {
if (void 0 !== e.host) {
const t = a;
if ("string" != typeof e.host) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = t === a;
} else u = !0;
if (u) if (void 0 !== e.port) {
const t = a;
if ("number" != typeof e.port) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a;
} else u = !0;
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (p = t === a, s = s || p, !s) {
const t = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
p = t === a, s = s || p;
}
}
if (s) a = r, null !== o && (r ? o.length = r : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
l = n === a;
} else l = !0;
if (l) {
if (void 0 !== t.protocol) {
let e = t.protocol;
const n = a;
if ("http" !== e && "https" !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
l = n === a;
} else l = !0;
if (l) if (void 0 !== t.server) {
let e = t.server;
const n = a, r = a;
let s = !1;
const i = a;
if (a === i) if (e && "object" == typeof e && !Array.isArray(e)) ; else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = i === a;
if (s = s || f, !s) {
const t = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, s = s || f;
}
if (s) a = r, null !== o && (r ? o.length = r : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
l = n === a;
} else l = !0;
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, s = s || i;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, x.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null);
var c = n === a;
} else c = !0;
if (c) {
if (void 0 !== e.entries) {
const t = a;
if ("boolean" != typeof e.entries) return x.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = t === a;
} else c = !0;
if (c) {
if (void 0 !== e.imports) {
const t = a;
if ("boolean" != typeof e.imports) return x.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = t === a;
} else c = !0;
if (c) if (void 0 !== e.test) {
let t = e.test;
const n = a, r = a;
let s = !1;
const i = a;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var m = i === a;
if (s = s || m, !s) {
const e = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (m = e === a, s = s || m, !s) {
const e = a;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
m = e === a, s = s || m;
}
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, x.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), c = n === a;
} else c = !0;
}
}
}
}
}
return x.errors = o, 0 === a;
}
function k(e, {instancePath: t = "", parentData: r, parentDataProperty: s, rootData: o = e} = {}) {
let a = null, i = 0;
if (0 === i) {
if (!e || "object" != typeof e || Array.isArray(e)) return k.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const r = i;
for (const t in e) if (!n.call(v, t)) return k.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (r === i) {
if (void 0 !== e.asyncWebAssembly) {
const t = i;
if ("boolean" != typeof e.asyncWebAssembly) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.backCompat) {
const t = i;
if ("boolean" != typeof e.backCompat) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.buildHttp) {
let n = e.buildHttp;
const r = i, s = i;
let u = !1;
const f = i;
P(n, {
instancePath: t + "/buildHttp",
parentData: e,
parentDataProperty: "buildHttp",
rootData: o
}) || (a = null === a ? P.errors : a.concat(P.errors), i = a.length);
var p = f === i;
if (u = u || p, !u) {
const r = i;
A(n, {
instancePath: t + "/buildHttp",
parentData: e,
parentDataProperty: "buildHttp",
rootData: o
}) || (a = null === a ? A.errors : a.concat(A.errors), i = a.length), p = r === i, 
u = u || p;
}
if (!u) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, k.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.cacheUnaffected) {
const t = i;
if ("boolean" != typeof e.cacheUnaffected) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.css) {
let t = e.css;
const n = i, r = i;
let s = !1;
const o = i;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var u = o === i;
if (s = s || u, !s) {
const e = i;
if (i == i) if (t && "object" == typeof t && !Array.isArray(t)) {
const e = i;
for (const e in t) if ("exportsOnly" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === a ? a = [ t ] : a.push(t), i++;
break;
}
if (e === i && void 0 !== t.exportsOnly && "boolean" != typeof t.exportsOnly) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "object"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
u = e === i, s = s || u;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, k.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.futureDefaults) {
const t = i;
if ("boolean" != typeof e.futureDefaults) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.layers) {
const t = i;
if ("boolean" != typeof e.layers) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.lazyCompilation) {
let n = e.lazyCompilation;
const r = i, s = i;
let p = !1;
const u = i;
if ("boolean" != typeof n) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = u === i;
if (p = p || f, !p) {
const r = i;
x(n, {
instancePath: t + "/lazyCompilation",
parentData: e,
parentDataProperty: "lazyCompilation",
rootData: o
}) || (a = null === a ? x.errors : a.concat(x.errors), i = a.length), f = r === i, 
p = p || f;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, k.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.outputModule) {
const t = i;
if ("boolean" != typeof e.outputModule) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.syncWebAssembly) {
const t = i;
if ("boolean" != typeof e.syncWebAssembly) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) if (void 0 !== e.topLevelAwait) {
const t = i;
if ("boolean" != typeof e.topLevelAwait) return k.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
}
}
}
}
}
}
}
}
}
}
}
}
return k.errors = a, 0 === i;
}
const j = {
validate: S
};
function S(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const n = a;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u = n === a, l = l || u, !l) {
const n = a;
if (a === n) if (e && "object" == typeof e && !Array.isArray(e)) {
const n = a;
for (const t in e) if ("byLayer" !== t) {
let n = e[t];
const r = a, s = a;
let i = !1;
const l = a;
if (a === l) if (Array.isArray(n)) {
const e = n.length;
for (let t = 0; t < e; t++) {
let e = n[t];
const r = a;
if (a === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = l === a;
if (i = i || f, !i) {
const e = a;
if ("boolean" != typeof n) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (f = e === a, i = i || f, !i) {
const e = a;
if ("string" != typeof n) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (f = e === a, i = i || f, !i) {
const e = a;
if (!n || "object" != typeof n || Array.isArray(n)) {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = e === a, i = i || f;
}
}
}
if (i) a = s, null !== o && (s ? o.length = s : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
if (n === a && void 0 !== e.byLayer) {
let n = e.byLayer;
const r = a;
let i = !1;
const l = a;
if (a === l) if (n && "object" == typeof n && !Array.isArray(n)) for (const e in n) {
const r = a;
if (j.validate(n[e], {
instancePath: t + "/byLayer/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: n,
parentDataProperty: e,
rootData: s
}) || (o = null === o ? j.validate.errors : o.concat(j.validate.errors), a = o.length), 
r !== a) break;
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = l === a;
if (i = i || c, !i) {
const e = a;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = e === a, i = i || c;
}
if (i) a = r, null !== o && (r ? o.length = r : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u = n === a, l = l || u, !l) {
const t = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a, l = l || u;
}
}
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, S.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), S.errors = o, 0 === a;
}
function C(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (a === p) if (Array.isArray(e)) {
const n = e.length;
for (let r = 0; r < n; r++) {
const n = a;
if (S(e[r], {
instancePath: t + "/" + r,
parentData: e,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? S.errors : o.concat(S.errors), a = o.length), n !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const i = a;
S(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? S.errors : o.concat(S.errors), a = o.length), u = i === a, 
l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, C.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), C.errors = o, 0 === a;
}
function O(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1;
const u = i;
if (i === u) if (Array.isArray(t)) {
const n = t.length;
for (let r = 0; r < n; r++) {
let n = t[r];
const s = i, o = i;
let l = !1, p = null;
const u = i, c = i;
let m = !1;
const y = i;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = y === i;
if (m = m || f, !m) {
const t = i;
if (i === t) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f = t === i, m = m || f, !m) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = e === i, m = m || f;
}
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (u === i && (l = !0, p = 0), l) i = o, null !== a && (o ? a.length = o : a = null); else {
const e = {
params: {
passingSchemas: p
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (s !== i) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var c = u === i;
if (p = p || c, !p) {
const n = i, r = i;
let s = !1;
const o = i;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var m = o === i;
if (s = s || m, !s) {
const n = i;
if (i === n) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (m = n === i, s = s || m, !s) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
m = e === i, s = s || m;
}
}
if (s) i = r, null !== a && (r ? a.length = r : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
c = n === i, p = p || c;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, O.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), O.errors = a, 0 === i;
}
function F(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return F.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = a;
for (const t in e) if ("appendOnly" !== t && "colors" !== t && "console" !== t && "debug" !== t && "level" !== t && "stream" !== t) return F.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (n === a) {
if (void 0 !== e.appendOnly) {
const t = a;
if ("boolean" != typeof e.appendOnly) return F.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var i = t === a;
} else i = !0;
if (i) {
if (void 0 !== e.colors) {
const t = a;
if ("boolean" != typeof e.colors) return F.errors = [ {
params: {
type: "boolean"
}
} ], !1;
i = t === a;
} else i = !0;
if (i) {
if (void 0 !== e.debug) {
let n = e.debug;
const r = a, p = a;
let u = !1;
const f = a;
if ("boolean" != typeof n) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var l = f === a;
if (u = u || l, !u) {
const r = a;
O(n, {
instancePath: t + "/debug",
parentData: e,
parentDataProperty: "debug",
rootData: s
}) || (o = null === o ? O.errors : o.concat(O.errors), a = o.length), l = r === a, 
u = u || l;
}
if (!u) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, F.errors = o, !1;
}
a = p, null !== o && (p ? o.length = p : o = null), i = r === a;
} else i = !0;
if (i) if (void 0 !== e.level) {
let t = e.level;
const n = a;
if ("none" !== t && "error" !== t && "warn" !== t && "info" !== t && "log" !== t && "verbose" !== t) return F.errors = [ {
params: {}
} ], !1;
i = n === a;
} else i = !0;
}
}
}
}
}
return F.errors = o, 0 === a;
}
const R = {
defaultRules: {
oneOf: [ {
$ref: "#/definitions/RuleSetRules"
} ]
},
exprContextCritical: {
type: "boolean"
},
exprContextRecursive: {
type: "boolean"
},
exprContextRegExp: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "boolean"
} ]
},
exprContextRequest: {
type: "string"
},
generator: {
$ref: "#/definitions/GeneratorOptionsByModuleType"
},
noParse: {
$ref: "#/definitions/NoParse"
},
parser: {
$ref: "#/definitions/ParserOptionsByModuleType"
},
rules: {
oneOf: [ {
$ref: "#/definitions/RuleSetRules"
} ]
},
strictExportPresence: {
type: "boolean"
},
strictThisContextOnImports: {
type: "boolean"
},
unknownContextCritical: {
type: "boolean"
},
unknownContextRecursive: {
type: "boolean"
},
unknownContextRegExp: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "boolean"
} ]
},
unknownContextRequest: {
type: "string"
},
unsafeCache: {
anyOf: [ {
type: "boolean"
}, {
instanceof: "Function"
} ]
},
wrappedContextCritical: {
type: "boolean"
},
wrappedContextRecursive: {
type: "boolean"
},
wrappedContextRegExp: {
instanceof: "RegExp"
}
}, E = {
assert: {
type: "object",
additionalProperties: {
$ref: "#/definitions/RuleSetConditionOrConditions"
}
},
compiler: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
dependency: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
descriptionData: {
type: "object",
additionalProperties: {
$ref: "#/definitions/RuleSetConditionOrConditions"
}
},
enforce: {
enum: [ "pre", "post" ]
},
exclude: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditionsAbsolute"
} ]
},
generator: {
type: "object"
},
include: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditionsAbsolute"
} ]
},
issuer: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditionsAbsolute"
} ]
},
issuerLayer: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
layer: {
type: "string"
},
loader: {
oneOf: [ {
$ref: "#/definitions/RuleSetLoader"
} ]
},
mimetype: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
oneOf: {
type: "array",
items: {
oneOf: [ {
$ref: "#/definitions/RuleSetRule"
} ]
}
},
options: {
oneOf: [ {
$ref: "#/definitions/RuleSetLoaderOptions"
} ]
},
parser: {
type: "object",
additionalProperties: !0
},
realResource: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditionsAbsolute"
} ]
},
resolve: {
type: "object",
oneOf: [ {
$ref: "#/definitions/ResolveOptions"
} ]
},
resource: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditionsAbsolute"
} ]
},
resourceFragment: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
resourceQuery: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
rules: {
type: "array",
items: {
oneOf: [ {
$ref: "#/definitions/RuleSetRule"
} ]
}
},
scheme: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditions"
} ]
},
sideEffects: {
type: "boolean"
},
test: {
oneOf: [ {
$ref: "#/definitions/RuleSetConditionOrConditionsAbsolute"
} ]
},
type: {
type: "string"
},
use: {
oneOf: [ {
$ref: "#/definitions/RuleSetUse"
} ]
}
}, $ = {
validate: w
};
function z(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return z.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const n = e.length;
for (let r = 0; r < n; r++) {
const n = a, i = a;
let l = !1, p = null;
const u = a;
if ($.validate(e[r], {
instancePath: t + "/" + r,
parentData: e,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? $.validate.errors : o.concat($.validate.errors), a = o.length), 
u === a && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, z.errors = o, !1;
}
if (a = i, null !== o && (i ? o.length = i : o = null), n !== a) break;
}
}
}
return z.errors = o, 0 === a;
}
function L(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return L.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = a;
for (const t in e) if ("and" !== t && "not" !== t && "or" !== t) return L.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (n === a) {
if (void 0 !== e.and) {
const n = a, r = a;
let l = !1, p = null;
const u = a;
if (z(e.and, {
instancePath: t + "/and",
parentData: e,
parentDataProperty: "and",
rootData: s
}) || (o = null === o ? z.errors : o.concat(z.errors), a = o.length), u === a && (l = !0, 
p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, L.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null);
var i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.not) {
const n = a, r = a;
let l = !1, p = null;
const u = a;
if ($.validate(e.not, {
instancePath: t + "/not",
parentData: e,
parentDataProperty: "not",
rootData: s
}) || (o = null === o ? $.validate.errors : o.concat($.validate.errors), a = o.length), 
u === a && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, L.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), i = n === a;
} else i = !0;
if (i) if (void 0 !== e.or) {
const n = a, r = a;
let l = !1, p = null;
const u = a;
if (z(e.or, {
instancePath: t + "/or",
parentData: e,
parentDataProperty: "or",
rootData: s
}) || (o = null === o ? z.errors : o.concat(z.errors), a = o.length), u === a && (l = !0, 
p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, L.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), i = n === a;
} else i = !0;
}
}
}
}
return L.errors = o, 0 === a;
}
function w(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const i = a;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u = i === a, l = l || u, !l) {
const i = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u = i === a, l = l || u, !l) {
const i = a;
if (L(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? L.errors : o.concat(L.errors), a = o.length), u = i === a, 
l = l || u, !l) {
const i = a;
z(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? z.errors : o.concat(z.errors), a = o.length), u = i === a, 
l = l || u;
}
}
}
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, w.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), w.errors = o, 0 === a;
}
function M(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
w(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? w.errors : o.concat(w.errors), a = o.length);
var u = p === a;
if (l = l || u, !l) {
const i = a;
z(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? z.errors : o.concat(z.errors), a = o.length), u = i === a, 
l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, M.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), M.errors = o, 0 === a;
}
const N = {
validate: B
};
function T(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return T.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const n = e.length;
for (let r = 0; r < n; r++) {
const n = a, i = a;
let l = !1, p = null;
const u = a;
if (N.validate(e[r], {
instancePath: t + "/" + r,
parentData: e,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? N.validate.errors : o.concat(N.validate.errors), a = o.length), 
u === a && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, T.errors = o, !1;
}
if (a = i, null !== o && (i ? o.length = i : o = null), n !== a) break;
}
}
}
return T.errors = o, 0 === a;
}
function I(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return I.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = a;
for (const t in e) if ("and" !== t && "not" !== t && "or" !== t) return I.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (n === a) {
if (void 0 !== e.and) {
const n = a, r = a;
let l = !1, p = null;
const u = a;
if (T(e.and, {
instancePath: t + "/and",
parentData: e,
parentDataProperty: "and",
rootData: s
}) || (o = null === o ? T.errors : o.concat(T.errors), a = o.length), u === a && (l = !0, 
p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, I.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null);
var i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.not) {
const n = a, r = a;
let l = !1, p = null;
const u = a;
if (N.validate(e.not, {
instancePath: t + "/not",
parentData: e,
parentDataProperty: "not",
rootData: s
}) || (o = null === o ? N.validate.errors : o.concat(N.validate.errors), a = o.length), 
u === a && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, I.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), i = n === a;
} else i = !0;
if (i) if (void 0 !== e.or) {
const n = a, r = a;
let l = !1, p = null;
const u = a;
if (T(e.or, {
instancePath: t + "/or",
parentData: e,
parentDataProperty: "or",
rootData: s
}) || (o = null === o ? T.errors : o.concat(T.errors), a = o.length), u === a && (l = !0, 
p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, I.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), i = n === a;
} else i = !0;
}
}
}
}
return I.errors = o, 0 === a;
}
function B(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1;
const u = i;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = u === i;
if (p = p || f, !p) {
const l = i;
if (i === l) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f = l === i, p = p || f, !p) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f = e === i, p = p || f, !p) {
const e = i;
if (I(t, {
instancePath: n,
parentData: r,
parentDataProperty: s,
rootData: o
}) || (a = null === a ? I.errors : a.concat(I.errors), i = a.length), f = e === i, 
p = p || f, !p) {
const e = i;
T(t, {
instancePath: n,
parentData: r,
parentDataProperty: s,
rootData: o
}) || (a = null === a ? T.errors : a.concat(T.errors), i = a.length), f = e === i, 
p = p || f;
}
}
}
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, B.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), B.errors = a, 0 === i;
}
function U(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
B(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? B.errors : o.concat(B.errors), a = o.length);
var u = p === a;
if (l = l || u, !l) {
const i = a;
T(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? T.errors : o.concat(T.errors), a = o.length), u = i === a, 
l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, U.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), U.errors = o, 0 === a;
}
const q = {
alias: {
$ref: "#/definitions/ResolveAlias"
},
aliasFields: {
type: "array",
items: {
anyOf: [ {
type: "array",
items: {
type: "string",
minLength: 1
}
}, {
type: "string",
minLength: 1
} ]
}
},
byDependency: {
type: "object",
additionalProperties: {
oneOf: [ {
$ref: "#/definitions/ResolveOptions"
} ]
}
},
cache: {
type: "boolean"
},
cachePredicate: {
instanceof: "Function"
},
cacheWithContext: {
type: "boolean"
},
conditionNames: {
type: "array",
items: {
type: "string"
}
},
descriptionFiles: {
type: "array",
items: {
type: "string",
minLength: 1
}
},
enforceExtension: {
type: "boolean"
},
exportsFields: {
type: "array",
items: {
type: "string"
}
},
extensionAlias: {
type: "object",
additionalProperties: {
anyOf: [ {
type: "array",
items: {
type: "string",
minLength: 1
}
}, {
type: "string",
minLength: 1
} ]
}
},
extensions: {
type: "array",
items: {
type: "string"
}
},
fallback: {
oneOf: [ {
$ref: "#/definitions/ResolveAlias"
} ]
},
fileSystem: {},
fullySpecified: {
type: "boolean"
},
importsFields: {
type: "array",
items: {
type: "string"
}
},
mainFields: {
type: "array",
items: {
anyOf: [ {
type: "array",
items: {
type: "string",
minLength: 1
}
}, {
type: "string",
minLength: 1
} ]
}
},
mainFiles: {
type: "array",
items: {
type: "string",
minLength: 1
}
},
modules: {
type: "array",
items: {
type: "string",
minLength: 1
}
},
plugins: {
type: "array",
items: {
anyOf: [ {
enum: [ "..." ]
}, {
$ref: "#/definitions/ResolvePluginInstance"
} ]
}
},
preferAbsolute: {
type: "boolean"
},
preferRelative: {
type: "boolean"
},
resolver: {},
restrictions: {
type: "array",
items: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string",
absolutePath: !0,
minLength: 1
} ]
}
},
roots: {
type: "array",
items: {
type: "string"
}
},
symlinks: {
type: "boolean"
},
unsafeCache: {
anyOf: [ {
type: "boolean"
}, {
type: "object",
additionalProperties: !0
} ]
},
useSyncFileSystemCalls: {
type: "boolean"
}
}, G = {
validate: W
};
function W(t, {instancePath: r = "", parentData: s, parentDataProperty: o, rootData: a = t} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return W.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = l;
for (const e in t) if (!n.call(q, e)) return W.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (s === l) {
if (void 0 !== t.alias) {
let e = t.alias;
const n = l, r = l;
let s = !1;
const o = l;
if (l === o) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) if (t && "object" == typeof t && !Array.isArray(t)) {
let e;
if (void 0 === t.alias && (e = "alias") || void 0 === t.name && (e = "name")) {
const t = {
params: {
missingProperty: e
}
};
null === i ? i = [ t ] : i.push(t), l++;
} else {
const e = l;
for (const e in t) if ("alias" !== e && "name" !== e && "onlyModule" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === i ? i = [ t ] : i.push(t), l++;
break;
}
if (e === l) {
if (void 0 !== t.alias) {
let e = t.alias;
const n = l, r = l;
let s = !1;
const o = l;
if (l === o) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var p = o === l;
if (s = s || p, !s) {
const t = l;
if (!1 !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (p = t === l, s = s || p, !s) {
const t = l;
if (l === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
p = t === l, s = s || p;
}
}
if (s) l = r, null !== i && (r ? i.length = r : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var u = n === l;
} else u = !0;
if (u) {
if (void 0 !== t.name) {
const e = l;
if ("string" != typeof t.name) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
u = e === l;
} else u = !0;
if (u) if (void 0 !== t.onlyModule) {
const e = l;
if ("boolean" != typeof t.onlyModule) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
u = e === l;
} else u = !0;
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var f = o === l;
if (s = s || f, !s) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
let n = e[t];
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if (Array.isArray(n)) {
const e = n.length;
for (let t = 0; t < e; t++) {
let e = n[t];
const r = l;
if (l === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var c = a === l;
if (o = o || c, !o) {
const e = l;
if (!1 !== n) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (c = e === l, o = o || c, !o) {
const e = l;
if (l === e) if ("string" == typeof n) {
if (n.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
c = e === l, o = o || c;
}
}
if (o) l = s, null !== i && (s ? i.length = s : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l, s = s || f;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null);
var m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.aliasFields) {
let e = t.aliasFields;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if (Array.isArray(t)) {
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = l;
if (l === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var y = a === l;
if (o = o || y, !o) {
const e = l;
if (l === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
y = e === l, o = o || y;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
if (l = s, null !== i && (s ? i.length = s : i = null), r !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.byDependency) {
let e = t.byDependency;
const n = l;
if (l === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return W.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const t in e) {
const n = l, s = l;
let o = !1, p = null;
const u = l;
if (G.validate(e[t], {
instancePath: r + "/byDependency/" + t.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: e,
parentDataProperty: t,
rootData: a
}) || (i = null === i ? G.validate.errors : i.concat(G.validate.errors), l = i.length), 
u === l && (o = !0, p = 0), !o) {
const e = {
params: {
passingSchemas: p
}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
if (l = s, null !== i && (s ? i.length = s : i = null), n !== l) break;
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.cache) {
const e = l;
if ("boolean" != typeof t.cache) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.cachePredicate) {
const e = l;
if (!(t.cachePredicate instanceof Function)) return W.errors = [ {
params: {}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.cacheWithContext) {
const e = l;
if ("boolean" != typeof t.cacheWithContext) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.conditionNames) {
let e = t.conditionNames;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = l;
if ("string" != typeof e[n]) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.descriptionFiles) {
let e = t.descriptionFiles;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) {
if ("string" != typeof t) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return W.errors = [ {
params: {}
} ], !1;
}
if (r !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.enforceExtension) {
const e = l;
if ("boolean" != typeof t.enforceExtension) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.exportsFields) {
let e = t.exportsFields;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = l;
if ("string" != typeof e[n]) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.extensionAlias) {
let e = t.extensionAlias;
const n = l;
if (l === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return W.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const t in e) {
let n = e[t];
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if (Array.isArray(n)) {
const e = n.length;
for (let t = 0; t < e; t++) {
let e = n[t];
const r = l;
if (l === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var h = a === l;
if (o = o || h, !o) {
const e = l;
if (l === e) if ("string" == typeof n) {
if (n.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
h = e === l, o = o || h;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
if (l = s, null !== i && (s ? i.length = s : i = null), r !== l) break;
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.extensions) {
let e = t.extensions;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = l;
if ("string" != typeof e[n]) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.fallback) {
let e = t.fallback;
const n = l, r = l;
let s = !1, o = null;
const a = l, p = l;
let u = !1;
const f = l;
if (l === f) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) if (t && "object" == typeof t && !Array.isArray(t)) {
let e;
if (void 0 === t.alias && (e = "alias") || void 0 === t.name && (e = "name")) {
const t = {
params: {
missingProperty: e
}
};
null === i ? i = [ t ] : i.push(t), l++;
} else {
const e = l;
for (const e in t) if ("alias" !== e && "name" !== e && "onlyModule" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === i ? i = [ t ] : i.push(t), l++;
break;
}
if (e === l) {
if (void 0 !== t.alias) {
let e = t.alias;
const n = l, r = l;
let s = !1;
const o = l;
if (l === o) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var d = o === l;
if (s = s || d, !s) {
const t = l;
if (!1 !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (d = t === l, s = s || d, !s) {
const t = l;
if (l === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
d = t === l, s = s || d;
}
}
if (s) l = r, null !== i && (r ? i.length = r : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var g = n === l;
} else g = !0;
if (g) {
if (void 0 !== t.name) {
const e = l;
if ("string" != typeof t.name) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
g = e === l;
} else g = !0;
if (g) if (void 0 !== t.onlyModule) {
const e = l;
if ("boolean" != typeof t.onlyModule) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
g = e === l;
} else g = !0;
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var b = f === l;
if (u = u || b, !u) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
let n = e[t];
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if (Array.isArray(n)) {
const e = n.length;
for (let t = 0; t < e; t++) {
let e = n[t];
const r = l;
if (l === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var v = a === l;
if (o = o || v, !o) {
const e = l;
if (!1 !== n) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (v = e === l, o = o || v, !o) {
const e = l;
if (l === e) if ("string" == typeof n) {
if (n.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
v = e === l, o = o || v;
}
}
if (o) l = s, null !== i && (s ? i.length = s : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
b = t === l, u = u || b;
}
if (u) l = p, null !== i && (p ? i.length = p : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.fullySpecified) {
const e = l;
if ("boolean" != typeof t.fullySpecified) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.importsFields) {
let e = t.importsFields;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = l;
if ("string" != typeof e[n]) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.mainFields) {
let e = t.mainFields;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if (Array.isArray(t)) {
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = l;
if (l === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (r !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var D = a === l;
if (o = o || D, !o) {
const e = l;
if (l === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
D = e === l, o = o || D;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
if (l = s, null !== i && (s ? i.length = s : i = null), r !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.mainFiles) {
let e = t.mainFiles;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) {
if ("string" != typeof t) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return W.errors = [ {
params: {}
} ], !1;
}
if (r !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.modules) {
let e = t.modules;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l;
if (l === r) {
if ("string" != typeof t) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return W.errors = [ {
params: {}
} ], !1;
}
if (r !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.plugins) {
let e = t.plugins;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = l, s = l;
let o = !1;
const a = l;
if ("..." !== t) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var P = a === l;
if (o = o || P, !o) {
const e = l;
if (l == l) if (t && "object" == typeof t && !Array.isArray(t)) {
let e;
if (void 0 === t.apply && (e = "apply")) {
const t = {
params: {
missingProperty: e
}
};
null === i ? i = [ t ] : i.push(t), l++;
} else if (void 0 !== t.apply && !(t.apply instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
P = e === l, o = o || P;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
if (l = s, null !== i && (s ? i.length = s : i = null), r !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.preferAbsolute) {
const e = l;
if ("boolean" != typeof t.preferAbsolute) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.preferRelative) {
const e = l;
if ("boolean" != typeof t.preferRelative) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.restrictions) {
let n = t.restrictions;
const r = l;
if (l === r) {
if (!Array.isArray(n)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = n.length;
for (let r = 0; r < t; r++) {
let t = n[r];
const s = l, o = l;
let a = !1;
const p = l;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var A = p === l;
if (a = a || A, !a) {
const n = l;
if (l === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
A = n === l, a = a || A;
}
if (!a) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
if (l = o, null !== i && (o ? i.length = o : i = null), s !== l) break;
}
}
}
m = r === l;
} else m = !0;
if (m) {
if (void 0 !== t.roots) {
let e = t.roots;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return W.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = l;
if ("string" != typeof e[n]) return W.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== l) break;
}
}
}
m = n === l;
} else m = !0;
if (m) {
if (void 0 !== t.symlinks) {
const e = l;
if ("boolean" != typeof t.symlinks) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
if (m) {
if (void 0 !== t.unsafeCache) {
let e = t.unsafeCache;
const n = l, r = l;
let s = !1;
const o = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var x = o === l;
if (s = s || x, !s) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) ; else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
x = t === l, s = s || x;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, W.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), m = n === l;
} else m = !0;
if (m) if (void 0 !== t.useSyncFileSystemCalls) {
const e = l;
if ("boolean" != typeof t.useSyncFileSystemCalls) return W.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === l;
} else m = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return W.errors = i, 0 === l;
}
function H(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (a === p) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = a;
for (const t in e) if ("ident" !== t && "loader" !== t && "options" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
if (t === a) {
if (void 0 !== e.ident) {
const t = a;
if ("string" != typeof e.ident) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = t === a;
} else u = !0;
if (u) {
if (void 0 !== e.loader) {
let t = e.loader;
const n = a, r = a;
let s = !1, i = null;
const l = a;
if (a == a) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (l === a && (s = !0, i = 0), s) a = r, null !== o && (r ? o.length = r : o = null); else {
const e = {
params: {
passingSchemas: i
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = n === a;
} else u = !0;
if (u) if (void 0 !== e.options) {
let t = e.options;
const n = a, r = a;
let s = !1, i = null;
const l = a, p = a;
let c = !1;
const m = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = m === a;
if (c = c || f, !c) {
const e = a;
if (!t || "object" != typeof t || Array.isArray(t)) {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = e === a, c = c || f;
}
if (c) a = p, null !== o && (p ? o.length = p : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (l === a && (s = !0, i = 0), s) a = r, null !== o && (r ? o.length = r : o = null); else {
const e = {
params: {
passingSchemas: i
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = n === a;
} else u = !0;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = p === a;
if (l = l || c, !l) {
const t = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (c = t === a, l = l || c, !l) {
const t = a;
if (a == a) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = t === a, l = l || c;
}
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, H.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), H.errors = o, 0 === a;
}
function _(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (a === p) if (Array.isArray(e)) {
const n = e.length;
for (let r = 0; r < n; r++) {
const n = a, i = a;
let l = !1, p = null;
const u = a;
if (H(e[r], {
instancePath: t + "/" + r,
parentData: e,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? H.errors : o.concat(H.errors), a = o.length), u === a && (l = !0, 
p = 0), l) a = i, null !== o && (i ? o.length = i : o = null); else {
const e = {
params: {
passingSchemas: p
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (n !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const i = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u = i === a, l = l || u, !l) {
const i = a;
H(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? H.errors : o.concat(H.errors), a = o.length), u = i === a, 
l = l || u;
}
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, _.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), _.errors = o, 0 === a;
}
const Q = {
validate: J
};
function J(e, {instancePath: t = "", parentData: r, parentDataProperty: s, rootData: o = e} = {}) {
let a = null, i = 0;
if (0 === i) {
if (!e || "object" != typeof e || Array.isArray(e)) return J.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const r = i;
for (const t in e) if (!n.call(E, t)) return J.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (r === i) {
if (void 0 !== e.assert) {
let n = e.assert;
const r = i;
if (i === r) {
if (!n || "object" != typeof n || Array.isArray(n)) return J.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in n) {
const r = i;
if (M(n[e], {
instancePath: t + "/assert/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: n,
parentDataProperty: e,
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), r !== i) break;
}
}
var l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.compiler) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.compiler, {
instancePath: t + "/compiler",
parentData: e,
parentDataProperty: "compiler",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.dependency) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.dependency, {
instancePath: t + "/dependency",
parentData: e,
parentDataProperty: "dependency",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.descriptionData) {
let n = e.descriptionData;
const r = i;
if (i === r) {
if (!n || "object" != typeof n || Array.isArray(n)) return J.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in n) {
const r = i;
if (M(n[e], {
instancePath: t + "/descriptionData/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: n,
parentDataProperty: e,
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), r !== i) break;
}
}
l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.enforce) {
let t = e.enforce;
const n = i;
if ("pre" !== t && "post" !== t) return J.errors = [ {
params: {}
} ], !1;
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.exclude) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (U(e.exclude, {
instancePath: t + "/exclude",
parentData: e,
parentDataProperty: "exclude",
rootData: o
}) || (a = null === a ? U.errors : a.concat(U.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.generator) {
let t = e.generator;
const n = i;
if (!t || "object" != typeof t || Array.isArray(t)) return J.errors = [ {
params: {
type: "object"
}
} ], !1;
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.include) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (U(e.include, {
instancePath: t + "/include",
parentData: e,
parentDataProperty: "include",
rootData: o
}) || (a = null === a ? U.errors : a.concat(U.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.issuer) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (U(e.issuer, {
instancePath: t + "/issuer",
parentData: e,
parentDataProperty: "issuer",
rootData: o
}) || (a = null === a ? U.errors : a.concat(U.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.issuerLayer) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.issuerLayer, {
instancePath: t + "/issuerLayer",
parentData: e,
parentDataProperty: "issuerLayer",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.layer) {
const t = i;
if ("string" != typeof e.layer) return J.errors = [ {
params: {
type: "string"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.loader) {
let t = e.loader;
const n = i, r = i;
let s = !1, o = null;
const p = i;
if (i == i) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (p === i && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.mimetype) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.mimetype, {
instancePath: t + "/mimetype",
parentData: e,
parentDataProperty: "mimetype",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.oneOf) {
let n = e.oneOf;
const r = i;
if (i === r) {
if (!Array.isArray(n)) return J.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const e = n.length;
for (let r = 0; r < e; r++) {
const e = i, s = i;
let l = !1, p = null;
const u = i;
if (Q.validate(n[r], {
instancePath: t + "/oneOf/" + r,
parentData: n,
parentDataProperty: r,
rootData: o
}) || (a = null === a ? Q.validate.errors : a.concat(Q.validate.errors), i = a.length), 
u === i && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
if (i = s, null !== a && (s ? a.length = s : a = null), e !== i) break;
}
}
}
l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.options) {
let t = e.options;
const n = i, r = i;
let s = !1, o = null;
const u = i, f = i;
let c = !1;
const m = i;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var p = m === i;
if (c = c || p, !c) {
const e = i;
if (!t || "object" != typeof t || Array.isArray(t)) {
const e = {
params: {
type: "object"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
p = e === i, c = c || p;
}
if (c) i = f, null !== a && (f ? a.length = f : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (u === i && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.parser) {
let t = e.parser;
const n = i;
if (i === n && (!t || "object" != typeof t || Array.isArray(t))) return J.errors = [ {
params: {
type: "object"
}
} ], !1;
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.realResource) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (U(e.realResource, {
instancePath: t + "/realResource",
parentData: e,
parentDataProperty: "realResource",
rootData: o
}) || (a = null === a ? U.errors : a.concat(U.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.resolve) {
let n = e.resolve;
const r = i;
if (!n || "object" != typeof n || Array.isArray(n)) return J.errors = [ {
params: {
type: "object"
}
} ], !1;
const s = i;
let p = !1, u = null;
const f = i;
if (W(n, {
instancePath: t + "/resolve",
parentData: e,
parentDataProperty: "resolve",
rootData: o
}) || (a = null === a ? W.errors : a.concat(W.errors), i = a.length), f === i && (p = !0, 
u = 0), !p) {
const e = {
params: {
passingSchemas: u
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.resource) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (U(e.resource, {
instancePath: t + "/resource",
parentData: e,
parentDataProperty: "resource",
rootData: o
}) || (a = null === a ? U.errors : a.concat(U.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.resourceFragment) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.resourceFragment, {
instancePath: t + "/resourceFragment",
parentData: e,
parentDataProperty: "resourceFragment",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.resourceQuery) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.resourceQuery, {
instancePath: t + "/resourceQuery",
parentData: e,
parentDataProperty: "resourceQuery",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.rules) {
let n = e.rules;
const r = i;
if (i === r) {
if (!Array.isArray(n)) return J.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const e = n.length;
for (let r = 0; r < e; r++) {
const e = i, s = i;
let l = !1, p = null;
const u = i;
if (Q.validate(n[r], {
instancePath: t + "/rules/" + r,
parentData: n,
parentDataProperty: r,
rootData: o
}) || (a = null === a ? Q.validate.errors : a.concat(Q.validate.errors), i = a.length), 
u === i && (l = !0, p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
if (i = s, null !== a && (s ? a.length = s : a = null), e !== i) break;
}
}
}
l = r === i;
} else l = !0;
if (l) {
if (void 0 !== e.scheme) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (M(e.scheme, {
instancePath: t + "/scheme",
parentData: e,
parentDataProperty: "scheme",
rootData: o
}) || (a = null === a ? M.errors : a.concat(M.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.sideEffects) {
const t = i;
if ("boolean" != typeof e.sideEffects) return J.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.test) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (U(e.test, {
instancePath: t + "/test",
parentData: e,
parentDataProperty: "test",
rootData: o
}) || (a = null === a ? U.errors : a.concat(U.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.type) {
const t = i;
if ("string" != typeof e.type) return J.errors = [ {
params: {
type: "string"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) if (void 0 !== e.use) {
const n = i, r = i;
let s = !1, p = null;
const u = i;
if (_(e.use, {
instancePath: t + "/use",
parentData: e,
parentDataProperty: "use",
rootData: o
}) || (a = null === a ? _.errors : a.concat(_.errors), i = a.length), u === i && (s = !0, 
p = 0), !s) {
const e = {
params: {
passingSchemas: p
}
};
return null === a ? a = [ e ] : a.push(e), i++, J.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return J.errors = a, 0 === i;
}
function V(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return V.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const n = e.length;
for (let r = 0; r < n; r++) {
let n = e[r];
const l = a, p = a;
let u = !1;
const f = a;
if ("..." !== n) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = f === a;
if (u = u || i, !u) {
const l = a;
J(n, {
instancePath: t + "/" + r,
parentData: e,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? J.errors : o.concat(J.errors), a = o.length), i = l === a, 
u = u || i;
}
if (!u) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, V.errors = o, !1;
}
if (a = p, null !== o && (p ? o.length = p : o = null), l !== a) break;
}
}
}
return V.errors = o, 0 === a;
}
function Z(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (a == a) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = a;
for (const t in e) if ("encoding" !== t && "mimetype" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
if (t === a) {
if (void 0 !== e.encoding) {
let t = e.encoding;
const n = a;
if (!1 !== t && "base64" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = n === a;
} else u = !0;
if (u) if (void 0 !== e.mimetype) {
const t = a;
if ("string" != typeof e.mimetype) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a;
} else u = !0;
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = p === a;
if (l = l || f, !l) {
const t = a;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a, l = l || f;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, Z.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), Z.errors = o, 0 === a;
}
function K(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
if (0 === i) {
if (!t || "object" != typeof t || Array.isArray(t)) return K.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const r = i;
for (const e in t) if ("dataUrl" !== e && "emit" !== e && "filename" !== e && "outputPath" !== e && "publicPath" !== e) return K.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (r === i) {
if (void 0 !== t.dataUrl) {
const e = i;
Z(t.dataUrl, {
instancePath: n + "/dataUrl",
parentData: t,
parentDataProperty: "dataUrl",
rootData: o
}) || (a = null === a ? Z.errors : a.concat(Z.errors), i = a.length);
var l = e === i;
} else l = !0;
if (l) {
if (void 0 !== t.emit) {
const e = i;
if ("boolean" != typeof t.emit) return K.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = e === i;
} else l = !0;
if (l) {
if (void 0 !== t.filename) {
let n = t.filename;
const r = i, s = i;
let o = !1;
const u = i;
if (i === u) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (n.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var p = u === i;
if (o = o || p, !o) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
p = e === i, o = o || p;
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, K.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) {
if (void 0 !== t.outputPath) {
let n = t.outputPath;
const r = i, s = i;
let o = !1;
const p = i;
if (i === p) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var u = p === i;
if (o = o || u, !o) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
u = e === i, o = o || u;
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, K.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) if (void 0 !== t.publicPath) {
let e = t.publicPath;
const n = i, r = i;
let s = !1;
const o = i;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = o === i;
if (s = s || f, !s) {
const t = i;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = t === i, s = s || f;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, K.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
}
}
}
}
}
}
return K.errors = a, 0 === i;
}
function X(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return X.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = a;
for (const t in e) if ("dataUrl" !== t) return X.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
n === a && void 0 !== e.dataUrl && (Z(e.dataUrl, {
instancePath: t + "/dataUrl",
parentData: e,
parentDataProperty: "dataUrl",
rootData: s
}) || (o = null === o ? Z.errors : o.concat(Z.errors), a = o.length));
}
}
return X.errors = o, 0 === a;
}
function Y(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
if (0 === i) {
if (!t || "object" != typeof t || Array.isArray(t)) return Y.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = i;
for (const e in t) if ("emit" !== e && "filename" !== e && "outputPath" !== e && "publicPath" !== e) return Y.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (n === i) {
if (void 0 !== t.emit) {
const e = i;
if ("boolean" != typeof t.emit) return Y.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var l = e === i;
} else l = !0;
if (l) {
if (void 0 !== t.filename) {
let n = t.filename;
const r = i, s = i;
let o = !1;
const u = i;
if (i === u) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (n.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var p = u === i;
if (o = o || p, !o) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
p = e === i, o = o || p;
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, Y.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) {
if (void 0 !== t.outputPath) {
let n = t.outputPath;
const r = i, s = i;
let o = !1;
const p = i;
if (i === p) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var u = p === i;
if (o = o || u, !o) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
u = e === i, o = o || u;
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, Y.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) if (void 0 !== t.publicPath) {
let e = t.publicPath;
const n = i, r = i;
let s = !1;
const o = i;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = o === i;
if (s = s || f, !s) {
const t = i;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = t === i, s = s || f;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, Y.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
}
}
}
}
}
return Y.errors = a, 0 === i;
}
function ee(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return ee.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = a;
for (const t in e) if ("asset" !== t && "asset/inline" !== t && "asset/resource" !== t && "javascript" !== t && "javascript/auto" !== t && "javascript/dynamic" !== t && "javascript/esm" !== t) {
let n = e[t];
const r = a;
if (a === r && (!n || "object" != typeof n || Array.isArray(n))) return ee.errors = [ {
params: {
type: "object"
}
} ], !1;
if (r !== a) break;
}
if (n === a) {
if (void 0 !== e.asset) {
const n = a;
K(e.asset, {
instancePath: t + "/asset",
parentData: e,
parentDataProperty: "asset",
rootData: s
}) || (o = null === o ? K.errors : o.concat(K.errors), a = o.length);
var i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["asset/inline"]) {
const n = a;
X(e["asset/inline"], {
instancePath: t + "/asset~1inline",
parentData: e,
parentDataProperty: "asset/inline",
rootData: s
}) || (o = null === o ? X.errors : o.concat(X.errors), a = o.length), i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["asset/resource"]) {
const n = a;
Y(e["asset/resource"], {
instancePath: t + "/asset~1resource",
parentData: e,
parentDataProperty: "asset/resource",
rootData: s
}) || (o = null === o ? Y.errors : o.concat(Y.errors), a = o.length), i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.javascript) {
let t = e.javascript;
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return ee.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return ee.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["javascript/auto"]) {
let t = e["javascript/auto"];
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return ee.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return ee.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["javascript/dynamic"]) {
let t = e["javascript/dynamic"];
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return ee.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return ee.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
if (i) if (void 0 !== e["javascript/esm"]) {
let t = e["javascript/esm"];
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return ee.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return ee.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
}
}
}
}
}
}
}
}
return ee.errors = o, 0 === a;
}
function te(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return te.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = a;
for (const t in e) if ("dataUrlCondition" !== t) return te.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === a && void 0 !== e.dataUrlCondition) {
let t = e.dataUrlCondition;
const n = a;
let r = !1;
const s = a;
if (a == a) if (t && "object" == typeof t && !Array.isArray(t)) {
const e = a;
for (const e in t) if ("maxSize" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === o ? o = [ t ] : o.push(t), a++;
break;
}
if (e === a && void 0 !== t.maxSize && "number" != typeof t.maxSize) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = s === a;
if (r = r || i, !r) {
const e = a;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, r = r || i;
}
if (!r) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, te.errors = o, !1;
}
a = n, null !== o && (n ? o.length = n : o = null);
}
}
}
return te.errors = o, 0 === a;
}
function ne(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (!1 !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const t = a;
if (a == a) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = a;
for (const t in e) if ("__dirname" !== t && "__filename" !== t && "global" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
if (t === a) {
if (void 0 !== e.__dirname) {
let t = e.__dirname;
const n = a;
if (!1 !== t && !0 !== t && "warn-mock" !== t && "mock" !== t && "eval-only" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = n === a;
} else f = !0;
if (f) {
if (void 0 !== e.__filename) {
let t = e.__filename;
const n = a;
if (!1 !== t && !0 !== t && "warn-mock" !== t && "mock" !== t && "eval-only" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = n === a;
} else f = !0;
if (f) if (void 0 !== e.global) {
let t = e.global;
const n = a;
if (!1 !== t && !0 !== t && "warn" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = n === a;
} else f = !0;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a, l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, ne.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), ne.errors = o, 0 === a;
}
function re(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return re.errors = [ {
params: {
type: "object"
}
} ], !1;
if (void 0 !== e.amd) {
let t = e.amd;
const n = a, r = a;
let s = !1;
const p = a;
if (!1 !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = p === a;
if (s = s || i, !s) {
const e = a;
if (!t || "object" != typeof t || Array.isArray(t)) {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, s = s || i;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null);
var l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.browserify) {
const t = a;
if ("boolean" != typeof e.browserify) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.commonjs) {
const t = a;
if ("boolean" != typeof e.commonjs) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.commonjsMagicComments) {
const t = a;
if ("boolean" != typeof e.commonjsMagicComments) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.createRequire) {
let t = e.createRequire;
const n = a, r = a;
let s = !1;
const i = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var p = i === a;
if (s = s || p, !s) {
const e = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
p = e === a, s = s || p;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.dynamicImportMode) {
let t = e.dynamicImportMode;
const n = a;
if ("eager" !== t && "weak" !== t && "lazy" !== t && "lazy-once" !== t) return re.errors = [ {
params: {}
} ], !1;
l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.dynamicImportPrefetch) {
let t = e.dynamicImportPrefetch;
const n = a, r = a;
let s = !1;
const i = a;
if ("number" != typeof t) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = i === a;
if (s = s || u, !s) {
const e = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = e === a, s = s || u;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.dynamicImportPreload) {
let t = e.dynamicImportPreload;
const n = a, r = a;
let s = !1;
const i = a;
if ("number" != typeof t) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = i === a;
if (s = s || f, !s) {
const e = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = e === a, s = s || f;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.exportsPresence) {
let t = e.exportsPresence;
const n = a;
if ("error" !== t && "warn" !== t && "auto" !== t && !1 !== t) return re.errors = [ {
params: {}
} ], !1;
l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.exprContextCritical) {
const t = a;
if ("boolean" != typeof e.exprContextCritical) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.exprContextRecursive) {
const t = a;
if ("boolean" != typeof e.exprContextRecursive) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.exprContextRegExp) {
let t = e.exprContextRegExp;
const n = a, r = a;
let s = !1;
const i = a;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = i === a;
if (s = s || c, !s) {
const e = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = e === a, s = s || c;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.exprContextRequest) {
const t = a;
if ("string" != typeof e.exprContextRequest) return re.errors = [ {
params: {
type: "string"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.harmony) {
const t = a;
if ("boolean" != typeof e.harmony) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.import) {
const t = a;
if ("boolean" != typeof e.import) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.importExportsPresence) {
let t = e.importExportsPresence;
const n = a;
if ("error" !== t && "warn" !== t && "auto" !== t && !1 !== t) return re.errors = [ {
params: {}
} ], !1;
l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.importMeta) {
const t = a;
if ("boolean" != typeof e.importMeta) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.importMetaContext) {
const t = a;
if ("boolean" != typeof e.importMetaContext) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.node) {
const n = a;
ne(e.node, {
instancePath: t + "/node",
parentData: e,
parentDataProperty: "node",
rootData: s
}) || (o = null === o ? ne.errors : o.concat(ne.errors), a = o.length), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.reexportExportsPresence) {
let t = e.reexportExportsPresence;
const n = a;
if ("error" !== t && "warn" !== t && "auto" !== t && !1 !== t) return re.errors = [ {
params: {}
} ], !1;
l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.requireContext) {
const t = a;
if ("boolean" != typeof e.requireContext) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.requireEnsure) {
const t = a;
if ("boolean" != typeof e.requireEnsure) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.requireInclude) {
const t = a;
if ("boolean" != typeof e.requireInclude) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.requireJs) {
const t = a;
if ("boolean" != typeof e.requireJs) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.strictExportPresence) {
const t = a;
if ("boolean" != typeof e.strictExportPresence) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.strictThisContextOnImports) {
const t = a;
if ("boolean" != typeof e.strictThisContextOnImports) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.system) {
const t = a;
if ("boolean" != typeof e.system) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.unknownContextCritical) {
const t = a;
if ("boolean" != typeof e.unknownContextCritical) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.unknownContextRecursive) {
const t = a;
if ("boolean" != typeof e.unknownContextRecursive) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.unknownContextRegExp) {
let t = e.unknownContextRegExp;
const n = a, r = a;
let s = !1;
const i = a;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var m = i === a;
if (s = s || m, !s) {
const e = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
m = e === a, s = s || m;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.unknownContextRequest) {
const t = a;
if ("string" != typeof e.unknownContextRequest) return re.errors = [ {
params: {
type: "string"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.url) {
let t = e.url;
const n = a, r = a;
let s = !1;
const i = a;
if ("relative" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var y = i === a;
if (s = s || y, !s) {
const e = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
y = e === a, s = s || y;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.worker) {
let t = e.worker;
const n = a, r = a;
let s = !1;
const i = a;
if (a === i) if (Array.isArray(t)) {
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = a;
if (a === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (r !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var h = i === a;
if (s = s || h, !s) {
const e = a;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
h = e === a, s = s || h;
}
if (!s) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, re.errors = o, !1;
}
a = r, null !== o && (r ? o.length = r : o = null), l = n === a;
} else l = !0;
if (l) {
if (void 0 !== e.wrappedContextCritical) {
const t = a;
if ("boolean" != typeof e.wrappedContextCritical) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) {
if (void 0 !== e.wrappedContextRecursive) {
const t = a;
if ("boolean" != typeof e.wrappedContextRecursive) return re.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === a;
} else l = !0;
if (l) if (void 0 !== e.wrappedContextRegExp) {
const t = a;
if (!(e.wrappedContextRegExp instanceof RegExp)) return re.errors = [ {
params: {}
} ], !1;
l = t === a;
} else l = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return re.errors = o, 0 === a;
}
function se(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!e || "object" != typeof e || Array.isArray(e)) return se.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = a;
for (const t in e) if ("asset" !== t && "asset/inline" !== t && "asset/resource" !== t && "asset/source" !== t && "javascript" !== t && "javascript/auto" !== t && "javascript/dynamic" !== t && "javascript/esm" !== t) {
let n = e[t];
const r = a;
if (a === r && (!n || "object" != typeof n || Array.isArray(n))) return se.errors = [ {
params: {
type: "object"
}
} ], !1;
if (r !== a) break;
}
if (n === a) {
if (void 0 !== e.asset) {
const n = a;
te(e.asset, {
instancePath: t + "/asset",
parentData: e,
parentDataProperty: "asset",
rootData: s
}) || (o = null === o ? te.errors : o.concat(te.errors), a = o.length);
var i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["asset/inline"]) {
let t = e["asset/inline"];
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return se.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return se.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["asset/resource"]) {
let t = e["asset/resource"];
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return se.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return se.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["asset/source"]) {
let t = e["asset/source"];
const n = a;
if (a == a) {
if (!t || "object" != typeof t || Array.isArray(t)) return se.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return se.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
}
i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e.javascript) {
const n = a;
re(e.javascript, {
instancePath: t + "/javascript",
parentData: e,
parentDataProperty: "javascript",
rootData: s
}) || (o = null === o ? re.errors : o.concat(re.errors), a = o.length), i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["javascript/auto"]) {
const n = a;
re(e["javascript/auto"], {
instancePath: t + "/javascript~1auto",
parentData: e,
parentDataProperty: "javascript/auto",
rootData: s
}) || (o = null === o ? re.errors : o.concat(re.errors), a = o.length), i = n === a;
} else i = !0;
if (i) {
if (void 0 !== e["javascript/dynamic"]) {
const n = a;
re(e["javascript/dynamic"], {
instancePath: t + "/javascript~1dynamic",
parentData: e,
parentDataProperty: "javascript/dynamic",
rootData: s
}) || (o = null === o ? re.errors : o.concat(re.errors), a = o.length), i = n === a;
} else i = !0;
if (i) if (void 0 !== e["javascript/esm"]) {
const n = a;
re(e["javascript/esm"], {
instancePath: t + "/javascript~1esm",
parentData: e,
parentDataProperty: "javascript/esm",
rootData: s
}) || (o = null === o ? re.errors : o.concat(re.errors), a = o.length), i = n === a;
} else i = !0;
}
}
}
}
}
}
}
}
}
return se.errors = o, 0 === a;
}
function oe(t, {instancePath: r = "", parentData: s, parentDataProperty: o, rootData: a = t} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return oe.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = l;
for (const e in t) if (!n.call(R, e)) return oe.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (s === l) {
if (void 0 !== t.defaultRules) {
const e = l, n = l;
let s = !1, o = null;
const u = l;
if (V(t.defaultRules, {
instancePath: r + "/defaultRules",
parentData: t,
parentDataProperty: "defaultRules",
rootData: a
}) || (i = null === i ? V.errors : i.concat(V.errors), l = i.length), u === l && (s = !0, 
o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, oe.errors = i, !1;
}
l = n, null !== i && (n ? i.length = n : i = null);
var p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.exprContextCritical) {
const e = l;
if ("boolean" != typeof t.exprContextCritical) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.exprContextRecursive) {
const e = l;
if ("boolean" != typeof t.exprContextRecursive) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.exprContextRegExp) {
let e = t.exprContextRegExp;
const n = l, r = l;
let s = !1;
const o = l;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var u = o === l;
if (s = s || u, !s) {
const t = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
u = t === l, s = s || u;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, oe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.exprContextRequest) {
const e = l;
if ("string" != typeof t.exprContextRequest) return oe.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.generator) {
const e = l;
ee(t.generator, {
instancePath: r + "/generator",
parentData: t,
parentDataProperty: "generator",
rootData: a
}) || (i = null === i ? ee.errors : i.concat(ee.errors), l = i.length), p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.noParse) {
let n = t.noParse;
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if (Array.isArray(n)) if (n.length < 1) {
const e = {
params: {
limit: 1
}
};
null === i ? i = [ e ] : i.push(e), l++;
} else {
const t = n.length;
for (let r = 0; r < t; r++) {
let t = n[r];
const s = l, o = l;
let a = !1;
const p = l;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var f = p === l;
if (a = a || f, !a) {
const n = l;
if (l === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (f = n === l, a = a || f, !a) {
const e = l;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = e === l, a = a || f;
}
}
if (a) l = o, null !== i && (o ? i.length = o : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (s !== l) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var c = a === l;
if (o = o || c, !o) {
const t = l;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (c = t === l, o = o || c, !o) {
const t = l;
if (l === t) if ("string" == typeof n) {
if (n.includes("!") || !0 !== e.test(n)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (c = t === l, o = o || c, !o) {
const e = l;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
c = e === l, o = o || c;
}
}
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, oe.errors = i, !1;
}
l = s, null !== i && (s ? i.length = s : i = null), p = r === l;
} else p = !0;
if (p) {
if (void 0 !== t.parser) {
const e = l;
se(t.parser, {
instancePath: r + "/parser",
parentData: t,
parentDataProperty: "parser",
rootData: a
}) || (i = null === i ? se.errors : i.concat(se.errors), l = i.length), p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.rules) {
const e = l, n = l;
let s = !1, o = null;
const u = l;
if (V(t.rules, {
instancePath: r + "/rules",
parentData: t,
parentDataProperty: "rules",
rootData: a
}) || (i = null === i ? V.errors : i.concat(V.errors), l = i.length), u === l && (s = !0, 
o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, oe.errors = i, !1;
}
l = n, null !== i && (n ? i.length = n : i = null), p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.strictExportPresence) {
const e = l;
if ("boolean" != typeof t.strictExportPresence) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.strictThisContextOnImports) {
const e = l;
if ("boolean" != typeof t.strictThisContextOnImports) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.unknownContextCritical) {
const e = l;
if ("boolean" != typeof t.unknownContextCritical) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.unknownContextRecursive) {
const e = l;
if ("boolean" != typeof t.unknownContextRecursive) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.unknownContextRegExp) {
let e = t.unknownContextRegExp;
const n = l, r = l;
let s = !1;
const o = l;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var m = o === l;
if (s = s || m, !s) {
const t = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
m = t === l, s = s || m;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, oe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.unknownContextRequest) {
const e = l;
if ("string" != typeof t.unknownContextRequest) return oe.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.unsafeCache) {
let e = t.unsafeCache;
const n = l, r = l;
let s = !1;
const o = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var y = o === l;
if (s = s || y, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
y = t === l, s = s || y;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, oe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.wrappedContextCritical) {
const e = l;
if ("boolean" != typeof t.wrappedContextCritical) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.wrappedContextRecursive) {
const e = l;
if ("boolean" != typeof t.wrappedContextRecursive) return oe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) if (void 0 !== t.wrappedContextRegExp) {
const e = l;
if (!(t.wrappedContextRegExp instanceof RegExp)) return oe.errors = [ {
params: {}
} ], !1;
p = e === l;
} else p = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return oe.errors = i, 0 === l;
}
const ae = {
checkWasmTypes: {
type: "boolean"
},
chunkIds: {
enum: [ "natural", "named", "deterministic", "size", "total-size", !1 ]
},
concatenateModules: {
type: "boolean"
},
emitOnErrors: {
type: "boolean"
},
flagIncludedChunks: {
type: "boolean"
},
innerGraph: {
type: "boolean"
},
mangleExports: {
anyOf: [ {
enum: [ "size", "deterministic" ]
}, {
type: "boolean"
} ]
},
mangleWasmImports: {
type: "boolean"
},
mergeDuplicateChunks: {
type: "boolean"
},
minimize: {
type: "boolean"
},
minimizer: {
type: "array",
items: {
anyOf: [ {
enum: [ "..." ]
}, {
$ref: "#/definitions/WebpackPluginInstance"
}, {
$ref: "#/definitions/WebpackPluginFunction"
} ]
}
},
moduleIds: {
enum: [ "natural", "named", "hashed", "deterministic", "size", !1 ]
},
noEmitOnErrors: {
type: "boolean"
},
nodeEnv: {
anyOf: [ {
enum: [ !1 ]
}, {
type: "string"
} ]
},
portableRecords: {
type: "boolean"
},
providedExports: {
type: "boolean"
},
realContentHash: {
type: "boolean"
},
removeAvailableModules: {
type: "boolean"
},
removeEmptyChunks: {
type: "boolean"
},
runtimeChunk: {
$ref: "#/definitions/OptimizationRuntimeChunk"
},
sideEffects: {
anyOf: [ {
enum: [ "flag" ]
}, {
type: "boolean"
} ]
},
splitChunks: {
anyOf: [ {
enum: [ !1 ]
}, {
$ref: "#/definitions/OptimizationSplitChunksOptions"
} ]
},
usedExports: {
anyOf: [ {
enum: [ "global" ]
}, {
type: "boolean"
} ]
}
}, ie = {
automaticNameDelimiter: {
type: "string",
minLength: 1
},
cacheGroups: {
type: "object",
additionalProperties: {
anyOf: [ {
enum: [ !1 ]
}, {
instanceof: "RegExp"
}, {
type: "string"
}, {
instanceof: "Function"
}, {
$ref: "#/definitions/OptimizationSplitChunksCacheGroup"
} ]
},
not: {
type: "object",
additionalProperties: !0,
properties: {
test: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string"
}, {
instanceof: "Function"
} ]
}
},
required: [ "test" ]
}
},
chunks: {
anyOf: [ {
enum: [ "initial", "async", "all" ]
}, {
instanceof: "Function"
} ]
},
defaultSizeTypes: {
type: "array",
items: {
type: "string"
},
minItems: 1
},
enforceSizeThreshold: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
fallbackCacheGroup: {
type: "object",
additionalProperties: !1,
properties: {
automaticNameDelimiter: {
type: "string",
minLength: 1
},
chunks: {
anyOf: [ {
enum: [ "initial", "async", "all" ]
}, {
instanceof: "Function"
} ]
},
maxAsyncSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
maxInitialSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
maxSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minSizeReduction: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
}
}
},
filename: {
anyOf: [ {
type: "string",
absolutePath: !1,
minLength: 1
}, {
instanceof: "Function"
} ]
},
hidePathInfo: {
type: "boolean"
},
maxAsyncRequests: {
type: "number",
minimum: 1
},
maxAsyncSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
maxInitialRequests: {
type: "number",
minimum: 1
},
maxInitialSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
maxSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minChunks: {
type: "number",
minimum: 1
},
minRemainingSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minSizeReduction: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
name: {
anyOf: [ {
enum: [ !1 ]
}, {
type: "string"
}, {
instanceof: "Function"
} ]
},
usedExports: {
type: "boolean"
}
}, le = {
automaticNameDelimiter: {
type: "string",
minLength: 1
},
chunks: {
anyOf: [ {
enum: [ "initial", "async", "all" ]
}, {
instanceof: "Function"
} ]
},
enforce: {
type: "boolean"
},
enforceSizeThreshold: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
filename: {
anyOf: [ {
type: "string",
absolutePath: !1,
minLength: 1
}, {
instanceof: "Function"
} ]
},
idHint: {
type: "string"
},
layer: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string"
}, {
instanceof: "Function"
} ]
},
maxAsyncRequests: {
type: "number",
minimum: 1
},
maxAsyncSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
maxInitialRequests: {
type: "number",
minimum: 1
},
maxInitialSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
maxSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minChunks: {
type: "number",
minimum: 1
},
minRemainingSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minSize: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
minSizeReduction: {
oneOf: [ {
$ref: "#/definitions/OptimizationSplitChunksSizes"
} ]
},
name: {
anyOf: [ {
enum: [ !1 ]
}, {
type: "string"
}, {
instanceof: "Function"
} ]
},
priority: {
type: "number"
},
reuseExistingChunk: {
type: "boolean"
},
test: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string"
}, {
instanceof: "Function"
} ]
},
type: {
anyOf: [ {
instanceof: "RegExp"
}, {
type: "string"
}, {
instanceof: "Function"
} ]
},
usedExports: {
type: "boolean"
}
};
function pe(t, {instancePath: r = "", parentData: s, parentDataProperty: o, rootData: a = t} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return pe.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const r = l;
for (const e in t) if (!n.call(le, e)) return pe.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (r === l) {
if (void 0 !== t.automaticNameDelimiter) {
let e = t.automaticNameDelimiter;
const n = l;
if (l === n) {
if ("string" != typeof e) return pe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return pe.errors = [ {
params: {}
} ], !1;
}
var p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunks) {
let e = t.chunks;
const n = l, r = l;
let s = !1;
const o = l;
if ("initial" !== e && "async" !== e && "all" !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var u = o === l;
if (s = s || u, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
u = t === l, s = s || u;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.enforce) {
const e = l;
if ("boolean" != typeof t.enforce) return pe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.enforceSizeThreshold) {
let e = t.enforceSizeThreshold;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let c = !1;
const m = l;
if (l === m) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var f = m === l;
if (c = c || f, !c) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l, c = c || f;
}
if (c) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.filename) {
let n = t.filename;
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
} else if (n.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var c = a === l;
if (o = o || c, !o) {
const e = l;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
c = e === l, o = o || c;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = s, null !== i && (s ? i.length = s : i = null), p = r === l;
} else p = !0;
if (p) {
if (void 0 !== t.idHint) {
const e = l;
if ("string" != typeof t.idHint) return pe.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.layer) {
let e = t.layer;
const n = l, r = l;
let s = !1;
const o = l;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var m = o === l;
if (s = s || m, !s) {
const t = l;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (m = t === l, s = s || m, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
m = t === l, s = s || m;
}
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxAsyncRequests) {
let e = t.maxAsyncRequests;
const n = l;
if (l === n) {
if ("number" != typeof e) return pe.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return pe.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxAsyncSize) {
let e = t.maxAsyncSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var y = c === l;
if (f = f || y, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
y = t === l, f = f || y;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxInitialRequests) {
let e = t.maxInitialRequests;
const n = l;
if (l === n) {
if ("number" != typeof e) return pe.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return pe.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxInitialSize) {
let e = t.maxInitialSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var h = c === l;
if (f = f || h, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
h = t === l, f = f || h;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxSize) {
let e = t.maxSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var d = c === l;
if (f = f || d, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
d = t === l, f = f || d;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minChunks) {
let e = t.minChunks;
const n = l;
if (l === n) {
if ("number" != typeof e) return pe.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return pe.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minRemainingSize) {
let e = t.minRemainingSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var g = c === l;
if (f = f || g, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
g = t === l, f = f || g;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minSize) {
let e = t.minSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var b = c === l;
if (f = f || b, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
b = t === l, f = f || b;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minSizeReduction) {
let e = t.minSizeReduction;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var v = c === l;
if (f = f || v, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
v = t === l, f = f || v;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.name) {
let e = t.name;
const n = l, r = l;
let s = !1;
const o = l;
if (!1 !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var D = o === l;
if (s = s || D, !s) {
const t = l;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (D = t === l, s = s || D, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
D = t === l, s = s || D;
}
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.priority) {
const e = l;
if ("number" != typeof t.priority) return pe.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.reuseExistingChunk) {
const e = l;
if ("boolean" != typeof t.reuseExistingChunk) return pe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.test) {
let e = t.test;
const n = l, r = l;
let s = !1;
const o = l;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var P = o === l;
if (s = s || P, !s) {
const t = l;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (P = t === l, s = s || P, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
P = t === l, s = s || P;
}
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.type) {
let e = t.type;
const n = l, r = l;
let s = !1;
const o = l;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var A = o === l;
if (s = s || A, !s) {
const t = l;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (A = t === l, s = s || A, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
A = t === l, s = s || A;
}
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, pe.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) if (void 0 !== t.usedExports) {
const e = l;
if ("boolean" != typeof t.usedExports) return pe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return pe.errors = i, 0 === l;
}
function ue(t, {instancePath: r = "", parentData: s, parentDataProperty: o, rootData: a = t} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return ue.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = l;
for (const e in t) if (!n.call(ie, e)) return ue.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (s === l) {
if (void 0 !== t.automaticNameDelimiter) {
let e = t.automaticNameDelimiter;
const n = l;
if (l === n) {
if ("string" != typeof e) return ue.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return ue.errors = [ {
params: {}
} ], !1;
}
var p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.cacheGroups) {
let e = t.cacheGroups;
const n = l, s = l, o = l;
if (l === o) if (e && "object" == typeof e && !Array.isArray(e)) {
let t;
if (void 0 === e.test && (t = "test")) {
const e = {};
null === i ? i = [ e ] : i.push(e), l++;
} else if (void 0 !== e.test) {
let t = e.test;
const n = l;
let r = !1;
const s = l;
if (!(t instanceof RegExp)) {
const e = {};
null === i ? i = [ e ] : i.push(e), l++;
}
var u = s === l;
if (r = r || u, !r) {
const e = l;
if ("string" != typeof t) {
const e = {};
null === i ? i = [ e ] : i.push(e), l++;
}
if (u = e === l, r = r || u, !r) {
const e = l;
if (!(t instanceof Function)) {
const e = {};
null === i ? i = [ e ] : i.push(e), l++;
}
u = e === l, r = r || u;
}
}
if (r) l = n, null !== i && (n ? i.length = n : i = null); else {
const e = {};
null === i ? i = [ e ] : i.push(e), l++;
}
}
} else {
const e = {};
null === i ? i = [ e ] : i.push(e), l++;
}
if (o === l) return ue.errors = [ {
params: {}
} ], !1;
if (l = s, null !== i && (s ? i.length = s : i = null), l === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return ue.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const t in e) {
let n = e[t];
const s = l, o = l;
let p = !1;
const u = l;
if (!1 !== n) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var f = u === l;
if (p = p || f, !p) {
const s = l;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (f = s === l, p = p || f, !p) {
const s = l;
if ("string" != typeof n) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (f = s === l, p = p || f, !p) {
const s = l;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (f = s === l, p = p || f, !p) {
const s = l;
pe(n, {
instancePath: r + "/cacheGroups/" + t.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: e,
parentDataProperty: t,
rootData: a
}) || (i = null === i ? pe.errors : i.concat(pe.errors), l = i.length), f = s === l, 
p = p || f;
}
}
}
}
if (!p) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
if (l = o, null !== i && (o ? i.length = o : i = null), s !== l) break;
}
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunks) {
let e = t.chunks;
const n = l, r = l;
let s = !1;
const o = l;
if ("initial" !== e && "async" !== e && "all" !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var c = o === l;
if (s = s || c, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
c = t === l, s = s || c;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.defaultSizeTypes) {
let e = t.defaultSizeTypes;
const n = l;
if (l === n) {
if (!Array.isArray(e)) return ue.errors = [ {
params: {
type: "array"
}
} ], !1;
if (e.length < 1) return ue.errors = [ {
params: {
limit: 1
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = l;
if ("string" != typeof e[n]) return ue.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== l) break;
}
}
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.enforceSizeThreshold) {
let e = t.enforceSizeThreshold;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var m = c === l;
if (f = f || m, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
m = t === l, f = f || m;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.fallbackCacheGroup) {
let e = t.fallbackCacheGroup;
const n = l;
if (l === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return ue.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = l;
for (const t in e) if ("automaticNameDelimiter" !== t && "chunks" !== t && "maxAsyncSize" !== t && "maxInitialSize" !== t && "maxSize" !== t && "minSize" !== t && "minSizeReduction" !== t) return ue.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === l) {
if (void 0 !== e.automaticNameDelimiter) {
let t = e.automaticNameDelimiter;
const n = l;
if (l === n) {
if ("string" != typeof t) return ue.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return ue.errors = [ {
params: {}
} ], !1;
}
var y = n === l;
} else y = !0;
if (y) {
if (void 0 !== e.chunks) {
let t = e.chunks;
const n = l, r = l;
let s = !1;
const o = l;
if ("initial" !== t && "async" !== t && "all" !== t) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var h = o === l;
if (s = s || h, !s) {
const e = l;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
h = e === l, s = s || h;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), y = n === l;
} else y = !0;
if (y) {
if (void 0 !== e.maxAsyncSize) {
let t = e.maxAsyncSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, p = l;
let u = !1;
const f = l;
if (l === f) if ("number" == typeof t) {
if (t < 0 || isNaN(t)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var d = f === l;
if (u = u || d, !u) {
const e = l;
if (l === e) if (t && "object" == typeof t && !Array.isArray(t)) for (const e in t) {
const n = l;
if ("number" != typeof t[e]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
d = e === l, u = u || d;
}
if (u) l = p, null !== i && (p ? i.length = p : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), y = n === l;
} else y = !0;
if (y) {
if (void 0 !== e.maxInitialSize) {
let t = e.maxInitialSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, p = l;
let u = !1;
const f = l;
if (l === f) if ("number" == typeof t) {
if (t < 0 || isNaN(t)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var g = f === l;
if (u = u || g, !u) {
const e = l;
if (l === e) if (t && "object" == typeof t && !Array.isArray(t)) for (const e in t) {
const n = l;
if ("number" != typeof t[e]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
g = e === l, u = u || g;
}
if (u) l = p, null !== i && (p ? i.length = p : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), y = n === l;
} else y = !0;
if (y) {
if (void 0 !== e.maxSize) {
let t = e.maxSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, p = l;
let u = !1;
const f = l;
if (l === f) if ("number" == typeof t) {
if (t < 0 || isNaN(t)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var b = f === l;
if (u = u || b, !u) {
const e = l;
if (l === e) if (t && "object" == typeof t && !Array.isArray(t)) for (const e in t) {
const n = l;
if ("number" != typeof t[e]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
b = e === l, u = u || b;
}
if (u) l = p, null !== i && (p ? i.length = p : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), y = n === l;
} else y = !0;
if (y) {
if (void 0 !== e.minSize) {
let t = e.minSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, p = l;
let u = !1;
const f = l;
if (l === f) if ("number" == typeof t) {
if (t < 0 || isNaN(t)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var v = f === l;
if (u = u || v, !u) {
const e = l;
if (l === e) if (t && "object" == typeof t && !Array.isArray(t)) for (const e in t) {
const n = l;
if ("number" != typeof t[e]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
v = e === l, u = u || v;
}
if (u) l = p, null !== i && (p ? i.length = p : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), y = n === l;
} else y = !0;
if (y) if (void 0 !== e.minSizeReduction) {
let t = e.minSizeReduction;
const n = l, r = l;
let s = !1, o = null;
const a = l, p = l;
let u = !1;
const f = l;
if (l === f) if ("number" == typeof t) {
if (t < 0 || isNaN(t)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var D = f === l;
if (u = u || D, !u) {
const e = l;
if (l === e) if (t && "object" == typeof t && !Array.isArray(t)) for (const e in t) {
const n = l;
if ("number" != typeof t[e]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
D = e === l, u = u || D;
}
if (u) l = p, null !== i && (p ? i.length = p : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), y = n === l;
} else y = !0;
}
}
}
}
}
}
}
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.filename) {
let n = t.filename;
const r = l, s = l;
let o = !1;
const a = l;
if (l === a) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
} else if (n.length < 1) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var P = a === l;
if (o = o || P, !o) {
const e = l;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
P = e === l, o = o || P;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = s, null !== i && (s ? i.length = s : i = null), p = r === l;
} else p = !0;
if (p) {
if (void 0 !== t.hidePathInfo) {
const e = l;
if ("boolean" != typeof t.hidePathInfo) return ue.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxAsyncRequests) {
let e = t.maxAsyncRequests;
const n = l;
if (l === n) {
if ("number" != typeof e) return ue.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return ue.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxAsyncSize) {
let e = t.maxAsyncSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var A = c === l;
if (f = f || A, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
A = t === l, f = f || A;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxInitialRequests) {
let e = t.maxInitialRequests;
const n = l;
if (l === n) {
if ("number" != typeof e) return ue.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return ue.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxInitialSize) {
let e = t.maxInitialSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var x = c === l;
if (f = f || x, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
x = t === l, f = f || x;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.maxSize) {
let e = t.maxSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var k = c === l;
if (f = f || k, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
k = t === l, f = f || k;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minChunks) {
let e = t.minChunks;
const n = l;
if (l === n) {
if ("number" != typeof e) return ue.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return ue.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minRemainingSize) {
let e = t.minRemainingSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var j = c === l;
if (f = f || j, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
j = t === l, f = f || j;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minSize) {
let e = t.minSize;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var S = c === l;
if (f = f || S, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
S = t === l, f = f || S;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.minSizeReduction) {
let e = t.minSizeReduction;
const n = l, r = l;
let s = !1, o = null;
const a = l, u = l;
let f = !1;
const c = l;
if (l === c) if ("number" == typeof e) {
if (e < 0 || isNaN(e)) {
const e = {
params: {
comparison: ">=",
limit: 0
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
} else {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var C = c === l;
if (f = f || C, !f) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) for (const t in e) {
const n = l;
if ("number" != typeof e[t]) {
const e = {
params: {
type: "number"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (n !== l) break;
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
C = t === l, f = f || C;
}
if (f) l = u, null !== i && (u ? i.length = u : i = null); else {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (a === l && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.name) {
let e = t.name;
const n = l, r = l;
let s = !1;
const o = l;
if (!1 !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var O = o === l;
if (s = s || O, !s) {
const t = l;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
if (O = t === l, s = s || O, !s) {
const t = l;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
O = t === l, s = s || O;
}
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, ue.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) if (void 0 !== t.usedExports) {
const e = l;
if ("boolean" != typeof t.usedExports) return ue.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return ue.errors = i, 0 === l;
}
function fe(e, {instancePath: t = "", parentData: r, parentDataProperty: s, rootData: o = e} = {}) {
let a = null, i = 0;
if (0 === i) {
if (!e || "object" != typeof e || Array.isArray(e)) return fe.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const r = i;
for (const t in e) if (!n.call(ae, t)) return fe.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (r === i) {
if (void 0 !== e.checkWasmTypes) {
const t = i;
if ("boolean" != typeof e.checkWasmTypes) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.chunkIds) {
let t = e.chunkIds;
const n = i;
if ("natural" !== t && "named" !== t && "deterministic" !== t && "size" !== t && "total-size" !== t && !1 !== t) return fe.errors = [ {
params: {}
} ], !1;
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.concatenateModules) {
const t = i;
if ("boolean" != typeof e.concatenateModules) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.emitOnErrors) {
const t = i;
if ("boolean" != typeof e.emitOnErrors) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.flagIncludedChunks) {
const t = i;
if ("boolean" != typeof e.flagIncludedChunks) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.innerGraph) {
const t = i;
if ("boolean" != typeof e.innerGraph) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.mangleExports) {
let t = e.mangleExports;
const n = i, r = i;
let s = !1;
const o = i;
if ("size" !== t && "deterministic" !== t) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var p = o === i;
if (s = s || p, !s) {
const e = i;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
p = e === i, s = s || p;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.mangleWasmImports) {
const t = i;
if ("boolean" != typeof e.mangleWasmImports) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.mergeDuplicateChunks) {
const t = i;
if ("boolean" != typeof e.mergeDuplicateChunks) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.minimize) {
const t = i;
if ("boolean" != typeof e.minimize) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.minimizer) {
let t = e.minimizer;
const n = i;
if (i === n) {
if (!Array.isArray(t)) return fe.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = i, s = i;
let o = !1;
const l = i;
if ("..." !== e) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var u = l === i;
if (o = o || u, !o) {
const t = i;
if (i == i) if (e && "object" == typeof e && !Array.isArray(e)) {
let t;
if (void 0 === e.apply && (t = "apply")) {
const e = {
params: {
missingProperty: t
}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (void 0 !== e.apply && !(e.apply instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "object"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (u = t === i, o = o || u, !o) {
const t = i;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
u = t === i, o = o || u;
}
}
if (!o) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
if (i = s, null !== a && (s ? a.length = s : a = null), r !== i) break;
}
}
}
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.moduleIds) {
let t = e.moduleIds;
const n = i;
if ("natural" !== t && "named" !== t && "hashed" !== t && "deterministic" !== t && "size" !== t && !1 !== t) return fe.errors = [ {
params: {}
} ], !1;
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.noEmitOnErrors) {
const t = i;
if ("boolean" != typeof e.noEmitOnErrors) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.nodeEnv) {
let t = e.nodeEnv;
const n = i, r = i;
let s = !1;
const o = i;
if (!1 !== t) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = o === i;
if (s = s || f, !s) {
const e = i;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = e === i, s = s || f;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.portableRecords) {
const t = i;
if ("boolean" != typeof e.portableRecords) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.providedExports) {
const t = i;
if ("boolean" != typeof e.providedExports) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.realContentHash) {
const t = i;
if ("boolean" != typeof e.realContentHash) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.removeAvailableModules) {
const t = i;
if ("boolean" != typeof e.removeAvailableModules) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.removeEmptyChunks) {
const t = i;
if ("boolean" != typeof e.removeEmptyChunks) return fe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.runtimeChunk) {
let t = e.runtimeChunk;
const n = i, r = i;
let s = !1;
const o = i;
if ("single" !== t && "multiple" !== t) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var c = o === i;
if (s = s || c, !s) {
const e = i;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (c = e === i, s = s || c, !s) {
const e = i;
if (i === e) if (t && "object" == typeof t && !Array.isArray(t)) {
const e = i;
for (const e in t) if ("name" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === a ? a = [ t ] : a.push(t), i++;
break;
}
if (e === i && void 0 !== t.name) {
let e = t.name;
const n = i;
let r = !1;
const s = i;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var m = s === i;
if (r = r || m, !r) {
const t = i;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
m = t === i, r = r || m;
}
if (r) i = n, null !== a && (n ? a.length = n : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
c = e === i, s = s || c;
}
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.sideEffects) {
let t = e.sideEffects;
const n = i, r = i;
let s = !1;
const o = i;
if ("flag" !== t) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var y = o === i;
if (s = s || y, !s) {
const e = i;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
y = e === i, s = s || y;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.splitChunks) {
let n = e.splitChunks;
const r = i, s = i;
let p = !1;
const u = i;
if (!1 !== n) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var h = u === i;
if (p = p || h, !p) {
const r = i;
ue(n, {
instancePath: t + "/splitChunks",
parentData: e,
parentDataProperty: "splitChunks",
rootData: o
}) || (a = null === a ? ue.errors : a.concat(ue.errors), i = a.length), h = r === i, 
p = p || h;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
i = s, null !== a && (s ? a.length = s : a = null), l = r === i;
} else l = !0;
if (l) if (void 0 !== e.usedExports) {
let t = e.usedExports;
const n = i, r = i;
let s = !1;
const o = i;
if ("global" !== t) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var d = o === i;
if (s = s || d, !s) {
const e = i;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
d = e === i, s = s || d;
}
if (!s) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, fe.errors = a, !1;
}
i = r, null !== a && (r ? a.length = r : a = null), l = n === i;
} else l = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return fe.errors = a, 0 === i;
}
const ce = {
assetModuleFilename: {
$ref: "#/definitions/AssetModuleFilename"
},
asyncChunks: {
type: "boolean"
},
auxiliaryComment: {
oneOf: [ {
$ref: "#/definitions/AuxiliaryComment"
} ]
},
charset: {
$ref: "#/definitions/Charset"
},
chunkFilename: {
$ref: "#/definitions/ChunkFilename"
},
chunkFormat: {
$ref: "#/definitions/ChunkFormat"
},
chunkLoadTimeout: {
$ref: "#/definitions/ChunkLoadTimeout"
},
chunkLoading: {
$ref: "#/definitions/ChunkLoading"
},
chunkLoadingGlobal: {
$ref: "#/definitions/ChunkLoadingGlobal"
},
clean: {
$ref: "#/definitions/Clean"
},
compareBeforeEmit: {
$ref: "#/definitions/CompareBeforeEmit"
},
crossOriginLoading: {
$ref: "#/definitions/CrossOriginLoading"
},
cssChunkFilename: {
$ref: "#/definitions/CssChunkFilename"
},
cssFilename: {
$ref: "#/definitions/CssFilename"
},
devtoolFallbackModuleFilenameTemplate: {
$ref: "#/definitions/DevtoolFallbackModuleFilenameTemplate"
},
devtoolModuleFilenameTemplate: {
$ref: "#/definitions/DevtoolModuleFilenameTemplate"
},
devtoolNamespace: {
$ref: "#/definitions/DevtoolNamespace"
},
enabledChunkLoadingTypes: {
$ref: "#/definitions/EnabledChunkLoadingTypes"
},
enabledLibraryTypes: {
$ref: "#/definitions/EnabledLibraryTypes"
},
enabledWasmLoadingTypes: {
$ref: "#/definitions/EnabledWasmLoadingTypes"
},
environment: {
$ref: "#/definitions/Environment"
},
filename: {
$ref: "#/definitions/Filename"
},
globalObject: {
$ref: "#/definitions/GlobalObject"
},
hashDigest: {
$ref: "#/definitions/HashDigest"
},
hashDigestLength: {
$ref: "#/definitions/HashDigestLength"
},
hashFunction: {
$ref: "#/definitions/HashFunction"
},
hashSalt: {
$ref: "#/definitions/HashSalt"
},
hotUpdateChunkFilename: {
$ref: "#/definitions/HotUpdateChunkFilename"
},
hotUpdateGlobal: {
$ref: "#/definitions/HotUpdateGlobal"
},
hotUpdateMainFilename: {
$ref: "#/definitions/HotUpdateMainFilename"
},
iife: {
$ref: "#/definitions/Iife"
},
importFunctionName: {
$ref: "#/definitions/ImportFunctionName"
},
importMetaName: {
$ref: "#/definitions/ImportMetaName"
},
library: {
$ref: "#/definitions/Library"
},
libraryExport: {
oneOf: [ {
$ref: "#/definitions/LibraryExport"
} ]
},
libraryTarget: {
oneOf: [ {
$ref: "#/definitions/LibraryType"
} ]
},
module: {
$ref: "#/definitions/OutputModule"
},
path: {
$ref: "#/definitions/Path"
},
pathinfo: {
$ref: "#/definitions/Pathinfo"
},
publicPath: {
$ref: "#/definitions/PublicPath"
},
scriptType: {
$ref: "#/definitions/ScriptType"
},
sourceMapFilename: {
$ref: "#/definitions/SourceMapFilename"
},
sourcePrefix: {
$ref: "#/definitions/SourcePrefix"
},
strictModuleErrorHandling: {
$ref: "#/definitions/StrictModuleErrorHandling"
},
strictModuleExceptionHandling: {
$ref: "#/definitions/StrictModuleExceptionHandling"
},
trustedTypes: {
anyOf: [ {
enum: [ !0 ]
}, {
type: "string",
minLength: 1
}, {
$ref: "#/definitions/TrustedTypes"
} ]
},
umdNamedDefine: {
oneOf: [ {
$ref: "#/definitions/UmdNamedDefine"
} ]
},
uniqueName: {
$ref: "#/definitions/UniqueName"
},
wasmLoading: {
$ref: "#/definitions/WasmLoading"
},
webassemblyModuleFilename: {
$ref: "#/definitions/WebassemblyModuleFilename"
},
workerChunkLoading: {
$ref: "#/definitions/ChunkLoading"
},
workerWasmLoading: {
$ref: "#/definitions/WasmLoading"
}
}, me = {
arrowFunction: {
type: "boolean"
},
bigIntLiteral: {
type: "boolean"
},
const: {
type: "boolean"
},
destructuring: {
type: "boolean"
},
dynamicImport: {
type: "boolean"
},
forOf: {
type: "boolean"
},
module: {
type: "boolean"
},
optionalChaining: {
type: "boolean"
},
templateLiteral: {
type: "boolean"
}
};
function ye(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1, u = null;
const f = i, c = i;
let m = !1;
const y = i;
if (i === y) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var h = y === i;
if (m = m || h, !m) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
h = e === i, m = m || h;
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f === i && (p = !0, u = 0), !p) {
const e = {
params: {
passingSchemas: u
}
};
return null === a ? a = [ e ] : a.push(e), i++, ye.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), ye.errors = a, 0 === i;
}
function he(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1;
const u = i;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = u === i;
if (p = p || f, !p) {
const n = i;
if (i == i) if (t && "object" == typeof t && !Array.isArray(t)) {
const n = i;
for (const e in t) if ("dry" !== e && "keep" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === a ? a = [ t ] : a.push(t), i++;
break;
}
if (n === i) {
if (void 0 !== t.dry) {
const e = i;
if ("boolean" != typeof t.dry) {
const e = {
params: {
type: "boolean"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var c = e === i;
} else c = !0;
if (c) if (void 0 !== t.keep) {
let n = t.keep;
const r = i, s = i;
let o = !1;
const l = i;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var m = l === i;
if (o = o || m, !o) {
const t = i;
if (i === t) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (m = t === i, o = o || m, !o) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
m = e === i, o = o || m;
}
}
if (o) i = s, null !== a && (s ? a.length = s : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
c = r === i;
} else c = !0;
}
} else {
const e = {
params: {
type: "object"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = n === i, p = p || f;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, he.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), he.errors = a, 0 === i;
}
function de(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1, u = null;
const f = i, c = i;
let m = !1;
const y = i;
if (i === y) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var h = y === i;
if (m = m || h, !m) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
h = e === i, m = m || h;
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f === i && (p = !0, u = 0), !p) {
const e = {
params: {
passingSchemas: u
}
};
return null === a ? a = [ e ] : a.push(e), i++, de.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), de.errors = a, 0 === i;
}
function ge(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1, u = null;
const f = i, c = i;
let m = !1;
const y = i;
if (i === y) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var h = y === i;
if (m = m || h, !m) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
h = e === i, m = m || h;
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f === i && (p = !0, u = 0), !p) {
const e = {
params: {
passingSchemas: u
}
};
return null === a ? a = [ e ] : a.push(e), i++, ge.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), ge.errors = a, 0 === i;
}
function be(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return be.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a, s = a;
let l = !1;
const p = a;
if ("jsonp" !== t && "import-scripts" !== t && "require" !== t && "async-node" !== t && "import" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = p === a;
if (l = l || i, !l) {
const e = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, l = l || i;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, be.errors = o, !1;
}
if (a = s, null !== o && (s ? o.length = s : o = null), r !== a) break;
}
}
}
return be.errors = o, 0 === a;
}
function ve(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return ve.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a, s = a;
let l = !1;
const p = a;
if ("var" !== t && "module" !== t && "assign" !== t && "assign-properties" !== t && "this" !== t && "window" !== t && "self" !== t && "global" !== t && "commonjs" !== t && "commonjs2" !== t && "commonjs-module" !== t && "commonjs-static" !== t && "amd" !== t && "amd-require" !== t && "umd" !== t && "umd2" !== t && "jsonp" !== t && "system" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = p === a;
if (l = l || i, !l) {
const e = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, l = l || i;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, ve.errors = o, !1;
}
if (a = s, null !== o && (s ? o.length = s : o = null), r !== a) break;
}
}
}
return ve.errors = o, 0 === a;
}
function De(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return De.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a, s = a;
let l = !1;
const p = a;
if ("fetch-streaming" !== t && "fetch" !== t && "async-node" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = p === a;
if (l = l || i, !l) {
const e = a;
if ("string" != typeof t) {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, l = l || i;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, De.errors = o, !1;
}
if (a = s, null !== o && (s ? o.length = s : o = null), r !== a) break;
}
}
}
return De.errors = o, 0 === a;
}
function Pe(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1, u = null;
const f = i, c = i;
let m = !1;
const y = i;
if (i === y) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var h = y === i;
if (m = m || h, !m) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
h = e === i, m = m || h;
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f === i && (p = !0, u = 0), !p) {
const e = {
params: {
passingSchemas: u
}
};
return null === a ? a = [ e ] : a.push(e), i++, Pe.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), Pe.errors = a, 0 === i;
}
function Ae(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
u(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? u.errors : o.concat(u.errors), a = o.length);
var c = p === a;
if (l = l || c, !l) {
const i = a;
f(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? f.errors : o.concat(f.errors), a = o.length), c = i === a, 
l = l || c;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, Ae.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), Ae.errors = o, 0 === a;
}
function xe(t, {instancePath: r = "", parentData: s, parentDataProperty: o, rootData: a = t} = {}) {
let l = null, u = 0;
if (0 === u) {
if (!t || "object" != typeof t || Array.isArray(t)) return xe.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = u;
for (const e in t) if (!n.call(ce, e)) return xe.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (s === u) {
if (void 0 !== t.assetModuleFilename) {
let n = t.assetModuleFilename;
const r = u, s = u;
let o = !1;
const a = u;
if (u === a) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var f = a === u;
if (o = o || f, !o) {
const e = u;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
f = e === u, o = o || f;
}
if (!o) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = s, null !== l && (s ? l.length = s : l = null);
var y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.asyncChunks) {
const e = u;
if ("boolean" != typeof t.asyncChunks) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.auxiliaryComment) {
const e = u, n = u;
let s = !1, o = null;
const i = u;
if (p(t.auxiliaryComment, {
instancePath: r + "/auxiliaryComment",
parentData: t,
parentDataProperty: "auxiliaryComment",
rootData: a
}) || (l = null === l ? p.errors : l.concat(p.errors), u = l.length), i === u && (s = !0, 
o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = n, null !== l && (n ? l.length = n : l = null), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.charset) {
const e = u;
if ("boolean" != typeof t.charset) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.chunkFilename) {
const e = u;
ye(t.chunkFilename, {
instancePath: r + "/chunkFilename",
parentData: t,
parentDataProperty: "chunkFilename",
rootData: a
}) || (l = null === l ? ye.errors : l.concat(ye.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.chunkFormat) {
let e = t.chunkFormat;
const n = u, r = u;
let s = !1;
const o = u;
if ("array-push" !== e && "commonjs" !== e && "module" !== e && !1 !== e) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var h = o === u;
if (s = s || h, !s) {
const t = u;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
h = t === u, s = s || h;
}
if (!s) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.chunkLoadTimeout) {
const e = u;
if ("number" != typeof t.chunkLoadTimeout) return xe.errors = [ {
params: {
type: "number"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.chunkLoading) {
const e = u;
i(t.chunkLoading, {
instancePath: r + "/chunkLoading",
parentData: t,
parentDataProperty: "chunkLoading",
rootData: a
}) || (l = null === l ? i.errors : l.concat(i.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.chunkLoadingGlobal) {
const e = u;
if ("string" != typeof t.chunkLoadingGlobal) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.clean) {
const e = u;
he(t.clean, {
instancePath: r + "/clean",
parentData: t,
parentDataProperty: "clean",
rootData: a
}) || (l = null === l ? he.errors : l.concat(he.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.compareBeforeEmit) {
const e = u;
if ("boolean" != typeof t.compareBeforeEmit) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.crossOriginLoading) {
let e = t.crossOriginLoading;
const n = u;
if (!1 !== e && "anonymous" !== e && "use-credentials" !== e) return xe.errors = [ {
params: {}
} ], !1;
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.cssChunkFilename) {
const e = u;
de(t.cssChunkFilename, {
instancePath: r + "/cssChunkFilename",
parentData: t,
parentDataProperty: "cssChunkFilename",
rootData: a
}) || (l = null === l ? de.errors : l.concat(de.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.cssFilename) {
const e = u;
ge(t.cssFilename, {
instancePath: r + "/cssFilename",
parentData: t,
parentDataProperty: "cssFilename",
rootData: a
}) || (l = null === l ? ge.errors : l.concat(ge.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.devtoolFallbackModuleFilenameTemplate) {
let e = t.devtoolFallbackModuleFilenameTemplate;
const n = u, r = u;
let s = !1;
const o = u;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var d = o === u;
if (s = s || d, !s) {
const t = u;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
d = t === u, s = s || d;
}
if (!s) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.devtoolModuleFilenameTemplate) {
let e = t.devtoolModuleFilenameTemplate;
const n = u, r = u;
let s = !1;
const o = u;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var g = o === u;
if (s = s || g, !s) {
const t = u;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
g = t === u, s = s || g;
}
if (!s) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.devtoolNamespace) {
const e = u;
if ("string" != typeof t.devtoolNamespace) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.enabledChunkLoadingTypes) {
const e = u;
be(t.enabledChunkLoadingTypes, {
instancePath: r + "/enabledChunkLoadingTypes",
parentData: t,
parentDataProperty: "enabledChunkLoadingTypes",
rootData: a
}) || (l = null === l ? be.errors : l.concat(be.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.enabledLibraryTypes) {
const e = u;
ve(t.enabledLibraryTypes, {
instancePath: r + "/enabledLibraryTypes",
parentData: t,
parentDataProperty: "enabledLibraryTypes",
rootData: a
}) || (l = null === l ? ve.errors : l.concat(ve.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.enabledWasmLoadingTypes) {
const e = u;
De(t.enabledWasmLoadingTypes, {
instancePath: r + "/enabledWasmLoadingTypes",
parentData: t,
parentDataProperty: "enabledWasmLoadingTypes",
rootData: a
}) || (l = null === l ? De.errors : l.concat(De.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.environment) {
let e = t.environment;
const r = u;
if (u == u) {
if (!e || "object" != typeof e || Array.isArray(e)) return xe.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if (!n.call(me, t)) return xe.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.arrowFunction) {
const t = u;
if ("boolean" != typeof e.arrowFunction) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.bigIntLiteral) {
const t = u;
if ("boolean" != typeof e.bigIntLiteral) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.const) {
const t = u;
if ("boolean" != typeof e.const) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.destructuring) {
const t = u;
if ("boolean" != typeof e.destructuring) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.dynamicImport) {
const t = u;
if ("boolean" != typeof e.dynamicImport) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.forOf) {
const t = u;
if ("boolean" != typeof e.forOf) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.module) {
const t = u;
if ("boolean" != typeof e.module) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) {
if (void 0 !== e.optionalChaining) {
const t = u;
if ("boolean" != typeof e.optionalChaining) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
if (b) if (void 0 !== e.templateLiteral) {
const t = u;
if ("boolean" != typeof e.templateLiteral) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
b = t === u;
} else b = !0;
}
}
}
}
}
}
}
}
}
}
y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.filename) {
const e = u;
Pe(t.filename, {
instancePath: r + "/filename",
parentData: t,
parentDataProperty: "filename",
rootData: a
}) || (l = null === l ? Pe.errors : l.concat(Pe.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.globalObject) {
let e = t.globalObject;
const n = u;
if (u == u) {
if ("string" != typeof e) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return xe.errors = [ {
params: {}
} ], !1;
}
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.hashDigest) {
const e = u;
if ("string" != typeof t.hashDigest) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.hashDigestLength) {
let e = t.hashDigestLength;
const n = u;
if (u == u) {
if ("number" != typeof e) return xe.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return xe.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.hashFunction) {
let e = t.hashFunction;
const n = u, r = u;
let s = !1;
const o = u;
if (u === o) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var v = o === u;
if (s = s || v, !s) {
const t = u;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
v = t === u, s = s || v;
}
if (!s) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.hashSalt) {
let e = t.hashSalt;
const n = u;
if (u == u) {
if ("string" != typeof e) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return xe.errors = [ {
params: {}
} ], !1;
}
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.hotUpdateChunkFilename) {
let n = t.hotUpdateChunkFilename;
const r = u;
if (u == u) {
if ("string" != typeof n) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !1 !== e.test(n)) return xe.errors = [ {
params: {}
} ], !1;
}
y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.hotUpdateGlobal) {
const e = u;
if ("string" != typeof t.hotUpdateGlobal) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.hotUpdateMainFilename) {
let n = t.hotUpdateMainFilename;
const r = u;
if (u == u) {
if ("string" != typeof n) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !1 !== e.test(n)) return xe.errors = [ {
params: {}
} ], !1;
}
y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.iife) {
const e = u;
if ("boolean" != typeof t.iife) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.importFunctionName) {
const e = u;
if ("string" != typeof t.importFunctionName) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.importMetaName) {
const e = u;
if ("string" != typeof t.importMetaName) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.library) {
const e = u;
Ae(t.library, {
instancePath: r + "/library",
parentData: t,
parentDataProperty: "library",
rootData: a
}) || (l = null === l ? Ae.errors : l.concat(Ae.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.libraryExport) {
let e = t.libraryExport;
const n = u, r = u;
let s = !1, o = null;
const a = u, i = u;
let p = !1;
const f = u;
if (u === f) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = u;
if (u === r) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
if (r !== u) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var D = f === u;
if (p = p || D, !p) {
const t = u;
if (u === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
D = t === u, p = p || D;
}
if (p) u = i, null !== l && (i ? l.length = i : l = null); else {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
if (a === u && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.libraryTarget) {
let e = t.libraryTarget;
const n = u, r = u;
let s = !1, o = null;
const a = u, i = u;
let p = !1;
const f = u;
if ("var" !== e && "module" !== e && "assign" !== e && "assign-properties" !== e && "this" !== e && "window" !== e && "self" !== e && "global" !== e && "commonjs" !== e && "commonjs2" !== e && "commonjs-module" !== e && "commonjs-static" !== e && "amd" !== e && "amd-require" !== e && "umd" !== e && "umd2" !== e && "jsonp" !== e && "system" !== e) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var P = f === u;
if (p = p || P, !p) {
const t = u;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
P = t === u, p = p || P;
}
if (p) u = i, null !== l && (i ? l.length = i : l = null); else {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
if (a === u && (s = !0, o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.module) {
const e = u;
if ("boolean" != typeof t.module) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.path) {
let n = t.path;
const r = u;
if (u == u) {
if ("string" != typeof n) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !0 !== e.test(n)) return xe.errors = [ {
params: {}
} ], !1;
}
y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.pathinfo) {
let e = t.pathinfo;
const n = u, r = u;
let s = !1;
const o = u;
if ("verbose" !== e) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var A = o === u;
if (s = s || A, !s) {
const t = u;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
A = t === u, s = s || A;
}
if (!s) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.publicPath) {
const e = u;
c(t.publicPath, {
instancePath: r + "/publicPath",
parentData: t,
parentDataProperty: "publicPath",
rootData: a
}) || (l = null === l ? c.errors : l.concat(c.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.scriptType) {
let e = t.scriptType;
const n = u;
if (!1 !== e && "text/javascript" !== e && "module" !== e) return xe.errors = [ {
params: {}
} ], !1;
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.sourceMapFilename) {
let n = t.sourceMapFilename;
const r = u;
if (u == u) {
if ("string" != typeof n) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !1 !== e.test(n)) return xe.errors = [ {
params: {}
} ], !1;
}
y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.sourcePrefix) {
const e = u;
if ("string" != typeof t.sourcePrefix) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.strictModuleErrorHandling) {
const e = u;
if ("boolean" != typeof t.strictModuleErrorHandling) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.strictModuleExceptionHandling) {
const e = u;
if ("boolean" != typeof t.strictModuleExceptionHandling) return xe.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.trustedTypes) {
let e = t.trustedTypes;
const n = u, r = u;
let s = !1;
const o = u;
if (!0 !== e) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
var x = o === u;
if (s = s || x, !s) {
const t = u;
if (u === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
if (x = t === u, s = s || x, !s) {
const t = u;
if (u == u) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = u;
for (const t in e) if ("policyName" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === l ? l = [ e ] : l.push(e), u++;
break;
}
if (t === u && void 0 !== e.policyName) {
let t = e.policyName;
if (u == u) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
x = t === u, s = s || x;
}
}
if (!s) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = r, null !== l && (r ? l.length = r : l = null), y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.umdNamedDefine) {
const e = u, n = u;
let r = !1, s = null;
const o = u;
if ("boolean" != typeof t.umdNamedDefine) {
const e = {
params: {
type: "boolean"
}
};
null === l ? l = [ e ] : l.push(e), u++;
}
if (o === u && (r = !0, s = 0), !r) {
const e = {
params: {
passingSchemas: s
}
};
return null === l ? l = [ e ] : l.push(e), u++, xe.errors = l, !1;
}
u = n, null !== l && (n ? l.length = n : l = null), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.uniqueName) {
let e = t.uniqueName;
const n = u;
if (u == u) {
if ("string" != typeof e) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return xe.errors = [ {
params: {}
} ], !1;
}
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== t.wasmLoading) {
const e = u;
m(t.wasmLoading, {
instancePath: r + "/wasmLoading",
parentData: t,
parentDataProperty: "wasmLoading",
rootData: a
}) || (l = null === l ? m.errors : l.concat(m.errors), u = l.length), y = e === u;
} else y = !0;
if (y) {
if (void 0 !== t.webassemblyModuleFilename) {
let n = t.webassemblyModuleFilename;
const r = u;
if (u == u) {
if ("string" != typeof n) return xe.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !1 !== e.test(n)) return xe.errors = [ {
params: {}
} ], !1;
}
y = r === u;
} else y = !0;
if (y) {
if (void 0 !== t.workerChunkLoading) {
const e = u;
i(t.workerChunkLoading, {
instancePath: r + "/workerChunkLoading",
parentData: t,
parentDataProperty: "workerChunkLoading",
rootData: a
}) || (l = null === l ? i.errors : l.concat(i.errors), u = l.length), y = e === u;
} else y = !0;
if (y) if (void 0 !== t.workerWasmLoading) {
const e = u;
m(t.workerWasmLoading, {
instancePath: r + "/workerWasmLoading",
parentData: t,
parentDataProperty: "workerWasmLoading",
rootData: a
}) || (l = null === l ? m.errors : l.concat(m.errors), u = l.length), y = e === u;
} else y = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return xe.errors = l, 0 === u;
}
function ke(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if (!1 !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const t = a;
if (a == a) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = a;
for (const t in e) if ("assetFilter" !== t && "hints" !== t && "maxAssetSize" !== t && "maxEntrypointSize" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === o ? o = [ e ] : o.push(e), a++;
break;
}
if (t === a) {
if (void 0 !== e.assetFilter) {
const t = a;
if (!(e.assetFilter instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = t === a;
} else f = !0;
if (f) {
if (void 0 !== e.hints) {
let t = e.hints;
const n = a;
if (!1 !== t && "warning" !== t && "error" !== t) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = n === a;
} else f = !0;
if (f) {
if (void 0 !== e.maxAssetSize) {
const t = a;
if ("number" != typeof e.maxAssetSize) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a;
} else f = !0;
if (f) if (void 0 !== e.maxEntrypointSize) {
const t = a;
if ("number" != typeof e.maxEntrypointSize) {
const e = {
params: {
type: "number"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = t === a;
} else f = !0;
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
u = t === a, l = l || u;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, ke.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), ke.errors = o, 0 === a;
}
function je(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
if (0 === a) {
if (!Array.isArray(e)) return je.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = a, s = a;
let l = !1;
const p = a;
if (a == a) if (t && "object" == typeof t && !Array.isArray(t)) {
let e;
if (void 0 === t.apply && (e = "apply")) {
const t = {
params: {
missingProperty: e
}
};
null === o ? o = [ t ] : o.push(t), a++;
} else if (void 0 !== t.apply && !(t.apply instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "object"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var i = p === a;
if (l = l || i, !l) {
const e = a;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
i = e === a, l = l || i;
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, je.errors = o, !1;
}
if (a = s, null !== o && (s ? o.length = s : o = null), r !== a) break;
}
}
}
return je.errors = o, 0 === a;
}
function Se(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1, p = null;
const u = a;
if (W(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? W.errors : o.concat(W.errors), a = o.length), u === a && (l = !0, 
p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, Se.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), Se.errors = o, 0 === a;
}
function Ce(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1, p = null;
const u = a;
if (W(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? W.errors : o.concat(W.errors), a = o.length), u === a && (l = !0, 
p = 0), !l) {
const e = {
params: {
passingSchemas: p
}
};
return null === o ? o = [ e ] : o.push(e), a++, Ce.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), Ce.errors = o, 0 === a;
}
const Oe = {
all: {
type: "boolean"
},
assets: {
type: "boolean"
},
assetsSort: {
type: "string"
},
assetsSpace: {
type: "number"
},
builtAt: {
type: "boolean"
},
cached: {
type: "boolean"
},
cachedAssets: {
type: "boolean"
},
cachedModules: {
type: "boolean"
},
children: {
type: "boolean"
},
chunkGroupAuxiliary: {
type: "boolean"
},
chunkGroupChildren: {
type: "boolean"
},
chunkGroupMaxAssets: {
type: "number"
},
chunkGroups: {
type: "boolean"
},
chunkModules: {
type: "boolean"
},
chunkModulesSpace: {
type: "number"
},
chunkOrigins: {
type: "boolean"
},
chunkRelations: {
type: "boolean"
},
chunks: {
type: "boolean"
},
chunksSort: {
type: "string"
},
colors: {
anyOf: [ {
type: "boolean"
}, {
type: "object",
additionalProperties: !1,
properties: {
bold: {
type: "string"
},
cyan: {
type: "string"
},
green: {
type: "string"
},
magenta: {
type: "string"
},
red: {
type: "string"
},
yellow: {
type: "string"
}
}
} ]
},
context: {
type: "string",
absolutePath: !0
},
dependentModules: {
type: "boolean"
},
depth: {
type: "boolean"
},
entrypoints: {
anyOf: [ {
enum: [ "auto" ]
}, {
type: "boolean"
} ]
},
env: {
type: "boolean"
},
errorDetails: {
anyOf: [ {
enum: [ "auto" ]
}, {
type: "boolean"
} ]
},
errorStack: {
type: "boolean"
},
errors: {
type: "boolean"
},
errorsCount: {
type: "boolean"
},
exclude: {
anyOf: [ {
type: "boolean"
}, {
$ref: "#/definitions/ModuleFilterTypes"
} ]
},
excludeAssets: {
oneOf: [ {
$ref: "#/definitions/AssetFilterTypes"
} ]
},
excludeModules: {
anyOf: [ {
type: "boolean"
}, {
$ref: "#/definitions/ModuleFilterTypes"
} ]
},
groupAssetsByChunk: {
type: "boolean"
},
groupAssetsByEmitStatus: {
type: "boolean"
},
groupAssetsByExtension: {
type: "boolean"
},
groupAssetsByInfo: {
type: "boolean"
},
groupAssetsByPath: {
type: "boolean"
},
groupModulesByAttributes: {
type: "boolean"
},
groupModulesByCacheStatus: {
type: "boolean"
},
groupModulesByExtension: {
type: "boolean"
},
groupModulesByLayer: {
type: "boolean"
},
groupModulesByPath: {
type: "boolean"
},
groupModulesByType: {
type: "boolean"
},
groupReasonsByOrigin: {
type: "boolean"
},
hash: {
type: "boolean"
},
ids: {
type: "boolean"
},
logging: {
anyOf: [ {
enum: [ "none", "error", "warn", "info", "log", "verbose" ]
}, {
type: "boolean"
} ]
},
loggingDebug: {
anyOf: [ {
type: "boolean"
}, {
$ref: "#/definitions/FilterTypes"
} ]
},
loggingTrace: {
type: "boolean"
},
moduleAssets: {
type: "boolean"
},
moduleTrace: {
type: "boolean"
},
modules: {
type: "boolean"
},
modulesSort: {
type: "string"
},
modulesSpace: {
type: "number"
},
nestedModules: {
type: "boolean"
},
nestedModulesSpace: {
type: "number"
},
optimizationBailout: {
type: "boolean"
},
orphanModules: {
type: "boolean"
},
outputPath: {
type: "boolean"
},
performance: {
type: "boolean"
},
preset: {
anyOf: [ {
type: "boolean"
}, {
type: "string"
} ]
},
providedExports: {
type: "boolean"
},
publicPath: {
type: "boolean"
},
reasons: {
type: "boolean"
},
reasonsSpace: {
type: "number"
},
relatedAssets: {
type: "boolean"
},
runtime: {
type: "boolean"
},
runtimeModules: {
type: "boolean"
},
source: {
type: "boolean"
},
timings: {
type: "boolean"
},
usedExports: {
type: "boolean"
},
version: {
type: "boolean"
},
warnings: {
type: "boolean"
},
warningsCount: {
type: "boolean"
},
warningsFilter: {
oneOf: [ {
$ref: "#/definitions/WarningFilterTypes"
} ]
}
};
function Fe(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1;
const u = i;
if (i === u) if (Array.isArray(t)) {
const n = t.length;
for (let r = 0; r < n; r++) {
let n = t[r];
const s = i, o = i;
let l = !1, p = null;
const u = i, c = i;
let m = !1;
const y = i;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = y === i;
if (m = m || f, !m) {
const t = i;
if (i === t) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f = t === i, m = m || f, !m) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = e === i, m = m || f;
}
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (u === i && (l = !0, p = 0), l) i = o, null !== a && (o ? a.length = o : a = null); else {
const e = {
params: {
passingSchemas: p
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (s !== i) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var c = u === i;
if (p = p || c, !p) {
const n = i, r = i;
let s = !1;
const o = i;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var m = o === i;
if (s = s || m, !s) {
const n = i;
if (i === n) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (m = n === i, s = s || m, !s) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
m = e === i, s = s || m;
}
}
if (s) i = r, null !== a && (r ? a.length = r : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
c = n === i, p = p || c;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, Fe.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), Fe.errors = a, 0 === i;
}
function Re(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1;
const u = i;
if (i === u) if (Array.isArray(t)) {
const n = t.length;
for (let r = 0; r < n; r++) {
let n = t[r];
const s = i, o = i;
let l = !1, p = null;
const u = i, c = i;
let m = !1;
const y = i;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = y === i;
if (m = m || f, !m) {
const t = i;
if (i === t) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f = t === i, m = m || f, !m) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = e === i, m = m || f;
}
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (u === i && (l = !0, p = 0), l) i = o, null !== a && (o ? a.length = o : a = null); else {
const e = {
params: {
passingSchemas: p
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (s !== i) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var c = u === i;
if (p = p || c, !p) {
const n = i, r = i;
let s = !1;
const o = i;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var m = o === i;
if (s = s || m, !s) {
const n = i;
if (i === n) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (m = n === i, s = s || m, !s) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
m = e === i, s = s || m;
}
}
if (s) i = r, null !== a && (r ? a.length = r : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
c = n === i, p = p || c;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, Re.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), Re.errors = a, 0 === i;
}
function Ee(t, {instancePath: n = "", parentData: r, parentDataProperty: s, rootData: o = t} = {}) {
let a = null, i = 0;
const l = i;
let p = !1;
const u = i;
if (i === u) if (Array.isArray(t)) {
const n = t.length;
for (let r = 0; r < n; r++) {
let n = t[r];
const s = i, o = i;
let l = !1, p = null;
const u = i, c = i;
let m = !1;
const y = i;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var f = y === i;
if (m = m || f, !m) {
const t = i;
if (i === t) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (f = t === i, m = m || f, !m) {
const e = i;
if (!(n instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
f = e === i, m = m || f;
}
}
if (m) i = c, null !== a && (c ? a.length = c : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (u === i && (l = !0, p = 0), l) i = o, null !== a && (o ? a.length = o : a = null); else {
const e = {
params: {
passingSchemas: p
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (s !== i) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var c = u === i;
if (p = p || c, !p) {
const n = i, r = i;
let s = !1;
const o = i;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
var m = o === i;
if (s = s || m, !s) {
const n = i;
if (i === n) if ("string" == typeof t) {
if (t.includes("!") || !1 !== e.test(t)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === a ? a = [ e ] : a.push(e), i++;
}
if (m = n === i, s = s || m, !s) {
const e = i;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
m = e === i, s = s || m;
}
}
if (s) i = r, null !== a && (r ? a.length = r : a = null); else {
const e = {
params: {}
};
null === a ? a = [ e ] : a.push(e), i++;
}
c = n === i, p = p || c;
}
if (!p) {
const e = {
params: {}
};
return null === a ? a = [ e ] : a.push(e), i++, Ee.errors = a, !1;
}
return i = l, null !== a && (l ? a.length = l : a = null), Ee.errors = a, 0 === i;
}
function $e(t, {instancePath: r = "", parentData: s, parentDataProperty: o, rootData: a = t} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return $e.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = l;
for (const e in t) if (!n.call(Oe, e)) return $e.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (s === l) {
if (void 0 !== t.all) {
const e = l;
if ("boolean" != typeof t.all) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.assets) {
const e = l;
if ("boolean" != typeof t.assets) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.assetsSort) {
const e = l;
if ("string" != typeof t.assetsSort) return $e.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.assetsSpace) {
const e = l;
if ("number" != typeof t.assetsSpace) return $e.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.builtAt) {
const e = l;
if ("boolean" != typeof t.builtAt) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.cached) {
const e = l;
if ("boolean" != typeof t.cached) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.cachedAssets) {
const e = l;
if ("boolean" != typeof t.cachedAssets) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.cachedModules) {
const e = l;
if ("boolean" != typeof t.cachedModules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.children) {
const e = l;
if ("boolean" != typeof t.children) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkGroupAuxiliary) {
const e = l;
if ("boolean" != typeof t.chunkGroupAuxiliary) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkGroupChildren) {
const e = l;
if ("boolean" != typeof t.chunkGroupChildren) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkGroupMaxAssets) {
const e = l;
if ("number" != typeof t.chunkGroupMaxAssets) return $e.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkGroups) {
const e = l;
if ("boolean" != typeof t.chunkGroups) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkModules) {
const e = l;
if ("boolean" != typeof t.chunkModules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkModulesSpace) {
const e = l;
if ("number" != typeof t.chunkModulesSpace) return $e.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkOrigins) {
const e = l;
if ("boolean" != typeof t.chunkOrigins) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunkRelations) {
const e = l;
if ("boolean" != typeof t.chunkRelations) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunks) {
const e = l;
if ("boolean" != typeof t.chunks) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.chunksSort) {
const e = l;
if ("string" != typeof t.chunksSort) return $e.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.colors) {
let e = t.colors;
const n = l, r = l;
let s = !1;
const o = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var u = o === l;
if (s = s || u, !s) {
const t = l;
if (l === t) if (e && "object" == typeof e && !Array.isArray(e)) {
const t = l;
for (const t in e) if ("bold" !== t && "cyan" !== t && "green" !== t && "magenta" !== t && "red" !== t && "yellow" !== t) {
const e = {
params: {
additionalProperty: t
}
};
null === i ? i = [ e ] : i.push(e), l++;
break;
}
if (t === l) {
if (void 0 !== e.bold) {
const t = l;
if ("string" != typeof e.bold) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var f = t === l;
} else f = !0;
if (f) {
if (void 0 !== e.cyan) {
const t = l;
if ("string" != typeof e.cyan) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l;
} else f = !0;
if (f) {
if (void 0 !== e.green) {
const t = l;
if ("string" != typeof e.green) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l;
} else f = !0;
if (f) {
if (void 0 !== e.magenta) {
const t = l;
if ("string" != typeof e.magenta) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l;
} else f = !0;
if (f) {
if (void 0 !== e.red) {
const t = l;
if ("string" != typeof e.red) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l;
} else f = !0;
if (f) if (void 0 !== e.yellow) {
const t = l;
if ("string" != typeof e.yellow) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
f = t === l;
} else f = !0;
}
}
}
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
u = t === l, s = s || u;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.context) {
let n = t.context;
const r = l;
if (l === r) {
if ("string" != typeof n) return $e.errors = [ {
params: {
type: "string"
}
} ], !1;
if (n.includes("!") || !0 !== e.test(n)) return $e.errors = [ {
params: {}
} ], !1;
}
p = r === l;
} else p = !0;
if (p) {
if (void 0 !== t.dependentModules) {
const e = l;
if ("boolean" != typeof t.dependentModules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.depth) {
const e = l;
if ("boolean" != typeof t.depth) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.entrypoints) {
let e = t.entrypoints;
const n = l, r = l;
let s = !1;
const o = l;
if ("auto" !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var c = o === l;
if (s = s || c, !s) {
const t = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
c = t === l, s = s || c;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.env) {
const e = l;
if ("boolean" != typeof t.env) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.errorDetails) {
let e = t.errorDetails;
const n = l, r = l;
let s = !1;
const o = l;
if ("auto" !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var m = o === l;
if (s = s || m, !s) {
const t = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
m = t === l, s = s || m;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.errorStack) {
const e = l;
if ("boolean" != typeof t.errorStack) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.errors) {
const e = l;
if ("boolean" != typeof t.errors) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.errorsCount) {
const e = l;
if ("boolean" != typeof t.errorsCount) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.exclude) {
let e = t.exclude;
const n = l, s = l;
let o = !1;
const u = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var y = u === l;
if (o = o || y, !o) {
const n = l;
Fe(e, {
instancePath: r + "/exclude",
parentData: t,
parentDataProperty: "exclude",
rootData: a
}) || (i = null === i ? Fe.errors : i.concat(Fe.errors), l = i.length), y = n === l, 
o = o || y;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = s, null !== i && (s ? i.length = s : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.excludeAssets) {
const e = l, n = l;
let s = !1, o = null;
const u = l;
if (Re(t.excludeAssets, {
instancePath: r + "/excludeAssets",
parentData: t,
parentDataProperty: "excludeAssets",
rootData: a
}) || (i = null === i ? Re.errors : i.concat(Re.errors), l = i.length), u === l && (s = !0, 
o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = n, null !== i && (n ? i.length = n : i = null), p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.excludeModules) {
let e = t.excludeModules;
const n = l, s = l;
let o = !1;
const u = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var h = u === l;
if (o = o || h, !o) {
const n = l;
Fe(e, {
instancePath: r + "/excludeModules",
parentData: t,
parentDataProperty: "excludeModules",
rootData: a
}) || (i = null === i ? Fe.errors : i.concat(Fe.errors), l = i.length), h = n === l, 
o = o || h;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = s, null !== i && (s ? i.length = s : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupAssetsByChunk) {
const e = l;
if ("boolean" != typeof t.groupAssetsByChunk) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupAssetsByEmitStatus) {
const e = l;
if ("boolean" != typeof t.groupAssetsByEmitStatus) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupAssetsByExtension) {
const e = l;
if ("boolean" != typeof t.groupAssetsByExtension) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupAssetsByInfo) {
const e = l;
if ("boolean" != typeof t.groupAssetsByInfo) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupAssetsByPath) {
const e = l;
if ("boolean" != typeof t.groupAssetsByPath) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupModulesByAttributes) {
const e = l;
if ("boolean" != typeof t.groupModulesByAttributes) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupModulesByCacheStatus) {
const e = l;
if ("boolean" != typeof t.groupModulesByCacheStatus) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupModulesByExtension) {
const e = l;
if ("boolean" != typeof t.groupModulesByExtension) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupModulesByLayer) {
const e = l;
if ("boolean" != typeof t.groupModulesByLayer) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupModulesByPath) {
const e = l;
if ("boolean" != typeof t.groupModulesByPath) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupModulesByType) {
const e = l;
if ("boolean" != typeof t.groupModulesByType) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.groupReasonsByOrigin) {
const e = l;
if ("boolean" != typeof t.groupReasonsByOrigin) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.hash) {
const e = l;
if ("boolean" != typeof t.hash) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.ids) {
const e = l;
if ("boolean" != typeof t.ids) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.logging) {
let e = t.logging;
const n = l, r = l;
let s = !1;
const o = l;
if ("none" !== e && "error" !== e && "warn" !== e && "info" !== e && "log" !== e && "verbose" !== e) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var d = o === l;
if (s = s || d, !s) {
const t = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
d = t === l, s = s || d;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.loggingDebug) {
let e = t.loggingDebug;
const n = l, s = l;
let o = !1;
const u = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var g = u === l;
if (o = o || g, !o) {
const n = l;
O(e, {
instancePath: r + "/loggingDebug",
parentData: t,
parentDataProperty: "loggingDebug",
rootData: a
}) || (i = null === i ? O.errors : i.concat(O.errors), l = i.length), g = n === l, 
o = o || g;
}
if (!o) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = s, null !== i && (s ? i.length = s : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.loggingTrace) {
const e = l;
if ("boolean" != typeof t.loggingTrace) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.moduleAssets) {
const e = l;
if ("boolean" != typeof t.moduleAssets) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.moduleTrace) {
const e = l;
if ("boolean" != typeof t.moduleTrace) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.modules) {
const e = l;
if ("boolean" != typeof t.modules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.modulesSort) {
const e = l;
if ("string" != typeof t.modulesSort) return $e.errors = [ {
params: {
type: "string"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.modulesSpace) {
const e = l;
if ("number" != typeof t.modulesSpace) return $e.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.nestedModules) {
const e = l;
if ("boolean" != typeof t.nestedModules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.nestedModulesSpace) {
const e = l;
if ("number" != typeof t.nestedModulesSpace) return $e.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.optimizationBailout) {
const e = l;
if ("boolean" != typeof t.optimizationBailout) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.orphanModules) {
const e = l;
if ("boolean" != typeof t.orphanModules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.outputPath) {
const e = l;
if ("boolean" != typeof t.outputPath) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.performance) {
const e = l;
if ("boolean" != typeof t.performance) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.preset) {
let e = t.preset;
const n = l, r = l;
let s = !1;
const o = l;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
var b = o === l;
if (s = s || b, !s) {
const t = l;
if ("string" != typeof e) {
const e = {
params: {
type: "string"
}
};
null === i ? i = [ e ] : i.push(e), l++;
}
b = t === l, s = s || b;
}
if (!s) {
const e = {
params: {}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = r, null !== i && (r ? i.length = r : i = null), p = n === l;
} else p = !0;
if (p) {
if (void 0 !== t.providedExports) {
const e = l;
if ("boolean" != typeof t.providedExports) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.publicPath) {
const e = l;
if ("boolean" != typeof t.publicPath) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.reasons) {
const e = l;
if ("boolean" != typeof t.reasons) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.reasonsSpace) {
const e = l;
if ("number" != typeof t.reasonsSpace) return $e.errors = [ {
params: {
type: "number"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.relatedAssets) {
const e = l;
if ("boolean" != typeof t.relatedAssets) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.runtime) {
const e = l;
if ("boolean" != typeof t.runtime) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.runtimeModules) {
const e = l;
if ("boolean" != typeof t.runtimeModules) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.source) {
const e = l;
if ("boolean" != typeof t.source) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.timings) {
const e = l;
if ("boolean" != typeof t.timings) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.usedExports) {
const e = l;
if ("boolean" != typeof t.usedExports) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.version) {
const e = l;
if ("boolean" != typeof t.version) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.warnings) {
const e = l;
if ("boolean" != typeof t.warnings) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) {
if (void 0 !== t.warningsCount) {
const e = l;
if ("boolean" != typeof t.warningsCount) return $e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
p = e === l;
} else p = !0;
if (p) if (void 0 !== t.warningsFilter) {
const e = l, n = l;
let s = !1, o = null;
const u = l;
if (Ee(t.warningsFilter, {
instancePath: r + "/warningsFilter",
parentData: t,
parentDataProperty: "warningsFilter",
rootData: a
}) || (i = null === i ? Ee.errors : i.concat(Ee.errors), l = i.length), u === l && (s = !0, 
o = 0), !s) {
const e = {
params: {
passingSchemas: o
}
};
return null === i ? i = [ e ] : i.push(e), l++, $e.errors = i, !1;
}
l = n, null !== i && (n ? i.length = n : i = null), p = e === l;
} else p = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return $e.errors = i, 0 === l;
}
function ze(e, {instancePath: t = "", parentData: n, parentDataProperty: r, rootData: s = e} = {}) {
let o = null, a = 0;
const i = a;
let l = !1;
const p = a;
if ("none" !== e && "summary" !== e && "errors-only" !== e && "errors-warnings" !== e && "minimal" !== e && "normal" !== e && "detailed" !== e && "verbose" !== e) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var u = p === a;
if (l = l || u, !l) {
const i = a;
if ("boolean" != typeof e) {
const e = {
params: {
type: "boolean"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u = i === a, l = l || u, !l) {
const i = a;
$e(e, {
instancePath: t,
parentData: n,
parentDataProperty: r,
rootData: s
}) || (o = null === o ? $e.errors : o.concat($e.errors), a = o.length), u = i === a, 
l = l || u;
}
}
if (!l) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, ze.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), ze.errors = o, 0 === a;
}
const Le = new RegExp("^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$", "u");
function we(r, {instancePath: s = "", parentData: a, parentDataProperty: i, rootData: l = r} = {}) {
let p = null, u = 0;
if (0 === u) {
if (!r || "object" != typeof r || Array.isArray(r)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const a = u;
for (const e in r) if (!n.call(t, e)) return we.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (a === u) {
if (void 0 !== r.amd) {
let e = r.amd;
const t = u, n = u;
let s = !1;
const o = u;
if (!1 !== e) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var f = o === u;
if (s = s || f, !s) {
const t = u;
if (!e || "object" != typeof e || Array.isArray(e)) {
const e = {
params: {
type: "object"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
f = t === u, s = s || f;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = n, null !== p && (n ? p.length = n : p = null);
var c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.bail) {
const e = u;
if ("boolean" != typeof r.bail) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.cache) {
const e = u;
o(r.cache, {
instancePath: s + "/cache",
parentData: r,
parentDataProperty: "cache",
rootData: l
}) || (p = null === p ? o.errors : p.concat(o.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.context) {
let t = r.context;
const n = u;
if (u == u) {
if ("string" != typeof t) return we.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.includes("!") || !0 !== e.test(t)) return we.errors = [ {
params: {}
} ], !1;
}
c = n === u;
} else c = !0;
if (c) {
if (void 0 !== r.dependencies) {
let e = r.dependencies;
const t = u;
if (u == u) {
if (!Array.isArray(e)) return we.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
const t = u;
if ("string" != typeof e[n]) return we.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t !== u) break;
}
}
}
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.devServer) {
let e = r.devServer;
const t = u;
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.devtool) {
let e = r.devtool;
const t = u, n = u;
let s = !1;
const o = u;
if (!1 !== e && "eval" !== e) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var m = o === u;
if (s = s || m, !s) {
const t = u;
if (u === t) if ("string" == typeof e) {
if (!Le.test(e)) {
const e = {
params: {
pattern: "^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
m = t === u, s = s || m;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = n, null !== p && (n ? p.length = n : p = null), c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.entry) {
const e = u;
b(r.entry, {
instancePath: s + "/entry",
parentData: r,
parentDataProperty: "entry",
rootData: l
}) || (p = null === p ? b.errors : p.concat(b.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.experiments) {
const e = u;
k(r.experiments, {
instancePath: s + "/experiments",
parentData: r,
parentDataProperty: "experiments",
rootData: l
}) || (p = null === p ? k.errors : p.concat(k.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.externals) {
const e = u;
C(r.externals, {
instancePath: s + "/externals",
parentData: r,
parentDataProperty: "externals",
rootData: l
}) || (p = null === p ? C.errors : p.concat(C.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.externalsPresets) {
let e = r.externalsPresets;
const t = u;
if (u == u) {
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if ("electron" !== t && "electronMain" !== t && "electronPreload" !== t && "electronRenderer" !== t && "node" !== t && "nwjs" !== t && "web" !== t && "webAsync" !== t) return we.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.electron) {
const t = u;
if ("boolean" != typeof e.electron) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var y = t === u;
} else y = !0;
if (y) {
if (void 0 !== e.electronMain) {
const t = u;
if ("boolean" != typeof e.electronMain) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== e.electronPreload) {
const t = u;
if ("boolean" != typeof e.electronPreload) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== e.electronRenderer) {
const t = u;
if ("boolean" != typeof e.electronRenderer) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== e.node) {
const t = u;
if ("boolean" != typeof e.node) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== e.nwjs) {
const t = u;
if ("boolean" != typeof e.nwjs) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== e.web) {
const t = u;
if ("boolean" != typeof e.web) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
if (y) if (void 0 !== e.webAsync) {
const t = u;
if ("boolean" != typeof e.webAsync) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
y = t === u;
} else y = !0;
}
}
}
}
}
}
}
}
}
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.externalsType) {
let e = r.externalsType;
const t = u;
if ("var" !== e && "module" !== e && "assign" !== e && "this" !== e && "window" !== e && "self" !== e && "global" !== e && "commonjs" !== e && "commonjs2" !== e && "commonjs-module" !== e && "commonjs-static" !== e && "amd" !== e && "amd-require" !== e && "umd" !== e && "umd2" !== e && "jsonp" !== e && "system" !== e && "promise" !== e && "import" !== e && "script" !== e && "node-commonjs" !== e) return we.errors = [ {
params: {}
} ], !1;
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.ignoreWarnings) {
let e = r.ignoreWarnings;
const t = u;
if (u == u) {
if (!Array.isArray(e)) return we.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = u, s = u;
let o = !1;
const a = u;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var h = a === u;
if (o = o || h, !o) {
const e = u;
if (u === e) if (t && "object" == typeof t && !Array.isArray(t)) {
const e = u;
for (const e in t) if ("file" !== e && "message" !== e && "module" !== e) {
const t = {
params: {
additionalProperty: e
}
};
null === p ? p = [ t ] : p.push(t), u++;
break;
}
if (e === u) {
if (void 0 !== t.file) {
const e = u;
if (!(t.file instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var d = e === u;
} else d = !0;
if (d) {
if (void 0 !== t.message) {
const e = u;
if (!(t.message instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
if (d) if (void 0 !== t.module) {
const e = u;
if (!(t.module instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
d = e === u;
} else d = !0;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (h = e === u, o = o || h, !o) {
const e = u;
if (!(t instanceof Function)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
h = e === u, o = o || h;
}
}
if (!o) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
if (u = s, null !== p && (s ? p.length = s : p = null), r !== u) break;
}
}
}
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.infrastructureLogging) {
const e = u;
F(r.infrastructureLogging, {
instancePath: s + "/infrastructureLogging",
parentData: r,
parentDataProperty: "infrastructureLogging",
rootData: l
}) || (p = null === p ? F.errors : p.concat(F.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.loader) {
let e = r.loader;
const t = u;
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.mode) {
let e = r.mode;
const t = u;
if ("development" !== e && "production" !== e && "none" !== e) return we.errors = [ {
params: {}
} ], !1;
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.module) {
const e = u;
oe(r.module, {
instancePath: s + "/module",
parentData: r,
parentDataProperty: "module",
rootData: l
}) || (p = null === p ? oe.errors : p.concat(oe.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.name) {
const e = u;
if ("string" != typeof r.name) return we.errors = [ {
params: {
type: "string"
}
} ], !1;
c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.node) {
const e = u;
ne(r.node, {
instancePath: s + "/node",
parentData: r,
parentDataProperty: "node",
rootData: l
}) || (p = null === p ? ne.errors : p.concat(ne.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.optimization) {
const e = u;
fe(r.optimization, {
instancePath: s + "/optimization",
parentData: r,
parentDataProperty: "optimization",
rootData: l
}) || (p = null === p ? fe.errors : p.concat(fe.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.output) {
const e = u;
xe(r.output, {
instancePath: s + "/output",
parentData: r,
parentDataProperty: "output",
rootData: l
}) || (p = null === p ? xe.errors : p.concat(xe.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.parallelism) {
let e = r.parallelism;
const t = u;
if (u == u) {
if ("number" != typeof e) return we.errors = [ {
params: {
type: "number"
}
} ], !1;
if (e < 1 || isNaN(e)) return we.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.performance) {
const e = u;
ke(r.performance, {
instancePath: s + "/performance",
parentData: r,
parentDataProperty: "performance",
rootData: l
}) || (p = null === p ? ke.errors : p.concat(ke.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.plugins) {
const e = u;
je(r.plugins, {
instancePath: s + "/plugins",
parentData: r,
parentDataProperty: "plugins",
rootData: l
}) || (p = null === p ? je.errors : p.concat(je.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.profile) {
const e = u;
if ("boolean" != typeof r.profile) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.recordsInputPath) {
let t = r.recordsInputPath;
const n = u, s = u;
let o = !1;
const a = u;
if (!1 !== t) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var g = a === u;
if (o = o || g, !o) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
g = n === u, o = o || g;
}
if (!o) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = s, null !== p && (s ? p.length = s : p = null), c = n === u;
} else c = !0;
if (c) {
if (void 0 !== r.recordsOutputPath) {
let t = r.recordsOutputPath;
const n = u, s = u;
let o = !1;
const a = u;
if (!1 !== t) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var v = a === u;
if (o = o || v, !o) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
v = n === u, o = o || v;
}
if (!o) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = s, null !== p && (s ? p.length = s : p = null), c = n === u;
} else c = !0;
if (c) {
if (void 0 !== r.recordsPath) {
let t = r.recordsPath;
const n = u, s = u;
let o = !1;
const a = u;
if (!1 !== t) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var D = a === u;
if (o = o || D, !o) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
D = n === u, o = o || D;
}
if (!o) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = s, null !== p && (s ? p.length = s : p = null), c = n === u;
} else c = !0;
if (c) {
if (void 0 !== r.resolve) {
const e = u;
Se(r.resolve, {
instancePath: s + "/resolve",
parentData: r,
parentDataProperty: "resolve",
rootData: l
}) || (p = null === p ? Se.errors : p.concat(Se.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.resolveLoader) {
const e = u;
Ce(r.resolveLoader, {
instancePath: s + "/resolveLoader",
parentData: r,
parentDataProperty: "resolveLoader",
rootData: l
}) || (p = null === p ? Ce.errors : p.concat(Ce.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.snapshot) {
let t = r.snapshot;
const n = u;
if (u == u) {
if (!t || "object" != typeof t || Array.isArray(t)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const n = u;
for (const e in t) if ("buildDependencies" !== e && "immutablePaths" !== e && "managedPaths" !== e && "module" !== e && "resolve" !== e && "resolveBuildDependencies" !== e) return we.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (n === u) {
if (void 0 !== t.buildDependencies) {
let e = t.buildDependencies;
const n = u;
if (u === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if ("hash" !== t && "timestamp" !== t) return we.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.hash) {
const t = u;
if ("boolean" != typeof e.hash) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var P = t === u;
} else P = !0;
if (P) if (void 0 !== e.timestamp) {
const t = u;
if ("boolean" != typeof e.timestamp) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
P = t === u;
} else P = !0;
}
}
}
var A = n === u;
} else A = !0;
if (A) {
if (void 0 !== t.immutablePaths) {
let n = t.immutablePaths;
const r = u;
if (u === r) {
if (!Array.isArray(n)) return we.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = n.length;
for (let r = 0; r < t; r++) {
let t = n[r];
const s = u, o = u;
let a = !1;
const i = u;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var x = i === u;
if (a = a || x, !a) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
x = n === u, a = a || x;
}
if (!a) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
if (u = o, null !== p && (o ? p.length = o : p = null), s !== u) break;
}
}
}
A = r === u;
} else A = !0;
if (A) {
if (void 0 !== t.managedPaths) {
let n = t.managedPaths;
const r = u;
if (u === r) {
if (!Array.isArray(n)) return we.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = n.length;
for (let r = 0; r < t; r++) {
let t = n[r];
const s = u, o = u;
let a = !1;
const i = u;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var j = i === u;
if (a = a || j, !a) {
const n = u;
if (u === n) if ("string" == typeof t) {
if (t.includes("!") || !0 !== e.test(t)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
} else if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
j = n === u, a = a || j;
}
if (!a) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
if (u = o, null !== p && (o ? p.length = o : p = null), s !== u) break;
}
}
}
A = r === u;
} else A = !0;
if (A) {
if (void 0 !== t.module) {
let e = t.module;
const n = u;
if (u === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if ("hash" !== t && "timestamp" !== t) return we.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.hash) {
const t = u;
if ("boolean" != typeof e.hash) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var S = t === u;
} else S = !0;
if (S) if (void 0 !== e.timestamp) {
const t = u;
if ("boolean" != typeof e.timestamp) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
S = t === u;
} else S = !0;
}
}
}
A = n === u;
} else A = !0;
if (A) {
if (void 0 !== t.resolve) {
let e = t.resolve;
const n = u;
if (u === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if ("hash" !== t && "timestamp" !== t) return we.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.hash) {
const t = u;
if ("boolean" != typeof e.hash) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var O = t === u;
} else O = !0;
if (O) if (void 0 !== e.timestamp) {
const t = u;
if ("boolean" != typeof e.timestamp) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
O = t === u;
} else O = !0;
}
}
}
A = n === u;
} else A = !0;
if (A) if (void 0 !== t.resolveBuildDependencies) {
let e = t.resolveBuildDependencies;
const n = u;
if (u === n) {
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if ("hash" !== t && "timestamp" !== t) return we.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.hash) {
const t = u;
if ("boolean" != typeof e.hash) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var R = t === u;
} else R = !0;
if (R) if (void 0 !== e.timestamp) {
const t = u;
if ("boolean" != typeof e.timestamp) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
R = t === u;
} else R = !0;
}
}
}
A = n === u;
} else A = !0;
}
}
}
}
}
}
}
c = n === u;
} else c = !0;
if (c) {
if (void 0 !== r.stats) {
const e = u;
ze(r.stats, {
instancePath: s + "/stats",
parentData: r,
parentDataProperty: "stats",
rootData: l
}) || (p = null === p ? ze.errors : p.concat(ze.errors), u = p.length), c = e === u;
} else c = !0;
if (c) {
if (void 0 !== r.target) {
let e = r.target;
const t = u, n = u;
let s = !1;
const o = u;
if (u === o) if (Array.isArray(e)) if (e.length < 1) {
const e = {
params: {
limit: 1
}
};
null === p ? p = [ e ] : p.push(e), u++;
} else {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const r = u;
if (u === r) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (r !== u) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var E = o === u;
if (s = s || E, !s) {
const t = u;
if (!1 !== e) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (E = t === u, s = s || E, !s) {
const t = u;
if (u === t) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
E = t === u, s = s || E;
}
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = n, null !== p && (n ? p.length = n : p = null), c = t === u;
} else c = !0;
if (c) {
if (void 0 !== r.watch) {
const e = u;
if ("boolean" != typeof r.watch) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = e === u;
} else c = !0;
if (c) if (void 0 !== r.watchOptions) {
let e = r.watchOptions;
const t = u;
if (u == u) {
if (!e || "object" != typeof e || Array.isArray(e)) return we.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = u;
for (const t in e) if ("aggregateTimeout" !== t && "followSymlinks" !== t && "ignored" !== t && "poll" !== t && "stdin" !== t) return we.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === u) {
if (void 0 !== e.aggregateTimeout) {
const t = u;
if ("number" != typeof e.aggregateTimeout) return we.errors = [ {
params: {
type: "number"
}
} ], !1;
var $ = t === u;
} else $ = !0;
if ($) {
if (void 0 !== e.followSymlinks) {
const t = u;
if ("boolean" != typeof e.followSymlinks) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
$ = t === u;
} else $ = !0;
if ($) {
if (void 0 !== e.ignored) {
let t = e.ignored;
const n = u, r = u;
let s = !1;
const o = u;
if (u === o) if (Array.isArray(t)) {
const e = t.length;
for (let n = 0; n < e; n++) {
let e = t[n];
const r = u;
if (u === r) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (r !== u) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var z = o === u;
if (s = s || z, !s) {
const e = u;
if (!(t instanceof RegExp)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
if (z = e === u, s = s || z, !s) {
const e = u;
if (u === e) if ("string" == typeof t) {
if (t.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), u++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
z = e === u, s = s || z;
}
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = r, null !== p && (r ? p.length = r : p = null), $ = n === u;
} else $ = !0;
if ($) {
if (void 0 !== e.poll) {
let t = e.poll;
const n = u, r = u;
let s = !1;
const o = u;
if ("number" != typeof t) {
const e = {
params: {
type: "number"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
var L = o === u;
if (s = s || L, !s) {
const e = u;
if ("boolean" != typeof t) {
const e = {
params: {
type: "boolean"
}
};
null === p ? p = [ e ] : p.push(e), u++;
}
L = e === u, s = s || L;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), u++, we.errors = p, !1;
}
u = r, null !== p && (r ? p.length = r : p = null), $ = n === u;
} else $ = !0;
if ($) if (void 0 !== e.stdin) {
const t = u;
if ("boolean" != typeof e.stdin) return we.errors = [ {
params: {
type: "boolean"
}
} ], !1;
$ = t === u;
} else $ = !0;
}
}
}
}
}
}
c = t === u;
} else c = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return we.errors = p, 0 === u;
}
},
89057: module => {
"use strict";
function n(t, {instancePath: l = "", parentData: e, parentDataProperty: s, rootData: a = t} = {}) {
let r = null, o = 0;
const u = o;
let i = !1;
const p = o;
if (o === p) if (Array.isArray(t)) {
const n = t.length;
for (let l = 0; l < n; l++) {
let n = t[l];
const e = o, s = o;
let a = !1, u = null;
const i = o, p = o;
let f = !1;
const h = o;
if (!(n instanceof RegExp)) {
const n = {
params: {}
};
null === r ? r = [ n ] : r.push(n), o++;
}
var c = h === o;
if (f = f || c, !f) {
const t = o;
if (o === t) if ("string" == typeof n) {
if (n.length < 1) {
const n = {
params: {}
};
null === r ? r = [ n ] : r.push(n), o++;
}
} else {
const n = {
params: {
type: "string"
}
};
null === r ? r = [ n ] : r.push(n), o++;
}
c = t === o, f = f || c;
}
if (f) o = p, null !== r && (p ? r.length = p : r = null); else {
const n = {
params: {}
};
null === r ? r = [ n ] : r.push(n), o++;
}
if (i === o && (a = !0, u = 0), a) o = s, null !== r && (s ? r.length = s : r = null); else {
const n = {
params: {
passingSchemas: u
}
};
null === r ? r = [ n ] : r.push(n), o++;
}
if (e !== o) break;
}
} else {
const n = {
params: {
type: "array"
}
};
null === r ? r = [ n ] : r.push(n), o++;
}
var f = p === o;
if (i = i || f, !i) {
const n = o, l = o;
let e = !1;
const s = o;
if (!(t instanceof RegExp)) {
const n = {
params: {}
};
null === r ? r = [ n ] : r.push(n), o++;
}
var h = s === o;
if (e = e || h, !e) {
const n = o;
if (o === n) if ("string" == typeof t) {
if (t.length < 1) {
const n = {
params: {}
};
null === r ? r = [ n ] : r.push(n), o++;
}
} else {
const n = {
params: {
type: "string"
}
};
null === r ? r = [ n ] : r.push(n), o++;
}
h = n === o, e = e || h;
}
if (e) o = l, null !== r && (l ? r.length = l : r = null); else {
const n = {
params: {}
};
null === r ? r = [ n ] : r.push(n), o++;
}
f = n === o, i = i || f;
}
if (!i) {
const t = {
params: {}
};
return null === r ? r = [ t ] : r.push(t), o++, n.errors = r, !1;
}
return o = u, null !== r && (u ? r.length = u : r = null), n.errors = r, 0 === o;
}
function t(l, {instancePath: e = "", parentData: s, parentDataProperty: a, rootData: r = l} = {}) {
let o = null, u = 0;
const i = u;
let p = !1;
const c = u;
if (u === c) if ("string" == typeof l) {
if (l.length < 1) {
const n = {
params: {}
};
null === o ? o = [ n ] : o.push(n), u++;
}
} else {
const n = {
params: {
type: "string"
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
var f = c === u;
if (p = p || f, !p) {
const t = u;
if (u === t) if (l && "object" == typeof l && !Array.isArray(l)) {
let t;
if (void 0 === l.banner && (t = "banner")) {
const n = {
params: {
missingProperty: t
}
};
null === o ? o = [ n ] : o.push(n), u++;
} else {
const t = u;
for (const n in l) if ("banner" !== n && "entryOnly" !== n && "exclude" !== n && "footer" !== n && "include" !== n && "raw" !== n && "test" !== n) {
const t = {
params: {
additionalProperty: n
}
};
null === o ? o = [ t ] : o.push(t), u++;
break;
}
if (t === u) {
if (void 0 !== l.banner) {
let n = l.banner;
const t = u, e = u;
let s = !1;
const a = u;
if ("string" != typeof n) {
const n = {
params: {
type: "string"
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
var h = a === u;
if (s = s || h, !s) {
const t = u;
if (!(n instanceof Function)) {
const n = {
params: {}
};
null === o ? o = [ n ] : o.push(n), u++;
}
h = t === u, s = s || h;
}
if (s) u = e, null !== o && (e ? o.length = e : o = null); else {
const n = {
params: {}
};
null === o ? o = [ n ] : o.push(n), u++;
}
var y = t === u;
} else y = !0;
if (y) {
if (void 0 !== l.entryOnly) {
const n = u;
if ("boolean" != typeof l.entryOnly) {
const n = {
params: {
type: "boolean"
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== l.exclude) {
const t = u, s = u;
let a = !1, i = null;
const p = u;
if (n(l.exclude, {
instancePath: e + "/exclude",
parentData: l,
parentDataProperty: "exclude",
rootData: r
}) || (o = null === o ? n.errors : o.concat(n.errors), u = o.length), p === u && (a = !0, 
i = 0), a) u = s, null !== o && (s ? o.length = s : o = null); else {
const n = {
params: {
passingSchemas: i
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== l.footer) {
const n = u;
if ("boolean" != typeof l.footer) {
const n = {
params: {
type: "boolean"
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
y = n === u;
} else y = !0;
if (y) {
if (void 0 !== l.include) {
const t = u, s = u;
let a = !1, i = null;
const p = u;
if (n(l.include, {
instancePath: e + "/include",
parentData: l,
parentDataProperty: "include",
rootData: r
}) || (o = null === o ? n.errors : o.concat(n.errors), u = o.length), p === u && (a = !0, 
i = 0), a) u = s, null !== o && (s ? o.length = s : o = null); else {
const n = {
params: {
passingSchemas: i
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
y = t === u;
} else y = !0;
if (y) {
if (void 0 !== l.raw) {
const n = u;
if ("boolean" != typeof l.raw) {
const n = {
params: {
type: "boolean"
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
y = n === u;
} else y = !0;
if (y) if (void 0 !== l.test) {
const t = u, s = u;
let a = !1, i = null;
const p = u;
if (n(l.test, {
instancePath: e + "/test",
parentData: l,
parentDataProperty: "test",
rootData: r
}) || (o = null === o ? n.errors : o.concat(n.errors), u = o.length), p === u && (a = !0, 
i = 0), a) u = s, null !== o && (s ? o.length = s : o = null); else {
const n = {
params: {
passingSchemas: i
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
y = t === u;
} else y = !0;
}
}
}
}
}
}
}
} else {
const n = {
params: {
type: "object"
}
};
null === o ? o = [ n ] : o.push(n), u++;
}
if (f = t === u, p = p || f, !p) {
const n = u;
if (!(l instanceof Function)) {
const n = {
params: {}
};
null === o ? o = [ n ] : o.push(n), u++;
}
f = n === u, p = p || f;
}
}
if (!p) {
const n = {
params: {}
};
return null === o ? o = [ n ] : o.push(n), u++, t.errors = o, !1;
}
return u = i, null !== o && (i ? o.length = i : o = null), t.errors = o, 0 === u;
}
module.exports = t, module.exports.default = t;
},
65662: module => {
"use strict";
function r(e, {instancePath: t = "", parentData: o, parentDataProperty: n, rootData: a = e} = {}) {
if (!e || "object" != typeof e || Array.isArray(e)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let t;
if (void 0 === e.path && (t = "path")) return r.errors = [ {
params: {
missingProperty: t
}
} ], !1;
{
const t = 0;
for (const t in e) if ("context" !== t && "entryOnly" !== t && "format" !== t && "name" !== t && "path" !== t && "type" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (0 === t) {
if (void 0 !== e.context) {
let t = e.context;
const o = 0;
if (0 === o) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
var s = 0 === o;
} else s = !0;
if (s) {
if (void 0 !== e.entryOnly) {
const t = 0;
if ("boolean" != typeof e.entryOnly) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
s = 0 === t;
} else s = !0;
if (s) {
if (void 0 !== e.format) {
const t = 0;
if ("boolean" != typeof e.format) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
s = 0 === t;
} else s = !0;
if (s) {
if (void 0 !== e.name) {
let t = e.name;
const o = 0;
if (0 === o) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
s = 0 === o;
} else s = !0;
if (s) {
if (void 0 !== e.path) {
let t = e.path;
const o = 0;
if (0 === o) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
s = 0 === o;
} else s = !0;
if (s) if (void 0 !== e.type) {
let t = e.type;
const o = 0;
if (0 === o) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
s = 0 === o;
} else s = !0;
}
}
}
}
}
}
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
7178: module => {
const s = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function t(s, {instancePath: e = "", parentData: n, parentDataProperty: l, rootData: o = s} = {}) {
let r = null, i = 0;
if (0 === i) {
if (!s || "object" != typeof s || Array.isArray(s)) return t.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === s.content && (e = "content")) return t.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = i;
for (const e in s) if ("content" !== e && "name" !== e && "type" !== e) return t.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (e === i) {
if (void 0 !== s.content) {
let e = s.content;
const n = i, l = i;
let o = !1, f = null;
const m = i;
if (i == i) if (e && "object" == typeof e && !Array.isArray(e)) if (Object.keys(e).length < 1) {
const s = {
params: {
limit: 1
}
};
null === r ? r = [ s ] : r.push(s), i++;
} else for (const s in e) {
let t = e[s];
const n = i;
if (i === n) if (t && "object" == typeof t && !Array.isArray(t)) {
let s;
if (void 0 === t.id && (s = "id")) {
const t = {
params: {
missingProperty: s
}
};
null === r ? r = [ t ] : r.push(t), i++;
} else {
const s = i;
for (const s in t) if ("buildMeta" !== s && "exports" !== s && "id" !== s) {
const t = {
params: {
additionalProperty: s
}
};
null === r ? r = [ t ] : r.push(t), i++;
break;
}
if (s === i) {
if (void 0 !== t.buildMeta) {
let s = t.buildMeta;
const e = i;
if (!s || "object" != typeof s || Array.isArray(s)) {
const s = {
params: {
type: "object"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
var a = e === i;
} else a = !0;
if (a) {
if (void 0 !== t.exports) {
let s = t.exports;
const e = i, n = i;
let l = !1;
const o = i;
if (i === o) if (Array.isArray(s)) {
const t = s.length;
for (let e = 0; e < t; e++) {
let t = s[e];
const n = i;
if (i === n) if ("string" == typeof t) {
if (t.length < 1) {
const s = {
params: {}
};
null === r ? r = [ s ] : r.push(s), i++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
if (n !== i) break;
}
} else {
const s = {
params: {
type: "array"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
var p = o === i;
if (l = l || p, !l) {
const t = i;
if (!0 !== s) {
const s = {
params: {}
};
null === r ? r = [ s ] : r.push(s), i++;
}
p = t === i, l = l || p;
}
if (l) i = n, null !== r && (n ? r.length = n : r = null); else {
const s = {
params: {}
};
null === r ? r = [ s ] : r.push(s), i++;
}
a = e === i;
} else a = !0;
if (a) if (void 0 !== t.id) {
let s = t.id;
const e = i, n = i;
let l = !1;
const o = i;
if ("number" != typeof s) {
const s = {
params: {
type: "number"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
var u = o === i;
if (l = l || u, !l) {
const t = i;
if (i === t) if ("string" == typeof s) {
if (s.length < 1) {
const s = {
params: {}
};
null === r ? r = [ s ] : r.push(s), i++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
u = t === i, l = l || u;
}
if (l) i = n, null !== r && (n ? r.length = n : r = null); else {
const s = {
params: {}
};
null === r ? r = [ s ] : r.push(s), i++;
}
a = e === i;
} else a = !0;
}
}
}
} else {
const s = {
params: {
type: "object"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
if (n !== i) break;
} else {
const s = {
params: {
type: "object"
}
};
null === r ? r = [ s ] : r.push(s), i++;
}
if (m === i && (o = !0, f = 0), !o) {
const s = {
params: {
passingSchemas: f
}
};
return null === r ? r = [ s ] : r.push(s), i++, t.errors = r, !1;
}
i = l, null !== r && (l ? r.length = l : r = null);
var c = n === i;
} else c = !0;
if (c) {
if (void 0 !== s.name) {
let e = s.name;
const n = i;
if (i === n) {
if ("string" != typeof e) return t.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return t.errors = [ {
params: {}
} ], !1;
}
c = n === i;
} else c = !0;
if (c) if (void 0 !== s.type) {
let e = s.type;
const n = i, l = i;
let o = !1, a = null;
const p = i;
if ("var" !== e && "assign" !== e && "this" !== e && "window" !== e && "global" !== e && "commonjs" !== e && "commonjs2" !== e && "commonjs-module" !== e && "amd" !== e && "amd-require" !== e && "umd" !== e && "umd2" !== e && "jsonp" !== e && "system" !== e) {
const s = {
params: {}
};
null === r ? r = [ s ] : r.push(s), i++;
}
if (p === i && (o = !0, a = 0), !o) {
const s = {
params: {
passingSchemas: a
}
};
return null === r ? r = [ s ] : r.push(s), i++, t.errors = r, !1;
}
i = l, null !== r && (l ? r.length = l : r = null), c = n === i;
} else c = !0;
}
}
}
}
}
return t.errors = r, 0 === i;
}
function e(n, {instancePath: l = "", parentData: o, parentDataProperty: r, rootData: i = n} = {}) {
let a = null, p = 0;
const u = p;
let c = !1;
const f = p;
if (p === f) if (n && "object" == typeof n && !Array.isArray(n)) {
let e;
if (void 0 === n.manifest && (e = "manifest")) {
const s = {
params: {
missingProperty: e
}
};
null === a ? a = [ s ] : a.push(s), p++;
} else {
const e = p;
for (const s in n) if ("context" !== s && "extensions" !== s && "manifest" !== s && "name" !== s && "scope" !== s && "sourceType" !== s && "type" !== s) {
const t = {
params: {
additionalProperty: s
}
};
null === a ? a = [ t ] : a.push(t), p++;
break;
}
if (e === p) {
if (void 0 !== n.context) {
let t = n.context;
const e = p;
if (p === e) if ("string" == typeof t) {
if (t.includes("!") || !0 !== s.test(t)) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var m = e === p;
} else m = !0;
if (m) {
if (void 0 !== n.extensions) {
let s = n.extensions;
const t = p;
if (p === t) if (Array.isArray(s)) {
const t = s.length;
for (let e = 0; e < t; e++) {
const t = p;
if ("string" != typeof s[e]) {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (t !== p) break;
}
} else {
const s = {
params: {
type: "array"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
m = t === p;
} else m = !0;
if (m) {
if (void 0 !== n.manifest) {
let e = n.manifest;
const o = p, r = p;
let u = !1;
const c = p;
if (p === c) if ("string" == typeof e) {
if (e.includes("!") || !0 !== s.test(e)) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var y = c === p;
if (u = u || y, !u) {
const s = p;
t(e, {
instancePath: l + "/manifest",
parentData: n,
parentDataProperty: "manifest",
rootData: i
}) || (a = null === a ? t.errors : a.concat(t.errors), p = a.length), y = s === p, 
u = u || y;
}
if (u) p = r, null !== a && (r ? a.length = r : a = null); else {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
m = o === p;
} else m = !0;
if (m) {
if (void 0 !== n.name) {
let s = n.name;
const t = p;
if (p === t) if ("string" == typeof s) {
if (s.length < 1) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
m = t === p;
} else m = !0;
if (m) {
if (void 0 !== n.scope) {
let s = n.scope;
const t = p;
if (p === t) if ("string" == typeof s) {
if (s.length < 1) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
m = t === p;
} else m = !0;
if (m) {
if (void 0 !== n.sourceType) {
let s = n.sourceType;
const t = p, e = p;
let l = !1, o = null;
const r = p;
if ("var" !== s && "assign" !== s && "this" !== s && "window" !== s && "global" !== s && "commonjs" !== s && "commonjs2" !== s && "commonjs-module" !== s && "amd" !== s && "amd-require" !== s && "umd" !== s && "umd2" !== s && "jsonp" !== s && "system" !== s) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (r === p && (l = !0, o = 0), l) p = e, null !== a && (e ? a.length = e : a = null); else {
const s = {
params: {
passingSchemas: o
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
m = t === p;
} else m = !0;
if (m) if (void 0 !== n.type) {
let s = n.type;
const t = p;
if ("require" !== s && "object" !== s) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
m = t === p;
} else m = !0;
}
}
}
}
}
}
}
} else {
const s = {
params: {
type: "object"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var h = f === p;
if (c = c || h, !c) {
const t = p;
if (p === t) if (n && "object" == typeof n && !Array.isArray(n)) {
let t;
if (void 0 === n.content && (t = "content") || void 0 === n.name && (t = "name")) {
const s = {
params: {
missingProperty: t
}
};
null === a ? a = [ s ] : a.push(s), p++;
} else {
const t = p;
for (const s in n) if ("content" !== s && "context" !== s && "extensions" !== s && "name" !== s && "scope" !== s && "sourceType" !== s && "type" !== s) {
const t = {
params: {
additionalProperty: s
}
};
null === a ? a = [ t ] : a.push(t), p++;
break;
}
if (t === p) {
if (void 0 !== n.content) {
let s = n.content;
const t = p, e = p;
let l = !1, o = null;
const r = p;
if (p == p) if (s && "object" == typeof s && !Array.isArray(s)) if (Object.keys(s).length < 1) {
const s = {
params: {
limit: 1
}
};
null === a ? a = [ s ] : a.push(s), p++;
} else for (const t in s) {
let e = s[t];
const n = p;
if (p === n) if (e && "object" == typeof e && !Array.isArray(e)) {
let s;
if (void 0 === e.id && (s = "id")) {
const t = {
params: {
missingProperty: s
}
};
null === a ? a = [ t ] : a.push(t), p++;
} else {
const s = p;
for (const s in e) if ("buildMeta" !== s && "exports" !== s && "id" !== s) {
const t = {
params: {
additionalProperty: s
}
};
null === a ? a = [ t ] : a.push(t), p++;
break;
}
if (s === p) {
if (void 0 !== e.buildMeta) {
let s = e.buildMeta;
const t = p;
if (!s || "object" != typeof s || Array.isArray(s)) {
const s = {
params: {
type: "object"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var d = t === p;
} else d = !0;
if (d) {
if (void 0 !== e.exports) {
let s = e.exports;
const t = p, n = p;
let l = !1;
const o = p;
if (p === o) if (Array.isArray(s)) {
const t = s.length;
for (let e = 0; e < t; e++) {
let t = s[e];
const n = p;
if (p === n) if ("string" == typeof t) {
if (t.length < 1) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (n !== p) break;
}
} else {
const s = {
params: {
type: "array"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var g = o === p;
if (l = l || g, !l) {
const t = p;
if (!0 !== s) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
g = t === p, l = l || g;
}
if (l) p = n, null !== a && (n ? a.length = n : a = null); else {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
d = t === p;
} else d = !0;
if (d) if (void 0 !== e.id) {
let s = e.id;
const t = p, n = p;
let l = !1;
const o = p;
if ("number" != typeof s) {
const s = {
params: {
type: "number"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var b = o === p;
if (l = l || b, !l) {
const t = p;
if (p === t) if ("string" == typeof s) {
if (s.length < 1) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
b = t === p, l = l || b;
}
if (l) p = n, null !== a && (n ? a.length = n : a = null); else {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
d = t === p;
} else d = !0;
}
}
}
} else {
const s = {
params: {
type: "object"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (n !== p) break;
} else {
const s = {
params: {
type: "object"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (r === p && (l = !0, o = 0), l) p = e, null !== a && (e ? a.length = e : a = null); else {
const s = {
params: {
passingSchemas: o
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
var v = t === p;
} else v = !0;
if (v) {
if (void 0 !== n.context) {
let t = n.context;
const e = p;
if (p === e) if ("string" == typeof t) {
if (t.includes("!") || !0 !== s.test(t)) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
v = e === p;
} else v = !0;
if (v) {
if (void 0 !== n.extensions) {
let s = n.extensions;
const t = p;
if (p === t) if (Array.isArray(s)) {
const t = s.length;
for (let e = 0; e < t; e++) {
const t = p;
if ("string" != typeof s[e]) {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (t !== p) break;
}
} else {
const s = {
params: {
type: "array"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
v = t === p;
} else v = !0;
if (v) {
if (void 0 !== n.name) {
let s = n.name;
const t = p;
if (p === t) if ("string" == typeof s) {
if (s.length < 1) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
v = t === p;
} else v = !0;
if (v) {
if (void 0 !== n.scope) {
let s = n.scope;
const t = p;
if (p === t) if ("string" == typeof s) {
if (s.length < 1) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
} else {
const s = {
params: {
type: "string"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
v = t === p;
} else v = !0;
if (v) {
if (void 0 !== n.sourceType) {
let s = n.sourceType;
const t = p, e = p;
let l = !1, o = null;
const r = p;
if ("var" !== s && "assign" !== s && "this" !== s && "window" !== s && "global" !== s && "commonjs" !== s && "commonjs2" !== s && "commonjs-module" !== s && "amd" !== s && "amd-require" !== s && "umd" !== s && "umd2" !== s && "jsonp" !== s && "system" !== s) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
if (r === p && (l = !0, o = 0), l) p = e, null !== a && (e ? a.length = e : a = null); else {
const s = {
params: {
passingSchemas: o
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
v = t === p;
} else v = !0;
if (v) if (void 0 !== n.type) {
let s = n.type;
const t = p;
if ("require" !== s && "object" !== s) {
const s = {
params: {}
};
null === a ? a = [ s ] : a.push(s), p++;
}
v = t === p;
} else v = !0;
}
}
}
}
}
}
}
} else {
const s = {
params: {
type: "object"
}
};
null === a ? a = [ s ] : a.push(s), p++;
}
h = t === p, c = c || h;
}
if (!c) {
const s = {
params: {}
};
return null === a ? a = [ s ] : a.push(s), p++, e.errors = a, !1;
}
return p = u, null !== a && (u ? a.length = u : a = null), e.errors = a, 0 === p;
}
module.exports = e, module.exports.default = e;
},
35227: module => {
const t = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function e(r, {instancePath: s = "", parentData: n, parentDataProperty: a, rootData: i = r} = {}) {
let o = null, l = 0;
if (0 === l) {
if (!r || "object" != typeof r || Array.isArray(r)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = l;
for (const t in r) if ("context" !== t && "hashDigest" !== t && "hashDigestLength" !== t && "hashFunction" !== t) return e.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (s === l) {
if (void 0 !== r.context) {
let s = r.context;
const n = l;
if (l === n) {
if ("string" != typeof s) return e.errors = [ {
params: {
type: "string"
}
} ], !1;
if (s.includes("!") || !0 !== t.test(s)) return e.errors = [ {
params: {}
} ], !1;
}
var u = n === l;
} else u = !0;
if (u) {
if (void 0 !== r.hashDigest) {
let t = r.hashDigest;
const s = l;
if ("hex" !== t && "latin1" !== t && "base64" !== t) return e.errors = [ {
params: {}
} ], !1;
u = s === l;
} else u = !0;
if (u) {
if (void 0 !== r.hashDigestLength) {
let t = r.hashDigestLength;
const s = l;
if (l === s) {
if ("number" != typeof t) return e.errors = [ {
params: {
type: "number"
}
} ], !1;
if (t < 1 || isNaN(t)) return e.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
u = s === l;
} else u = !0;
if (u) if (void 0 !== r.hashFunction) {
let t = r.hashFunction;
const s = l, n = l;
let a = !1, i = null;
const p = l, h = l;
let c = !1;
const m = l;
if (l === m) if ("string" == typeof t) {
if (t.length < 1) {
const t = {
params: {}
};
null === o ? o = [ t ] : o.push(t), l++;
}
} else {
const t = {
params: {
type: "string"
}
};
null === o ? o = [ t ] : o.push(t), l++;
}
var f = m === l;
if (c = c || f, !c) {
const e = l;
if (!(t instanceof Function)) {
const t = {
params: {}
};
null === o ? o = [ t ] : o.push(t), l++;
}
f = e === l, c = c || f;
}
if (c) l = h, null !== o && (h ? o.length = h : o = null); else {
const t = {
params: {}
};
null === o ? o = [ t ] : o.push(t), l++;
}
if (p === l && (a = !0, i = 0), !a) {
const t = {
params: {
passingSchemas: i
}
};
return null === o ? o = [ t ] : o.push(t), l++, e.errors = o, !1;
}
l = n, null !== o && (n ? o.length = n : o = null), u = s === l;
} else u = !0;
}
}
}
}
}
return e.errors = o, 0 === l;
}
module.exports = e, module.exports.default = e;
},
21286: module => {
"use strict";
function e(s, {instancePath: o = "", parentData: r, parentDataProperty: t, rootData: n = s} = {}) {
let c = null, a = 0;
const p = a;
let l = !1;
const i = a;
if (a === i) if (s && "object" == typeof s && !Array.isArray(s)) {
let e;
if (void 0 === s.resourceRegExp && (e = "resourceRegExp")) {
const s = {
params: {
missingProperty: e
}
};
null === c ? c = [ s ] : c.push(s), a++;
} else {
const e = a;
for (const e in s) if ("contextRegExp" !== e && "resourceRegExp" !== e) {
const s = {
params: {
additionalProperty: e
}
};
null === c ? c = [ s ] : c.push(s), a++;
break;
}
if (e === a) {
if (void 0 !== s.contextRegExp) {
const e = a;
if (!(s.contextRegExp instanceof RegExp)) {
const e = {
params: {}
};
null === c ? c = [ e ] : c.push(e), a++;
}
var u = e === a;
} else u = !0;
if (u) if (void 0 !== s.resourceRegExp) {
const e = a;
if (!(s.resourceRegExp instanceof RegExp)) {
const e = {
params: {}
};
null === c ? c = [ e ] : c.push(e), a++;
}
u = e === a;
} else u = !0;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === c ? c = [ e ] : c.push(e), a++;
}
var f = i === a;
if (l = l || f, !l) {
const e = a;
if (a === e) if (s && "object" == typeof s && !Array.isArray(s)) {
let e;
if (void 0 === s.checkResource && (e = "checkResource")) {
const s = {
params: {
missingProperty: e
}
};
null === c ? c = [ s ] : c.push(s), a++;
} else {
const e = a;
for (const e in s) if ("checkResource" !== e) {
const s = {
params: {
additionalProperty: e
}
};
null === c ? c = [ s ] : c.push(s), a++;
break;
}
if (e === a && void 0 !== s.checkResource && !(s.checkResource instanceof Function)) {
const e = {
params: {}
};
null === c ? c = [ e ] : c.push(e), a++;
}
}
} else {
const e = {
params: {
type: "object"
}
};
null === c ? c = [ e ] : c.push(e), a++;
}
f = e === a, l = l || f;
}
if (!l) {
const s = {
params: {}
};
return null === c ? c = [ s ] : c.push(s), a++, e.errors = c, !1;
}
return a = p, null !== c && (p ? c.length = p : c = null), e.errors = c, 0 === a;
}
module.exports = e, module.exports.default = e;
},
8395: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: a, parentDataProperty: o, rootData: n = t} = {}) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const e = 0;
for (const e in t) if ("parse" !== e) return r.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (0 === e && void 0 !== t.parse && !(t.parse instanceof Function)) return r.errors = [ {
params: {}
} ], !1;
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
99422: module => {
const r = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function e(t, {instancePath: o = "", parentData: a, parentDataProperty: i, rootData: n = t} = {}) {
if (!t || "object" != typeof t || Array.isArray(t)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
if (void 0 !== t.debug) {
const r = 0;
if ("boolean" != typeof t.debug) return e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var s = 0 === r;
} else s = !0;
if (s) {
if (void 0 !== t.minimize) {
const r = 0;
if ("boolean" != typeof t.minimize) return e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
s = 0 === r;
} else s = !0;
if (s) if (void 0 !== t.options) {
let o = t.options;
const a = 0;
if (0 === a) {
if (!o || "object" != typeof o || Array.isArray(o)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
if (void 0 !== o.context) {
let t = o.context;
if ("string" != typeof t) return e.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.includes("!") || !0 !== r.test(t)) return e.errors = [ {
params: {}
} ], !1;
}
}
s = 0 === a;
} else s = !0;
}
return e.errors = null, !0;
}
module.exports = e, module.exports.default = e;
},
11116: module => {
"use strict";
module.exports = t, module.exports.default = t;
const e = {
activeModules: {
type: "boolean"
},
dependencies: {
type: "boolean"
},
dependenciesCount: {
type: "number"
},
entries: {
type: "boolean"
},
handler: {
oneOf: [ {
$ref: "#/definitions/HandlerFunction"
} ]
},
modules: {
type: "boolean"
},
modulesCount: {
type: "number"
},
percentBy: {
enum: [ "entries", "modules", "dependencies", null ]
},
profile: {
enum: [ !0, !1, null ]
}
}, r = Object.prototype.hasOwnProperty;
function n(t, {instancePath: o = "", parentData: s, parentDataProperty: a, rootData: l = t} = {}) {
let i = null, p = 0;
if (0 === p) {
if (!t || "object" != typeof t || Array.isArray(t)) return n.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const o = p;
for (const o in t) if (!r.call(e, o)) return n.errors = [ {
params: {
additionalProperty: o
}
} ], !1;
if (o === p) {
if (void 0 !== t.activeModules) {
const e = p;
if ("boolean" != typeof t.activeModules) return n.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.dependencies) {
const e = p;
if ("boolean" != typeof t.dependencies) return n.errors = [ {
params: {
type: "boolean"
}
} ], !1;
u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.dependenciesCount) {
const e = p;
if ("number" != typeof t.dependenciesCount) return n.errors = [ {
params: {
type: "number"
}
} ], !1;
u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.entries) {
const e = p;
if ("boolean" != typeof t.entries) return n.errors = [ {
params: {
type: "boolean"
}
} ], !1;
u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.handler) {
const e = p, r = p;
let o = !1, s = null;
const a = p;
if (!(t.handler instanceof Function)) {
const e = {
params: {}
};
null === i ? i = [ e ] : i.push(e), p++;
}
if (a === p && (o = !0, s = 0), !o) {
const e = {
params: {
passingSchemas: s
}
};
return null === i ? i = [ e ] : i.push(e), p++, n.errors = i, !1;
}
p = r, null !== i && (r ? i.length = r : i = null), u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.modules) {
const e = p;
if ("boolean" != typeof t.modules) return n.errors = [ {
params: {
type: "boolean"
}
} ], !1;
u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.modulesCount) {
const e = p;
if ("number" != typeof t.modulesCount) return n.errors = [ {
params: {
type: "number"
}
} ], !1;
u = e === p;
} else u = !0;
if (u) {
if (void 0 !== t.percentBy) {
let e = t.percentBy;
const r = p;
if ("entries" !== e && "modules" !== e && "dependencies" !== e && null !== e) return n.errors = [ {
params: {}
} ], !1;
u = r === p;
} else u = !0;
if (u) if (void 0 !== t.profile) {
let e = t.profile;
const r = p;
if (!0 !== e && !1 !== e && null !== e) return n.errors = [ {
params: {}
} ], !1;
u = r === p;
} else u = !0;
}
}
}
}
}
}
}
}
}
}
return n.errors = i, 0 === p;
}
function t(e, {instancePath: r = "", parentData: o, parentDataProperty: s, rootData: a = e} = {}) {
let l = null, i = 0;
const p = i;
let u = !1;
const f = i;
n(e, {
instancePath: r,
parentData: o,
parentDataProperty: s,
rootData: a
}) || (l = null === l ? n.errors : l.concat(n.errors), i = l.length);
var c = f === i;
if (u = u || c, !u) {
const r = i;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === l ? l = [ e ] : l.push(e), i++;
}
c = r === i, u = u || c;
}
if (!u) {
const e = {
params: {}
};
return null === l ? l = [ e ] : l.push(e), i++, t.errors = l, !1;
}
return i = p, null !== l && (p ? l.length = p : l = null), t.errors = l, 0 === i;
}
},
61710: module => {
const e = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
module.exports = l, module.exports.default = l;
const n = {
append: {
anyOf: [ {
enum: [ !1, null ]
}, {
type: "string",
minLength: 1
} ]
},
columns: {
type: "boolean"
},
exclude: {
oneOf: [ {
$ref: "#/definitions/rules"
} ]
},
fallbackModuleFilenameTemplate: {
anyOf: [ {
type: "string",
minLength: 1
}, {
instanceof: "Function"
} ]
},
fileContext: {
type: "string"
},
filename: {
anyOf: [ {
enum: [ !1, null ]
}, {
type: "string",
absolutePath: !1,
minLength: 1
} ]
},
include: {
oneOf: [ {
$ref: "#/definitions/rules"
} ]
},
module: {
type: "boolean"
},
moduleFilenameTemplate: {
anyOf: [ {
type: "string",
minLength: 1
}, {
instanceof: "Function"
} ]
},
namespace: {
type: "string"
},
noSources: {
type: "boolean"
},
publicPath: {
type: "string"
},
sourceRoot: {
type: "string"
},
test: {
$ref: "#/definitions/rules"
}
}, t = Object.prototype.hasOwnProperty;
function s(e, {instancePath: n = "", parentData: t, parentDataProperty: l, rootData: r = e} = {}) {
let o = null, a = 0;
const i = a;
let u = !1;
const p = a;
if (a === p) if (Array.isArray(e)) {
const n = e.length;
for (let t = 0; t < n; t++) {
let n = e[t];
const s = a, l = a;
let r = !1, i = null;
const u = a, p = a;
let c = !1;
const m = a;
if (!(n instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var f = m === a;
if (c = c || f, !c) {
const e = a;
if (a === e) if ("string" == typeof n) {
if (n.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
f = e === a, c = c || f;
}
if (c) a = p, null !== o && (p ? o.length = p : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (u === a && (r = !0, i = 0), r) a = l, null !== o && (l ? o.length = l : o = null); else {
const e = {
params: {
passingSchemas: i
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
if (s !== a) break;
}
} else {
const e = {
params: {
type: "array"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var c = p === a;
if (u = u || c, !u) {
const n = a, t = a;
let s = !1;
const l = a;
if (!(e instanceof RegExp)) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
var m = l === a;
if (s = s || m, !s) {
const n = a;
if (a === n) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === o ? o = [ e ] : o.push(e), a++;
}
m = n === a, s = s || m;
}
if (s) a = t, null !== o && (t ? o.length = t : o = null); else {
const e = {
params: {}
};
null === o ? o = [ e ] : o.push(e), a++;
}
c = n === a, u = u || c;
}
if (!u) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), a++, s.errors = o, !1;
}
return a = i, null !== o && (i ? o.length = i : o = null), s.errors = o, 0 === a;
}
function l(r, {instancePath: o = "", parentData: a, parentDataProperty: i, rootData: u = r} = {}) {
let p = null, f = 0;
if (0 === f) {
if (!r || "object" != typeof r || Array.isArray(r)) return l.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const a = f;
for (const e in r) if (!t.call(n, e)) return l.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (a === f) {
if (void 0 !== r.append) {
let e = r.append;
const n = f, t = f;
let s = !1;
const o = f;
if (!1 !== e && null !== e) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
var c = o === f;
if (s = s || c, !s) {
const n = f;
if (f === n) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), f++;
}
c = n === f, s = s || c;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), f++, l.errors = p, !1;
}
f = t, null !== p && (t ? p.length = t : p = null);
var m = n === f;
} else m = !0;
if (m) {
if (void 0 !== r.columns) {
const e = f;
if ("boolean" != typeof r.columns) return l.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.exclude) {
const e = f, n = f;
let t = !1, a = null;
const i = f;
if (s(r.exclude, {
instancePath: o + "/exclude",
parentData: r,
parentDataProperty: "exclude",
rootData: u
}) || (p = null === p ? s.errors : p.concat(s.errors), f = p.length), i === f && (t = !0, 
a = 0), !t) {
const e = {
params: {
passingSchemas: a
}
};
return null === p ? p = [ e ] : p.push(e), f++, l.errors = p, !1;
}
f = n, null !== p && (n ? p.length = n : p = null), m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.fallbackModuleFilenameTemplate) {
let e = r.fallbackModuleFilenameTemplate;
const n = f, t = f;
let s = !1;
const o = f;
if (f === o) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), f++;
}
var h = o === f;
if (s = s || h, !s) {
const n = f;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
h = n === f, s = s || h;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), f++, l.errors = p, !1;
}
f = t, null !== p && (t ? p.length = t : p = null), m = n === f;
} else m = !0;
if (m) {
if (void 0 !== r.fileContext) {
const e = f;
if ("string" != typeof r.fileContext) return l.errors = [ {
params: {
type: "string"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.filename) {
let n = r.filename;
const t = f, s = f;
let o = !1;
const a = f;
if (!1 !== n && null !== n) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
var g = a === f;
if (o = o || g, !o) {
const t = f;
if (f === t) if ("string" == typeof n) {
if (n.includes("!") || !1 !== e.test(n)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
} else if (n.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), f++;
}
g = t === f, o = o || g;
}
if (!o) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), f++, l.errors = p, !1;
}
f = s, null !== p && (s ? p.length = s : p = null), m = t === f;
} else m = !0;
if (m) {
if (void 0 !== r.include) {
const e = f, n = f;
let t = !1, a = null;
const i = f;
if (s(r.include, {
instancePath: o + "/include",
parentData: r,
parentDataProperty: "include",
rootData: u
}) || (p = null === p ? s.errors : p.concat(s.errors), f = p.length), i === f && (t = !0, 
a = 0), !t) {
const e = {
params: {
passingSchemas: a
}
};
return null === p ? p = [ e ] : p.push(e), f++, l.errors = p, !1;
}
f = n, null !== p && (n ? p.length = n : p = null), m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.module) {
const e = f;
if ("boolean" != typeof r.module) return l.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.moduleFilenameTemplate) {
let e = r.moduleFilenameTemplate;
const n = f, t = f;
let s = !1;
const o = f;
if (f === o) if ("string" == typeof e) {
if (e.length < 1) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
} else {
const e = {
params: {
type: "string"
}
};
null === p ? p = [ e ] : p.push(e), f++;
}
var y = o === f;
if (s = s || y, !s) {
const n = f;
if (!(e instanceof Function)) {
const e = {
params: {}
};
null === p ? p = [ e ] : p.push(e), f++;
}
y = n === f, s = s || y;
}
if (!s) {
const e = {
params: {}
};
return null === p ? p = [ e ] : p.push(e), f++, l.errors = p, !1;
}
f = t, null !== p && (t ? p.length = t : p = null), m = n === f;
} else m = !0;
if (m) {
if (void 0 !== r.namespace) {
const e = f;
if ("string" != typeof r.namespace) return l.errors = [ {
params: {
type: "string"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.noSources) {
const e = f;
if ("boolean" != typeof r.noSources) return l.errors = [ {
params: {
type: "boolean"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.publicPath) {
const e = f;
if ("string" != typeof r.publicPath) return l.errors = [ {
params: {
type: "string"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) {
if (void 0 !== r.sourceRoot) {
const e = f;
if ("string" != typeof r.sourceRoot) return l.errors = [ {
params: {
type: "string"
}
} ], !1;
m = e === f;
} else m = !0;
if (m) if (void 0 !== r.test) {
const e = f;
s(r.test, {
instancePath: o + "/test",
parentData: r,
parentDataProperty: "test",
rootData: u
}) || (p = null === p ? s.errors : p.concat(s.errors), f = p.length), m = e === f;
} else m = !0;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
return l.errors = p, 0 === f;
}
},
99024: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: s, parentDataProperty: a, rootData: n = t} = {}) {
let o = null, i = 0;
if (0 === i) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === t.paths && (e = "paths")) return r.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = i;
for (const e in t) if ("paths" !== e) return r.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (e === i && void 0 !== t.paths) {
let e = t.paths;
if (i == i) {
if (!Array.isArray(e)) return r.errors = [ {
params: {
type: "array"
}
} ], !1;
if (e.length < 1) return r.errors = [ {
params: {
limit: 1
}
} ], !1;
{
const t = e.length;
for (let s = 0; s < t; s++) {
let t = e[s];
const a = i, n = i;
let l = !1;
const u = i;
if (!(t instanceof RegExp)) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), i++;
}
var p = u === i;
if (l = l || p, !l) {
const r = i;
if ("string" != typeof t) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), i++;
}
p = r === i, l = l || p;
}
if (!l) {
const t = {
params: {}
};
return null === o ? o = [ t ] : o.push(t), i++, r.errors = o, !1;
}
if (i = n, null !== o && (n ? o.length = n : o = null), a !== i) break;
}
}
}
}
}
}
}
return r.errors = o, 0 === i;
}
module.exports = r, module.exports.default = r;
},
53e3: module => {
const t = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function n(t, {instancePath: r = "", parentData: e, parentDataProperty: a, rootData: s = t} = {}) {
let o = null, l = 0;
const i = l;
let p = !1;
const u = l;
if (l == l) if (t && "object" == typeof t && !Array.isArray(t)) {
const n = l;
for (const n in t) if ("encoding" !== n && "mimetype" !== n) {
const t = {
params: {
additionalProperty: n
}
};
null === o ? o = [ t ] : o.push(t), l++;
break;
}
if (n === l) {
if (void 0 !== t.encoding) {
let n = t.encoding;
const r = l;
if (!1 !== n && "base64" !== n) {
const t = {
params: {}
};
null === o ? o = [ t ] : o.push(t), l++;
}
var c = r === l;
} else c = !0;
if (c) if (void 0 !== t.mimetype) {
const n = l;
if ("string" != typeof t.mimetype) {
const t = {
params: {
type: "string"
}
};
null === o ? o = [ t ] : o.push(t), l++;
}
c = n === l;
} else c = !0;
}
} else {
const t = {
params: {
type: "object"
}
};
null === o ? o = [ t ] : o.push(t), l++;
}
var f = u === l;
if (p = p || f, !p) {
const n = l;
if (!(t instanceof Function)) {
const t = {
params: {}
};
null === o ? o = [ t ] : o.push(t), l++;
}
f = n === l, p = p || f;
}
if (!p) {
const t = {
params: {}
};
return null === o ? o = [ t ] : o.push(t), l++, n.errors = o, !1;
}
return l = i, null !== o && (i ? o.length = i : o = null), n.errors = o, 0 === l;
}
function r(e, {instancePath: a = "", parentData: s, parentDataProperty: o, rootData: l = e} = {}) {
let i = null, p = 0;
if (0 === p) {
if (!e || "object" != typeof e || Array.isArray(e)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = p;
for (const t in e) if ("dataUrl" !== t && "emit" !== t && "filename" !== t && "outputPath" !== t && "publicPath" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (s === p) {
if (void 0 !== e.dataUrl) {
const t = p;
n(e.dataUrl, {
instancePath: a + "/dataUrl",
parentData: e,
parentDataProperty: "dataUrl",
rootData: l
}) || (i = null === i ? n.errors : i.concat(n.errors), p = i.length);
var u = t === p;
} else u = !0;
if (u) {
if (void 0 !== e.emit) {
const t = p;
if ("boolean" != typeof e.emit) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
u = t === p;
} else u = !0;
if (u) {
if (void 0 !== e.filename) {
let n = e.filename;
const a = p, s = p;
let o = !1;
const l = p;
if (p === l) if ("string" == typeof n) {
if (n.includes("!") || !1 !== t.test(n)) {
const t = {
params: {}
};
null === i ? i = [ t ] : i.push(t), p++;
} else if (n.length < 1) {
const t = {
params: {}
};
null === i ? i = [ t ] : i.push(t), p++;
}
} else {
const t = {
params: {
type: "string"
}
};
null === i ? i = [ t ] : i.push(t), p++;
}
var c = l === p;
if (o = o || c, !o) {
const t = p;
if (!(n instanceof Function)) {
const t = {
params: {}
};
null === i ? i = [ t ] : i.push(t), p++;
}
c = t === p, o = o || c;
}
if (!o) {
const t = {
params: {}
};
return null === i ? i = [ t ] : i.push(t), p++, r.errors = i, !1;
}
p = s, null !== i && (s ? i.length = s : i = null), u = a === p;
} else u = !0;
if (u) {
if (void 0 !== e.outputPath) {
let n = e.outputPath;
const a = p, s = p;
let o = !1;
const l = p;
if (p === l) if ("string" == typeof n) {
if (n.includes("!") || !1 !== t.test(n)) {
const t = {
params: {}
};
null === i ? i = [ t ] : i.push(t), p++;
}
} else {
const t = {
params: {
type: "string"
}
};
null === i ? i = [ t ] : i.push(t), p++;
}
var f = l === p;
if (o = o || f, !o) {
const t = p;
if (!(n instanceof Function)) {
const t = {
params: {}
};
null === i ? i = [ t ] : i.push(t), p++;
}
f = t === p, o = o || f;
}
if (!o) {
const t = {
params: {}
};
return null === i ? i = [ t ] : i.push(t), p++, r.errors = i, !1;
}
p = s, null !== i && (s ? i.length = s : i = null), u = a === p;
} else u = !0;
if (u) if (void 0 !== e.publicPath) {
let t = e.publicPath;
const n = p, a = p;
let s = !1;
const o = p;
if ("string" != typeof t) {
const t = {
params: {
type: "string"
}
};
null === i ? i = [ t ] : i.push(t), p++;
}
var h = o === p;
if (s = s || h, !s) {
const n = p;
if (!(t instanceof Function)) {
const t = {
params: {}
};
null === i ? i = [ t ] : i.push(t), p++;
}
h = n === p, s = s || h;
}
if (!s) {
const t = {
params: {}
};
return null === i ? i = [ t ] : i.push(t), p++, r.errors = i, !1;
}
p = a, null !== i && (a ? i.length = a : i = null), u = n === p;
} else u = !0;
}
}
}
}
}
}
return r.errors = i, 0 === p;
}
function e(t, {instancePath: n = "", parentData: a, parentDataProperty: s, rootData: o = t} = {}) {
let l = null, i = 0;
return r(t, {
instancePath: n,
parentData: a,
parentDataProperty: s,
rootData: o
}) || (l = null === l ? r.errors : l.concat(r.errors), i = l.length), e.errors = l, 
0 === i;
}
module.exports = e, module.exports.default = e;
},
71251: module => {
"use strict";
function t(r, {instancePath: a = "", parentData: n, parentDataProperty: e, rootData: o = r} = {}) {
let s = null, l = 0;
const i = l;
let p = !1;
const c = l;
if (l == l) if (r && "object" == typeof r && !Array.isArray(r)) {
const t = l;
for (const t in r) if ("encoding" !== t && "mimetype" !== t) {
const r = {
params: {
additionalProperty: t
}
};
null === s ? s = [ r ] : s.push(r), l++;
break;
}
if (t === l) {
if (void 0 !== r.encoding) {
let t = r.encoding;
const a = l;
if (!1 !== t && "base64" !== t) {
const t = {
params: {}
};
null === s ? s = [ t ] : s.push(t), l++;
}
var u = a === l;
} else u = !0;
if (u) if (void 0 !== r.mimetype) {
const t = l;
if ("string" != typeof r.mimetype) {
const t = {
params: {
type: "string"
}
};
null === s ? s = [ t ] : s.push(t), l++;
}
u = t === l;
} else u = !0;
}
} else {
const t = {
params: {
type: "object"
}
};
null === s ? s = [ t ] : s.push(t), l++;
}
var f = c === l;
if (p = p || f, !p) {
const t = l;
if (!(r instanceof Function)) {
const t = {
params: {}
};
null === s ? s = [ t ] : s.push(t), l++;
}
f = t === l, p = p || f;
}
if (!p) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), l++, t.errors = s, !1;
}
return l = i, null !== s && (i ? s.length = i : s = null), t.errors = s, 0 === l;
}
function r(a, {instancePath: n = "", parentData: e, parentDataProperty: o, rootData: s = a} = {}) {
let l = null, i = 0;
if (0 === i) {
if (!a || "object" != typeof a || Array.isArray(a)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const e = i;
for (const t in a) if ("dataUrl" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
e === i && void 0 !== a.dataUrl && (t(a.dataUrl, {
instancePath: n + "/dataUrl",
parentData: a,
parentDataProperty: "dataUrl",
rootData: s
}) || (l = null === l ? t.errors : l.concat(t.errors), i = l.length));
}
}
return r.errors = l, 0 === i;
}
function a(t, {instancePath: n = "", parentData: e, parentDataProperty: o, rootData: s = t} = {}) {
let l = null, i = 0;
return r(t, {
instancePath: n,
parentData: e,
parentDataProperty: o,
rootData: s
}) || (l = null === l ? r.errors : l.concat(r.errors), i = l.length), a.errors = l, 
0 === i;
}
module.exports = a, module.exports.default = a;
},
63319: module => {
"use strict";
function t(r, {instancePath: a = "", parentData: n, parentDataProperty: o, rootData: e = r} = {}) {
let s = null, i = 0;
if (0 === i) {
if (!r || "object" != typeof r || Array.isArray(r)) return t.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const a = i;
for (const a in r) if ("dataUrlCondition" !== a) return t.errors = [ {
params: {
additionalProperty: a
}
} ], !1;
if (a === i && void 0 !== r.dataUrlCondition) {
let a = r.dataUrlCondition;
const n = i;
let o = !1;
const e = i;
if (i == i) if (a && "object" == typeof a && !Array.isArray(a)) {
const t = i;
for (const t in a) if ("maxSize" !== t) {
const r = {
params: {
additionalProperty: t
}
};
null === s ? s = [ r ] : s.push(r), i++;
break;
}
if (t === i && void 0 !== a.maxSize && "number" != typeof a.maxSize) {
const t = {
params: {
type: "number"
}
};
null === s ? s = [ t ] : s.push(t), i++;
}
} else {
const t = {
params: {
type: "object"
}
};
null === s ? s = [ t ] : s.push(t), i++;
}
var l = e === i;
if (o = o || l, !o) {
const t = i;
if (!(a instanceof Function)) {
const t = {
params: {}
};
null === s ? s = [ t ] : s.push(t), i++;
}
l = t === i, o = o || l;
}
if (!o) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), i++, t.errors = s, !1;
}
i = n, null !== s && (n ? s.length = n : s = null);
}
}
}
return t.errors = s, 0 === i;
}
function r(a, {instancePath: n = "", parentData: o, parentDataProperty: e, rootData: s = a} = {}) {
let i = null, l = 0;
return t(a, {
instancePath: n,
parentData: o,
parentDataProperty: e,
rootData: s
}) || (i = null === i ? t.errors : i.concat(t.errors), l = i.length), r.errors = i, 
0 === l;
}
module.exports = r, module.exports.default = r;
},
5970: module => {
const t = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function n(r, {instancePath: e = "", parentData: s, parentDataProperty: a, rootData: o = r} = {}) {
let l = null, i = 0;
if (0 === i) {
if (!r || "object" != typeof r || Array.isArray(r)) return n.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const e = i;
for (const t in r) if ("emit" !== t && "filename" !== t && "outputPath" !== t && "publicPath" !== t) return n.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (e === i) {
if (void 0 !== r.emit) {
const t = i;
if ("boolean" != typeof r.emit) return n.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var u = t === i;
} else u = !0;
if (u) {
if (void 0 !== r.filename) {
let e = r.filename;
const s = i, a = i;
let o = !1;
const c = i;
if (i === c) if ("string" == typeof e) {
if (e.includes("!") || !1 !== t.test(e)) {
const t = {
params: {}
};
null === l ? l = [ t ] : l.push(t), i++;
} else if (e.length < 1) {
const t = {
params: {}
};
null === l ? l = [ t ] : l.push(t), i++;
}
} else {
const t = {
params: {
type: "string"
}
};
null === l ? l = [ t ] : l.push(t), i++;
}
var p = c === i;
if (o = o || p, !o) {
const t = i;
if (!(e instanceof Function)) {
const t = {
params: {}
};
null === l ? l = [ t ] : l.push(t), i++;
}
p = t === i, o = o || p;
}
if (!o) {
const t = {
params: {}
};
return null === l ? l = [ t ] : l.push(t), i++, n.errors = l, !1;
}
i = a, null !== l && (a ? l.length = a : l = null), u = s === i;
} else u = !0;
if (u) {
if (void 0 !== r.outputPath) {
let e = r.outputPath;
const s = i, a = i;
let o = !1;
const p = i;
if (i === p) if ("string" == typeof e) {
if (e.includes("!") || !1 !== t.test(e)) {
const t = {
params: {}
};
null === l ? l = [ t ] : l.push(t), i++;
}
} else {
const t = {
params: {
type: "string"
}
};
null === l ? l = [ t ] : l.push(t), i++;
}
var c = p === i;
if (o = o || c, !o) {
const t = i;
if (!(e instanceof Function)) {
const t = {
params: {}
};
null === l ? l = [ t ] : l.push(t), i++;
}
c = t === i, o = o || c;
}
if (!o) {
const t = {
params: {}
};
return null === l ? l = [ t ] : l.push(t), i++, n.errors = l, !1;
}
i = a, null !== l && (a ? l.length = a : l = null), u = s === i;
} else u = !0;
if (u) if (void 0 !== r.publicPath) {
let t = r.publicPath;
const e = i, s = i;
let a = !1;
const o = i;
if ("string" != typeof t) {
const t = {
params: {
type: "string"
}
};
null === l ? l = [ t ] : l.push(t), i++;
}
var f = o === i;
if (a = a || f, !a) {
const n = i;
if (!(t instanceof Function)) {
const t = {
params: {}
};
null === l ? l = [ t ] : l.push(t), i++;
}
f = n === i, a = a || f;
}
if (!a) {
const t = {
params: {}
};
return null === l ? l = [ t ] : l.push(t), i++, n.errors = l, !1;
}
i = s, null !== l && (s ? l.length = s : l = null), u = e === i;
} else u = !0;
}
}
}
}
}
return n.errors = l, 0 === i;
}
function r(t, {instancePath: e = "", parentData: s, parentDataProperty: a, rootData: o = t} = {}) {
let l = null, i = 0;
return n(t, {
instancePath: e,
parentData: s,
parentDataProperty: a,
rootData: o
}) || (l = null === l ? n.errors : l.concat(n.errors), i = l.length), r.errors = l, 
0 === i;
}
module.exports = r, module.exports.default = r;
},
38902: module => {
const r = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function t(r, {instancePath: e = "", parentData: n, parentDataProperty: s, rootData: a = r} = {}) {
if (!Array.isArray(r)) return t.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const e = r.length;
for (let n = 0; n < e; n++) {
let e = r[n];
const s = 0;
if ("string" != typeof e) return t.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return t.errors = [ {
params: {}
} ], !1;
if (0 !== s) break;
}
}
return t.errors = null, !0;
}
function e(r, {instancePath: n = "", parentData: s, parentDataProperty: a, rootData: o = r} = {}) {
let l = null, i = 0;
if (0 === i) {
if (!r || "object" != typeof r || Array.isArray(r)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let s;
if (void 0 === r.import && (s = "import")) return e.errors = [ {
params: {
missingProperty: s
}
} ], !1;
{
const s = i;
for (const t in r) if ("import" !== t && "name" !== t) return e.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (s === i) {
if (void 0 !== r.import) {
let s = r.import;
const a = i, u = i;
let c = !1;
const m = i;
if (i == i) if ("string" == typeof s) {
if (s.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var p = m === i;
if (c = c || p, !c) {
const e = i;
t(s, {
instancePath: n + "/import",
parentData: r,
parentDataProperty: "import",
rootData: o
}) || (l = null === l ? t.errors : l.concat(t.errors), i = l.length), p = e === i, 
c = c || p;
}
if (!c) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), i++, e.errors = l, !1;
}
i = u, null !== l && (u ? l.length = u : l = null);
var f = a === i;
} else f = !0;
if (f) if (void 0 !== r.name) {
const t = i;
if ("string" != typeof r.name) return e.errors = [ {
params: {
type: "string"
}
} ], !1;
f = t === i;
} else f = !0;
}
}
}
}
return e.errors = l, 0 === i;
}
function n(r, {instancePath: s = "", parentData: a, parentDataProperty: o, rootData: l = r} = {}) {
let i = null, p = 0;
if (0 === p) {
if (!r || "object" != typeof r || Array.isArray(r)) return n.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const a in r) {
let o = r[a];
const u = p, c = p;
let m = !1;
const y = p;
e(o, {
instancePath: s + "/" + a.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: a,
rootData: l
}) || (i = null === i ? e.errors : i.concat(e.errors), p = i.length);
var f = y === p;
if (m = m || f, !m) {
const e = p;
if (p == p) if ("string" == typeof o) {
if (o.length < 1) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
if (f = e === p, m = m || f, !m) {
const e = p;
t(o, {
instancePath: s + "/" + a.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: a,
rootData: l
}) || (i = null === i ? t.errors : i.concat(t.errors), p = i.length), f = e === p, 
m = m || f;
}
}
if (!m) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), p++, n.errors = i, !1;
}
if (p = c, null !== i && (c ? i.length = c : i = null), u !== p) break;
}
}
return n.errors = i, 0 === p;
}
function s(r, {instancePath: t = "", parentData: e, parentDataProperty: a, rootData: o = r} = {}) {
let l = null, i = 0;
const p = i;
let f = !1;
const u = i;
if (i === u) if (Array.isArray(r)) {
const e = r.length;
for (let s = 0; s < e; s++) {
let e = r[s];
const a = i, p = i;
let f = !1;
const u = i;
if (i == i) if ("string" == typeof e) {
if (e.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var c = u === i;
if (f = f || c, !f) {
const a = i;
n(e, {
instancePath: t + "/" + s,
parentData: r,
parentDataProperty: s,
rootData: o
}) || (l = null === l ? n.errors : l.concat(n.errors), i = l.length), c = a === i, 
f = f || c;
}
if (f) i = p, null !== l && (p ? l.length = p : l = null); else {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
if (a !== i) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var m = u === i;
if (f = f || m, !f) {
const s = i;
n(r, {
instancePath: t,
parentData: e,
parentDataProperty: a,
rootData: o
}) || (l = null === l ? n.errors : l.concat(n.errors), i = l.length), m = s === i, 
f = f || m;
}
if (!f) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), i++, s.errors = l, !1;
}
return i = p, null !== l && (p ? l.length = p : l = null), s.errors = l, 0 === i;
}
function a(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: s = r} = {}) {
let o = null, l = 0;
const i = l;
let p = !1;
const f = l;
if ("string" != typeof r) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var u = f === l;
if (p = p || u, !p) {
const t = l;
if (l == l) if (r && "object" == typeof r && !Array.isArray(r)) {
const t = l;
for (const t in r) if ("amd" !== t && "commonjs" !== t && "commonjs2" !== t && "root" !== t) {
const r = {
params: {
additionalProperty: t
}
};
null === o ? o = [ r ] : o.push(r), l++;
break;
}
if (t === l) {
if (void 0 !== r.amd) {
const t = l;
if ("string" != typeof r.amd) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var c = t === l;
} else c = !0;
if (c) {
if (void 0 !== r.commonjs) {
const t = l;
if ("string" != typeof r.commonjs) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
c = t === l;
} else c = !0;
if (c) {
if (void 0 !== r.commonjs2) {
const t = l;
if ("string" != typeof r.commonjs2) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
c = t === l;
} else c = !0;
if (c) if (void 0 !== r.root) {
const t = l;
if ("string" != typeof r.root) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
c = t === l;
} else c = !0;
}
}
}
} else {
const r = {
params: {
type: "object"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
u = t === l, p = p || u;
}
if (!p) {
const r = {
params: {}
};
return null === o ? o = [ r ] : o.push(r), l++, a.errors = o, !1;
}
return l = i, null !== o && (i ? o.length = i : o = null), a.errors = o, 0 === l;
}
function o(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: s = r} = {}) {
let a = null, l = 0;
const i = l;
let p = !1;
const f = l;
if (l === f) if (Array.isArray(r)) if (r.length < 1) {
const r = {
params: {
limit: 1
}
};
null === a ? a = [ r ] : a.push(r), l++;
} else {
const t = r.length;
for (let e = 0; e < t; e++) {
let t = r[e];
const n = l;
if (l === n) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
if (n !== l) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
var u = f === l;
if (p = p || u, !p) {
const t = l;
if (l === t) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
if (u = t === l, p = p || u, !p) {
const t = l;
if (l == l) if (r && "object" == typeof r && !Array.isArray(r)) {
const t = l;
for (const t in r) if ("amd" !== t && "commonjs" !== t && "root" !== t) {
const r = {
params: {
additionalProperty: t
}
};
null === a ? a = [ r ] : a.push(r), l++;
break;
}
if (t === l) {
if (void 0 !== r.amd) {
let t = r.amd;
const e = l;
if (l === e) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
var c = e === l;
} else c = !0;
if (c) {
if (void 0 !== r.commonjs) {
let t = r.commonjs;
const e = l;
if (l === e) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
c = e === l;
} else c = !0;
if (c) if (void 0 !== r.root) {
let t = r.root;
const e = l, n = l;
let s = !1;
const o = l;
if (l === o) if (Array.isArray(t)) {
const r = t.length;
for (let e = 0; e < r; e++) {
let r = t[e];
const n = l;
if (l === n) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
if (n !== l) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
var m = o === l;
if (s = s || m, !s) {
const r = l;
if (l === r) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
m = r === l, s = s || m;
}
if (s) l = n, null !== a && (n ? a.length = n : a = null); else {
const r = {
params: {}
};
null === a ? a = [ r ] : a.push(r), l++;
}
c = e === l;
} else c = !0;
}
}
} else {
const r = {
params: {
type: "object"
}
};
null === a ? a = [ r ] : a.push(r), l++;
}
u = t === l, p = p || u;
}
}
if (!p) {
const r = {
params: {}
};
return null === a ? a = [ r ] : a.push(r), l++, o.errors = a, !1;
}
return l = i, null !== a && (i ? a.length = i : a = null), o.errors = a, 0 === l;
}
function l(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: s = r} = {}) {
let i = null, p = 0;
if (0 === p) {
if (!r || "object" != typeof r || Array.isArray(r)) return l.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === r.type && (e = "type")) return l.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = p;
for (const t in r) if ("auxiliaryComment" !== t && "export" !== t && "name" !== t && "type" !== t && "umdNamedDefine" !== t) return l.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (e === p) {
if (void 0 !== r.auxiliaryComment) {
const e = p;
a(r.auxiliaryComment, {
instancePath: t + "/auxiliaryComment",
parentData: r,
parentDataProperty: "auxiliaryComment",
rootData: s
}) || (i = null === i ? a.errors : i.concat(a.errors), p = i.length);
var f = e === p;
} else f = !0;
if (f) {
if (void 0 !== r.export) {
let t = r.export;
const e = p, n = p;
let s = !1;
const a = p;
if (p === a) if (Array.isArray(t)) {
const r = t.length;
for (let e = 0; e < r; e++) {
let r = t[e];
const n = p;
if (p === n) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
if (n !== p) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
var u = a === p;
if (s = s || u, !s) {
const r = p;
if (p === r) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
u = r === p, s = s || u;
}
if (!s) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), p++, l.errors = i, !1;
}
p = n, null !== i && (n ? i.length = n : i = null), f = e === p;
} else f = !0;
if (f) {
if (void 0 !== r.name) {
const e = p;
o(r.name, {
instancePath: t + "/name",
parentData: r,
parentDataProperty: "name",
rootData: s
}) || (i = null === i ? o.errors : i.concat(o.errors), p = i.length), f = e === p;
} else f = !0;
if (f) {
if (void 0 !== r.type) {
let t = r.type;
const e = p, n = p;
let s = !1;
const a = p;
if ("var" !== t && "module" !== t && "assign" !== t && "assign-properties" !== t && "this" !== t && "window" !== t && "self" !== t && "global" !== t && "commonjs" !== t && "commonjs2" !== t && "commonjs-module" !== t && "commonjs-static" !== t && "amd" !== t && "amd-require" !== t && "umd" !== t && "umd2" !== t && "jsonp" !== t && "system" !== t) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
var c = a === p;
if (s = s || c, !s) {
const r = p;
if ("string" != typeof t) {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
c = r === p, s = s || c;
}
if (!s) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), p++, l.errors = i, !1;
}
p = n, null !== i && (n ? i.length = n : i = null), f = e === p;
} else f = !0;
if (f) if (void 0 !== r.umdNamedDefine) {
const t = p;
if ("boolean" != typeof r.umdNamedDefine) return l.errors = [ {
params: {
type: "boolean"
}
} ], !1;
f = t === p;
} else f = !0;
}
}
}
}
}
}
}
return l.errors = i, 0 === p;
}
function i(t, {instancePath: e = "", parentData: n, parentDataProperty: a, rootData: o = t} = {}) {
let p = null, f = 0;
if (0 === f) {
if (!t || "object" != typeof t || Array.isArray(t)) return i.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let n;
if (void 0 === t.name && (n = "name") || void 0 === t.exposes && (n = "exposes")) return i.errors = [ {
params: {
missingProperty: n
}
} ], !1;
{
const n = f;
for (const r in t) if ("exposes" !== r && "filename" !== r && "library" !== r && "name" !== r && "runtime" !== r && "shareScope" !== r) return i.errors = [ {
params: {
additionalProperty: r
}
} ], !1;
if (n === f) {
if (void 0 !== t.exposes) {
const r = f;
s(t.exposes, {
instancePath: e + "/exposes",
parentData: t,
parentDataProperty: "exposes",
rootData: o
}) || (p = null === p ? s.errors : p.concat(s.errors), f = p.length);
var u = r === f;
} else u = !0;
if (u) {
if (void 0 !== t.filename) {
let e = t.filename;
const n = f;
if (f === n) {
if ("string" != typeof e) return i.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.includes("!") || !1 !== r.test(e)) return i.errors = [ {
params: {}
} ], !1;
if (e.length < 1) return i.errors = [ {
params: {}
} ], !1;
}
u = n === f;
} else u = !0;
if (u) {
if (void 0 !== t.library) {
const r = f;
l(t.library, {
instancePath: e + "/library",
parentData: t,
parentDataProperty: "library",
rootData: o
}) || (p = null === p ? l.errors : p.concat(l.errors), f = p.length), u = r === f;
} else u = !0;
if (u) {
if (void 0 !== t.name) {
let r = t.name;
const e = f;
if (f === e) {
if ("string" != typeof r) return i.errors = [ {
params: {
type: "string"
}
} ], !1;
if (r.length < 1) return i.errors = [ {
params: {}
} ], !1;
}
u = e === f;
} else u = !0;
if (u) {
if (void 0 !== t.runtime) {
let r = t.runtime;
const e = f, n = f;
let s = !1;
const a = f;
if (!1 !== r) {
const r = {
params: {}
};
null === p ? p = [ r ] : p.push(r), f++;
}
var c = a === f;
if (s = s || c, !s) {
const t = f;
if (f === t) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === p ? p = [ r ] : p.push(r), f++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === p ? p = [ r ] : p.push(r), f++;
}
c = t === f, s = s || c;
}
if (!s) {
const r = {
params: {}
};
return null === p ? p = [ r ] : p.push(r), f++, i.errors = p, !1;
}
f = n, null !== p && (n ? p.length = n : p = null), u = e === f;
} else u = !0;
if (u) if (void 0 !== t.shareScope) {
let r = t.shareScope;
const e = f;
if (f === e) {
if ("string" != typeof r) return i.errors = [ {
params: {
type: "string"
}
} ], !1;
if (r.length < 1) return i.errors = [ {
params: {}
} ], !1;
}
u = e === f;
} else u = !0;
}
}
}
}
}
}
}
}
return i.errors = p, 0 === f;
}
module.exports = i, module.exports.default = i;
},
83832: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: a, parentDataProperty: n, rootData: o = t} = {}) {
if (!Array.isArray(t)) return r.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const e = t.length;
for (let a = 0; a < e; a++) {
let e = t[a];
const n = 0;
if ("string" != typeof e) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return r.errors = [ {
params: {}
} ], !1;
if (0 !== n) break;
}
}
return r.errors = null, !0;
}
function t(e, {instancePath: a = "", parentData: n, parentDataProperty: o, rootData: s = e} = {}) {
let l = null, p = 0;
if (0 === p) {
if (!e || "object" != typeof e || Array.isArray(e)) return t.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let n;
if (void 0 === e.external && (n = "external")) return t.errors = [ {
params: {
missingProperty: n
}
} ], !1;
{
const n = p;
for (const r in e) if ("external" !== r && "shareScope" !== r) return t.errors = [ {
params: {
additionalProperty: r
}
} ], !1;
if (n === p) {
if (void 0 !== e.external) {
let n = e.external;
const o = p, u = p;
let f = !1;
const m = p;
if (p == p) if ("string" == typeof n) {
if (n.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), p++;
}
var i = m === p;
if (f = f || i, !f) {
const t = p;
r(n, {
instancePath: a + "/external",
parentData: e,
parentDataProperty: "external",
rootData: s
}) || (l = null === l ? r.errors : l.concat(r.errors), p = l.length), i = t === p, 
f = f || i;
}
if (!f) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), p++, t.errors = l, !1;
}
p = u, null !== l && (u ? l.length = u : l = null);
var c = o === p;
} else c = !0;
if (c) if (void 0 !== e.shareScope) {
let r = e.shareScope;
const a = p;
if (p === a) {
if ("string" != typeof r) return t.errors = [ {
params: {
type: "string"
}
} ], !1;
if (r.length < 1) return t.errors = [ {
params: {}
} ], !1;
}
c = a === p;
} else c = !0;
}
}
}
}
return t.errors = l, 0 === p;
}
function e(a, {instancePath: n = "", parentData: o, parentDataProperty: s, rootData: l = a} = {}) {
let p = null, i = 0;
if (0 === i) {
if (!a || "object" != typeof a || Array.isArray(a)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const o in a) {
let s = a[o];
const u = i, f = i;
let m = !1;
const y = i;
t(s, {
instancePath: n + "/" + o.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: a,
parentDataProperty: o,
rootData: l
}) || (p = null === p ? t.errors : p.concat(t.errors), i = p.length);
var c = y === i;
if (m = m || c, !m) {
const t = i;
if (i == i) if ("string" == typeof s) {
if (s.length < 1) {
const r = {
params: {}
};
null === p ? p = [ r ] : p.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === p ? p = [ r ] : p.push(r), i++;
}
if (c = t === i, m = m || c, !m) {
const t = i;
r(s, {
instancePath: n + "/" + o.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: a,
parentDataProperty: o,
rootData: l
}) || (p = null === p ? r.errors : p.concat(r.errors), i = p.length), c = t === i, 
m = m || c;
}
}
if (!m) {
const r = {
params: {}
};
return null === p ? p = [ r ] : p.push(r), i++, e.errors = p, !1;
}
if (i = f, null !== p && (f ? p.length = f : p = null), u !== i) break;
}
}
return e.errors = p, 0 === i;
}
function a(r, {instancePath: t = "", parentData: n, parentDataProperty: o, rootData: s = r} = {}) {
let l = null, p = 0;
const i = p;
let c = !1;
const u = p;
if (p === u) if (Array.isArray(r)) {
const a = r.length;
for (let n = 0; n < a; n++) {
let a = r[n];
const o = p, i = p;
let c = !1;
const u = p;
if (p == p) if ("string" == typeof a) {
if (a.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), p++;
}
var f = u === p;
if (c = c || f, !c) {
const o = p;
e(a, {
instancePath: t + "/" + n,
parentData: r,
parentDataProperty: n,
rootData: s
}) || (l = null === l ? e.errors : l.concat(e.errors), p = l.length), f = o === p, 
c = c || f;
}
if (c) p = i, null !== l && (i ? l.length = i : l = null); else {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), p++;
}
if (o !== p) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === l ? l = [ r ] : l.push(r), p++;
}
var m = u === p;
if (c = c || m, !c) {
const a = p;
e(r, {
instancePath: t,
parentData: n,
parentDataProperty: o,
rootData: s
}) || (l = null === l ? e.errors : l.concat(e.errors), p = l.length), m = a === p, 
c = c || m;
}
if (!c) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), p++, a.errors = l, !1;
}
return p = i, null !== l && (i ? l.length = i : l = null), a.errors = l, 0 === p;
}
function n(r, {instancePath: t = "", parentData: e, parentDataProperty: o, rootData: s = r} = {}) {
let l = null, p = 0;
if (0 === p) {
if (!r || "object" != typeof r || Array.isArray(r)) return n.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === r.remoteType && (e = "remoteType") || void 0 === r.remotes && (e = "remotes")) return n.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = p;
for (const t in r) if ("remoteType" !== t && "remotes" !== t && "shareScope" !== t) return n.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (e === p) {
if (void 0 !== r.remoteType) {
let t = r.remoteType;
const e = p, a = p;
let o = !1, s = null;
const c = p;
if ("var" !== t && "module" !== t && "assign" !== t && "this" !== t && "window" !== t && "self" !== t && "global" !== t && "commonjs" !== t && "commonjs2" !== t && "commonjs-module" !== t && "commonjs-static" !== t && "amd" !== t && "amd-require" !== t && "umd" !== t && "umd2" !== t && "jsonp" !== t && "system" !== t && "promise" !== t && "import" !== t && "script" !== t && "node-commonjs" !== t) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), p++;
}
if (c === p && (o = !0, s = 0), !o) {
const r = {
params: {
passingSchemas: s
}
};
return null === l ? l = [ r ] : l.push(r), p++, n.errors = l, !1;
}
p = a, null !== l && (a ? l.length = a : l = null);
var i = e === p;
} else i = !0;
if (i) {
if (void 0 !== r.remotes) {
const e = p;
a(r.remotes, {
instancePath: t + "/remotes",
parentData: r,
parentDataProperty: "remotes",
rootData: s
}) || (l = null === l ? a.errors : l.concat(a.errors), p = l.length), i = e === p;
} else i = !0;
if (i) if (void 0 !== r.shareScope) {
let t = r.shareScope;
const e = p;
if (p === e) {
if ("string" != typeof t) return n.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return n.errors = [ {
params: {}
} ], !1;
}
i = e === p;
} else i = !0;
}
}
}
}
}
return n.errors = l, 0 === p;
}
module.exports = n, module.exports.default = n;
},
9530: module => {
"use strict";
function o(r, {instancePath: s = "", parentData: m, parentDataProperty: t, rootData: e = r} = {}) {
return "var" !== r && "module" !== r && "assign" !== r && "this" !== r && "window" !== r && "self" !== r && "global" !== r && "commonjs" !== r && "commonjs2" !== r && "commonjs-module" !== r && "commonjs-static" !== r && "amd" !== r && "amd-require" !== r && "umd" !== r && "umd2" !== r && "jsonp" !== r && "system" !== r && "promise" !== r && "import" !== r && "script" !== r && "node-commonjs" !== r ? (o.errors = [ {
params: {}
} ], !1) : (o.errors = null, !0);
}
module.exports = o, module.exports.default = o;
},
68979: module => {
const r = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
module.exports = d, module.exports.default = d;
const t = {
exposes: {
$ref: "#/definitions/Exposes"
},
filename: {
type: "string",
absolutePath: !1
},
library: {
$ref: "#/definitions/LibraryOptions"
},
name: {
type: "string"
},
remoteType: {
oneOf: [ {
$ref: "#/definitions/ExternalsType"
} ]
},
remotes: {
$ref: "#/definitions/Remotes"
},
runtime: {
$ref: "#/definitions/EntryRuntime"
},
shareScope: {
type: "string",
minLength: 1
},
shared: {
$ref: "#/definitions/Shared"
}
}, e = Object.prototype.hasOwnProperty;
function n(r, {instancePath: t = "", parentData: e, parentDataProperty: a, rootData: s = r} = {}) {
if (!Array.isArray(r)) return n.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = r.length;
for (let e = 0; e < t; e++) {
let t = r[e];
const a = 0;
if ("string" != typeof t) return n.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return n.errors = [ {
params: {}
} ], !1;
if (0 !== a) break;
}
}
return n.errors = null, !0;
}
function a(r, {instancePath: t = "", parentData: e, parentDataProperty: s, rootData: o = r} = {}) {
let l = null, i = 0;
if (0 === i) {
if (!r || "object" != typeof r || Array.isArray(r)) return a.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === r.import && (e = "import")) return a.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = i;
for (const t in r) if ("import" !== t && "name" !== t) return a.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (e === i) {
if (void 0 !== r.import) {
let e = r.import;
const s = i, c = i;
let u = !1;
const m = i;
if (i == i) if ("string" == typeof e) {
if (e.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var p = m === i;
if (u = u || p, !u) {
const a = i;
n(e, {
instancePath: t + "/import",
parentData: r,
parentDataProperty: "import",
rootData: o
}) || (l = null === l ? n.errors : l.concat(n.errors), i = l.length), p = a === i, 
u = u || p;
}
if (!u) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), i++, a.errors = l, !1;
}
i = c, null !== l && (c ? l.length = c : l = null);
var f = s === i;
} else f = !0;
if (f) if (void 0 !== r.name) {
const t = i;
if ("string" != typeof r.name) return a.errors = [ {
params: {
type: "string"
}
} ], !1;
f = t === i;
} else f = !0;
}
}
}
}
return a.errors = l, 0 === i;
}
function s(r, {instancePath: t = "", parentData: e, parentDataProperty: o, rootData: l = r} = {}) {
let i = null, p = 0;
if (0 === p) {
if (!r || "object" != typeof r || Array.isArray(r)) return s.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in r) {
let o = r[e];
const c = p, u = p;
let m = !1;
const y = p;
a(o, {
instancePath: t + "/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: e,
rootData: l
}) || (i = null === i ? a.errors : i.concat(a.errors), p = i.length);
var f = y === p;
if (m = m || f, !m) {
const a = p;
if (p == p) if ("string" == typeof o) {
if (o.length < 1) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
if (f = a === p, m = m || f, !m) {
const a = p;
n(o, {
instancePath: t + "/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: e,
rootData: l
}) || (i = null === i ? n.errors : i.concat(n.errors), p = i.length), f = a === p, 
m = m || f;
}
}
if (!m) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), p++, s.errors = i, !1;
}
if (p = u, null !== i && (u ? i.length = u : i = null), c !== p) break;
}
}
return s.errors = i, 0 === p;
}
function o(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let l = null, i = 0;
const p = i;
let f = !1;
const c = i;
if (i === c) if (Array.isArray(r)) {
const e = r.length;
for (let n = 0; n < e; n++) {
let e = r[n];
const o = i, p = i;
let f = !1;
const c = i;
if (i == i) if ("string" == typeof e) {
if (e.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var u = c === i;
if (f = f || u, !f) {
const o = i;
s(e, {
instancePath: t + "/" + n,
parentData: r,
parentDataProperty: n,
rootData: a
}) || (l = null === l ? s.errors : l.concat(s.errors), i = l.length), u = o === i, 
f = f || u;
}
if (f) i = p, null !== l && (p ? l.length = p : l = null); else {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
if (o !== i) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var m = c === i;
if (f = f || m, !f) {
const o = i;
s(r, {
instancePath: t,
parentData: e,
parentDataProperty: n,
rootData: a
}) || (l = null === l ? s.errors : l.concat(s.errors), i = l.length), m = o === i, 
f = f || m;
}
if (!f) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), i++, o.errors = l, !1;
}
return i = p, null !== l && (p ? l.length = p : l = null), o.errors = l, 0 === i;
}
function l(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
const i = o;
let p = !1;
const f = o;
if ("string" != typeof r) {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var c = f === o;
if (p = p || c, !p) {
const t = o;
if (o == o) if (r && "object" == typeof r && !Array.isArray(r)) {
const t = o;
for (const t in r) if ("amd" !== t && "commonjs" !== t && "commonjs2" !== t && "root" !== t) {
const r = {
params: {
additionalProperty: t
}
};
null === s ? s = [ r ] : s.push(r), o++;
break;
}
if (t === o) {
if (void 0 !== r.amd) {
const t = o;
if ("string" != typeof r.amd) {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var u = t === o;
} else u = !0;
if (u) {
if (void 0 !== r.commonjs) {
const t = o;
if ("string" != typeof r.commonjs) {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
u = t === o;
} else u = !0;
if (u) {
if (void 0 !== r.commonjs2) {
const t = o;
if ("string" != typeof r.commonjs2) {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
u = t === o;
} else u = !0;
if (u) if (void 0 !== r.root) {
const t = o;
if ("string" != typeof r.root) {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
u = t === o;
} else u = !0;
}
}
}
} else {
const r = {
params: {
type: "object"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
c = t === o, p = p || c;
}
if (!p) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, l.errors = s, !1;
}
return o = i, null !== s && (i ? s.length = i : s = null), l.errors = s, 0 === o;
}
function i(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
const l = o;
let p = !1;
const f = o;
if (o === f) if (Array.isArray(r)) if (r.length < 1) {
const r = {
params: {
limit: 1
}
};
null === s ? s = [ r ] : s.push(r), o++;
} else {
const t = r.length;
for (let e = 0; e < t; e++) {
let t = r[e];
const n = o;
if (o === n) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (n !== o) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var c = f === o;
if (p = p || c, !p) {
const t = o;
if (o === t) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (c = t === o, p = p || c, !p) {
const t = o;
if (o == o) if (r && "object" == typeof r && !Array.isArray(r)) {
const t = o;
for (const t in r) if ("amd" !== t && "commonjs" !== t && "root" !== t) {
const r = {
params: {
additionalProperty: t
}
};
null === s ? s = [ r ] : s.push(r), o++;
break;
}
if (t === o) {
if (void 0 !== r.amd) {
let t = r.amd;
const e = o;
if (o === e) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var u = e === o;
} else u = !0;
if (u) {
if (void 0 !== r.commonjs) {
let t = r.commonjs;
const e = o;
if (o === e) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
u = e === o;
} else u = !0;
if (u) if (void 0 !== r.root) {
let t = r.root;
const e = o, n = o;
let a = !1;
const l = o;
if (o === l) if (Array.isArray(t)) {
const r = t.length;
for (let e = 0; e < r; e++) {
let r = t[e];
const n = o;
if (o === n) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (n !== o) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var m = l === o;
if (a = a || m, !a) {
const r = o;
if (o === r) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
m = r === o, a = a || m;
}
if (a) o = n, null !== s && (n ? s.length = n : s = null); else {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
u = e === o;
} else u = !0;
}
}
} else {
const r = {
params: {
type: "object"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
c = t === o, p = p || c;
}
}
if (!p) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, i.errors = s, !1;
}
return o = l, null !== s && (l ? s.length = l : s = null), i.errors = s, 0 === o;
}
function p(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
if (0 === o) {
if (!r || "object" != typeof r || Array.isArray(r)) return p.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === r.type && (e = "type")) return p.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = o;
for (const t in r) if ("auxiliaryComment" !== t && "export" !== t && "name" !== t && "type" !== t && "umdNamedDefine" !== t) return p.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (e === o) {
if (void 0 !== r.auxiliaryComment) {
const e = o;
l(r.auxiliaryComment, {
instancePath: t + "/auxiliaryComment",
parentData: r,
parentDataProperty: "auxiliaryComment",
rootData: a
}) || (s = null === s ? l.errors : s.concat(l.errors), o = s.length);
var f = e === o;
} else f = !0;
if (f) {
if (void 0 !== r.export) {
let t = r.export;
const e = o, n = o;
let a = !1;
const l = o;
if (o === l) if (Array.isArray(t)) {
const r = t.length;
for (let e = 0; e < r; e++) {
let r = t[e];
const n = o;
if (o === n) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (n !== o) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var c = l === o;
if (a = a || c, !a) {
const r = o;
if (o === r) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
c = r === o, a = a || c;
}
if (!a) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, p.errors = s, !1;
}
o = n, null !== s && (n ? s.length = n : s = null), f = e === o;
} else f = !0;
if (f) {
if (void 0 !== r.name) {
const e = o;
i(r.name, {
instancePath: t + "/name",
parentData: r,
parentDataProperty: "name",
rootData: a
}) || (s = null === s ? i.errors : s.concat(i.errors), o = s.length), f = e === o;
} else f = !0;
if (f) {
if (void 0 !== r.type) {
let t = r.type;
const e = o, n = o;
let a = !1;
const l = o;
if ("var" !== t && "module" !== t && "assign" !== t && "assign-properties" !== t && "this" !== t && "window" !== t && "self" !== t && "global" !== t && "commonjs" !== t && "commonjs2" !== t && "commonjs-module" !== t && "commonjs-static" !== t && "amd" !== t && "amd-require" !== t && "umd" !== t && "umd2" !== t && "jsonp" !== t && "system" !== t) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var u = l === o;
if (a = a || u, !a) {
const r = o;
if ("string" != typeof t) {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
u = r === o, a = a || u;
}
if (!a) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, p.errors = s, !1;
}
o = n, null !== s && (n ? s.length = n : s = null), f = e === o;
} else f = !0;
if (f) if (void 0 !== r.umdNamedDefine) {
const t = o;
if ("boolean" != typeof r.umdNamedDefine) return p.errors = [ {
params: {
type: "boolean"
}
} ], !1;
f = t === o;
} else f = !0;
}
}
}
}
}
}
}
return p.errors = s, 0 === o;
}
function f(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
if (!Array.isArray(r)) return f.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const t = r.length;
for (let e = 0; e < t; e++) {
let t = r[e];
const n = 0;
if ("string" != typeof t) return f.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return f.errors = [ {
params: {}
} ], !1;
if (0 !== n) break;
}
}
return f.errors = null, !0;
}
function c(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
if (0 === o) {
if (!r || "object" != typeof r || Array.isArray(r)) return c.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let e;
if (void 0 === r.external && (e = "external")) return c.errors = [ {
params: {
missingProperty: e
}
} ], !1;
{
const e = o;
for (const t in r) if ("external" !== t && "shareScope" !== t) return c.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (e === o) {
if (void 0 !== r.external) {
let e = r.external;
const n = o, p = o;
let u = !1;
const m = o;
if (o == o) if ("string" == typeof e) {
if (e.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var l = m === o;
if (u = u || l, !u) {
const n = o;
f(e, {
instancePath: t + "/external",
parentData: r,
parentDataProperty: "external",
rootData: a
}) || (s = null === s ? f.errors : s.concat(f.errors), o = s.length), l = n === o, 
u = u || l;
}
if (!u) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, c.errors = s, !1;
}
o = p, null !== s && (p ? s.length = p : s = null);
var i = n === o;
} else i = !0;
if (i) if (void 0 !== r.shareScope) {
let t = r.shareScope;
const e = o;
if (o === e) {
if ("string" != typeof t) return c.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return c.errors = [ {
params: {}
} ], !1;
}
i = e === o;
} else i = !0;
}
}
}
}
return c.errors = s, 0 === o;
}
function u(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
if (0 === o) {
if (!r || "object" != typeof r || Array.isArray(r)) return u.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in r) {
let n = r[e];
const i = o, p = o;
let m = !1;
const y = o;
c(n, {
instancePath: t + "/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: e,
rootData: a
}) || (s = null === s ? c.errors : s.concat(c.errors), o = s.length);
var l = y === o;
if (m = m || l, !m) {
const i = o;
if (o == o) if ("string" == typeof n) {
if (n.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (l = i === o, m = m || l, !m) {
const i = o;
f(n, {
instancePath: t + "/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: e,
rootData: a
}) || (s = null === s ? f.errors : s.concat(f.errors), o = s.length), l = i === o, 
m = m || l;
}
}
if (!m) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, u.errors = s, !1;
}
if (o = p, null !== s && (p ? s.length = p : s = null), i !== o) break;
}
}
return u.errors = s, 0 === o;
}
function m(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
const l = o;
let i = !1;
const p = o;
if (o === p) if (Array.isArray(r)) {
const e = r.length;
for (let n = 0; n < e; n++) {
let e = r[n];
const l = o, i = o;
let p = !1;
const c = o;
if (o == o) if ("string" == typeof e) {
if (e.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var f = c === o;
if (p = p || f, !p) {
const l = o;
u(e, {
instancePath: t + "/" + n,
parentData: r,
parentDataProperty: n,
rootData: a
}) || (s = null === s ? u.errors : s.concat(u.errors), o = s.length), f = l === o, 
p = p || f;
}
if (p) o = i, null !== s && (i ? s.length = i : s = null); else {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (l !== o) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var c = p === o;
if (i = i || c, !i) {
const l = o;
u(r, {
instancePath: t,
parentData: e,
parentDataProperty: n,
rootData: a
}) || (s = null === s ? u.errors : s.concat(u.errors), o = s.length), c = l === o, 
i = i || c;
}
if (!i) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, m.errors = s, !1;
}
return o = l, null !== s && (l ? s.length = l : s = null), m.errors = s, 0 === o;
}
const y = {
eager: {
type: "boolean"
},
import: {
anyOf: [ {
enum: [ !1 ]
}, {
$ref: "#/definitions/SharedItem"
} ]
},
packageName: {
type: "string",
minLength: 1
},
requiredVersion: {
anyOf: [ {
enum: [ !1 ]
}, {
type: "string"
} ]
},
shareKey: {
type: "string",
minLength: 1
},
shareScope: {
type: "string",
minLength: 1
},
singleton: {
type: "boolean"
},
strictVersion: {
type: "boolean"
},
version: {
anyOf: [ {
enum: [ !1 ]
}, {
type: "string"
} ]
}
};
function h(r, {instancePath: t = "", parentData: n, parentDataProperty: a, rootData: s = r} = {}) {
let o = null, l = 0;
if (0 === l) {
if (!r || "object" != typeof r || Array.isArray(r)) return h.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = l;
for (const t in r) if (!e.call(y, t)) return h.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === l) {
if (void 0 !== r.eager) {
const t = l;
if ("boolean" != typeof r.eager) return h.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var i = t === l;
} else i = !0;
if (i) {
if (void 0 !== r.import) {
let t = r.import;
const e = l, n = l;
let a = !1;
const s = l;
if (!1 !== t) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var p = s === l;
if (a = a || p, !a) {
const r = l;
if (l == l) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
p = r === l, a = a || p;
}
if (!a) {
const r = {
params: {}
};
return null === o ? o = [ r ] : o.push(r), l++, h.errors = o, !1;
}
l = n, null !== o && (n ? o.length = n : o = null), i = e === l;
} else i = !0;
if (i) {
if (void 0 !== r.packageName) {
let t = r.packageName;
const e = l;
if (l === e) {
if ("string" != typeof t) return h.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return h.errors = [ {
params: {}
} ], !1;
}
i = e === l;
} else i = !0;
if (i) {
if (void 0 !== r.requiredVersion) {
let t = r.requiredVersion;
const e = l, n = l;
let a = !1;
const s = l;
if (!1 !== t) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var f = s === l;
if (a = a || f, !a) {
const r = l;
if ("string" != typeof t) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
f = r === l, a = a || f;
}
if (!a) {
const r = {
params: {}
};
return null === o ? o = [ r ] : o.push(r), l++, h.errors = o, !1;
}
l = n, null !== o && (n ? o.length = n : o = null), i = e === l;
} else i = !0;
if (i) {
if (void 0 !== r.shareKey) {
let t = r.shareKey;
const e = l;
if (l === e) {
if ("string" != typeof t) return h.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return h.errors = [ {
params: {}
} ], !1;
}
i = e === l;
} else i = !0;
if (i) {
if (void 0 !== r.shareScope) {
let t = r.shareScope;
const e = l;
if (l === e) {
if ("string" != typeof t) return h.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return h.errors = [ {
params: {}
} ], !1;
}
i = e === l;
} else i = !0;
if (i) {
if (void 0 !== r.singleton) {
const t = l;
if ("boolean" != typeof r.singleton) return h.errors = [ {
params: {
type: "boolean"
}
} ], !1;
i = t === l;
} else i = !0;
if (i) {
if (void 0 !== r.strictVersion) {
const t = l;
if ("boolean" != typeof r.strictVersion) return h.errors = [ {
params: {
type: "boolean"
}
} ], !1;
i = t === l;
} else i = !0;
if (i) if (void 0 !== r.version) {
let t = r.version;
const e = l, n = l;
let a = !1;
const s = l;
if (!1 !== t) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var c = s === l;
if (a = a || c, !a) {
const r = l;
if ("string" != typeof t) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
c = r === l, a = a || c;
}
if (!a) {
const r = {
params: {}
};
return null === o ? o = [ r ] : o.push(r), l++, h.errors = o, !1;
}
l = n, null !== o && (n ? o.length = n : o = null), i = e === l;
} else i = !0;
}
}
}
}
}
}
}
}
}
}
return h.errors = o, 0 === l;
}
function g(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
if (0 === o) {
if (!r || "object" != typeof r || Array.isArray(r)) return g.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in r) {
let n = r[e];
const i = o, p = o;
let f = !1;
const c = o;
h(n, {
instancePath: t + "/" + e.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: r,
parentDataProperty: e,
rootData: a
}) || (s = null === s ? h.errors : s.concat(h.errors), o = s.length);
var l = c === o;
if (f = f || l, !f) {
const r = o;
if (o == o) if ("string" == typeof n) {
if (n.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
l = r === o, f = f || l;
}
if (!f) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, g.errors = s, !1;
}
if (o = p, null !== s && (p ? s.length = p : s = null), i !== o) break;
}
}
return g.errors = s, 0 === o;
}
function D(r, {instancePath: t = "", parentData: e, parentDataProperty: n, rootData: a = r} = {}) {
let s = null, o = 0;
const l = o;
let i = !1;
const p = o;
if (o === p) if (Array.isArray(r)) {
const e = r.length;
for (let n = 0; n < e; n++) {
let e = r[n];
const l = o, i = o;
let p = !1;
const c = o;
if (o == o) if ("string" == typeof e) {
if (e.length < 1) {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var f = c === o;
if (p = p || f, !p) {
const l = o;
g(e, {
instancePath: t + "/" + n,
parentData: r,
parentDataProperty: n,
rootData: a
}) || (s = null === s ? g.errors : s.concat(g.errors), o = s.length), f = l === o, 
p = p || f;
}
if (p) o = i, null !== s && (i ? s.length = i : s = null); else {
const r = {
params: {}
};
null === s ? s = [ r ] : s.push(r), o++;
}
if (l !== o) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === s ? s = [ r ] : s.push(r), o++;
}
var c = p === o;
if (i = i || c, !i) {
const l = o;
g(r, {
instancePath: t,
parentData: e,
parentDataProperty: n,
rootData: a
}) || (s = null === s ? g.errors : s.concat(g.errors), o = s.length), c = l === o, 
i = i || c;
}
if (!i) {
const r = {
params: {}
};
return null === s ? s = [ r ] : s.push(r), o++, D.errors = s, !1;
}
return o = l, null !== s && (l ? s.length = l : s = null), D.errors = s, 0 === o;
}
function d(n, {instancePath: a = "", parentData: s, parentDataProperty: l, rootData: i = n} = {}) {
let f = null, c = 0;
if (0 === c) {
if (!n || "object" != typeof n || Array.isArray(n)) return d.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const s = c;
for (const r in n) if (!e.call(t, r)) return d.errors = [ {
params: {
additionalProperty: r
}
} ], !1;
if (s === c) {
if (void 0 !== n.exposes) {
const r = c;
o(n.exposes, {
instancePath: a + "/exposes",
parentData: n,
parentDataProperty: "exposes",
rootData: i
}) || (f = null === f ? o.errors : f.concat(o.errors), c = f.length);
var u = r === c;
} else u = !0;
if (u) {
if (void 0 !== n.filename) {
let t = n.filename;
const e = c;
if (c === e) {
if ("string" != typeof t) return d.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.includes("!") || !1 !== r.test(t)) return d.errors = [ {
params: {}
} ], !1;
}
u = e === c;
} else u = !0;
if (u) {
if (void 0 !== n.library) {
const r = c;
p(n.library, {
instancePath: a + "/library",
parentData: n,
parentDataProperty: "library",
rootData: i
}) || (f = null === f ? p.errors : f.concat(p.errors), c = f.length), u = r === c;
} else u = !0;
if (u) {
if (void 0 !== n.name) {
const r = c;
if ("string" != typeof n.name) return d.errors = [ {
params: {
type: "string"
}
} ], !1;
u = r === c;
} else u = !0;
if (u) {
if (void 0 !== n.remoteType) {
let r = n.remoteType;
const t = c, e = c;
let a = !1, s = null;
const o = c;
if ("var" !== r && "module" !== r && "assign" !== r && "this" !== r && "window" !== r && "self" !== r && "global" !== r && "commonjs" !== r && "commonjs2" !== r && "commonjs-module" !== r && "commonjs-static" !== r && "amd" !== r && "amd-require" !== r && "umd" !== r && "umd2" !== r && "jsonp" !== r && "system" !== r && "promise" !== r && "import" !== r && "script" !== r && "node-commonjs" !== r) {
const r = {
params: {}
};
null === f ? f = [ r ] : f.push(r), c++;
}
if (o === c && (a = !0, s = 0), !a) {
const r = {
params: {
passingSchemas: s
}
};
return null === f ? f = [ r ] : f.push(r), c++, d.errors = f, !1;
}
c = e, null !== f && (e ? f.length = e : f = null), u = t === c;
} else u = !0;
if (u) {
if (void 0 !== n.remotes) {
const r = c;
m(n.remotes, {
instancePath: a + "/remotes",
parentData: n,
parentDataProperty: "remotes",
rootData: i
}) || (f = null === f ? m.errors : f.concat(m.errors), c = f.length), u = r === c;
} else u = !0;
if (u) {
if (void 0 !== n.runtime) {
let r = n.runtime;
const t = c, e = c;
let a = !1;
const s = c;
if (!1 !== r) {
const r = {
params: {}
};
null === f ? f = [ r ] : f.push(r), c++;
}
var y = s === c;
if (a = a || y, !a) {
const t = c;
if (c === t) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === f ? f = [ r ] : f.push(r), c++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === f ? f = [ r ] : f.push(r), c++;
}
y = t === c, a = a || y;
}
if (!a) {
const r = {
params: {}
};
return null === f ? f = [ r ] : f.push(r), c++, d.errors = f, !1;
}
c = e, null !== f && (e ? f.length = e : f = null), u = t === c;
} else u = !0;
if (u) {
if (void 0 !== n.shareScope) {
let r = n.shareScope;
const t = c;
if (c === t) {
if ("string" != typeof r) return d.errors = [ {
params: {
type: "string"
}
} ], !1;
if (r.length < 1) return d.errors = [ {
params: {}
} ], !1;
}
u = t === c;
} else u = !0;
if (u) if (void 0 !== n.shared) {
const r = c;
D(n.shared, {
instancePath: a + "/shared",
parentData: n,
parentDataProperty: "shared",
rootData: i
}) || (f = null === f ? D.errors : f.concat(D.errors), c = f.length), u = r === c;
} else u = !0;
}
}
}
}
}
}
}
}
}
}
return d.errors = f, 0 === c;
}
},
55391: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: a, parentDataProperty: o, rootData: n = t} = {}) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return r.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
380: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: a, parentDataProperty: o, rootData: n = t} = {}) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) return r.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
15919: module => {
const r = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
function t(e, {instancePath: a = "", parentData: o, parentDataProperty: n, rootData: s = e} = {}) {
if (!e || "object" != typeof e || Array.isArray(e)) return t.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const a = 0;
for (const r in e) if ("outputPath" !== r) return t.errors = [ {
params: {
additionalProperty: r
}
} ], !1;
if (0 === a && void 0 !== e.outputPath) {
let a = e.outputPath;
if ("string" != typeof a) return t.errors = [ {
params: {
type: "string"
}
} ], !1;
if (a.includes("!") || !0 !== r.test(a)) return t.errors = [ {
params: {}
} ], !1;
}
}
return t.errors = null, !0;
}
module.exports = t, module.exports.default = t;
},
12599: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: o, parentDataProperty: a, rootData: i = t} = {}) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const e = 0;
for (const e in t) if ("prioritiseInitial" !== e) return r.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (0 === e && void 0 !== t.prioritiseInitial && "boolean" != typeof t.prioritiseInitial) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
29209: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: o, parentDataProperty: a, rootData: i = t} = {}) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const e = 0;
for (const e in t) if ("prioritiseInitial" !== e) return r.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (0 === e && void 0 !== t.prioritiseInitial && "boolean" != typeof t.prioritiseInitial) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
65623: module => {
"use strict";
function r(e, {instancePath: t = "", parentData: n, parentDataProperty: i, rootData: o = e} = {}) {
if (!e || "object" != typeof e || Array.isArray(e)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = 0;
for (const t in e) if ("chunkOverhead" !== t && "entryChunkMultiplicator" !== t && "maxSize" !== t && "minSize" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (0 === t) {
if (void 0 !== e.chunkOverhead) {
const t = 0;
if ("number" != typeof e.chunkOverhead) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
var a = 0 === t;
} else a = !0;
if (a) {
if (void 0 !== e.entryChunkMultiplicator) {
const t = 0;
if ("number" != typeof e.entryChunkMultiplicator) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
a = 0 === t;
} else a = !0;
if (a) {
if (void 0 !== e.maxSize) {
const t = 0;
if ("number" != typeof e.maxSize) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
a = 0 === t;
} else a = !0;
if (a) if (void 0 !== e.minSize) {
const t = 0;
if ("number" != typeof e.minSize) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
a = 0 === t;
} else a = !0;
}
}
}
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
87810: module => {
"use strict";
function r(e, {instancePath: t = "", parentData: n, parentDataProperty: a, rootData: o = e} = {}) {
if (!e || "object" != typeof e || Array.isArray(e)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let t;
if (void 0 === e.maxChunks && (t = "maxChunks")) return r.errors = [ {
params: {
missingProperty: t
}
} ], !1;
{
const t = 0;
for (const t in e) if ("chunkOverhead" !== t && "entryChunkMultiplicator" !== t && "maxChunks" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (0 === t) {
if (void 0 !== e.chunkOverhead) {
const t = 0;
if ("number" != typeof e.chunkOverhead) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
var s = 0 === t;
} else s = !0;
if (s) {
if (void 0 !== e.entryChunkMultiplicator) {
const t = 0;
if ("number" != typeof e.entryChunkMultiplicator) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
s = 0 === t;
} else s = !0;
if (s) if (void 0 !== e.maxChunks) {
let t = e.maxChunks;
const n = 0;
if (0 === n) {
if ("number" != typeof t) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
if (t < 1 || isNaN(t)) return r.errors = [ {
params: {
comparison: ">=",
limit: 1
}
} ], !1;
}
s = 0 === n;
} else s = !0;
}
}
}
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
12383: module => {
"use strict";
function r(e, {instancePath: t = "", parentData: n, parentDataProperty: i, rootData: o = e} = {}) {
if (!e || "object" != typeof e || Array.isArray(e)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let t;
if (void 0 === e.minChunkSize && (t = "minChunkSize")) return r.errors = [ {
params: {
missingProperty: t
}
} ], !1;
{
const t = 0;
for (const t in e) if ("chunkOverhead" !== t && "entryChunkMultiplicator" !== t && "minChunkSize" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (0 === t) {
if (void 0 !== e.chunkOverhead) {
const t = 0;
if ("number" != typeof e.chunkOverhead) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
var a = 0 === t;
} else a = !0;
if (a) {
if (void 0 !== e.entryChunkMultiplicator) {
const t = 0;
if ("number" != typeof e.entryChunkMultiplicator) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
a = 0 === t;
} else a = !0;
if (a) if (void 0 !== e.minChunkSize) {
const t = 0;
if ("number" != typeof e.minChunkSize) return r.errors = [ {
params: {
type: "number"
}
} ], !1;
a = 0 === t;
} else a = !0;
}
}
}
}
return r.errors = null, !0;
}
module.exports = r, module.exports.default = r;
},
4485: module => {
const r = /^(?:[A-Za-z]:[\\/]|\\\\|\/)/;
module.exports = n, module.exports.default = n;
const t = new RegExp("^https?://", "u");
function e(n, {instancePath: o = "", parentData: s, parentDataProperty: a, rootData: l = n} = {}) {
let i = null, p = 0;
if (0 === p) {
if (!n || "object" != typeof n || Array.isArray(n)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let o;
if (void 0 === n.allowedUris && (o = "allowedUris")) return e.errors = [ {
params: {
missingProperty: o
}
} ], !1;
{
const o = p;
for (const r in n) if ("allowedUris" !== r && "cacheLocation" !== r && "frozen" !== r && "lockfileLocation" !== r && "proxy" !== r && "upgrade" !== r) return e.errors = [ {
params: {
additionalProperty: r
}
} ], !1;
if (o === p) {
if (void 0 !== n.allowedUris) {
let r = n.allowedUris;
const o = p;
if (p == p) {
if (!Array.isArray(r)) return e.errors = [ {
params: {
type: "array"
}
} ], !1;
{
const n = r.length;
for (let o = 0; o < n; o++) {
let n = r[o];
const s = p, a = p;
let l = !1;
const c = p;
if (!(n instanceof RegExp)) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
var f = c === p;
if (l = l || f, !l) {
const r = p;
if (p === r) if ("string" == typeof n) {
if (!t.test(n)) {
const r = {
params: {
pattern: "^https?://"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
if (f = r === p, l = l || f, !l) {
const r = p;
if (!(n instanceof Function)) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
f = r === p, l = l || f;
}
}
if (!l) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), p++, e.errors = i, !1;
}
if (p = a, null !== i && (a ? i.length = a : i = null), s !== p) break;
}
}
}
var c = o === p;
} else c = !0;
if (c) {
if (void 0 !== n.cacheLocation) {
let t = n.cacheLocation;
const o = p, s = p;
let a = !1;
const l = p;
if (!1 !== t) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
var u = l === p;
if (a = a || u, !a) {
const e = p;
if (p === e) if ("string" == typeof t) {
if (t.includes("!") || !0 !== r.test(t)) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), p++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), p++;
}
u = e === p, a = a || u;
}
if (!a) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), p++, e.errors = i, !1;
}
p = s, null !== i && (s ? i.length = s : i = null), c = o === p;
} else c = !0;
if (c) {
if (void 0 !== n.frozen) {
const r = p;
if ("boolean" != typeof n.frozen) return e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = r === p;
} else c = !0;
if (c) {
if (void 0 !== n.lockfileLocation) {
let t = n.lockfileLocation;
const o = p;
if (p === o) {
if ("string" != typeof t) return e.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.includes("!") || !0 !== r.test(t)) return e.errors = [ {
params: {}
} ], !1;
}
c = o === p;
} else c = !0;
if (c) {
if (void 0 !== n.proxy) {
const r = p;
if ("string" != typeof n.proxy) return e.errors = [ {
params: {
type: "string"
}
} ], !1;
c = r === p;
} else c = !0;
if (c) if (void 0 !== n.upgrade) {
const r = p;
if ("boolean" != typeof n.upgrade) return e.errors = [ {
params: {
type: "boolean"
}
} ], !1;
c = r === p;
} else c = !0;
}
}
}
}
}
}
}
}
return e.errors = i, 0 === p;
}
function n(r, {instancePath: t = "", parentData: o, parentDataProperty: s, rootData: a = r} = {}) {
let l = null, i = 0;
const p = i;
let f = !1, c = null;
const u = i;
if (e(r, {
instancePath: t,
parentData: o,
parentDataProperty: s,
rootData: a
}) || (l = null === l ? e.errors : l.concat(e.errors), i = l.length), u === i && (f = !0, 
c = 0), !f) {
const r = {
params: {
passingSchemas: c
}
};
return null === l ? l = [ r ] : l.push(r), i++, n.errors = l, !1;
}
return i = p, null !== l && (p ? l.length = p : l = null), n.errors = l, 0 === i;
}
},
35842: module => {
"use strict";
function r(e, {instancePath: t = "", parentData: n, parentDataProperty: s, rootData: a = e} = {}) {
let o = null, i = 0;
if (0 === i) {
if (!e || "object" != typeof e || Array.isArray(e)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
{
const t = i;
for (const t in e) if ("eager" !== t && "import" !== t && "packageName" !== t && "requiredVersion" !== t && "shareKey" !== t && "shareScope" !== t && "singleton" !== t && "strictVersion" !== t) return r.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (t === i) {
if (void 0 !== e.eager) {
const t = i;
if ("boolean" != typeof e.eager) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
var l = t === i;
} else l = !0;
if (l) {
if (void 0 !== e.import) {
let t = e.import;
const n = i, s = i;
let a = !1;
const f = i;
if (!1 !== t) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), i++;
}
var p = f === i;
if (a = a || p, !a) {
const r = i;
if (i == i) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), i++;
}
p = r === i, a = a || p;
}
if (!a) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), i++, r.errors = o, !1;
}
i = s, null !== o && (s ? o.length = s : o = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.packageName) {
let t = e.packageName;
const n = i;
if (i === n) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.requiredVersion) {
let t = e.requiredVersion;
const n = i, s = i;
let a = !1;
const p = i;
if (!1 !== t) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), i++;
}
var f = p === i;
if (a = a || f, !a) {
const r = i;
if ("string" != typeof t) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), i++;
}
f = r === i, a = a || f;
}
if (!a) {
const e = {
params: {}
};
return null === o ? o = [ e ] : o.push(e), i++, r.errors = o, !1;
}
i = s, null !== o && (s ? o.length = s : o = null), l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.shareKey) {
let t = e.shareKey;
const n = i;
if (i === n) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.shareScope) {
let t = e.shareScope;
const n = i;
if (i === n) {
if ("string" != typeof t) return r.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return r.errors = [ {
params: {}
} ], !1;
}
l = n === i;
} else l = !0;
if (l) {
if (void 0 !== e.singleton) {
const t = i;
if ("boolean" != typeof e.singleton) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
if (l) if (void 0 !== e.strictVersion) {
const t = i;
if ("boolean" != typeof e.strictVersion) return r.errors = [ {
params: {
type: "boolean"
}
} ], !1;
l = t === i;
} else l = !0;
}
}
}
}
}
}
}
}
}
return r.errors = o, 0 === i;
}
function e(t, {instancePath: n = "", parentData: s, parentDataProperty: a, rootData: o = t} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const s in t) {
let a = t[s];
const f = l, c = l;
let u = !1;
const y = l;
r(a, {
instancePath: n + "/" + s.replace(/~/g, "~0").replace(/\//g, "~1"),
parentData: t,
parentDataProperty: s,
rootData: o
}) || (i = null === i ? r.errors : i.concat(r.errors), l = i.length);
var p = y === l;
if (u = u || p, !u) {
const r = l;
if (l == l) if ("string" == typeof a) {
if (a.length < 1) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), l++;
}
p = r === l, u = u || p;
}
if (!u) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), l++, e.errors = i, !1;
}
if (l = c, null !== i && (c ? i.length = c : i = null), f !== l) break;
}
}
return e.errors = i, 0 === l;
}
function t(r, {instancePath: n = "", parentData: s, parentDataProperty: a, rootData: o = r} = {}) {
let i = null, l = 0;
const p = l;
let f = !1;
const c = l;
if (l === c) if (Array.isArray(r)) {
const t = r.length;
for (let s = 0; s < t; s++) {
let t = r[s];
const a = l, p = l;
let f = !1;
const c = l;
if (l == l) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === i ? i = [ r ] : i.push(r), l++;
}
var u = c === l;
if (f = f || u, !f) {
const a = l;
e(t, {
instancePath: n + "/" + s,
parentData: r,
parentDataProperty: s,
rootData: o
}) || (i = null === i ? e.errors : i.concat(e.errors), l = i.length), u = a === l, 
f = f || u;
}
if (f) l = p, null !== i && (p ? i.length = p : i = null); else {
const r = {
params: {}
};
null === i ? i = [ r ] : i.push(r), l++;
}
if (a !== l) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === i ? i = [ r ] : i.push(r), l++;
}
var y = c === l;
if (f = f || y, !f) {
const t = l;
e(r, {
instancePath: n,
parentData: s,
parentDataProperty: a,
rootData: o
}) || (i = null === i ? e.errors : i.concat(e.errors), l = i.length), y = t === l, 
f = f || y;
}
if (!f) {
const r = {
params: {}
};
return null === i ? i = [ r ] : i.push(r), l++, t.errors = i, !1;
}
return l = p, null !== i && (p ? i.length = p : i = null), t.errors = i, 0 === l;
}
function n(r, {instancePath: e = "", parentData: s, parentDataProperty: a, rootData: o = r} = {}) {
let i = null, l = 0;
if (0 === l) {
if (!r || "object" != typeof r || Array.isArray(r)) return n.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let s;
if (void 0 === r.consumes && (s = "consumes")) return n.errors = [ {
params: {
missingProperty: s
}
} ], !1;
{
const s = l;
for (const e in r) if ("consumes" !== e && "shareScope" !== e) return n.errors = [ {
params: {
additionalProperty: e
}
} ], !1;
if (s === l) {
if (void 0 !== r.consumes) {
const n = l;
t(r.consumes, {
instancePath: e + "/consumes",
parentData: r,
parentDataProperty: "consumes",
rootData: o
}) || (i = null === i ? t.errors : i.concat(t.errors), l = i.length);
var p = n === l;
} else p = !0;
if (p) if (void 0 !== r.shareScope) {
let e = r.shareScope;
const t = l;
if (l === t) {
if ("string" != typeof e) return n.errors = [ {
params: {
type: "string"
}
} ], !1;
if (e.length < 1) return n.errors = [ {
params: {}
} ], !1;
}
p = t === l;
} else p = !0;
}
}
}
}
return n.errors = i, 0 === l;
}
module.exports = n, module.exports.default = n;
},
34355: module => {
"use strict";
function r(t, {instancePath: e = "", parentData: s, parentDataProperty: n, rootData: a = t} = {}) {
let o = null, l = 0;
if (0 === l) {
if (!t || "object" != typeof t || Array.isArray(t)) return r.errors = [ {
params: {
type: "object"
}
} ], !1;
for (const e in t) {
let s = t[e];
const n = l, a = l;
let f = !1;
const u = l;
if (l == l) if (s && "object" == typeof s && !Array.isArray(s)) {
const r = l;
for (const r in s) if ("eager" !== r && "shareKey" !== r && "shareScope" !== r && "version" !== r) {
const t = {
params: {
additionalProperty: r
}
};
null === o ? o = [ t ] : o.push(t), l++;
break;
}
if (r === l) {
if (void 0 !== s.eager) {
const r = l;
if ("boolean" != typeof s.eager) {
const r = {
params: {
type: "boolean"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var i = r === l;
} else i = !0;
if (i) {
if (void 0 !== s.shareKey) {
let r = s.shareKey;
const t = l;
if (l === t) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
i = t === l;
} else i = !0;
if (i) {
if (void 0 !== s.shareScope) {
let r = s.shareScope;
const t = l;
if (l === t) if ("string" == typeof r) {
if (r.length < 1) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
i = t === l;
} else i = !0;
if (i) if (void 0 !== s.version) {
let r = s.version;
const t = l, e = l;
let n = !1;
const a = l;
if (!1 !== r) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var p = a === l;
if (n = n || p, !n) {
const t = l;
if ("string" != typeof r) {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
p = t === l, n = n || p;
}
if (n) l = e, null !== o && (e ? o.length = e : o = null); else {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
i = t === l;
} else i = !0;
}
}
}
} else {
const r = {
params: {
type: "object"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
var c = u === l;
if (f = f || c, !f) {
const r = l;
if (l == l) if ("string" == typeof s) {
if (s.length < 1) {
const r = {
params: {}
};
null === o ? o = [ r ] : o.push(r), l++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === o ? o = [ r ] : o.push(r), l++;
}
c = r === l, f = f || c;
}
if (!f) {
const t = {
params: {}
};
return null === o ? o = [ t ] : o.push(t), l++, r.errors = o, !1;
}
if (l = a, null !== o && (a ? o.length = a : o = null), n !== l) break;
}
}
return r.errors = o, 0 === l;
}
function t(e, {instancePath: s = "", parentData: n, parentDataProperty: a, rootData: o = e} = {}) {
let l = null, i = 0;
const p = i;
let c = !1;
const f = i;
if (i === f) if (Array.isArray(e)) {
const t = e.length;
for (let n = 0; n < t; n++) {
let t = e[n];
const a = i, p = i;
let c = !1;
const f = i;
if (i == i) if ("string" == typeof t) {
if (t.length < 1) {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
} else {
const r = {
params: {
type: "string"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var u = f === i;
if (c = c || u, !c) {
const a = i;
r(t, {
instancePath: s + "/" + n,
parentData: e,
parentDataProperty: n,
rootData: o
}) || (l = null === l ? r.errors : l.concat(r.errors), i = l.length), u = a === i, 
c = c || u;
}
if (c) i = p, null !== l && (p ? l.length = p : l = null); else {
const r = {
params: {}
};
null === l ? l = [ r ] : l.push(r), i++;
}
if (a !== i) break;
}
} else {
const r = {
params: {
type: "array"
}
};
null === l ? l = [ r ] : l.push(r), i++;
}
var h = f === i;
if (c = c || h, !c) {
const t = i;
r(e, {
instancePath: s,
parentData: n,
parentDataProperty: a,
rootData: o
}) || (l = null === l ? r.errors : l.concat(r.errors), i = l.length), h = t === i, 
c = c || h;
}
if (!c) {
const r = {
params: {}
};
return null === l ? l = [ r ] : l.push(r), i++, t.errors = l, !1;
}
return i = p, null !== l && (p ? l.length = p : l = null), t.errors = l, 0 === i;
}
function e(r, {instancePath: s = "", parentData: n, parentDataProperty: a, rootData: o = r} = {}) {
let l = null, i = 0;
if (0 === i) {
if (!r || "object" != typeof r || Array.isArray(r)) return e.errors = [ {
params: {
type: "object"
}
} ], !1;
{
let n;
if (void 0 === r.provides && (n = "provides")) return e.errors = [ {
params: {
missingProperty: n
}
} ], !1;
{
const n = i;
for (const t in r) if ("provides" !== t && "shareScope" !== t) return e.errors = [ {
params: {
additionalProperty: t
}
} ], !1;
if (n === i) {
if (void 0 !== r.provides) {
const e = i;
t(r.provides, {
instancePath: s + "/provides",
parentData: r,
parentDataProperty: "provides",
rootData: o
}) || (l = null === l ? t.errors : l.concat(t.errors), i = l.length);
var p = e === i;
} else p = !0;
if (p) if (void 0 !== r.shareScope) {
let t = r.shareScope;
const s = i;
if (i === s) {
if ("string" != typeof t) return e.errors = [ {
params: {
type: "string"
}
} ], !1;
if (t.length < 1) return e.errors = [ {
params: {}
} ], !1;
}
p = s === i;
} else p = !0;
}
}
}
}
return e.errors = l, 0 === i;
}
module.exports = e, module.exports.default = e;
},
35551: (module, __unused_webpack_exports, __webpack_require__) => {
"use strict";
const {ReplaceSource} = __webpack_require__(37946), {validate} = __webpack_require__(33842), {PROCESS_ASSETS_STAGE_ADDITIONS} = __webpack_require__(62843), schema = {
type: "object",
additionalProperties: !1,
properties: {
search: {
anyOf: [ {
type: "string",
minLength: 1
}, {
instanceof: "RegExp"
} ]
},
replace: {
type: "string"
},
test: {
instanceof: "RegExp"
}
},
required: [ "search", "replace" ]
}, searchReplacements = (str, patterns) => {
const indices = [];
return patterns.forEach((({search, replace}) => {
if ("string" == typeof search) {
const i = str.indexOf(search);
i >= 0 && indices.push({
start: i,
end: i + search.length - 1,
replace
});
} else {
const re = new RegExp(search.source, search.flags);
str.replace(search, ((m, ...args) => {
"object" == typeof args.pop() && args.pop();
const k = args.pop();
return indices.push({
start: k,
end: k + m.length - 1,
replace: m.replace(re, replace)
}), "";
}));
}
})), indices;
};
module.exports = class {
constructor(options) {
validate(schema, options, {
name: "ReplaceCode Plugin",
baseDataPath: "options"
}), this.options = Array.isArray(options) ? options : [ options ];
}
apply(compiler) {
const options = this.options, cache = new WeakMap;
compiler.hooks.compilation.tap("ReplaceCodePlugin", (compilation => {
compilation.hooks.processAssets.tap({
name: "ReplaceCodePlugin",
stage: PROCESS_ASSETS_STAGE_ADDITIONS
}, (() => {
for (const chunk of compilation.chunks) for (const file of chunk.files) {
const filtered = options.filter((({test}) => !test || test.test(file)));
if (!filtered.length) continue;
const patterns = filtered.map((({search, replace}) => ({
search,
replace
})));
compilation.updateAsset(file, (old => {
const cached = cache.get(old);
if (cached && JSON.stringify(cached.patterns) === JSON.stringify(patterns)) return cached.source;
const indices = searchReplacements(old.source(), patterns), source = new ReplaceSource(old);
return indices.forEach((({start, end, replace}) => source.replace(start, end, replace))), 
cache.set(old, {
source,
patterns
}), source;
}));
}
}));
}));
}
};
},
75971: module => {
"use strict";
module.exports = require("../vendor/wasm-ast");
},
4898: module => {
"use strict";
module.exports = require("../vendor/wasm-edit");
},
64812: module => {
"use strict";
module.exports = require("../vendor/wasm-parser");
},
89943: module => {
"use strict";
module.exports = require("../vendor/browserslist");
},
27720: module => {
"use strict";
module.exports = require("./copy-plugin");
},
35965: module => {
"use strict";
module.exports = require;
},
33842: module => {
"use strict";
module.exports = require("./schema-utils");
},
2357: module => {
"use strict";
module.exports = require("./terser-plugin");
},
39491: module => {
"use strict";
module.exports = require("assert");
},
14300: module => {
"use strict";
module.exports = require("buffer");
},
22057: module => {
"use strict";
module.exports = require("constants");
},
6113: module => {
"use strict";
module.exports = require("crypto");
},
82361: module => {
"use strict";
module.exports = require("events");
},
57147: module => {
"use strict";
module.exports = require("fs");
},
13685: module => {
"use strict";
module.exports = require("http");
},
95687: module => {
"use strict";
module.exports = require("https");
},
31405: module => {
"use strict";
module.exports = require("inspector");
},
98188: module => {
"use strict";
module.exports = require("module");
},
22037: module => {
"use strict";
module.exports = require("os");
},
71017: module => {
"use strict";
module.exports = require("path");
},
35125: module => {
"use strict";
module.exports = require("pnpapi");
},
77282: module => {
"use strict";
module.exports = require("process");
},
63477: module => {
"use strict";
module.exports = require("querystring");
},
12781: module => {
"use strict";
module.exports = require("stream");
},
57310: module => {
"use strict";
module.exports = require("url");
},
73837: module => {
"use strict";
module.exports = require("util");
},
26144: module => {
"use strict";
module.exports = require("vm");
},
59796: module => {
"use strict";
module.exports = require("zlib");
},
44813: (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
"use strict";
__webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
init: () => init,
parse: () => parse
});
const A = 1 === new Uint8Array(new Uint16Array([ 1 ]).buffer)[0];
function parse(E, I = "@") {
if (!B) return init.then((() => parse(E)));
const g = E.length + 1, D = (B.__heap_base.value || B.__heap_base) + 4 * g - B.memory.buffer.byteLength;
D > 0 && B.memory.grow(Math.ceil(D / 65536));
const w = B.sa(g - 1);
if ((A ? C : Q)(E, new Uint16Array(B.memory.buffer, w, g)), !B.parse()) throw Object.assign(new Error(`Parse error ${I}:${E.slice(0, B.e()).split("\n").length}:${B.e() - E.lastIndexOf("\n", B.e() - 1)}`), {
idx: B.e()
});
const L = [], k = [];
for (;B.ri(); ) {
const A = B.is(), Q = B.ie(), C = B.ai(), I = B.id(), g = B.ss(), D = B.se();
let w;
B.ip() && (w = J(E.slice(-1 === I ? A - 1 : A, -1 === I ? Q + 1 : Q))), L.push({
n: w,
s: A,
e: Q,
ss: g,
se: D,
d: I,
a: C
});
}
for (;B.re(); ) {
const A = E.slice(B.es(), B.ee()), Q = A[0];
k.push('"' === Q || "'" === Q ? J(A) : A);
}
function J(A) {
try {
return (0, eval)(A);
} catch (A) {}
}
return [ L, k, !!B.f() ];
}
function Q(A, Q) {
const C = A.length;
let B = 0;
for (;B < C; ) {
const C = A.charCodeAt(B);
Q[B++] = (255 & C) << 8 | C >>> 8;
}
}
function C(A, Q) {
const C = A.length;
let B = 0;
for (;B < C; ) Q[B] = A.charCodeAt(B++);
}
let B;
const init = WebAssembly.compile((E = "AGFzbQEAAAABXA1gAX8Bf2AEf39/fwBgAn9/AGAAAX9gBn9/f39/fwF/YAAAYAF/AGAEf39/fwF/YAN/f38Bf2AHf39/f39/fwF/YAV/f39/fwF/YAJ/fwF/YAh/f39/f39/fwF/AzEwAAECAwMDAwMDAwMDAwMDAwAABAUFBQYFBgAAAAAFBQAEBwgJCgsMAAIAAAALAwkMBAUBcAEBAQUDAQABBg8CfwFB8PAAC38AQfDwAAsHZBEGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwCcmkADQJyZQAOAWYADwVwYXJzZQAQC19faGVhcF9iYXNlAwEK8jkwaAEBf0EAIAA2ArgIQQAoApAIIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgK8CEEAIAA2AsAIQQBBADYClAhBAEEANgKkCEEAQQA2ApwIQQBBADYCmAhBAEEANgKsCEEAQQA2AqAIIAELsgEBAn9BACgCpAgiBEEcakGUCCAEG0EAKALACCIFNgIAQQAgBTYCpAhBACAENgKoCEEAIAVBIGo2AsAIIAUgADYCCAJAAkBBACgCiAggA0cNACAFIAI2AgwMAQsCQEEAKAKECCADRw0AIAUgAkECajYCDAwBCyAFQQAoApAINgIMCyAFIAE2AgAgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIcIAVBACgChAggA0Y6ABgLSAEBf0EAKAKsCCICQQhqQZgIIAIbQQAoAsAIIgI2AgBBACACNgKsCEEAIAJBDGo2AsAIIAJBADYCCCACIAE2AgQgAiAANgIACwgAQQAoAsQICxUAQQAoApwIKAIAQQAoApAIa0EBdQsVAEEAKAKcCCgCBEEAKAKQCGtBAXULFQBBACgCnAgoAghBACgCkAhrQQF1CxUAQQAoApwIKAIMQQAoApAIa0EBdQseAQF/QQAoApwIKAIQIgBBACgCkAhrQQF1QX8gABsLOwEBfwJAQQAoApwIKAIUIgBBACgChAhHDQBBfw8LAkAgAEEAKAKICEcNAEF+DwsgAEEAKAKQCGtBAXULCwBBACgCnAgtABgLFQBBACgCoAgoAgBBACgCkAhrQQF1CxUAQQAoAqAIKAIEQQAoApAIa0EBdQslAQF/QQBBACgCnAgiAEEcakGUCCAAGygCACIANgKcCCAAQQBHCyUBAX9BAEEAKAKgCCIAQQhqQZgIIAAbKAIAIgA2AqAIIABBAEcLCABBAC0AyAgL9gsBBH8jAEGA8ABrIgEkAEEAQQE6AMgIQQBB//8DOwHOCEEAQQAoAowINgLQCEEAQQAoApAIQX5qIgI2AuQIQQAgAkEAKAK4CEEBdGoiAzYC6AhBAEEAOwHKCEEAQQA7AcwIQQBBADoA1AhBAEEANgLECEEAQQA6ALQIQQAgAUGA0ABqNgLYCEEAIAFBgBBqNgLcCEEAQQA6AOAIAkACQAJAAkADQEEAIAJBAmoiBDYC5AggAiADTw0BAkAgBC8BACIDQXdqQQVJDQACQAJAAkACQAJAIANBm39qDgUBCAgIAgALIANBIEYNBCADQS9GDQMgA0E7Rg0CDAcLQQAvAcwIDQEgBBARRQ0BIAJBBGpB+ABB8ABB7wBB8gBB9AAQEkUNARATQQAtAMgIDQFBAEEAKALkCCICNgLQCAwHCyAEEBFFDQAgAkEEakHtAEHwAEHvAEHyAEH0ABASRQ0AEBQLQQBBACgC5Ag2AtAIDAELAkAgAi8BBCIEQSpGDQAgBEEvRw0EEBUMAQtBARAWC0EAKALoCCEDQQAoAuQIIQIMAAsLQQAhAyAEIQJBAC0AtAgNAgwBC0EAIAI2AuQIQQBBADoAyAgLA0BBACACQQJqIgQ2AuQIAkACQAJAAkACQAJAIAJBACgC6AhPDQAgBC8BACIDQXdqQQVJDQUCQAJAAkACQAJAAkACQAJAAkACQCADQWBqDgoPDggODg4OBwECAAsCQAJAAkACQCADQaB/ag4KCBERAxEBERERAgALIANBhX9qDgMFEAYLC0EALwHMCA0PIAQQEUUNDyACQQRqQfgAQfAAQe8AQfIAQfQAEBJFDQ8QEwwPCyAEEBFFDQ4gAkEEakHtAEHwAEHvAEHyAEH0ABASRQ0OEBQMDgsgBBARRQ0NIAIvAQpB8wBHDQ0gAi8BCEHzAEcNDSACLwEGQeEARw0NIAIvAQRB7ABHDQ0gAi8BDCIEQXdqIgJBF0sNC0EBIAJ0QZ+AgARxRQ0LDAwLQQBBAC8BzAgiAkEBajsBzAhBACgC3AggAkECdGpBACgC0Ag2AgAMDAtBAC8BzAgiAkUNCEEAIAJBf2oiAzsBzAhBACgCsAgiAkUNCyACKAIUQQAoAtwIIANB//8DcUECdGooAgBHDQsCQCACKAIEDQAgAiAENgIECyACIAQ2AgxBAEEANgKwCAwLCwJAQQAoAtAIIgQvAQBBKUcNAEEAKAKkCCICRQ0AIAIoAgQgBEcNAEEAQQAoAqgIIgI2AqQIAkAgAkUNACACQQA2AhwMAQtBAEEANgKUCAsgAUEALwHMCCICakEALQDgCDoAAEEAIAJBAWo7AcwIQQAoAtwIIAJBAnRqIAQ2AgBBAEEAOgDgCAwKC0EALwHMCCICRQ0GQQAgAkF/aiIDOwHMCCACQQAvAc4IIgRHDQFBAEEALwHKCEF/aiICOwHKCEEAQQAoAtgIIAJB//8DcUEBdGovAQA7Ac4ICxAXDAgLIARB//8DRg0HIANB//8DcSAESQ0EDAcLQScQGAwGC0EiEBgMBQsgA0EvRw0EAkACQCACLwEEIgJBKkYNACACQS9HDQEQFQwHC0EBEBYMBgsCQAJAAkACQEEAKALQCCIELwEAIgIQGUUNAAJAAkACQCACQVVqDgQBBQIABQsgBEF+ai8BAEFQakH//wNxQQpJDQMMBAsgBEF+ai8BAEErRg0CDAMLIARBfmovAQBBLUYNAQwCCwJAIAJB/QBGDQAgAkEpRw0BQQAoAtwIQQAvAcwIQQJ0aigCABAaRQ0BDAILQQAoAtwIQQAvAcwIIgNBAnRqKAIAEBsNASABIANqLQAADQELIAQQHA0AIAJFDQBBASEEIAJBL0ZBAC0A1AhBAEdxRQ0BCxAdQQAhBAtBACAEOgDUCAwEC0EALwHOCEH//wNGQQAvAcwIRXFBAC0AtAhFcSEDDAYLEB5BACEDDAULIARBoAFHDQELQQBBAToA4AgLQQBBACgC5Ag2AtAIC0EAKALkCCECDAALCyABQYDwAGokACADCx0AAkBBACgCkAggAEcNAEEBDwsgAEF+ai8BABAfCz8BAX9BACEGAkAgAC8BCCAFRw0AIAAvAQYgBEcNACAALwEEIANHDQAgAC8BAiACRw0AIAAvAQAgAUYhBgsgBgvUBgEEf0EAQQAoAuQIIgBBDGoiATYC5AhBARAnIQICQAJAAkACQAJAQQAoAuQIIgMgAUcNACACECtFDQELAkACQAJAAkACQCACQZ9/ag4MBgEDCAEHAQEBAQEEAAsCQAJAIAJBKkYNACACQfYARg0FIAJB+wBHDQJBACADQQJqNgLkCEEBECchA0EAKALkCCEBA0ACQAJAIANB//8DcSICQSJGDQAgAkEnRg0AIAIQKhpBACgC5AghAgwBCyACEBhBAEEAKALkCEECaiICNgLkCAtBARAnGgJAIAEgAhAsIgNBLEcNAEEAQQAoAuQIQQJqNgLkCEEBECchAwtBACgC5AghAgJAIANB/QBGDQAgAiABRg0FIAIhASACQQAoAugITQ0BDAULC0EAIAJBAmo2AuQIDAELQQAgA0ECajYC5AhBARAnGkEAKALkCCICIAIQLBoLQQEQJyECC0EAKALkCCEDAkAgAkHmAEcNACADLwEGQe0ARw0AIAMvAQRB7wBHDQAgAy8BAkHyAEcNAEEAIANBCGo2AuQIIABBARAnECgPC0EAIANBfmo2AuQIDAMLEB4PCwJAIAMvAQhB8wBHDQAgAy8BBkHzAEcNACADLwEEQeEARw0AIAMvAQJB7ABHDQAgAy8BChAfRQ0AQQAgA0EKajYC5AhBARAnIQJBACgC5AghAyACECoaIANBACgC5AgQAkEAQQAoAuQIQX5qNgLkCA8LQQAgA0EEaiIDNgLkCAtBACADQQRqIgI2AuQIQQBBADoAyAgDQEEAIAJBAmo2AuQIQQEQJyEDQQAoAuQIIQICQCADECpBIHJB+wBHDQBBAEEAKALkCEF+ajYC5AgPC0EAKALkCCIDIAJGDQEgAiADEAICQEEBECciAkEsRg0AAkAgAkE9Rw0AQQBBACgC5AhBfmo2AuQIDwtBAEEAKALkCEF+ajYC5AgPC0EAKALkCCECDAALCw8LQQAgA0EKajYC5AhBARAnGkEAKALkCCEDC0EAIANBEGo2AuQIAkBBARAnIgJBKkcNAEEAQQAoAuQIQQJqNgLkCEEBECchAgtBACgC5AghAyACECoaIANBACgC5AgQAkEAQQAoAuQIQX5qNgLkCA8LIAMgA0EOahACC64GAQR/QQBBACgC5AgiAEEMaiIBNgLkCAJAAkACQAJAAkACQAJAAkACQAJAQQEQJyICQVlqDggCCAECAQEBBwALIAJBIkYNASACQfsARg0CC0EAKALkCCABRg0HC0EALwHMCA0BQQAoAuQIIQJBACgC6AghAwNAIAIgA08NBAJAAkAgAi8BACIBQSdGDQAgAUEiRw0BCyAAIAEQKA8LQQAgAkECaiICNgLkCAwACwtBACgC5AghAkEALwHMCA0BAkADQAJAAkACQCACQQAoAugITw0AQQEQJyICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKALkCEECajYC5AgLQQEQJxpBACgC5AgiAi8BBkHtAEcNBiACLwEEQe8ARw0GIAIvAQJB8gBHDQYgAi8BAEHmAEcNBkEAIAJBCGo2AuQIQQEQJyICQSJGDQMgAkEnRg0DDAYLIAIQGAtBAEEAKALkCEECaiICNgLkCAwACwsgACACECgMBQtBAEEAKALkCEF+ajYC5AgPC0EAIAJBfmo2AuQIDwsQHg8LQQBBACgC5AhBAmo2AuQIQQEQJ0HtAEcNAUEAKALkCCICLwEGQeEARw0BIAIvAQRB9ABHDQEgAi8BAkHlAEcNAUEAKALQCC8BAEEuRg0BIAAgACACQQhqQQAoAogIEAEPC0EAKALcCEEALwHMCCICQQJ0aiAANgIAQQAgAkEBajsBzAhBACgC0AgvAQBBLkYNACAAQQAoAuQIQQJqQQAgABABQQBBACgCpAg2ArAIQQBBACgC5AhBAmo2AuQIAkBBARAnIgJBIkYNACACQSdGDQBBAEEAKALkCEF+ajYC5AgPCyACEBhBAEEAKALkCEECajYC5AgCQAJAAkBBARAnQVdqDgQBAgIAAgtBACgCpAhBACgC5AgiAjYCBEEAIAJBAmo2AuQIQQEQJxpBACgCpAgiAkEBOgAYIAJBACgC5AgiATYCEEEAIAFBfmo2AuQIDwtBACgCpAgiAkEBOgAYIAJBACgC5AgiATYCDCACIAE2AgRBAEEALwHMCEF/ajsBzAgPC0EAQQAoAuQIQX5qNgLkCA8LC0cBA39BACgC5AhBAmohAEEAKALoCCEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AuQIC5gBAQN/QQBBACgC5AgiAUECajYC5AggAUEGaiEBQQAoAugIIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AuQIDAELIAFBfmohAQtBACABNgLkCA8LIAFBAmohAQwACwu/AQEEf0EAKALkCCEAQQAoAugIIQECQAJAA0AgACICQQJqIQAgAiABTw0BAkACQCAALwEAIgNBpH9qDgUBAgICBAALIANBJEcNASACLwEEQfsARw0BQQBBAC8ByggiAEEBajsByghBACgC2AggAEEBdGpBAC8Bzgg7AQBBACACQQRqNgLkCEEAQQAvAcwIQQFqIgA7Ac4IQQAgADsBzAgPCyACQQRqIQAMAAsLQQAgADYC5AgQHg8LQQAgADYC5AgLiAEBBH9BACgC5AghAUEAKALoCCECAkACQANAIAEiA0ECaiEBIAMgAk8NASABLwEAIgQgAEYNAgJAIARB3ABGDQAgBEF2ag4EAgEBAgELIANBBGohASADLwEEQQ1HDQAgA0EGaiABIAMvAQZBCkYbIQEMAAsLQQAgATYC5AgQHg8LQQAgATYC5AgLbAEBfwJAAkAgAEFfaiIBQQVLDQBBASABdEExcQ0BCyAAQUZqQf//A3FBBkkNACAAQSlHIABBWGpB//8DcUEHSXENAAJAIABBpX9qDgQBAAABAAsgAEH9AEcgAEGFf2pB//8DcUEESXEPC0EBCz0BAX9BASEBAkAgAEH3AEHoAEHpAEHsAEHlABAgDQAgAEHmAEHvAEHyABAhDQAgAEHpAEHmABAiIQELIAELmwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQeYAQekAQe4AQeEAQewAQewAECMPCyAAQX5qLwEAQT1GDwsgAEF+akHjAEHhAEH0AEHjABAkDwsgAEF+akHlAEHsAEHzABAhDwtBACEBCyABC9IDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCAgICAgICAMECAgFCAYICAcICwJAAkAgAEF+ai8BAEGXf2oOBAAJCQEJCyAAQXxqQfYAQe8AECIPCyAAQXxqQfkAQekAQeUAECEPCwJAAkAgAEF+ai8BAEGNf2oOAgABCAsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCCAAQXpqQeUAECUPCyAAQXpqQeMAECUPCyAAQXxqQeQAQeUAQewAQeUAECQPCyAAQX5qLwEAQe8ARw0FIABBfGovAQBB5QBHDQUCQCAAQXpqLwEAIgJB8ABGDQAgAkHjAEcNBiAAQXhqQekAQe4AQfMAQfQAQeEAQe4AECMPCyAAQXhqQfQAQfkAECIPC0EBIQEgAEF+aiIAQekAECUNBCAAQfIAQeUAQfQAQfUAQfIAECAPCyAAQX5qQeQAECUPCyAAQX5qQeQAQeUAQeIAQfUAQecAQecAQeUAECYPCyAAQX5qQeEAQfcAQeEAQekAECQPCwJAIABBfmovAQAiAkHvAEYNACACQeUARw0BIABBfGpB7gAQJQ8LIABBfGpB9ABB6ABB8gAQISEBCyABC3ABAn8CQAJAA0BBAEEAKALkCCIAQQJqIgE2AuQIIABBACgC6AhPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLRoMAQtBACAAQQRqNgLkCAwACwsQHgsLNQEBf0EAQQE6ALQIQQAoAuQIIQBBAEEAKALoCEECajYC5AhBACAAQQAoApAIa0EBdTYCxAgLNAEBf0EBIQECQCAAQXdqQf//A3FBBUkNACAAQYABckGgAUYNACAAQS5HIAAQK3EhAQsgAQtJAQN/QQAhBgJAIABBeGoiB0EAKAKQCCIISQ0AIAcgASACIAMgBCAFEBJFDQACQCAHIAhHDQBBAQ8LIABBdmovAQAQHyEGCyAGC1kBA39BACEEAkAgAEF8aiIFQQAoApAIIgZJDQAgAC8BACADRw0AIABBfmovAQAgAkcNACAFLwEAIAFHDQACQCAFIAZHDQBBAQ8LIABBemovAQAQHyEECyAEC0wBA39BACEDAkAgAEF+aiIEQQAoApAIIgVJDQAgAC8BACACRw0AIAQvAQAgAUcNAAJAIAQgBUcNAEEBDwsgAEF8ai8BABAfIQMLIAMLSwEDf0EAIQcCQCAAQXZqIghBACgCkAgiCUkNACAIIAEgAiADIAQgBSAGEC5FDQACQCAIIAlHDQBBAQ8LIABBdGovAQAQHyEHCyAHC2YBA39BACEFAkAgAEF6aiIGQQAoApAIIgdJDQAgAC8BACAERw0AIABBfmovAQAgA0cNACAAQXxqLwEAIAJHDQAgBi8BACABRw0AAkAgBiAHRw0AQQEPCyAAQXhqLwEAEB8hBQsgBQs9AQJ/QQAhAgJAQQAoApAIIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQHyECCyACC00BA39BACEIAkAgAEF0aiIJQQAoApAIIgpJDQAgCSABIAIgAyAEIAUgBiAHEC9FDQACQCAJIApHDQBBAQ8LIABBcmovAQAQHyEICyAIC5wBAQN/QQAoAuQIIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAVDAILIAAQFgwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQKUUNAwwBCyACQaABRw0CC0EAQQAoAuQIIgNBAmoiATYC5AggA0EAKALoCEkNAAsLIAILywMBAX8CQCABQSJGDQAgAUEnRg0AEB4PC0EAKALkCCECIAEQGCAAIAJBAmpBACgC5AhBACgChAgQAUEAQQAoAuQIQQJqNgLkCEEAECchAEEAKALkCCEBAkACQCAAQeEARw0AIAFBAmpB8wBB8wBB5QBB8gBB9AAQEg0BC0EAIAFBfmo2AuQIDwtBACABQQxqNgLkCAJAQQEQJ0H7AEYNAEEAIAE2AuQIDwtBACgC5AgiAiEAA0BBACAAQQJqNgLkCAJAAkACQEEBECciAEEiRg0AIABBJ0cNAUEnEBhBAEEAKALkCEECajYC5AhBARAnIQAMAgtBIhAYQQBBACgC5AhBAmo2AuQIQQEQJyEADAELIAAQKiEACwJAIABBOkYNAEEAIAE2AuQIDwtBAEEAKALkCEECajYC5AgCQEEBECciAEEiRg0AIABBJ0YNAEEAIAE2AuQIDwsgABAYQQBBACgC5AhBAmo2AuQIAkACQEEBECciAEEsRg0AIABB/QBGDQFBACABNgLkCA8LQQBBACgC5AhBAmo2AuQIQQEQJ0H9AEYNAEEAKALkCCEADAELC0EAKAKkCCIBIAI2AhAgAUEAKALkCEECajYCDAswAQF/AkACQCAAQXdqIgFBF0sNAEEBIAF0QY2AgARxDQELIABBoAFGDQBBAA8LQQELbQECfwJAAkADQAJAIABB//8DcSIBQXdqIgJBF0sNAEEBIAJ0QZ+AgARxDQILIAFBoAFGDQEgACECIAEQKw0CQQAhAkEAQQAoAuQIIgBBAmo2AuQIIAAvAQIiAA0ADAILCyAAIQILIAJB//8DcQtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQuLAQECfwJAQQAoAuQIIgIvAQAiA0HhAEcNAEEAIAJBBGo2AuQIQQEQJyECQQAoAuQIIQACQAJAIAJBIkYNACACQSdGDQAgAhAqGkEAKALkCCEBDAELIAIQGEEAQQAoAuQIQQJqIgE2AuQIC0EBECchA0EAKALkCCECCwJAIAIgAEYNACAAIAEQAgsgAwtyAQR/QQAoAuQIIQBBACgC6AghAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AuQIEB5BAA8LQQAgAjYC5AhB3QALSQEBf0EAIQcCQCAALwEKIAZHDQAgAC8BCCAFRw0AIAAvAQYgBEcNACAALwEEIANHDQAgAC8BAiACRw0AIAAvAQAgAUYhBwsgBwtTAQF/QQAhCAJAIAAvAQwgB0cNACAALwEKIAZHDQAgAC8BCCAFRw0AIAAvAQYgBEcNACAALwEEIANHDQAgAC8BAiACRw0AIAAvAQAgAUYhCAsgCAsLHwIAQYAICwIAAABBhAgLEAEAAAACAAAAAAQAAHA4AAA=", 
"undefined" != typeof Buffer ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A => A.charCodeAt(0))))).then(WebAssembly.instantiate).then((({exports: A}) => {
B = A;
}));
var E;
},
83196: module => {
"use strict";
module.exports = {
i8: "5.1.1"
};
},
29389: module => {
"use strict";
module.exports = {
version: "4.3.0"
};
},
53765: module => {
"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');
},
37589: module => {
"use strict";
module.exports = {
i8: "5.74.0"
};
},
46312: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"Amd":{"description":"Set the value of `require.amd` and `define.amd`. Or disable AMD support.","anyOf":[{"description":"You can pass `false` to disable AMD support.","enum":[false]},{"description":"You can pass an object to set the value of `require.amd` and `define.amd`.","type":"object"}]},"AssetFilterItemTypes":{"description":"Filtering value, regexp or function.","cli":{"helper":true},"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((name: string, asset: import(\'../lib/stats/DefaultStatsFactoryPlugin\').StatsAsset) => boolean)"}]},"AssetFilterTypes":{"description":"Filtering modules.","cli":{"helper":true},"anyOf":[{"type":"array","items":{"description":"Rule to filter.","cli":{"helper":true},"oneOf":[{"$ref":"#/definitions/AssetFilterItemTypes"}]}},{"$ref":"#/definitions/AssetFilterItemTypes"}]},"AssetGeneratorDataUrl":{"description":"The options for data url generator.","anyOf":[{"$ref":"#/definitions/AssetGeneratorDataUrlOptions"},{"$ref":"#/definitions/AssetGeneratorDataUrlFunction"}]},"AssetGeneratorDataUrlFunction":{"description":"Function that executes for module and should return an DataUrl string. It can have a string as \'ident\' property which contributes to the module hash.","instanceof":"Function","tsType":"((source: string | Buffer, context: { filename: string, module: import(\'../lib/Module\') }) => string)"},"AssetGeneratorDataUrlOptions":{"description":"Options object for data url generation.","type":"object","additionalProperties":false,"properties":{"encoding":{"description":"Asset encoding (defaults to base64).","enum":[false,"base64"]},"mimetype":{"description":"Asset mimetype (getting from file extension by default).","type":"string"}}},"AssetGeneratorOptions":{"description":"Generator options for asset modules.","type":"object","implements":["#/definitions/AssetInlineGeneratorOptions","#/definitions/AssetResourceGeneratorOptions"],"additionalProperties":false,"properties":{"dataUrl":{"$ref":"#/definitions/AssetGeneratorDataUrl"},"emit":{"description":"Emit an output asset from this asset module. This can be set to \'false\' to omit emitting e. g. for SSR.","type":"boolean"},"filename":{"$ref":"#/definitions/FilenameTemplate"},"outputPath":{"$ref":"#/definitions/AssetModuleOutputPath"},"publicPath":{"$ref":"#/definitions/RawPublicPath"}}},"AssetInlineGeneratorOptions":{"description":"Generator options for asset/inline modules.","type":"object","additionalProperties":false,"properties":{"dataUrl":{"$ref":"#/definitions/AssetGeneratorDataUrl"}}},"AssetModuleFilename":{"description":"The filename of asset modules as relative path inside the \'output.path\' directory.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((pathData: import(\\"../lib/Compilation\\").PathData, assetInfo?: import(\\"../lib/Compilation\\").AssetInfo) => string)"}]},"AssetModuleOutputPath":{"description":"Emit the asset in the specified folder relative to \'output.path\'. This should only be needed when custom \'publicPath\' is specified to match the folder structure there.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((pathData: import(\\"../lib/Compilation\\").PathData, assetInfo?: import(\\"../lib/Compilation\\").AssetInfo) => string)"}]},"AssetParserDataUrlFunction":{"description":"Function that executes for module and should return whenever asset should be inlined as DataUrl.","instanceof":"Function","tsType":"((source: string | Buffer, context: { filename: string, module: import(\'../lib/Module\') }) => boolean)"},"AssetParserDataUrlOptions":{"description":"Options object for DataUrl condition.","type":"object","additionalProperties":false,"properties":{"maxSize":{"description":"Maximum size of asset that should be inline as modules. Default: 8kb.","type":"number"}}},"AssetParserOptions":{"description":"Parser options for asset modules.","type":"object","additionalProperties":false,"properties":{"dataUrlCondition":{"description":"The condition for inlining the asset as DataUrl.","anyOf":[{"$ref":"#/definitions/AssetParserDataUrlOptions"},{"$ref":"#/definitions/AssetParserDataUrlFunction"}]}}},"AssetResourceGeneratorOptions":{"description":"Generator options for asset/resource modules.","type":"object","additionalProperties":false,"properties":{"emit":{"description":"Emit an output asset from this asset module. This can be set to \'false\' to omit emitting e. g. for SSR.","type":"boolean"},"filename":{"$ref":"#/definitions/FilenameTemplate"},"outputPath":{"$ref":"#/definitions/AssetModuleOutputPath"},"publicPath":{"$ref":"#/definitions/RawPublicPath"}}},"AuxiliaryComment":{"description":"Add a comment in the UMD wrapper.","anyOf":[{"description":"Append the same comment above each import style.","type":"string"},{"$ref":"#/definitions/LibraryCustomUmdCommentObject"}]},"Bail":{"description":"Report the first error as a hard error instead of tolerating it.","type":"boolean"},"CacheOptions":{"description":"Cache generated modules and chunks to improve performance for multiple incremental builds.","anyOf":[{"description":"Enable in memory caching.","enum":[true]},{"$ref":"#/definitions/CacheOptionsNormalized"}]},"CacheOptionsNormalized":{"description":"Cache generated modules and chunks to improve performance for multiple incremental builds.","anyOf":[{"description":"Disable caching.","enum":[false]},{"$ref":"#/definitions/MemoryCacheOptions"},{"$ref":"#/definitions/FileCacheOptions"}]},"Charset":{"description":"Add charset attribute for script tag.","type":"boolean"},"ChunkFilename":{"description":"Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by \'/\'! The specified path is joined with the value of the \'output.path\' option to determine the location on disk.","oneOf":[{"$ref":"#/definitions/FilenameTemplate"}]},"ChunkFormat":{"description":"The format of chunks (formats included by default are \'array-push\' (web/WebWorker), \'commonjs\' (node.js), \'module\' (ESM), but others might be added by plugins).","anyOf":[{"enum":["array-push","commonjs","module",false]},{"type":"string"}]},"ChunkLoadTimeout":{"description":"Number of milliseconds before chunk request expires.","type":"number"},"ChunkLoading":{"description":"The method of loading chunks (methods included by default are \'jsonp\' (web), \'import\' (ESM), \'importScripts\' (WebWorker), \'require\' (sync node.js), \'async-node\' (async node.js), but others might be added by plugins).","anyOf":[{"enum":[false]},{"$ref":"#/definitions/ChunkLoadingType"}]},"ChunkLoadingGlobal":{"description":"The global variable used by webpack for loading of chunks.","type":"string"},"ChunkLoadingType":{"description":"The method of loading chunks (methods included by default are \'jsonp\' (web), \'import\' (ESM), \'importScripts\' (WebWorker), \'require\' (sync node.js), \'async-node\' (async node.js), but others might be added by plugins).","anyOf":[{"enum":["jsonp","import-scripts","require","async-node","import"]},{"type":"string"}]},"Clean":{"description":"Clean the output directory before emit.","anyOf":[{"type":"boolean"},{"$ref":"#/definitions/CleanOptions"}]},"CleanOptions":{"description":"Advanced options for cleaning assets.","type":"object","additionalProperties":false,"properties":{"dry":{"description":"Log the assets that should be removed instead of deleting them.","type":"boolean"},"keep":{"description":"Keep these assets.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((filename: string) => boolean)"}]}}},"CompareBeforeEmit":{"description":"Check if to be emitted file already exists and have the same content before writing to output filesystem.","type":"boolean"},"Context":{"description":"The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.","type":"string","absolutePath":true},"CrossOriginLoading":{"description":"This option enables cross-origin loading of chunks.","enum":[false,"anonymous","use-credentials"]},"CssChunkFilename":{"description":"Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by \'/\'! The specified path is joined with the value of the \'output.path\' option to determine the location on disk.","oneOf":[{"$ref":"#/definitions/FilenameTemplate"}]},"CssExperimentOptions":{"description":"Options for css handling.","type":"object","additionalProperties":false,"properties":{"exportsOnly":{"description":"Avoid generating and loading a stylesheet and only embed exports from css into output javascript files.","type":"boolean"}}},"CssFilename":{"description":"Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by \'/\'! The specified path is joined with the value of the \'output.path\' option to determine the location on disk.","oneOf":[{"$ref":"#/definitions/FilenameTemplate"}]},"CssGeneratorOptions":{"description":"Generator options for css modules.","type":"object","additionalProperties":false,"properties":{}},"CssParserOptions":{"description":"Parser options for css modules.","type":"object","additionalProperties":false,"properties":{}},"Dependencies":{"description":"References to other configurations to depend on.","type":"array","items":{"description":"References to another configuration to depend on.","type":"string"}},"DevServer":{"description":"Options for the webpack-dev-server.","type":"object"},"DevTool":{"description":"A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).","anyOf":[{"enum":[false,"eval"]},{"type":"string","pattern":"^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$"}]},"DevtoolFallbackModuleFilenameTemplate":{"description":"Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"DevtoolModuleFilenameTemplate":{"description":"Filename template string of function for the sources array in a generated SourceMap.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"DevtoolNamespace":{"description":"Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It\'s useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.","type":"string"},"EmptyGeneratorOptions":{"description":"No generator options are supported for this module type.","type":"object","additionalProperties":false},"EmptyParserOptions":{"description":"No parser options are supported for this module type.","type":"object","additionalProperties":false},"EnabledChunkLoadingTypes":{"description":"List of chunk loading types enabled for use by entry points.","type":"array","items":{"$ref":"#/definitions/ChunkLoadingType"}},"EnabledLibraryTypes":{"description":"List of library types enabled for use by entry points.","type":"array","items":{"$ref":"#/definitions/LibraryType"}},"EnabledWasmLoadingTypes":{"description":"List of wasm loading types enabled for use by entry points.","type":"array","items":{"$ref":"#/definitions/WasmLoadingType"}},"Entry":{"description":"The entry point(s) of the compilation.","anyOf":[{"$ref":"#/definitions/EntryDynamic"},{"$ref":"#/definitions/EntryStatic"}]},"EntryDescription":{"description":"An object with entry point description.","type":"object","additionalProperties":false,"properties":{"asyncChunks":{"description":"Enable/disable creating async chunks that are loaded on demand.","type":"boolean"},"baseUri":{"description":"Base uri for this entry.","type":"string"},"chunkLoading":{"$ref":"#/definitions/ChunkLoading"},"dependOn":{"description":"The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.","anyOf":[{"description":"The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.","type":"array","items":{"description":"An entrypoint that the current entrypoint depend on. It must be loaded when this entrypoint is loaded.","type":"string","minLength":1},"minItems":1,"uniqueItems":true},{"description":"An entrypoint that the current entrypoint depend on. It must be loaded when this entrypoint is loaded.","type":"string","minLength":1}]},"filename":{"$ref":"#/definitions/EntryFilename"},"import":{"$ref":"#/definitions/EntryItem"},"layer":{"$ref":"#/definitions/Layer"},"library":{"$ref":"#/definitions/LibraryOptions"},"publicPath":{"$ref":"#/definitions/PublicPath"},"runtime":{"$ref":"#/definitions/EntryRuntime"},"wasmLoading":{"$ref":"#/definitions/WasmLoading"}},"required":["import"]},"EntryDescriptionNormalized":{"description":"An object with entry point description.","type":"object","additionalProperties":false,"properties":{"asyncChunks":{"description":"Enable/disable creating async chunks that are loaded on demand.","type":"boolean"},"baseUri":{"description":"Base uri for this entry.","type":"string"},"chunkLoading":{"$ref":"#/definitions/ChunkLoading"},"dependOn":{"description":"The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.","type":"array","items":{"description":"An entrypoint that the current entrypoint depend on. It must be loaded when this entrypoint is loaded.","type":"string","minLength":1},"minItems":1,"uniqueItems":true},"filename":{"$ref":"#/definitions/Filename"},"import":{"description":"Module(s) that are loaded upon startup. The last one is exported.","type":"array","items":{"description":"Module that is loaded upon startup. Only the last one is exported.","type":"string","minLength":1},"minItems":1,"uniqueItems":true},"layer":{"$ref":"#/definitions/Layer"},"library":{"$ref":"#/definitions/LibraryOptions"},"publicPath":{"$ref":"#/definitions/PublicPath"},"runtime":{"$ref":"#/definitions/EntryRuntime"},"wasmLoading":{"$ref":"#/definitions/WasmLoading"}}},"EntryDynamic":{"description":"A Function returning an entry object, an entry string, an entry array or a promise to these things.","instanceof":"Function","tsType":"(() => EntryStatic | Promise<EntryStatic>)"},"EntryDynamicNormalized":{"description":"A Function returning a Promise resolving to a normalized entry.","instanceof":"Function","tsType":"(() => Promise<EntryStaticNormalized>)"},"EntryFilename":{"description":"Specifies the filename of the output file on disk. You must **not** specify an absolute path here, but the path may contain folders separated by \'/\'! The specified path is joined with the value of the \'output.path\' option to determine the location on disk.","oneOf":[{"$ref":"#/definitions/FilenameTemplate"}]},"EntryItem":{"description":"Module(s) that are loaded upon startup.","anyOf":[{"description":"All modules are loaded upon startup. The last one is exported.","type":"array","items":{"description":"A module that is loaded upon startup. Only the last one is exported.","type":"string","minLength":1},"minItems":1,"uniqueItems":true},{"description":"The string is resolved to a module which is loaded upon startup.","type":"string","minLength":1}]},"EntryNormalized":{"description":"The entry point(s) of the compilation.","anyOf":[{"$ref":"#/definitions/EntryDynamicNormalized"},{"$ref":"#/definitions/EntryStaticNormalized"}]},"EntryObject":{"description":"Multiple entry bundles are created. The key is the entry name. The value can be a string, an array or an entry description object.","type":"object","additionalProperties":{"description":"An entry point with name.","anyOf":[{"$ref":"#/definitions/EntryItem"},{"$ref":"#/definitions/EntryDescription"}]}},"EntryRuntime":{"description":"The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.","anyOf":[{"enum":[false]},{"type":"string","minLength":1}]},"EntryStatic":{"description":"A static entry description.","anyOf":[{"$ref":"#/definitions/EntryObject"},{"$ref":"#/definitions/EntryUnnamed"}]},"EntryStaticNormalized":{"description":"Multiple entry bundles are created. The key is the entry name. The value is an entry description object.","type":"object","additionalProperties":{"description":"An object with entry point description.","oneOf":[{"$ref":"#/definitions/EntryDescriptionNormalized"}]}},"EntryUnnamed":{"description":"An entry point without name.","oneOf":[{"$ref":"#/definitions/EntryItem"}]},"Environment":{"description":"The abilities of the environment where the webpack generated code should run.","type":"object","additionalProperties":false,"properties":{"arrowFunction":{"description":"The environment supports arrow functions (\'() => { ... }\').","type":"boolean"},"bigIntLiteral":{"description":"The environment supports BigInt as literal (123n).","type":"boolean"},"const":{"description":"The environment supports const and let for variable declarations.","type":"boolean"},"destructuring":{"description":"The environment supports destructuring (\'{ a, b } = obj\').","type":"boolean"},"dynamicImport":{"description":"The environment supports an async import() function to import EcmaScript modules.","type":"boolean"},"forOf":{"description":"The environment supports \'for of\' iteration (\'for (const x of array) { ... }\').","type":"boolean"},"module":{"description":"The environment supports EcmaScript Module syntax to import EcmaScript modules (import ... from \'...\').","type":"boolean"},"optionalChaining":{"description":"The environment supports optional chaining (\'obj?.a\' or \'obj?.()\').","type":"boolean"},"templateLiteral":{"description":"The environment supports template literals.","type":"boolean"}}},"Experiments":{"description":"Enables/Disables experiments (experimental features with relax SemVer compatibility).","type":"object","implements":["#/definitions/ExperimentsCommon"],"additionalProperties":false,"properties":{"asyncWebAssembly":{"description":"Support WebAssembly as asynchronous EcmaScript Module.","type":"boolean"},"backCompat":{"description":"Enable backward-compat layer with deprecation warnings for many webpack 4 APIs.","type":"boolean"},"buildHttp":{"description":"Build http(s): urls using a lockfile and resource content cache.","anyOf":[{"$ref":"#/definitions/HttpUriAllowedUris"},{"$ref":"#/definitions/HttpUriOptions"}]},"cacheUnaffected":{"description":"Enable additional in memory caching of modules that are unchanged and reference only unchanged modules.","type":"boolean"},"css":{"description":"Enable css support.","anyOf":[{"type":"boolean"},{"$ref":"#/definitions/CssExperimentOptions"}]},"futureDefaults":{"description":"Apply defaults of next major version.","type":"boolean"},"layers":{"description":"Enable module layers.","type":"boolean"},"lazyCompilation":{"description":"Compile entrypoints and import()s only when they are accessed.","anyOf":[{"type":"boolean"},{"$ref":"#/definitions/LazyCompilationOptions"}]},"outputModule":{"description":"Allow output javascript files as module source type.","type":"boolean"},"syncWebAssembly":{"description":"Support WebAssembly as synchronous EcmaScript Module (outdated).","type":"boolean"},"topLevelAwait":{"description":"Allow using top-level-await in EcmaScript Modules.","type":"boolean"}}},"ExperimentsCommon":{"description":"Enables/Disables experiments (experimental features with relax SemVer compatibility).","type":"object","additionalProperties":false,"properties":{"asyncWebAssembly":{"description":"Support WebAssembly as asynchronous EcmaScript Module.","type":"boolean"},"backCompat":{"description":"Enable backward-compat layer with deprecation warnings for many webpack 4 APIs.","type":"boolean"},"cacheUnaffected":{"description":"Enable additional in memory caching of modules that are unchanged and reference only unchanged modules.","type":"boolean"},"futureDefaults":{"description":"Apply defaults of next major version.","type":"boolean"},"layers":{"description":"Enable module layers.","type":"boolean"},"outputModule":{"description":"Allow output javascript files as module source type.","type":"boolean"},"syncWebAssembly":{"description":"Support WebAssembly as synchronous EcmaScript Module (outdated).","type":"boolean"},"topLevelAwait":{"description":"Allow using top-level-await in EcmaScript Modules.","type":"boolean"}}},"ExperimentsNormalized":{"description":"Enables/Disables experiments (experimental features with relax SemVer compatibility).","type":"object","implements":["#/definitions/ExperimentsCommon"],"additionalProperties":false,"properties":{"asyncWebAssembly":{"description":"Support WebAssembly as asynchronous EcmaScript Module.","type":"boolean"},"backCompat":{"description":"Enable backward-compat layer with deprecation warnings for many webpack 4 APIs.","type":"boolean"},"buildHttp":{"description":"Build http(s): urls using a lockfile and resource content cache.","oneOf":[{"$ref":"#/definitions/HttpUriOptions"}]},"cacheUnaffected":{"description":"Enable additional in memory caching of modules that are unchanged and reference only unchanged modules.","type":"boolean"},"css":{"description":"Enable css support.","oneOf":[{"$ref":"#/definitions/CssExperimentOptions"}]},"futureDefaults":{"description":"Apply defaults of next major version.","type":"boolean"},"layers":{"description":"Enable module layers.","type":"boolean"},"lazyCompilation":{"description":"Compile entrypoints and import()s only when they are accessed.","oneOf":[{"$ref":"#/definitions/LazyCompilationOptions"}]},"outputModule":{"description":"Allow output javascript files as module source type.","type":"boolean"},"syncWebAssembly":{"description":"Support WebAssembly as synchronous EcmaScript Module (outdated).","type":"boolean"},"topLevelAwait":{"description":"Allow using top-level-await in EcmaScript Modules.","type":"boolean"}}},"ExternalItem":{"description":"Specify dependency that shouldn\'t be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.","anyOf":[{"description":"Every matched dependency becomes external.","instanceof":"RegExp","tsType":"RegExp"},{"description":"An exact matched dependency becomes external. The same string is used as external dependency.","type":"string"},{"description":"If an dependency matches exactly a property of the object, the property value is used as dependency.","type":"object","additionalProperties":{"$ref":"#/definitions/ExternalItemValue"},"properties":{"byLayer":{"description":"Specify externals depending on the layer.","anyOf":[{"type":"object","additionalProperties":{"$ref":"#/definitions/ExternalItem"}},{"instanceof":"Function","tsType":"((layer: string | null) => ExternalItem)"}]}}},{"description":"The function is called on each dependency (`function(context, request, callback(err, result))`).","instanceof":"Function","tsType":"(((data: ExternalItemFunctionData, callback: (err?: Error, result?: ExternalItemValue) => void) => void) | ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>))"}]},"ExternalItemFunctionData":{"description":"Data object passed as argument when a function is set for \'externals\'.","type":"object","additionalProperties":false,"properties":{"context":{"description":"The directory in which the request is placed.","type":"string"},"contextInfo":{"description":"Contextual information.","type":"object","tsType":"import(\'../lib/ModuleFactory\').ModuleFactoryCreateDataContextInfo"},"dependencyType":{"description":"The category of the referencing dependencies.","type":"string"},"getResolve":{"description":"Get a resolve function with the current resolver options.","instanceof":"Function","tsType":"((options?: ResolveOptions) => ((context: string, request: string, callback: (err?: Error, result?: string) => void) => void) | ((context: string, request: string) => Promise<string>))"},"request":{"description":"The request as written by the user in the require/import expression/statement.","type":"string"}}},"ExternalItemValue":{"description":"The dependency used for the external.","anyOf":[{"type":"array","items":{"description":"A part of the target of the external.","type":"string","minLength":1}},{"description":"`true`: The dependency name is used as target of the external.","type":"boolean"},{"description":"The target of the external.","type":"string"},{"type":"object"}]},"Externals":{"description":"Specify dependencies that shouldn\'t be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.","anyOf":[{"type":"array","items":{"$ref":"#/definitions/ExternalItem"}},{"$ref":"#/definitions/ExternalItem"}]},"ExternalsPresets":{"description":"Enable presets of externals for specific targets.","type":"object","additionalProperties":false,"properties":{"electron":{"description":"Treat common electron built-in modules in main and preload context like \'electron\', \'ipc\' or \'shell\' as external and load them via require() when used.","type":"boolean"},"electronMain":{"description":"Treat electron built-in modules in the main context like \'app\', \'ipc-main\' or \'shell\' as external and load them via require() when used.","type":"boolean"},"electronPreload":{"description":"Treat electron built-in modules in the preload context like \'web-frame\', \'ipc-renderer\' or \'shell\' as external and load them via require() when used.","type":"boolean"},"electronRenderer":{"description":"Treat electron built-in modules in the renderer context like \'web-frame\', \'ipc-renderer\' or \'shell\' as external and load them via require() when used.","type":"boolean"},"node":{"description":"Treat node.js built-in modules like fs, path or vm as external and load them via require() when used.","type":"boolean"},"nwjs":{"description":"Treat NW.js legacy nw.gui module as external and load it via require() when used.","type":"boolean"},"web":{"description":"Treat references to \'http(s)://...\' and \'std:...\' as external and load them via import when used (Note that this changes execution order as externals are executed before any other code in the chunk).","type":"boolean"},"webAsync":{"description":"Treat references to \'http(s)://...\' and \'std:...\' as external and load them via async import() when used (Note that this external type is an async module, which has various effects on the execution).","type":"boolean"}}},"ExternalsType":{"description":"Specifies the default type of externals (\'amd*\', \'umd*\', \'system\' and \'jsonp\' depend on output.libraryTarget set to the same value).","enum":["var","module","assign","this","window","self","global","commonjs","commonjs2","commonjs-module","commonjs-static","amd","amd-require","umd","umd2","jsonp","system","promise","import","script","node-commonjs"]},"FileCacheOptions":{"description":"Options object for persistent file-based caching.","type":"object","additionalProperties":false,"properties":{"allowCollectingMemory":{"description":"Allows to collect unused memory allocated during deserialization. This requires copying data into smaller buffers and has a performance cost.","type":"boolean"},"buildDependencies":{"description":"Dependencies the build depends on (in multiple categories, default categories: \'defaultWebpack\').","type":"object","additionalProperties":{"description":"List of dependencies the build depends on.","type":"array","items":{"description":"Request to a dependency (resolved as directory relative to the context directory).","type":"string","minLength":1}}},"cacheDirectory":{"description":"Base directory for the cache (defaults to node_modules/.cache/webpack).","type":"string","absolutePath":true},"cacheLocation":{"description":"Locations for the cache (defaults to cacheDirectory / name).","type":"string","absolutePath":true},"compression":{"description":"Compression type used for the cache files.","enum":[false,"gzip","brotli"]},"hashAlgorithm":{"description":"Algorithm used for generation the hash (see node.js crypto package).","type":"string"},"idleTimeout":{"description":"Time in ms after which idle period the cache storing should happen.","type":"number","minimum":0},"idleTimeoutAfterLargeChanges":{"description":"Time in ms after which idle period the cache storing should happen when larger changes has been detected (cumulative build time > 2 x avg cache store time).","type":"number","minimum":0},"idleTimeoutForInitialStore":{"description":"Time in ms after which idle period the initial cache storing should happen.","type":"number","minimum":0},"immutablePaths":{"description":"List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.","type":"array","items":{"description":"List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.","anyOf":[{"description":"A RegExp matching an immutable directory (usually a package manager cache directory, including the tailing slash)","instanceof":"RegExp","tsType":"RegExp"},{"description":"A path to an immutable directory (usually a package manager cache directory).","type":"string","absolutePath":true,"minLength":1}]}},"managedPaths":{"description":"List of paths that are managed by a package manager and can be trusted to not be modified otherwise.","type":"array","items":{"description":"List of paths that are managed by a package manager and can be trusted to not be modified otherwise.","anyOf":[{"description":"A RegExp matching a managed directory (usually a node_modules directory, including the tailing slash)","instanceof":"RegExp","tsType":"RegExp"},{"description":"A path to a managed directory (usually a node_modules directory).","type":"string","absolutePath":true,"minLength":1}]}},"maxAge":{"description":"Time for which unused cache entries stay in the filesystem cache at minimum (in milliseconds).","type":"number","minimum":0},"maxMemoryGenerations":{"description":"Number of generations unused cache entries stay in memory cache at minimum (0 = no memory cache used, 1 = may be removed after unused for a single compilation, ..., Infinity: kept forever). Cache entries will be deserialized from disk when removed from memory cache.","type":"number","minimum":0},"memoryCacheUnaffected":{"description":"Additionally cache computation of modules that are unchanged and reference only unchanged modules in memory.","type":"boolean"},"name":{"description":"Name for the cache. Different names will lead to different coexisting caches.","type":"string"},"profile":{"description":"Track and log detailed timing information for individual cache items.","type":"boolean"},"store":{"description":"When to store data to the filesystem. (pack: Store data when compiler is idle in a single file).","enum":["pack"]},"type":{"description":"Filesystem caching.","enum":["filesystem"]},"version":{"description":"Version of the cache data. Different versions won\'t allow to reuse the cache and override existing content. Update the version when config changed in a way which doesn\'t allow to reuse cache. This will invalidate the cache.","type":"string"}},"required":["type"]},"Filename":{"description":"Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by \'/\'! The specified path is joined with the value of the \'output.path\' option to determine the location on disk.","oneOf":[{"$ref":"#/definitions/FilenameTemplate"}]},"FilenameTemplate":{"description":"Specifies the filename template of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by \'/\'! The specified path is joined with the value of the \'output.path\' option to determine the location on disk.","anyOf":[{"type":"string","absolutePath":false,"minLength":1},{"instanceof":"Function","tsType":"((pathData: import(\\"../lib/Compilation\\").PathData, assetInfo?: import(\\"../lib/Compilation\\").AssetInfo) => string)"}]},"FilterItemTypes":{"description":"Filtering value, regexp or function.","cli":{"helper":true},"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((value: string) => boolean)"}]},"FilterTypes":{"description":"Filtering values.","cli":{"helper":true},"anyOf":[{"type":"array","items":{"description":"Rule to filter.","cli":{"helper":true},"oneOf":[{"$ref":"#/definitions/FilterItemTypes"}]}},{"$ref":"#/definitions/FilterItemTypes"}]},"GeneratorOptionsByModuleType":{"description":"Specify options for each generator.","type":"object","additionalProperties":{"description":"Options for generating.","type":"object","additionalProperties":true},"properties":{"asset":{"$ref":"#/definitions/AssetGeneratorOptions"},"asset/inline":{"$ref":"#/definitions/AssetInlineGeneratorOptions"},"asset/resource":{"$ref":"#/definitions/AssetResourceGeneratorOptions"},"javascript":{"$ref":"#/definitions/EmptyGeneratorOptions"},"javascript/auto":{"$ref":"#/definitions/EmptyGeneratorOptions"},"javascript/dynamic":{"$ref":"#/definitions/EmptyGeneratorOptions"},"javascript/esm":{"$ref":"#/definitions/EmptyGeneratorOptions"}}},"GlobalObject":{"description":"An expression which is used to address the global object/scope in runtime code.","type":"string","minLength":1},"HashDigest":{"description":"Digest type used for the hash.","type":"string"},"HashDigestLength":{"description":"Number of chars which are used for the hash.","type":"number","minimum":1},"HashFunction":{"description":"Algorithm used for generation the hash (see node.js crypto package).","anyOf":[{"type":"string","minLength":1},{"instanceof":"Function","tsType":"typeof import(\'../lib/util/Hash\')"}]},"HashSalt":{"description":"Any string which is added to the hash to salt it.","type":"string","minLength":1},"HotUpdateChunkFilename":{"description":"The filename of the Hot Update Chunks. They are inside the output.path directory.","type":"string","absolutePath":false},"HotUpdateGlobal":{"description":"The global variable used by webpack for loading of hot update chunks.","type":"string"},"HotUpdateMainFilename":{"description":"The filename of the Hot Update Main File. It is inside the \'output.path\' directory.","type":"string","absolutePath":false},"HttpUriAllowedUris":{"description":"List of allowed URIs for building http resources.","cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/HttpUriOptionsAllowedUris"}]},"HttpUriOptions":{"description":"Options for building http resources.","type":"object","additionalProperties":false,"properties":{"allowedUris":{"$ref":"#/definitions/HttpUriOptionsAllowedUris"},"cacheLocation":{"description":"Location where resource content is stored for lockfile entries. It\'s also possible to disable storing by passing false.","anyOf":[{"enum":[false]},{"type":"string","absolutePath":true}]},"frozen":{"description":"When set, anything that would lead to a modification of the lockfile or any resource content, will result in an error.","type":"boolean"},"lockfileLocation":{"description":"Location of the lockfile.","type":"string","absolutePath":true},"proxy":{"description":"Proxy configuration, which can be used to specify a proxy server to use for HTTP requests.","type":"string"},"upgrade":{"description":"When set, resources of existing lockfile entries will be fetched and entries will be upgraded when resource content has changed.","type":"boolean"}},"required":["allowedUris"]},"HttpUriOptionsAllowedUris":{"description":"List of allowed URIs (resp. the beginning of them).","type":"array","items":{"description":"List of allowed URIs (resp. the beginning of them).","anyOf":[{"description":"Allowed URI pattern.","instanceof":"RegExp","tsType":"RegExp"},{"description":"Allowed URI (resp. the beginning of it).","type":"string","pattern":"^https?://"},{"description":"Allowed URI filter function.","instanceof":"Function","tsType":"((uri: string) => boolean)"}]}},"IgnoreWarnings":{"description":"Ignore specific warnings.","type":"array","items":{"description":"Ignore specific warnings.","anyOf":[{"description":"A RegExp to select the warning message.","instanceof":"RegExp","tsType":"RegExp"},{"type":"object","additionalProperties":false,"properties":{"file":{"description":"A RegExp to select the origin file for the warning.","instanceof":"RegExp","tsType":"RegExp"},"message":{"description":"A RegExp to select the warning message.","instanceof":"RegExp","tsType":"RegExp"},"module":{"description":"A RegExp to select the origin module for the warning.","instanceof":"RegExp","tsType":"RegExp"}}},{"description":"A custom function to select warnings based on the raw warning instance.","instanceof":"Function","tsType":"((warning: import(\'../lib/WebpackError\'), compilation: import(\'../lib/Compilation\')) => boolean)"}]}},"IgnoreWarningsNormalized":{"description":"Ignore specific warnings.","type":"array","items":{"description":"A function to select warnings based on the raw warning instance.","instanceof":"Function","tsType":"((warning: import(\'../lib/WebpackError\'), compilation: import(\'../lib/Compilation\')) => boolean)"}},"Iife":{"description":"Wrap javascript code into IIFE\'s to avoid leaking into global scope.","type":"boolean"},"ImportFunctionName":{"description":"The name of the native import() function (can be exchanged for a polyfill).","type":"string"},"ImportMetaName":{"description":"The name of the native import.meta object (can be exchanged for a polyfill).","type":"string"},"InfrastructureLogging":{"description":"Options for infrastructure level logging.","type":"object","additionalProperties":false,"properties":{"appendOnly":{"description":"Only appends lines to the output. Avoids updating existing output e. g. for status messages. This option is only used when no custom console is provided.","type":"boolean"},"colors":{"description":"Enables/Disables colorful output. This option is only used when no custom console is provided.","type":"boolean"},"console":{"description":"Custom console used for logging.","tsType":"Console"},"debug":{"description":"Enable debug logging for specific loggers.","anyOf":[{"description":"Enable/Disable debug logging for all loggers.","type":"boolean"},{"$ref":"#/definitions/FilterTypes"}]},"level":{"description":"Log level.","enum":["none","error","warn","info","log","verbose"]},"stream":{"description":"Stream used for logging output. Defaults to process.stderr. This option is only used when no custom console is provided.","tsType":"NodeJS.WritableStream"}}},"JavascriptParserOptions":{"description":"Parser options for javascript modules.","type":"object","additionalProperties":true,"properties":{"amd":{"$ref":"#/definitions/Amd"},"browserify":{"description":"Enable/disable special handling for browserify bundles.","type":"boolean"},"commonjs":{"description":"Enable/disable parsing of CommonJs syntax.","type":"boolean"},"commonjsMagicComments":{"description":"Enable/disable parsing of magic comments in CommonJs syntax.","type":"boolean"},"createRequire":{"description":"Enable/disable parsing \\"import { createRequire } from \\"module\\"\\" and evaluating createRequire().","anyOf":[{"type":"boolean"},{"type":"string"}]},"dynamicImportMode":{"description":"Specifies global mode for dynamic import.","enum":["eager","weak","lazy","lazy-once"]},"dynamicImportPrefetch":{"description":"Specifies global prefetch for dynamic import.","anyOf":[{"type":"number"},{"type":"boolean"}]},"dynamicImportPreload":{"description":"Specifies global preload for dynamic import.","anyOf":[{"type":"number"},{"type":"boolean"}]},"exportsPresence":{"description":"Specifies the behavior of invalid export names in \\"import ... from ...\\" and \\"export ... from ...\\".","enum":["error","warn","auto",false]},"exprContextCritical":{"description":"Enable warnings for full dynamic dependencies.","type":"boolean"},"exprContextRecursive":{"description":"Enable recursive directory lookup for full dynamic dependencies.","type":"boolean"},"exprContextRegExp":{"description":"Sets the default regular expression for full dynamic dependencies.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"boolean"}]},"exprContextRequest":{"description":"Set the default request for full dynamic dependencies.","type":"string"},"harmony":{"description":"Enable/disable parsing of EcmaScript Modules syntax.","type":"boolean"},"import":{"description":"Enable/disable parsing of import() syntax.","type":"boolean"},"importExportsPresence":{"description":"Specifies the behavior of invalid export names in \\"import ... from ...\\".","enum":["error","warn","auto",false]},"importMeta":{"description":"Enable/disable evaluating import.meta.","type":"boolean"},"importMetaContext":{"description":"Enable/disable evaluating import.meta.webpackContext.","type":"boolean"},"node":{"$ref":"#/definitions/Node"},"reexportExportsPresence":{"description":"Specifies the behavior of invalid export names in \\"export ... from ...\\". This might be useful to disable during the migration from \\"export ... from ...\\" to \\"export type ... from ...\\" when reexporting types in TypeScript.","enum":["error","warn","auto",false]},"requireContext":{"description":"Enable/disable parsing of require.context syntax.","type":"boolean"},"requireEnsure":{"description":"Enable/disable parsing of require.ensure syntax.","type":"boolean"},"requireInclude":{"description":"Enable/disable parsing of require.include syntax.","type":"boolean"},"requireJs":{"description":"Enable/disable parsing of require.js special syntax like require.config, requirejs.config, require.version and requirejs.onError.","type":"boolean"},"strictExportPresence":{"description":"Deprecated in favor of \\"exportsPresence\\". Emit errors instead of warnings when imported names don\'t exist in imported module.","type":"boolean"},"strictThisContextOnImports":{"description":"Handle the this context correctly according to the spec for namespace objects.","type":"boolean"},"system":{"description":"Enable/disable parsing of System.js special syntax like System.import, System.get, System.set and System.register.","type":"boolean"},"unknownContextCritical":{"description":"Enable warnings when using the require function in a not statically analyse-able way.","type":"boolean"},"unknownContextRecursive":{"description":"Enable recursive directory lookup when using the require function in a not statically analyse-able way.","type":"boolean"},"unknownContextRegExp":{"description":"Sets the regular expression when using the require function in a not statically analyse-able way.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"boolean"}]},"unknownContextRequest":{"description":"Sets the request when using the require function in a not statically analyse-able way.","type":"string"},"url":{"description":"Enable/disable parsing of new URL() syntax.","anyOf":[{"enum":["relative"]},{"type":"boolean"}]},"worker":{"description":"Disable or configure parsing of WebWorker syntax like new Worker() or navigator.serviceWorker.register().","anyOf":[{"type":"array","items":{"description":"Specify a syntax that should be parsed as WebWorker reference. \'Abc\' handles \'new Abc()\', \'Abc from xyz\' handles \'import { Abc } from \\"xyz\\"; new Abc()\', \'abc()\' handles \'abc()\', and combinations are also possible.","type":"string","minLength":1}},{"type":"boolean"}]},"wrappedContextCritical":{"description":"Enable warnings for partial dynamic dependencies.","type":"boolean"},"wrappedContextRecursive":{"description":"Enable recursive directory lookup for partial dynamic dependencies.","type":"boolean"},"wrappedContextRegExp":{"description":"Set the inner regular expression for partial dynamic dependencies.","instanceof":"RegExp","tsType":"RegExp"}}},"Layer":{"description":"Specifies the layer in which modules of this entrypoint are placed.","anyOf":[{"enum":[null]},{"type":"string","minLength":1}]},"LazyCompilationDefaultBackendOptions":{"description":"Options for the default backend.","type":"object","additionalProperties":false,"properties":{"client":{"description":"A custom client.","type":"string"},"listen":{"description":"Specifies where to listen to from the server.","anyOf":[{"description":"A port.","type":"number"},{"description":"Listen options.","type":"object","additionalProperties":true,"properties":{"host":{"description":"A host.","type":"string"},"port":{"description":"A port.","type":"number"}},"tsType":"import(\\"net\\").ListenOptions"},{"description":"A custom listen function.","instanceof":"Function","tsType":"((server: import(\\"net\\").Server) => void)"}]},"protocol":{"description":"Specifies the protocol the client should use to connect to the server.","enum":["http","https"]},"server":{"description":"Specifies how to create the server handling the EventSource requests.","anyOf":[{"description":"ServerOptions for the http or https createServer call.","type":"object","additionalProperties":true,"properties":{},"tsType":"(import(\\"https\\").ServerOptions | import(\\"http\\").ServerOptions)"},{"description":"A custom create server function.","instanceof":"Function","tsType":"(() => import(\\"net\\").Server)"}]}}},"LazyCompilationOptions":{"description":"Options for compiling entrypoints and import()s only when they are accessed.","type":"object","additionalProperties":false,"properties":{"backend":{"description":"Specifies the backend that should be used for handling client keep alive.","anyOf":[{"description":"A custom backend.","instanceof":"Function","tsType":"(((compiler: import(\'../lib/Compiler\'), callback: (err?: Error, api?: import(\\"../lib/hmr/LazyCompilationPlugin\\").BackendApi) => void) => void) | ((compiler: import(\'../lib/Compiler\')) => Promise<import(\\"../lib/hmr/LazyCompilationPlugin\\").BackendApi>))"},{"$ref":"#/definitions/LazyCompilationDefaultBackendOptions"}]},"entries":{"description":"Enable/disable lazy compilation for entries.","type":"boolean"},"imports":{"description":"Enable/disable lazy compilation for import() modules.","type":"boolean"},"test":{"description":"Specify which entrypoints or import()ed modules should be lazily compiled. This is matched with the imported module and not the entrypoint name.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"((module: import(\'../lib/Module\')) => boolean)"}]}}},"Library":{"description":"Make the output files a library, exporting the exports of the entry point.","anyOf":[{"$ref":"#/definitions/LibraryName"},{"$ref":"#/definitions/LibraryOptions"}]},"LibraryCustomUmdCommentObject":{"description":"Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set comment for `amd` section in UMD.","type":"string"},"commonjs":{"description":"Set comment for `commonjs` (exports) section in UMD.","type":"string"},"commonjs2":{"description":"Set comment for `commonjs2` (module.exports) section in UMD.","type":"string"},"root":{"description":"Set comment for `root` (global variable) section in UMD.","type":"string"}}},"LibraryCustomUmdObject":{"description":"Description object for all UMD variants of the library name.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Name of the exposed AMD library in the UMD.","type":"string","minLength":1},"commonjs":{"description":"Name of the exposed commonjs export in the UMD.","type":"string","minLength":1},"root":{"description":"Name of the property exposed globally by a UMD library.","anyOf":[{"type":"array","items":{"description":"Part of the name of the property exposed globally by a UMD library.","type":"string","minLength":1}},{"type":"string","minLength":1}]}}},"LibraryExport":{"description":"Specify which export should be exposed as library.","anyOf":[{"type":"array","items":{"description":"Part of the export that should be exposed as library.","type":"string","minLength":1}},{"type":"string","minLength":1}]},"LibraryName":{"description":"The name of the library (some types allow unnamed libraries too).","anyOf":[{"type":"array","items":{"description":"A part of the library name.","type":"string","minLength":1},"minItems":1},{"type":"string","minLength":1},{"$ref":"#/definitions/LibraryCustomUmdObject"}]},"LibraryOptions":{"description":"Options for library.","type":"object","additionalProperties":false,"properties":{"auxiliaryComment":{"$ref":"#/definitions/AuxiliaryComment"},"export":{"$ref":"#/definitions/LibraryExport"},"name":{"$ref":"#/definitions/LibraryName"},"type":{"$ref":"#/definitions/LibraryType"},"umdNamedDefine":{"$ref":"#/definitions/UmdNamedDefine"}},"required":["type"]},"LibraryType":{"description":"Type of library (types included by default are \'var\', \'module\', \'assign\', \'assign-properties\', \'this\', \'window\', \'self\', \'global\', \'commonjs\', \'commonjs2\', \'commonjs-module\', \'commonjs-static\', \'amd\', \'amd-require\', \'umd\', \'umd2\', \'jsonp\', \'system\', but others might be added by plugins).","anyOf":[{"enum":["var","module","assign","assign-properties","this","window","self","global","commonjs","commonjs2","commonjs-module","commonjs-static","amd","amd-require","umd","umd2","jsonp","system"]},{"type":"string"}]},"Loader":{"description":"Custom values available in the loader context.","type":"object"},"MemoryCacheOptions":{"description":"Options object for in-memory caching.","type":"object","additionalProperties":false,"properties":{"cacheUnaffected":{"description":"Additionally cache computation of modules that are unchanged and reference only unchanged modules.","type":"boolean"},"maxGenerations":{"description":"Number of generations unused cache entries stay in memory cache at minimum (1 = may be removed after unused for a single compilation, ..., Infinity: kept forever).","type":"number","minimum":1},"type":{"description":"In memory caching.","enum":["memory"]}},"required":["type"]},"Mode":{"description":"Enable production optimizations or development hints.","enum":["development","production","none"]},"ModuleFilterItemTypes":{"description":"Filtering value, regexp or function.","cli":{"helper":true},"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((name: string, module: import(\'../lib/stats/DefaultStatsFactoryPlugin\').StatsModule, type: \'module\' | \'chunk\' | \'root-of-chunk\' | \'nested\') => boolean)"}]},"ModuleFilterTypes":{"description":"Filtering modules.","cli":{"helper":true},"anyOf":[{"type":"array","items":{"description":"Rule to filter.","cli":{"helper":true},"oneOf":[{"$ref":"#/definitions/ModuleFilterItemTypes"}]}},{"$ref":"#/definitions/ModuleFilterItemTypes"}]},"ModuleOptions":{"description":"Options affecting the normal modules (`NormalModuleFactory`).","type":"object","additionalProperties":false,"properties":{"defaultRules":{"description":"An array of rules applied by default for modules.","cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/RuleSetRules"}]},"exprContextCritical":{"description":"Enable warnings for full dynamic dependencies.","type":"boolean"},"exprContextRecursive":{"description":"Enable recursive directory lookup for full dynamic dependencies. Deprecated: This option has moved to \'module.parser.javascript.exprContextRecursive\'.","type":"boolean"},"exprContextRegExp":{"description":"Sets the default regular expression for full dynamic dependencies. Deprecated: This option has moved to \'module.parser.javascript.exprContextRegExp\'.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"boolean"}]},"exprContextRequest":{"description":"Set the default request for full dynamic dependencies. Deprecated: This option has moved to \'module.parser.javascript.exprContextRequest\'.","type":"string"},"generator":{"$ref":"#/definitions/GeneratorOptionsByModuleType"},"noParse":{"$ref":"#/definitions/NoParse"},"parser":{"$ref":"#/definitions/ParserOptionsByModuleType"},"rules":{"description":"An array of rules applied for modules.","oneOf":[{"$ref":"#/definitions/RuleSetRules"}]},"strictExportPresence":{"description":"Emit errors instead of warnings when imported names don\'t exist in imported module. Deprecated: This option has moved to \'module.parser.javascript.strictExportPresence\'.","type":"boolean"},"strictThisContextOnImports":{"description":"Handle the this context correctly according to the spec for namespace objects. Deprecated: This option has moved to \'module.parser.javascript.strictThisContextOnImports\'.","type":"boolean"},"unknownContextCritical":{"description":"Enable warnings when using the require function in a not statically analyse-able way. Deprecated: This option has moved to \'module.parser.javascript.unknownContextCritical\'.","type":"boolean"},"unknownContextRecursive":{"description":"Enable recursive directory lookup when using the require function in a not statically analyse-able way. Deprecated: This option has moved to \'module.parser.javascript.unknownContextRecursive\'.","type":"boolean"},"unknownContextRegExp":{"description":"Sets the regular expression when using the require function in a not statically analyse-able way. Deprecated: This option has moved to \'module.parser.javascript.unknownContextRegExp\'.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"boolean"}]},"unknownContextRequest":{"description":"Sets the request when using the require function in a not statically analyse-able way. Deprecated: This option has moved to \'module.parser.javascript.unknownContextRequest\'.","type":"string"},"unsafeCache":{"description":"Cache the resolving of module requests.","anyOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"}]},"wrappedContextCritical":{"description":"Enable warnings for partial dynamic dependencies. Deprecated: This option has moved to \'module.parser.javascript.wrappedContextCritical\'.","type":"boolean"},"wrappedContextRecursive":{"description":"Enable recursive directory lookup for partial dynamic dependencies. Deprecated: This option has moved to \'module.parser.javascript.wrappedContextRecursive\'.","type":"boolean"},"wrappedContextRegExp":{"description":"Set the inner regular expression for partial dynamic dependencies. Deprecated: This option has moved to \'module.parser.javascript.wrappedContextRegExp\'.","instanceof":"RegExp","tsType":"RegExp"}}},"ModuleOptionsNormalized":{"description":"Options affecting the normal modules (`NormalModuleFactory`).","type":"object","additionalProperties":false,"properties":{"defaultRules":{"description":"An array of rules applied by default for modules.","cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/RuleSetRules"}]},"generator":{"$ref":"#/definitions/GeneratorOptionsByModuleType"},"noParse":{"$ref":"#/definitions/NoParse"},"parser":{"$ref":"#/definitions/ParserOptionsByModuleType"},"rules":{"description":"An array of rules applied for modules.","oneOf":[{"$ref":"#/definitions/RuleSetRules"}]},"unsafeCache":{"description":"Cache the resolving of module requests.","anyOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"}]}},"required":["defaultRules","generator","parser","rules"]},"Name":{"description":"Name of the configuration. Used when loading multiple configurations.","type":"string"},"NoParse":{"description":"Don\'t parse files matching. It\'s matched against the full resolved request.","anyOf":[{"type":"array","items":{"description":"Don\'t parse files matching. It\'s matched against the full resolved request.","anyOf":[{"description":"A regular expression, when matched the module is not parsed.","instanceof":"RegExp","tsType":"RegExp"},{"description":"An absolute path, when the module starts with this path it is not parsed.","type":"string","absolutePath":true},{"instanceof":"Function","tsType":"Function"}]},"minItems":1},{"description":"A regular expression, when matched the module is not parsed.","instanceof":"RegExp","tsType":"RegExp"},{"description":"An absolute path, when the module starts with this path it is not parsed.","type":"string","absolutePath":true},{"instanceof":"Function","tsType":"Function"}]},"Node":{"description":"Include polyfills or mocks for various node stuff.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/NodeOptions"}]},"NodeOptions":{"description":"Options object for node compatibility features.","type":"object","additionalProperties":false,"properties":{"__dirname":{"description":"Include a polyfill for the \'__dirname\' variable.","enum":[false,true,"warn-mock","mock","eval-only"]},"__filename":{"description":"Include a polyfill for the \'__filename\' variable.","enum":[false,true,"warn-mock","mock","eval-only"]},"global":{"description":"Include a polyfill for the \'global\' variable.","enum":[false,true,"warn"]}}},"Optimization":{"description":"Enables/Disables integrated optimizations.","type":"object","additionalProperties":false,"properties":{"checkWasmTypes":{"description":"Check for incompatible wasm types when importing/exporting from/to ESM.","type":"boolean"},"chunkIds":{"description":"Define the algorithm to choose chunk ids (named: readable ids for better debugging, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin).","enum":["natural","named","deterministic","size","total-size",false]},"concatenateModules":{"description":"Concatenate modules when possible to generate less modules, more efficient code and enable more optimizations by the minimizer.","type":"boolean"},"emitOnErrors":{"description":"Emit assets even when errors occur. Critical errors are emitted into the generated code and will cause errors at runtime.","type":"boolean"},"flagIncludedChunks":{"description":"Also flag chunks as loaded which contain a subset of the modules.","type":"boolean"},"innerGraph":{"description":"Creates a module-internal dependency graph for top level symbols, exports and imports, to improve unused exports detection.","type":"boolean"},"mangleExports":{"description":"Rename exports when possible to generate shorter code (depends on optimization.usedExports and optimization.providedExports, true/\\"deterministic\\": generate short deterministic names optimized for caching, \\"size\\": generate the shortest possible names).","anyOf":[{"enum":["size","deterministic"]},{"type":"boolean"}]},"mangleWasmImports":{"description":"Reduce size of WASM by changing imports to shorter strings.","type":"boolean"},"mergeDuplicateChunks":{"description":"Merge chunks which contain the same modules.","type":"boolean"},"minimize":{"description":"Enable minimizing the output. Uses optimization.minimizer.","type":"boolean"},"minimizer":{"description":"Minimizer(s) to use for minimizing the output.","type":"array","cli":{"exclude":true},"items":{"description":"Plugin of type object or instanceof Function.","anyOf":[{"enum":["..."]},{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"moduleIds":{"description":"Define the algorithm to choose module ids (natural: numeric ids in order of usage, named: readable ids for better debugging, hashed: (deprecated) short hashes as ids for better long term caching, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, false: no algorithm used, as custom one can be provided via plugin).","enum":["natural","named","hashed","deterministic","size",false]},"noEmitOnErrors":{"description":"Avoid emitting assets when errors occur (deprecated: use \'emitOnErrors\' instead).","type":"boolean","cli":{"exclude":true}},"nodeEnv":{"description":"Set process.env.NODE_ENV to a specific value.","anyOf":[{"enum":[false]},{"type":"string"}]},"portableRecords":{"description":"Generate records with relative paths to be able to move the context folder.","type":"boolean"},"providedExports":{"description":"Figure out which exports are provided by modules to generate more efficient code.","type":"boolean"},"realContentHash":{"description":"Use real [contenthash] based on final content of the assets.","type":"boolean"},"removeAvailableModules":{"description":"Removes modules from chunks when these modules are already included in all parents.","type":"boolean"},"removeEmptyChunks":{"description":"Remove chunks which are empty.","type":"boolean"},"runtimeChunk":{"$ref":"#/definitions/OptimizationRuntimeChunk"},"sideEffects":{"description":"Skip over modules which contain no side effects when exports are not used (false: disabled, \'flag\': only use manually placed side effects flag, true: also analyse source code for side effects).","anyOf":[{"enum":["flag"]},{"type":"boolean"}]},"splitChunks":{"description":"Optimize duplication and caching by splitting chunks by shared modules and cache group.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/OptimizationSplitChunksOptions"}]},"usedExports":{"description":"Figure out which exports are used by modules to mangle export names, omit unused exports and generate more efficient code (true: analyse used exports for each runtime, \\"global\\": analyse exports globally for all runtimes combined).","anyOf":[{"enum":["global"]},{"type":"boolean"}]}}},"OptimizationRuntimeChunk":{"description":"Create an additional chunk which contains only the webpack runtime and chunk hash maps.","anyOf":[{"enum":["single","multiple"]},{"type":"boolean"},{"type":"object","additionalProperties":false,"properties":{"name":{"description":"The name or name factory for the runtime chunks.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]}}}]},"OptimizationRuntimeChunkNormalized":{"description":"Create an additional chunk which contains only the webpack runtime and chunk hash maps.","anyOf":[{"enum":[false]},{"type":"object","additionalProperties":false,"properties":{"name":{"description":"The name factory for the runtime chunks.","instanceof":"Function","tsType":"Function"}}}]},"OptimizationSplitChunksCacheGroup":{"description":"Options object for describing behavior of a cache group selecting modules that should be cached together.","type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks.","type":"string","minLength":1},"chunks":{"description":"Select chunks for determining cache group content (defaults to \\"initial\\", \\"initial\\" and \\"all\\" requires adding these chunks to the HTML).","anyOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"((chunk: import(\'../lib/Chunk\')) => boolean)"}]},"enforce":{"description":"Ignore minimum size, minimum chunks and maximum requests and always create chunks for this cache group.","type":"boolean"},"enforceSizeThreshold":{"description":"Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"filename":{"description":"Sets the template for the filename for created chunks.","anyOf":[{"type":"string","absolutePath":false,"minLength":1},{"instanceof":"Function","tsType":"((pathData: import(\\"../lib/Compilation\\").PathData, assetInfo?: import(\\"../lib/Compilation\\").AssetInfo) => string)"}]},"idHint":{"description":"Sets the hint for chunk id.","type":"string"},"layer":{"description":"Assign modules to a cache group by module layer.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"maxAsyncRequests":{"description":"Maximum number of requests which are accepted for on-demand loading.","type":"number","minimum":1},"maxAsyncSize":{"description":"Maximal size hint for the on-demand chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"maxInitialRequests":{"description":"Maximum number of initial chunks which are accepted for an entry point.","type":"number","minimum":1},"maxInitialSize":{"description":"Maximal size hint for the initial chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"maxSize":{"description":"Maximal size hint for the created chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minChunks":{"description":"Minimum number of times a module has to be duplicated until it\'s considered for splitting.","type":"number","minimum":1},"minRemainingSize":{"description":"Minimal size for the chunks the stay after moving the modules to a new chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minSize":{"description":"Minimal size for the created chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minSizeReduction":{"description":"Minimum size reduction due to the created chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"name":{"description":"Give chunks for this cache group a name (chunks with equal name are merged).","anyOf":[{"enum":[false]},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"priority":{"description":"Priority of this cache group.","type":"number"},"reuseExistingChunk":{"description":"Try to reuse existing chunk (with name) when it has matching modules.","type":"boolean"},"test":{"description":"Assign modules to a cache group by module name.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"type":{"description":"Assign modules to a cache group by module type.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"usedExports":{"description":"Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.","type":"boolean"}}},"OptimizationSplitChunksGetCacheGroups":{"description":"A function returning cache groups.","instanceof":"Function","tsType":"((module: import(\'../lib/Module\')) => OptimizationSplitChunksCacheGroup | OptimizationSplitChunksCacheGroup[] | void)"},"OptimizationSplitChunksOptions":{"description":"Options object for splitting chunks into smaller chunks.","type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks.","type":"string","minLength":1},"cacheGroups":{"description":"Assign modules to a cache group (modules from different cache groups are tried to keep in separate chunks, default categories: \'default\', \'defaultVendors\').","type":"object","additionalProperties":{"description":"Configuration for a cache group.","anyOf":[{"enum":[false]},{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"Function"},{"$ref":"#/definitions/OptimizationSplitChunksCacheGroup"}]},"not":{"description":"Using the cacheGroup shorthand syntax with a cache group named \'test\' is a potential config error\\nDid you intent to define a cache group with a test instead?\\ncacheGroups: {\\n  <name>: {\\n    test: ...\\n  }\\n}.","type":"object","additionalProperties":true,"properties":{"test":{"description":"The test property is a cache group name, but using the test option of the cache group could be intended instead.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]}},"required":["test"]}},"chunks":{"description":"Select chunks for determining shared modules (defaults to \\"async\\", \\"initial\\" and \\"all\\" requires adding these chunks to the HTML).","anyOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"((chunk: import(\'../lib/Chunk\')) => boolean)"}]},"defaultSizeTypes":{"description":"Sets the size types which are used when a number is used for sizes.","type":"array","items":{"description":"Size type, like \'javascript\', \'webassembly\'.","type":"string"},"minItems":1},"enforceSizeThreshold":{"description":"Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"fallbackCacheGroup":{"description":"Options for modules not selected by any other cache group.","type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks.","type":"string","minLength":1},"chunks":{"description":"Select chunks for determining shared modules (defaults to \\"async\\", \\"initial\\" and \\"all\\" requires adding these chunks to the HTML).","anyOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"((chunk: import(\'../lib/Chunk\')) => boolean)"}]},"maxAsyncSize":{"description":"Maximal size hint for the on-demand chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"maxInitialSize":{"description":"Maximal size hint for the initial chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"maxSize":{"description":"Maximal size hint for the created chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minSize":{"description":"Minimal size for the created chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minSizeReduction":{"description":"Minimum size reduction due to the created chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]}}},"filename":{"description":"Sets the template for the filename for created chunks.","anyOf":[{"type":"string","absolutePath":false,"minLength":1},{"instanceof":"Function","tsType":"((pathData: import(\\"../lib/Compilation\\").PathData, assetInfo?: import(\\"../lib/Compilation\\").AssetInfo) => string)"}]},"hidePathInfo":{"description":"Prevents exposing path info when creating names for parts splitted by maxSize.","type":"boolean"},"maxAsyncRequests":{"description":"Maximum number of requests which are accepted for on-demand loading.","type":"number","minimum":1},"maxAsyncSize":{"description":"Maximal size hint for the on-demand chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"maxInitialRequests":{"description":"Maximum number of initial chunks which are accepted for an entry point.","type":"number","minimum":1},"maxInitialSize":{"description":"Maximal size hint for the initial chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"maxSize":{"description":"Maximal size hint for the created chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minChunks":{"description":"Minimum number of times a module has to be duplicated until it\'s considered for splitting.","type":"number","minimum":1},"minRemainingSize":{"description":"Minimal size for the chunks the stay after moving the modules to a new chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minSize":{"description":"Minimal size for the created chunks.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"minSizeReduction":{"description":"Minimum size reduction due to the created chunk.","oneOf":[{"$ref":"#/definitions/OptimizationSplitChunksSizes"}]},"name":{"description":"Give chunks created a name (chunks with equal name are merged).","anyOf":[{"enum":[false]},{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"usedExports":{"description":"Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.","type":"boolean"}}},"OptimizationSplitChunksSizes":{"description":"Size description for limits.","anyOf":[{"description":"Size of the javascript part of the chunk.","type":"number","minimum":0},{"description":"Specify size limits per size type.","type":"object","additionalProperties":{"description":"Size of the part of the chunk with the type of the key.","type":"number"}}]},"Output":{"description":"Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.","type":"object","additionalProperties":false,"properties":{"assetModuleFilename":{"$ref":"#/definitions/AssetModuleFilename"},"asyncChunks":{"description":"Enable/disable creating async chunks that are loaded on demand.","type":"boolean"},"auxiliaryComment":{"cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/AuxiliaryComment"}]},"charset":{"$ref":"#/definitions/Charset"},"chunkFilename":{"$ref":"#/definitions/ChunkFilename"},"chunkFormat":{"$ref":"#/definitions/ChunkFormat"},"chunkLoadTimeout":{"$ref":"#/definitions/ChunkLoadTimeout"},"chunkLoading":{"$ref":"#/definitions/ChunkLoading"},"chunkLoadingGlobal":{"$ref":"#/definitions/ChunkLoadingGlobal"},"clean":{"$ref":"#/definitions/Clean"},"compareBeforeEmit":{"$ref":"#/definitions/CompareBeforeEmit"},"crossOriginLoading":{"$ref":"#/definitions/CrossOriginLoading"},"cssChunkFilename":{"$ref":"#/definitions/CssChunkFilename"},"cssFilename":{"$ref":"#/definitions/CssFilename"},"devtoolFallbackModuleFilenameTemplate":{"$ref":"#/definitions/DevtoolFallbackModuleFilenameTemplate"},"devtoolModuleFilenameTemplate":{"$ref":"#/definitions/DevtoolModuleFilenameTemplate"},"devtoolNamespace":{"$ref":"#/definitions/DevtoolNamespace"},"enabledChunkLoadingTypes":{"$ref":"#/definitions/EnabledChunkLoadingTypes"},"enabledLibraryTypes":{"$ref":"#/definitions/EnabledLibraryTypes"},"enabledWasmLoadingTypes":{"$ref":"#/definitions/EnabledWasmLoadingTypes"},"environment":{"$ref":"#/definitions/Environment"},"filename":{"$ref":"#/definitions/Filename"},"globalObject":{"$ref":"#/definitions/GlobalObject"},"hashDigest":{"$ref":"#/definitions/HashDigest"},"hashDigestLength":{"$ref":"#/definitions/HashDigestLength"},"hashFunction":{"$ref":"#/definitions/HashFunction"},"hashSalt":{"$ref":"#/definitions/HashSalt"},"hotUpdateChunkFilename":{"$ref":"#/definitions/HotUpdateChunkFilename"},"hotUpdateGlobal":{"$ref":"#/definitions/HotUpdateGlobal"},"hotUpdateMainFilename":{"$ref":"#/definitions/HotUpdateMainFilename"},"iife":{"$ref":"#/definitions/Iife"},"importFunctionName":{"$ref":"#/definitions/ImportFunctionName"},"importMetaName":{"$ref":"#/definitions/ImportMetaName"},"library":{"$ref":"#/definitions/Library"},"libraryExport":{"cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/LibraryExport"}]},"libraryTarget":{"cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/LibraryType"}]},"module":{"$ref":"#/definitions/OutputModule"},"path":{"$ref":"#/definitions/Path"},"pathinfo":{"$ref":"#/definitions/Pathinfo"},"publicPath":{"$ref":"#/definitions/PublicPath"},"scriptType":{"$ref":"#/definitions/ScriptType"},"sourceMapFilename":{"$ref":"#/definitions/SourceMapFilename"},"sourcePrefix":{"$ref":"#/definitions/SourcePrefix"},"strictModuleErrorHandling":{"$ref":"#/definitions/StrictModuleErrorHandling"},"strictModuleExceptionHandling":{"$ref":"#/definitions/StrictModuleExceptionHandling"},"trustedTypes":{"description":"Use a Trusted Types policy to create urls for chunks. \'output.uniqueName\' is used a default policy name. Passing a string sets a custom policy name.","anyOf":[{"enum":[true]},{"description":"The name of the Trusted Types policy created by webpack to serve bundle chunks.","type":"string","minLength":1},{"$ref":"#/definitions/TrustedTypes"}]},"umdNamedDefine":{"cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/UmdNamedDefine"}]},"uniqueName":{"$ref":"#/definitions/UniqueName"},"wasmLoading":{"$ref":"#/definitions/WasmLoading"},"webassemblyModuleFilename":{"$ref":"#/definitions/WebassemblyModuleFilename"},"workerChunkLoading":{"$ref":"#/definitions/ChunkLoading"},"workerWasmLoading":{"$ref":"#/definitions/WasmLoading"}}},"OutputModule":{"description":"Output javascript files as module source type.","type":"boolean"},"OutputNormalized":{"description":"Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.","type":"object","additionalProperties":false,"properties":{"assetModuleFilename":{"$ref":"#/definitions/AssetModuleFilename"},"asyncChunks":{"description":"Enable/disable creating async chunks that are loaded on demand.","type":"boolean"},"charset":{"$ref":"#/definitions/Charset"},"chunkFilename":{"$ref":"#/definitions/ChunkFilename"},"chunkFormat":{"$ref":"#/definitions/ChunkFormat"},"chunkLoadTimeout":{"$ref":"#/definitions/ChunkLoadTimeout"},"chunkLoading":{"$ref":"#/definitions/ChunkLoading"},"chunkLoadingGlobal":{"$ref":"#/definitions/ChunkLoadingGlobal"},"clean":{"$ref":"#/definitions/Clean"},"compareBeforeEmit":{"$ref":"#/definitions/CompareBeforeEmit"},"crossOriginLoading":{"$ref":"#/definitions/CrossOriginLoading"},"cssChunkFilename":{"$ref":"#/definitions/CssChunkFilename"},"cssFilename":{"$ref":"#/definitions/CssFilename"},"devtoolFallbackModuleFilenameTemplate":{"$ref":"#/definitions/DevtoolFallbackModuleFilenameTemplate"},"devtoolModuleFilenameTemplate":{"$ref":"#/definitions/DevtoolModuleFilenameTemplate"},"devtoolNamespace":{"$ref":"#/definitions/DevtoolNamespace"},"enabledChunkLoadingTypes":{"$ref":"#/definitions/EnabledChunkLoadingTypes"},"enabledLibraryTypes":{"$ref":"#/definitions/EnabledLibraryTypes"},"enabledWasmLoadingTypes":{"$ref":"#/definitions/EnabledWasmLoadingTypes"},"environment":{"$ref":"#/definitions/Environment"},"filename":{"$ref":"#/definitions/Filename"},"globalObject":{"$ref":"#/definitions/GlobalObject"},"hashDigest":{"$ref":"#/definitions/HashDigest"},"hashDigestLength":{"$ref":"#/definitions/HashDigestLength"},"hashFunction":{"$ref":"#/definitions/HashFunction"},"hashSalt":{"$ref":"#/definitions/HashSalt"},"hotUpdateChunkFilename":{"$ref":"#/definitions/HotUpdateChunkFilename"},"hotUpdateGlobal":{"$ref":"#/definitions/HotUpdateGlobal"},"hotUpdateMainFilename":{"$ref":"#/definitions/HotUpdateMainFilename"},"iife":{"$ref":"#/definitions/Iife"},"importFunctionName":{"$ref":"#/definitions/ImportFunctionName"},"importMetaName":{"$ref":"#/definitions/ImportMetaName"},"library":{"$ref":"#/definitions/LibraryOptions"},"module":{"$ref":"#/definitions/OutputModule"},"path":{"$ref":"#/definitions/Path"},"pathinfo":{"$ref":"#/definitions/Pathinfo"},"publicPath":{"$ref":"#/definitions/PublicPath"},"scriptType":{"$ref":"#/definitions/ScriptType"},"sourceMapFilename":{"$ref":"#/definitions/SourceMapFilename"},"sourcePrefix":{"$ref":"#/definitions/SourcePrefix"},"strictModuleErrorHandling":{"$ref":"#/definitions/StrictModuleErrorHandling"},"strictModuleExceptionHandling":{"$ref":"#/definitions/StrictModuleExceptionHandling"},"trustedTypes":{"$ref":"#/definitions/TrustedTypes"},"uniqueName":{"$ref":"#/definitions/UniqueName"},"wasmLoading":{"$ref":"#/definitions/WasmLoading"},"webassemblyModuleFilename":{"$ref":"#/definitions/WebassemblyModuleFilename"},"workerChunkLoading":{"$ref":"#/definitions/ChunkLoading"},"workerWasmLoading":{"$ref":"#/definitions/WasmLoading"}}},"Parallelism":{"description":"The number of parallel processed modules in the compilation.","type":"number","minimum":1},"ParserOptionsByModuleType":{"description":"Specify options for each parser.","type":"object","additionalProperties":{"description":"Options for parsing.","type":"object","additionalProperties":true},"properties":{"asset":{"$ref":"#/definitions/AssetParserOptions"},"asset/inline":{"$ref":"#/definitions/EmptyParserOptions"},"asset/resource":{"$ref":"#/definitions/EmptyParserOptions"},"asset/source":{"$ref":"#/definitions/EmptyParserOptions"},"javascript":{"$ref":"#/definitions/JavascriptParserOptions"},"javascript/auto":{"$ref":"#/definitions/JavascriptParserOptions"},"javascript/dynamic":{"$ref":"#/definitions/JavascriptParserOptions"},"javascript/esm":{"$ref":"#/definitions/JavascriptParserOptions"}}},"Path":{"description":"The output directory as **absolute path** (required).","type":"string","absolutePath":true},"Pathinfo":{"description":"Include comments with information about the modules.","anyOf":[{"enum":["verbose"]},{"type":"boolean"}]},"Performance":{"description":"Configuration for web performance recommendations.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/PerformanceOptions"}]},"PerformanceOptions":{"description":"Configuration object for web performance recommendations.","type":"object","additionalProperties":false,"properties":{"assetFilter":{"description":"Filter function to select assets that are checked.","instanceof":"Function","tsType":"Function"},"hints":{"description":"Sets the format of the hints: warnings, errors or nothing at all.","enum":[false,"warning","error"]},"maxAssetSize":{"description":"File size limit (in bytes) when exceeded, that webpack will provide performance hints.","type":"number"},"maxEntrypointSize":{"description":"Total size of an entry point (in bytes).","type":"number"}}},"Plugins":{"description":"Add additional plugins to the compiler.","type":"array","items":{"description":"Plugin of type object or instanceof Function.","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"Profile":{"description":"Capture timing information for each module.","type":"boolean"},"PublicPath":{"description":"The \'publicPath\' specifies the public URL address of the output files when referenced in a browser.","anyOf":[{"enum":["auto"]},{"$ref":"#/definitions/RawPublicPath"}]},"RawPublicPath":{"description":"The \'publicPath\' specifies the public URL address of the output files when referenced in a browser.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"((pathData: import(\\"../lib/Compilation\\").PathData, assetInfo?: import(\\"../lib/Compilation\\").AssetInfo) => string)"}]},"RecordsInputPath":{"description":"Store compiler state to a json file.","anyOf":[{"enum":[false]},{"type":"string","absolutePath":true}]},"RecordsOutputPath":{"description":"Load compiler state from a json file.","anyOf":[{"enum":[false]},{"type":"string","absolutePath":true}]},"RecordsPath":{"description":"Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.","anyOf":[{"enum":[false]},{"type":"string","absolutePath":true}]},"Resolve":{"description":"Options for the resolver.","oneOf":[{"$ref":"#/definitions/ResolveOptions"}]},"ResolveAlias":{"description":"Redirect module requests.","anyOf":[{"type":"array","items":{"description":"Alias configuration.","type":"object","additionalProperties":false,"properties":{"alias":{"description":"New request.","anyOf":[{"description":"Multiple alternative requests.","type":"array","items":{"description":"One choice of request.","type":"string","minLength":1}},{"description":"Ignore request (replace with empty module).","enum":[false]},{"description":"New request.","type":"string","minLength":1}]},"name":{"description":"Request to be redirected.","type":"string"},"onlyModule":{"description":"Redirect only exact matching request.","type":"boolean"}},"required":["alias","name"]}},{"type":"object","additionalProperties":{"description":"New request.","anyOf":[{"description":"Multiple alternative requests.","type":"array","items":{"description":"One choice of request.","type":"string","minLength":1}},{"description":"Ignore request (replace with empty module).","enum":[false]},{"description":"New request.","type":"string","minLength":1}]}}]},"ResolveLoader":{"description":"Options for the resolver when resolving loaders.","oneOf":[{"$ref":"#/definitions/ResolveOptions"}]},"ResolveOptions":{"description":"Options object for resolving requests.","type":"object","additionalProperties":false,"properties":{"alias":{"$ref":"#/definitions/ResolveAlias"},"aliasFields":{"description":"Fields in the description file (usually package.json) which are used to redirect requests inside the module.","type":"array","items":{"description":"Field in the description file (usually package.json) which are used to redirect requests inside the module.","anyOf":[{"type":"array","items":{"description":"Part of the field path in the description file (usually package.json) which are used to redirect requests inside the module.","type":"string","minLength":1}},{"type":"string","minLength":1}]}},"byDependency":{"description":"Extra resolve options per dependency category. Typical categories are \\"commonjs\\", \\"amd\\", \\"esm\\".","type":"object","additionalProperties":{"description":"Options object for resolving requests.","oneOf":[{"$ref":"#/definitions/ResolveOptions"}]}},"cache":{"description":"Enable caching of successfully resolved requests (cache entries are revalidated).","type":"boolean"},"cachePredicate":{"description":"Predicate function to decide which requests should be cached.","instanceof":"Function","tsType":"((request: import(\'enhanced-resolve\').ResolveRequest) => boolean)"},"cacheWithContext":{"description":"Include the context information in the cache identifier when caching.","type":"boolean"},"conditionNames":{"description":"Condition names for exports field entry point.","type":"array","items":{"description":"Condition names for exports field entry point.","type":"string"}},"descriptionFiles":{"description":"Filenames used to find a description file (like a package.json).","type":"array","items":{"description":"Filename used to find a description file (like a package.json).","type":"string","minLength":1}},"enforceExtension":{"description":"Enforce the resolver to use one of the extensions from the extensions option (User must specify requests without extension).","type":"boolean"},"exportsFields":{"description":"Field names from the description file (usually package.json) which are used to provide entry points of a package.","type":"array","items":{"description":"Field name from the description file (usually package.json) which is used to provide entry points of a package.","type":"string"}},"extensionAlias":{"description":"An object which maps extension to extension aliases.","type":"object","additionalProperties":{"description":"Extension alias.","anyOf":[{"description":"Multiple extensions.","type":"array","items":{"description":"Aliased extension.","type":"string","minLength":1}},{"description":"Aliased extension.","type":"string","minLength":1}]}},"extensions":{"description":"Extensions added to the request when trying to find the file.","type":"array","items":{"description":"Extension added to the request when trying to find the file.","type":"string"}},"fallback":{"description":"Redirect module requests when normal resolving fails.","oneOf":[{"$ref":"#/definitions/ResolveAlias"}]},"fileSystem":{"description":"Filesystem for the resolver.","tsType":"(import(\'../lib/util/fs\').InputFileSystem)"},"fullySpecified":{"description":"Treats the request specified by the user as fully specified, meaning no extensions are added and the mainFiles in directories are not resolved (This doesn\'t affect requests from mainFields, aliasFields or aliases).","type":"boolean"},"importsFields":{"description":"Field names from the description file (usually package.json) which are used to provide internal request of a package (requests starting with # are considered as internal).","type":"array","items":{"description":"Field name from the description file (usually package.json) which is used to provide internal request of a package (requests starting with # are considered as internal).","type":"string"}},"mainFields":{"description":"Field names from the description file (package.json) which are used to find the default entry point.","type":"array","items":{"description":"Field name from the description file (package.json) which are used to find the default entry point.","anyOf":[{"type":"array","items":{"description":"Part of the field path from the description file (package.json) which are used to find the default entry point.","type":"string","minLength":1}},{"type":"string","minLength":1}]}},"mainFiles":{"description":"Filenames used to find the default entry point if there is no description file or main field.","type":"array","items":{"description":"Filename used to find the default entry point if there is no description file or main field.","type":"string","minLength":1}},"modules":{"description":"Folder names or directory paths where to find modules.","type":"array","items":{"description":"Folder name or directory path where to find modules.","type":"string","minLength":1}},"plugins":{"description":"Plugins for the resolver.","type":"array","cli":{"exclude":true},"items":{"description":"Plugin of type object or instanceof Function.","anyOf":[{"enum":["..."]},{"$ref":"#/definitions/ResolvePluginInstance"}]}},"preferAbsolute":{"description":"Prefer to resolve server-relative URLs (starting with \'/\') as absolute paths before falling back to resolve in \'resolve.roots\'.","type":"boolean"},"preferRelative":{"description":"Prefer to resolve module requests as relative request and fallback to resolving as module.","type":"boolean"},"resolver":{"description":"Custom resolver.","tsType":"(import(\'enhanced-resolve\').Resolver)"},"restrictions":{"description":"A list of resolve restrictions. Resolve results must fulfill all of these restrictions to resolve successfully. Other resolve paths are taken when restrictions are not met.","type":"array","items":{"description":"Resolve restriction. Resolve result must fulfill this restriction.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":true,"minLength":1}]}},"roots":{"description":"A list of directories in which requests that are server-relative URLs (starting with \'/\') are resolved.","type":"array","items":{"description":"Directory in which requests that are server-relative URLs (starting with \'/\') are resolved.","type":"string"}},"symlinks":{"description":"Enable resolving symlinks to the original location.","type":"boolean"},"unsafeCache":{"description":"Enable caching of successfully resolved requests (cache entries are not revalidated).","anyOf":[{"type":"boolean"},{"type":"object","additionalProperties":true}]},"useSyncFileSystemCalls":{"description":"Use synchronous filesystem calls for the resolver.","type":"boolean"}}},"ResolvePluginInstance":{"description":"Plugin instance.","type":"object","additionalProperties":true,"properties":{"apply":{"description":"The run point of the plugin, required method.","instanceof":"Function","tsType":"(resolver: import(\'enhanced-resolve\').Resolver) => void"}},"required":["apply"]},"RuleSetCondition":{"description":"A condition matcher.","cli":{"helper":true},"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"((value: string) => boolean)"},{"$ref":"#/definitions/RuleSetLogicalConditions"},{"$ref":"#/definitions/RuleSetConditions"}]},"RuleSetConditionAbsolute":{"description":"A condition matcher matching an absolute path.","cli":{"helper":true},"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":true},{"instanceof":"Function","tsType":"((value: string) => boolean)"},{"$ref":"#/definitions/RuleSetLogicalConditionsAbsolute"},{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"RuleSetConditionOrConditions":{"description":"One or multiple rule conditions.","cli":{"helper":true},"anyOf":[{"$ref":"#/definitions/RuleSetCondition"},{"$ref":"#/definitions/RuleSetConditions"}]},"RuleSetConditionOrConditionsAbsolute":{"description":"One or multiple rule conditions matching an absolute path.","cli":{"helper":true},"anyOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"},{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"RuleSetConditions":{"description":"A list of rule conditions.","type":"array","items":{"description":"A rule condition.","oneOf":[{"$ref":"#/definitions/RuleSetCondition"}]}},"RuleSetConditionsAbsolute":{"description":"A list of rule conditions matching an absolute path.","type":"array","items":{"description":"A rule condition matching an absolute path.","oneOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"}]}},"RuleSetLoader":{"description":"A loader request.","type":"string","minLength":1},"RuleSetLoaderOptions":{"description":"Options passed to a loader.","anyOf":[{"type":"string"},{"type":"object"}]},"RuleSetLogicalConditions":{"description":"Logic operators used in a condition matcher.","type":"object","additionalProperties":false,"properties":{"and":{"description":"Logical AND.","oneOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"not":{"description":"Logical NOT.","oneOf":[{"$ref":"#/definitions/RuleSetCondition"}]},"or":{"description":"Logical OR.","oneOf":[{"$ref":"#/definitions/RuleSetConditions"}]}}},"RuleSetLogicalConditionsAbsolute":{"description":"Logic operators used in a condition matcher.","type":"object","additionalProperties":false,"properties":{"and":{"description":"Logical AND.","oneOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"not":{"description":"Logical NOT.","oneOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"}]},"or":{"description":"Logical OR.","oneOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]}}},"RuleSetRule":{"description":"A rule description with conditions and effects for modules.","type":"object","additionalProperties":false,"properties":{"assert":{"description":"Match on import assertions of the dependency.","type":"object","additionalProperties":{"$ref":"#/definitions/RuleSetConditionOrConditions"}},"compiler":{"description":"Match the child compiler name.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"dependency":{"description":"Match dependency type.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"descriptionData":{"description":"Match values of properties in the description file (usually package.json).","type":"object","additionalProperties":{"$ref":"#/definitions/RuleSetConditionOrConditions"}},"enforce":{"description":"Enforce this rule as pre or post step.","enum":["pre","post"]},"exclude":{"description":"Shortcut for resource.exclude.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"generator":{"description":"The options for the module generator.","type":"object"},"include":{"description":"Shortcut for resource.include.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"issuer":{"description":"Match the issuer of the module (The module pointing to this module).","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"issuerLayer":{"description":"Match layer of the issuer of this module (The module pointing to this module).","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"layer":{"description":"Specifies the layer in which the module should be placed in.","type":"string"},"loader":{"description":"Shortcut for use.loader.","oneOf":[{"$ref":"#/definitions/RuleSetLoader"}]},"mimetype":{"description":"Match module mimetype when load from Data URI.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"oneOf":{"description":"Only execute the first matching rule in this array.","type":"array","items":{"description":"A rule.","oneOf":[{"$ref":"#/definitions/RuleSetRule"}]}},"options":{"description":"Shortcut for use.options.","cli":{"exclude":true},"oneOf":[{"$ref":"#/definitions/RuleSetLoaderOptions"}]},"parser":{"description":"Options for parsing.","type":"object","additionalProperties":true},"realResource":{"description":"Match the real resource path of the module.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"resolve":{"description":"Options for the resolver.","type":"object","oneOf":[{"$ref":"#/definitions/ResolveOptions"}]},"resource":{"description":"Match the resource path of the module.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"resourceFragment":{"description":"Match the resource fragment of the module.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"resourceQuery":{"description":"Match the resource query of the module.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"rules":{"description":"Match and execute these rules when this rule is matched.","type":"array","items":{"description":"A rule.","oneOf":[{"$ref":"#/definitions/RuleSetRule"}]}},"scheme":{"description":"Match module scheme.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"sideEffects":{"description":"Flags a module as with or without side effects.","type":"boolean"},"test":{"description":"Shortcut for resource.test.","oneOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"type":{"description":"Module type to use for the module.","type":"string"},"use":{"description":"Modifiers applied to the module when rule is matched.","oneOf":[{"$ref":"#/definitions/RuleSetUse"}]}}},"RuleSetRules":{"description":"A list of rules.","type":"array","items":{"description":"A rule.","anyOf":[{"cli":{"exclude":true},"enum":["..."]},{"$ref":"#/definitions/RuleSetRule"}]}},"RuleSetUse":{"description":"A list of descriptions of loaders applied.","anyOf":[{"type":"array","items":{"description":"An use item.","oneOf":[{"$ref":"#/definitions/RuleSetUseItem"}]}},{"instanceof":"Function","tsType":"((data: { resource: string, realResource: string, resourceQuery: string, issuer: string, compiler: string }) => RuleSetUseItem[])"},{"$ref":"#/definitions/RuleSetUseItem"}]},"RuleSetUseItem":{"description":"A description of an applied loader.","anyOf":[{"type":"object","additionalProperties":false,"properties":{"ident":{"description":"Unique loader options identifier.","type":"string"},"loader":{"description":"Loader name.","oneOf":[{"$ref":"#/definitions/RuleSetLoader"}]},"options":{"description":"Loader options.","oneOf":[{"$ref":"#/definitions/RuleSetLoaderOptions"}]}}},{"instanceof":"Function","tsType":"((data: object) => RuleSetUseItem|RuleSetUseItem[])"},{"$ref":"#/definitions/RuleSetLoader"}]},"ScriptType":{"description":"This option enables loading async chunks via a custom script type, such as script type=\\"module\\".","enum":[false,"text/javascript","module"]},"SnapshotOptions":{"description":"Options affecting how file system snapshots are created and validated.","type":"object","additionalProperties":false,"properties":{"buildDependencies":{"description":"Options for snapshotting build dependencies to determine if the whole cache need to be invalidated.","type":"object","additionalProperties":false,"properties":{"hash":{"description":"Use hashes of the content of the files/directories to determine invalidation.","type":"boolean"},"timestamp":{"description":"Use timestamps of the files/directories to determine invalidation.","type":"boolean"}}},"immutablePaths":{"description":"List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.","type":"array","items":{"description":"List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.","anyOf":[{"description":"A RegExp matching an immutable directory (usually a package manager cache directory, including the tailing slash)","instanceof":"RegExp","tsType":"RegExp"},{"description":"A path to an immutable directory (usually a package manager cache directory).","type":"string","absolutePath":true,"minLength":1}]}},"managedPaths":{"description":"List of paths that are managed by a package manager and can be trusted to not be modified otherwise.","type":"array","items":{"description":"List of paths that are managed by a package manager and can be trusted to not be modified otherwise.","anyOf":[{"description":"A RegExp matching a managed directory (usually a node_modules directory, including the tailing slash)","instanceof":"RegExp","tsType":"RegExp"},{"description":"A path to a managed directory (usually a node_modules directory).","type":"string","absolutePath":true,"minLength":1}]}},"module":{"description":"Options for snapshotting dependencies of modules to determine if they need to be built again.","type":"object","additionalProperties":false,"properties":{"hash":{"description":"Use hashes of the content of the files/directories to determine invalidation.","type":"boolean"},"timestamp":{"description":"Use timestamps of the files/directories to determine invalidation.","type":"boolean"}}},"resolve":{"description":"Options for snapshotting dependencies of request resolving to determine if requests need to be re-resolved.","type":"object","additionalProperties":false,"properties":{"hash":{"description":"Use hashes of the content of the files/directories to determine invalidation.","type":"boolean"},"timestamp":{"description":"Use timestamps of the files/directories to determine invalidation.","type":"boolean"}}},"resolveBuildDependencies":{"description":"Options for snapshotting the resolving of build dependencies to determine if the build dependencies need to be re-resolved.","type":"object","additionalProperties":false,"properties":{"hash":{"description":"Use hashes of the content of the files/directories to determine invalidation.","type":"boolean"},"timestamp":{"description":"Use timestamps of the files/directories to determine invalidation.","type":"boolean"}}}}},"SourceMapFilename":{"description":"The filename of the SourceMaps for the JavaScript files. They are inside the \'output.path\' directory.","type":"string","absolutePath":false},"SourcePrefix":{"description":"Prefixes every line of the source in the bundle with this string.","type":"string"},"StatsOptions":{"description":"Stats options object.","type":"object","additionalProperties":false,"properties":{"all":{"description":"Fallback value for stats options when an option is not defined (has precedence over local webpack defaults).","type":"boolean"},"assets":{"description":"Add assets information.","type":"boolean"},"assetsSort":{"description":"Sort the assets by that field.","type":"string"},"assetsSpace":{"description":"Space to display assets (groups will be collapsed to fit this space).","type":"number"},"builtAt":{"description":"Add built at time information.","type":"boolean"},"cached":{"description":"Add information about cached (not built) modules (deprecated: use \'cachedModules\' instead).","type":"boolean"},"cachedAssets":{"description":"Show cached assets (setting this to `false` only shows emitted files).","type":"boolean"},"cachedModules":{"description":"Add information about cached (not built) modules.","type":"boolean"},"children":{"description":"Add children information.","type":"boolean"},"chunkGroupAuxiliary":{"description":"Display auxiliary assets in chunk groups.","type":"boolean"},"chunkGroupChildren":{"description":"Display children of chunk groups.","type":"boolean"},"chunkGroupMaxAssets":{"description":"Limit of assets displayed in chunk groups.","type":"number"},"chunkGroups":{"description":"Display all chunk groups with the corresponding bundles.","type":"boolean"},"chunkModules":{"description":"Add built modules information to chunk information.","type":"boolean"},"chunkModulesSpace":{"description":"Space to display chunk modules (groups will be collapsed to fit this space, value is in number of modules/group).","type":"number"},"chunkOrigins":{"description":"Add the origins of chunks and chunk merging info.","type":"boolean"},"chunkRelations":{"description":"Add information about parent, children and sibling chunks to chunk information.","type":"boolean"},"chunks":{"description":"Add chunk information.","type":"boolean"},"chunksSort":{"description":"Sort the chunks by that field.","type":"string"},"colors":{"description":"Enables/Disables colorful output.","anyOf":[{"description":"Enables/Disables colorful output.","type":"boolean"},{"type":"object","additionalProperties":false,"properties":{"bold":{"description":"Custom color for bold text.","type":"string"},"cyan":{"description":"Custom color for cyan text.","type":"string"},"green":{"description":"Custom color for green text.","type":"string"},"magenta":{"description":"Custom color for magenta text.","type":"string"},"red":{"description":"Custom color for red text.","type":"string"},"yellow":{"description":"Custom color for yellow text.","type":"string"}}}]},"context":{"description":"Context directory for request shortening.","type":"string","absolutePath":true},"dependentModules":{"description":"Show chunk modules that are dependencies of other modules of the chunk.","type":"boolean"},"depth":{"description":"Add module depth in module graph.","type":"boolean"},"entrypoints":{"description":"Display the entry points with the corresponding bundles.","anyOf":[{"enum":["auto"]},{"type":"boolean"}]},"env":{"description":"Add --env information.","type":"boolean"},"errorDetails":{"description":"Add details to errors (like resolving log).","anyOf":[{"enum":["auto"]},{"type":"boolean"}]},"errorStack":{"description":"Add internal stack trace to errors.","type":"boolean"},"errors":{"description":"Add errors.","type":"boolean"},"errorsCount":{"description":"Add errors count.","type":"boolean"},"exclude":{"description":"Please use excludeModules instead.","cli":{"exclude":true},"anyOf":[{"type":"boolean"},{"$ref":"#/definitions/ModuleFilterTypes"}]},"excludeAssets":{"description":"Suppress assets that match the specified filters. Filters can be Strings, RegExps or Functions.","oneOf":[{"$ref":"#/definitions/AssetFilterTypes"}]},"excludeModules":{"description":"Suppress modules that match the specified filters. Filters can be Strings, RegExps, Booleans or Functions.","anyOf":[{"type":"boolean"},{"$ref":"#/definitions/ModuleFilterTypes"}]},"groupAssetsByChunk":{"description":"Group assets by how their are related to chunks.","type":"boolean"},"groupAssetsByEmitStatus":{"description":"Group assets by their status (emitted, compared for emit or cached).","type":"boolean"},"groupAssetsByExtension":{"description":"Group assets by their extension.","type":"boolean"},"groupAssetsByInfo":{"description":"Group assets by their asset info (immutable, development, hotModuleReplacement, etc).","type":"boolean"},"groupAssetsByPath":{"description":"Group assets by their path.","type":"boolean"},"groupModulesByAttributes":{"description":"Group modules by their attributes (errors, warnings, assets, optional, orphan, or dependent).","type":"boolean"},"groupModulesByCacheStatus":{"description":"Group modules by their status (cached or built and cacheable).","type":"boolean"},"groupModulesByExtension":{"description":"Group modules by their extension.","type":"boolean"},"groupModulesByLayer":{"description":"Group modules by their layer.","type":"boolean"},"groupModulesByPath":{"description":"Group modules by their path.","type":"boolean"},"groupModulesByType":{"description":"Group modules by their type.","type":"boolean"},"groupReasonsByOrigin":{"description":"Group reasons by their origin module.","type":"boolean"},"hash":{"description":"Add the hash of the compilation.","type":"boolean"},"ids":{"description":"Add ids.","type":"boolean"},"logging":{"description":"Add logging output.","anyOf":[{"description":"Specify log level of logging output.","enum":["none","error","warn","info","log","verbose"]},{"description":"Enable/disable logging output (`true`: shows normal logging output, loglevel: log).","type":"boolean"}]},"loggingDebug":{"description":"Include debug logging of specified loggers (i. e. for plugins or loaders). Filters can be Strings, RegExps or Functions.","anyOf":[{"description":"Enable/Disable debug logging for all loggers.","type":"boolean"},{"$ref":"#/definitions/FilterTypes"}]},"loggingTrace":{"description":"Add stack traces to logging output.","type":"boolean"},"moduleAssets":{"description":"Add information about assets inside modules.","type":"boolean"},"moduleTrace":{"description":"Add dependencies and origin of warnings/errors.","type":"boolean"},"modules":{"description":"Add built modules information.","type":"boolean"},"modulesSort":{"description":"Sort the modules by that field.","type":"string"},"modulesSpace":{"description":"Space to display modules (groups will be collapsed to fit this space, value is in number of modules/groups).","type":"number"},"nestedModules":{"description":"Add information about modules nested in other modules (like with module concatenation).","type":"boolean"},"nestedModulesSpace":{"description":"Space to display modules nested within other modules (groups will be collapsed to fit this space, value is in number of modules/group).","type":"number"},"optimizationBailout":{"description":"Show reasons why optimization bailed out for modules.","type":"boolean"},"orphanModules":{"description":"Add information about orphan modules.","type":"boolean"},"outputPath":{"description":"Add output path information.","type":"boolean"},"performance":{"description":"Add performance hint flags.","type":"boolean"},"preset":{"description":"Preset for the default values.","anyOf":[{"type":"boolean"},{"type":"string"}]},"providedExports":{"description":"Show exports provided by modules.","type":"boolean"},"publicPath":{"description":"Add public path information.","type":"boolean"},"reasons":{"description":"Add information about the reasons why modules are included.","type":"boolean"},"reasonsSpace":{"description":"Space to display reasons (groups will be collapsed to fit this space).","type":"number"},"relatedAssets":{"description":"Add information about assets that are related to other assets (like SourceMaps for assets).","type":"boolean"},"runtime":{"description":"Add information about runtime modules (deprecated: use \'runtimeModules\' instead).","type":"boolean"},"runtimeModules":{"description":"Add information about runtime modules.","type":"boolean"},"source":{"description":"Add the source code of modules.","type":"boolean"},"timings":{"description":"Add timing information.","type":"boolean"},"usedExports":{"description":"Show exports used by modules.","type":"boolean"},"version":{"description":"Add webpack version information.","type":"boolean"},"warnings":{"description":"Add warnings.","type":"boolean"},"warningsCount":{"description":"Add warnings count.","type":"boolean"},"warningsFilter":{"description":"Suppress listing warnings that match the specified filters (they will still be counted). Filters can be Strings, RegExps or Functions.","oneOf":[{"$ref":"#/definitions/WarningFilterTypes"}]}}},"StatsValue":{"description":"Stats options object or preset name.","anyOf":[{"enum":["none","summary","errors-only","errors-warnings","minimal","normal","detailed","verbose"]},{"type":"boolean"},{"$ref":"#/definitions/StatsOptions"}]},"StrictModuleErrorHandling":{"description":"Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.","type":"boolean"},"StrictModuleExceptionHandling":{"description":"Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.","type":"boolean"},"Target":{"description":"Environment to build for. An array of environments to build for all of them when possible.","anyOf":[{"type":"array","items":{"description":"Environment to build for.","type":"string","minLength":1},"minItems":1},{"enum":[false]},{"type":"string","minLength":1}]},"TrustedTypes":{"description":"Use a Trusted Types policy to create urls for chunks.","type":"object","additionalProperties":false,"properties":{"policyName":{"description":"The name of the Trusted Types policy created by webpack to serve bundle chunks.","type":"string","minLength":1}}},"UmdNamedDefine":{"description":"If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.","type":"boolean"},"UniqueName":{"description":"A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.","type":"string","minLength":1},"WarningFilterItemTypes":{"description":"Filtering value, regexp or function.","cli":{"helper":true},"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"((warning: import(\'../lib/stats/DefaultStatsFactoryPlugin\').StatsError, value: string) => boolean)"}]},"WarningFilterTypes":{"description":"Filtering warnings.","cli":{"helper":true},"anyOf":[{"type":"array","items":{"description":"Rule to filter.","cli":{"helper":true},"oneOf":[{"$ref":"#/definitions/WarningFilterItemTypes"}]}},{"$ref":"#/definitions/WarningFilterItemTypes"}]},"WasmLoading":{"description":"The method of loading WebAssembly Modules (methods included by default are \'fetch\' (web/WebWorker), \'async-node\' (node.js), but others might be added by plugins).","anyOf":[{"enum":[false]},{"$ref":"#/definitions/WasmLoadingType"}]},"WasmLoadingType":{"description":"The method of loading WebAssembly Modules (methods included by default are \'fetch\' (web/WebWorker), \'async-node\' (node.js), but others might be added by plugins).","anyOf":[{"enum":["fetch-streaming","fetch","async-node"]},{"type":"string"}]},"Watch":{"description":"Enter watch mode, which rebuilds on file change.","type":"boolean"},"WatchOptions":{"description":"Options for the watcher.","type":"object","additionalProperties":false,"properties":{"aggregateTimeout":{"description":"Delay the rebuilt after the first change. Value is a time in ms.","type":"number"},"followSymlinks":{"description":"Resolve symlinks and watch symlink and real file. This is usually not needed as webpack already resolves symlinks (\'resolve.symlinks\').","type":"boolean"},"ignored":{"description":"Ignore some files from watching (glob pattern or regexp).","anyOf":[{"type":"array","items":{"description":"A glob pattern for files that should be ignored from watching.","type":"string","minLength":1}},{"instanceof":"RegExp","tsType":"RegExp"},{"description":"A single glob pattern for files that should be ignored from watching.","type":"string","minLength":1}]},"poll":{"description":"Enable polling mode for watching.","anyOf":[{"description":"`number`: use polling with specified interval.","type":"number"},{"description":"`true`: use polling.","type":"boolean"}]},"stdin":{"description":"Stop watching when stdin stream has ended.","type":"boolean"}}},"WebassemblyModuleFilename":{"description":"The filename of WebAssembly modules as relative path inside the \'output.path\' directory.","type":"string","absolutePath":false},"WebpackOptionsNormalized":{"description":"Normalized webpack options object.","type":"object","additionalProperties":false,"properties":{"amd":{"$ref":"#/definitions/Amd"},"bail":{"$ref":"#/definitions/Bail"},"cache":{"$ref":"#/definitions/CacheOptionsNormalized"},"context":{"$ref":"#/definitions/Context"},"dependencies":{"$ref":"#/definitions/Dependencies"},"devServer":{"$ref":"#/definitions/DevServer"},"devtool":{"$ref":"#/definitions/DevTool"},"entry":{"$ref":"#/definitions/EntryNormalized"},"experiments":{"$ref":"#/definitions/ExperimentsNormalized"},"externals":{"$ref":"#/definitions/Externals"},"externalsPresets":{"$ref":"#/definitions/ExternalsPresets"},"externalsType":{"$ref":"#/definitions/ExternalsType"},"ignoreWarnings":{"$ref":"#/definitions/IgnoreWarningsNormalized"},"infrastructureLogging":{"$ref":"#/definitions/InfrastructureLogging"},"loader":{"$ref":"#/definitions/Loader"},"mode":{"$ref":"#/definitions/Mode"},"module":{"$ref":"#/definitions/ModuleOptionsNormalized"},"name":{"$ref":"#/definitions/Name"},"node":{"$ref":"#/definitions/Node"},"optimization":{"$ref":"#/definitions/Optimization"},"output":{"$ref":"#/definitions/OutputNormalized"},"parallelism":{"$ref":"#/definitions/Parallelism"},"performance":{"$ref":"#/definitions/Performance"},"plugins":{"$ref":"#/definitions/Plugins"},"profile":{"$ref":"#/definitions/Profile"},"recordsInputPath":{"$ref":"#/definitions/RecordsInputPath"},"recordsOutputPath":{"$ref":"#/definitions/RecordsOutputPath"},"resolve":{"$ref":"#/definitions/Resolve"},"resolveLoader":{"$ref":"#/definitions/ResolveLoader"},"snapshot":{"$ref":"#/definitions/SnapshotOptions"},"stats":{"$ref":"#/definitions/StatsValue"},"target":{"$ref":"#/definitions/Target"},"watch":{"$ref":"#/definitions/Watch"},"watchOptions":{"$ref":"#/definitions/WatchOptions"}},"required":["cache","snapshot","entry","experiments","externals","externalsPresets","infrastructureLogging","module","node","optimization","output","plugins","resolve","resolveLoader","stats","watchOptions"]},"WebpackPluginFunction":{"description":"Function acting as plugin.","instanceof":"Function","tsType":"(this: import(\'../lib/Compiler\'), compiler: import(\'../lib/Compiler\')) => void"},"WebpackPluginInstance":{"description":"Plugin instance.","type":"object","additionalProperties":true,"properties":{"apply":{"description":"The run point of the plugin, required method.","instanceof":"Function","tsType":"(compiler: import(\'../lib/Compiler\')) => void"}},"required":["apply"]}},"title":"WebpackOptions","description":"Options object as provided by the user.","type":"object","additionalProperties":false,"properties":{"amd":{"$ref":"#/definitions/Amd"},"bail":{"$ref":"#/definitions/Bail"},"cache":{"$ref":"#/definitions/CacheOptions"},"context":{"$ref":"#/definitions/Context"},"dependencies":{"$ref":"#/definitions/Dependencies"},"devServer":{"$ref":"#/definitions/DevServer"},"devtool":{"$ref":"#/definitions/DevTool"},"entry":{"$ref":"#/definitions/Entry"},"experiments":{"$ref":"#/definitions/Experiments"},"externals":{"$ref":"#/definitions/Externals"},"externalsPresets":{"$ref":"#/definitions/ExternalsPresets"},"externalsType":{"$ref":"#/definitions/ExternalsType"},"ignoreWarnings":{"$ref":"#/definitions/IgnoreWarnings"},"infrastructureLogging":{"$ref":"#/definitions/InfrastructureLogging"},"loader":{"$ref":"#/definitions/Loader"},"mode":{"$ref":"#/definitions/Mode"},"module":{"$ref":"#/definitions/ModuleOptions"},"name":{"$ref":"#/definitions/Name"},"node":{"$ref":"#/definitions/Node"},"optimization":{"$ref":"#/definitions/Optimization"},"output":{"$ref":"#/definitions/Output"},"parallelism":{"$ref":"#/definitions/Parallelism"},"performance":{"$ref":"#/definitions/Performance"},"plugins":{"$ref":"#/definitions/Plugins"},"profile":{"$ref":"#/definitions/Profile"},"recordsInputPath":{"$ref":"#/definitions/RecordsInputPath"},"recordsOutputPath":{"$ref":"#/definitions/RecordsOutputPath"},"recordsPath":{"$ref":"#/definitions/RecordsPath"},"resolve":{"$ref":"#/definitions/Resolve"},"resolveLoader":{"$ref":"#/definitions/ResolveLoader"},"snapshot":{"$ref":"#/definitions/SnapshotOptions"},"stats":{"$ref":"#/definitions/StatsValue"},"target":{"$ref":"#/definitions/Target"},"watch":{"$ref":"#/definitions/Watch"},"watchOptions":{"$ref":"#/definitions/WatchOptions"}}}');
},
87298: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"BannerFunction":{"description":"The banner as function, it will be wrapped in a comment.","instanceof":"Function","tsType":"(data: { hash: string, chunk: import(\'../../lib/Chunk\'), filename: string }) => string"},"Rule":{"description":"Filtering rule as regex or string.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"Rules":{"description":"Filtering rules.","anyOf":[{"type":"array","items":{"description":"A rule condition.","oneOf":[{"$ref":"#/definitions/Rule"}]}},{"$ref":"#/definitions/Rule"}]}},"title":"BannerPluginArgument","anyOf":[{"description":"The banner as string, it will be wrapped in a comment.","type":"string","minLength":1},{"title":"BannerPluginOptions","type":"object","additionalProperties":false,"properties":{"banner":{"description":"Specifies the banner.","anyOf":[{"type":"string"},{"$ref":"#/definitions/BannerFunction"}]},"entryOnly":{"description":"If true, the banner will only be added to the entry chunks.","type":"boolean"},"exclude":{"description":"Exclude all modules matching any of these conditions.","oneOf":[{"$ref":"#/definitions/Rules"}]},"footer":{"description":"If true, banner will be placed at the end of the output.","type":"boolean"},"include":{"description":"Include all modules matching any of these conditions.","oneOf":[{"$ref":"#/definitions/Rules"}]},"raw":{"description":"If true, banner will not be wrapped in a comment.","type":"boolean"},"test":{"description":"Include all modules that pass test assertion.","oneOf":[{"$ref":"#/definitions/Rules"}]}},"required":["banner"]},{"$ref":"#/definitions/BannerFunction"}]}');
},
28991: module => {
"use strict";
module.exports = JSON.parse('{"title":"DllPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"Context of requests in the manifest file (defaults to the webpack context).","type":"string","minLength":1},"entryOnly":{"description":"If true, only entry points will be exposed (default: true).","type":"boolean"},"format":{"description":"If true, manifest json file (output) will be formatted.","type":"boolean"},"name":{"description":"Name of the exposed dll function (external name, use value of \'output.library\').","type":"string","minLength":1},"path":{"description":"Absolute path to the manifest json file (output).","type":"string","minLength":1},"type":{"description":"Type of the dll bundle (external type, use value of \'output.libraryTarget\').","type":"string","minLength":1}},"required":["path"]}');
},
67138: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"DllReferencePluginOptionsContent":{"description":"The mappings from request to module info.","type":"object","additionalProperties":{"description":"Module info.","type":"object","additionalProperties":false,"properties":{"buildMeta":{"description":"Meta information about the module.","type":"object"},"exports":{"description":"Information about the provided exports of the module.","anyOf":[{"description":"List of provided exports of the module.","type":"array","items":{"description":"Name of the export.","type":"string","minLength":1}},{"description":"Exports unknown/dynamic.","enum":[true]}]},"id":{"description":"Module ID.","anyOf":[{"type":"number"},{"type":"string","minLength":1}]}},"required":["id"]},"minProperties":1},"DllReferencePluginOptionsManifest":{"description":"An object containing content, name and type.","type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info.","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"name":{"description":"The name where the dll is exposed (external name).","type":"string","minLength":1},"type":{"description":"The type how the dll is exposed (external type).","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]}},"required":["content"]},"DllReferencePluginOptionsSourceType":{"description":"The type how the dll is exposed (external type).","enum":["var","assign","this","window","global","commonjs","commonjs2","commonjs-module","amd","amd-require","umd","umd2","jsonp","system"]}},"title":"DllReferencePluginOptions","anyOf":[{"type":"object","additionalProperties":false,"properties":{"context":{"description":"Context of requests in the manifest (or content property) as absolute path.","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using \'scope\').","type":"array","items":{"description":"An extension.","type":"string"}},"manifest":{"description":"An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation.","anyOf":[{"type":"string","absolutePath":true},{"$ref":"#/definitions/DllReferencePluginOptionsManifest"}]},"name":{"description":"The name where the dll is exposed (external name, defaults to manifest.name).","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll.","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget, defaults to manifest.type).","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used.","enum":["require","object"]}},"required":["manifest"]},{"type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info.","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"context":{"description":"Context of requests in the manifest (or content property) as absolute path.","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using \'scope\').","type":"array","items":{"description":"An extension.","type":"string"}},"name":{"description":"The name where the dll is exposed (external name).","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll.","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget).","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used.","enum":["require","object"]}},"required":["content","name"]}]}');
},
39586: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"HashFunction":{"description":"Algorithm used for generation the hash (see node.js crypto package).","anyOf":[{"type":"string","minLength":1},{"instanceof":"Function","tsType":"typeof import(\'../../lib/util/Hash\')"}]}},"title":"HashedModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"The context directory for creating names.","type":"string","absolutePath":true},"hashDigest":{"description":"The encoding to use when generating the hash, defaults to \'base64\'. All encodings from Node.JS\' hash.digest are supported.","enum":["hex","latin1","base64"]},"hashDigestLength":{"description":"The prefix length of the hash digest to use, defaults to 4.","type":"number","minimum":1},"hashFunction":{"description":"The hashing algorithm to use, defaults to \'md4\'. All functions from Node.JS\' crypto.createHash are supported.","oneOf":[{"$ref":"#/definitions/HashFunction"}]}}}');
},
8679: module => {
"use strict";
module.exports = JSON.parse('{"title":"IgnorePluginOptions","anyOf":[{"type":"object","additionalProperties":false,"properties":{"contextRegExp":{"description":"A RegExp to test the context (directory) against.","instanceof":"RegExp","tsType":"RegExp"},"resourceRegExp":{"description":"A RegExp to test the request against.","instanceof":"RegExp","tsType":"RegExp"}},"required":["resourceRegExp"]},{"type":"object","additionalProperties":false,"properties":{"checkResource":{"description":"A filter function for resource and context.","instanceof":"Function","tsType":"((resource: string, context: string) => boolean)"}},"required":["checkResource"]}]}');
},
89408: module => {
"use strict";
module.exports = JSON.parse('{"title":"JsonModulesPluginParserOptions","type":"object","additionalProperties":false,"properties":{"parse":{"description":"Function that executes for a module source string and should return json-compatible data.","instanceof":"Function","tsType":"((input: string) => any)"}}}');
},
30685: module => {
"use strict";
module.exports = JSON.parse('{"title":"LoaderOptionsPluginOptions","type":"object","additionalProperties":true,"properties":{"debug":{"description":"Whether loaders should be in debug mode or not. debug will be removed as of webpack 3.","type":"boolean"},"minimize":{"description":"Where loaders can be switched to minimize mode.","type":"boolean"},"options":{"description":"A configuration object that can be used to configure older loaders.","type":"object","additionalProperties":true,"properties":{"context":{"description":"The context that can be used to configure older loaders.","type":"string","absolutePath":true}}}}}');
},
43691: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"HandlerFunction":{"description":"Function that executes for every progress step.","instanceof":"Function","tsType":"((percentage: number, msg: string, ...args: string[]) => void)"},"ProgressPluginOptions":{"description":"Options object for the ProgressPlugin.","type":"object","additionalProperties":false,"properties":{"activeModules":{"description":"Show active modules count and one active module in progress message.","type":"boolean"},"dependencies":{"description":"Show dependencies count in progress message.","type":"boolean"},"dependenciesCount":{"description":"Minimum dependencies count to start with. For better progress calculation. Default: 10000.","type":"number"},"entries":{"description":"Show entries count in progress message.","type":"boolean"},"handler":{"description":"Function that executes for every progress step.","oneOf":[{"$ref":"#/definitions/HandlerFunction"}]},"modules":{"description":"Show modules count in progress message.","type":"boolean"},"modulesCount":{"description":"Minimum modules count to start with. For better progress calculation. Default: 5000.","type":"number"},"percentBy":{"description":"Collect percent algorithm. By default it calculates by a median from modules, entries and dependencies percent.","enum":["entries","modules","dependencies",null]},"profile":{"description":"Collect profile data for progress steps. Default: false.","enum":[true,false,null]}}}},"title":"ProgressPluginArgument","anyOf":[{"$ref":"#/definitions/ProgressPluginOptions"},{"$ref":"#/definitions/HandlerFunction"}]}');
},
78061: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"rule":{"description":"Include source maps for modules based on their extension (defaults to .js and .css).","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"rules":{"description":"Include source maps for modules based on their extension (defaults to .js and .css).","anyOf":[{"type":"array","items":{"description":"A rule condition.","oneOf":[{"$ref":"#/definitions/rule"}]}},{"$ref":"#/definitions/rule"}]}},"title":"SourceMapDevToolPluginOptions","type":"object","additionalProperties":false,"properties":{"append":{"description":"Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending.","anyOf":[{"description":"Append no SourceMap comment to the bundle, but still generate SourceMaps.","enum":[false,null]},{"type":"string","minLength":1}]},"columns":{"description":"Indicates whether column mappings should be used (defaults to true).","type":"boolean"},"exclude":{"description":"Exclude modules that match the given value from source map generation.","oneOf":[{"$ref":"#/definitions/rules"}]},"fallbackModuleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the \'sources\' array in the SourceMap used only if \'moduleFilenameTemplate\' would result in a conflict.","anyOf":[{"type":"string","minLength":1},{"description":"Custom function generating the identifier.","instanceof":"Function","tsType":"Function"}]},"fileContext":{"description":"Path prefix to which the [file] placeholder is relative to.","type":"string"},"filename":{"description":"Defines the output filename of the SourceMap (will be inlined if no value is provided).","anyOf":[{"description":"Disable separate SourceMap file and inline SourceMap as DataUrl.","enum":[false,null]},{"type":"string","absolutePath":false,"minLength":1}]},"include":{"description":"Include source maps for module paths that match the given value.","oneOf":[{"$ref":"#/definitions/rules"}]},"module":{"description":"Indicates whether SourceMaps from loaders should be used (defaults to true).","type":"boolean"},"moduleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the \'sources\' array in the SourceMap.","anyOf":[{"type":"string","minLength":1},{"description":"Custom function generating the identifier.","instanceof":"Function","tsType":"Function"}]},"namespace":{"description":"Namespace prefix to allow multiple webpack roots in the devtools.","type":"string"},"noSources":{"description":"Omit the \'sourceContents\' array from the SourceMap.","type":"boolean"},"publicPath":{"description":"Provide a custom public path for the SourceMapping comment.","type":"string"},"sourceRoot":{"description":"Provide a custom value for the \'sourceRoot\' property in the SourceMap.","type":"string"},"test":{"$ref":"#/definitions/rules"}}}');
},
91014: module => {
"use strict";
module.exports = JSON.parse('{"title":"WatchIgnorePluginOptions","type":"object","additionalProperties":false,"properties":{"paths":{"description":"A list of RegExps or absolute paths to directories or files that should be ignored.","type":"array","items":{"description":"RegExp or absolute path to directories or files that should be ignored.","anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"}]},"minItems":1}},"required":["paths"]}');
},
93944: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"AuxiliaryComment":{"description":"Add a comment in the UMD wrapper.","anyOf":[{"description":"Append the same comment above each import style.","type":"string"},{"$ref":"#/definitions/LibraryCustomUmdCommentObject"}]},"EntryRuntime":{"description":"The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.","anyOf":[{"enum":[false]},{"type":"string","minLength":1}]},"Exposes":{"description":"Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.","anyOf":[{"type":"array","items":{"description":"Modules that should be exposed by this container.","anyOf":[{"$ref":"#/definitions/ExposesItem"},{"$ref":"#/definitions/ExposesObject"}]}},{"$ref":"#/definitions/ExposesObject"}]},"ExposesConfig":{"description":"Advanced configuration for modules that should be exposed by this container.","type":"object","additionalProperties":false,"properties":{"import":{"description":"Request to a module that should be exposed by this container.","anyOf":[{"$ref":"#/definitions/ExposesItem"},{"$ref":"#/definitions/ExposesItems"}]},"name":{"description":"Custom chunk name for the exposed module.","type":"string"}},"required":["import"]},"ExposesItem":{"description":"Module that should be exposed by this container.","type":"string","minLength":1},"ExposesItems":{"description":"Modules that should be exposed by this container.","type":"array","items":{"$ref":"#/definitions/ExposesItem"}},"ExposesObject":{"description":"Modules that should be exposed by this container. Property names are used as public paths.","type":"object","additionalProperties":{"description":"Modules that should be exposed by this container.","anyOf":[{"$ref":"#/definitions/ExposesConfig"},{"$ref":"#/definitions/ExposesItem"},{"$ref":"#/definitions/ExposesItems"}]}},"LibraryCustomUmdCommentObject":{"description":"Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set comment for `amd` section in UMD.","type":"string"},"commonjs":{"description":"Set comment for `commonjs` (exports) section in UMD.","type":"string"},"commonjs2":{"description":"Set comment for `commonjs2` (module.exports) section in UMD.","type":"string"},"root":{"description":"Set comment for `root` (global variable) section in UMD.","type":"string"}}},"LibraryCustomUmdObject":{"description":"Description object for all UMD variants of the library name.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Name of the exposed AMD library in the UMD.","type":"string","minLength":1},"commonjs":{"description":"Name of the exposed commonjs export in the UMD.","type":"string","minLength":1},"root":{"description":"Name of the property exposed globally by a UMD library.","anyOf":[{"type":"array","items":{"description":"Part of the name of the property exposed globally by a UMD library.","type":"string","minLength":1}},{"type":"string","minLength":1}]}}},"LibraryExport":{"description":"Specify which export should be exposed as library.","anyOf":[{"type":"array","items":{"description":"Part of the export that should be exposed as library.","type":"string","minLength":1}},{"type":"string","minLength":1}]},"LibraryName":{"description":"The name of the library (some types allow unnamed libraries too).","anyOf":[{"type":"array","items":{"description":"A part of the library name.","type":"string","minLength":1},"minItems":1},{"type":"string","minLength":1},{"$ref":"#/definitions/LibraryCustomUmdObject"}]},"LibraryOptions":{"description":"Options for library.","type":"object","additionalProperties":false,"properties":{"auxiliaryComment":{"$ref":"#/definitions/AuxiliaryComment"},"export":{"$ref":"#/definitions/LibraryExport"},"name":{"$ref":"#/definitions/LibraryName"},"type":{"$ref":"#/definitions/LibraryType"},"umdNamedDefine":{"$ref":"#/definitions/UmdNamedDefine"}},"required":["type"]},"LibraryType":{"description":"Type of library (types included by default are \'var\', \'module\', \'assign\', \'assign-properties\', \'this\', \'window\', \'self\', \'global\', \'commonjs\', \'commonjs2\', \'commonjs-module\', \'commonjs-static\', \'amd\', \'amd-require\', \'umd\', \'umd2\', \'jsonp\', \'system\', but others might be added by plugins).","anyOf":[{"enum":["var","module","assign","assign-properties","this","window","self","global","commonjs","commonjs2","commonjs-module","commonjs-static","amd","amd-require","umd","umd2","jsonp","system"]},{"type":"string"}]},"UmdNamedDefine":{"description":"If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.","type":"boolean"}},"title":"ContainerPluginOptions","type":"object","additionalProperties":false,"properties":{"exposes":{"$ref":"#/definitions/Exposes"},"filename":{"description":"The filename for this container relative path inside the `output.path` directory.","type":"string","absolutePath":false,"minLength":1},"library":{"$ref":"#/definitions/LibraryOptions"},"name":{"description":"The name for this container.","type":"string","minLength":1},"runtime":{"$ref":"#/definitions/EntryRuntime"},"shareScope":{"description":"The name of the share scope which is shared with the host (defaults to \'default\').","type":"string","minLength":1}},"required":["name","exposes"]}');
},
38279: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"ExternalsType":{"description":"Specifies the default type of externals (\'amd*\', \'umd*\', \'system\' and \'jsonp\' depend on output.libraryTarget set to the same value).","enum":["var","module","assign","this","window","self","global","commonjs","commonjs2","commonjs-module","commonjs-static","amd","amd-require","umd","umd2","jsonp","system","promise","import","script","node-commonjs"]},"Remotes":{"description":"Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.","anyOf":[{"type":"array","items":{"description":"Container locations and request scopes from which modules should be resolved and loaded at runtime.","anyOf":[{"$ref":"#/definitions/RemotesItem"},{"$ref":"#/definitions/RemotesObject"}]}},{"$ref":"#/definitions/RemotesObject"}]},"RemotesConfig":{"description":"Advanced configuration for container locations from which modules should be resolved and loaded at runtime.","type":"object","additionalProperties":false,"properties":{"external":{"description":"Container locations from which modules should be resolved and loaded at runtime.","anyOf":[{"$ref":"#/definitions/RemotesItem"},{"$ref":"#/definitions/RemotesItems"}]},"shareScope":{"description":"The name of the share scope shared with this remote.","type":"string","minLength":1}},"required":["external"]},"RemotesItem":{"description":"Container location from which modules should be resolved and loaded at runtime.","type":"string","minLength":1},"RemotesItems":{"description":"Container locations from which modules should be resolved and loaded at runtime.","type":"array","items":{"$ref":"#/definitions/RemotesItem"}},"RemotesObject":{"description":"Container locations from which modules should be resolved and loaded at runtime. Property names are used as request scopes.","type":"object","additionalProperties":{"description":"Container locations from which modules should be resolved and loaded at runtime.","anyOf":[{"$ref":"#/definitions/RemotesConfig"},{"$ref":"#/definitions/RemotesItem"},{"$ref":"#/definitions/RemotesItems"}]}}},"title":"ContainerReferencePluginOptions","type":"object","additionalProperties":false,"properties":{"remoteType":{"description":"The external type of the remote containers.","oneOf":[{"$ref":"#/definitions/ExternalsType"}]},"remotes":{"$ref":"#/definitions/Remotes"},"shareScope":{"description":"The name of the share scope shared with all remotes (defaults to \'default\').","type":"string","minLength":1}},"required":["remoteType","remotes"]}');
},
85195: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"AuxiliaryComment":{"description":"Add a comment in the UMD wrapper.","anyOf":[{"description":"Append the same comment above each import style.","type":"string"},{"$ref":"#/definitions/LibraryCustomUmdCommentObject"}]},"EntryRuntime":{"description":"The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.","anyOf":[{"enum":[false]},{"type":"string","minLength":1}]},"Exposes":{"description":"Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.","anyOf":[{"type":"array","items":{"description":"Modules that should be exposed by this container.","anyOf":[{"$ref":"#/definitions/ExposesItem"},{"$ref":"#/definitions/ExposesObject"}]}},{"$ref":"#/definitions/ExposesObject"}]},"ExposesConfig":{"description":"Advanced configuration for modules that should be exposed by this container.","type":"object","additionalProperties":false,"properties":{"import":{"description":"Request to a module that should be exposed by this container.","anyOf":[{"$ref":"#/definitions/ExposesItem"},{"$ref":"#/definitions/ExposesItems"}]},"name":{"description":"Custom chunk name for the exposed module.","type":"string"}},"required":["import"]},"ExposesItem":{"description":"Module that should be exposed by this container.","type":"string","minLength":1},"ExposesItems":{"description":"Modules that should be exposed by this container.","type":"array","items":{"$ref":"#/definitions/ExposesItem"}},"ExposesObject":{"description":"Modules that should be exposed by this container. Property names are used as public paths.","type":"object","additionalProperties":{"description":"Modules that should be exposed by this container.","anyOf":[{"$ref":"#/definitions/ExposesConfig"},{"$ref":"#/definitions/ExposesItem"},{"$ref":"#/definitions/ExposesItems"}]}},"ExternalsType":{"description":"Specifies the default type of externals (\'amd*\', \'umd*\', \'system\' and \'jsonp\' depend on output.libraryTarget set to the same value).","enum":["var","module","assign","this","window","self","global","commonjs","commonjs2","commonjs-module","commonjs-static","amd","amd-require","umd","umd2","jsonp","system","promise","import","script","node-commonjs"]},"LibraryCustomUmdCommentObject":{"description":"Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set comment for `amd` section in UMD.","type":"string"},"commonjs":{"description":"Set comment for `commonjs` (exports) section in UMD.","type":"string"},"commonjs2":{"description":"Set comment for `commonjs2` (module.exports) section in UMD.","type":"string"},"root":{"description":"Set comment for `root` (global variable) section in UMD.","type":"string"}}},"LibraryCustomUmdObject":{"description":"Description object for all UMD variants of the library name.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Name of the exposed AMD library in the UMD.","type":"string","minLength":1},"commonjs":{"description":"Name of the exposed commonjs export in the UMD.","type":"string","minLength":1},"root":{"description":"Name of the property exposed globally by a UMD library.","anyOf":[{"type":"array","items":{"description":"Part of the name of the property exposed globally by a UMD library.","type":"string","minLength":1}},{"type":"string","minLength":1}]}}},"LibraryExport":{"description":"Specify which export should be exposed as library.","anyOf":[{"type":"array","items":{"description":"Part of the export that should be exposed as library.","type":"string","minLength":1}},{"type":"string","minLength":1}]},"LibraryName":{"description":"The name of the library (some types allow unnamed libraries too).","anyOf":[{"type":"array","items":{"description":"A part of the library name.","type":"string","minLength":1},"minItems":1},{"type":"string","minLength":1},{"$ref":"#/definitions/LibraryCustomUmdObject"}]},"LibraryOptions":{"description":"Options for library.","type":"object","additionalProperties":false,"properties":{"auxiliaryComment":{"$ref":"#/definitions/AuxiliaryComment"},"export":{"$ref":"#/definitions/LibraryExport"},"name":{"$ref":"#/definitions/LibraryName"},"type":{"$ref":"#/definitions/LibraryType"},"umdNamedDefine":{"$ref":"#/definitions/UmdNamedDefine"}},"required":["type"]},"LibraryType":{"description":"Type of library (types included by default are \'var\', \'module\', \'assign\', \'assign-properties\', \'this\', \'window\', \'self\', \'global\', \'commonjs\', \'commonjs2\', \'commonjs-module\', \'commonjs-static\', \'amd\', \'amd-require\', \'umd\', \'umd2\', \'jsonp\', \'system\', but others might be added by plugins).","anyOf":[{"enum":["var","module","assign","assign-properties","this","window","self","global","commonjs","commonjs2","commonjs-module","commonjs-static","amd","amd-require","umd","umd2","jsonp","system"]},{"type":"string"}]},"Remotes":{"description":"Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.","anyOf":[{"type":"array","items":{"description":"Container locations and request scopes from which modules should be resolved and loaded at runtime.","anyOf":[{"$ref":"#/definitions/RemotesItem"},{"$ref":"#/definitions/RemotesObject"}]}},{"$ref":"#/definitions/RemotesObject"}]},"RemotesConfig":{"description":"Advanced configuration for container locations from which modules should be resolved and loaded at runtime.","type":"object","additionalProperties":false,"properties":{"external":{"description":"Container locations from which modules should be resolved and loaded at runtime.","anyOf":[{"$ref":"#/definitions/RemotesItem"},{"$ref":"#/definitions/RemotesItems"}]},"shareScope":{"description":"The name of the share scope shared with this remote.","type":"string","minLength":1}},"required":["external"]},"RemotesItem":{"description":"Container location from which modules should be resolved and loaded at runtime.","type":"string","minLength":1},"RemotesItems":{"description":"Container locations from which modules should be resolved and loaded at runtime.","type":"array","items":{"$ref":"#/definitions/RemotesItem"}},"RemotesObject":{"description":"Container locations from which modules should be resolved and loaded at runtime. Property names are used as request scopes.","type":"object","additionalProperties":{"description":"Container locations from which modules should be resolved and loaded at runtime.","anyOf":[{"$ref":"#/definitions/RemotesConfig"},{"$ref":"#/definitions/RemotesItem"},{"$ref":"#/definitions/RemotesItems"}]}},"Shared":{"description":"Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.","anyOf":[{"type":"array","items":{"description":"Modules that should be shared in the share scope.","anyOf":[{"$ref":"#/definitions/SharedItem"},{"$ref":"#/definitions/SharedObject"}]}},{"$ref":"#/definitions/SharedObject"}]},"SharedConfig":{"description":"Advanced configuration for modules that should be shared in the share scope.","type":"object","additionalProperties":false,"properties":{"eager":{"description":"Include the provided and fallback module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.","type":"boolean"},"import":{"description":"Provided module that should be provided to share scope. Also acts as fallback module if no shared module is found in share scope or version isn\'t valid. Defaults to the property name.","anyOf":[{"description":"No provided or fallback module.","enum":[false]},{"$ref":"#/definitions/SharedItem"}]},"packageName":{"description":"Package name to determine required version from description file. This is only needed when package name can\'t be automatically determined from request.","type":"string","minLength":1},"requiredVersion":{"description":"Version requirement from module in share scope.","anyOf":[{"description":"No version requirement check.","enum":[false]},{"description":"Version as string. Can be prefixed with \'^\' or \'~\' for minimum matches. Each part of the version should be separated by a dot \'.\'.","type":"string"}]},"shareKey":{"description":"Module is looked up under this key from the share scope.","type":"string","minLength":1},"shareScope":{"description":"Share scope name.","type":"string","minLength":1},"singleton":{"description":"Allow only a single version of the shared module in share scope (disabled by default).","type":"boolean"},"strictVersion":{"description":"Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).","type":"boolean"},"version":{"description":"Version of the provided module. Will replace lower matching versions, but not higher.","anyOf":[{"description":"Don\'t provide a version.","enum":[false]},{"description":"Version as string. Each part of the version should be separated by a dot \'.\'.","type":"string"}]}}},"SharedItem":{"description":"A module that should be shared in the share scope.","type":"string","minLength":1},"SharedObject":{"description":"Modules that should be shared in the share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.","type":"object","additionalProperties":{"description":"Modules that should be shared in the share scope.","anyOf":[{"$ref":"#/definitions/SharedConfig"},{"$ref":"#/definitions/SharedItem"}]}},"UmdNamedDefine":{"description":"If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.","type":"boolean"}},"title":"ModuleFederationPluginOptions","type":"object","additionalProperties":false,"properties":{"exposes":{"$ref":"#/definitions/Exposes"},"filename":{"description":"The filename of the container as relative path inside the `output.path` directory.","type":"string","absolutePath":false},"library":{"$ref":"#/definitions/LibraryOptions"},"name":{"description":"The name of the container.","type":"string"},"remoteType":{"description":"The external type of the remote containers.","oneOf":[{"$ref":"#/definitions/ExternalsType"}]},"remotes":{"$ref":"#/definitions/Remotes"},"runtime":{"$ref":"#/definitions/EntryRuntime"},"shareScope":{"description":"Share scope name used for all shared modules (defaults to \'default\').","type":"string","minLength":1},"shared":{"$ref":"#/definitions/Shared"}}}');
},
78555: module => {
"use strict";
module.exports = JSON.parse('{"title":"ProfilingPluginOptions","type":"object","additionalProperties":false,"properties":{"outputPath":{"description":"Path to the output file e.g. `path.resolve(__dirname, \'profiling/events.json\')`. Defaults to `events.json`.","type":"string","absolutePath":true}}}');
},
9659: module => {
"use strict";
module.exports = JSON.parse('{"title":"OccurrenceChunkIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size.","type":"boolean"}}}');
},
37931: module => {
"use strict";
module.exports = JSON.parse('{"title":"OccurrenceModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size.","type":"boolean"}}}');
},
3484: module => {
"use strict";
module.exports = JSON.parse('{"title":"AggressiveSplittingPluginOptions","type":"object","additionalProperties":false,"properties":{"chunkOverhead":{"description":"Extra cost for each chunk (Default: 9.8kiB).","type":"number"},"entryChunkMultiplicator":{"description":"Extra cost multiplicator for entry chunks (Default: 10).","type":"number"},"maxSize":{"description":"Byte, max size of per file (Default: 50kiB).","type":"number"},"minSize":{"description":"Byte, split point. (Default: 30kiB).","type":"number"}}}');
},
10692: module => {
"use strict";
module.exports = JSON.parse('{"title":"LimitChunkCountPluginOptions","type":"object","additionalProperties":false,"properties":{"chunkOverhead":{"description":"Constant overhead for a chunk.","type":"number"},"entryChunkMultiplicator":{"description":"Multiplicator for initial chunks.","type":"number"},"maxChunks":{"description":"Limit the maximum number of chunks using a value greater greater than or equal to 1.","type":"number","minimum":1}},"required":["maxChunks"]}');
},
84638: module => {
"use strict";
module.exports = JSON.parse('{"title":"MinChunkSizePluginOptions","type":"object","additionalProperties":false,"properties":{"chunkOverhead":{"description":"Constant overhead for a chunk.","type":"number"},"entryChunkMultiplicator":{"description":"Multiplicator for initial chunks.","type":"number"},"minChunkSize":{"description":"Minimum number of characters.","type":"number"}},"required":["minChunkSize"]}');
},
5404: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"HttpUriOptions":{"description":"Options for building http resources.","type":"object","additionalProperties":false,"properties":{"allowedUris":{"$ref":"#/definitions/HttpUriOptionsAllowedUris"},"cacheLocation":{"description":"Location where resource content is stored for lockfile entries. It\'s also possible to disable storing by passing false.","anyOf":[{"enum":[false]},{"type":"string","absolutePath":true}]},"frozen":{"description":"When set, anything that would lead to a modification of the lockfile or any resource content, will result in an error.","type":"boolean"},"lockfileLocation":{"description":"Location of the lockfile.","type":"string","absolutePath":true},"proxy":{"description":"Proxy configuration, which can be used to specify a proxy server to use for HTTP requests.","type":"string"},"upgrade":{"description":"When set, resources of existing lockfile entries will be fetched and entries will be upgraded when resource content has changed.","type":"boolean"}},"required":["allowedUris"]},"HttpUriOptionsAllowedUris":{"description":"List of allowed URIs (resp. the beginning of them).","type":"array","items":{"description":"List of allowed URIs (resp. the beginning of them).","anyOf":[{"description":"Allowed URI pattern.","instanceof":"RegExp","tsType":"RegExp"},{"description":"Allowed URI (resp. the beginning of it).","type":"string","pattern":"^https?://"},{"description":"Allowed URI filter function.","instanceof":"Function","tsType":"((uri: string) => boolean)"}]}}},"title":"HttpUriPluginOptions","oneOf":[{"$ref":"#/definitions/HttpUriOptions"}]}');
},
52021: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"Consumes":{"description":"Modules that should be consumed from share scope. When provided, property names are used to match requested modules in this compilation.","anyOf":[{"type":"array","items":{"description":"Modules that should be consumed from share scope.","anyOf":[{"$ref":"#/definitions/ConsumesItem"},{"$ref":"#/definitions/ConsumesObject"}]}},{"$ref":"#/definitions/ConsumesObject"}]},"ConsumesConfig":{"description":"Advanced configuration for modules that should be consumed from share scope.","type":"object","additionalProperties":false,"properties":{"eager":{"description":"Include the fallback module directly instead behind an async request. This allows to use fallback module in initial load too. All possible shared modules need to be eager too.","type":"boolean"},"import":{"description":"Fallback module if no shared module is found in share scope. Defaults to the property name.","anyOf":[{"description":"No fallback module.","enum":[false]},{"$ref":"#/definitions/ConsumesItem"}]},"packageName":{"description":"Package name to determine required version from description file. This is only needed when package name can\'t be automatically determined from request.","type":"string","minLength":1},"requiredVersion":{"description":"Version requirement from module in share scope.","anyOf":[{"description":"No version requirement check.","enum":[false]},{"description":"Version as string. Can be prefixed with \'^\' or \'~\' for minimum matches. Each part of the version should be separated by a dot \'.\'.","type":"string"}]},"shareKey":{"description":"Module is looked up under this key from the share scope.","type":"string","minLength":1},"shareScope":{"description":"Share scope name.","type":"string","minLength":1},"singleton":{"description":"Allow only a single version of the shared module in share scope (disabled by default).","type":"boolean"},"strictVersion":{"description":"Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).","type":"boolean"}}},"ConsumesItem":{"description":"A module that should be consumed from share scope.","type":"string","minLength":1},"ConsumesObject":{"description":"Modules that should be consumed from share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.","type":"object","additionalProperties":{"description":"Modules that should be consumed from share scope.","anyOf":[{"$ref":"#/definitions/ConsumesConfig"},{"$ref":"#/definitions/ConsumesItem"}]}}},"title":"ConsumeSharedPluginOptions","description":"Options for consuming shared modules.","type":"object","additionalProperties":false,"properties":{"consumes":{"$ref":"#/definitions/Consumes"},"shareScope":{"description":"Share scope name used for all consumed modules (defaults to \'default\').","type":"string","minLength":1}},"required":["consumes"]}');
},
97295: module => {
"use strict";
module.exports = JSON.parse('{"definitions":{"Provides":{"description":"Modules that should be provided as shared modules to the share scope. When provided, property name is used to match modules, otherwise this is automatically inferred from share key.","anyOf":[{"type":"array","items":{"description":"Modules that should be provided as shared modules to the share scope.","anyOf":[{"$ref":"#/definitions/ProvidesItem"},{"$ref":"#/definitions/ProvidesObject"}]}},{"$ref":"#/definitions/ProvidesObject"}]},"ProvidesConfig":{"description":"Advanced configuration for modules that should be provided as shared modules to the share scope.","type":"object","additionalProperties":false,"properties":{"eager":{"description":"Include the provided module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.","type":"boolean"},"shareKey":{"description":"Key in the share scope under which the shared modules should be stored.","type":"string","minLength":1},"shareScope":{"description":"Share scope name.","type":"string","minLength":1},"version":{"description":"Version of the provided module. Will replace lower matching versions, but not higher.","anyOf":[{"description":"Don\'t provide a version.","enum":[false]},{"description":"Version as string. Each part of the version should be separated by a dot \'.\'.","type":"string"}]}}},"ProvidesItem":{"description":"Request to a module that should be provided as shared module to the share scope (will be resolved when relative).","type":"string","minLength":1},"ProvidesObject":{"description":"Modules that should be provided as shared modules to the share scope. Property names are used as share keys.","type":"object","additionalProperties":{"description":"Modules that should be provided as shared modules to the share scope.","anyOf":[{"$ref":"#/definitions/ProvidesConfig"},{"$ref":"#/definitions/ProvidesItem"}]}}},"title":"ProvideSharedPluginOptions","type":"object","additionalProperties":false,"properties":{"provides":{"$ref":"#/definitions/Provides"},"shareScope":{"description":"Share scope name used for all provided modules (defaults to \'default\').","type":"string","minLength":1}},"required":["provides"]}');
}
}, __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
var cachedModule = __webpack_module_cache__[moduleId];
if (void 0 !== cachedModule) return cachedModule.exports;
var module = __webpack_module_cache__[moduleId] = {
id: moduleId,
loaded: !1,
exports: {}
};
return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
module.loaded = !0, module.exports;
}
__webpack_require__.c = __webpack_module_cache__, __webpack_require__.d = (exports, definition) => {
for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
enumerable: !0,
get: definition[key]
});
}, __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), 
__webpack_require__.r = exports => {
"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
value: "Module"
}), Object.defineProperty(exports, "__esModule", {
value: !0
});
};
var __webpack_exports__ = __webpack_require__(91459);
module.exports = __webpack_exports__;
})();