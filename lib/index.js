module.exports = function(modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: !1,
      exports: {}
    };
    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
    module.l = !0, module.exports;
  }
  return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
  __webpack_require__.d = function(exports, name, getter) {
    __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
      enumerable: !0,
      get: getter
    });
  }, __webpack_require__.r = function(exports) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(exports, "__esModule", {
      value: !0
    });
  }, __webpack_require__.t = function(value, mode) {
    if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
    if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
    var ns = Object.create(null);
    if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
      enumerable: !0,
      value: value
    }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
      return value[key];
    }.bind(null, key));
    return ns;
  }, __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ? function() {
      return module.default;
    } : function() {
      return module;
    };
    return __webpack_require__.d(getter, "a", getter), getter;
  }, __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 161);
}([ function(module, exports, __webpack_require__) {
  "use strict";
  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.declare = function(builder) {
    return (api, options, dirname) => (api.assertVersion || (api = Object.assign(function(api) {
      let proto = null;
      "string" == typeof api.version && /^7\./.test(api.version) && (proto = Object.getPrototypeOf(api), 
      !proto || has(proto, "version") && has(proto, "transform") && has(proto, "template") && has(proto, "types") || (proto = null));
      return Object.assign({}, proto, api);
    }(api), {
      assertVersion(range) {
        !function(range, version) {
          if ("number" == typeof range) {
            if (!Number.isInteger(range)) throw new Error("Expected string or integer value.");
            range = `^${range}.0.0-0`;
          }
          if ("string" != typeof range) throw new Error("Expected string or integer value.");
          const limit = Error.stackTraceLimit;
          "number" == typeof limit && limit < 25 && (Error.stackTraceLimit = 25);
          let err;
          err = "7." === version.slice(0, 2) ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          "number" == typeof limit && (Error.stackTraceLimit = limit);
          throw Object.assign(err, {
            code: "BABEL_VERSION_UNSUPPORTED",
            version: version,
            range: range
          });
        }(range, api.version);
      }
    })), builder(api, options || {}, dirname));
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var _exportNames = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toSequenceExpression: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0
  };
  Object.defineProperty(exports, "assertNode", {
    enumerable: !0,
    get: function() {
      return _assertNode.default;
    }
  }), Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: function() {
      return _createTypeAnnotationBasedOnTypeof.default;
    }
  }), Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return _createFlowUnionType.default;
    }
  }), Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: !0,
    get: function() {
      return _createFlowUnionType.default;
    }
  }), Object.defineProperty(exports, "createTSUnionType", {
    enumerable: !0,
    get: function() {
      return _createTSUnionType.default;
    }
  }), Object.defineProperty(exports, "cloneNode", {
    enumerable: !0,
    get: function() {
      return _cloneNode.default;
    }
  }), Object.defineProperty(exports, "clone", {
    enumerable: !0,
    get: function() {
      return _clone.default;
    }
  }), Object.defineProperty(exports, "cloneDeep", {
    enumerable: !0,
    get: function() {
      return _cloneDeep.default;
    }
  }), Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: function() {
      return _cloneDeepWithoutLoc.default;
    }
  }), Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: !0,
    get: function() {
      return _cloneWithoutLoc.default;
    }
  }), Object.defineProperty(exports, "addComment", {
    enumerable: !0,
    get: function() {
      return _addComment.default;
    }
  }), Object.defineProperty(exports, "addComments", {
    enumerable: !0,
    get: function() {
      return _addComments.default;
    }
  }), Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: !0,
    get: function() {
      return _inheritInnerComments.default;
    }
  }), Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: !0,
    get: function() {
      return _inheritLeadingComments.default;
    }
  }), Object.defineProperty(exports, "inheritsComments", {
    enumerable: !0,
    get: function() {
      return _inheritsComments.default;
    }
  }), Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: !0,
    get: function() {
      return _inheritTrailingComments.default;
    }
  }), Object.defineProperty(exports, "removeComments", {
    enumerable: !0,
    get: function() {
      return _removeComments.default;
    }
  }), Object.defineProperty(exports, "ensureBlock", {
    enumerable: !0,
    get: function() {
      return _ensureBlock.default;
    }
  }), Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: !0,
    get: function() {
      return _toBindingIdentifierName.default;
    }
  }), Object.defineProperty(exports, "toBlock", {
    enumerable: !0,
    get: function() {
      return _toBlock.default;
    }
  }), Object.defineProperty(exports, "toComputedKey", {
    enumerable: !0,
    get: function() {
      return _toComputedKey.default;
    }
  }), Object.defineProperty(exports, "toExpression", {
    enumerable: !0,
    get: function() {
      return _toExpression.default;
    }
  }), Object.defineProperty(exports, "toIdentifier", {
    enumerable: !0,
    get: function() {
      return _toIdentifier.default;
    }
  }), Object.defineProperty(exports, "toKeyAlias", {
    enumerable: !0,
    get: function() {
      return _toKeyAlias.default;
    }
  }), Object.defineProperty(exports, "toSequenceExpression", {
    enumerable: !0,
    get: function() {
      return _toSequenceExpression.default;
    }
  }), Object.defineProperty(exports, "toStatement", {
    enumerable: !0,
    get: function() {
      return _toStatement.default;
    }
  }), Object.defineProperty(exports, "valueToNode", {
    enumerable: !0,
    get: function() {
      return _valueToNode.default;
    }
  }), Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: !0,
    get: function() {
      return _appendToMemberExpression.default;
    }
  }), Object.defineProperty(exports, "inherits", {
    enumerable: !0,
    get: function() {
      return _inherits.default;
    }
  }), Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: !0,
    get: function() {
      return _prependToMemberExpression.default;
    }
  }), Object.defineProperty(exports, "removeProperties", {
    enumerable: !0,
    get: function() {
      return _removeProperties.default;
    }
  }), Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: !0,
    get: function() {
      return _removePropertiesDeep.default;
    }
  }), Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: !0,
    get: function() {
      return _removeTypeDuplicates.default;
    }
  }), Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: !0,
    get: function() {
      return _getBindingIdentifiers.default;
    }
  }), Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: function() {
      return _getOuterBindingIdentifiers.default;
    }
  }), Object.defineProperty(exports, "traverse", {
    enumerable: !0,
    get: function() {
      return _traverse.default;
    }
  }), Object.defineProperty(exports, "traverseFast", {
    enumerable: !0,
    get: function() {
      return _traverseFast.default;
    }
  }), Object.defineProperty(exports, "shallowEqual", {
    enumerable: !0,
    get: function() {
      return _shallowEqual.default;
    }
  }), Object.defineProperty(exports, "is", {
    enumerable: !0,
    get: function() {
      return _is.default;
    }
  }), Object.defineProperty(exports, "isBinding", {
    enumerable: !0,
    get: function() {
      return _isBinding.default;
    }
  }), Object.defineProperty(exports, "isBlockScoped", {
    enumerable: !0,
    get: function() {
      return _isBlockScoped.default;
    }
  }), Object.defineProperty(exports, "isImmutable", {
    enumerable: !0,
    get: function() {
      return _isImmutable.default;
    }
  }), Object.defineProperty(exports, "isLet", {
    enumerable: !0,
    get: function() {
      return _isLet.default;
    }
  }), Object.defineProperty(exports, "isNode", {
    enumerable: !0,
    get: function() {
      return _isNode.default;
    }
  }), Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: !0,
    get: function() {
      return _isNodesEquivalent.default;
    }
  }), Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: !0,
    get: function() {
      return _isPlaceholderType.default;
    }
  }), Object.defineProperty(exports, "isReferenced", {
    enumerable: !0,
    get: function() {
      return _isReferenced.default;
    }
  }), Object.defineProperty(exports, "isScope", {
    enumerable: !0,
    get: function() {
      return _isScope.default;
    }
  }), Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: !0,
    get: function() {
      return _isSpecifierDefault.default;
    }
  }), Object.defineProperty(exports, "isType", {
    enumerable: !0,
    get: function() {
      return _isType.default;
    }
  }), Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: !0,
    get: function() {
      return _isValidES3Identifier.default;
    }
  }), Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: !0,
    get: function() {
      return _isValidIdentifier.default;
    }
  }), Object.defineProperty(exports, "isVar", {
    enumerable: !0,
    get: function() {
      return _isVar.default;
    }
  }), Object.defineProperty(exports, "matchesPattern", {
    enumerable: !0,
    get: function() {
      return _matchesPattern.default;
    }
  }), Object.defineProperty(exports, "validate", {
    enumerable: !0,
    get: function() {
      return _validate.default;
    }
  }), Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: !0,
    get: function() {
      return _buildMatchMemberExpression.default;
    }
  }), exports.react = void 0;
  var _isReactComponent = _interopRequireDefault(__webpack_require__(180)), _isCompatTag = _interopRequireDefault(__webpack_require__(181)), _buildChildren = _interopRequireDefault(__webpack_require__(182)), _assertNode = _interopRequireDefault(__webpack_require__(259)), _generated = __webpack_require__(260);
  Object.keys(_generated).forEach((function(key) {
    "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _generated[key];
      }
    }));
  }));
  var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(__webpack_require__(261)), _createFlowUnionType = _interopRequireDefault(__webpack_require__(262)), _createTSUnionType = _interopRequireDefault(__webpack_require__(263)), _generated2 = __webpack_require__(4);
  Object.keys(_generated2).forEach((function(key) {
    "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _generated2[key];
      }
    }));
  }));
  var _cloneNode = _interopRequireDefault(__webpack_require__(17)), _clone = _interopRequireDefault(__webpack_require__(265)), _cloneDeep = _interopRequireDefault(__webpack_require__(266)), _cloneDeepWithoutLoc = _interopRequireDefault(__webpack_require__(267)), _cloneWithoutLoc = _interopRequireDefault(__webpack_require__(268)), _addComment = _interopRequireDefault(__webpack_require__(269)), _addComments = _interopRequireDefault(__webpack_require__(117)), _inheritInnerComments = _interopRequireDefault(__webpack_require__(118)), _inheritLeadingComments = _interopRequireDefault(__webpack_require__(119)), _inheritsComments = _interopRequireDefault(__webpack_require__(120)), _inheritTrailingComments = _interopRequireDefault(__webpack_require__(121)), _removeComments = _interopRequireDefault(__webpack_require__(270)), _generated3 = __webpack_require__(271);
  Object.keys(_generated3).forEach((function(key) {
    "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _generated3[key];
      }
    }));
  }));
  var _constants = __webpack_require__(16);
  Object.keys(_constants).forEach((function(key) {
    "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _constants[key];
      }
    }));
  }));
  var _ensureBlock = _interopRequireDefault(__webpack_require__(272)), _toBindingIdentifierName = _interopRequireDefault(__webpack_require__(273)), _toBlock = _interopRequireDefault(__webpack_require__(122)), _toComputedKey = _interopRequireDefault(__webpack_require__(274)), _toExpression = _interopRequireDefault(__webpack_require__(275)), _toIdentifier = _interopRequireDefault(__webpack_require__(123)), _toKeyAlias = _interopRequireDefault(__webpack_require__(276)), _toSequenceExpression = _interopRequireDefault(__webpack_require__(277)), _toStatement = _interopRequireDefault(__webpack_require__(279)), _valueToNode = _interopRequireDefault(__webpack_require__(280)), _definitions = __webpack_require__(5);
  Object.keys(_definitions).forEach((function(key) {
    "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _definitions[key];
      }
    }));
  }));
  var _appendToMemberExpression = _interopRequireDefault(__webpack_require__(284)), _inherits = _interopRequireDefault(__webpack_require__(285)), _prependToMemberExpression = _interopRequireDefault(__webpack_require__(286)), _removeProperties = _interopRequireDefault(__webpack_require__(126)), _removePropertiesDeep = _interopRequireDefault(__webpack_require__(124)), _removeTypeDuplicates = _interopRequireDefault(__webpack_require__(116)), _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(40)), _getOuterBindingIdentifiers = _interopRequireDefault(__webpack_require__(287)), _traverse = _interopRequireDefault(__webpack_require__(288)), _traverseFast = _interopRequireDefault(__webpack_require__(125)), _shallowEqual = _interopRequireDefault(__webpack_require__(55)), _is = _interopRequireDefault(__webpack_require__(26)), _isBinding = _interopRequireDefault(__webpack_require__(289)), _isBlockScoped = _interopRequireDefault(__webpack_require__(290)), _isImmutable = _interopRequireDefault(__webpack_require__(291)), _isLet = _interopRequireDefault(__webpack_require__(127)), _isNode = _interopRequireDefault(__webpack_require__(115)), _isNodesEquivalent = _interopRequireDefault(__webpack_require__(292)), _isPlaceholderType = _interopRequireDefault(__webpack_require__(113)), _isReferenced = _interopRequireDefault(__webpack_require__(293)), _isScope = _interopRequireDefault(__webpack_require__(294)), _isSpecifierDefault = _interopRequireDefault(__webpack_require__(295)), _isType = _interopRequireDefault(__webpack_require__(67)), _isValidES3Identifier = _interopRequireDefault(__webpack_require__(296)), _isValidIdentifier = _interopRequireDefault(__webpack_require__(27)), _isVar = _interopRequireDefault(__webpack_require__(297)), _matchesPattern = _interopRequireDefault(__webpack_require__(96)), _validate = _interopRequireDefault(__webpack_require__(69)), _buildMatchMemberExpression = _interopRequireDefault(__webpack_require__(95)), _generated4 = __webpack_require__(3);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  Object.keys(_generated4).forEach((function(key) {
    "default" !== key && "__esModule" !== key && (Object.prototype.hasOwnProperty.call(_exportNames, key) || Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _generated4[key];
      }
    }));
  }));
  const react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
  };
  exports.react = react;
}, function(module, exports) {
  module.exports = require("@babel/core");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.isArrayExpression = function(node, opts) {
    if (!node) return !1;
    if ("ArrayExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isAssignmentExpression = function(node, opts) {
    if (!node) return !1;
    if ("AssignmentExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBinaryExpression = function(node, opts) {
    if (!node) return !1;
    if ("BinaryExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isInterpreterDirective = function(node, opts) {
    if (!node) return !1;
    if ("InterpreterDirective" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDirective = function(node, opts) {
    if (!node) return !1;
    if ("Directive" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDirectiveLiteral = function(node, opts) {
    if (!node) return !1;
    if ("DirectiveLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBlockStatement = function(node, opts) {
    if (!node) return !1;
    if ("BlockStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBreakStatement = function(node, opts) {
    if (!node) return !1;
    if ("BreakStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isCallExpression = function(node, opts) {
    if (!node) return !1;
    if ("CallExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isCatchClause = function(node, opts) {
    if (!node) return !1;
    if ("CatchClause" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isConditionalExpression = function(node, opts) {
    if (!node) return !1;
    if ("ConditionalExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isContinueStatement = function(node, opts) {
    if (!node) return !1;
    if ("ContinueStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDebuggerStatement = function(node, opts) {
    if (!node) return !1;
    if ("DebuggerStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDoWhileStatement = function(node, opts) {
    if (!node) return !1;
    if ("DoWhileStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEmptyStatement = function(node, opts) {
    if (!node) return !1;
    if ("EmptyStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExpressionStatement = function(node, opts) {
    if (!node) return !1;
    if ("ExpressionStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFile = function(node, opts) {
    if (!node) return !1;
    if ("File" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isForInStatement = function(node, opts) {
    if (!node) return !1;
    if ("ForInStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isForStatement = function(node, opts) {
    if (!node) return !1;
    if ("ForStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFunctionDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("FunctionDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFunctionExpression = function(node, opts) {
    if (!node) return !1;
    if ("FunctionExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isIdentifier = function(node, opts) {
    if (!node) return !1;
    if ("Identifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isIfStatement = function(node, opts) {
    if (!node) return !1;
    if ("IfStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isLabeledStatement = function(node, opts) {
    if (!node) return !1;
    if ("LabeledStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isStringLiteral = function(node, opts) {
    if (!node) return !1;
    if ("StringLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNumericLiteral = function(node, opts) {
    if (!node) return !1;
    if ("NumericLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNullLiteral = function(node, opts) {
    if (!node) return !1;
    if ("NullLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBooleanLiteral = function(node, opts) {
    if (!node) return !1;
    if ("BooleanLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isRegExpLiteral = function(node, opts) {
    if (!node) return !1;
    if ("RegExpLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isLogicalExpression = function(node, opts) {
    if (!node) return !1;
    if ("LogicalExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isMemberExpression = function(node, opts) {
    if (!node) return !1;
    if ("MemberExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNewExpression = function(node, opts) {
    if (!node) return !1;
    if ("NewExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isProgram = function(node, opts) {
    if (!node) return !1;
    if ("Program" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectExpression = function(node, opts) {
    if (!node) return !1;
    if ("ObjectExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectMethod = function(node, opts) {
    if (!node) return !1;
    if ("ObjectMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectProperty = function(node, opts) {
    if (!node) return !1;
    if ("ObjectProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isRestElement = function(node, opts) {
    if (!node) return !1;
    if ("RestElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isReturnStatement = function(node, opts) {
    if (!node) return !1;
    if ("ReturnStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSequenceExpression = function(node, opts) {
    if (!node) return !1;
    if ("SequenceExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isParenthesizedExpression = function(node, opts) {
    if (!node) return !1;
    if ("ParenthesizedExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSwitchCase = function(node, opts) {
    if (!node) return !1;
    if ("SwitchCase" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSwitchStatement = function(node, opts) {
    if (!node) return !1;
    if ("SwitchStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isThisExpression = function(node, opts) {
    if (!node) return !1;
    if ("ThisExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isThrowStatement = function(node, opts) {
    if (!node) return !1;
    if ("ThrowStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTryStatement = function(node, opts) {
    if (!node) return !1;
    if ("TryStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isUnaryExpression = function(node, opts) {
    if (!node) return !1;
    if ("UnaryExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isUpdateExpression = function(node, opts) {
    if (!node) return !1;
    if ("UpdateExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isVariableDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("VariableDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isVariableDeclarator = function(node, opts) {
    if (!node) return !1;
    if ("VariableDeclarator" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isWhileStatement = function(node, opts) {
    if (!node) return !1;
    if ("WhileStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isWithStatement = function(node, opts) {
    if (!node) return !1;
    if ("WithStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isAssignmentPattern = function(node, opts) {
    if (!node) return !1;
    if ("AssignmentPattern" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isArrayPattern = function(node, opts) {
    if (!node) return !1;
    if ("ArrayPattern" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isArrowFunctionExpression = function(node, opts) {
    if (!node) return !1;
    if ("ArrowFunctionExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassBody = function(node, opts) {
    if (!node) return !1;
    if ("ClassBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassExpression = function(node, opts) {
    if (!node) return !1;
    if ("ClassExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("ClassDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportAllDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("ExportAllDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportDefaultDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("ExportDefaultDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportNamedDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("ExportNamedDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportSpecifier = function(node, opts) {
    if (!node) return !1;
    if ("ExportSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isForOfStatement = function(node, opts) {
    if (!node) return !1;
    if ("ForOfStatement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImportDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("ImportDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImportDefaultSpecifier = function(node, opts) {
    if (!node) return !1;
    if ("ImportDefaultSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImportNamespaceSpecifier = function(node, opts) {
    if (!node) return !1;
    if ("ImportNamespaceSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImportSpecifier = function(node, opts) {
    if (!node) return !1;
    if ("ImportSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isMetaProperty = function(node, opts) {
    if (!node) return !1;
    if ("MetaProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassMethod = function(node, opts) {
    if (!node) return !1;
    if ("ClassMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectPattern = function(node, opts) {
    if (!node) return !1;
    if ("ObjectPattern" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSpreadElement = function(node, opts) {
    if (!node) return !1;
    if ("SpreadElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSuper = function(node, opts) {
    if (!node) return !1;
    if ("Super" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTaggedTemplateExpression = function(node, opts) {
    if (!node) return !1;
    if ("TaggedTemplateExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTemplateElement = function(node, opts) {
    if (!node) return !1;
    if ("TemplateElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTemplateLiteral = function(node, opts) {
    if (!node) return !1;
    if ("TemplateLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isYieldExpression = function(node, opts) {
    if (!node) return !1;
    if ("YieldExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isAnyTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("AnyTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isArrayTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("ArrayTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBooleanTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("BooleanTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBooleanLiteralTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("BooleanLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNullLiteralTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("NullLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassImplements = function(node, opts) {
    if (!node) return !1;
    if ("ClassImplements" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareClass = function(node, opts) {
    if (!node) return !1;
    if ("DeclareClass" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareFunction = function(node, opts) {
    if (!node) return !1;
    if ("DeclareFunction" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareInterface = function(node, opts) {
    if (!node) return !1;
    if ("DeclareInterface" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareModule = function(node, opts) {
    if (!node) return !1;
    if ("DeclareModule" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareModuleExports = function(node, opts) {
    if (!node) return !1;
    if ("DeclareModuleExports" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareTypeAlias = function(node, opts) {
    if (!node) return !1;
    if ("DeclareTypeAlias" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareOpaqueType = function(node, opts) {
    if (!node) return !1;
    if ("DeclareOpaqueType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareVariable = function(node, opts) {
    if (!node) return !1;
    if ("DeclareVariable" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareExportDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("DeclareExportDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclareExportAllDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("DeclareExportAllDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclaredPredicate = function(node, opts) {
    if (!node) return !1;
    if ("DeclaredPredicate" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExistsTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("ExistsTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFunctionTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("FunctionTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFunctionTypeParam = function(node, opts) {
    if (!node) return !1;
    if ("FunctionTypeParam" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isGenericTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("GenericTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isInferredPredicate = function(node, opts) {
    if (!node) return !1;
    if ("InferredPredicate" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isInterfaceExtends = function(node, opts) {
    if (!node) return !1;
    if ("InterfaceExtends" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isInterfaceDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("InterfaceDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isInterfaceTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("InterfaceTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isIntersectionTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("IntersectionTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isMixedTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("MixedTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEmptyTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("EmptyTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNullableTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("NullableTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNumberLiteralTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("NumberLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNumberTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("NumberTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("ObjectTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectTypeInternalSlot = function(node, opts) {
    if (!node) return !1;
    if ("ObjectTypeInternalSlot" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectTypeCallProperty = function(node, opts) {
    if (!node) return !1;
    if ("ObjectTypeCallProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectTypeIndexer = function(node, opts) {
    if (!node) return !1;
    if ("ObjectTypeIndexer" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectTypeProperty = function(node, opts) {
    if (!node) return !1;
    if ("ObjectTypeProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectTypeSpreadProperty = function(node, opts) {
    if (!node) return !1;
    if ("ObjectTypeSpreadProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isOpaqueType = function(node, opts) {
    if (!node) return !1;
    if ("OpaqueType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isQualifiedTypeIdentifier = function(node, opts) {
    if (!node) return !1;
    if ("QualifiedTypeIdentifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isStringLiteralTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("StringLiteralTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isStringTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("StringTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSymbolTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("SymbolTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isThisTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("ThisTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTupleTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("TupleTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeofTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("TypeofTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeAlias = function(node, opts) {
    if (!node) return !1;
    if ("TypeAlias" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("TypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeCastExpression = function(node, opts) {
    if (!node) return !1;
    if ("TypeCastExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeParameter = function(node, opts) {
    if (!node) return !1;
    if ("TypeParameter" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeParameterDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TypeParameterDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTypeParameterInstantiation = function(node, opts) {
    if (!node) return !1;
    if ("TypeParameterInstantiation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isUnionTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("UnionTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isVariance = function(node, opts) {
    if (!node) return !1;
    if ("Variance" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isVoidTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("VoidTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("EnumDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumBooleanBody = function(node, opts) {
    if (!node) return !1;
    if ("EnumBooleanBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumNumberBody = function(node, opts) {
    if (!node) return !1;
    if ("EnumNumberBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumStringBody = function(node, opts) {
    if (!node) return !1;
    if ("EnumStringBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumSymbolBody = function(node, opts) {
    if (!node) return !1;
    if ("EnumSymbolBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumBooleanMember = function(node, opts) {
    if (!node) return !1;
    if ("EnumBooleanMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumNumberMember = function(node, opts) {
    if (!node) return !1;
    if ("EnumNumberMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumStringMember = function(node, opts) {
    if (!node) return !1;
    if ("EnumStringMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumDefaultedMember = function(node, opts) {
    if (!node) return !1;
    if ("EnumDefaultedMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXAttribute = function(node, opts) {
    if (!node) return !1;
    if ("JSXAttribute" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXClosingElement = function(node, opts) {
    if (!node) return !1;
    if ("JSXClosingElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXElement = function(node, opts) {
    if (!node) return !1;
    if ("JSXElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXEmptyExpression = function(node, opts) {
    if (!node) return !1;
    if ("JSXEmptyExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXExpressionContainer = function(node, opts) {
    if (!node) return !1;
    if ("JSXExpressionContainer" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXSpreadChild = function(node, opts) {
    if (!node) return !1;
    if ("JSXSpreadChild" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXIdentifier = function(node, opts) {
    if (!node) return !1;
    if ("JSXIdentifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXMemberExpression = function(node, opts) {
    if (!node) return !1;
    if ("JSXMemberExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXNamespacedName = function(node, opts) {
    if (!node) return !1;
    if ("JSXNamespacedName" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXOpeningElement = function(node, opts) {
    if (!node) return !1;
    if ("JSXOpeningElement" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXSpreadAttribute = function(node, opts) {
    if (!node) return !1;
    if ("JSXSpreadAttribute" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXText = function(node, opts) {
    if (!node) return !1;
    if ("JSXText" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXFragment = function(node, opts) {
    if (!node) return !1;
    if ("JSXFragment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXOpeningFragment = function(node, opts) {
    if (!node) return !1;
    if ("JSXOpeningFragment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSXClosingFragment = function(node, opts) {
    if (!node) return !1;
    if ("JSXClosingFragment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNoop = function(node, opts) {
    if (!node) return !1;
    if ("Noop" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPlaceholder = function(node, opts) {
    if (!node) return !1;
    if ("Placeholder" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isV8IntrinsicIdentifier = function(node, opts) {
    if (!node) return !1;
    if ("V8IntrinsicIdentifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isArgumentPlaceholder = function(node, opts) {
    if (!node) return !1;
    if ("ArgumentPlaceholder" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isAwaitExpression = function(node, opts) {
    if (!node) return !1;
    if ("AwaitExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBindExpression = function(node, opts) {
    if (!node) return !1;
    if ("BindExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassProperty = function(node, opts) {
    if (!node) return !1;
    if ("ClassProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isOptionalMemberExpression = function(node, opts) {
    if (!node) return !1;
    if ("OptionalMemberExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPipelineTopicExpression = function(node, opts) {
    if (!node) return !1;
    if ("PipelineTopicExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPipelineBareFunction = function(node, opts) {
    if (!node) return !1;
    if ("PipelineBareFunction" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPipelinePrimaryTopicReference = function(node, opts) {
    if (!node) return !1;
    if ("PipelinePrimaryTopicReference" === node.type) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isOptionalCallExpression = function(node, opts) {
    if (!node) return !1;
    if ("OptionalCallExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassPrivateProperty = function(node, opts) {
    if (!node) return !1;
    if ("ClassPrivateProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClassPrivateMethod = function(node, opts) {
    if (!node) return !1;
    if ("ClassPrivateMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImport = function(node, opts) {
    if (!node) return !1;
    if ("Import" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImportAttribute = function(node, opts) {
    if (!node) return !1;
    if ("ImportAttribute" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDecorator = function(node, opts) {
    if (!node) return !1;
    if ("Decorator" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDoExpression = function(node, opts) {
    if (!node) return !1;
    if ("DoExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportDefaultSpecifier = function(node, opts) {
    if (!node) return !1;
    if ("ExportDefaultSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportNamespaceSpecifier = function(node, opts) {
    if (!node) return !1;
    if ("ExportNamespaceSpecifier" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPrivateName = function(node, opts) {
    if (!node) return !1;
    if ("PrivateName" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBigIntLiteral = function(node, opts) {
    if (!node) return !1;
    if ("BigIntLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isRecordExpression = function(node, opts) {
    if (!node) return !1;
    if ("RecordExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTupleExpression = function(node, opts) {
    if (!node) return !1;
    if ("TupleExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSParameterProperty = function(node, opts) {
    if (!node) return !1;
    if ("TSParameterProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSDeclareFunction = function(node, opts) {
    if (!node) return !1;
    if ("TSDeclareFunction" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSDeclareMethod = function(node, opts) {
    if (!node) return !1;
    if ("TSDeclareMethod" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSQualifiedName = function(node, opts) {
    if (!node) return !1;
    if ("TSQualifiedName" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSCallSignatureDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSCallSignatureDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSConstructSignatureDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSConstructSignatureDeclaration" === node.type) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSPropertySignature = function(node, opts) {
    if (!node) return !1;
    if ("TSPropertySignature" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSMethodSignature = function(node, opts) {
    if (!node) return !1;
    if ("TSMethodSignature" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSIndexSignature = function(node, opts) {
    if (!node) return !1;
    if ("TSIndexSignature" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSAnyKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSAnyKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSBooleanKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSBooleanKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSBigIntKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSBigIntKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSNeverKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSNeverKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSNullKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSNullKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSNumberKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSNumberKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSObjectKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSObjectKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSStringKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSStringKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSSymbolKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSSymbolKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSUndefinedKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSUndefinedKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSUnknownKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSUnknownKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSVoidKeyword = function(node, opts) {
    if (!node) return !1;
    if ("TSVoidKeyword" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSThisType = function(node, opts) {
    if (!node) return !1;
    if ("TSThisType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSFunctionType = function(node, opts) {
    if (!node) return !1;
    if ("TSFunctionType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSConstructorType = function(node, opts) {
    if (!node) return !1;
    if ("TSConstructorType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeReference = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeReference" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypePredicate = function(node, opts) {
    if (!node) return !1;
    if ("TSTypePredicate" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeQuery = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeQuery" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeLiteral = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSArrayType = function(node, opts) {
    if (!node) return !1;
    if ("TSArrayType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTupleType = function(node, opts) {
    if (!node) return !1;
    if ("TSTupleType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSOptionalType = function(node, opts) {
    if (!node) return !1;
    if ("TSOptionalType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSRestType = function(node, opts) {
    if (!node) return !1;
    if ("TSRestType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSUnionType = function(node, opts) {
    if (!node) return !1;
    if ("TSUnionType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSIntersectionType = function(node, opts) {
    if (!node) return !1;
    if ("TSIntersectionType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSConditionalType = function(node, opts) {
    if (!node) return !1;
    if ("TSConditionalType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSInferType = function(node, opts) {
    if (!node) return !1;
    if ("TSInferType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSParenthesizedType = function(node, opts) {
    if (!node) return !1;
    if ("TSParenthesizedType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeOperator = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeOperator" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSIndexedAccessType = function(node, opts) {
    if (!node) return !1;
    if ("TSIndexedAccessType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSMappedType = function(node, opts) {
    if (!node) return !1;
    if ("TSMappedType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSLiteralType = function(node, opts) {
    if (!node) return !1;
    if ("TSLiteralType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSExpressionWithTypeArguments = function(node, opts) {
    if (!node) return !1;
    if ("TSExpressionWithTypeArguments" === node.type) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSInterfaceDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSInterfaceDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSInterfaceBody = function(node, opts) {
    if (!node) return !1;
    if ("TSInterfaceBody" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeAliasDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeAliasDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSAsExpression = function(node, opts) {
    if (!node) return !1;
    if ("TSAsExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeAssertion = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeAssertion" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSEnumDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSEnumDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSEnumMember = function(node, opts) {
    if (!node) return !1;
    if ("TSEnumMember" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSModuleDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSModuleDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSModuleBlock = function(node, opts) {
    if (!node) return !1;
    if ("TSModuleBlock" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSImportType = function(node, opts) {
    if (!node) return !1;
    if ("TSImportType" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSImportEqualsDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSImportEqualsDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSExternalModuleReference = function(node, opts) {
    if (!node) return !1;
    if ("TSExternalModuleReference" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSNonNullExpression = function(node, opts) {
    if (!node) return !1;
    if ("TSNonNullExpression" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSExportAssignment = function(node, opts) {
    if (!node) return !1;
    if ("TSExportAssignment" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSNamespaceExportDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSNamespaceExportDeclaration" === node.type) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeAnnotation = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeAnnotation" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeParameterInstantiation = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeParameterInstantiation" === node.type) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeParameterDeclaration = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeParameterDeclaration" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeParameter = function(node, opts) {
    if (!node) return !1;
    if ("TSTypeParameter" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExpression = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Expression" === nodeType || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "AwaitExpression" === nodeType || "BindExpression" === nodeType || "OptionalMemberExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "OptionalCallExpression" === nodeType || "Import" === nodeType || "DoExpression" === nodeType || "BigIntLiteral" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || "Placeholder" === nodeType && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBinary = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Binary" === nodeType || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isScopable = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Scopable" === nodeType || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || "Placeholder" === nodeType && "BlockStatement" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBlockParent = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("BlockParent" === nodeType || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || "Placeholder" === nodeType && "BlockStatement" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isBlock = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Block" === nodeType || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || "Placeholder" === nodeType && "BlockStatement" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isStatement = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Statement" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "Placeholder" === nodeType && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTerminatorless = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Terminatorless" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isCompletionStatement = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("CompletionStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isConditional = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Conditional" === nodeType || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isLoop = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Loop" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isWhile = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("While" === nodeType || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExpressionWrapper = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("ExpressionWrapper" === nodeType || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFor = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("For" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isForXStatement = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("ForXStatement" === nodeType || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFunction = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Function" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFunctionParent = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("FunctionParent" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPureish = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Pureish" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "Placeholder" === nodeType && "StringLiteral" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isDeclaration = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Declaration" === nodeType || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "Placeholder" === nodeType && "Declaration" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPatternLike = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("PatternLike" === nodeType || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "Placeholder" === nodeType && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isLVal = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("LVal" === nodeType || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || "Placeholder" === nodeType && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSEntityName = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("TSEntityName" === nodeType || "Identifier" === nodeType || "TSQualifiedName" === nodeType || "Placeholder" === nodeType && "Identifier" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isLiteral = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Literal" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "Placeholder" === nodeType && "StringLiteral" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isImmutable = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Immutable" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "BigIntLiteral" === nodeType || "Placeholder" === nodeType && "StringLiteral" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isUserWhitespacable = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("UserWhitespacable" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isMethod = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Method" === nodeType || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isObjectMember = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("ObjectMember" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isProperty = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Property" === nodeType || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isUnaryLike = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("UnaryLike" === nodeType || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPattern = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Pattern" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "Placeholder" === nodeType && "Pattern" === node.expectedNode) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isClass = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Class" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isModuleDeclaration = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("ModuleDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isExportDeclaration = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("ExportDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isModuleSpecifier = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("ModuleSpecifier" === nodeType || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFlow = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Flow" === nodeType || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFlowType = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("FlowType" === nodeType || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFlowBaseAnnotation = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("FlowBaseAnnotation" === nodeType || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFlowDeclaration = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("FlowDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isFlowPredicate = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("FlowPredicate" === nodeType || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumBody = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("EnumBody" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isEnumMember = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("EnumMember" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isJSX = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("JSX" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isPrivate = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("Private" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSTypeElement = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("TSTypeElement" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSType = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("TSType" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isTSBaseType = function(node, opts) {
    if (!node) return !1;
    const nodeType = node.type;
    if ("TSBaseType" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) return void 0 === opts || (0, 
    _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isNumberLiteral = function(node, opts) {
    if (console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), 
    !node) return !1;
    if ("NumberLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isRegexLiteral = function(node, opts) {
    if (console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), 
    !node) return !1;
    if ("RegexLiteral" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isRestProperty = function(node, opts) {
    if (console.trace("The node type RestProperty has been renamed to RestElement"), 
    !node) return !1;
    if ("RestProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  }, exports.isSpreadProperty = function(node, opts) {
    if (console.trace("The node type SpreadProperty has been renamed to SpreadElement"), 
    !node) return !1;
    if ("SpreadProperty" === node.type) return void 0 === opts || (0, _shallowEqual.default)(node, opts);
    return !1;
  };
  var obj, _shallowEqual = (obj = __webpack_require__(55)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.ArrayExpression = exports.arrayExpression = function(...args) {
    return (0, _builder.default)("ArrayExpression", ...args);
  }, exports.AssignmentExpression = exports.assignmentExpression = function(...args) {
    return (0, _builder.default)("AssignmentExpression", ...args);
  }, exports.BinaryExpression = exports.binaryExpression = function(...args) {
    return (0, _builder.default)("BinaryExpression", ...args);
  }, exports.InterpreterDirective = exports.interpreterDirective = function(...args) {
    return (0, _builder.default)("InterpreterDirective", ...args);
  }, exports.Directive = exports.directive = function(...args) {
    return (0, _builder.default)("Directive", ...args);
  }, exports.DirectiveLiteral = exports.directiveLiteral = function(...args) {
    return (0, _builder.default)("DirectiveLiteral", ...args);
  }, exports.BlockStatement = exports.blockStatement = function(...args) {
    return (0, _builder.default)("BlockStatement", ...args);
  }, exports.BreakStatement = exports.breakStatement = function(...args) {
    return (0, _builder.default)("BreakStatement", ...args);
  }, exports.CallExpression = exports.callExpression = function(...args) {
    return (0, _builder.default)("CallExpression", ...args);
  }, exports.CatchClause = exports.catchClause = function(...args) {
    return (0, _builder.default)("CatchClause", ...args);
  }, exports.ConditionalExpression = exports.conditionalExpression = function(...args) {
    return (0, _builder.default)("ConditionalExpression", ...args);
  }, exports.ContinueStatement = exports.continueStatement = function(...args) {
    return (0, _builder.default)("ContinueStatement", ...args);
  }, exports.DebuggerStatement = exports.debuggerStatement = function(...args) {
    return (0, _builder.default)("DebuggerStatement", ...args);
  }, exports.DoWhileStatement = exports.doWhileStatement = function(...args) {
    return (0, _builder.default)("DoWhileStatement", ...args);
  }, exports.EmptyStatement = exports.emptyStatement = function(...args) {
    return (0, _builder.default)("EmptyStatement", ...args);
  }, exports.ExpressionStatement = exports.expressionStatement = function(...args) {
    return (0, _builder.default)("ExpressionStatement", ...args);
  }, exports.File = exports.file = function(...args) {
    return (0, _builder.default)("File", ...args);
  }, exports.ForInStatement = exports.forInStatement = function(...args) {
    return (0, _builder.default)("ForInStatement", ...args);
  }, exports.ForStatement = exports.forStatement = function(...args) {
    return (0, _builder.default)("ForStatement", ...args);
  }, exports.FunctionDeclaration = exports.functionDeclaration = function(...args) {
    return (0, _builder.default)("FunctionDeclaration", ...args);
  }, exports.FunctionExpression = exports.functionExpression = function(...args) {
    return (0, _builder.default)("FunctionExpression", ...args);
  }, exports.Identifier = exports.identifier = function(...args) {
    return (0, _builder.default)("Identifier", ...args);
  }, exports.IfStatement = exports.ifStatement = function(...args) {
    return (0, _builder.default)("IfStatement", ...args);
  }, exports.LabeledStatement = exports.labeledStatement = function(...args) {
    return (0, _builder.default)("LabeledStatement", ...args);
  }, exports.StringLiteral = exports.stringLiteral = function(...args) {
    return (0, _builder.default)("StringLiteral", ...args);
  }, exports.NumericLiteral = exports.numericLiteral = function(...args) {
    return (0, _builder.default)("NumericLiteral", ...args);
  }, exports.NullLiteral = exports.nullLiteral = function(...args) {
    return (0, _builder.default)("NullLiteral", ...args);
  }, exports.BooleanLiteral = exports.booleanLiteral = function(...args) {
    return (0, _builder.default)("BooleanLiteral", ...args);
  }, exports.RegExpLiteral = exports.regExpLiteral = function(...args) {
    return (0, _builder.default)("RegExpLiteral", ...args);
  }, exports.LogicalExpression = exports.logicalExpression = function(...args) {
    return (0, _builder.default)("LogicalExpression", ...args);
  }, exports.MemberExpression = exports.memberExpression = function(...args) {
    return (0, _builder.default)("MemberExpression", ...args);
  }, exports.NewExpression = exports.newExpression = function(...args) {
    return (0, _builder.default)("NewExpression", ...args);
  }, exports.Program = exports.program = function(...args) {
    return (0, _builder.default)("Program", ...args);
  }, exports.ObjectExpression = exports.objectExpression = function(...args) {
    return (0, _builder.default)("ObjectExpression", ...args);
  }, exports.ObjectMethod = exports.objectMethod = function(...args) {
    return (0, _builder.default)("ObjectMethod", ...args);
  }, exports.ObjectProperty = exports.objectProperty = function(...args) {
    return (0, _builder.default)("ObjectProperty", ...args);
  }, exports.RestElement = exports.restElement = function(...args) {
    return (0, _builder.default)("RestElement", ...args);
  }, exports.ReturnStatement = exports.returnStatement = function(...args) {
    return (0, _builder.default)("ReturnStatement", ...args);
  }, exports.SequenceExpression = exports.sequenceExpression = function(...args) {
    return (0, _builder.default)("SequenceExpression", ...args);
  }, exports.ParenthesizedExpression = exports.parenthesizedExpression = function(...args) {
    return (0, _builder.default)("ParenthesizedExpression", ...args);
  }, exports.SwitchCase = exports.switchCase = function(...args) {
    return (0, _builder.default)("SwitchCase", ...args);
  }, exports.SwitchStatement = exports.switchStatement = function(...args) {
    return (0, _builder.default)("SwitchStatement", ...args);
  }, exports.ThisExpression = exports.thisExpression = function(...args) {
    return (0, _builder.default)("ThisExpression", ...args);
  }, exports.ThrowStatement = exports.throwStatement = function(...args) {
    return (0, _builder.default)("ThrowStatement", ...args);
  }, exports.TryStatement = exports.tryStatement = function(...args) {
    return (0, _builder.default)("TryStatement", ...args);
  }, exports.UnaryExpression = exports.unaryExpression = function(...args) {
    return (0, _builder.default)("UnaryExpression", ...args);
  }, exports.UpdateExpression = exports.updateExpression = function(...args) {
    return (0, _builder.default)("UpdateExpression", ...args);
  }, exports.VariableDeclaration = exports.variableDeclaration = function(...args) {
    return (0, _builder.default)("VariableDeclaration", ...args);
  }, exports.VariableDeclarator = exports.variableDeclarator = function(...args) {
    return (0, _builder.default)("VariableDeclarator", ...args);
  }, exports.WhileStatement = exports.whileStatement = function(...args) {
    return (0, _builder.default)("WhileStatement", ...args);
  }, exports.WithStatement = exports.withStatement = function(...args) {
    return (0, _builder.default)("WithStatement", ...args);
  }, exports.AssignmentPattern = exports.assignmentPattern = function(...args) {
    return (0, _builder.default)("AssignmentPattern", ...args);
  }, exports.ArrayPattern = exports.arrayPattern = function(...args) {
    return (0, _builder.default)("ArrayPattern", ...args);
  }, exports.ArrowFunctionExpression = exports.arrowFunctionExpression = function(...args) {
    return (0, _builder.default)("ArrowFunctionExpression", ...args);
  }, exports.ClassBody = exports.classBody = function(...args) {
    return (0, _builder.default)("ClassBody", ...args);
  }, exports.ClassExpression = exports.classExpression = function(...args) {
    return (0, _builder.default)("ClassExpression", ...args);
  }, exports.ClassDeclaration = exports.classDeclaration = function(...args) {
    return (0, _builder.default)("ClassDeclaration", ...args);
  }, exports.ExportAllDeclaration = exports.exportAllDeclaration = function(...args) {
    return (0, _builder.default)("ExportAllDeclaration", ...args);
  }, exports.ExportDefaultDeclaration = exports.exportDefaultDeclaration = function(...args) {
    return (0, _builder.default)("ExportDefaultDeclaration", ...args);
  }, exports.ExportNamedDeclaration = exports.exportNamedDeclaration = function(...args) {
    return (0, _builder.default)("ExportNamedDeclaration", ...args);
  }, exports.ExportSpecifier = exports.exportSpecifier = function(...args) {
    return (0, _builder.default)("ExportSpecifier", ...args);
  }, exports.ForOfStatement = exports.forOfStatement = function(...args) {
    return (0, _builder.default)("ForOfStatement", ...args);
  }, exports.ImportDeclaration = exports.importDeclaration = function(...args) {
    return (0, _builder.default)("ImportDeclaration", ...args);
  }, exports.ImportDefaultSpecifier = exports.importDefaultSpecifier = function(...args) {
    return (0, _builder.default)("ImportDefaultSpecifier", ...args);
  }, exports.ImportNamespaceSpecifier = exports.importNamespaceSpecifier = function(...args) {
    return (0, _builder.default)("ImportNamespaceSpecifier", ...args);
  }, exports.ImportSpecifier = exports.importSpecifier = function(...args) {
    return (0, _builder.default)("ImportSpecifier", ...args);
  }, exports.MetaProperty = exports.metaProperty = function(...args) {
    return (0, _builder.default)("MetaProperty", ...args);
  }, exports.ClassMethod = exports.classMethod = function(...args) {
    return (0, _builder.default)("ClassMethod", ...args);
  }, exports.ObjectPattern = exports.objectPattern = function(...args) {
    return (0, _builder.default)("ObjectPattern", ...args);
  }, exports.SpreadElement = exports.spreadElement = function(...args) {
    return (0, _builder.default)("SpreadElement", ...args);
  }, exports.super = exports.Super = function(...args) {
    return (0, _builder.default)("Super", ...args);
  }, exports.TaggedTemplateExpression = exports.taggedTemplateExpression = function(...args) {
    return (0, _builder.default)("TaggedTemplateExpression", ...args);
  }, exports.TemplateElement = exports.templateElement = function(...args) {
    return (0, _builder.default)("TemplateElement", ...args);
  }, exports.TemplateLiteral = exports.templateLiteral = function(...args) {
    return (0, _builder.default)("TemplateLiteral", ...args);
  }, exports.YieldExpression = exports.yieldExpression = function(...args) {
    return (0, _builder.default)("YieldExpression", ...args);
  }, exports.AnyTypeAnnotation = exports.anyTypeAnnotation = function(...args) {
    return (0, _builder.default)("AnyTypeAnnotation", ...args);
  }, exports.ArrayTypeAnnotation = exports.arrayTypeAnnotation = function(...args) {
    return (0, _builder.default)("ArrayTypeAnnotation", ...args);
  }, exports.BooleanTypeAnnotation = exports.booleanTypeAnnotation = function(...args) {
    return (0, _builder.default)("BooleanTypeAnnotation", ...args);
  }, exports.BooleanLiteralTypeAnnotation = exports.booleanLiteralTypeAnnotation = function(...args) {
    return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...args);
  }, exports.NullLiteralTypeAnnotation = exports.nullLiteralTypeAnnotation = function(...args) {
    return (0, _builder.default)("NullLiteralTypeAnnotation", ...args);
  }, exports.ClassImplements = exports.classImplements = function(...args) {
    return (0, _builder.default)("ClassImplements", ...args);
  }, exports.DeclareClass = exports.declareClass = function(...args) {
    return (0, _builder.default)("DeclareClass", ...args);
  }, exports.DeclareFunction = exports.declareFunction = function(...args) {
    return (0, _builder.default)("DeclareFunction", ...args);
  }, exports.DeclareInterface = exports.declareInterface = function(...args) {
    return (0, _builder.default)("DeclareInterface", ...args);
  }, exports.DeclareModule = exports.declareModule = function(...args) {
    return (0, _builder.default)("DeclareModule", ...args);
  }, exports.DeclareModuleExports = exports.declareModuleExports = function(...args) {
    return (0, _builder.default)("DeclareModuleExports", ...args);
  }, exports.DeclareTypeAlias = exports.declareTypeAlias = function(...args) {
    return (0, _builder.default)("DeclareTypeAlias", ...args);
  }, exports.DeclareOpaqueType = exports.declareOpaqueType = function(...args) {
    return (0, _builder.default)("DeclareOpaqueType", ...args);
  }, exports.DeclareVariable = exports.declareVariable = function(...args) {
    return (0, _builder.default)("DeclareVariable", ...args);
  }, exports.DeclareExportDeclaration = exports.declareExportDeclaration = function(...args) {
    return (0, _builder.default)("DeclareExportDeclaration", ...args);
  }, exports.DeclareExportAllDeclaration = exports.declareExportAllDeclaration = function(...args) {
    return (0, _builder.default)("DeclareExportAllDeclaration", ...args);
  }, exports.DeclaredPredicate = exports.declaredPredicate = function(...args) {
    return (0, _builder.default)("DeclaredPredicate", ...args);
  }, exports.ExistsTypeAnnotation = exports.existsTypeAnnotation = function(...args) {
    return (0, _builder.default)("ExistsTypeAnnotation", ...args);
  }, exports.FunctionTypeAnnotation = exports.functionTypeAnnotation = function(...args) {
    return (0, _builder.default)("FunctionTypeAnnotation", ...args);
  }, exports.FunctionTypeParam = exports.functionTypeParam = function(...args) {
    return (0, _builder.default)("FunctionTypeParam", ...args);
  }, exports.GenericTypeAnnotation = exports.genericTypeAnnotation = function(...args) {
    return (0, _builder.default)("GenericTypeAnnotation", ...args);
  }, exports.InferredPredicate = exports.inferredPredicate = function(...args) {
    return (0, _builder.default)("InferredPredicate", ...args);
  }, exports.InterfaceExtends = exports.interfaceExtends = function(...args) {
    return (0, _builder.default)("InterfaceExtends", ...args);
  }, exports.InterfaceDeclaration = exports.interfaceDeclaration = function(...args) {
    return (0, _builder.default)("InterfaceDeclaration", ...args);
  }, exports.InterfaceTypeAnnotation = exports.interfaceTypeAnnotation = function(...args) {
    return (0, _builder.default)("InterfaceTypeAnnotation", ...args);
  }, exports.IntersectionTypeAnnotation = exports.intersectionTypeAnnotation = function(...args) {
    return (0, _builder.default)("IntersectionTypeAnnotation", ...args);
  }, exports.MixedTypeAnnotation = exports.mixedTypeAnnotation = function(...args) {
    return (0, _builder.default)("MixedTypeAnnotation", ...args);
  }, exports.EmptyTypeAnnotation = exports.emptyTypeAnnotation = function(...args) {
    return (0, _builder.default)("EmptyTypeAnnotation", ...args);
  }, exports.NullableTypeAnnotation = exports.nullableTypeAnnotation = function(...args) {
    return (0, _builder.default)("NullableTypeAnnotation", ...args);
  }, exports.NumberLiteralTypeAnnotation = exports.numberLiteralTypeAnnotation = function(...args) {
    return (0, _builder.default)("NumberLiteralTypeAnnotation", ...args);
  }, exports.NumberTypeAnnotation = exports.numberTypeAnnotation = function(...args) {
    return (0, _builder.default)("NumberTypeAnnotation", ...args);
  }, exports.ObjectTypeAnnotation = exports.objectTypeAnnotation = function(...args) {
    return (0, _builder.default)("ObjectTypeAnnotation", ...args);
  }, exports.ObjectTypeInternalSlot = exports.objectTypeInternalSlot = function(...args) {
    return (0, _builder.default)("ObjectTypeInternalSlot", ...args);
  }, exports.ObjectTypeCallProperty = exports.objectTypeCallProperty = function(...args) {
    return (0, _builder.default)("ObjectTypeCallProperty", ...args);
  }, exports.ObjectTypeIndexer = exports.objectTypeIndexer = function(...args) {
    return (0, _builder.default)("ObjectTypeIndexer", ...args);
  }, exports.ObjectTypeProperty = exports.objectTypeProperty = function(...args) {
    return (0, _builder.default)("ObjectTypeProperty", ...args);
  }, exports.ObjectTypeSpreadProperty = exports.objectTypeSpreadProperty = function(...args) {
    return (0, _builder.default)("ObjectTypeSpreadProperty", ...args);
  }, exports.OpaqueType = exports.opaqueType = function(...args) {
    return (0, _builder.default)("OpaqueType", ...args);
  }, exports.QualifiedTypeIdentifier = exports.qualifiedTypeIdentifier = function(...args) {
    return (0, _builder.default)("QualifiedTypeIdentifier", ...args);
  }, exports.StringLiteralTypeAnnotation = exports.stringLiteralTypeAnnotation = function(...args) {
    return (0, _builder.default)("StringLiteralTypeAnnotation", ...args);
  }, exports.StringTypeAnnotation = exports.stringTypeAnnotation = function(...args) {
    return (0, _builder.default)("StringTypeAnnotation", ...args);
  }, exports.SymbolTypeAnnotation = exports.symbolTypeAnnotation = function(...args) {
    return (0, _builder.default)("SymbolTypeAnnotation", ...args);
  }, exports.ThisTypeAnnotation = exports.thisTypeAnnotation = function(...args) {
    return (0, _builder.default)("ThisTypeAnnotation", ...args);
  }, exports.TupleTypeAnnotation = exports.tupleTypeAnnotation = function(...args) {
    return (0, _builder.default)("TupleTypeAnnotation", ...args);
  }, exports.TypeofTypeAnnotation = exports.typeofTypeAnnotation = function(...args) {
    return (0, _builder.default)("TypeofTypeAnnotation", ...args);
  }, exports.TypeAlias = exports.typeAlias = function(...args) {
    return (0, _builder.default)("TypeAlias", ...args);
  }, exports.TypeAnnotation = exports.typeAnnotation = function(...args) {
    return (0, _builder.default)("TypeAnnotation", ...args);
  }, exports.TypeCastExpression = exports.typeCastExpression = function(...args) {
    return (0, _builder.default)("TypeCastExpression", ...args);
  }, exports.TypeParameter = exports.typeParameter = function(...args) {
    return (0, _builder.default)("TypeParameter", ...args);
  }, exports.TypeParameterDeclaration = exports.typeParameterDeclaration = function(...args) {
    return (0, _builder.default)("TypeParameterDeclaration", ...args);
  }, exports.TypeParameterInstantiation = exports.typeParameterInstantiation = function(...args) {
    return (0, _builder.default)("TypeParameterInstantiation", ...args);
  }, exports.UnionTypeAnnotation = exports.unionTypeAnnotation = function(...args) {
    return (0, _builder.default)("UnionTypeAnnotation", ...args);
  }, exports.Variance = exports.variance = function(...args) {
    return (0, _builder.default)("Variance", ...args);
  }, exports.VoidTypeAnnotation = exports.voidTypeAnnotation = function(...args) {
    return (0, _builder.default)("VoidTypeAnnotation", ...args);
  }, exports.EnumDeclaration = exports.enumDeclaration = function(...args) {
    return (0, _builder.default)("EnumDeclaration", ...args);
  }, exports.EnumBooleanBody = exports.enumBooleanBody = function(...args) {
    return (0, _builder.default)("EnumBooleanBody", ...args);
  }, exports.EnumNumberBody = exports.enumNumberBody = function(...args) {
    return (0, _builder.default)("EnumNumberBody", ...args);
  }, exports.EnumStringBody = exports.enumStringBody = function(...args) {
    return (0, _builder.default)("EnumStringBody", ...args);
  }, exports.EnumSymbolBody = exports.enumSymbolBody = function(...args) {
    return (0, _builder.default)("EnumSymbolBody", ...args);
  }, exports.EnumBooleanMember = exports.enumBooleanMember = function(...args) {
    return (0, _builder.default)("EnumBooleanMember", ...args);
  }, exports.EnumNumberMember = exports.enumNumberMember = function(...args) {
    return (0, _builder.default)("EnumNumberMember", ...args);
  }, exports.EnumStringMember = exports.enumStringMember = function(...args) {
    return (0, _builder.default)("EnumStringMember", ...args);
  }, exports.EnumDefaultedMember = exports.enumDefaultedMember = function(...args) {
    return (0, _builder.default)("EnumDefaultedMember", ...args);
  }, exports.jSXAttribute = exports.JSXAttribute = exports.jsxAttribute = function(...args) {
    return (0, _builder.default)("JSXAttribute", ...args);
  }, exports.jSXClosingElement = exports.JSXClosingElement = exports.jsxClosingElement = function(...args) {
    return (0, _builder.default)("JSXClosingElement", ...args);
  }, exports.jSXElement = exports.JSXElement = exports.jsxElement = function(...args) {
    return (0, _builder.default)("JSXElement", ...args);
  }, exports.jSXEmptyExpression = exports.JSXEmptyExpression = exports.jsxEmptyExpression = function(...args) {
    return (0, _builder.default)("JSXEmptyExpression", ...args);
  }, exports.jSXExpressionContainer = exports.JSXExpressionContainer = exports.jsxExpressionContainer = function(...args) {
    return (0, _builder.default)("JSXExpressionContainer", ...args);
  }, exports.jSXSpreadChild = exports.JSXSpreadChild = exports.jsxSpreadChild = function(...args) {
    return (0, _builder.default)("JSXSpreadChild", ...args);
  }, exports.jSXIdentifier = exports.JSXIdentifier = exports.jsxIdentifier = function(...args) {
    return (0, _builder.default)("JSXIdentifier", ...args);
  }, exports.jSXMemberExpression = exports.JSXMemberExpression = exports.jsxMemberExpression = function(...args) {
    return (0, _builder.default)("JSXMemberExpression", ...args);
  }, exports.jSXNamespacedName = exports.JSXNamespacedName = exports.jsxNamespacedName = function(...args) {
    return (0, _builder.default)("JSXNamespacedName", ...args);
  }, exports.jSXOpeningElement = exports.JSXOpeningElement = exports.jsxOpeningElement = function(...args) {
    return (0, _builder.default)("JSXOpeningElement", ...args);
  }, exports.jSXSpreadAttribute = exports.JSXSpreadAttribute = exports.jsxSpreadAttribute = function(...args) {
    return (0, _builder.default)("JSXSpreadAttribute", ...args);
  }, exports.jSXText = exports.JSXText = exports.jsxText = function(...args) {
    return (0, _builder.default)("JSXText", ...args);
  }, exports.jSXFragment = exports.JSXFragment = exports.jsxFragment = function(...args) {
    return (0, _builder.default)("JSXFragment", ...args);
  }, exports.jSXOpeningFragment = exports.JSXOpeningFragment = exports.jsxOpeningFragment = function(...args) {
    return (0, _builder.default)("JSXOpeningFragment", ...args);
  }, exports.jSXClosingFragment = exports.JSXClosingFragment = exports.jsxClosingFragment = function(...args) {
    return (0, _builder.default)("JSXClosingFragment", ...args);
  }, exports.Noop = exports.noop = function(...args) {
    return (0, _builder.default)("Noop", ...args);
  }, exports.Placeholder = exports.placeholder = function(...args) {
    return (0, _builder.default)("Placeholder", ...args);
  }, exports.V8IntrinsicIdentifier = exports.v8IntrinsicIdentifier = function(...args) {
    return (0, _builder.default)("V8IntrinsicIdentifier", ...args);
  }, exports.ArgumentPlaceholder = exports.argumentPlaceholder = function(...args) {
    return (0, _builder.default)("ArgumentPlaceholder", ...args);
  }, exports.AwaitExpression = exports.awaitExpression = function(...args) {
    return (0, _builder.default)("AwaitExpression", ...args);
  }, exports.BindExpression = exports.bindExpression = function(...args) {
    return (0, _builder.default)("BindExpression", ...args);
  }, exports.ClassProperty = exports.classProperty = function(...args) {
    return (0, _builder.default)("ClassProperty", ...args);
  }, exports.OptionalMemberExpression = exports.optionalMemberExpression = function(...args) {
    return (0, _builder.default)("OptionalMemberExpression", ...args);
  }, exports.PipelineTopicExpression = exports.pipelineTopicExpression = function(...args) {
    return (0, _builder.default)("PipelineTopicExpression", ...args);
  }, exports.PipelineBareFunction = exports.pipelineBareFunction = function(...args) {
    return (0, _builder.default)("PipelineBareFunction", ...args);
  }, exports.PipelinePrimaryTopicReference = exports.pipelinePrimaryTopicReference = function(...args) {
    return (0, _builder.default)("PipelinePrimaryTopicReference", ...args);
  }, exports.OptionalCallExpression = exports.optionalCallExpression = function(...args) {
    return (0, _builder.default)("OptionalCallExpression", ...args);
  }, exports.ClassPrivateProperty = exports.classPrivateProperty = function(...args) {
    return (0, _builder.default)("ClassPrivateProperty", ...args);
  }, exports.ClassPrivateMethod = exports.classPrivateMethod = function(...args) {
    return (0, _builder.default)("ClassPrivateMethod", ...args);
  }, exports.import = exports.Import = function(...args) {
    return (0, _builder.default)("Import", ...args);
  }, exports.ImportAttribute = exports.importAttribute = function(...args) {
    return (0, _builder.default)("ImportAttribute", ...args);
  }, exports.Decorator = exports.decorator = function(...args) {
    return (0, _builder.default)("Decorator", ...args);
  }, exports.DoExpression = exports.doExpression = function(...args) {
    return (0, _builder.default)("DoExpression", ...args);
  }, exports.ExportDefaultSpecifier = exports.exportDefaultSpecifier = function(...args) {
    return (0, _builder.default)("ExportDefaultSpecifier", ...args);
  }, exports.ExportNamespaceSpecifier = exports.exportNamespaceSpecifier = function(...args) {
    return (0, _builder.default)("ExportNamespaceSpecifier", ...args);
  }, exports.PrivateName = exports.privateName = function(...args) {
    return (0, _builder.default)("PrivateName", ...args);
  }, exports.BigIntLiteral = exports.bigIntLiteral = function(...args) {
    return (0, _builder.default)("BigIntLiteral", ...args);
  }, exports.RecordExpression = exports.recordExpression = function(...args) {
    return (0, _builder.default)("RecordExpression", ...args);
  }, exports.TupleExpression = exports.tupleExpression = function(...args) {
    return (0, _builder.default)("TupleExpression", ...args);
  }, exports.tSParameterProperty = exports.TSParameterProperty = exports.tsParameterProperty = function(...args) {
    return (0, _builder.default)("TSParameterProperty", ...args);
  }, exports.tSDeclareFunction = exports.TSDeclareFunction = exports.tsDeclareFunction = function(...args) {
    return (0, _builder.default)("TSDeclareFunction", ...args);
  }, exports.tSDeclareMethod = exports.TSDeclareMethod = exports.tsDeclareMethod = function(...args) {
    return (0, _builder.default)("TSDeclareMethod", ...args);
  }, exports.tSQualifiedName = exports.TSQualifiedName = exports.tsQualifiedName = function(...args) {
    return (0, _builder.default)("TSQualifiedName", ...args);
  }, exports.tSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = function(...args) {
    return (0, _builder.default)("TSCallSignatureDeclaration", ...args);
  }, exports.tSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = function(...args) {
    return (0, _builder.default)("TSConstructSignatureDeclaration", ...args);
  }, exports.tSPropertySignature = exports.TSPropertySignature = exports.tsPropertySignature = function(...args) {
    return (0, _builder.default)("TSPropertySignature", ...args);
  }, exports.tSMethodSignature = exports.TSMethodSignature = exports.tsMethodSignature = function(...args) {
    return (0, _builder.default)("TSMethodSignature", ...args);
  }, exports.tSIndexSignature = exports.TSIndexSignature = exports.tsIndexSignature = function(...args) {
    return (0, _builder.default)("TSIndexSignature", ...args);
  }, exports.tSAnyKeyword = exports.TSAnyKeyword = exports.tsAnyKeyword = function(...args) {
    return (0, _builder.default)("TSAnyKeyword", ...args);
  }, exports.tSBooleanKeyword = exports.TSBooleanKeyword = exports.tsBooleanKeyword = function(...args) {
    return (0, _builder.default)("TSBooleanKeyword", ...args);
  }, exports.tSBigIntKeyword = exports.TSBigIntKeyword = exports.tsBigIntKeyword = function(...args) {
    return (0, _builder.default)("TSBigIntKeyword", ...args);
  }, exports.tSNeverKeyword = exports.TSNeverKeyword = exports.tsNeverKeyword = function(...args) {
    return (0, _builder.default)("TSNeverKeyword", ...args);
  }, exports.tSNullKeyword = exports.TSNullKeyword = exports.tsNullKeyword = function(...args) {
    return (0, _builder.default)("TSNullKeyword", ...args);
  }, exports.tSNumberKeyword = exports.TSNumberKeyword = exports.tsNumberKeyword = function(...args) {
    return (0, _builder.default)("TSNumberKeyword", ...args);
  }, exports.tSObjectKeyword = exports.TSObjectKeyword = exports.tsObjectKeyword = function(...args) {
    return (0, _builder.default)("TSObjectKeyword", ...args);
  }, exports.tSStringKeyword = exports.TSStringKeyword = exports.tsStringKeyword = function(...args) {
    return (0, _builder.default)("TSStringKeyword", ...args);
  }, exports.tSSymbolKeyword = exports.TSSymbolKeyword = exports.tsSymbolKeyword = function(...args) {
    return (0, _builder.default)("TSSymbolKeyword", ...args);
  }, exports.tSUndefinedKeyword = exports.TSUndefinedKeyword = exports.tsUndefinedKeyword = function(...args) {
    return (0, _builder.default)("TSUndefinedKeyword", ...args);
  }, exports.tSUnknownKeyword = exports.TSUnknownKeyword = exports.tsUnknownKeyword = function(...args) {
    return (0, _builder.default)("TSUnknownKeyword", ...args);
  }, exports.tSVoidKeyword = exports.TSVoidKeyword = exports.tsVoidKeyword = function(...args) {
    return (0, _builder.default)("TSVoidKeyword", ...args);
  }, exports.tSThisType = exports.TSThisType = exports.tsThisType = function(...args) {
    return (0, _builder.default)("TSThisType", ...args);
  }, exports.tSFunctionType = exports.TSFunctionType = exports.tsFunctionType = function(...args) {
    return (0, _builder.default)("TSFunctionType", ...args);
  }, exports.tSConstructorType = exports.TSConstructorType = exports.tsConstructorType = function(...args) {
    return (0, _builder.default)("TSConstructorType", ...args);
  }, exports.tSTypeReference = exports.TSTypeReference = exports.tsTypeReference = function(...args) {
    return (0, _builder.default)("TSTypeReference", ...args);
  }, exports.tSTypePredicate = exports.TSTypePredicate = exports.tsTypePredicate = function(...args) {
    return (0, _builder.default)("TSTypePredicate", ...args);
  }, exports.tSTypeQuery = exports.TSTypeQuery = exports.tsTypeQuery = function(...args) {
    return (0, _builder.default)("TSTypeQuery", ...args);
  }, exports.tSTypeLiteral = exports.TSTypeLiteral = exports.tsTypeLiteral = function(...args) {
    return (0, _builder.default)("TSTypeLiteral", ...args);
  }, exports.tSArrayType = exports.TSArrayType = exports.tsArrayType = function(...args) {
    return (0, _builder.default)("TSArrayType", ...args);
  }, exports.tSTupleType = exports.TSTupleType = exports.tsTupleType = function(...args) {
    return (0, _builder.default)("TSTupleType", ...args);
  }, exports.tSOptionalType = exports.TSOptionalType = exports.tsOptionalType = function(...args) {
    return (0, _builder.default)("TSOptionalType", ...args);
  }, exports.tSRestType = exports.TSRestType = exports.tsRestType = function(...args) {
    return (0, _builder.default)("TSRestType", ...args);
  }, exports.tSUnionType = exports.TSUnionType = exports.tsUnionType = function(...args) {
    return (0, _builder.default)("TSUnionType", ...args);
  }, exports.tSIntersectionType = exports.TSIntersectionType = exports.tsIntersectionType = function(...args) {
    return (0, _builder.default)("TSIntersectionType", ...args);
  }, exports.tSConditionalType = exports.TSConditionalType = exports.tsConditionalType = function(...args) {
    return (0, _builder.default)("TSConditionalType", ...args);
  }, exports.tSInferType = exports.TSInferType = exports.tsInferType = function(...args) {
    return (0, _builder.default)("TSInferType", ...args);
  }, exports.tSParenthesizedType = exports.TSParenthesizedType = exports.tsParenthesizedType = function(...args) {
    return (0, _builder.default)("TSParenthesizedType", ...args);
  }, exports.tSTypeOperator = exports.TSTypeOperator = exports.tsTypeOperator = function(...args) {
    return (0, _builder.default)("TSTypeOperator", ...args);
  }, exports.tSIndexedAccessType = exports.TSIndexedAccessType = exports.tsIndexedAccessType = function(...args) {
    return (0, _builder.default)("TSIndexedAccessType", ...args);
  }, exports.tSMappedType = exports.TSMappedType = exports.tsMappedType = function(...args) {
    return (0, _builder.default)("TSMappedType", ...args);
  }, exports.tSLiteralType = exports.TSLiteralType = exports.tsLiteralType = function(...args) {
    return (0, _builder.default)("TSLiteralType", ...args);
  }, exports.tSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = function(...args) {
    return (0, _builder.default)("TSExpressionWithTypeArguments", ...args);
  }, exports.tSInterfaceDeclaration = exports.TSInterfaceDeclaration = exports.tsInterfaceDeclaration = function(...args) {
    return (0, _builder.default)("TSInterfaceDeclaration", ...args);
  }, exports.tSInterfaceBody = exports.TSInterfaceBody = exports.tsInterfaceBody = function(...args) {
    return (0, _builder.default)("TSInterfaceBody", ...args);
  }, exports.tSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = function(...args) {
    return (0, _builder.default)("TSTypeAliasDeclaration", ...args);
  }, exports.tSAsExpression = exports.TSAsExpression = exports.tsAsExpression = function(...args) {
    return (0, _builder.default)("TSAsExpression", ...args);
  }, exports.tSTypeAssertion = exports.TSTypeAssertion = exports.tsTypeAssertion = function(...args) {
    return (0, _builder.default)("TSTypeAssertion", ...args);
  }, exports.tSEnumDeclaration = exports.TSEnumDeclaration = exports.tsEnumDeclaration = function(...args) {
    return (0, _builder.default)("TSEnumDeclaration", ...args);
  }, exports.tSEnumMember = exports.TSEnumMember = exports.tsEnumMember = function(...args) {
    return (0, _builder.default)("TSEnumMember", ...args);
  }, exports.tSModuleDeclaration = exports.TSModuleDeclaration = exports.tsModuleDeclaration = function(...args) {
    return (0, _builder.default)("TSModuleDeclaration", ...args);
  }, exports.tSModuleBlock = exports.TSModuleBlock = exports.tsModuleBlock = function(...args) {
    return (0, _builder.default)("TSModuleBlock", ...args);
  }, exports.tSImportType = exports.TSImportType = exports.tsImportType = function(...args) {
    return (0, _builder.default)("TSImportType", ...args);
  }, exports.tSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = function(...args) {
    return (0, _builder.default)("TSImportEqualsDeclaration", ...args);
  }, exports.tSExternalModuleReference = exports.TSExternalModuleReference = exports.tsExternalModuleReference = function(...args) {
    return (0, _builder.default)("TSExternalModuleReference", ...args);
  }, exports.tSNonNullExpression = exports.TSNonNullExpression = exports.tsNonNullExpression = function(...args) {
    return (0, _builder.default)("TSNonNullExpression", ...args);
  }, exports.tSExportAssignment = exports.TSExportAssignment = exports.tsExportAssignment = function(...args) {
    return (0, _builder.default)("TSExportAssignment", ...args);
  }, exports.tSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = function(...args) {
    return (0, _builder.default)("TSNamespaceExportDeclaration", ...args);
  }, exports.tSTypeAnnotation = exports.TSTypeAnnotation = exports.tsTypeAnnotation = function(...args) {
    return (0, _builder.default)("TSTypeAnnotation", ...args);
  }, exports.tSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = function(...args) {
    return (0, _builder.default)("TSTypeParameterInstantiation", ...args);
  }, exports.tSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = function(...args) {
    return (0, _builder.default)("TSTypeParameterDeclaration", ...args);
  }, exports.tSTypeParameter = exports.TSTypeParameter = exports.tsTypeParameter = function(...args) {
    return (0, _builder.default)("TSTypeParameter", ...args);
  }, exports.numberLiteral = exports.NumberLiteral = function(...args) {
    return console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), 
    (0, _builder.default)("NumberLiteral", ...args);
  }, exports.regexLiteral = exports.RegexLiteral = function(...args) {
    return console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), 
    (0, _builder.default)("RegexLiteral", ...args);
  }, exports.restProperty = exports.RestProperty = function(...args) {
    return console.trace("The node type RestProperty has been renamed to RestElement"), 
    (0, _builder.default)("RestProperty", ...args);
  }, exports.spreadProperty = exports.SpreadProperty = function(...args) {
    return console.trace("The node type SpreadProperty has been renamed to SpreadElement"), 
    (0, _builder.default)("SpreadProperty", ...args);
  };
  var obj, _builder = (obj = __webpack_require__(184)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: !0,
    get: function() {
      return _utils.VISITOR_KEYS;
    }
  }), Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: !0,
    get: function() {
      return _utils.ALIAS_KEYS;
    }
  }), Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: function() {
      return _utils.FLIPPED_ALIAS_KEYS;
    }
  }), Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: !0,
    get: function() {
      return _utils.NODE_FIELDS;
    }
  }), Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: !0,
    get: function() {
      return _utils.BUILDER_KEYS;
    }
  }), Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: function() {
      return _utils.DEPRECATED_KEYS;
    }
  }), Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: function() {
      return _utils.NODE_PARENT_VALIDATIONS;
    }
  }), Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: !0,
    get: function() {
      return _placeholders.PLACEHOLDERS;
    }
  }), Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: function() {
      return _placeholders.PLACEHOLDERS_ALIAS;
    }
  }), Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: function() {
      return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  }), exports.TYPES = void 0;
  var obj, _toFastProperties = (obj = __webpack_require__(251)) && obj.__esModule ? obj : {
    default: obj
  };
  __webpack_require__(39), __webpack_require__(70), __webpack_require__(254), __webpack_require__(255), 
  __webpack_require__(256), __webpack_require__(257), __webpack_require__(258);
  var _utils = __webpack_require__(7), _placeholders = __webpack_require__(114);
  (0, _toFastProperties.default)(_utils.VISITOR_KEYS), (0, _toFastProperties.default)(_utils.ALIAS_KEYS), 
  (0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS), (0, _toFastProperties.default)(_utils.NODE_FIELDS), 
  (0, _toFastProperties.default)(_utils.BUILDER_KEYS), (0, _toFastProperties.default)(_utils.DEPRECATED_KEYS), 
  (0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_ALIAS), (0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
  const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
  exports.TYPES = TYPES;
}, function(module, exports, __webpack_require__) {
  var freeGlobal = __webpack_require__(98), freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.validate = validate, exports.typeIs = typeIs, exports.validateType = function(typeName) {
    return validate(typeIs(typeName));
  }, exports.validateOptional = function(validate) {
    return {
      validate: validate,
      optional: !0
    };
  }, exports.validateOptionalType = function(typeName) {
    return {
      validate: typeIs(typeName),
      optional: !0
    };
  }, exports.arrayOf = arrayOf, exports.arrayOfType = arrayOfType, exports.validateArrayOfType = function(typeName) {
    return validate(arrayOfType(typeName));
  }, exports.assertEach = assertEach, exports.assertOneOf = function(...values) {
    function validate(node, key, val) {
      if (values.indexOf(val) < 0) throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
    return validate.oneOf = values, validate;
  }, exports.assertNodeType = assertNodeType, exports.assertNodeOrValueType = function(...types) {
    function validate(node, key, val) {
      for (const type of types) if (getType(val) === type || (0, _is.default)(type, val)) return void (0, 
      _validate.validateChild)(node, key, val);
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null == val ? void 0 : val.type)}`);
    }
    return validate.oneOfNodeOrValueTypes = types, validate;
  }, exports.assertValueType = assertValueType, exports.assertShape = function(shape) {
    function validate(node, key, val) {
      const errors = [];
      for (const property of Object.keys(shape)) try {
        (0, _validate.validateField)(node, property, val[property], shape[property]);
      } catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message);
          continue;
        }
        throw error;
      }
      if (errors.length) throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
    return validate.shapeOf = shape, validate;
  }, exports.assertOptionalChainStart = function() {
    return function(node) {
      var _current;
      let current = node;
      for (;node; ) {
        const {type: type} = current;
        if ("OptionalCallExpression" !== type) {
          if ("OptionalMemberExpression" !== type) break;
          if (current.optional) return;
          current = current.object;
        } else {
          if (current.optional) return;
          current = current.callee;
        }
      }
      throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (_current = current) ? void 0 : _current.type}`);
    };
  }, exports.chain = chain, exports.default = function(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;
    if (!fields && (fields = {}, inherits.fields)) {
      const keys = Object.getOwnPropertyNames(inherits.fields);
      for (const key of keys) {
        const field = inherits.fields[key];
        fields[key] = {
          default: field.default,
          optional: field.optional,
          validate: field.validate
        };
      }
    }
    const visitor = opts.visitor || inherits.visitor || [], aliases = opts.aliases || inherits.aliases || [], builder = opts.builder || inherits.builder || opts.visitor || [];
    for (const k of Object.keys(opts)) if (-1 === validTypeOpts.indexOf(k)) throw new Error(`Unknown type option "${k}" on ${type}`);
    opts.deprecatedAlias && (DEPRECATED_KEYS[opts.deprecatedAlias] = type);
    for (const key of visitor.concat(builder)) fields[key] = fields[key] || {};
    for (const key of Object.keys(fields)) {
      const field = fields[key];
      void 0 !== field.default && -1 === builder.indexOf(key) && (field.optional = !0), 
      void 0 === field.default ? field.default = null : field.validate || null == field.default || (field.validate = assertValueType(getType(field.default)));
      for (const k of Object.keys(field)) if (-1 === validFieldKeys.indexOf(k)) throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
    }
    VISITOR_KEYS[type] = opts.visitor = visitor, BUILDER_KEYS[type] = opts.builder = builder, 
    NODE_FIELDS[type] = opts.fields = fields, ALIAS_KEYS[type] = opts.aliases = aliases, 
    aliases.forEach(alias => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [], FLIPPED_ALIAS_KEYS[alias].push(type);
    }), opts.validate && (NODE_PARENT_VALIDATIONS[type] = opts.validate);
    store[type] = opts;
  }, exports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;
  var obj, _is = (obj = __webpack_require__(26)) && obj.__esModule ? obj : {
    default: obj
  }, _validate = __webpack_require__(69);
  const VISITOR_KEYS = {};
  exports.VISITOR_KEYS = VISITOR_KEYS;
  const ALIAS_KEYS = {};
  exports.ALIAS_KEYS = ALIAS_KEYS;
  const FLIPPED_ALIAS_KEYS = {};
  exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
  const NODE_FIELDS = {};
  exports.NODE_FIELDS = NODE_FIELDS;
  const BUILDER_KEYS = {};
  exports.BUILDER_KEYS = BUILDER_KEYS;
  const DEPRECATED_KEYS = {};
  exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
  const NODE_PARENT_VALIDATIONS = {};
  function getType(val) {
    return Array.isArray(val) ? "array" : null === val ? "null" : typeof val;
  }
  function validate(validate) {
    return {
      validate: validate
    };
  }
  function typeIs(typeName) {
    return "string" == typeof typeName ? assertNodeType(typeName) : assertNodeType(...typeName);
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (Array.isArray(val)) for (let i = 0; i < val.length; i++) {
        const subkey = `${key}[${i}]`, v = val[i];
        callback(node, subkey, v), process.env.BABEL_TYPES_8_BREAKING && (0, _validate.validateChild)(node, subkey, v);
      }
    }
    return validator.each = callback, validator;
  }
  function assertNodeType(...types) {
    function validate(node, key, val) {
      for (const type of types) if ((0, _is.default)(type, val)) return void (0, _validate.validateChild)(node, key, val);
      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(null == val ? void 0 : val.type)}`);
    }
    return validate.oneOfNodeTypes = types, validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      if (!(getType(val) === type)) throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
    return validate.type = type, validate;
  }
  function chain(...fns) {
    function validate(...args) {
      for (const fn of fns) fn(...args);
    }
    return validate.chainOf = fns, validate;
  }
  exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
  const validTypeOpts = [ "aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate" ], validFieldKeys = [ "default", "optional", "validate" ];
  const store = {};
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function({node: node, parent: parent, scope: scope, id: id}, localBinding = !1) {
    if (node.id) return;
    if (!t.isObjectProperty(parent) && !t.isObjectMethod(parent, {
      kind: "method"
    }) || parent.computed && !t.isLiteral(parent.key)) {
      if (t.isVariableDeclarator(parent)) {
        if (id = parent.id, t.isIdentifier(id) && !localBinding) {
          const binding = scope.parent.getBinding(id.name);
          if (binding && binding.constant && scope.getBinding(id.name) === binding) return node.id = t.cloneNode(id), 
          void (node.id[t.NOT_LOCAL_BINDING] = !0);
        }
      } else if (t.isAssignmentExpression(parent, {
        operator: "="
      })) id = parent.left; else if (!id) return;
    } else id = parent.key;
    let name;
    id && t.isLiteral(id) ? name = function(id) {
      if (t.isNullLiteral(id)) return "null";
      if (t.isRegExpLiteral(id)) return `_${id.pattern}_${id.flags}`;
      if (t.isTemplateLiteral(id)) return id.quasis.map(quasi => quasi.value.raw).join("");
      if (void 0 !== id.value) return id.value + "";
      return "";
    }(id) : id && t.isIdentifier(id) && (name = id.name);
    if (void 0 === name) return;
    name = t.toBindingIdentifierName(name), (id = t.identifier(name))[t.NOT_LOCAL_BINDING] = !0;
    return function(state, method, id, scope) {
      if (state.selfReference) {
        if (!scope.hasBinding(id.name) || scope.hasGlobal(id.name)) {
          if (!t.isFunction(method)) return;
          let build = buildPropertyMethodAssignmentWrapper;
          method.generator && (build = buildGeneratorPropertyMethodAssignmentWrapper);
          const template = build({
            FUNCTION: method,
            FUNCTION_ID: id,
            FUNCTION_KEY: scope.generateUidIdentifier(id.name)
          }).expression, params = template.callee.body.body[0].params;
          for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) params.push(scope.generateUidIdentifier("x"));
          return template;
        }
        scope.rename(id.name);
      }
      method.id = id, scope.getProgramParent().references[id.name] = !0;
    }(function(node, name, scope) {
      const state = {
        selfAssignment: !1,
        selfReference: !1,
        outerDeclar: scope.getBindingIdentifier(name),
        references: [],
        name: name
      }, binding = scope.getOwnBinding(name);
      binding ? "param" === binding.kind && (state.selfReference = !0) : (state.outerDeclar || scope.hasGlobal(name)) && scope.traverse(node, visitor, state);
      return state;
    }(node, name, scope), node, id, scope) || node;
  };
  var _helperGetFunctionArity = _interopRequireDefault(__webpack_require__(179)), _template = _interopRequireDefault(__webpack_require__(41)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const buildPropertyMethodAssignmentWrapper = (0, _template.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), buildGeneratorPropertyMethodAssignmentWrapper = (0, 
  _template.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), visitor = {
    "ReferencedIdentifier|BindingIdentifier"(path, state) {
      if (path.node.name !== state.name) return;
      path.scope.getBindingIdentifier(state.name) === state.outerDeclar && (state.selfReference = !0, 
      path.stop());
    }
  };
}, function(module, exports) {
  module.exports = function(value) {
    return null != value && "object" == typeof value;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;
  var virtualTypes = _interopRequireWildcard(__webpack_require__(133)), _debug = _interopRequireDefault(__webpack_require__(309)), _index = _interopRequireDefault(__webpack_require__(28)), _scope = _interopRequireDefault(__webpack_require__(136)), t = _interopRequireWildcard(__webpack_require__(1)), _cache = __webpack_require__(44), _generator = _interopRequireDefault(__webpack_require__(324)), NodePath_ancestry = _interopRequireWildcard(__webpack_require__(348)), NodePath_inference = _interopRequireWildcard(__webpack_require__(349)), NodePath_replacement = _interopRequireWildcard(__webpack_require__(352)), NodePath_evaluation = _interopRequireWildcard(__webpack_require__(353)), NodePath_conversion = _interopRequireWildcard(__webpack_require__(354)), NodePath_introspection = _interopRequireWildcard(__webpack_require__(355)), NodePath_context = _interopRequireWildcard(__webpack_require__(356)), NodePath_removal = _interopRequireWildcard(__webpack_require__(357)), NodePath_modification = _interopRequireWildcard(__webpack_require__(359)), NodePath_family = _interopRequireWildcard(__webpack_require__(361)), NodePath_comments = _interopRequireWildcard(__webpack_require__(362));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  const debug = (0, _debug.default)("babel");
  exports.REMOVED = 1;
  exports.SHOULD_STOP = 2;
  exports.SHOULD_SKIP = 4;
  class NodePath {
    constructor(hub, parent) {
      this.parent = parent, this.hub = hub, this.contexts = [], this.data = null, this._traverseFlags = 0, 
      this.state = null, this.opts = null, this.skipKeys = null, this.parentPath = null, 
      this.context = null, this.container = null, this.listKey = null, this.key = null, 
      this.node = null, this.scope = null, this.type = null;
    }
    static get({hub: hub, parentPath: parentPath, parent: parent, container: container, listKey: listKey, key: key}) {
      if (!hub && parentPath && (hub = parentPath.hub), !parent) throw new Error("To get a node path the parent needs to exist");
      const targetNode = container[key], paths = _cache.path.get(parent) || [];
      let path;
      _cache.path.has(parent) || _cache.path.set(parent, paths);
      for (let i = 0; i < paths.length; i++) {
        const pathCheck = paths[i];
        if (pathCheck.node === targetNode) {
          path = pathCheck;
          break;
        }
      }
      return path || (path = new NodePath(hub, parent), paths.push(path)), path.setup(parentPath, container, listKey, key), 
      path;
    }
    getScope(scope) {
      return this.isScope() ? new _scope.default(this) : scope;
    }
    setData(key, val) {
      return null == this.data && (this.data = Object.create(null)), this.data[key] = val;
    }
    getData(key, def) {
      null == this.data && (this.data = Object.create(null));
      let val = this.data[key];
      return void 0 === val && void 0 !== def && (val = this.data[key] = def), val;
    }
    buildCodeFrameError(msg, Error = SyntaxError) {
      return this.hub.buildError(this.node, msg, Error);
    }
    traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
    set(key, node) {
      t.validate(this.node, key, node), this.node[key] = node;
    }
    getPathLocation() {
      const parts = [];
      let path = this;
      do {
        let key = path.key;
        path.inList && (key = `${path.listKey}[${key}]`), parts.unshift(key);
      } while (path = path.parentPath);
      return parts.join(".");
    }
    debug(message) {
      debug.enabled && debug(`${this.getPathLocation()} ${this.type}: ${message}`);
    }
    toString() {
      return (0, _generator.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(inList) {
      inList || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(4 & this._traverseFlags);
    }
    set shouldSkip(v) {
      v ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    get shouldStop() {
      return !!(2 & this._traverseFlags);
    }
    set shouldStop(v) {
      v ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get removed() {
      return !!(1 & this._traverseFlags);
    }
    set removed(v) {
      v ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
  }
  exports.default = NodePath, Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
  for (const type of t.TYPES) {
    const typeKey = "is" + type, fn = t[typeKey];
    NodePath.prototype[typeKey] = function(opts) {
      return fn(this.node, opts);
    }, NodePath.prototype["assert" + type] = function(opts) {
      if (!fn(this.node, opts)) throw new TypeError("Expected node path of type " + type);
    };
  }
  for (const type of Object.keys(virtualTypes)) {
    if ("_" === type[0]) continue;
    t.TYPES.indexOf(type) < 0 && t.TYPES.push(type);
    const virtualType = virtualTypes[type];
    NodePath.prototype["is" + type] = function(opts) {
      return virtualType.checkPath(this, opts);
    };
  }
}, function(module, exports) {
  module.exports = require("assert");
}, function(module, exports, __webpack_require__) {
  var baseIsNative = __webpack_require__(198), getValue = __webpack_require__(203);
  module.exports = function(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  };
}, function(module, exports, __webpack_require__) {
  var Symbol = __webpack_require__(33), getRawTag = __webpack_require__(199), objectToString = __webpack_require__(200), symToStringTag = Symbol ? Symbol.toStringTag : void 0;
  module.exports = function(value) {
    return null == value ? void 0 === value ? "[object Undefined]" : "[object Null]" : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  };
}, function(module, exports) {
  module.exports = function(value) {
    var type = typeof value;
    return null != value && ("object" == type || "function" == type);
  };
}, function(module, exports) {
  var isArray = Array.isArray;
  module.exports = isArray;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
  exports.STATEMENT_OR_BLOCK_KEYS = [ "consequent", "body", "alternate" ];
  exports.FLATTENABLE_KEYS = [ "body", "expressions" ];
  exports.FOR_INIT_KEYS = [ "left", "init" ];
  exports.COMMENT_KEYS = [ "leadingComments", "trailingComments", "innerComments" ];
  const LOGICAL_OPERATORS = [ "||", "&&", "??" ];
  exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
  exports.UPDATE_OPERATORS = [ "++", "--" ];
  const BOOLEAN_NUMBER_BINARY_OPERATORS = [ ">", "<", ">=", "<=" ];
  exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
  const EQUALITY_BINARY_OPERATORS = [ "==", "===", "!=", "!==" ];
  exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
  const COMPARISON_BINARY_OPERATORS = [ ...EQUALITY_BINARY_OPERATORS, "in", "instanceof" ];
  exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
  const BOOLEAN_BINARY_OPERATORS = [ ...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS ];
  exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
  const NUMBER_BINARY_OPERATORS = [ "-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^" ];
  exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
  const BINARY_OPERATORS = [ "+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS ];
  exports.BINARY_OPERATORS = BINARY_OPERATORS;
  const ASSIGNMENT_OPERATORS = [ "=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=") ];
  exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
  const BOOLEAN_UNARY_OPERATORS = [ "delete", "!" ];
  exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
  const NUMBER_UNARY_OPERATORS = [ "+", "-", "~" ];
  exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
  const STRING_UNARY_OPERATORS = [ "typeof" ];
  exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
  const UNARY_OPERATORS = [ "void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS ];
  exports.UNARY_OPERATORS = UNARY_OPERATORS;
  exports.INHERIT_KEYS = {
    optional: [ "typeAnnotation", "typeParameters", "returnType" ],
    force: [ "start", "loc", "end" ]
  };
  const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
  const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = cloneNode;
  var _definitions = __webpack_require__(5);
  const has = Function.call.bind(Object.prototype.hasOwnProperty);
  function cloneIfNode(obj, deep, withoutLoc) {
    return obj && "string" == typeof obj.type ? cloneNode(obj, deep, withoutLoc) : obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    return Array.isArray(obj) ? obj.map(node => cloneIfNode(node, deep, withoutLoc)) : cloneIfNode(obj, deep, withoutLoc);
  }
  function cloneNode(node, deep = !0, withoutLoc = !1) {
    if (!node) return node;
    const {type: type} = node, newNode = {
      type: type
    };
    if ("Identifier" === type) newNode.name = node.name, has(node, "optional") && "boolean" == typeof node.optional && (newNode.optional = node.optional), 
    has(node, "typeAnnotation") && (newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, !0, withoutLoc) : node.typeAnnotation); else {
      if (!has(_definitions.NODE_FIELDS, type)) throw new Error(`Unknown node type: "${type}"`);
      for (const field of Object.keys(_definitions.NODE_FIELDS[type])) has(node, field) && (newNode[field] = deep ? "File" === type && "comments" === field ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], !0, withoutLoc) : node[field]);
    }
    return has(node, "loc") && (newNode.loc = withoutLoc ? null : node.loc), has(node, "leadingComments") && (newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc)), 
    has(node, "innerComments") && (newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc)), 
    has(node, "trailingComments") && (newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc)), 
    has(node, "extra") && (newNode.extra = Object.assign({}, node.extra)), newNode;
  }
  function maybeCloneComments(comments, deep, withoutLoc) {
    return deep && withoutLoc ? function(comments) {
      return comments.map(({type: type, value: value}) => ({
        type: type,
        value: value,
        loc: null
      }));
    }(comments) : comments;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.getType = function(target) {
    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
  }, exports.intersection = function(first, second, third) {
    const result = new Set;
    for (const el of first) second.has(el) && third.has(el) && result.add(el);
    return result;
  }, exports.filterStageFromList = function(list, stageList) {
    return Object.keys(list).reduce((result, item) => (stageList.has(item) || (result[item] = list[item]), 
    result), {});
  }, exports.getImportSource = function({node: node}) {
    if (0 === node.specifiers.length) return node.source.value;
  }, exports.getRequireSource = function({node: node}) {
    if (!t.isExpressionStatement(node)) return;
    const {expression: expression} = node;
    if (t.isCallExpression(expression) && t.isIdentifier(expression.callee) && "require" === expression.callee.name && 1 === expression.arguments.length && t.isStringLiteral(expression.arguments[0])) return expression.arguments[0].value;
  }, exports.isPolyfillSource = function(source) {
    return "@babel/polyfill" === source || "core-js" === source;
  }, exports.getModulePath = getModulePath, exports.createImport = function(path, mod) {
    return (0, _helperModuleImports.addSideEffect)(path, getModulePath(mod));
  }, exports.isNamespaced = function(path) {
    if (!path.node) return !1;
    const binding = path.scope.getBinding(path.node.name);
    return !!binding && binding.path.isImportNamespaceSpecifier();
  }, exports.has = void 0;
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _helperModuleImports = __webpack_require__(74);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const has = Object.hasOwnProperty.call.bind(Object.hasOwnProperty);
  exports.has = has;
  const modulePathMap = {
    "regenerator-runtime": "regenerator-runtime/runtime"
  };
  function getModulePath(mod) {
    return modulePathMap[mod] || "core-js/modules/" + mod;
  }
}, function(module, exports) {
  var debug;
  exports = module.exports = SemVer, debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift("SEMVER"), console.log.apply(console, args);
  } : function() {}, exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991, re = exports.re = [], src = exports.src = [], R = 0, NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var MAINVERSION = R++;
  src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
  var PRERELEASE = R++;
  src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  var BUILD = R++;
  src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
  var FULL = R++, FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
  src[FULL] = "^" + FULLPLAIN + "$";
  var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?", LOOSE = R++;
  src[LOOSE] = "^" + LOOSEPLAIN + "$";
  var GTLT = R++;
  src[GTLT] = "((?:<|>)?=?)";
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
  var XRANGE = R++;
  src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
  var COERCE = R++;
  src[COERCE] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
  var LONETILDE = R++;
  src[LONETILDE] = "(?:~>?)";
  var TILDETRIM = R++;
  src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+", re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
  var TILDE = R++;
  src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
  var TILDELOOSE = R++;
  src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
  var LONECARET = R++;
  src[LONECARET] = "(?:\\^)";
  var CARETTRIM = R++;
  src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+", re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
  var CARET = R++;
  src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
  var CARETLOOSE = R++;
  src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
  var COMPARATOR = R++;
  src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")", 
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
  var STAR = R++;
  src[STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < 35; i++) debug(i, src[i]), re[i] || (re[i] = new RegExp(src[i]));
  function parse(version, options) {
    if (options && "object" == typeof options || (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    if (version.length > 256) return null;
    if (!(options.loose ? re[LOOSE] : re[FULL]).test(version)) return null;
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  function SemVer(version, options) {
    if (options && "object" == typeof options || (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) {
      if (version.loose === options.loose) return version;
      version = version.version;
    } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);
    if (version.length > 256) throw new TypeError("version is longer than 256 characters");
    if (!(this instanceof SemVer)) return new SemVer(version, options);
    debug("SemVer", version, options), this.options = options, this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) throw new TypeError("Invalid Version: " + version);
    if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
    this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
    m[4] ? this.prerelease = m[4].split(".").map((function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
      }
      return id;
    })) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
  }
  exports.parse = parse, exports.valid = function(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }, exports.clean = function(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }, exports.SemVer = SemVer, SemVer.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), 
    this.version;
  }, SemVer.prototype.toString = function() {
    return this.version;
  }, SemVer.prototype.compare = function(other) {
    return debug("SemVer.compare", this.version, this.options, other), other instanceof SemVer || (other = new SemVer(other, this.options)), 
    this.compareMain(other) || this.comparePre(other);
  }, SemVer.prototype.compareMain = function(other) {
    return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }, SemVer.prototype.comparePre = function(other) {
    if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
    if (!this.prerelease.length && other.prerelease.length) return 1;
    if (!this.prerelease.length && !other.prerelease.length) return 0;
    var i = 0;
    do {
      var a = this.prerelease[i], b = other.prerelease[i];
      if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
      if (void 0 === b) return 1;
      if (void 0 === a) return -1;
      if (a !== b) return compareIdentifiers(a, b);
    } while (++i);
  }, SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
     case "premajor":
      this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
      break;

     case "preminor":
      this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
      break;

     case "prepatch":
      this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
      break;

     case "prerelease":
      0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
      break;

     case "major":
      0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
      this.minor = 0, this.patch = 0, this.prerelease = [];
      break;

     case "minor":
      0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
      this.prerelease = [];
      break;

     case "patch":
      0 === this.prerelease.length && this.patch++, this.prerelease = [];
      break;

     case "pre":
      if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
        for (var i = this.prerelease.length; --i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
        i = -2);
        -1 === i && this.prerelease.push(0);
      }
      identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
      break;

     default:
      throw new Error("invalid increment argument: " + release);
    }
    return this.format(), this.raw = this.version, this;
  }, exports.inc = function(version, release, loose, identifier) {
    "string" == typeof loose && (identifier = loose, loose = void 0);
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }, exports.diff = function(version1, version2) {
    if (eq(version1, version2)) return null;
    var v1 = parse(version1), v2 = parse(version2), prefix = "";
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = "pre";
      var defaultResult = "prerelease";
    }
    for (var key in v1) if (("major" === key || "minor" === key || "patch" === key) && v1[key] !== v2[key]) return prefix + key;
    return defaultResult;
  }, exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  function eq(a, b, loose) {
    return 0 === compare(a, b, loose);
  }
  function neq(a, b, loose) {
    return 0 !== compare(a, b, loose);
  }
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  function cmp(a, op, b, loose) {
    switch (op) {
     case "===":
      return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
      a === b;

     case "!==":
      return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
      a !== b;

     case "":
     case "=":
     case "==":
      return eq(a, b, loose);

     case "!=":
      return neq(a, b, loose);

     case ">":
      return gt(a, b, loose);

     case ">=":
      return gte(a, b, loose);

     case "<":
      return lt(a, b, loose);

     case "<=":
      return lte(a, b, loose);

     default:
      throw new TypeError("Invalid operator: " + op);
    }
  }
  function Comparator(comp, options) {
    if (options && "object" == typeof options || (options = {
      loose: !!options,
      includePrerelease: !1
    }), comp instanceof Comparator) {
      if (comp.loose === !!options.loose) return comp;
      comp = comp.value;
    }
    if (!(this instanceof Comparator)) return new Comparator(comp, options);
    debug("comparator", comp, options), this.options = options, this.loose = !!options.loose, 
    this.parse(comp), this.semver === ANY ? this.value = "" : this.value = this.operator + this.semver.version, 
    debug("comp", this);
  }
  exports.rcompareIdentifiers = function(a, b) {
    return compareIdentifiers(b, a);
  }, exports.major = function(a, loose) {
    return new SemVer(a, loose).major;
  }, exports.minor = function(a, loose) {
    return new SemVer(a, loose).minor;
  }, exports.patch = function(a, loose) {
    return new SemVer(a, loose).patch;
  }, exports.compare = compare, exports.compareLoose = function(a, b) {
    return compare(a, b, !0);
  }, exports.rcompare = function(a, b, loose) {
    return compare(b, a, loose);
  }, exports.sort = function(list, loose) {
    return list.sort((function(a, b) {
      return exports.compare(a, b, loose);
    }));
  }, exports.rsort = function(list, loose) {
    return list.sort((function(a, b) {
      return exports.rcompare(a, b, loose);
    }));
  }, exports.gt = gt, exports.lt = lt, exports.eq = eq, exports.neq = neq, exports.gte = gte, 
  exports.lte = lte, exports.cmp = cmp, exports.Comparator = Comparator;
  var ANY = {};
  function Range(range, options) {
    if (options && "object" == typeof options || (options = {
      loose: !!options,
      includePrerelease: !1
    }), range instanceof Range) return range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease ? range : new Range(range.raw, options);
    if (range instanceof Comparator) return new Range(range.value, options);
    if (!(this instanceof Range)) return new Range(range, options);
    if (this.options = options, this.loose = !!options.loose, this.includePrerelease = !!options.includePrerelease, 
    this.raw = range, this.set = range.split(/\s*\|\|\s*/).map((function(range) {
      return this.parseRange(range.trim());
    }), this).filter((function(c) {
      return c.length;
    })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + range);
    this.format();
  }
  function isX(id) {
    return !id || "x" === id.toLowerCase() || "*" === id;
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    return ((from = isX(fM) ? "" : isX(fm) ? ">=" + fM + ".0.0" : isX(fp) ? ">=" + fM + "." + fm + ".0" : ">=" + from) + " " + (to = isX(tM) ? "" : isX(tm) ? "<" + (+tM + 1) + ".0.0" : isX(tp) ? "<" + tM + "." + (+tm + 1) + ".0" : tpr ? "<=" + tM + "." + tm + "." + tp + "-" + tpr : "<=" + to)).trim();
  }
  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) if (!set[i].test(version)) return !1;
    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) if (debug(set[i].semver), set[i].semver !== ANY && set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) return !0;
      }
      return !1;
    }
    return !0;
  }
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return !1;
    }
    return range.test(version);
  }
  function outside(version, range, hilo, options) {
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (version = new SemVer(version, options), range = new Range(range, options), 
    hilo) {
     case ">":
      gtfn = gt, ltefn = lte, ltfn = lt, comp = ">", ecomp = ">=";
      break;

     case "<":
      gtfn = lt, ltefn = gte, ltfn = gt, comp = "<", ecomp = "<=";
      break;

     default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) return !1;
    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i], high = null, low = null;
      if (comparators.forEach((function(comparator) {
        comparator.semver === ANY && (comparator = new Comparator(">=0.0.0")), high = high || comparator, 
        low = low || comparator, gtfn(comparator.semver, high.semver, options) ? high = comparator : ltfn(comparator.semver, low.semver, options) && (low = comparator);
      })), high.operator === comp || high.operator === ecomp) return !1;
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) return !1;
      if (low.operator === ecomp && ltfn(version, low.semver)) return !1;
    }
    return !0;
  }
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR], m = comp.match(r);
    if (!m) throw new TypeError("Invalid comparator: " + comp);
    this.operator = m[1], "=" === this.operator && (this.operator = ""), m[2] ? this.semver = new SemVer(m[2], this.options.loose) : this.semver = ANY;
  }, Comparator.prototype.toString = function() {
    return this.value;
  }, Comparator.prototype.test = function(version) {
    return debug("Comparator.test", version, this.options.loose), this.semver === ANY || ("string" == typeof version && (version = new SemVer(version, this.options)), 
    cmp(version, this.operator, this.semver, this.options));
  }, Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) throw new TypeError("a Comparator is required");
    var rangeTmp;
    if (options && "object" == typeof options || (options = {
      loose: !!options,
      includePrerelease: !1
    }), "" === this.operator) return rangeTmp = new Range(comp.value, options), satisfies(this.value, rangeTmp, options);
    if ("" === comp.operator) return rangeTmp = new Range(this.value, options), satisfies(comp.semver, rangeTmp, options);
    var sameDirectionIncreasing = !(">=" !== this.operator && ">" !== this.operator || ">=" !== comp.operator && ">" !== comp.operator), sameDirectionDecreasing = !("<=" !== this.operator && "<" !== this.operator || "<=" !== comp.operator && "<" !== comp.operator), sameSemVer = this.semver.version === comp.semver.version, differentDirectionsInclusive = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== comp.operator && "<=" !== comp.operator), oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (">=" === this.operator || ">" === this.operator) && ("<=" === comp.operator || "<" === comp.operator), oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ("<=" === this.operator || "<" === this.operator) && (">=" === comp.operator || ">" === comp.operator);
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }, exports.Range = Range, Range.prototype.format = function() {
    return this.range = this.set.map((function(comps) {
      return comps.join(" ").trim();
    })).join("||").trim(), this.range;
  }, Range.prototype.toString = function() {
    return this.range;
  }, Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace), debug("hyphen replace", range), range = range.replace(re[COMPARATORTRIM], "$1$2$3"), 
    debug("comparator trim", range, re[COMPARATORTRIM]), range = (range = (range = range.replace(re[TILDETRIM], "$1~")).replace(re[CARETTRIM], "$1^")).split(/\s+/).join(" ");
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR], set = range.split(" ").map((function(comp) {
      return function(comp, options) {
        return debug("comp", comp, options), comp = function(comp, options) {
          return comp.trim().split(/\s+/).map((function(comp) {
            return function(comp, options) {
              debug("caret", comp, options);
              var r = options.loose ? re[CARETLOOSE] : re[CARET];
              return comp.replace(r, (function(_, M, m, p, pr) {
                var ret;
                return debug("caret", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = "0" === M ? ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0" : pr ? (debug("replaceCaret pr", pr), 
                ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0") : (debug("no pr"), 
                ret = "0" === M ? "0" === m ? ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1) : ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0" : ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0"), 
                debug("caret return", ret), ret;
              }));
            }(comp, options);
          })).join(" ");
        }(comp, options), debug("caret", comp), comp = function(comp, options) {
          return comp.trim().split(/\s+/).map((function(comp) {
            return function(comp, options) {
              var r = options.loose ? re[TILDELOOSE] : re[TILDE];
              return comp.replace(r, (function(_, M, m, p, pr) {
                var ret;
                return debug("tilde", comp, _, M, m, p, pr), isX(M) ? ret = "" : isX(m) ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : isX(p) ? ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0" : pr ? (debug("replaceTilde pr", pr), 
                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0") : ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0", 
                debug("tilde return", ret), ret;
              }));
            }(comp, options);
          })).join(" ");
        }(comp, options), debug("tildes", comp), comp = function(comp, options) {
          return debug("replaceXRanges", comp, options), comp.split(/\s+/).map((function(comp) {
            return function(comp, options) {
              comp = comp.trim();
              var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
              return comp.replace(r, (function(ret, gtlt, M, m, p, pr) {
                debug("xRange", comp, ret, gtlt, M, m, p, pr);
                var xM = isX(M), xm = xM || isX(m), xp = xm || isX(p);
                return "=" === gtlt && xp && (gtlt = ""), xM ? ret = ">" === gtlt || "<" === gtlt ? "<0.0.0" : "*" : gtlt && xp ? (xm && (m = 0), 
                p = 0, ">" === gtlt ? (gtlt = ">=", xm ? (M = +M + 1, m = 0, p = 0) : (m = +m + 1, 
                p = 0)) : "<=" === gtlt && (gtlt = "<", xm ? M = +M + 1 : m = +m + 1), ret = gtlt + M + "." + m + "." + p) : xm ? ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0" : xp && (ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0"), 
                debug("xRange return", ret), ret;
              }));
            }(comp, options);
          })).join(" ");
        }(comp, options), debug("xrange", comp), comp = function(comp, options) {
          return debug("replaceStars", comp, options), comp.trim().replace(re[STAR], "");
        }(comp, options), debug("stars", comp), comp;
      }(comp, this.options);
    }), this).join(" ").split(/\s+/);
    return this.options.loose && (set = set.filter((function(comp) {
      return !!comp.match(compRe);
    }))), set = set.map((function(comp) {
      return new Comparator(comp, this.options);
    }), this);
  }, Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) throw new TypeError("a Range is required");
    return this.set.some((function(thisComparators) {
      return thisComparators.every((function(thisComparator) {
        return range.set.some((function(rangeComparators) {
          return rangeComparators.every((function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          }));
        }));
      }));
    }));
  }, exports.toComparators = function(range, options) {
    return new Range(range, options).set.map((function(comp) {
      return comp.map((function(c) {
        return c.value;
      })).join(" ").trim().split(" ");
    }));
  }, Range.prototype.test = function(version) {
    if (!version) return !1;
    "string" == typeof version && (version = new SemVer(version, this.options));
    for (var i = 0; i < this.set.length; i++) if (testSet(this.set[i], version, this.options)) return !0;
    return !1;
  }, exports.satisfies = satisfies, exports.maxSatisfying = function(versions, range, options) {
    var max = null, maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    return versions.forEach((function(v) {
      rangeObj.test(v) && (max && -1 !== maxSV.compare(v) || (maxSV = new SemVer(max = v, options)));
    })), max;
  }, exports.minSatisfying = function(versions, range, options) {
    var min = null, minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    return versions.forEach((function(v) {
      rangeObj.test(v) && (min && 1 !== minSV.compare(v) || (minSV = new SemVer(min = v, options)));
    })), min;
  }, exports.minVersion = function(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) return minver;
    if (minver = new SemVer("0.0.0-0"), range.test(minver)) return minver;
    minver = null;
    for (var i = 0; i < range.set.length; ++i) {
      range.set[i].forEach((function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
         case ">":
          0 === compver.prerelease.length ? compver.patch++ : compver.prerelease.push(0), 
          compver.raw = compver.format();

         case "":
         case ">=":
          minver && !gt(minver, compver) || (minver = compver);
          break;

         case "<":
         case "<=":
          break;

         default:
          throw new Error("Unexpected operation: " + comparator.operator);
        }
      }));
    }
    if (minver && range.test(minver)) return minver;
    return null;
  }, exports.validRange = function(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }, exports.ltr = function(version, range, options) {
    return outside(version, range, "<", options);
  }, exports.gtr = function(version, range, options) {
    return outside(version, range, ">", options);
  }, exports.outside = outside, exports.prerelease = function(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }, exports.intersects = function(r1, r2, options) {
    return r1 = new Range(r1, options), r2 = new Range(r2, options), r1.intersects(r2);
  }, exports.coerce = function(version) {
    if (version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    var match = version.match(re[COERCE]);
    if (null == match) return null;
    return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.isBrowsersQueryValid = isBrowsersQueryValid, exports.default = function(inputTargets = {}, options = {}) {
    let {browsers: browsers} = inputTargets;
    if (inputTargets.esmodules) {
      const supportsESModules = _nativeModules.default["es6.module"];
      browsers = Object.keys(supportsESModules).map(browser => `${browser} ${supportsESModules[browser]}`).join(", ");
    }
    const browsersquery = function(browsers) {
      return (0, _invariant.default)(void 0 === browsers || isBrowsersQueryValid(browsers), `Invalid Option: '${String(browsers)}' is not a valid browserslist query`), 
      browsers;
    }(browsers), input = Object.assign({}, inputTargets);
    delete input.esmodules, delete input.browsers;
    let targets = function(targets) {
      const validTargets = Object.keys(_options.TargetNames);
      for (const target in targets) if (!_options.TargetNames[target]) throw new Error(`Invalid Option: '${target}' is not a valid target\n        Maybe you meant to use '${(0, 
      _levenary.default)(target, validTargets)}'?`);
      return targets;
    }(input);
    const shouldParseBrowsers = !!browsersquery, hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0, shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
    if (shouldParseBrowsers || shouldSearchForConfig) {
      hasTargets || (_browserslist.default.defaults = (object = targets, Object.keys(object).reduce((list, targetName) => {
        if (validBrowserslistTargets.indexOf(targetName) >= 0) {
          const targetVersion = object[targetName];
          return list.concat(`${targetName} ${targetVersion}`);
        }
        return list;
      }, [])));
      const queryBrowsers = function(browsers) {
        return browsers.reduce((all, browser) => {
          const [browserName, browserVersion] = browser.split(" "), normalizedBrowserName = _targets.browserNameMap[browserName];
          if (!normalizedBrowserName) return all;
          try {
            const splitVersion = browserVersion.split("-")[0].toLowerCase(), isSplitUnreleased = (0, 
            _utils.isUnreleasedVersion)(splitVersion, browserName);
            if (!all[normalizedBrowserName]) return all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : (0, 
            _utils.semverify)(splitVersion), all;
            const version = all[normalizedBrowserName], isUnreleased = (0, _utils.isUnreleasedVersion)(version, browserName);
            if (isUnreleased && isSplitUnreleased) all[normalizedBrowserName] = (0, _utils.getLowestUnreleased)(version, splitVersion, browserName); else if (isUnreleased) all[normalizedBrowserName] = (0, 
            _utils.semverify)(splitVersion); else if (!isUnreleased && !isSplitUnreleased) {
              const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
              all[normalizedBrowserName] = (0, _utils.semverMin)(version, parsedBrowserVersion);
            }
          } catch (e) {}
          return all;
        }, {});
      }((0, _browserslist.default)(browsersquery, {
        path: options.configPath,
        mobileToDesktop: !0,
        env: options.browserslistEnv
      }));
      targets = Object.assign(queryBrowsers, targets), _browserslist.default.defaults = browserslistDefaults;
    }
    var object;
    const parsed = Object.keys(targets).sort().reduce((results, target) => {
      var _targetParserMap$targ;
      const value = targets[target];
      "number" == typeof value && value % 1 != 0 && results.decimalWarnings.push({
        target: target,
        value: value
      });
      const parser = null != (_targetParserMap$targ = targetParserMap[target]) ? _targetParserMap$targ : targetParserMap.__default, [parsedTarget, parsedValue] = parser(target, value);
      return parsedValue && (results.targets[parsedTarget] = parsedValue), results;
    }, {
      targets: {},
      decimalWarnings: []
    });
    return function(decimalTargets) {
      if (!(null == decimalTargets ? void 0 : decimalTargets.length)) return;
      console.log("Warning, the following targets are using a decimal version:"), console.log(""), 
      decimalTargets.forEach(({target: target, value: value}) => console.log(`  ${target}: ${value}`)), 
      console.log(""), console.log("We recommend using a string for minor/patch versions to avoid numbers like 6.10"), 
      console.log("getting parsed as 6.1, which can lead to unexpected behavior."), console.log("");
    }(parsed.decimalWarnings), parsed.targets;
  }, Object.defineProperty(exports, "unreleasedLabels", {
    enumerable: !0,
    get: function() {
      return _targets.unreleasedLabels;
    }
  }), Object.defineProperty(exports, "prettifyTargets", {
    enumerable: !0,
    get: function() {
      return _pretty.prettifyTargets;
    }
  }), Object.defineProperty(exports, "getInclusionReasons", {
    enumerable: !0,
    get: function() {
      return _debug.getInclusionReasons;
    }
  }), Object.defineProperty(exports, "filterItems", {
    enumerable: !0,
    get: function() {
      return _filterItems.default;
    }
  }), Object.defineProperty(exports, "isRequired", {
    enumerable: !0,
    get: function() {
      return _filterItems.isRequired;
    }
  });
  var _browserslist = _interopRequireDefault(__webpack_require__(162)), _levenary = _interopRequireDefault(__webpack_require__(80)), _invariant = _interopRequireDefault(__webpack_require__(50)), _nativeModules = _interopRequireDefault(__webpack_require__(163)), _utils = __webpack_require__(51), _targets = __webpack_require__(52), _options = __webpack_require__(165), _pretty = __webpack_require__(81), _debug = __webpack_require__(166), _filterItems = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(167));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const browserslistDefaults = _browserslist.default.defaults, validBrowserslistTargets = [ ...Object.keys(_browserslist.default.data), ...Object.keys(_browserslist.default.aliases) ];
  function isBrowsersQueryValid(browsers) {
    return "string" == typeof browsers || Array.isArray(browsers);
  }
  function semverifyTarget(target, value) {
    try {
      return (0, _utils.semverify)(value);
    } catch (error) {
      throw new Error(`Invalid Option: '${value}' is not a valid value for 'targets.${target}'.`);
    }
  }
  const targetParserMap = {
    __default: (target, value) => [ target, (0, _utils.isUnreleasedVersion)(value, target) ? value.toLowerCase() : semverifyTarget(target, value) ],
    node: (target, value) => [ target, !0 === value || "current" === value ? process.versions.node : semverifyTarget(target, value) ]
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.skipAllButComputedKey = skipAllButComputedKey, exports.default = exports.environmentVisitor = void 0;
  var _traverse = _interopRequireDefault(__webpack_require__(28)), _helperMemberExpressionToFunctions = _interopRequireDefault(__webpack_require__(148)), _helperOptimiseCallExpression = _interopRequireDefault(__webpack_require__(73)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
    objectRef = t.cloneNode(objectRef);
    const targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier("prototype"));
    return t.callExpression(file.addHelper("getPrototypeOf"), [ targetRef ]);
  }
  function skipAllButComputedKey(path) {
    if (!path.node.computed) return void path.skip();
    const keys = t.VISITOR_KEYS[path.type];
    for (const key of keys) "key" !== key && path.skipKey(key);
  }
  const environmentVisitor = {
    TypeAnnotation(path) {
      path.skip();
    },
    Function(path) {
      path.isMethod() || path.isArrowFunctionExpression() || path.skip();
    },
    "Method|ClassProperty|ClassPrivateProperty"(path) {
      skipAllButComputedKey(path);
    }
  };
  exports.environmentVisitor = environmentVisitor;
  const visitor = _traverse.default.visitors.merge([ environmentVisitor, {
    Super(path, state) {
      const {node: node, parentPath: parentPath} = path;
      parentPath.isMemberExpression({
        object: node
      }) && state.handle(parentPath);
    }
  } ]), specHandlers = {
    memoise(superMember, count) {
      const {scope: scope, node: node} = superMember, {computed: computed, property: property} = node;
      if (!computed) return;
      const memo = scope.maybeGenerateMemoised(property);
      memo && this.memoiser.set(property, memo, count);
    },
    prop(superMember) {
      const {computed: computed, property: property} = superMember.node;
      return this.memoiser.has(property) ? t.cloneNode(this.memoiser.get(property)) : computed ? t.cloneNode(property) : t.stringLiteral(property.name);
    },
    get(superMember) {
      return this._get(superMember, this._getThisRefs());
    },
    _get(superMember, thisRefs) {
      const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return t.callExpression(this.file.addHelper("get"), [ thisRefs.memo ? t.sequenceExpression([ thisRefs.memo, proto ]) : proto, this.prop(superMember), thisRefs.this ]);
    },
    _getThisRefs() {
      if (!this.isDerivedConstructor) return {
        this: t.thisExpression()
      };
      const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
      return {
        memo: t.assignmentExpression("=", thisRef, t.thisExpression()),
        this: t.cloneNode(thisRef)
      };
    },
    set(superMember, value) {
      const thisRefs = this._getThisRefs(), proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return t.callExpression(this.file.addHelper("set"), [ thisRefs.memo ? t.sequenceExpression([ thisRefs.memo, proto ]) : proto, this.prop(superMember), value, thisRefs.this, t.booleanLiteral(superMember.isInStrictMode()) ]);
    },
    destructureSet(superMember) {
      throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(superMember, args) {
      const thisRefs = this._getThisRefs();
      return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, !1);
    }
  }, looseHandlers = Object.assign({}, specHandlers, {
    prop(superMember) {
      const {property: property} = superMember.node;
      return this.memoiser.has(property) ? t.cloneNode(this.memoiser.get(property)) : t.cloneNode(property);
    },
    get(superMember) {
      const {isStatic: isStatic, superRef: superRef} = this, {computed: computed} = superMember.node, prop = this.prop(superMember);
      let object;
      return object = isStatic ? superRef ? t.cloneNode(superRef) : t.memberExpression(t.identifier("Function"), t.identifier("prototype")) : superRef ? t.memberExpression(t.cloneNode(superRef), t.identifier("prototype")) : t.memberExpression(t.identifier("Object"), t.identifier("prototype")), 
      t.memberExpression(object, prop, computed);
    },
    set(superMember, value) {
      const {computed: computed} = superMember.node, prop = this.prop(superMember);
      return t.assignmentExpression("=", t.memberExpression(t.thisExpression(), prop, computed), value);
    },
    destructureSet(superMember) {
      const {computed: computed} = superMember.node, prop = this.prop(superMember);
      return t.memberExpression(t.thisExpression(), prop, computed);
    },
    call(superMember, args) {
      return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, !1);
    }
  });
  exports.default = class {
    constructor(opts) {
      const path = opts.methodPath;
      this.methodPath = path, this.isDerivedConstructor = path.isClassMethod({
        kind: "constructor"
      }) && !!opts.superRef, this.isStatic = path.isObjectMethod() || path.node.static, 
      this.isPrivateMethod = path.isPrivate() && path.isMethod(), this.file = opts.file, 
      this.superRef = opts.superRef, this.isLoose = opts.isLoose, this.opts = opts;
    }
    getObjectRef() {
      return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
    replace() {
      const handler = this.isLoose ? looseHandlers : specHandlers;
      (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        superRef: this.superRef
      }, handler));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.wrapWithTypes = function(types, fn) {
    return function() {
      var oldTypes = currentTypes;
      currentTypes = types;
      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return fn.apply(this, args);
      } finally {
        currentTypes = oldTypes;
      }
    };
  }, exports.getTypes = getTypes, exports.runtimeProperty = function(name) {
    var t = getTypes();
    return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), !1);
  }, exports.isReference = function(path) {
    return path.isReferenced() || path.parentPath.isAssignmentExpression({
      left: path.node
    });
  }, exports.replaceWithOrRemove = function(path, replacement) {
    replacement ? path.replaceWith(replacement) : path.remove();
  };
  var currentTypes = null;
  function getTypes() {
    return currentTypes;
  }
}, function(module, exports, __webpack_require__) {
  const SemVer = __webpack_require__(77);
  module.exports = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.logUsagePolyfills = exports.logEntryPolyfills = exports.logPluginOrPolyfill = void 0;
  var _helperCompilationTargets = __webpack_require__(20);
  const wordEnds = size => size > 1 ? "s" : "", logPluginOrPolyfill = (item, targetVersions, list) => {
    const filteredList = (0, _helperCompilationTargets.getInclusionReasons)(item, targetVersions, list), formattedTargets = JSON.stringify(filteredList).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
    console.log(`  ${item} ${formattedTargets}`);
  };
  exports.logPluginOrPolyfill = logPluginOrPolyfill;
  exports.logEntryPolyfills = (polyfillName, importPolyfillIncluded, polyfills, filename, polyfillTargets, allBuiltInsList) => {
    if ("test" === process.env.BABEL_ENV && (filename = filename.replace(/\\/g, "/")), 
    importPolyfillIncluded) if (polyfills.size) {
      console.log(`\n[${filename}] Replaced ${polyfillName} entries with the following polyfill${wordEnds(polyfills.size)}:`);
      for (const polyfill of polyfills) logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    } else console.log(`\n[${filename}] Based on your targets, polyfills were not added.`); else console.log(`\n[${filename}] Import of ${polyfillName} was not found.`);
  };
  exports.logUsagePolyfills = (polyfills, filename, polyfillTargets, allBuiltInsList) => {
    if ("test" === process.env.BABEL_ENV && (filename = filename.replace(/\\/g, "/")), 
    polyfills.size) {
      console.log(`\n[${filename}] Added following core-js polyfill${wordEnds(polyfills.size)}:`);
      for (const polyfill of polyfills) logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    } else console.log(`\n[${filename}] Based on your code and targets, core-js polyfills were not added.`);
  };
}, function(module, exports) {
  module.exports = function(func) {
    return function(value) {
      return func(value);
    };
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(type, node, opts) {
    if (!node) return !1;
    if (!(0, _isType.default)(node.type, type)) return !opts && "Placeholder" === node.type && type in _definitions.FLIPPED_ALIAS_KEYS && (0, 
    _isPlaceholderType.default)(node.expectedNode, type);
    return void 0 === opts || (0, _shallowEqual.default)(node, opts);
  };
  var _shallowEqual = _interopRequireDefault(__webpack_require__(55)), _isType = _interopRequireDefault(__webpack_require__(67)), _isPlaceholderType = _interopRequireDefault(__webpack_require__(113)), _definitions = __webpack_require__(5);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(name, reserved = !0) {
    if ("string" != typeof name) return !1;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name)) return !1;
      if ("await" === name) return !1;
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  };
  var _helperValidatorIdentifier = __webpack_require__(68);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = traverse, Object.defineProperty(exports, "NodePath", {
    enumerable: !0,
    get: function() {
      return _path.default;
    }
  }), Object.defineProperty(exports, "Scope", {
    enumerable: !0,
    get: function() {
      return _scope.default;
    }
  }), Object.defineProperty(exports, "Hub", {
    enumerable: !0,
    get: function() {
      return _hub.default;
    }
  }), exports.visitors = void 0;
  var _context = _interopRequireDefault(__webpack_require__(308)), visitors = _interopRequireWildcard(__webpack_require__(363));
  exports.visitors = visitors;
  var t = _interopRequireWildcard(__webpack_require__(1)), cache = _interopRequireWildcard(__webpack_require__(44)), _path = _interopRequireDefault(__webpack_require__(10)), _scope = _interopRequireDefault(__webpack_require__(136)), _hub = _interopRequireDefault(__webpack_require__(364));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function traverse(parent, opts, scope, state, parentPath) {
    if (parent) {
      if (opts || (opts = {}), !opts.noScope && !scope && "Program" !== parent.type && "File" !== parent.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
      t.VISITOR_KEYS[parent.type] && (visitors.explode(opts), traverse.node(parent, opts, scope, state, parentPath));
    }
  }
  function hasBlacklistedType(path, state) {
    path.node.type === state.type && (state.has = !0, path.stop());
  }
  traverse.visitors = visitors, traverse.verify = visitors.verify, traverse.explode = visitors.explode, 
  traverse.cheap = function(node, enter) {
    return t.traverseFast(node, enter);
  }, traverse.node = function(node, opts, scope, state, parentPath, skipKeys) {
    const keys = t.VISITOR_KEYS[node.type];
    if (!keys) return;
    const context = new _context.default(scope, opts, state, parentPath);
    for (const key of keys) if ((!skipKeys || !skipKeys[key]) && context.visit(node, key)) return;
  }, traverse.clearNode = function(node, opts) {
    t.removeProperties(node, opts), cache.path.delete(node);
  }, traverse.removeProperties = function(tree, opts) {
    return t.traverseFast(tree, traverse.clearNode, opts), tree;
  }, traverse.hasType = function(tree, type, blacklistTypes) {
    if (null == blacklistTypes ? void 0 : blacklistTypes.includes(tree.type)) return !1;
    if (tree.type === type) return !0;
    const state = {
      has: !1,
      type: type
    };
    return traverse(tree, {
      noScope: !0,
      blacklist: blacklistTypes,
      enter: hasBlacklistedType
    }, null, state), state.has;
  }, traverse.cache = cache;
}, function(module, exports) {
  exports.getArg = function(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) return aArgs[aName];
    if (3 === arguments.length) return aDefaultValue;
    throw new Error('"' + aName + '" is a required argument.');
  };
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/, dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    return match ? {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    } : null;
  }
  function urlGenerate(aParsedUrl) {
    var url = "";
    return aParsedUrl.scheme && (url += aParsedUrl.scheme + ":"), url += "//", aParsedUrl.auth && (url += aParsedUrl.auth + "@"), 
    aParsedUrl.host && (url += aParsedUrl.host), aParsedUrl.port && (url += ":" + aParsedUrl.port), 
    aParsedUrl.path && (url += aParsedUrl.path), url;
  }
  function normalize(aPath) {
    var path = aPath, url = urlParse(aPath);
    if (url) {
      if (!url.path) return aPath;
      path = url.path;
    }
    for (var part, isAbsolute = exports.isAbsolute(path), parts = path.split(/\/+/), up = 0, i = parts.length - 1; i >= 0; i--) "." === (part = parts[i]) ? parts.splice(i, 1) : ".." === part ? up++ : up > 0 && ("" === part ? (parts.splice(i + 1, up), 
    up = 0) : (parts.splice(i, 2), up--));
    return "" === (path = parts.join("/")) && (path = isAbsolute ? "/" : "."), url ? (url.path = path, 
    urlGenerate(url)) : path;
  }
  exports.urlParse = urlParse, exports.urlGenerate = urlGenerate, exports.normalize = normalize, 
  exports.join = function(aRoot, aPath) {
    "" === aRoot && (aRoot = "."), "" === aPath && (aPath = ".");
    var aPathUrl = urlParse(aPath), aRootUrl = urlParse(aRoot);
    if (aRootUrl && (aRoot = aRootUrl.path || "/"), aPathUrl && !aPathUrl.scheme) return aRootUrl && (aPathUrl.scheme = aRootUrl.scheme), 
    urlGenerate(aPathUrl);
    if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) return aRootUrl.host = aPath, 
    urlGenerate(aRootUrl);
    var joined = "/" === aPath.charAt(0) ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    return aRootUrl ? (aRootUrl.path = joined, urlGenerate(aRootUrl)) : joined;
  }, exports.isAbsolute = function(aPath) {
    return "/" === aPath.charAt(0) || !!aPath.match(urlRegexp);
  }, exports.relative = function(aRoot, aPath) {
    "" === aRoot && (aRoot = "."), aRoot = aRoot.replace(/\/$/, "");
    for (var level = 0; 0 !== aPath.indexOf(aRoot + "/"); ) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) return aPath;
      if ((aRoot = aRoot.slice(0, index)).match(/^([^\/]+:\/)?\/*$/)) return aPath;
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  };
  var supportsNullProto = !("__proto__" in Object.create(null));
  function identity(s) {
    return s;
  }
  function isProtoString(s) {
    if (!s) return !1;
    var length = s.length;
    if (length < 9) return !1;
    if (95 !== s.charCodeAt(length - 1) || 95 !== s.charCodeAt(length - 2) || 111 !== s.charCodeAt(length - 3) || 116 !== s.charCodeAt(length - 4) || 111 !== s.charCodeAt(length - 5) || 114 !== s.charCodeAt(length - 6) || 112 !== s.charCodeAt(length - 7) || 95 !== s.charCodeAt(length - 8) || 95 !== s.charCodeAt(length - 9)) return !1;
    for (var i = length - 10; i >= 0; i--) if (36 !== s.charCodeAt(i)) return !1;
    return !0;
  }
  function strcmp(aStr1, aStr2) {
    return aStr1 === aStr2 ? 0 : aStr1 > aStr2 ? 1 : -1;
  }
  exports.toSetString = supportsNullProto ? identity : function(aStr) {
    return isProtoString(aStr) ? "$" + aStr : aStr;
  }, exports.fromSetString = supportsNullProto ? identity : function(aStr) {
    return isProtoString(aStr) ? aStr.slice(1) : aStr;
  }, exports.compareByOriginalPositions = function(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    return 0 !== cmp || 0 !== (cmp = mappingA.originalLine - mappingB.originalLine) || 0 !== (cmp = mappingA.originalColumn - mappingB.originalColumn) || onlyCompareOriginal || 0 !== (cmp = mappingA.generatedColumn - mappingB.generatedColumn) || 0 !== (cmp = mappingA.generatedLine - mappingB.generatedLine) ? cmp : mappingA.name - mappingB.name;
  }, exports.compareByGeneratedPositionsDeflated = function(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    return 0 !== cmp || 0 !== (cmp = mappingA.generatedColumn - mappingB.generatedColumn) || onlyCompareGenerated || 0 !== (cmp = mappingA.source - mappingB.source) || 0 !== (cmp = mappingA.originalLine - mappingB.originalLine) || 0 !== (cmp = mappingA.originalColumn - mappingB.originalColumn) ? cmp : mappingA.name - mappingB.name;
  }, exports.compareByGeneratedPositionsInflated = function(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    return 0 !== cmp || 0 !== (cmp = mappingA.generatedColumn - mappingB.generatedColumn) || 0 !== (cmp = strcmp(mappingA.source, mappingB.source)) || 0 !== (cmp = mappingA.originalLine - mappingB.originalLine) || 0 !== (cmp = mappingA.originalColumn - mappingB.originalColumn) ? cmp : strcmp(mappingA.name, mappingB.name);
  };
}, function(module, exports, __webpack_require__) {
  var listCacheClear = __webpack_require__(188), listCacheDelete = __webpack_require__(189), listCacheGet = __webpack_require__(190), listCacheHas = __webpack_require__(191), listCacheSet = __webpack_require__(192);
  function ListCache(entries) {
    var index = -1, length = null == entries ? 0 : entries.length;
    for (this.clear(); ++index < length; ) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, 
  ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, 
  ListCache.prototype.set = listCacheSet, module.exports = ListCache;
}, function(module, exports, __webpack_require__) {
  var eq = __webpack_require__(32);
  module.exports = function(array, key) {
    for (var length = array.length; length--; ) if (eq(array[length][0], key)) return length;
    return -1;
  };
}, function(module, exports) {
  module.exports = function(value, other) {
    return value === other || value != value && other != other;
  };
}, function(module, exports, __webpack_require__) {
  var Symbol = __webpack_require__(6).Symbol;
  module.exports = Symbol;
}, function(module, exports, __webpack_require__) {
  var nativeCreate = __webpack_require__(12)(Object, "create");
  module.exports = nativeCreate;
}, function(module, exports, __webpack_require__) {
  var isKeyable = __webpack_require__(212);
  module.exports = function(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
  };
}, function(module, exports, __webpack_require__) {
  var assignValue = __webpack_require__(101), baseAssignValue = __webpack_require__(102);
  module.exports = function(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    for (var index = -1, length = props.length; ++index < length; ) {
      var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      void 0 === newValue && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
    }
    return object;
  };
}, function(module, exports, __webpack_require__) {
  (function(module) {
    var freeGlobal = __webpack_require__(98), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        return types || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {}
    }();
    module.exports = nodeUtil;
  }).call(this, __webpack_require__(58)(module));
}, function(module, exports, __webpack_require__) {
  var arrayLikeKeys = __webpack_require__(104), baseKeysIn = __webpack_require__(226), isArrayLike = __webpack_require__(62);
  module.exports = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;
  var _is = _interopRequireDefault(__webpack_require__(26)), _isValidIdentifier = _interopRequireDefault(__webpack_require__(27)), _helperValidatorIdentifier = __webpack_require__(68), _constants = __webpack_require__(16), _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  (0, _utils.default)("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: [ "elements" ],
    aliases: [ "Expression" ]
  }), (0, _utils.default)("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) return (0, _utils.assertValueType)("string");
          const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS), pattern = (0, 
          _utils.assertOneOf)("=");
          return function(node, key, val) {
            ((0, _is.default)("Pattern", node.left) ? pattern : identifier)(node, key, val);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0, 
        _utils.assertNodeType)("LVal")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: [ "operator", "left", "right" ],
    visitor: [ "left", "right" ],
    aliases: [ "Expression" ]
  }), (0, _utils.default)("BinaryExpression", {
    builder: [ "operator", "left", "right" ],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const expression = (0, _utils.assertNodeType)("Expression"), inOp = (0, _utils.assertNodeType)("Expression", "PrivateName"), validator = function(node, key, val) {
            ("in" === node.operator ? inOp : expression)(node, key, val);
          };
          return validator.oneOfNodeTypes = [ "Expression", "PrivateName" ], validator;
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: [ "left", "right" ],
    aliases: [ "Binary", "Expression" ]
  }), (0, _utils.default)("InterpreterDirective", {
    builder: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  }), (0, _utils.default)("Directive", {
    visitor: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  }), (0, _utils.default)("DirectiveLiteral", {
    builder: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  }), (0, _utils.default)("BlockStatement", {
    builder: [ "body", "directives" ],
    visitor: [ "directives", "body" ],
    fields: {
      directives: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Statement")))
      }
    },
    aliases: [ "Scopable", "BlockParent", "Block", "Statement" ]
  }), (0, _utils.default)("BreakStatement", {
    visitor: [ "label" ],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: [ "Statement", "Terminatorless", "CompletionStatement" ]
  }), (0, _utils.default)("CallExpression", {
    visitor: [ "callee", "arguments", "typeParameters", "typeArguments" ],
    builder: [ "callee", "arguments" ],
    aliases: [ "Expression" ],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, _utils.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  }), (0, _utils.default)("CatchClause", {
    visitor: [ "param", "body" ],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: [ "Scopable", "BlockParent" ]
  }), (0, _utils.default)("ConditionalExpression", {
    visitor: [ "test", "consequent", "alternate" ],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: [ "Expression", "Conditional" ]
  }), (0, _utils.default)("ContinueStatement", {
    visitor: [ "label" ],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: [ "Statement", "Terminatorless", "CompletionStatement" ]
  }), (0, _utils.default)("DebuggerStatement", {
    aliases: [ "Statement" ]
  }), (0, _utils.default)("DoWhileStatement", {
    visitor: [ "test", "body" ],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: [ "Statement", "BlockParent", "Loop", "While", "Scopable" ]
  }), (0, _utils.default)("EmptyStatement", {
    aliases: [ "Statement" ]
  }), (0, _utils.default)("ExpressionStatement", {
    visitor: [ "expression" ],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: [ "Statement", "ExpressionWrapper" ]
  }), (0, _utils.default)("File", {
    builder: [ "program", "comments", "tokens" ],
    visitor: [ "program" ],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {}, {
          each: {
            oneOfNodeTypes: [ "CommentBlock", "CommentLine" ]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(() => {}, {
          type: "any"
        })),
        optional: !0
      }
    }
  }), (0, _utils.default)("ForInStatement", {
    visitor: [ "left", "right", "body" ],
    aliases: [ "Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement" ],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern") : (0, 
        _utils.assertNodeType)("VariableDeclaration", "LVal")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  }), (0, _utils.default)("ForStatement", {
    visitor: [ "init", "test", "update", "body" ],
    aliases: [ "Scopable", "Statement", "For", "BlockParent", "Loop" ],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  const functionCommon = {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
      _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  };
  exports.functionCommon = functionCommon;
  const functionTypeAnnotationCommon = {
    returnType: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  };
  exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  const functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: !0
    }
  });
  exports.functionDeclarationCommon = functionDeclarationCommon, (0, _utils.default)("FunctionDeclaration", {
    builder: [ "id", "params", "body", "generator", "async" ],
    visitor: [ "id", "params", "body", "returnType", "typeParameters" ],
    fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    aliases: [ "Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration" ],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node) {
        (0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id);
      };
    }()
  }), (0, _utils.default)("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: [ "Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish" ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  const patternLikeCommon = {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
      _utils.assertNodeType)("Decorator")))
    }
  };
  exports.patternLikeCommon = patternLikeCommon, (0, _utils.default)("Identifier", {
    builder: [ "name" ],
    visitor: [ "typeAnnotation", "decorators" ],
    aliases: [ "Expression", "PatternLike", "LVal", "TSEntityName" ],
    fields: Object.assign({}, patternLikeCommon, {
      name: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign((function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, _isValidIdentifier.default)(val, !1)) throw new TypeError(`"${val}" is not a valid identifier name`);
        }), {
          type: "string"
        }))
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      }
    }),
    validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const match = /\.(\w+)$/.exec(key);
      if (!match) return;
      const [, parentKey] = match, nonComp = {
        computed: !1
      };
      if ("property" === parentKey) {
        if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
        if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
      } else if ("key" === parentKey) {
        if ((0, _is.default)("Property", parent, nonComp)) return;
        if ((0, _is.default)("Method", parent, nonComp)) return;
      } else if ("exported" === parentKey) {
        if ((0, _is.default)("ExportSpecifier", parent)) return;
      } else if ("imported" === parentKey) {
        if ((0, _is.default)("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if ("meta" === parentKey && (0, _is.default)("MetaProperty", parent, {
        meta: node
      })) return;
      if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && "this" !== node.name) throw new TypeError(`"${node.name}" is not a valid identifier`);
    }
  }), (0, _utils.default)("IfStatement", {
    visitor: [ "test", "consequent", "alternate" ],
    aliases: [ "Statement", "Conditional" ],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  }), (0, _utils.default)("LabeledStatement", {
    visitor: [ "label", "body" ],
    aliases: [ "Statement" ],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  }), (0, _utils.default)("StringLiteral", {
    builder: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
  }), (0, _utils.default)("NumericLiteral", {
    builder: [ "value" ],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("number")
      }
    },
    aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
  }), (0, _utils.default)("NullLiteral", {
    aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
  }), (0, _utils.default)("BooleanLiteral", {
    builder: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
  }), (0, _utils.default)("RegExpLiteral", {
    builder: [ "pattern", "flags" ],
    deprecatedAlias: "RegexLiteral",
    aliases: [ "Expression", "Pureish", "Literal" ],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign((function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          const invalid = /[^gimsuy]/.exec(val);
          if (invalid) throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }), {
          type: "string"
        })),
        default: ""
      }
    }
  }), (0, _utils.default)("LogicalExpression", {
    builder: [ "operator", "left", "right" ],
    visitor: [ "left", "right" ],
    aliases: [ "Binary", "Expression" ],
    fields: {
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("MemberExpression", {
    builder: [ "object", "property", "computed", "optional" ],
    visitor: [ "object", "property" ],
    aliases: [ "Expression", "LVal" ],
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName"), computed = (0, 
          _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = [ "Expression", "Identifier", "PrivateName" ], 
          validator;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, _utils.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  }), (0, _utils.default)("NewExpression", {
    inherits: "CallExpression"
  }), (0, _utils.default)("Program", {
    visitor: [ "directives", "body" ],
    builder: [ "body", "directives", "sourceType", "interpreter" ],
    fields: {
      sourceFile: {
        validate: (0, _utils.assertValueType)("string")
      },
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Statement")))
      }
    },
    aliases: [ "Scopable", "BlockParent", "Block" ]
  }), (0, _utils.default)("ObjectExpression", {
    visitor: [ "properties" ],
    aliases: [ "Expression" ],
    fields: {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  }), (0, _utils.default)("ObjectMethod", {
    builder: [ "kind", "key", "params", "body", "computed", "generator", "async" ],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, 
          _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = [ "Expression", "Identifier", "StringLiteral", "NumericLiteral" ], 
          validator;
        }()
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    visitor: [ "key", "params", "body", "decorators", "returnType", "typeParameters" ],
    aliases: [ "UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember" ]
  }), (0, _utils.default)("ObjectProperty", {
    builder: [ "key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : [ "decorators" ] ],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, 
          _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = [ "Expression", "Identifier", "StringLiteral", "NumericLiteral" ], 
          validator;
        }()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign((function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }), {
          type: "boolean"
        }), (function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && !(0, _is.default)("Identifier", node.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        })),
        default: !1
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: [ "key", "value", "decorators" ],
    aliases: [ "UserWhitespacable", "Property", "ObjectMember" ],
    validate: function() {
      const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern"), expression = (0, 
      _utils.assertNodeType)("Expression");
      return function(parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        ((0, _is.default)("ObjectPattern", parent) ? pattern : expression)(node, "value", node.value);
      };
    }()
  }), (0, _utils.default)("RestElement", {
    visitor: [ "argument", "typeAnnotation" ],
    builder: [ "argument" ],
    aliases: [ "LVal", "PatternLike" ],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "Pattern", "MemberExpression") : (0, 
        _utils.assertNodeType)("LVal")
      }
    }),
    validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;
      if (parent[listKey].length > index + 1) throw new TypeError("RestElement must be last element of " + listKey);
    }
  }), (0, _utils.default)("ReturnStatement", {
    visitor: [ "argument" ],
    aliases: [ "Statement", "Terminatorless", "CompletionStatement" ],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), (0, _utils.default)("SequenceExpression", {
    visitor: [ "expressions" ],
    fields: {
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Expression")))
      }
    },
    aliases: [ "Expression" ]
  }), (0, _utils.default)("ParenthesizedExpression", {
    visitor: [ "expression" ],
    aliases: [ "Expression", "ExpressionWrapper" ],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("SwitchCase", {
    visitor: [ "test", "consequent" ],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Statement")))
      }
    }
  }), (0, _utils.default)("SwitchStatement", {
    visitor: [ "discriminant", "cases" ],
    aliases: [ "Statement", "BlockParent", "Scopable" ],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("SwitchCase")))
      }
    }
  }), (0, _utils.default)("ThisExpression", {
    aliases: [ "Expression" ]
  }), (0, _utils.default)("ThrowStatement", {
    visitor: [ "argument" ],
    aliases: [ "Statement", "Terminatorless", "CompletionStatement" ],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("TryStatement", {
    visitor: [ "block", "handler", "finalizer" ],
    aliases: [ "Statement" ],
    fields: {
      block: {
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign((function(node) {
          if (process.env.BABEL_TYPES_8_BREAKING && !node.handler && !node.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }), {
          oneOfNodeTypes: [ "BlockStatement" ]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  }), (0, _utils.default)("UnaryExpression", {
    builder: [ "operator", "argument", "prefix" ],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
      }
    },
    visitor: [ "argument" ],
    aliases: [ "UnaryLike", "Expression" ]
  }), (0, _utils.default)("UpdateExpression", {
    builder: [ "operator", "argument", "prefix" ],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Identifier", "MemberExpression") : (0, 
        _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
      }
    },
    visitor: [ "argument" ],
    aliases: [ "Expression" ]
  }), (0, _utils.default)("VariableDeclaration", {
    builder: [ "kind", "declarations" ],
    visitor: [ "declarations" ],
    aliases: [ "Statement", "Declaration" ],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const")
      },
      declarations: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(parent, key, node) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, _is.default)("ForXStatement", parent, {
        left: node
      }) && 1 !== node.declarations.length) throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
    }
  }), (0, _utils.default)("VariableDeclarator", {
    visitor: [ "id", "init" ],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) return (0, _utils.assertNodeType)("LVal");
          const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), without = (0, 
          _utils.assertNodeType)("Identifier");
          return function(node, key, val) {
            (node.init ? normal : without)(node, key, val);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("WhileStatement", {
    visitor: [ "test", "body" ],
    aliases: [ "Statement", "BlockParent", "Loop", "While", "Scopable" ],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  }), (0, _utils.default)("WithStatement", {
    visitor: [ "object", "body" ],
    aliases: [ "Statement" ],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = getBindingIdentifiers;
  var _generated = __webpack_require__(3);
  function getBindingIdentifiers(node, duplicates, outerOnly) {
    let search = [].concat(node);
    const ids = Object.create(null);
    for (;search.length; ) {
      const id = search.shift();
      if (!id) continue;
      const keys = getBindingIdentifiers.keys[id.type];
      if ((0, _generated.isIdentifier)(id)) if (duplicates) {
        (ids[id.name] = ids[id.name] || []).push(id);
      } else ids[id.name] = id; else if ((0, _generated.isExportDeclaration)(id)) (0, 
      _generated.isDeclaration)(id.declaration) && search.push(id.declaration); else {
        if (outerOnly) {
          if ((0, _generated.isFunctionDeclaration)(id)) {
            search.push(id.id);
            continue;
          }
          if ((0, _generated.isFunctionExpression)(id)) continue;
        }
        if (keys) for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          id[key] && (search = search.concat(id[key]));
        }
      }
    }
    return ids;
  }
  getBindingIdentifiers.keys = {
    DeclareClass: [ "id" ],
    DeclareFunction: [ "id" ],
    DeclareModule: [ "id" ],
    DeclareVariable: [ "id" ],
    DeclareInterface: [ "id" ],
    DeclareTypeAlias: [ "id" ],
    DeclareOpaqueType: [ "id" ],
    InterfaceDeclaration: [ "id" ],
    TypeAlias: [ "id" ],
    OpaqueType: [ "id" ],
    CatchClause: [ "param" ],
    LabeledStatement: [ "label" ],
    UnaryExpression: [ "argument" ],
    AssignmentExpression: [ "left" ],
    ImportSpecifier: [ "local" ],
    ImportNamespaceSpecifier: [ "local" ],
    ImportDefaultSpecifier: [ "local" ],
    ImportDeclaration: [ "specifiers" ],
    ExportSpecifier: [ "exported" ],
    ExportNamespaceSpecifier: [ "exported" ],
    ExportDefaultSpecifier: [ "exported" ],
    FunctionDeclaration: [ "id", "params" ],
    FunctionExpression: [ "id", "params" ],
    ArrowFunctionExpression: [ "params" ],
    ObjectMethod: [ "params" ],
    ClassMethod: [ "params" ],
    ForInStatement: [ "left" ],
    ForOfStatement: [ "left" ],
    ClassDeclaration: [ "id" ],
    ClassExpression: [ "id" ],
    RestElement: [ "argument" ],
    UpdateExpression: [ "argument" ],
    ObjectProperty: [ "value" ],
    AssignmentPattern: [ "left" ],
    ArrayPattern: [ "elements" ],
    ObjectPattern: [ "properties" ],
    VariableDeclaration: [ "declarations" ],
    VariableDeclarator: [ "id" ]
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = exports.program = exports.expression = exports.statements = exports.statement = exports.smart = void 0;
  var obj, formatters = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(298)), _builder = (obj = __webpack_require__(299)) && obj.__esModule ? obj : {
    default: obj
  };
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const smart = (0, _builder.default)(formatters.smart);
  exports.smart = smart;
  const statement = (0, _builder.default)(formatters.statement);
  exports.statement = statement;
  const statements = (0, _builder.default)(formatters.statements);
  exports.statements = statements;
  const expression = (0, _builder.default)(formatters.expression);
  exports.expression = expression;
  const program = (0, _builder.default)(formatters.program);
  exports.program = program;
  var _default = Object.assign(smart.bind(void 0), {
    smart: smart,
    statement: statement,
    statements: statements,
    expression: expression,
    program: program,
    ast: smart.ast
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(pathOrNode) {
    const node = pathOrNode.node || pathOrNode;
    if ((({leadingComments: leadingComments}) => !!leadingComments && leadingComments.some(comment => /[@#]__PURE__/.test(comment.value)))(node)) return;
    t.addComment(node, "leading", "#__PURE__");
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration()) throw new Error("Only export declarations can be splitted.");
    const isDefault = exportDeclaration.isExportDefaultDeclaration(), declaration = exportDeclaration.get("declaration"), isClassDeclaration = declaration.isClassDeclaration();
    if (isDefault) {
      const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration, scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      let id = declaration.node.id, needBindingRegistration = !1;
      id || (needBindingRegistration = !0, id = scope.generateUidIdentifier("default"), 
      (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) && (declaration.node.id = t.cloneNode(id)));
      const updatedDeclaration = standaloneDeclaration ? declaration : t.variableDeclaration("var", [ t.variableDeclarator(t.cloneNode(id), declaration.node) ]), updatedExportDeclaration = t.exportNamedDeclaration(null, [ t.exportSpecifier(t.cloneNode(id), t.identifier("default")) ]);
      return exportDeclaration.insertAfter(updatedExportDeclaration), exportDeclaration.replaceWith(updatedDeclaration), 
      needBindingRegistration && scope.registerDeclaration(exportDeclaration), exportDeclaration;
    }
    if (exportDeclaration.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
    const bindingIdentifiers = declaration.getOuterBindingIdentifiers(), specifiers = Object.keys(bindingIdentifiers).map(name => t.exportSpecifier(t.identifier(name), t.identifier(name))), aliasDeclar = t.exportNamedDeclaration(null, specifiers);
    return exportDeclaration.insertAfter(aliasDeclar), exportDeclaration.replaceWith(declaration.node), 
    exportDeclaration;
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.clear = function() {
    clearPath(), clearScope();
  }, exports.clearPath = clearPath, exports.clearScope = clearScope, exports.scope = exports.path = void 0;
  let path = new WeakMap;
  exports.path = path;
  let scope = new WeakMap;
  function clearPath() {
    exports.path = path = new WeakMap;
  }
  function clearScope() {
    exports.scope = scope = new WeakMap;
  }
  exports.scope = scope;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.createRegExpFeaturePlugin = function({name: name, feature: feature, options: options = {}}) {
    return {
      name: name,
      pre() {
        var _file$get;
        const {file: file} = this, features = null != (_file$get = file.get(_features.featuresKey)) ? _file$get : 0;
        let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);
        const {useUnicodeFlag: useUnicodeFlag, runtime: runtime = !0} = options;
        !1 === useUnicodeFlag && (newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag)), 
        newFeatures !== features && file.set(_features.featuresKey, newFeatures), runtime || file.set(_features.runtimeKey, !1), 
        (!file.has(versionKey) || file.get(versionKey) < version) && file.set(versionKey, version);
      },
      visitor: {
        RegExpLiteral(path) {
          var _file$get2;
          const {node: node} = path, {file: file} = this, features = file.get(_features.featuresKey), runtime = null == (_file$get2 = file.get(_features.runtimeKey)) || _file$get2, regexpuOptions = (0, 
          _util.generateRegexpuOptions)(node, features);
          if (null === regexpuOptions) return;
          const namedCaptureGroups = {};
          if (regexpuOptions.namedGroup && (regexpuOptions.onNamedGroup = (name, index) => {
            namedCaptureGroups[name] = index;
          }), node.pattern = (0, _regexpuCore.default)(node.pattern, node.flags, regexpuOptions), 
          regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !function(path) {
            return path.parentPath.isMemberExpression({
              object: path.node,
              computed: !1
            }) && path.parentPath.get("property").isIdentifier({
              name: "test"
            });
          }(path)) {
            const call = _core.types.callExpression(this.addHelper("wrapRegExp"), [ node, _core.types.valueToNode(namedCaptureGroups) ]);
            (0, _helperAnnotateAsPure.default)(call), path.replaceWith(call);
          }
          (0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag) && (0, _helperRegex.pullFlag)(node, "u"), 
          (0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag) && (0, _helperRegex.pullFlag)(node, "s");
        }
      }
    };
  };
  var _regexpuCore = _interopRequireDefault(__webpack_require__(381)), _features = __webpack_require__(151), _util = __webpack_require__(382), _package = _interopRequireDefault(__webpack_require__(383)), _core = __webpack_require__(2), _helperRegex = __webpack_require__(152), _helperAnnotateAsPure = _interopRequireDefault(__webpack_require__(42));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const version = _package.default.version.split(".").reduce((v, x) => 1e5 * v + +x, 0), versionKey = "@babel/plugin-regexp-features/version";
}, function(module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(13), isObjectLike = __webpack_require__(9);
  module.exports = function(value) {
    return "symbol" == typeof value || isObjectLike(value) && "[object Symbol]" == baseGetTag(value);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.rewriteModuleStatementsAndPrepareHeader = function(path, {exportName: exportName, strict: strict, allowTopLevelThis: allowTopLevelThis, strictMode: strictMode, loose: loose, noInterop: noInterop, lazy: lazy, esNamespaceOnly: esNamespaceOnly}) {
    (0, _assert.default)((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script"), 
    path.node.sourceType = "script";
    const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
      noInterop: noInterop,
      loose: loose,
      lazy: lazy,
      esNamespaceOnly: esNamespaceOnly
    });
    allowTopLevelThis || (0, _rewriteThis.default)(path);
    if ((0, _rewriteLiveReferences.default)(path, meta), !1 !== strictMode) {
      path.node.directives.some(directive => "use strict" === directive.value.value) || path.unshiftContainer("directives", t.directive(t.directiveLiteral("use strict")));
    }
    const headers = [];
    (0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict && headers.push(function(metadata, enumerable = !1) {
      return (enumerable ? _template.default.statement`
        EXPORTS.__esModule = true;
      ` : _template.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
        EXPORTS: metadata.exportName
      });
    }(meta, loose));
    const nameList = function(programPath, metadata) {
      const exportedVars = Object.create(null);
      for (const data of metadata.local.values()) for (const name of data.names) exportedVars[name] = !0;
      let hasReexport = !1;
      for (const data of metadata.source.values()) {
        for (const exportName of data.reexports.keys()) exportedVars[exportName] = !0;
        for (const exportName of data.reexportNamespace) exportedVars[exportName] = !0;
        hasReexport = hasReexport || data.reexportAll;
      }
      if (!hasReexport || 0 === Object.keys(exportedVars).length) return null;
      const name = programPath.scope.generateUidIdentifier("exportNames");
      return delete exportedVars.default, {
        name: name.name,
        statement: t.variableDeclaration("var", [ t.variableDeclarator(name, t.valueToNode(exportedVars)) ])
      };
    }(path, meta);
    nameList && (meta.exportNameListName = nameList.name, headers.push(nameList.statement));
    return headers.push(...function(programPath, metadata, loose = !1) {
      const initStatements = [], exportNames = [];
      for (const [localName, data] of metadata.local) "import" === data.kind || ("hoisted" === data.kind ? initStatements.push(buildInitStatement(metadata, data.names, t.identifier(localName))) : exportNames.push(...data.names));
      for (const data of metadata.source.values()) {
        loose || initStatements.push(...buildReexportsFromMeta(metadata, data, loose));
        for (const exportName of data.reexportNamespace) exportNames.push(exportName);
      }
      return initStatements.push(...(0, _chunk.default)(exportNames, 100).map(members => buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode()))), 
      initStatements;
    }(path, meta, loose)), {
      meta: meta,
      headers: headers
    };
  }, exports.ensureStatementsHoisted = function(statements) {
    statements.forEach(header => {
      header._blockHoist = 3;
    });
  }, exports.wrapInterop = function(programPath, expr, type) {
    if ("none" === type) return null;
    let helper;
    if ("default" === type) helper = "interopRequireDefault"; else {
      if ("namespace" !== type) throw new Error("Unknown interop: " + type);
      helper = "interopRequireWildcard";
    }
    return t.callExpression(programPath.hub.addHelper(helper), [ expr ]);
  }, exports.buildNamespaceInitStatements = function(metadata, sourceMetadata, loose = !1) {
    const statements = [];
    let srcNamespace = t.identifier(sourceMetadata.name);
    sourceMetadata.lazy && (srcNamespace = t.callExpression(srcNamespace, []));
    for (const localName of sourceMetadata.importsNamespace) localName !== sourceMetadata.name && statements.push(_template.default.statement`var NAME = SOURCE;`({
      NAME: localName,
      SOURCE: t.cloneNode(srcNamespace)
    }));
    loose && statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, loose));
    for (const exportName of sourceMetadata.reexportNamespace) statements.push((sourceMetadata.lazy ? _template.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({
      EXPORTS: metadata.exportName,
      NAME: exportName,
      NAMESPACE: t.cloneNode(srcNamespace)
    }));
    if (sourceMetadata.reexportAll) {
      const statement = function(metadata, namespace, loose) {
        return (loose ? _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _template.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
          NAMESPACE: namespace,
          EXPORTS: metadata.exportName,
          VERIFY_NAME_LIST: metadata.exportNameListName ? _template.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
            EXPORTS_LIST: metadata.exportNameListName
          }) : null
        });
      }(metadata, t.cloneNode(srcNamespace), loose);
      statement.loc = sourceMetadata.reexportAll.loc, statements.push(statement);
    }
    return statements;
  }, Object.defineProperty(exports, "isModule", {
    enumerable: !0,
    get: function() {
      return _helperModuleImports.isModule;
    }
  }), Object.defineProperty(exports, "rewriteThis", {
    enumerable: !0,
    get: function() {
      return _rewriteThis.default;
    }
  }), Object.defineProperty(exports, "hasExports", {
    enumerable: !0,
    get: function() {
      return _normalizeAndLoadMetadata.hasExports;
    }
  }), Object.defineProperty(exports, "isSideEffectImport", {
    enumerable: !0,
    get: function() {
      return _normalizeAndLoadMetadata.isSideEffectImport;
    }
  }), Object.defineProperty(exports, "getModuleName", {
    enumerable: !0,
    get: function() {
      return _getModuleName.default;
    }
  });
  var _assert = _interopRequireDefault(__webpack_require__(11)), t = _interopRequireWildcard(__webpack_require__(1)), _template = _interopRequireDefault(__webpack_require__(41)), _chunk = _interopRequireDefault(__webpack_require__(427)), _helperModuleImports = __webpack_require__(74), _rewriteThis = _interopRequireDefault(__webpack_require__(432)), _rewriteLiveReferences = _interopRequireDefault(__webpack_require__(433)), _normalizeAndLoadMetadata = _interopRequireWildcard(__webpack_require__(434)), _getModuleName = _interopRequireDefault(__webpack_require__(435));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const buildReexportsFromMeta = (meta, metadata, loose) => {
    const namespace = metadata.lazy ? t.callExpression(t.identifier(metadata.name), []) : t.identifier(metadata.name), templateForCurrentMode = (loose => loose ? _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE.IMPORT_NAME;` : _template.default`
      Object.defineProperty(EXPORTS, "EXPORT_NAME", {
        enumerable: true,
        get: function() {
          return NAMESPACE.IMPORT_NAME;
        },
      });
    `)(loose);
    return Array.from(metadata.reexports, ([exportName, importName]) => templateForCurrentMode({
      EXPORTS: meta.exportName,
      EXPORT_NAME: exportName,
      NAMESPACE: t.cloneNode(namespace),
      IMPORT_NAME: importName
    }));
  };
  function buildInitStatement(metadata, exportNames, initExpr) {
    return t.expressionStatement(exportNames.reduce((acc, exportName) => _template.default.expression`EXPORTS.NAME = VALUE`({
      EXPORTS: metadata.exportName,
      NAME: exportName,
      VALUE: acc
    }), initExpr));
  }
}, function(module, exports, __webpack_require__) {
  var _typeof = __webpack_require__(448);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  module.exports = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" !== _typeof(obj) && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  };
}, function(module, exports) {
  module.exports = function(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var NODE_ENV = process.env.NODE_ENV;
  module.exports = function(condition, format, a, b, c, d, e, f) {
    if ("production" !== NODE_ENV && void 0 === format) throw new Error("invariant requires an error message argument");
    if (!condition) {
      var error;
      if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
        var args = [ a, b, c, d, e, f ], argIndex = 0;
        (error = new Error(format.replace(/%s/g, (function() {
          return args[argIndex++];
        })))).name = "Invariant Violation";
      }
      throw error.framesToPop = 1, error;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.semverMin = semverMin, exports.semverify = function(version) {
    if ("string" == typeof version && _semver.default.valid(version)) return version;
    (0, _invariant.default)("number" == typeof version || "string" == typeof version && versionRegExp.test(version), `'${version}' is not a valid version`);
    const split = version.toString().split(".");
    for (;split.length < 3; ) split.push("0");
    return split.join(".");
  }, exports.isUnreleasedVersion = function(version, env) {
    const unreleasedLabel = _targets.unreleasedLabels[env];
    return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
  }, exports.getLowestUnreleased = function(a, b, env) {
    const unreleasedLabel = _targets.unreleasedLabels[env], hasUnreleased = [ a, b ].some(item => item === unreleasedLabel);
    if (hasUnreleased) return a === hasUnreleased ? b : a || b;
    return semverMin(a, b);
  }, exports.getLowestImplementedVersion = function(plugin, environment) {
    const result = plugin[environment];
    if (!result && "android" === environment) return plugin.chrome;
    return result;
  };
  var _invariant = _interopRequireDefault(__webpack_require__(50)), _semver = _interopRequireDefault(__webpack_require__(19)), _targets = __webpack_require__(52);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const versionRegExp = /^(\d+|\d+.\d+)$/;
  function semverMin(first, second) {
    return first && _semver.default.lt(first, second) ? first : second;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.browserNameMap = exports.unreleasedLabels = void 0;
  exports.unreleasedLabels = {
    safari: "tp"
  };
  exports.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    op_mob: "opera",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
}, function(module) {
  module.exports = JSON.parse('{"es.symbol":{"chrome":"49","edge":"15","electron":"0.37","firefox":"51","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.symbol.description":{"chrome":"70","edge":"74","electron":"5.0","firefox":"63","ios":"12.2","node":"11.0","opera":"57","opera_mobile":"49","safari":"12.1","samsung":"10.0"},"es.symbol.async-iterator":{"chrome":"63","edge":"74","electron":"3.0","firefox":"55","ios":"12.0","node":"10.0","opera":"50","opera_mobile":"46","safari":"12.0","samsung":"8.0"},"es.symbol.has-instance":{"chrome":"50","edge":"15","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.symbol.is-concat-spreadable":{"chrome":"48","edge":"15","electron":"0.37","firefox":"48","ios":"10.0","node":"6.0","opera":"35","opera_mobile":"35","safari":"10.0","samsung":"5.0"},"es.symbol.iterator":{"chrome":"39","edge":"13","electron":"0.20","firefox":"36","ios":"9.0","node":"1.0","opera":"26","opera_mobile":"26","safari":"9.0","samsung":"3.4"},"es.symbol.match":{"chrome":"50","edge":"74","electron":"1.1","firefox":"40","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.symbol.match-all":{"chrome":"73","edge":"74","electron":"5.0","firefox":"67","ios":"13.0","node":"12.0","opera":"60","opera_mobile":"52","safari":"13","samsung":"11.0"},"es.symbol.replace":{"chrome":"50","edge":"74","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.symbol.search":{"chrome":"50","edge":"74","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.symbol.species":{"chrome":"51","edge":"13","electron":"1.2","firefox":"41","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.symbol.split":{"chrome":"50","edge":"74","electron":"1.1","firefox":"49","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.symbol.to-primitive":{"chrome":"47","edge":"15","electron":"0.36","firefox":"44","ios":"10.0","node":"6.0","opera":"34","opera_mobile":"34","safari":"10.0","samsung":"5.0"},"es.symbol.to-string-tag":{"chrome":"49","edge":"15","electron":"0.37","firefox":"51","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.symbol.unscopables":{"chrome":"39","edge":"13","electron":"0.20","firefox":"48","ios":"9.0","node":"1.0","opera":"26","opera_mobile":"26","safari":"9.0","samsung":"3.4"},"es.array.concat":{"chrome":"51","edge":"15","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.copy-within":{"chrome":"45","edge":"12","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.every":{"chrome":"48","edge":"15","electron":"0.37","firefox":"50","ios":"9.0","node":"6.0","opera":"35","opera_mobile":"35","safari":"9.0","samsung":"5.0"},"es.array.fill":{"chrome":"45","edge":"12","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.filter":{"chrome":"51","edge":"15","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.find":{"chrome":"45","edge":"13","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.find-index":{"chrome":"45","edge":"13","electron":"0.31","firefox":"48","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.flat":{"chrome":"69","edge":"74","electron":"4.0","firefox":"62","ios":"12.0","node":"11.0","opera":"56","opera_mobile":"48","safari":"12.0","samsung":"10.0"},"es.array.flat-map":{"chrome":"69","edge":"74","electron":"4.0","firefox":"62","ios":"12.0","node":"11.0","opera":"56","opera_mobile":"48","safari":"12.0","samsung":"10.0"},"es.array.for-each":{"chrome":"48","edge":"15","electron":"0.37","firefox":"50","ios":"9.0","node":"6.0","opera":"35","opera_mobile":"35","safari":"9.0","samsung":"5.0"},"es.array.from":{"chrome":"51","edge":"15","electron":"1.2","firefox":"53","ios":"9.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"9.0","samsung":"5.0"},"es.array.includes":{"chrome":"53","edge":"15","electron":"1.4","firefox":"48","ios":"10.0","node":"7.0","opera":"40","opera_mobile":"40","safari":"10.0","samsung":"6.0"},"es.array.index-of":{"chrome":"51","edge":"15","electron":"1.2","firefox":"50","ios":"11.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"11.0","samsung":"5.0"},"es.array.is-array":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"3.2","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"4.0","samsung":"1.0"},"es.array.iterator":{"chrome":"66","edge":"15","electron":"3.0","firefox":"60","ios":"10.0","node":"10.0","opera":"53","opera_mobile":"47","safari":"10.0","samsung":"9.0"},"es.array.join":{"android":"4.4","chrome":"26","edge":"13","electron":"0.20","firefox":"4","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.array.last-index-of":{"chrome":"51","edge":"13","electron":"1.2","firefox":"50","ios":"11.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"11.0","samsung":"5.0"},"es.array.map":{"chrome":"51","edge":"13","electron":"1.2","firefox":"50","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.of":{"chrome":"45","edge":"13","electron":"0.31","firefox":"25","ios":"9.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"9.0","samsung":"5.0"},"es.array.reduce":{"chrome":"48","edge":"15","electron":"0.37","firefox":"50","ios":"9.0","node":"6.0","opera":"35","opera_mobile":"35","safari":"9.0","samsung":"5.0"},"es.array.reduce-right":{"chrome":"48","edge":"15","electron":"0.37","firefox":"50","ios":"9.0","node":"6.0","opera":"35","opera_mobile":"35","safari":"9.0","samsung":"5.0"},"es.array.reverse":{"android":"3.0","chrome":"1","edge":"12","electron":"0.20","firefox":"1","ie":"5.5","ios":"12.2","node":"0.0.3","opera":"10.50","opera_mobile":"10.50","safari":"12.0.2","samsung":"1.0"},"es.array.slice":{"chrome":"51","edge":"15","electron":"1.2","firefox":"48","ios":"11.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"11.0","samsung":"5.0"},"es.array.some":{"chrome":"48","edge":"15","electron":"0.37","firefox":"50","ios":"9.0","node":"6.0","opera":"35","opera_mobile":"35","safari":"9.0","samsung":"5.0"},"es.array.sort":{"chrome":"63","edge":"12","electron":"3.0","firefox":"4","ie":"9","ios":"12.0","node":"10.0","opera":"50","opera_mobile":"46","safari":"12.0","samsung":"8.0"},"es.array.species":{"chrome":"51","edge":"13","electron":"1.2","firefox":"48","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.array.splice":{"chrome":"51","edge":"15","electron":"1.2","firefox":"49","ios":"11.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"11.0","samsung":"5.0"},"es.array.unscopables.flat":{"chrome":"73","edge":"74","electron":"5.0","firefox":"67","ios":"13.0","node":"12.0","opera":"60","opera_mobile":"52","safari":"13","samsung":"11.0"},"es.array.unscopables.flat-map":{"chrome":"73","edge":"74","electron":"5.0","firefox":"67","ios":"13.0","node":"12.0","opera":"60","opera_mobile":"52","safari":"13","samsung":"11.0"},"es.array-buffer.constructor":{"android":"4.4","chrome":"26","edge":"14","electron":"0.20","firefox":"44","ios":"12.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"12.0","samsung":"1.5"},"es.array-buffer.is-view":{"android":"4.4.3","chrome":"32","edge":"12","electron":"0.20","firefox":"29","ie":"11","ios":"8.0","node":"0.11.9","opera":"19","opera_mobile":"19","safari":"7.1","samsung":"2.0"},"es.array-buffer.slice":{"android":"4.4.3","chrome":"31","edge":"12","electron":"0.20","firefox":"46","ie":"11","ios":"12.2","node":"0.11.8","opera":"18","opera_mobile":"18","safari":"12.1","samsung":"2.0"},"es.data-view":{"android":"4.4","chrome":"26","edge":"12","electron":"0.20","firefox":"15","ie":"10","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.date.now":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ie":"9","ios":"3.2","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"4.0","samsung":"1.0"},"es.date.to-iso-string":{"android":"4.4","chrome":"26","edge":"12","electron":"0.20","firefox":"7","ie":"9","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.date.to-json":{"android":"4.4","chrome":"26","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"10.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"10.0","samsung":"1.5"},"es.date.to-primitive":{"chrome":"47","edge":"15","electron":"0.36","firefox":"44","ios":"10.0","node":"6.0","opera":"34","opera_mobile":"34","safari":"10.0","samsung":"5.0"},"es.date.to-string":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ie":"9","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.function.bind":{"android":"3.0","chrome":"7","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"5.1","node":"0.1.101","opera":"12","opera_mobile":"12","phantom":"2.0","safari":"5.1","samsung":"1.0"},"es.function.has-instance":{"chrome":"51","edge":"15","electron":"1.2","firefox":"50","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.function.name":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"3.2","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"4.0","samsung":"1.0"},"es.global-this":{"chrome":"71","edge":"74","electron":"5.0","firefox":"65","ios":"12.2","node":"12.0","opera":"58","opera_mobile":"50","safari":"12.1","samsung":"10.0"},"es.json.stringify":{"chrome":"72","edge":"74","electron":"5.0","firefox":"64","ios":"12.2","node":"12.0","opera":"59","opera_mobile":"51","safari":"12.1","samsung":"11.0"},"es.json.to-string-tag":{"chrome":"50","edge":"15","electron":"1.1","firefox":"51","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.map":{"chrome":"51","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.math.acosh":{"chrome":"54","edge":"13","electron":"1.4","firefox":"25","ios":"8.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"7.1","samsung":"6.0"},"es.math.asinh":{"chrome":"38","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.atanh":{"chrome":"38","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.cbrt":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.clz32":{"chrome":"38","edge":"12","electron":"0.20","firefox":"31","ios":"9.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"9.0","samsung":"3.0"},"es.math.cosh":{"chrome":"39","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"1.0","opera":"26","opera_mobile":"26","safari":"7.1","samsung":"3.4"},"es.math.expm1":{"chrome":"39","edge":"13","electron":"0.20","firefox":"46","ios":"8.0","node":"1.0","opera":"26","opera_mobile":"26","safari":"7.1","samsung":"3.4"},"es.math.fround":{"chrome":"38","edge":"12","electron":"0.20","firefox":"26","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.hypot":{"chrome":"78","edge":"12","electron":"7.0","firefox":"27","ios":"8.0","node":"13.0","opera":"65","safari":"7.1"},"es.math.imul":{"android":"4.4","chrome":"28","edge":"13","electron":"0.20","firefox":"20","ios":"9.0","node":"0.11.1","opera":"16","opera_mobile":"16","safari":"9.0","samsung":"1.5"},"es.math.log10":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.log1p":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.log2":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.sign":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"9.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"9.0","samsung":"3.0"},"es.math.sinh":{"chrome":"39","edge":"13","electron":"0.20","firefox":"25","ios":"8.0","node":"1.0","opera":"26","opera_mobile":"26","safari":"7.1","samsung":"3.4"},"es.math.tanh":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.math.to-string-tag":{"chrome":"50","edge":"15","electron":"1.1","firefox":"51","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.math.trunc":{"chrome":"38","edge":"12","electron":"0.20","firefox":"25","ios":"8.0","node":"0.11.15","opera":"25","opera_mobile":"25","safari":"7.1","samsung":"3.0"},"es.number.constructor":{"chrome":"41","edge":"13","electron":"0.21","firefox":"46","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","safari":"9.0","samsung":"3.4"},"es.number.epsilon":{"chrome":"34","edge":"12","electron":"0.20","firefox":"25","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","safari":"9.0","samsung":"2.0"},"es.number.is-finite":{"android":"4.1","chrome":"19","edge":"12","electron":"0.20","firefox":"16","ios":"9.0","node":"0.7.3","opera":"15","opera_mobile":"15","safari":"9.0","samsung":"1.5"},"es.number.is-integer":{"chrome":"34","edge":"12","electron":"0.20","firefox":"16","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","safari":"9.0","samsung":"2.0"},"es.number.is-nan":{"android":"4.1","chrome":"19","edge":"12","electron":"0.20","firefox":"15","ios":"9.0","node":"0.7.3","opera":"15","opera_mobile":"15","safari":"9.0","samsung":"1.5"},"es.number.is-safe-integer":{"chrome":"34","edge":"12","electron":"0.20","firefox":"32","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","safari":"9.0","samsung":"2.0"},"es.number.max-safe-integer":{"chrome":"34","edge":"12","electron":"0.20","firefox":"31","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","safari":"9.0","samsung":"2.0"},"es.number.min-safe-integer":{"chrome":"34","edge":"12","electron":"0.20","firefox":"31","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","safari":"9.0","samsung":"2.0"},"es.number.parse-float":{"chrome":"35","edge":"13","electron":"0.20","firefox":"39","ios":"11.0","node":"0.11.13","opera":"22","opera_mobile":"22","safari":"11.0","samsung":"3.0"},"es.number.parse-int":{"chrome":"35","edge":"13","electron":"0.20","firefox":"39","ios":"9.0","node":"0.11.13","opera":"22","opera_mobile":"22","safari":"9.0","samsung":"3.0"},"es.number.to-fixed":{"android":"4.4","chrome":"26","edge":"74","electron":"0.20","firefox":"4","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.number.to-precision":{"android":"4.4","chrome":"26","edge":"12","electron":"0.20","firefox":"4","ie":"8","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.object.assign":{"chrome":"49","edge":"74","electron":"0.37","firefox":"36","ios":"9.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"9.0","samsung":"5.0"},"es.object.create":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"3.2","node":"0.1.27","opera":"12","opera_mobile":"12","phantom":"1.9","safari":"4.0","samsung":"1.0"},"es.object.define-getter":{"chrome":"62","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","safari":"7.1","samsung":"8.0"},"es.object.define-properties":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"5.1","node":"0.1.27","opera":"12","opera_mobile":"12","phantom":"2.0","safari":"5.1","samsung":"1.0"},"es.object.define-property":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"4","ie":"9","ios":"5.1","node":"0.1.27","opera":"12","opera_mobile":"12","phantom":"2.0","safari":"5.1","samsung":"1.0"},"es.object.define-setter":{"chrome":"62","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","safari":"7.1","samsung":"8.0"},"es.object.entries":{"chrome":"54","edge":"14","electron":"1.4","firefox":"47","ios":"10.3","node":"7.0","opera":"41","opera_mobile":"41","safari":"10.1","samsung":"6.0"},"es.object.freeze":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.from-entries":{"chrome":"73","edge":"74","electron":"5.0","firefox":"63","ios":"12.2","node":"12.0","opera":"60","opera_mobile":"52","safari":"12.1","samsung":"11.0"},"es.object.get-own-property-descriptor":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.get-own-property-descriptors":{"chrome":"54","edge":"15","electron":"1.4","firefox":"50","ios":"10.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"10.0","samsung":"6.0"},"es.object.get-own-property-names":{"chrome":"40","edge":"13","electron":"0.21","firefox":"34","ios":"9.0","node":"1.0","opera":"27","opera_mobile":"27","safari":"9.0","samsung":"3.4"},"es.object.get-prototype-of":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.is":{"android":"4.1","chrome":"19","edge":"12","electron":"0.20","firefox":"22","ios":"9.0","node":"0.7.3","opera":"15","opera_mobile":"15","safari":"9.0","samsung":"1.5"},"es.object.is-extensible":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.is-frozen":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.is-sealed":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.keys":{"chrome":"40","edge":"13","electron":"0.21","firefox":"35","ios":"9.0","node":"1.0","opera":"27","opera_mobile":"27","safari":"9.0","samsung":"3.4"},"es.object.lookup-getter":{"chrome":"62","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","safari":"7.1","samsung":"8.0"},"es.object.lookup-setter":{"chrome":"62","edge":"16","electron":"3.0","firefox":"48","ios":"8.0","node":"8.10","opera":"49","opera_mobile":"46","safari":"7.1","samsung":"8.0"},"es.object.prevent-extensions":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.seal":{"chrome":"44","edge":"13","electron":"0.30","firefox":"35","ios":"9.0","node":"3.0","opera":"31","opera_mobile":"31","safari":"9.0","samsung":"4.0"},"es.object.set-prototype-of":{"chrome":"34","edge":"12","electron":"0.20","firefox":"31","ie":"11","ios":"9.0","node":"0.11.13","opera":"21","opera_mobile":"21","safari":"9.0","samsung":"2.0"},"es.object.to-string":{"chrome":"49","edge":"15","electron":"0.37","firefox":"51","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.object.values":{"chrome":"54","edge":"14","electron":"1.4","firefox":"47","ios":"10.3","node":"7.0","opera":"41","opera_mobile":"41","safari":"10.1","samsung":"6.0"},"es.parse-float":{"chrome":"35","edge":"12","electron":"0.20","firefox":"8","ie":"8","ios":"8.0","node":"0.11.13","opera":"22","opera_mobile":"22","safari":"7.1","samsung":"3.0"},"es.parse-int":{"chrome":"35","edge":"12","electron":"0.20","firefox":"21","ie":"9","ios":"8.0","node":"0.11.13","opera":"22","opera_mobile":"22","safari":"7.1","samsung":"3.0"},"es.promise":{"chrome":"67","edge":"74","electron":"4.0","firefox":"69","ios":"11.0","node":"10.4","opera":"54","opera_mobile":"48","safari":"11.0","samsung":"9.0"},"es.promise.all-settled":{"chrome":"76","edge":"76","electron":"6.0","firefox":"71","ios":"13.0","node":"12.9","opera":"63","opera_mobile":"54","safari":"13"},"es.promise.finally":{"chrome":"67","edge":"74","electron":"4.0","firefox":"69","ios":"13.2.3","node":"10.4","opera":"54","opera_mobile":"48","safari":"13.0.3","samsung":"9.0"},"es.reflect.apply":{"chrome":"49","edge":"15","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.construct":{"chrome":"49","edge":"15","electron":"0.37","firefox":"44","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.define-property":{"chrome":"49","edge":"13","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.delete-property":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.get":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.get-own-property-descriptor":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.get-prototype-of":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.has":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.is-extensible":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.own-keys":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.prevent-extensions":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.set":{"chrome":"49","edge":"74","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.reflect.set-prototype-of":{"chrome":"49","edge":"12","electron":"0.37","firefox":"42","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.regexp.constructor":{"chrome":"51","edge":"74","electron":"1.2","firefox":"49","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.regexp.exec":{"android":"4.4","chrome":"26","edge":"13","electron":"0.20","firefox":"44","ios":"10.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"10.0","samsung":"1.5"},"es.regexp.flags":{"chrome":"49","edge":"74","electron":"0.37","firefox":"37","ios":"9.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"9.0","samsung":"5.0"},"es.regexp.sticky":{"chrome":"49","edge":"13","electron":"0.37","firefox":"3","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.regexp.test":{"chrome":"51","edge":"74","electron":"1.2","firefox":"46","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.regexp.to-string":{"chrome":"50","edge":"74","electron":"1.1","firefox":"46","ios":"10.0","node":"6.0","opera":"37","opera_mobile":"37","safari":"10.0","samsung":"5.0"},"es.set":{"chrome":"51","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.code-point-at":{"chrome":"41","edge":"13","electron":"0.21","firefox":"29","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","safari":"9.0","samsung":"3.4"},"es.string.ends-with":{"chrome":"51","edge":"74","electron":"1.2","firefox":"40","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.from-code-point":{"chrome":"41","edge":"13","electron":"0.21","firefox":"29","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","safari":"9.0","samsung":"3.4"},"es.string.includes":{"chrome":"51","edge":"74","electron":"1.2","firefox":"40","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.iterator":{"chrome":"39","edge":"13","electron":"0.20","firefox":"36","ios":"9.0","node":"1.0","opera":"26","opera_mobile":"26","safari":"9.0","samsung":"3.4"},"es.string.match":{"chrome":"51","edge":"74","electron":"1.2","firefox":"49","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.match-all":{"chrome":"80","edge":"80","electron":"8.0","firefox":"73","opera":"67","safari":"13.1"},"es.string.pad-end":{"chrome":"57","edge":"15","electron":"1.7","firefox":"48","ios":"11.0","node":"8.0","opera":"44","opera_mobile":"43","safari":"11.0","samsung":"7.0"},"es.string.pad-start":{"chrome":"57","edge":"15","electron":"1.7","firefox":"48","ios":"11.0","node":"8.0","opera":"44","opera_mobile":"43","safari":"11.0","samsung":"7.0"},"es.string.raw":{"chrome":"41","edge":"13","electron":"0.21","firefox":"34","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","safari":"9.0","samsung":"3.4"},"es.string.repeat":{"chrome":"41","edge":"13","electron":"0.21","firefox":"24","ios":"9.0","node":"1.0","opera":"28","opera_mobile":"28","safari":"9.0","samsung":"3.4"},"es.string.replace":{"chrome":"64","edge":"74","electron":"3.0","node":"10.0","opera":"51","opera_mobile":"47","samsung":"9.0"},"es.string.search":{"chrome":"51","edge":"74","electron":"1.2","firefox":"49","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.split":{"chrome":"54","edge":"74","electron":"1.4","firefox":"49","ios":"10.0","node":"7.0","opera":"41","opera_mobile":"41","safari":"10.0","samsung":"6.0"},"es.string.starts-with":{"chrome":"51","edge":"74","electron":"1.2","firefox":"40","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.string.trim":{"chrome":"59","edge":"15","electron":"1.8","firefox":"52","ios":"12.2","node":"8.3","opera":"46","opera_mobile":"43","safari":"12.1","samsung":"7.0"},"es.string.trim-end":{"chrome":"66","edge":"74","electron":"3.0","firefox":"61","ios":"12.2","node":"10.0","opera":"53","opera_mobile":"47","safari":"12.1","samsung":"9.0"},"es.string.trim-start":{"chrome":"66","edge":"74","electron":"3.0","firefox":"61","ios":"12.0","node":"10.0","opera":"53","opera_mobile":"47","safari":"12.0","samsung":"9.0"},"es.string.anchor":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","safari":"6.0","samsung":"1.0"},"es.string.big":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.blink":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.bold":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.fixed":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.fontcolor":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","safari":"6.0","samsung":"1.0"},"es.string.fontsize":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","safari":"6.0","samsung":"1.0"},"es.string.italics":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.link":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"17","ios":"6.0","node":"0.1.27","opera":"15","opera_mobile":"15","phantom":"2.0","safari":"6.0","samsung":"1.0"},"es.string.small":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.strike":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.sub":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.string.sup":{"android":"3.0","chrome":"5","edge":"12","electron":"0.20","firefox":"2","ios":"2.0","node":"0.1.27","opera":"10.50","opera_mobile":"10.50","phantom":"1.9","safari":"3.1","samsung":"1.0"},"es.typed-array.float32-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.float64-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.int8-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.int16-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.int32-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.uint8-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.uint8-clamped-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.uint16-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.uint32-array":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.copy-within":{"chrome":"45","edge":"13","electron":"0.31","firefox":"34","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.every":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.fill":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.filter":{"chrome":"45","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.find":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.find-index":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.for-each":{"chrome":"45","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.from":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.includes":{"chrome":"49","edge":"14","electron":"0.37","firefox":"43","ios":"10.0","node":"6.0","opera":"36","opera_mobile":"36","safari":"10.0","samsung":"5.0"},"es.typed-array.index-of":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.iterator":{"chrome":"47","edge":"13","electron":"0.36","firefox":"37","ios":"10.0","node":"6.0","opera":"34","opera_mobile":"34","safari":"10.0","samsung":"5.0"},"es.typed-array.join":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.last-index-of":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.map":{"chrome":"45","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.of":{"chrome":"54","edge":"15","electron":"1.4","firefox":"55","node":"7.0","opera":"41","opera_mobile":"41","samsung":"6.0"},"es.typed-array.reduce":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.reduce-right":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.reverse":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.set":{"android":"4.4","chrome":"26","edge":"13","electron":"0.20","firefox":"15","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.typed-array.slice":{"chrome":"45","edge":"13","electron":"0.31","firefox":"38","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.some":{"chrome":"45","edge":"13","electron":"0.31","firefox":"37","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.sort":{"chrome":"45","edge":"13","electron":"0.31","firefox":"46","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.subarray":{"android":"4.4","chrome":"26","edge":"13","electron":"0.20","firefox":"15","ios":"8.0","node":"0.11.0","opera":"16","opera_mobile":"16","safari":"7.1","samsung":"1.5"},"es.typed-array.to-locale-string":{"chrome":"45","edge":"74","electron":"0.31","firefox":"51","ios":"10.0","node":"4.0","opera":"32","opera_mobile":"32","safari":"10.0","samsung":"5.0"},"es.typed-array.to-string":{"chrome":"51","edge":"13","electron":"1.2","firefox":"51","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.weak-map":{"chrome":"51","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"es.weak-set":{"chrome":"51","edge":"15","electron":"1.2","firefox":"53","ios":"10.0","node":"6.5","opera":"38","opera_mobile":"38","safari":"10.0","samsung":"5.0"},"esnext.aggregate-error":{},"esnext.array.is-template-object":{},"esnext.array.last-index":{},"esnext.array.last-item":{},"esnext.async-iterator.constructor":{},"esnext.async-iterator.as-indexed-pairs":{},"esnext.async-iterator.drop":{},"esnext.async-iterator.every":{},"esnext.async-iterator.filter":{},"esnext.async-iterator.find":{},"esnext.async-iterator.flat-map":{},"esnext.async-iterator.for-each":{},"esnext.async-iterator.from":{},"esnext.async-iterator.map":{},"esnext.async-iterator.reduce":{},"esnext.async-iterator.some":{},"esnext.async-iterator.take":{},"esnext.async-iterator.to-array":{},"esnext.composite-key":{},"esnext.composite-symbol":{},"esnext.global-this":{"chrome":"71","edge":"74","electron":"5.0","firefox":"65","ios":"12.2","node":"12.0","opera":"58","opera_mobile":"50","safari":"12.1","samsung":"10.0"},"esnext.iterator.constructor":{},"esnext.iterator.as-indexed-pairs":{},"esnext.iterator.drop":{},"esnext.iterator.every":{},"esnext.iterator.filter":{},"esnext.iterator.find":{},"esnext.iterator.flat-map":{},"esnext.iterator.for-each":{},"esnext.iterator.from":{},"esnext.iterator.map":{},"esnext.iterator.reduce":{},"esnext.iterator.some":{},"esnext.iterator.take":{},"esnext.iterator.to-array":{},"esnext.map.delete-all":{},"esnext.map.every":{},"esnext.map.filter":{},"esnext.map.find":{},"esnext.map.find-key":{},"esnext.map.from":{},"esnext.map.group-by":{},"esnext.map.includes":{},"esnext.map.key-by":{},"esnext.map.key-of":{},"esnext.map.map-keys":{},"esnext.map.map-values":{},"esnext.map.merge":{},"esnext.map.of":{},"esnext.map.reduce":{},"esnext.map.some":{},"esnext.map.update":{},"esnext.map.update-or-insert":{},"esnext.map.upsert":{},"esnext.math.clamp":{},"esnext.math.deg-per-rad":{},"esnext.math.degrees":{},"esnext.math.fscale":{},"esnext.math.iaddh":{},"esnext.math.imulh":{},"esnext.math.isubh":{},"esnext.math.rad-per-deg":{},"esnext.math.radians":{},"esnext.math.scale":{},"esnext.math.seeded-prng":{},"esnext.math.signbit":{},"esnext.math.umulh":{},"esnext.number.from-string":{},"esnext.object.iterate-entries":{},"esnext.object.iterate-keys":{},"esnext.object.iterate-values":{},"esnext.observable":{},"esnext.promise.all-settled":{"chrome":"76","edge":"76","electron":"6.0","firefox":"71","ios":"13.0","node":"12.9","opera":"63","opera_mobile":"54","safari":"13"},"esnext.promise.any":{},"esnext.promise.try":{},"esnext.reflect.define-metadata":{},"esnext.reflect.delete-metadata":{},"esnext.reflect.get-metadata":{},"esnext.reflect.get-metadata-keys":{},"esnext.reflect.get-own-metadata":{},"esnext.reflect.get-own-metadata-keys":{},"esnext.reflect.has-metadata":{},"esnext.reflect.has-own-metadata":{},"esnext.reflect.metadata":{},"esnext.set.add-all":{},"esnext.set.delete-all":{},"esnext.set.difference":{},"esnext.set.every":{},"esnext.set.filter":{},"esnext.set.find":{},"esnext.set.from":{},"esnext.set.intersection":{},"esnext.set.is-disjoint-from":{},"esnext.set.is-subset-of":{},"esnext.set.is-superset-of":{},"esnext.set.join":{},"esnext.set.map":{},"esnext.set.of":{},"esnext.set.reduce":{},"esnext.set.some":{},"esnext.set.symmetric-difference":{},"esnext.set.union":{},"esnext.string.at":{},"esnext.string.code-points":{},"esnext.string.match-all":{"chrome":"80","edge":"80","electron":"8.0","firefox":"73","opera":"67","safari":"13.1"},"esnext.string.replace-all":{},"esnext.symbol.async-dispose":{},"esnext.symbol.dispose":{},"esnext.symbol.observable":{},"esnext.symbol.pattern-match":{},"esnext.symbol.replace-all":{},"esnext.weak-map.delete-all":{},"esnext.weak-map.from":{},"esnext.weak-map.of":{},"esnext.weak-map.upsert":{},"esnext.weak-set.add-all":{},"esnext.weak-set.delete-all":{},"esnext.weak-set.from":{},"esnext.weak-set.of":{},"web.dom-collections.for-each":{"chrome":"58","edge":"16","electron":"1.7","firefox":"50","ios":"10.0","node":"0.0.1","opera":"45","opera_mobile":"43","safari":"10.0","samsung":"7.0"},"web.dom-collections.iterator":{"chrome":"66","edge":"74","electron":"3.0","firefox":"60","node":"0.0.1","opera":"53","opera_mobile":"47","safari":"13.1","samsung":"9.0"},"web.immediate":{"ie":"10","node":"0.9.1"},"web.queue-microtask":{"chrome":"71","edge":"74","electron":"5.0","firefox":"69","ios":"12.2","node":"12.0","opera":"58","opera_mobile":"50","safari":"12.1","samsung":"10.0"},"web.timers":{"android":"1.5","chrome":"1","edge":"12","electron":"0.20","firefox":"1","ie":"10","ios":"1.0","node":"0.0.1","opera":"7","opera_mobile":"7","phantom":"1.9","safari":"1.0","samsung":"1.0"},"web.url":{"chrome":"67","edge":"74","electron":"4.0","firefox":"57","node":"10.0","opera":"54","opera_mobile":"48","samsung":"9.0"},"web.url.to-json":{"chrome":"71","edge":"74","electron":"5.0","firefox":"57","node":"10.0","opera":"58","opera_mobile":"50","samsung":"10.0"},"web.url-search-params":{"chrome":"67","edge":"74","electron":"4.0","firefox":"57","node":"10.0","opera":"54","opera_mobile":"48","samsung":"9.0"}}');
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(172);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(actual, expected) {
    const keys = Object.keys(expected);
    for (const key of keys) if (actual[key] !== expected[key]) return !1;
    return !0;
  };
}, function(module, exports, __webpack_require__) {
  var Map = __webpack_require__(12)(__webpack_require__(6), "Map");
  module.exports = Map;
}, function(module, exports, __webpack_require__) {
  var arrayLikeKeys = __webpack_require__(104), baseKeys = __webpack_require__(223), isArrayLike = __webpack_require__(62);
  module.exports = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  };
}, function(module, exports) {
  module.exports = function(module) {
    return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], 
    module.children || (module.children = []), Object.defineProperty(module, "loaded", {
      enumerable: !0,
      get: function() {
        return module.l;
      }
    }), Object.defineProperty(module, "id", {
      enumerable: !0,
      get: function() {
        return module.i;
      }
    }), module.webpackPolyfill = 1), module;
  };
}, function(module, exports) {
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  module.exports = function(value, length) {
    var type = typeof value;
    return !!(length = null == length ? 9007199254740991 : length) && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  };
}, function(module, exports) {
  module.exports = function(value) {
    return "number" == typeof value && value > -1 && value % 1 == 0 && value <= 9007199254740991;
  };
}, function(module, exports) {
  var objectProto = Object.prototype;
  module.exports = function(value) {
    var Ctor = value && value.constructor;
    return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
  };
}, function(module, exports, __webpack_require__) {
  var isFunction = __webpack_require__(97), isLength = __webpack_require__(60);
  module.exports = function(value) {
    return null != value && isLength(value.length) && !isFunction(value);
  };
}, function(module, exports, __webpack_require__) {
  var arrayFilter = __webpack_require__(230), stubArray = __webpack_require__(109), propertyIsEnumerable = Object.prototype.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(object) {
    return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), (function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    })));
  } : stubArray;
  module.exports = getSymbols;
}, function(module, exports, __webpack_require__) {
  var getPrototype = __webpack_require__(107)(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
}, function(module, exports, __webpack_require__) {
  var DataView = __webpack_require__(234), Map = __webpack_require__(56), Promise = __webpack_require__(235), Set = __webpack_require__(236), WeakMap = __webpack_require__(237), baseGetTag = __webpack_require__(13), toSource = __webpack_require__(99), dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), getTag = baseGetTag;
  (DataView && "[object DataView]" != getTag(new DataView(new ArrayBuffer(1))) || Map && "[object Map]" != getTag(new Map) || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && "[object Set]" != getTag(new Set) || WeakMap && "[object WeakMap]" != getTag(new WeakMap)) && (getTag = function(value) {
    var result = baseGetTag(value), Ctor = "[object Object]" == result ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) switch (ctorString) {
     case dataViewCtorString:
      return "[object DataView]";

     case mapCtorString:
      return "[object Map]";

     case promiseCtorString:
      return "[object Promise]";

     case setCtorString:
      return "[object Set]";

     case weakMapCtorString:
      return "[object WeakMap]";
    }
    return result;
  }), module.exports = getTag;
}, function(module, exports, __webpack_require__) {
  var Uint8Array = __webpack_require__(240);
  module.exports = function(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(nodeType, targetType) {
    if (nodeType === targetType) return !0;
    if (_definitions.ALIAS_KEYS[targetType]) return !1;
    const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
      if (aliases[0] === nodeType) return !0;
      for (const alias of aliases) if (nodeType === alias) return !0;
    }
    return !1;
  };
  var _definitions = __webpack_require__(5);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), Object.defineProperty(exports, "isIdentifierName", {
    enumerable: !0,
    get: function() {
      return _identifier.isIdentifierName;
    }
  }), Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: !0,
    get: function() {
      return _identifier.isIdentifierChar;
    }
  }), Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: !0,
    get: function() {
      return _identifier.isIdentifierStart;
    }
  }), Object.defineProperty(exports, "isReservedWord", {
    enumerable: !0,
    get: function() {
      return _keyword.isReservedWord;
    }
  }), Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: function() {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  }), Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: !0,
    get: function() {
      return _keyword.isStrictBindReservedWord;
    }
  }), Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: !0,
    get: function() {
      return _keyword.isStrictReservedWord;
    }
  }), Object.defineProperty(exports, "isKeyword", {
    enumerable: !0,
    get: function() {
      return _keyword.isKeyword;
    }
  });
  var _identifier = __webpack_require__(252), _keyword = __webpack_require__(253);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, key, val) {
    if (!node) return;
    const fields = _definitions.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field), validateChild(node, key, val);
  }, exports.validateField = validateField, exports.validateChild = validateChild;
  var _definitions = __webpack_require__(5);
  function validateField(node, key, val, field) {
    (null == field ? void 0 : field.validate) && (field.optional && null == val || field.validate(node, key, val));
  }
  function validateChild(node, key, val) {
    if (null == val) return;
    const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
    validate && validate(node, key, val);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = void 0;
  var obj, _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7)), _core = __webpack_require__(39), _is = (obj = __webpack_require__(26)) && obj.__esModule ? obj : {
    default: obj
  };
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  (0, _utils.default)("AssignmentPattern", {
    visitor: [ "left", "right", "decorators" ],
    builder: [ "left", "right" ],
    aliases: [ "Pattern", "PatternLike", "LVal" ],
    fields: Object.assign({}, _core.patternLikeCommon, {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  }), (0, _utils.default)("ArrayPattern", {
    visitor: [ "elements", "typeAnnotation" ],
    builder: [ "elements" ],
    aliases: [ "Pattern", "PatternLike", "LVal" ],
    fields: Object.assign({}, _core.patternLikeCommon, {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeOrValueType)("null", "PatternLike")))
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  }), (0, _utils.default)("ArrowFunctionExpression", {
    builder: [ "params", "body", "async" ],
    visitor: [ "params", "body", "returnType", "typeParameters" ],
    aliases: [ "Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish" ],
    fields: Object.assign({}, _core.functionCommon, _core.functionTypeAnnotationCommon, {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      }
    })
  }), (0, _utils.default)("ClassBody", {
    visitor: [ "body" ],
    fields: {
      body: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
      }
    }
  }), (0, _utils.default)("ClassExpression", {
    builder: [ "id", "superClass", "body", "decorators" ],
    visitor: [ "id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators" ],
    aliases: [ "Scopable", "Class", "Expression" ],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  }), (0, _utils.default)("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: [ "Scopable", "Class", "Statement", "Declaration" ],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, _utils.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      const identifier = (0, _utils.assertNodeType)("Identifier");
      return function(parent, key, node) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, _is.default)("ExportDefaultDeclaration", parent) || identifier(node, "id", node.id));
      };
    }()
  }), (0, _utils.default)("ExportAllDeclaration", {
    visitor: [ "source" ],
    aliases: [ "Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration" ],
    fields: {
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  }), (0, _utils.default)("ExportDefaultDeclaration", {
    visitor: [ "declaration" ],
    aliases: [ "Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration" ],
    fields: {
      declaration: {
        validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
      }
    }
  }), (0, _utils.default)("ExportNamedDeclaration", {
    visitor: [ "declaration", "specifiers", "source" ],
    aliases: [ "Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration" ],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign((function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }), {
          oneOfNodeTypes: [ "Declaration" ]
        }), (function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && node.source) throw new TypeError("Cannot export a declaration from a source");
        }))
      },
      specifiers: {
        default: [],
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function() {
          const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), sourceless = (0, 
          _utils.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(node, key, val) {
            (node.source ? sourced : sourceless)(node, key, val);
          } : sourced;
        }()))
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
  }), (0, _utils.default)("ExportSpecifier", {
    visitor: [ "local", "exported" ],
    aliases: [ "ModuleSpecifier" ],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  }), (0, _utils.default)("ForOfStatement", {
    visitor: [ "left", "right", "body" ],
    builder: [ "left", "right", "body", "await" ],
    aliases: [ "Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement" ],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          const declaration = (0, _utils.assertNodeType)("VariableDeclaration"), lval = (0, 
          _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
          return function(node, key, val) {
            (0, _is.default)("VariableDeclaration", val) ? declaration(node, key, val) : lval(node, key, val);
          };
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  }), (0, _utils.default)("ImportDeclaration", {
    visitor: [ "specifiers", "source" ],
    aliases: [ "Statement", "Declaration", "ModuleDeclaration" ],
    fields: {
      specifiers: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), (0, _utils.default)("ImportDefaultSpecifier", {
    visitor: [ "local" ],
    aliases: [ "ModuleSpecifier" ],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  }), (0, _utils.default)("ImportNamespaceSpecifier", {
    visitor: [ "local" ],
    aliases: [ "ModuleSpecifier" ],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  }), (0, _utils.default)("ImportSpecifier", {
    visitor: [ "local", "imported" ],
    aliases: [ "ModuleSpecifier" ],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof"),
        optional: !0
      }
    }
  }), (0, _utils.default)("MetaProperty", {
    visitor: [ "meta", "property" ],
    aliases: [ "Expression" ],
    fields: {
      meta: {
        validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign((function(node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          let property;
          switch (val.name) {
           case "function":
            property = "sent";
            break;

           case "new":
            property = "target";
            break;

           case "import":
            property = "meta";
          }
          if (!(0, _is.default)("Identifier", node.property, {
            name: property
          })) throw new TypeError("Unrecognised MetaProperty");
        }), {
          oneOfNodeTypes: [ "Identifier" ]
        }))
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  const classMethodOrPropertyCommon = {
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, _utils.chain)(function() {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), computed = (0, 
        _utils.assertNodeType)("Expression");
        return function(node, key, val) {
          (node.computed ? computed : normal)(node, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
  };
  exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  const classMethodOrDeclareMethodCommon = Object.assign({}, _core.functionCommon, classMethodOrPropertyCommon, {
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
      _utils.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon, (0, 
  _utils.default)("ClassMethod", {
    aliases: [ "Function", "Scopable", "BlockParent", "FunctionParent", "Method" ],
    builder: [ "kind", "key", "params", "body", "computed", "static", "generator", "async" ],
    visitor: [ "key", "params", "body", "decorators", "returnType", "typeParameters" ],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  }), (0, _utils.default)("ObjectPattern", {
    visitor: [ "properties", "typeAnnotation", "decorators" ],
    builder: [ "properties" ],
    aliases: [ "Pattern", "PatternLike", "LVal" ],
    fields: Object.assign({}, _core.patternLikeCommon, {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  }), (0, _utils.default)("SpreadElement", {
    visitor: [ "argument" ],
    aliases: [ "UnaryLike" ],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("Super", {
    aliases: [ "Expression" ]
  }), (0, _utils.default)("TaggedTemplateExpression", {
    visitor: [ "tag", "quasi" ],
    aliases: [ "Expression" ],
    fields: {
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), (0, _utils.default)("TemplateElement", {
    builder: [ "value", "tail" ],
    fields: {
      value: {
        validate: (0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: !0
          }
        })
      },
      tail: {
        default: !1
      }
    }
  }), (0, _utils.default)("TemplateLiteral", {
    visitor: [ "quasis", "expressions" ],
    aliases: [ "Expression", "Literal" ],
    fields: {
      quasis: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Expression")), (function(node, key, val) {
          if (node.quasis.length !== val.length + 1) throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }))
      }
    }
  }), (0, _utils.default)("YieldExpression", {
    builder: [ "argument", "delegate" ],
    visitor: [ "argument" ],
    aliases: [ "Expression", "Terminatorless" ],
    fields: {
      delegate: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign((function(node, key, val) {
          if (process.env.BABEL_TYPES_8_BREAKING && val && !node.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }), {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(key, child, parent) {
    child && parent && (child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean))));
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.merge = function(a, b) {
    const {placeholderWhitelist: placeholderWhitelist = a.placeholderWhitelist, placeholderPattern: placeholderPattern = a.placeholderPattern, preserveComments: preserveComments = a.preserveComments, syntacticPlaceholders: syntacticPlaceholders = a.syntacticPlaceholders} = b;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      preserveComments: preserveComments,
      syntacticPlaceholders: syntacticPlaceholders
    };
  }, exports.validate = function(opts) {
    if (null != opts && "object" != typeof opts) throw new Error("Unknown template options.");
    const _ref = opts || {}, {placeholderWhitelist: placeholderWhitelist, placeholderPattern: placeholderPattern, preserveComments: preserveComments, syntacticPlaceholders: syntacticPlaceholders} = _ref, parser = function(source, excluded) {
      if (null == source) return {};
      var key, i, target = {}, sourceKeys = Object.keys(source);
      for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
      return target;
    }(_ref, [ "placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders" ]);
    if (null != placeholderWhitelist && !(placeholderWhitelist instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (null != placeholderPattern && !(placeholderPattern instanceof RegExp) && !1 !== placeholderPattern) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (null != preserveComments && "boolean" != typeof preserveComments) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (null != syntacticPlaceholders && "boolean" != typeof syntacticPlaceholders) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (!0 === syntacticPlaceholders && (null != placeholderWhitelist || null != placeholderPattern)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: parser,
      placeholderWhitelist: placeholderWhitelist || void 0,
      placeholderPattern: null == placeholderPattern ? void 0 : placeholderPattern,
      preserveComments: null == preserveComments ? void 0 : preserveComments,
      syntacticPlaceholders: null == syntacticPlaceholders ? void 0 : syntacticPlaceholders
    };
  }, exports.normalizeReplacements = function(replacements) {
    if (Array.isArray(replacements)) return replacements.reduce((acc, replacement, i) => (acc["$" + i] = replacement, 
    acc), {});
    if ("object" == typeof replacements || null == replacements) return replacements || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(callee, thisNode, args, optional) {
    return 1 === args.length && t.isSpreadElement(args[0]) && t.isIdentifier(args[0].argument, {
      name: "arguments"
    }) ? t.callExpression(t.memberExpression(callee, t.identifier("apply")), [ thisNode, args[0].argument ]) : optional ? t.optionalCallExpression(t.optionalMemberExpression(callee, t.identifier("call"), !1, !0), [ thisNode, ...args ], !1) : t.callExpression(t.memberExpression(callee, t.identifier("call")), [ thisNode, ...args ]);
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.addDefault = function(path, importedSource, opts) {
    return new _importInjector.default(path).addDefault(importedSource, opts);
  }, exports.addNamed = function(path, name, importedSource, opts) {
    return new _importInjector.default(path).addNamed(name, importedSource, opts);
  }, exports.addNamespace = function(path, importedSource, opts) {
    return new _importInjector.default(path).addNamespace(importedSource, opts);
  }, exports.addSideEffect = function(path, importedSource, opts) {
    return new _importInjector.default(path).addSideEffect(importedSource, opts);
  }, Object.defineProperty(exports, "ImportInjector", {
    enumerable: !0,
    get: function() {
      return _importInjector.default;
    }
  }), Object.defineProperty(exports, "isModule", {
    enumerable: !0,
    get: function() {
      return _isModule.default;
    }
  });
  var _importInjector = _interopRequireDefault(__webpack_require__(393)), _isModule = _interopRequireDefault(__webpack_require__(154));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(436);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(targets) {
    const targetNames = Object.keys(targets), isAnyTarget = !targetNames.length, isWebTarget = targetNames.some(name => "node" !== name);
    return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
  }, exports.defaultWebIncludes = void 0;
  const defaultWebIncludes = [ "web.timers", "web.immediate", "web.dom.iterable" ];
  exports.defaultWebIncludes = defaultWebIncludes;
}, function(module, exports, __webpack_require__) {
  const debug = __webpack_require__(159), {MAX_LENGTH: MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER} = __webpack_require__(78), {re: re, t: t} = __webpack_require__(79), {compareIdentifiers: compareIdentifiers} = __webpack_require__(479);
  class SemVer {
    constructor(version, options) {
      if (options && "object" == typeof options || (options = {
        loose: !!options,
        includePrerelease: !1
      }), version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) return version;
        version = version.version;
      } else if ("string" != typeof version) throw new TypeError("Invalid Version: " + version);
      if (version.length > MAX_LENGTH) throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      debug("SemVer", version, options), this.options = options, this.loose = !!options.loose, 
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) throw new TypeError("Invalid Version: " + version);
      if (this.raw = version, this.major = +m[1], this.minor = +m[2], this.patch = +m[3], 
      this.major > MAX_SAFE_INTEGER || this.major < 0) throw new TypeError("Invalid major version");
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) throw new TypeError("Invalid minor version");
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) throw new TypeError("Invalid patch version");
      m[4] ? this.prerelease = m[4].split(".").map(id => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) return num;
        }
        return id;
      }) : this.prerelease = [], this.build = m[5] ? m[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), 
      this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      if (debug("SemVer.compare", this.version, this.options, other), !(other instanceof SemVer)) {
        if ("string" == typeof other && other === this.version) return 0;
        other = new SemVer(other, this.options);
      }
      return other.version === this.version ? 0 : this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      return other instanceof SemVer || (other = new SemVer(other, this.options)), compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (other instanceof SemVer || (other = new SemVer(other, this.options)), this.prerelease.length && !other.prerelease.length) return -1;
      if (!this.prerelease.length && other.prerelease.length) return 1;
      if (!this.prerelease.length && !other.prerelease.length) return 0;
      let i = 0;
      do {
        const a = this.prerelease[i], b = other.prerelease[i];
        if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
        if (void 0 === b) return 1;
        if (void 0 === a) return -1;
        if (a !== b) return compareIdentifiers(a, b);
      } while (++i);
    }
    compareBuild(other) {
      other instanceof SemVer || (other = new SemVer(other, this.options));
      let i = 0;
      do {
        const a = this.build[i], b = other.build[i];
        if (debug("prerelease compare", i, a, b), void 0 === a && void 0 === b) return 0;
        if (void 0 === b) return 1;
        if (void 0 === a) return -1;
        if (a !== b) return compareIdentifiers(a, b);
      } while (++i);
    }
    inc(release, identifier) {
      switch (release) {
       case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", identifier);
        break;

       case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", identifier);
        break;

       case "prepatch":
        this.prerelease.length = 0, this.inc("patch", identifier), this.inc("pre", identifier);
        break;

       case "prerelease":
        0 === this.prerelease.length && this.inc("patch", identifier), this.inc("pre", identifier);
        break;

       case "major":
        0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, 
        this.minor = 0, this.patch = 0, this.prerelease = [];
        break;

       case "minor":
        0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, 
        this.prerelease = [];
        break;

       case "patch":
        0 === this.prerelease.length && this.patch++, this.prerelease = [];
        break;

       case "pre":
        if (0 === this.prerelease.length) this.prerelease = [ 0 ]; else {
          let i = this.prerelease.length;
          for (;--i >= 0; ) "number" == typeof this.prerelease[i] && (this.prerelease[i]++, 
          i = -2);
          -1 === i && this.prerelease.push(0);
        }
        identifier && (this.prerelease[0] === identifier ? isNaN(this.prerelease[1]) && (this.prerelease = [ identifier, 0 ]) : this.prerelease = [ identifier, 0 ]);
        break;

       default:
        throw new Error("invalid increment argument: " + release);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  module.exports = SemVer;
}, function(module, exports) {
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  module.exports = {
    SEMVER_SPEC_VERSION: "2.0.0",
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    MAX_SAFE_COMPONENT_LENGTH: 16
  };
}, function(module, exports, __webpack_require__) {
  const {MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH} = __webpack_require__(78), debug = __webpack_require__(159), re = (exports = module.exports = {}).re = [], src = exports.src = [], t = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug(index, value), t[name] = index, src[index] = value, re[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*"), createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+"), 
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`), 
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`), 
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`), 
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`), 
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`), 
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`), 
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`), 
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`), 
  createToken("FULL", `^${src[t.FULLPLAIN]}$`), createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`), 
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`), createToken("GTLT", "((?:<|>)?=?)"), 
  createToken("XRANGEIDENTIFIERLOOSE", src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*"), 
  createToken("XRANGEIDENTIFIER", src[t.NUMERICIDENTIFIER] + "|x|X|\\*"), createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`), 
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`), 
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`), createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`), 
  createToken("COERCE", `(^|[^\\d])(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`), 
  createToken("COERCERTL", src[t.COERCE], !0), createToken("LONETILDE", "(?:~>?)"), 
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, !0), exports.tildeTrimReplace = "$1~", 
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`), createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`), 
  createToken("LONECARET", "(?:\\^)"), createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, !0), 
  exports.caretTrimReplace = "$1^", createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`), 
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`), createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`), 
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`), createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, !0), 
  exports.comparatorTrimReplace = "$1$2$3", createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`), 
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`), 
  createToken("STAR", "(<|>)?=?\\s*\\*");
}, function(__webpack_module__, __webpack_exports__, __webpack_require__) {
  "use strict";
  __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "default", (function() {
    return levenArray;
  }));
  var leven__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(160);
  function levenArray(str, array) {
    let minLeven = Number.POSITIVE_INFINITY, result = void 0;
    for (const item of array) {
      const distance = leven__WEBPACK_IMPORTED_MODULE_0__(str, item);
      distance < minLeven && (minLeven = distance, result = item);
    }
    return result;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.prettifyVersion = prettifyVersion, exports.prettifyTargets = function(targets) {
    return Object.keys(targets).reduce((results, target) => {
      let value = targets[target];
      const unreleasedLabel = _targets.unreleasedLabels[target];
      return "string" == typeof value && unreleasedLabel !== value && (value = prettifyVersion(value)), 
      results[target] = value, results;
    }, {});
  };
  var obj, _semver = (obj = __webpack_require__(19)) && obj.__esModule ? obj : {
    default: obj
  }, _targets = __webpack_require__(52);
  function prettifyVersion(version) {
    if ("string" != typeof version) return version;
    const parts = [ _semver.default.major(version) ], minor = _semver.default.minor(version), patch = _semver.default.patch(version);
    return (minor || patch) && parts.push(minor), patch && parts.push(patch), parts.join(".");
  }
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(168);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  exports.default = {
    auto: "transform-modules-commonjs",
    amd: "transform-modules-amd",
    commonjs: "transform-modules-commonjs",
    cjs: "transform-modules-commonjs",
    systemjs: "transform-modules-systemjs",
    umd: "transform-modules-umd"
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.pluginsBugfixes = exports.plugins = void 0;
  var _plugins = _interopRequireDefault(__webpack_require__(82)), _pluginBugfixes = _interopRequireDefault(__webpack_require__(173)), _availablePlugins = _interopRequireDefault(__webpack_require__(85));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const pluginsFiltered = {};
  exports.plugins = pluginsFiltered;
  const bugfixPluginsFiltered = {};
  exports.pluginsBugfixes = bugfixPluginsFiltered;
  for (const plugin of Object.keys(_plugins.default)) Object.hasOwnProperty.call(_availablePlugins.default, plugin) && (pluginsFiltered[plugin] = _plugins.default[plugin]);
  for (const plugin of Object.keys(_pluginBugfixes.default)) Object.hasOwnProperty.call(_availablePlugins.default, plugin) && (bugfixPluginsFiltered[plugin] = _pluginBugfixes.default[plugin]);
  pluginsFiltered["proposal-class-properties"] = pluginsFiltered["proposal-private-methods"];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _pluginSyntaxAsyncGenerators = _interopRequireDefault(__webpack_require__(86)), _pluginSyntaxClassProperties = _interopRequireDefault(__webpack_require__(175)), _pluginSyntaxDynamicImport = _interopRequireDefault(__webpack_require__(87)), _pluginSyntaxJsonStrings = _interopRequireDefault(__webpack_require__(88)), _pluginSyntaxNullishCoalescingOperator = _interopRequireDefault(__webpack_require__(89)), _pluginSyntaxNumericSeparator = _interopRequireDefault(__webpack_require__(90)), _pluginSyntaxObjectRestSpread = _interopRequireDefault(__webpack_require__(91)), _pluginSyntaxOptionalCatchBinding = _interopRequireDefault(__webpack_require__(92)), _pluginSyntaxOptionalChaining = _interopRequireDefault(__webpack_require__(93)), _pluginSyntaxTopLevelAwait = _interopRequireDefault(__webpack_require__(176)), _pluginProposalAsyncGeneratorFunctions = _interopRequireDefault(__webpack_require__(177)), _pluginProposalClassProperties = _interopRequireDefault(__webpack_require__(306)), _pluginProposalDynamicImport = _interopRequireDefault(__webpack_require__(369)), _pluginProposalJsonStrings = _interopRequireDefault(__webpack_require__(371)), _pluginProposalNullishCoalescingOperator = _interopRequireDefault(__webpack_require__(372)), _pluginProposalNumericSeparator = _interopRequireDefault(__webpack_require__(373)), _pluginProposalObjectRestSpread = _interopRequireDefault(__webpack_require__(374)), _pluginProposalOptionalCatchBinding = _interopRequireDefault(__webpack_require__(377)), _pluginProposalOptionalChaining = _interopRequireDefault(__webpack_require__(378)), _pluginProposalPrivateMethods = _interopRequireDefault(__webpack_require__(379)), _pluginProposalUnicodePropertyRegex = _interopRequireDefault(__webpack_require__(380)), _pluginTransformAsyncToGenerator = _interopRequireDefault(__webpack_require__(392)), _pluginTransformArrowFunctions = _interopRequireDefault(__webpack_require__(395)), _pluginTransformBlockScopedFunctions = _interopRequireDefault(__webpack_require__(396)), _pluginTransformBlockScoping = _interopRequireDefault(__webpack_require__(397)), _pluginTransformClasses = _interopRequireDefault(__webpack_require__(399)), _pluginTransformComputedProperties = _interopRequireDefault(__webpack_require__(414)), _pluginTransformDestructuring = _interopRequireDefault(__webpack_require__(415)), _pluginTransformDotallRegex = _interopRequireDefault(__webpack_require__(416)), _pluginTransformDuplicateKeys = _interopRequireDefault(__webpack_require__(417)), _pluginTransformExponentiationOperator = _interopRequireDefault(__webpack_require__(418)), _pluginTransformForOf = _interopRequireDefault(__webpack_require__(421)), _pluginTransformFunctionName = _interopRequireDefault(__webpack_require__(423)), _pluginTransformLiterals = _interopRequireDefault(__webpack_require__(424)), _pluginTransformMemberExpressionLiterals = _interopRequireDefault(__webpack_require__(425)), _pluginTransformModulesAmd = _interopRequireDefault(__webpack_require__(426)), _pluginTransformModulesCommonjs = _interopRequireDefault(__webpack_require__(437)), _pluginTransformModulesSystemjs = _interopRequireDefault(__webpack_require__(438)), _pluginTransformModulesUmd = _interopRequireDefault(__webpack_require__(440)), _pluginTransformNamedCapturingGroupsRegex = _interopRequireDefault(__webpack_require__(441)), _pluginTransformNewTarget = _interopRequireDefault(__webpack_require__(442)), _pluginTransformObjectSuper = _interopRequireDefault(__webpack_require__(443)), _pluginTransformParameters = _interopRequireDefault(__webpack_require__(150)), _pluginTransformPropertyLiterals = _interopRequireDefault(__webpack_require__(444)), _pluginTransformRegenerator = _interopRequireDefault(__webpack_require__(445)), _pluginTransformReservedWords = _interopRequireDefault(__webpack_require__(453)), _pluginTransformShorthandProperties = _interopRequireDefault(__webpack_require__(454)), _pluginTransformSpread = _interopRequireDefault(__webpack_require__(455)), _pluginTransformStickyRegex = _interopRequireDefault(__webpack_require__(456)), _pluginTransformTemplateLiterals = _interopRequireDefault(__webpack_require__(457)), _pluginTransformTypeofSymbol = _interopRequireDefault(__webpack_require__(458)), _pluginTransformUnicodeEscapes = _interopRequireDefault(__webpack_require__(459)), _pluginTransformUnicodeRegex = _interopRequireDefault(__webpack_require__(460)), _transformAsyncArrowsInClass = _interopRequireDefault(__webpack_require__(461)), _transformEdgeDefaultParameters = _interopRequireDefault(__webpack_require__(462)), _transformEdgeFunctionName = _interopRequireDefault(__webpack_require__(463)), _transformTaggedTemplateCaching = _interopRequireDefault(__webpack_require__(464)), _transformSafariBlockShadowing = _interopRequireDefault(__webpack_require__(465)), _transformSafariForShadowing = _interopRequireDefault(__webpack_require__(466));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var _default = {
    "bugfix/transform-async-arrows-in-class": _transformAsyncArrowsInClass.default,
    "bugfix/transform-edge-default-parameters": _transformEdgeDefaultParameters.default,
    "bugfix/transform-edge-function-name": _transformEdgeFunctionName.default,
    "bugfix/transform-safari-block-shadowing": _transformSafariBlockShadowing.default,
    "bugfix/transform-safari-for-shadowing": _transformSafariForShadowing.default,
    "bugfix/transform-tagged-template-caching": _transformTaggedTemplateCaching.default,
    "proposal-async-generator-functions": _pluginProposalAsyncGeneratorFunctions.default,
    "proposal-class-properties": _pluginProposalClassProperties.default,
    "proposal-dynamic-import": _pluginProposalDynamicImport.default,
    "proposal-json-strings": _pluginProposalJsonStrings.default,
    "proposal-nullish-coalescing-operator": _pluginProposalNullishCoalescingOperator.default,
    "proposal-numeric-separator": _pluginProposalNumericSeparator.default,
    "proposal-object-rest-spread": _pluginProposalObjectRestSpread.default,
    "proposal-optional-catch-binding": _pluginProposalOptionalCatchBinding.default,
    "proposal-optional-chaining": _pluginProposalOptionalChaining.default,
    "proposal-private-methods": _pluginProposalPrivateMethods.default,
    "proposal-unicode-property-regex": _pluginProposalUnicodePropertyRegex.default,
    "syntax-async-generators": _pluginSyntaxAsyncGenerators.default,
    "syntax-class-properties": _pluginSyntaxClassProperties.default,
    "syntax-dynamic-import": _pluginSyntaxDynamicImport.default,
    "syntax-json-strings": _pluginSyntaxJsonStrings.default,
    "syntax-nullish-coalescing-operator": _pluginSyntaxNullishCoalescingOperator.default,
    "syntax-numeric-separator": _pluginSyntaxNumericSeparator.default,
    "syntax-object-rest-spread": _pluginSyntaxObjectRestSpread.default,
    "syntax-optional-catch-binding": _pluginSyntaxOptionalCatchBinding.default,
    "syntax-optional-chaining": _pluginSyntaxOptionalChaining.default,
    "syntax-top-level-await": _pluginSyntaxTopLevelAwait.default,
    "transform-arrow-functions": _pluginTransformArrowFunctions.default,
    "transform-async-to-generator": _pluginTransformAsyncToGenerator.default,
    "transform-block-scoped-functions": _pluginTransformBlockScopedFunctions.default,
    "transform-block-scoping": _pluginTransformBlockScoping.default,
    "transform-classes": _pluginTransformClasses.default,
    "transform-computed-properties": _pluginTransformComputedProperties.default,
    "transform-destructuring": _pluginTransformDestructuring.default,
    "transform-dotall-regex": _pluginTransformDotallRegex.default,
    "transform-duplicate-keys": _pluginTransformDuplicateKeys.default,
    "transform-exponentiation-operator": _pluginTransformExponentiationOperator.default,
    "transform-for-of": _pluginTransformForOf.default,
    "transform-function-name": _pluginTransformFunctionName.default,
    "transform-literals": _pluginTransformLiterals.default,
    "transform-member-expression-literals": _pluginTransformMemberExpressionLiterals.default,
    "transform-modules-amd": _pluginTransformModulesAmd.default,
    "transform-modules-commonjs": _pluginTransformModulesCommonjs.default,
    "transform-modules-systemjs": _pluginTransformModulesSystemjs.default,
    "transform-modules-umd": _pluginTransformModulesUmd.default,
    "transform-named-capturing-groups-regex": _pluginTransformNamedCapturingGroupsRegex.default,
    "transform-new-target": _pluginTransformNewTarget.default,
    "transform-object-super": _pluginTransformObjectSuper.default,
    "transform-parameters": _pluginTransformParameters.default,
    "transform-property-literals": _pluginTransformPropertyLiterals.default,
    "transform-regenerator": _pluginTransformRegenerator.default,
    "transform-reserved-words": _pluginTransformReservedWords.default,
    "transform-shorthand-properties": _pluginTransformShorthandProperties.default,
    "transform-spread": _pluginTransformSpread.default,
    "transform-sticky-regex": _pluginTransformStickyRegex.default,
    "transform-template-literals": _pluginTransformTemplateLiterals.default,
    "transform-typeof-symbol": _pluginTransformTypeofSymbol.default,
    "transform-unicode-escapes": _pluginTransformUnicodeEscapes.default,
    "transform-unicode-regex": _pluginTransformUnicodeRegex.default
  };
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-async-generators",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("asyncGenerators");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-dynamic-import",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("dynamicImport");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-json-strings",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("jsonStrings");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-nullish-coalescing-operator",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("nullishCoalescingOperator");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-numeric-separator",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("numericSeparator");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-object-rest-spread",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("objectRestSpread");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-optional-catch-binding",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalCatchBinding");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-optional-chaining",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("optionalChaining");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, helpers) {
    path.traverse(awaitVisitor, {
      wrapAwait: helpers.wrapAwait
    });
    const isIIFE = function(path) {
      if (path.parentPath.isCallExpression({
        callee: path.node
      })) return !0;
      const {parentPath: parentPath} = path;
      if (parentPath.isMemberExpression() && t.isIdentifier(parentPath.node.property, {
        name: "bind"
      })) {
        const {parentPath: bindCall} = parentPath;
        return bindCall.isCallExpression() && 1 === bindCall.node.arguments.length && t.isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
          callee: bindCall.node
        });
      }
      return !1;
    }(path);
    path.node.async = !1, path.node.generator = !0, (0, _helperWrapFunction.default)(path, t.cloneNode(helpers.wrapAsync));
    path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty() || isIIFE || !path.isExpression() || (0, 
    _helperAnnotateAsPure.default)(path);
  };
  var _helperWrapFunction = _interopRequireDefault(__webpack_require__(178)), _helperAnnotateAsPure = _interopRequireDefault(__webpack_require__(42)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const awaitVisitor = {
    Function(path) {
      path.skip();
    },
    AwaitExpression(path, {wrapAwait: wrapAwait}) {
      const argument = path.get("argument");
      path.parentPath.isYieldExpression() ? path.replaceWith(argument.node) : path.replaceWith(t.yieldExpression(wrapAwait ? t.callExpression(t.cloneNode(wrapAwait), [ argument.node ]) : argument.node));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(match, allowPartial) {
    const parts = match.split(".");
    return member => (0, _matchesPattern.default)(member, parts, allowPartial);
  };
  var obj, _matchesPattern = (obj = __webpack_require__(96)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(member, match, allowPartial) {
    if (!(0, _generated.isMemberExpression)(member)) return !1;
    const parts = Array.isArray(match) ? match : match.split("."), nodes = [];
    let node;
    for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) nodes.push(node.property);
    if (nodes.push(node), nodes.length < parts.length) return !1;
    if (!allowPartial && nodes.length > parts.length) return !1;
    for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      const node = nodes[j];
      let value;
      if ((0, _generated.isIdentifier)(node)) value = node.name; else {
        if (!(0, _generated.isStringLiteral)(node)) return !1;
        value = node.value;
      }
      if (parts[i] !== value) return !1;
    }
    return !0;
  };
  var _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(13), isObject = __webpack_require__(14);
  module.exports = function(value) {
    if (!isObject(value)) return !1;
    var tag = baseGetTag(value);
    return "[object Function]" == tag || "[object GeneratorFunction]" == tag || "[object AsyncFunction]" == tag || "[object Proxy]" == tag;
  };
}, function(module, exports) {
  var freeGlobal = "object" == typeof global && global && global.Object === Object && global;
  module.exports = freeGlobal;
}, function(module, exports) {
  var funcToString = Function.prototype.toString;
  module.exports = function(func) {
    if (null != func) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  };
}, function(module, exports, __webpack_require__) {
  var mapCacheClear = __webpack_require__(204), mapCacheDelete = __webpack_require__(211), mapCacheGet = __webpack_require__(213), mapCacheHas = __webpack_require__(214), mapCacheSet = __webpack_require__(215);
  function MapCache(entries) {
    var index = -1, length = null == entries ? 0 : entries.length;
    for (this.clear(); ++index < length; ) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, 
  MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, 
  module.exports = MapCache;
}, function(module, exports, __webpack_require__) {
  var baseAssignValue = __webpack_require__(102), eq = __webpack_require__(32), hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(object, key, value) {
    var objValue = object[key];
    hasOwnProperty.call(object, key) && eq(objValue, value) && (void 0 !== value || key in object) || baseAssignValue(object, key, value);
  };
}, function(module, exports, __webpack_require__) {
  var defineProperty = __webpack_require__(103);
  module.exports = function(object, key, value) {
    "__proto__" == key && defineProperty ? defineProperty(object, key, {
      configurable: !0,
      enumerable: !0,
      value: value,
      writable: !0
    }) : object[key] = value;
  };
}, function(module, exports, __webpack_require__) {
  var getNative = __webpack_require__(12), defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      return func({}, "", {}), func;
    } catch (e) {}
  }();
  module.exports = defineProperty;
}, function(module, exports, __webpack_require__) {
  var baseTimes = __webpack_require__(218), isArguments = __webpack_require__(105), isArray = __webpack_require__(15), isBuffer = __webpack_require__(106), isIndex = __webpack_require__(59), isTypedArray = __webpack_require__(221), hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
    return result;
  };
}, function(module, exports, __webpack_require__) {
  var baseIsArguments = __webpack_require__(219), isObjectLike = __webpack_require__(9), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, propertyIsEnumerable = objectProto.propertyIsEnumerable, isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module.exports = isArguments;
}, function(module, exports, __webpack_require__) {
  (function(module) {
    var root = __webpack_require__(6), stubFalse = __webpack_require__(220), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0, isBuffer = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;
    module.exports = isBuffer;
  }).call(this, __webpack_require__(58)(module));
}, function(module, exports) {
  module.exports = function(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  };
}, function(module, exports) {
  module.exports = function(source, array) {
    var index = -1, length = source.length;
    for (array || (array = Array(length)); ++index < length; ) array[index] = source[index];
    return array;
  };
}, function(module, exports) {
  module.exports = function() {
    return [];
  };
}, function(module, exports, __webpack_require__) {
  var arrayPush = __webpack_require__(111), getPrototype = __webpack_require__(64), getSymbols = __webpack_require__(63), stubArray = __webpack_require__(109), getSymbolsIn = Object.getOwnPropertySymbols ? function(object) {
    for (var result = []; object; ) arrayPush(result, getSymbols(object)), object = getPrototype(object);
    return result;
  } : stubArray;
  module.exports = getSymbolsIn;
}, function(module, exports) {
  module.exports = function(array, values) {
    for (var index = -1, length = values.length, offset = array.length; ++index < length; ) array[offset + index] = values[index];
    return array;
  };
}, function(module, exports, __webpack_require__) {
  var arrayPush = __webpack_require__(111), isArray = __webpack_require__(15);
  module.exports = function(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(placeholderType, targetType) {
    if (placeholderType === targetType) return !0;
    const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) for (const alias of aliases) if (targetType === alias) return !0;
    return !1;
  };
  var _definitions = __webpack_require__(5);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;
  var _utils = __webpack_require__(7);
  const PLACEHOLDERS = [ "Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern" ];
  exports.PLACEHOLDERS = PLACEHOLDERS;
  const PLACEHOLDERS_ALIAS = {
    Declaration: [ "Statement" ],
    Pattern: [ "PatternLike", "LVal" ]
  };
  exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;
  for (const type of PLACEHOLDERS) {
    const alias = _utils.ALIAS_KEYS[type];
    (null == alias ? void 0 : alias.length) && (PLACEHOLDERS_ALIAS[type] = alias);
  }
  const PLACEHOLDERS_FLIPPED_ALIAS = {};
  exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS, Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
    PLACEHOLDERS_ALIAS[type].forEach(alias => {
      Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias) || (PLACEHOLDERS_FLIPPED_ALIAS[alias] = []), 
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return !(!node || !_definitions.VISITOR_KEYS[node.type]);
  };
  var _definitions = __webpack_require__(5);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function removeTypeDuplicates(nodes) {
    const generics = {}, bases = {}, typeGroups = [], types = [];
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node && !(types.indexOf(node) >= 0)) {
        if ((0, _generated.isAnyTypeAnnotation)(node)) return [ node ];
        if ((0, _generated.isFlowBaseAnnotation)(node)) bases[node.type] = node; else if ((0, 
        _generated.isUnionTypeAnnotation)(node)) typeGroups.indexOf(node.types) < 0 && (nodes = nodes.concat(node.types), 
        typeGroups.push(node.types)); else if ((0, _generated.isGenericTypeAnnotation)(node)) {
          const name = node.id.name;
          if (generics[name]) {
            let existing = generics[name];
            existing.typeParameters ? node.typeParameters && (existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params))) : existing = node.typeParameters;
          } else generics[name] = node;
        } else types.push(node);
      }
    }
    for (const type of Object.keys(bases)) types.push(bases[type]);
    for (const name of Object.keys(generics)) types.push(generics[name]);
    return types;
  };
  var _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, type, comments) {
    if (!comments || !node) return node;
    const key = type + "Comments";
    node[key] ? node[key] = "leading" === type ? comments.concat(node[key]) : node[key].concat(comments) : node[key] = comments;
    return node;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(child, parent) {
    (0, _inherit.default)("innerComments", child, parent);
  };
  var obj, _inherit = (obj = __webpack_require__(71)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(child, parent) {
    (0, _inherit.default)("leadingComments", child, parent);
  };
  var obj, _inherit = (obj = __webpack_require__(71)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(child, parent) {
    return (0, _inheritTrailingComments.default)(child, parent), (0, _inheritLeadingComments.default)(child, parent), 
    (0, _inheritInnerComments.default)(child, parent), child;
  };
  var _inheritTrailingComments = _interopRequireDefault(__webpack_require__(121)), _inheritLeadingComments = _interopRequireDefault(__webpack_require__(119)), _inheritInnerComments = _interopRequireDefault(__webpack_require__(118));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  };
  var obj, _inherit = (obj = __webpack_require__(71)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, parent) {
    if ((0, _generated.isBlockStatement)(node)) return node;
    let blockNodes = [];
    (0, _generated.isEmptyStatement)(node) ? blockNodes = [] : ((0, _generated.isStatement)(node) || (node = (0, 
    _generated.isFunction)(parent) ? (0, _generated2.returnStatement)(node) : (0, _generated2.expressionStatement)(node)), 
    blockNodes = [ node ]);
    return (0, _generated2.blockStatement)(blockNodes);
  };
  var _generated = __webpack_require__(3), _generated2 = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(name) {
    name = (name = (name = (name += "").replace(/[^a-zA-Z0-9$_]/g, "-")).replace(/^[-0-9]+/, "")).replace(/[-\s]+(.)?/g, (function(match, c) {
      return c ? c.toUpperCase() : "";
    })), (0, _isValidIdentifier.default)(name) || (name = "_" + name);
    return name || "_";
  };
  var obj, _isValidIdentifier = (obj = __webpack_require__(27)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(tree, opts) {
    return (0, _traverseFast.default)(tree, _removeProperties.default, opts), tree;
  };
  var _traverseFast = _interopRequireDefault(__webpack_require__(125)), _removeProperties = _interopRequireDefault(__webpack_require__(126));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = _definitions.VISITOR_KEYS[node.type];
    if (!keys) return;
    enter(node, opts = opts || {});
    for (const key of keys) {
      const subNode = node[key];
      if (Array.isArray(subNode)) for (const node of subNode) traverseFast(node, enter, opts); else traverseFast(subNode, enter, opts);
    }
  };
  var _definitions = __webpack_require__(5);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    for (const key of map) null != node[key] && (node[key] = void 0);
    for (const key of Object.keys(node)) "_" === key[0] && null != node[key] && (node[key] = void 0);
    const symbols = Object.getOwnPropertySymbols(node);
    for (const sym of symbols) node[sym] = null;
  };
  var _constants = __webpack_require__(16);
  const CLEAR_KEYS = [ "tokens", "start", "end", "loc", "raw", "rawValue" ], CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat([ "comments" ]).concat(CLEAR_KEYS);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _generated.isVariableDeclaration)(node) && ("var" !== node.kind || node[_constants.BLOCK_SCOPED_SYMBOL]);
  };
  var _generated = __webpack_require__(3), _constants = __webpack_require__(16);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(formatter, code, opts) {
    const {placeholderWhitelist: placeholderWhitelist, placeholderPattern: placeholderPattern, preserveComments: preserveComments, syntacticPlaceholders: syntacticPlaceholders} = opts, ast = function(code, parserOpts, syntacticPlaceholders) {
      const plugins = (parserOpts.plugins || []).slice();
      !1 !== syntacticPlaceholders && plugins.push("placeholders");
      parserOpts = Object.assign({
        allowReturnOutsideFunction: !0,
        allowSuperOutsideMethod: !0,
        sourceType: "module"
      }, parserOpts, {
        plugins: plugins
      });
      try {
        return (0, _parser.parse)(code, parserOpts);
      } catch (err) {
        const loc = err.loc;
        throw loc && (err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        }), err.code = "BABEL_TEMPLATE_PARSE_ERROR"), err;
      }
    }(code, opts.parser, syntacticPlaceholders);
    t.removePropertiesDeep(ast, {
      preserveComments: preserveComments
    }), formatter.validate(ast);
    const syntactic = {
      placeholders: [],
      placeholderNames: new Set
    }, legacy = {
      placeholders: [],
      placeholderNames: new Set
    }, isLegacyRef = {
      value: void 0
    };
    return t.traverse(ast, placeholderVisitorHandler, {
      syntactic: syntactic,
      legacy: legacy,
      isLegacyRef: isLegacyRef,
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      syntacticPlaceholders: syntacticPlaceholders
    }), Object.assign({
      ast: ast
    }, isLegacyRef.value ? legacy : syntactic);
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _parser = __webpack_require__(129), _codeFrame = __webpack_require__(130);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const PATTERN = /^[_$A-Z0-9]+$/;
  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;
    let name;
    if (t.isPlaceholder(node)) {
      if (!1 === state.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      name = node.name.name, state.isLegacyRef.value = !1;
    } else {
      if (!1 === state.isLegacyRef.value || state.syntacticPlaceholders) return;
      if (t.isIdentifier(node) || t.isJSXIdentifier(node)) name = node.name, state.isLegacyRef.value = !0; else {
        if (!t.isStringLiteral(node)) return;
        name = node.value, state.isLegacyRef.value = !0;
      }
    }
    if (!state.isLegacyRef.value && (null != state.placeholderPattern || null != state.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (state.isLegacyRef.value && (!1 === state.placeholderPattern || !(state.placeholderPattern || PATTERN).test(name)) && !(null == (_state$placeholderWhi = state.placeholderWhitelist) ? void 0 : _state$placeholderWhi.has(name))) return;
    ancestors = ancestors.slice();
    const {node: parent, key: key} = ancestors[ancestors.length - 1];
    let type;
    t.isStringLiteral(node) || t.isPlaceholder(node, {
      expectedNode: "StringLiteral"
    }) ? type = "string" : t.isNewExpression(parent) && "arguments" === key || t.isCallExpression(parent) && "arguments" === key || t.isFunction(parent) && "params" === key ? type = "param" : t.isExpressionStatement(parent) && !t.isPlaceholder(node) ? (type = "statement", 
    ancestors = ancestors.slice(0, -1)) : type = t.isStatement(node) && t.isPlaceholder(node) ? "statement" : "other";
    const {placeholders: placeholders, placeholderNames: placeholderNames} = state.isLegacyRef.value ? state.legacy : state.syntactic;
    placeholders.push({
      name: name,
      type: type,
      resolve: ast => function(ast, ancestors) {
        let parent = ast;
        for (let i = 0; i < ancestors.length - 1; i++) {
          const {key: key, index: index} = ancestors[i];
          parent = void 0 === index ? parent[key] : parent[key][index];
        }
        const {key: key, index: index} = ancestors[ancestors.length - 1];
        return {
          parent: parent,
          key: key,
          index: index
        };
      }(ast, ancestors),
      isDuplicate: placeholderNames.has(name)
    }), placeholderNames.add(name);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  class TokenType {
    constructor(label, conf = {}) {
      this.label = label, this.keyword = conf.keyword, this.beforeExpr = !!conf.beforeExpr, 
      this.startsExpr = !!conf.startsExpr, this.rightAssociative = !!conf.rightAssociative, 
      this.isLoop = !!conf.isLoop, this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, 
      this.postfix = !!conf.postfix, this.binop = null != conf.binop ? conf.binop : null, 
      this.updateContext = null;
    }
  }
  const keywords = new Map;
  function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = new TokenType(name, options);
    return keywords.set(name, token), token;
  }
  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr: !0,
      binop: binop
    });
  }
  const types = {
    num: new TokenType("num", {
      startsExpr: !0
    }),
    bigint: new TokenType("bigint", {
      startsExpr: !0
    }),
    regexp: new TokenType("regexp", {
      startsExpr: !0
    }),
    string: new TokenType("string", {
      startsExpr: !0
    }),
    name: new TokenType("name", {
      startsExpr: !0
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    braceR: new TokenType("}"),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr: !0
    }),
    semi: new TokenType(";", {
      beforeExpr: !0
    }),
    colon: new TokenType(":", {
      beforeExpr: !0
    }),
    doubleColon: new TokenType("::", {
      beforeExpr: !0
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr: !0
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr: !0
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr: !0
    }),
    backQuote: new TokenType("`", {
      startsExpr: !0
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr: !0
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr: !0,
      isAssign: !0
    }),
    assign: new TokenType("_=", {
      beforeExpr: !0,
      isAssign: !0
    }),
    incDec: new TokenType("++/--", {
      prefix: !0,
      postfix: !0,
      startsExpr: !0
    }),
    bang: new TokenType("!", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    tilde: new TokenType("~", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: !0,
      binop: 9,
      prefix: !0,
      startsExpr: !0
    }),
    modulo: new TokenType("%", {
      beforeExpr: !0,
      binop: 10,
      startsExpr: !0
    }),
    star: createBinop("*", 10),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr: !0,
      binop: 11,
      rightAssociative: !0
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr: !0
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr: !0
    }),
    _do: createKeyword("do", {
      isLoop: !0,
      beforeExpr: !0
    }),
    _else: createKeyword("else", {
      beforeExpr: !0
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop: !0
    }),
    _function: createKeyword("function", {
      startsExpr: !0
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr: !0
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop: !0
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    _this: createKeyword("this", {
      startsExpr: !0
    }),
    _super: createKeyword("super", {
      startsExpr: !0
    }),
    _class: createKeyword("class", {
      startsExpr: !0
    }),
    _extends: createKeyword("extends", {
      beforeExpr: !0
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr: !0
    }),
    _null: createKeyword("null", {
      startsExpr: !0
    }),
    _true: createKeyword("true", {
      startsExpr: !0
    }),
    _false: createKeyword("false", {
      startsExpr: !0
    }),
    _in: createKeyword("in", {
      beforeExpr: !0,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr: !0,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _void: createKeyword("void", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _delete: createKeyword("delete", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    })
  }, lineBreak = /\r\n?|[\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
     case 10:
     case 13:
     case 8232:
     case 8233:
      return !0;

     default:
      return !1;
    }
  }
  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
     case 9:
     case 11:
     case 12:
     case 32:
     case 160:
     case 5760:
     case 8192:
     case 8193:
     case 8194:
     case 8195:
     case 8196:
     case 8197:
     case 8198:
     case 8199:
     case 8200:
     case 8201:
     case 8202:
     case 8239:
     case 8287:
     case 12288:
     case 65279:
      return !0;

     default:
      return !1;
    }
  }
  class Position {
    constructor(line, col) {
      this.line = line, this.column = col;
    }
  }
  class SourceLocation {
    constructor(start, end) {
      this.start = start, this.end = end;
    }
  }
  function last(stack) {
    return stack[stack.length - 1];
  }
  const ErrorMessages = Object.freeze({
    ArgumentsDisallowedInInitializer: "'arguments' is not allowed in class field initializer",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
    AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
    AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function",
    BadGetterArity: "getter must not have any formal parameters",
    BadSetterArity: "setter must have exactly one formal parameter",
    BadSetterRestParameter: "setter function argument must not be a rest parameter",
    ConstructorClassField: "Classes may not have a field named 'constructor'",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
    ConstructorIsAccessor: "Class constructor may not be an accessor",
    ConstructorIsAsync: "Constructor can't be an async function",
    ConstructorIsGenerator: "Constructor can't be a generator",
    DeclarationMissingInitializer: "%0 require an initialization value",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon",
    DeletePrivateField: "Deleting a private field is not allowed",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property",
    DuplicateRegExpFlags: "Duplicate regular expression flag",
    ElementAfterRest: "Rest element must be last element",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'",
    ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
    IllegalBreakContinue: "Unsyntactic %0",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
    IllegalReturn: "'return' outside of function",
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
    ImportCallArity: "import() requires exactly %0",
    ImportCallNotNewExpression: "Cannot use new with import(...)",
    ImportCallSpreadArgument: "... is not allowed in import()",
    ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
    ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
    InvalidBigIntLiteral: "Invalid BigIntLiteral",
    InvalidCodePoint: "Code point out of bounds",
    InvalidDigit: "Expected number in radix %0",
    InvalidEscapeSequence: "Bad character escape sequence",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0",
    InvalidIdentifier: "Invalid identifier %0",
    InvalidLhs: "Invalid left-hand side in %0",
    InvalidLhsBinding: "Binding invalid left-hand side in %0",
    InvalidNumber: "Invalid number",
    InvalidOrUnexpectedToken: "Unexpected character '%0'",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined",
    InvalidPropertyBindingPattern: "Binding member expression",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument",
    LabelRedeclaration: "Label '%0' is already declared",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    MalformedRegExpFlags: "Invalid regular expression flag",
    MissingClassName: "A class name is required",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes',
    ModuleExportUndefined: "Export '%0' is not defined",
    MultipleDefaultsInSwitch: "Multiple default clauses",
    NewlineAfterThrow: "Illegal newline after throw",
    NoCatchOrFinally: "Missing catch or finally clause",
    NumberIdentifier: "Identifier directly after number",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
    ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
    ParamDupe: "Argument name clash",
    PatternHasAccessor: "Object pattern can't contain getter or setter",
    PatternHasMethod: "Object pattern can't contain methods",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
    PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
    PrivateNameRedeclaration: "Duplicate private name #%0",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    RecordNoProto: "'__proto__' is not allowed in Record expressions",
    RestTrailingComma: "Unexpected trailing comma after rest element",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
    StaticPrototype: "Classes may not have static property named prototype",
    StrictDelete: "Deleting local variable in strict mode",
    StrictEvalArguments: "Assigning to '%0' in strict mode",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
    StrictWith: "'with' in strict mode",
    SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super",
    TrailingDecorator: "Decorators must be attached to a class element",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
    UnexpectedKeyword: "Unexpected keyword '%0'",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
    UnexpectedNewTarget: "new.target can only be used in functions",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'",
    UnexpectedSuper: "super is only allowed in object methods and classes",
    UnexpectedToken: "Unexpected token '%0'",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "import can only be used in import() or import.meta",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
    UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
    UnterminatedComment: "Unterminated comment",
    UnterminatedRegExp: "Unterminated regular expression",
    UnterminatedString: "Unterminated string constant",
    UnterminatedTemplate: "Unterminated template",
    VarRedeclaration: "Identifier '%0' has already been declared",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
    YieldInParameter: "yield is not allowed in generator parameters",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
  });
  function isSimpleProperty(node) {
    return null != node && "Property" === node.type && "init" === node.kind && !1 === node.method;
  }
  class TokContext {
    constructor(token, isExpr, preserveSpace, override) {
      this.token = token, this.isExpr = !!isExpr, this.preserveSpace = !!preserveSpace, 
      this.override = override;
    }
  }
  const types$1 = {
    braceStatement: new TokContext("{", !1),
    braceExpression: new TokContext("{", !0),
    templateQuasi: new TokContext("${", !1),
    parenStatement: new TokContext("(", !1),
    parenExpression: new TokContext("(", !0),
    template: new TokContext("`", !0, !0, p => p.readTmplToken()),
    functionExpression: new TokContext("function", !0),
    functionStatement: new TokContext("function", !1)
  };
  types.parenR.updateContext = types.braceR.updateContext = function() {
    if (1 === this.state.context.length) return void (this.state.exprAllowed = !0);
    let out = this.state.context.pop();
    out === types$1.braceStatement && "function" === this.curContext().token && (out = this.state.context.pop()), 
    this.state.exprAllowed = !out.isExpr;
  }, types.name.updateContext = function(prevType) {
    let allowed = !1;
    prevType !== types.dot && ("of" === this.state.value && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class || "yield" === this.state.value && this.prodParam.hasYield) && (allowed = !0), 
    this.state.exprAllowed = allowed, this.state.isIterator && (this.state.isIterator = !1);
  }, types.braceL.updateContext = function(prevType) {
    this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression), 
    this.state.exprAllowed = !0;
  }, types.dollarBraceL.updateContext = function() {
    this.state.context.push(types$1.templateQuasi), this.state.exprAllowed = !0;
  }, types.parenL.updateContext = function(prevType) {
    const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression), 
    this.state.exprAllowed = !0;
  }, types.incDec.updateContext = function() {}, types._function.updateContext = types._class.updateContext = function(prevType) {
    prevType === types.dot || prevType === types.questionDot || (!prevType.beforeExpr || prevType === types.semi || prevType === types._else || prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)) || (prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat ? this.state.context.push(types$1.functionStatement) : this.state.context.push(types$1.functionExpression)), 
    this.state.exprAllowed = !1;
  }, types.backQuote.updateContext = function() {
    this.curContext() === types$1.template ? this.state.context.pop() : this.state.context.push(types$1.template), 
    this.state.exprAllowed = !1;
  }, types.star.updateContext = function() {
    this.state.exprAllowed = !1;
  };
  let nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938 ], astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239 ];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      if (pos += set[i], pos > code) return !1;
      if (pos += set[i + 1], pos >= code) return !0;
    }
    return !1;
  }
  function isIdentifierStart(code) {
    return code < 65 ? 36 === code : code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes)));
  }
  function isIdentifierChar(code) {
    return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes))));
  }
  const reservedWords_strict = [ "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield" ], reservedWords_strictBind = [ "eval", "arguments" ], keywords$1 = new Set([ "break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete" ]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
  function isReservedWord(word, inModule) {
    return inModule && "await" === word || "enum" === word;
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  const keywordRelationalOperator = /^in(stanceof)?$/;
  const reservedTypes = new Set([ "_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void" ]), FlowErrors = Object.freeze({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
    AssignReservedType: "Cannot overwrite reserved type %0",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
    InexactVariance: "Explicit inexact syntax cannot have variance",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SpreadVariance: "Spread properties cannot have variance",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
    UnexpectedReservedType: "Unexpected reserved type %0",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
    UnterminatedFlowComment: "Unterminated flow-comment"
  });
  function hasTypeImportKind(node) {
    return "type" === node.importKind || "typeof" === node.importKind;
  }
  function isMaybeDefaultImport(state) {
    return (state.type === types.name || !!state.type.keyword) && "from" !== state.value;
  }
  const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  const entities = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  }, HEX_NUMBER = /^[\da-fA-F]+$/, DECIMAL_NUMBER = /^\d+$/, JsxErrors = Object.freeze({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
    UnterminatedJsxContent: "Unterminated JSX contents",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function isFragment(object) {
    return !!object && ("JSXOpeningFragment" === object.type || "JSXClosingFragment" === object.type);
  }
  function getQualifiedJSXName(object) {
    if ("JSXIdentifier" === object.type) return object.name;
    if ("JSXNamespacedName" === object.type) return object.namespace.name + ":" + object.name.name;
    if ("JSXMemberExpression" === object.type) return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    throw new Error("Node had unexpected type: " + object.type);
  }
  types$1.j_oTag = new TokContext("<tag", !1), types$1.j_cTag = new TokContext("</tag", !1), 
  types$1.j_expr = new TokContext("<tag>...</tag>", !0, !0), types.jsxName = new TokenType("jsxName"), 
  types.jsxText = new TokenType("jsxText", {
    beforeExpr: !0
  }), types.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: !0
  }), types.jsxTagEnd = new TokenType("jsxTagEnd"), types.jsxTagStart.updateContext = function() {
    this.state.context.push(types$1.j_expr), this.state.context.push(types$1.j_oTag), 
    this.state.exprAllowed = !1;
  }, types.jsxTagEnd.updateContext = function(prevType) {
    const out = this.state.context.pop();
    out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag ? (this.state.context.pop(), 
    this.state.exprAllowed = this.curContext() === types$1.j_expr) : this.state.exprAllowed = !0;
  };
  class Scope {
    constructor(flags) {
      this.var = [], this.lexical = [], this.functions = [], this.flags = flags;
    }
  }
  class ScopeHandler {
    constructor(raise, inModule) {
      this.scopeStack = [], this.undefinedExports = new Map, this.undefinedPrivateNames = new Map, 
      this.raise = raise, this.inModule = inModule;
    }
    get inFunction() {
      return (2 & this.currentVarScope().flags) > 0;
    }
    get allowSuper() {
      return (16 & this.currentThisScope().flags) > 0;
    }
    get allowDirectSuper() {
      return (32 & this.currentThisScope().flags) > 0;
    }
    get inClass() {
      return (64 & this.currentThisScope().flags) > 0;
    }
    get inNonArrowFunction() {
      return (2 & this.currentThisScope().flags) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(flags) {
      return new Scope(flags);
    }
    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }
    exit() {
      this.scopeStack.pop();
    }
    treatFunctionsAsVarInScope(scope) {
      return !!(2 & scope.flags || !this.inModule && 1 & scope.flags);
    }
    declareName(name, bindingType, pos) {
      let scope = this.currentScope();
      if (8 & bindingType || 16 & bindingType) this.checkRedeclarationInScope(scope, name, bindingType, pos), 
      16 & bindingType ? scope.functions.push(name) : scope.lexical.push(name), 8 & bindingType && this.maybeExportDefined(scope, name); else if (4 & bindingType) for (let i = this.scopeStack.length - 1; i >= 0 && (scope = this.scopeStack[i], 
      this.checkRedeclarationInScope(scope, name, bindingType, pos), scope.var.push(name), 
      this.maybeExportDefined(scope, name), !(131 & scope.flags)); --i) ;
      this.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
    }
    maybeExportDefined(scope, name) {
      this.inModule && 1 & scope.flags && this.undefinedExports.delete(name);
    }
    checkRedeclarationInScope(scope, name, bindingType, pos) {
      this.isRedeclaredInScope(scope, name, bindingType) && this.raise(pos, ErrorMessages.VarRedeclaration, name);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      return !!(1 & bindingType) && (8 & bindingType ? scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1 : 16 & bindingType ? scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1 : scope.lexical.indexOf(name) > -1 && !(8 & scope.flags && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1);
    }
    checkLocalExport(id) {
      -1 === this.scopeStack[0].lexical.indexOf(id.name) && -1 === this.scopeStack[0].var.indexOf(id.name) && -1 === this.scopeStack[0].functions.indexOf(id.name) && this.undefinedExports.set(id.name, id.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScope() {
      for (let i = this.scopeStack.length - 1; ;i--) {
        const scope = this.scopeStack[i];
        if (131 & scope.flags) return scope;
      }
    }
    currentThisScope() {
      for (let i = this.scopeStack.length - 1; ;i--) {
        const scope = this.scopeStack[i];
        if ((131 & scope.flags || 64 & scope.flags) && !(4 & scope.flags)) return scope;
      }
    }
  }
  class TypeScriptScope extends Scope {
    constructor(...args) {
      super(...args), this.types = [], this.enums = [], this.constEnums = [], this.classes = [], 
      this.exportOnlyBindings = [];
    }
  }
  class TypeScriptScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new TypeScriptScope(flags);
    }
    declareName(name, bindingType, pos) {
      const scope = this.currentScope();
      if (1024 & bindingType) return this.maybeExportDefined(scope, name), void scope.exportOnlyBindings.push(name);
      super.declareName(...arguments), 2 & bindingType && (1 & bindingType || (this.checkRedeclarationInScope(scope, name, bindingType, pos), 
      this.maybeExportDefined(scope, name)), scope.types.push(name)), 256 & bindingType && scope.enums.push(name), 
      512 & bindingType && scope.constEnums.push(name), 128 & bindingType && scope.classes.push(name);
    }
    isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (256 & bindingType) {
          return !!(512 & bindingType) !== scope.constEnums.indexOf(name) > -1;
        }
        return !0;
      }
      return 128 & bindingType && scope.classes.indexOf(name) > -1 ? scope.lexical.indexOf(name) > -1 && !!(1 & bindingType) : !!(2 & bindingType && scope.types.indexOf(name) > -1) || super.isRedeclaredInScope(...arguments);
    }
    checkLocalExport(id) {
      -1 === this.scopeStack[0].types.indexOf(id.name) && -1 === this.scopeStack[0].exportOnlyBindings.indexOf(id.name) && super.checkLocalExport(id);
    }
  }
  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }
    enter(flags) {
      this.stacks.push(flags);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (2 & this.currentFlags()) > 0;
    }
    get hasYield() {
      return (1 & this.currentFlags()) > 0;
    }
    get hasReturn() {
      return (4 & this.currentFlags()) > 0;
    }
  }
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
  }
  function nonNull(x) {
    if (null == x) throw new Error(`Unexpected ${x} value.`);
    return x;
  }
  function assert(x) {
    if (!x) throw new Error("Assert fail");
  }
  const TSErrors = Object.freeze({
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
    DeclareClassFieldHasInitializer: "'declare' class fields cannot have an initializer",
    DuplicateModifier: "Duplicate modifier: '%0'",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
    TemplateTypeHasSubstitution: "Template literal types cannot have any substitution",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
  });
  types.placeholder = new TokenType("%%", {
    startsExpr: !0
  });
  function hasPlugin(plugins, name) {
    return plugins.some(plugin => Array.isArray(plugin) ? plugin[0] === name : plugin === name);
  }
  function getPluginOption(plugins, name, option) {
    const plugin = plugins.find(plugin => Array.isArray(plugin) ? plugin[0] === name : plugin === name);
    return plugin && Array.isArray(plugin) ? plugin[1][option] : null;
  }
  const PIPELINE_PROPOSALS = [ "minimal", "smart", "fsharp" ], RECORD_AND_TUPLE_SYNTAX_TYPES = [ "hash", "bar" ];
  const mixinPlugins = {
    estree: superClass => class extends superClass {
      estreeParseRegExpLiteral({pattern: pattern, flags: flags}) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {}
        const node = this.estreeParseLiteral(regex);
        return node.regex = {
          pattern: pattern,
          flags: flags
        }, node;
      }
      estreeParseBigIntLiteral(value) {
        const bigInt = "undefined" != typeof BigInt ? BigInt(value) : null, node = this.estreeParseLiteral(bigInt);
        return node.bigint = String(node.value || value), node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      directiveToStmt(directive) {
        const directiveLiteral = directive.value, stmt = this.startNodeAt(directive.start, directive.loc.start), expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        return expression.value = directiveLiteral.value, expression.raw = directiveLiteral.extra.raw, 
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end), 
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1), this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync), node.expression = !1;
      }
      checkDeclaration(node) {
        isSimpleProperty(node) ? this.checkDeclaration(node.value) : super.checkDeclaration(node);
      }
      checkGetterSetterParams(method) {
        const prop = method, paramCount = "get" === prop.kind ? 0 : 1, start = prop.start;
        prop.value.params.length !== paramCount ? "get" === method.kind ? this.raise(start, ErrorMessages.BadGetterArity) : this.raise(start, ErrorMessages.BadSetterArity) : "set" === prop.kind && "RestElement" === prop.value.params[0].type && this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
      checkLVal(expr, bindingType = 64, checkClashes, contextDescription, disallowLetBinding) {
        switch (expr.type) {
         case "ObjectPattern":
          expr.properties.forEach(prop => {
            this.checkLVal("Property" === prop.type ? prop.value : prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
          });
          break;

         default:
          super.checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding);
        }
      }
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        prop.method || super.checkProto(prop, isRecord, protoRef, refExpressionErrors);
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return "ExpressionStatement" === stmt.type && "Literal" === stmt.expression.type && "string" == typeof stmt.expression.value && !(null == (_stmt$expression$extr = stmt.expression.extra) ? void 0 : _stmt$expression$extr.parenthesized);
      }
      stmtToDirective(stmt) {
        const directive = super.stmtToDirective(stmt), value = stmt.expression.value;
        return directive.value.value = value, directive;
      }
      parseBlockBody(node, allowDirectives, topLevel, end) {
        super.parseBlockBody(node, allowDirectives, topLevel, end);
        const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body), delete node.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0), 
        method.typeParameters && (method.value.typeParameters = method.typeParameters, delete method.typeParameters), 
        classBody.body.push(method);
      }
      parseExprAtom(refExpressionErrors) {
        switch (this.state.type) {
         case types.num:
         case types.string:
          return this.estreeParseLiteral(this.state.value);

         case types.regexp:
          return this.estreeParseRegExpLiteral(this.state.value);

         case types.bigint:
          return this.estreeParseBigIntLiteral(this.state.value);

         case types._null:
          return this.estreeParseLiteral(null);

         case types._true:
          return this.estreeParseLiteral(!0);

         case types._false:
          return this.estreeParseLiteral(!1);

         default:
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      parseLiteral(value, type, startPos, startLoc) {
        const node = super.parseLiteral(value, type, startPos, startLoc);
        return node.raw = node.extra.raw, delete node.extra, node;
      }
      parseFunctionBody(node, allowExpression, isMethod = !1) {
        super.parseFunctionBody(node, allowExpression, isMethod), node.expression = "BlockStatement" !== node.body.type;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = !1) {
        let funcNode = this.startNode();
        return funcNode.kind = node.kind, funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope), 
        funcNode.type = "FunctionExpression", delete funcNode.kind, node.value = funcNode, 
        type = "ClassMethod" === type ? "MethodDefinition" : type, this.finishNode(node, type);
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc);
        return node && (node.type = "Property", "method" === node.kind && (node.kind = "init"), 
        node.shorthand = !1), node;
      }
      parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
        return node && (node.kind = "init", node.type = "Property"), node;
      }
      toAssignable(node) {
        return isSimpleProperty(node) ? (this.toAssignable(node.value), node) : super.toAssignable(node);
      }
      toAssignableObjectExpressionProp(prop, isLast) {
        if ("get" === prop.kind || "set" === prop.kind) throw this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
        if (prop.method) throw this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
        super.toAssignableObjectExpressionProp(prop, isLast);
      }
      finishCallExpression(node, optional) {
        return super.finishCallExpression(node, optional), "Import" === node.callee.type ? (node.type = "ImportExpression", 
        node.source = node.arguments[0], delete node.arguments, delete node.callee) : "CallExpression" === node.type && (node.optional = !1), 
        node;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        exprList && super.toReferencedListDeep(exprList, isParenthesizedExpr);
      }
      parseExport(node) {
        switch (super.parseExport(node), node.type) {
         case "ExportAllDeclaration":
          node.exported = null;
          break;

         case "ExportNamedDeclaration":
          1 === node.specifiers.length && "ExportNamespaceSpecifier" === node.specifiers[0].type && (node.type = "ExportAllDeclaration", 
          node.exported = node.specifiers[0].exported, delete node.specifiers);
        }
        return node;
      }
      parseSubscript(...args) {
        const node = super.parseSubscript(...args);
        return "MemberExpression" === node.type && (node.optional = !1), node;
      }
    },
    jsx: superClass => class extends superClass {
      jsxReadToken() {
        let out = "", chunkStart = this.state.pos;
        for (;;) {
          if (this.state.pos >= this.length) throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
           case 60:
           case 123:
            return this.state.pos === this.state.start ? 60 === ch && this.state.exprAllowed ? (++this.state.pos, 
            this.finishToken(types.jsxTagStart)) : super.getTokenFromCode(ch) : (out += this.input.slice(chunkStart, this.state.pos), 
            this.finishToken(types.jsxText, out));

           case 38:
            out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), 
            chunkStart = this.state.pos;
            break;

           default:
            isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadNewLine(!0), 
            chunkStart = this.state.pos) : ++this.state.pos;
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        return ++this.state.pos, 13 === ch && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, 
        out = normalizeCRLF ? "\n" : "\r\n") : out = String.fromCharCode(ch), ++this.state.curLine, 
        this.state.lineStart = this.state.pos, out;
      }
      jsxReadString(quote) {
        let out = "", chunkStart = ++this.state.pos;
        for (;;) {
          if (this.state.pos >= this.length) throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          38 === ch ? (out += this.input.slice(chunkStart, this.state.pos), out += this.jsxReadEntity(), 
          chunkStart = this.state.pos) : isNewLine(ch) ? (out += this.input.slice(chunkStart, this.state.pos), 
          out += this.jsxReadNewLine(!1), chunkStart = this.state.pos) : ++this.state.pos;
        }
        return out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(types.string, out);
      }
      jsxReadEntity() {
        let entity, str = "", count = 0, ch = this.input[this.state.pos];
        const startPos = ++this.state.pos;
        for (;this.state.pos < this.length && count++ < 10; ) {
          if (ch = this.input[this.state.pos++], ";" === ch) {
            "#" === str[0] ? "x" === str[1] ? (str = str.substr(2), HEX_NUMBER.test(str) && (entity = String.fromCodePoint(parseInt(str, 16)))) : (str = str.substr(1), 
            DECIMAL_NUMBER.test(str) && (entity = String.fromCodePoint(parseInt(str, 10)))) : entity = entities[str];
            break;
          }
          str += ch;
        }
        return entity || (this.state.pos = startPos, "&");
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || 45 === ch);
        return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        return this.match(types.jsxName) ? node.name = this.state.value : this.state.type.keyword ? node.name = this.state.type.keyword : this.unexpected(), 
        this.next(), this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startPos = this.state.start, startLoc = this.state.startLoc, name = this.jsxParseIdentifier();
        if (!this.eat(types.colon)) return name;
        const node = this.startNodeAt(startPos, startLoc);
        return node.namespace = name, node.name = this.jsxParseIdentifier(), this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startPos = this.state.start, startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if ("JSXNamespacedName" === node.type) return node;
        for (;this.eat(types.dot); ) {
          const newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node, newNode.property = this.jsxParseIdentifier(), node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
         case types.braceL:
          return node = this.startNode(), this.next(), node = this.jsxParseExpressionContainer(node), 
          "JSXEmptyExpression" === node.expression.type && this.raise(node.start, JsxErrors.AttributeIsEmpty), 
          node;

         case types.jsxTagStart:
         case types.string:
          return this.parseExprAtom();

         default:
          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        return this.next(), node.expression = this.parseExpression(), this.expect(types.braceR), 
        this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node) {
        return this.match(types.braceR) ? node.expression = this.jsxParseEmptyExpression() : node.expression = this.parseExpression(), 
        this.expect(types.braceR), this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        return this.eat(types.braceL) ? (this.expect(types.ellipsis), node.argument = this.parseMaybeAssign(), 
        this.expect(types.braceR), this.finishNode(node, "JSXSpreadAttribute")) : (node.name = this.jsxParseNamespacedName(), 
        node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(node, "JSXAttribute"));
      }
      jsxParseOpeningElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        return this.match(types.jsxTagEnd) ? (this.expect(types.jsxTagEnd), this.finishNode(node, "JSXOpeningFragment")) : (node.name = this.jsxParseElementName(), 
        this.jsxParseOpeningElementAfterName(node));
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        for (;!this.match(types.slash) && !this.match(types.jsxTagEnd); ) attributes.push(this.jsxParseAttribute());
        return node.attributes = attributes, node.selfClosing = this.eat(types.slash), this.expect(types.jsxTagEnd), 
        this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        return this.match(types.jsxTagEnd) ? (this.expect(types.jsxTagEnd), this.finishNode(node, "JSXClosingFragment")) : (node.name = this.jsxParseElementName(), 
        this.expect(types.jsxTagEnd), this.finishNode(node, "JSXClosingElement"));
      }
      jsxParseElementAt(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc), children = [], openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (;;) switch (this.state.type) {
           case types.jsxTagStart:
            if (startPos = this.state.start, startLoc = this.state.startLoc, this.next(), this.eat(types.slash)) {
              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
              break contents;
            }
            children.push(this.jsxParseElementAt(startPos, startLoc));
            break;

           case types.jsxText:
            children.push(this.parseExprAtom());
            break;

           case types.braceL:
            {
              const node = this.startNode();
              this.next(), this.match(types.ellipsis) ? children.push(this.jsxParseSpreadChild(node)) : children.push(this.jsxParseExpressionContainer(node));
              break;
            }

           default:
            throw this.unexpected();
          }
          isFragment(openingElement) && !isFragment(closingElement) ? this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment) : !isFragment(openingElement) && isFragment(closingElement) ? this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name)) : isFragment(openingElement) || isFragment(closingElement) || getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name) && this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
        }
        if (isFragment(openingElement) ? (node.openingFragment = openingElement, node.closingFragment = closingElement) : (node.openingElement = openingElement, 
        node.closingElement = closingElement), node.children = children, this.isRelational("<")) throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startPos = this.state.start, startLoc = this.state.startLoc;
        return this.next(), this.jsxParseElementAt(startPos, startLoc);
      }
      parseExprAtom(refExpressionErrors) {
        return this.match(types.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(types.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && 33 !== this.input.charCodeAt(this.state.pos) ? (this.finishToken(types.jsxTagStart), 
        this.jsxParseElement()) : super.parseExprAtom(refExpressionErrors);
      }
      getTokenFromCode(code) {
        if (this.state.inPropertyName) return super.getTokenFromCode(code);
        const context = this.curContext();
        if (context === types$1.j_expr) return this.jsxReadToken();
        if (context === types$1.j_oTag || context === types$1.j_cTag) {
          if (isIdentifierStart(code)) return this.jsxReadWord();
          if (62 === code) return ++this.state.pos, this.finishToken(types.jsxTagEnd);
          if ((34 === code || 39 === code) && context === types$1.j_oTag) return this.jsxReadString(code);
        }
        return 60 === code && this.state.exprAllowed && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, 
        this.finishToken(types.jsxTagStart)) : super.getTokenFromCode(code);
      }
      updateContext(prevType) {
        if (this.match(types.braceL)) {
          const curContext = this.curContext();
          curContext === types$1.j_oTag ? this.state.context.push(types$1.braceExpression) : curContext === types$1.j_expr ? this.state.context.push(types$1.templateQuasi) : super.updateContext(prevType), 
          this.state.exprAllowed = !0;
        } else {
          if (!this.match(types.slash) || prevType !== types.jsxTagStart) return super.updateContext(prevType);
          this.state.context.length -= 2, this.state.context.push(types$1.j_cTag), this.state.exprAllowed = !1;
        }
      }
    },
    flow: superClass => class extends superClass {
      constructor(options, input) {
        super(options, input), this.flowPragma = void 0;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        return type !== types.string && type !== types.semi && type !== types.interpreterDirective && void 0 === this.flowPragma && (this.flowPragma = null), 
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (void 0 === this.flowPragma) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (matches) if ("flow" === matches[1]) this.flowPragma = "flow"; else {
            if ("noflow" !== matches[1]) throw new Error("Unexpected flow pragma");
            this.flowPragma = "noflow";
          } else ;
        }
        return super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = !0, this.expect(tok || types.colon);
        const type = this.flowParseType();
        return this.state.inType = oldInType, type;
      }
      flowParsePredicate() {
        const node = this.startNode(), moduloLoc = this.state.startLoc, moduloPos = this.state.start;
        this.expect(types.modulo);
        const checksLoc = this.state.startLoc;
        return this.expectContextual("checks"), moduloLoc.line === checksLoc.line && moduloLoc.column === checksLoc.column - 1 || this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks), 
        this.eat(types.parenL) ? (node.value = this.parseExpression(), this.expect(types.parenR), 
        this.finishNode(node, "DeclaredPredicate")) : this.finishNode(node, "InferredPredicate");
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = !0, this.expect(types.colon);
        let type = null, predicate = null;
        return this.match(types.modulo) ? (this.state.inType = oldInType, predicate = this.flowParsePredicate()) : (type = this.flowParseType(), 
        this.state.inType = oldInType, this.match(types.modulo) && (predicate = this.flowParsePredicate())), 
        [ type, predicate ];
      }
      flowParseDeclareClass(node) {
        return this.next(), this.flowParseInterfaceish(node, !0), this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier(), typeNode = this.startNode(), typeContainer = this.startNode();
        this.isRelational("<") ? typeNode.typeParameters = this.flowParseTypeParameterDeclaration() : typeNode.typeParameters = null, 
        this.expect(types.parenL);
        const tmp = this.flowParseFunctionTypeParams();
        return typeNode.params = tmp.params, typeNode.rest = tmp.rest, this.expect(types.parenR), 
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), 
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation"), 
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation"), this.resetEndLocation(id), 
        this.semicolon(), this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(types._class)) return this.flowParseDeclareClass(node);
        if (this.match(types._function)) return this.flowParseDeclareFunction(node);
        if (this.match(types._var)) return this.flowParseDeclareVariable(node);
        if (this.eatContextual("module")) return this.match(types.dot) ? this.flowParseDeclareModuleExports(node) : (insideModule && this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule), 
        this.flowParseDeclareModule(node));
        if (this.isContextual("type")) return this.flowParseDeclareTypeAlias(node);
        if (this.isContextual("opaque")) return this.flowParseDeclareOpaqueType(node);
        if (this.isContextual("interface")) return this.flowParseDeclareInterface(node);
        if (this.match(types._export)) return this.flowParseDeclareExportDeclaration(node, insideModule);
        throw this.unexpected();
      }
      flowParseDeclareVariable(node) {
        return this.next(), node.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(node.id.name, 5, node.id.start), 
        this.semicolon(), this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0), this.match(types.string) ? node.id = this.parseExprAtom() : node.id = this.parseIdentifier();
        const bodyNode = node.body = this.startNode(), body = bodyNode.body = [];
        for (this.expect(types.braceL); !this.match(types.braceR); ) {
          let bodyNode = this.startNode();
          this.match(types._import) ? (this.next(), this.isContextual("type") || this.match(types._typeof) || this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule), 
          this.parseImport(bodyNode)) : (this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule), 
          bodyNode = this.flowParseDeclare(bodyNode, !0)), body.push(bodyNode);
        }
        this.scope.exit(), this.expect(types.braceR), this.finishNode(bodyNode, "BlockStatement");
        let kind = null, hasModuleExport = !1;
        return body.forEach(bodyElement => {
          !function(bodyElement) {
            return "DeclareExportAllDeclaration" === bodyElement.type || "DeclareExportDeclaration" === bodyElement.type && (!bodyElement.declaration || "TypeAlias" !== bodyElement.declaration.type && "InterfaceDeclaration" !== bodyElement.declaration.type);
          }(bodyElement) ? "DeclareModuleExports" === bodyElement.type && (hasModuleExport && this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports), 
          "ES" === kind && this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind), 
          kind = "CommonJS", hasModuleExport = !0) : ("CommonJS" === kind && this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind), 
          kind = "ES");
        }), node.kind = kind || "CommonJS", this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        if (this.expect(types._export), this.eat(types._default)) return this.match(types._function) || this.match(types._class) ? node.declaration = this.flowParseDeclare(this.startNode()) : (node.declaration = this.flowParseType(), 
        this.semicolon()), node.default = !0, this.finishNode(node, "DeclareExportDeclaration");
        if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
          const label = this.state.value, suggestion = exportSuggestions[label];
          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
        }
        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) return node.declaration = this.flowParseDeclare(this.startNode()), 
        node.default = !1, this.finishNode(node, "DeclareExportDeclaration");
        if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) return "ExportNamedDeclaration" === (node = this.parseExport(node)).type && (node.type = "ExportDeclaration", 
        node.default = !1, delete node.exportKind), node.type = "Declare" + node.type, node;
        throw this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        return this.next(), this.expectContextual("exports"), node.typeAnnotation = this.flowParseTypeAnnotation(), 
        this.semicolon(), this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        return this.next(), this.flowParseTypeAlias(node), node.type = "DeclareTypeAlias", 
        node;
      }
      flowParseDeclareOpaqueType(node) {
        return this.next(), this.flowParseOpaqueType(node, !0), node.type = "DeclareOpaqueType", 
        node;
      }
      flowParseDeclareInterface(node) {
        return this.next(), this.flowParseInterfaceish(node), this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass = !1) {
        if (node.id = this.flowParseRestrictedIdentifier(!isClass, !0), this.scope.declareName(node.id.name, isClass ? 17 : 9, node.id.start), 
        this.isRelational("<") ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, 
        node.extends = [], node.implements = [], node.mixins = [], this.eat(types._extends)) do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(types.comma));
        if (this.isContextual("mixins")) {
          this.next();
          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }
        if (this.isContextual("implements")) {
          this.next();
          do {
            node.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: !1,
          allowSpread: !1,
          allowProto: isClass,
          allowInexact: !1
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        return node.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, 
        this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        return this.flowParseInterfaceish(node), this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        "_" === word && this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
      }
      checkReservedType(word, startLoc, declaration) {
        reservedTypes.has(word) && this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        return this.checkReservedType(this.state.value, this.state.start, declaration), 
        this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        return node.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(node.id.name, 9, node.id.start), 
        this.isRelational("<") ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, 
        node.right = this.flowParseTypeInitialiser(types.eq), this.semicolon(), this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        return this.expectContextual("type"), node.id = this.flowParseRestrictedIdentifier(!0, !0), 
        this.scope.declareName(node.id.name, 9, node.id.start), this.isRelational("<") ? node.typeParameters = this.flowParseTypeParameterDeclaration() : node.typeParameters = null, 
        node.supertype = null, this.match(types.colon) && (node.supertype = this.flowParseTypeInitialiser(types.colon)), 
        node.impltype = null, declare || (node.impltype = this.flowParseTypeInitialiser(types.eq)), 
        this.semicolon(), this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = !1) {
        const nodeStart = this.state.start, node = this.startNode(), variance = this.flowParseVariance(), ident = this.flowParseTypeAnnotatableIdentifier();
        return node.name = ident.name, node.variance = variance, node.bound = ident.typeAnnotation, 
        this.match(types.eq) ? (this.eat(types.eq), node.default = this.flowParseType()) : requireDefault && this.raise(nodeStart, FlowErrors.MissingTypeParamDefault), 
        this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType, node = this.startNode();
        node.params = [], this.state.inType = !0, this.isRelational("<") || this.match(types.jsxTagStart) ? this.next() : this.unexpected();
        let defaultRequired = !1;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter), typeParameter.default && (defaultRequired = !0), 
          this.isRelational(">") || this.expect(types.comma);
        } while (!this.isRelational(">"));
        return this.expectRelational(">"), this.state.inType = oldInType, this.finishNode(node, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode(), oldInType = this.state.inType;
        node.params = [], this.state.inType = !0, this.expectRelational("<");
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.isRelational(">"); ) node.params.push(this.flowParseType()), 
        this.isRelational(">") || this.expect(types.comma);
        return this.state.noAnonFunctionType = oldNoAnonFunctionType, this.expectRelational(">"), 
        this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode(), oldInType = this.state.inType;
        for (node.params = [], this.state.inType = !0, this.expectRelational("<"); !this.isRelational(">"); ) node.params.push(this.flowParseTypeOrImplicitInstantiation()), 
        this.isRelational(">") || this.expect(types.comma);
        return this.expectRelational(">"), this.state.inType = oldInType, this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        if (this.expectContextual("interface"), node.extends = [], this.eat(types._extends)) do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(types.comma));
        return node.body = this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !1,
          allowProto: !1,
          allowInexact: !1
        }), this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(!0);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        return node.static = isStatic, this.lookahead().type === types.colon ? (node.id = this.flowParseObjectPropertyKey(), 
        node.key = this.flowParseTypeInitialiser()) : (node.id = null, node.key = this.flowParseType()), 
        this.expect(types.bracketR), node.value = this.flowParseTypeInitialiser(), node.variance = variance, 
        this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        return node.static = isStatic, node.id = this.flowParseObjectPropertyKey(), this.expect(types.bracketR), 
        this.expect(types.bracketR), this.isRelational("<") || this.match(types.parenL) ? (node.method = !0, 
        node.optional = !1, node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start))) : (node.method = !1, 
        this.eat(types.question) && (node.optional = !0), node.value = this.flowParseTypeInitialiser()), 
        this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        for (node.params = [], node.rest = null, node.typeParameters = null, this.isRelational("<") && (node.typeParameters = this.flowParseTypeParameterDeclaration()), 
        this.expect(types.parenL); !this.match(types.parenR) && !this.match(types.ellipsis); ) node.params.push(this.flowParseFunctionTypeParam()), 
        this.match(types.parenR) || this.expect(types.comma);
        return this.eat(types.ellipsis) && (node.rest = this.flowParseFunctionTypeParam()), 
        this.expect(types.parenR), node.returnType = this.flowParseTypeInitialiser(), this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        return node.static = isStatic, node.value = this.flowParseObjectTypeMethodish(valueNode), 
        this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({allowStatic: allowStatic, allowExact: allowExact, allowSpread: allowSpread, allowProto: allowProto, allowInexact: allowInexact}) {
        const oldInType = this.state.inType;
        this.state.inType = !0;
        const nodeStart = this.startNode();
        let endDelim, exact;
        nodeStart.callProperties = [], nodeStart.properties = [], nodeStart.indexers = [], 
        nodeStart.internalSlots = [];
        let inexact = !1;
        for (allowExact && this.match(types.braceBarL) ? (this.expect(types.braceBarL), 
        endDelim = types.braceBarR, exact = !0) : (this.expect(types.braceL), endDelim = types.braceR, 
        exact = !1), nodeStart.exact = exact; !this.match(endDelim); ) {
          let isStatic = !1, protoStart = null, inexactStart = null;
          const node = this.startNode();
          if (allowProto && this.isContextual("proto")) {
            const lookahead = this.lookahead();
            lookahead.type !== types.colon && lookahead.type !== types.question && (this.next(), 
            protoStart = this.state.start, allowStatic = !1);
          }
          if (allowStatic && this.isContextual("static")) {
            const lookahead = this.lookahead();
            lookahead.type !== types.colon && lookahead.type !== types.question && (this.next(), 
            isStatic = !0);
          }
          const variance = this.flowParseVariance();
          if (this.eat(types.bracketL)) null != protoStart && this.unexpected(protoStart), 
          this.eat(types.bracketL) ? (variance && this.unexpected(variance.start), nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic))) : nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance)); else if (this.match(types.parenL) || this.isRelational("<")) null != protoStart && this.unexpected(protoStart), 
          variance && this.unexpected(variance.start), nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic)); else {
            let kind = "init";
            if (this.isContextual("get") || this.isContextual("set")) {
              const lookahead = this.lookahead();
              lookahead.type !== types.name && lookahead.type !== types.string && lookahead.type !== types.num || (kind = this.state.value, 
              this.next());
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, null != allowInexact ? allowInexact : !exact);
            null === propOrInexact ? (inexact = !0, inexactStart = this.state.lastTokStart) : nodeStart.properties.push(propOrInexact);
          }
          this.flowObjectTypeSemicolon(), !inexactStart || this.match(types.braceR) || this.match(types.braceBarR) || this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
        }
        this.expect(endDelim), allowSpread && (nodeStart.inexact = inexact);
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        return this.state.inType = oldInType, out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
        if (this.eat(types.ellipsis)) {
          return this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR) ? (allowSpread ? allowInexact || this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact) : this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject), 
          variance && this.raise(variance.start, FlowErrors.InexactVariance), null) : (allowSpread || this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType), 
          null != protoStart && this.unexpected(protoStart), variance && this.raise(variance.start, FlowErrors.SpreadVariance), 
          node.argument = this.flowParseType(), this.finishNode(node, "ObjectTypeSpreadProperty"));
        }
        {
          node.key = this.flowParseObjectPropertyKey(), node.static = isStatic, node.proto = null != protoStart, 
          node.kind = kind;
          let optional = !1;
          return this.isRelational("<") || this.match(types.parenL) ? (node.method = !0, null != protoStart && this.unexpected(protoStart), 
          variance && this.unexpected(variance.start), node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start)), 
          "get" !== kind && "set" !== kind || this.flowCheckGetterSetterParams(node)) : ("init" !== kind && this.unexpected(), 
          node.method = !1, this.eat(types.question) && (optional = !0), node.value = this.flowParseTypeInitialiser(), 
          node.variance = variance), node.optional = optional, this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = "get" === property.kind ? 0 : 1, start = property.start;
        property.value.params.length + (property.value.rest ? 1 : 0) !== paramCount && ("get" === property.kind ? this.raise(start, ErrorMessages.BadGetterArity) : this.raise(start, ErrorMessages.BadSetterArity)), 
        "set" === property.kind && property.value.rest && this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
      flowObjectTypeSemicolon() {
        this.eat(types.semi) || this.eat(types.comma) || this.match(types.braceR) || this.match(types.braceBarR) || this.unexpected();
      }
      flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start, startLoc = startLoc || this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(!0);
        for (;this.eat(types.dot); ) {
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node, node2.id = this.flowParseRestrictedIdentifier(!0), node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startPos, startLoc, id) {
        const node = this.startNodeAt(startPos, startLoc);
        return node.typeParameters = null, node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id), 
        this.isRelational("<") && (node.typeParameters = this.flowParseTypeParameterInstantiation()), 
        this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        return this.expect(types._typeof), node.argument = this.flowParsePrimaryType(), 
        this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        for (node.types = [], this.expect(types.bracketL); this.state.pos < this.length && !this.match(types.bracketR) && (node.types.push(this.flowParseType()), 
        !this.match(types.bracketR)); ) this.expect(types.comma);
        return this.expect(types.bracketR), this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam() {
        let name = null, optional = !1, typeAnnotation = null;
        const node = this.startNode(), lh = this.lookahead();
        return lh.type === types.colon || lh.type === types.question ? (name = this.parseIdentifier(), 
        this.eat(types.question) && (optional = !0), typeAnnotation = this.flowParseTypeInitialiser()) : typeAnnotation = this.flowParseType(), 
        node.name = name, node.optional = optional, node.typeAnnotation = typeAnnotation, 
        this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.start, type.loc.start);
        return node.name = null, node.optional = !1, node.typeAnnotation = type, this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        for (;!this.match(types.parenR) && !this.match(types.ellipsis); ) params.push(this.flowParseFunctionTypeParam()), 
        this.match(types.parenR) || this.expect(types.comma);
        return this.eat(types.ellipsis) && (rest = this.flowParseFunctionTypeParam()), {
          params: params,
          rest: rest
        };
      }
      flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
         case "any":
          return this.finishNode(node, "AnyTypeAnnotation");

         case "bool":
         case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");

         case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");

         case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");

         case "number":
          return this.finishNode(node, "NumberTypeAnnotation");

         case "string":
          return this.finishNode(node, "StringTypeAnnotation");

         case "symbol":
          return this.finishNode(node, "SymbolTypeAnnotation");

         default:
          return this.checkNotUnderscore(id.name), this.flowParseGenericType(startPos, startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startPos = this.state.start, startLoc = this.state.startLoc, node = this.startNode();
        let tmp, type, isGroupedType = !1;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
         case types.name:
          return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

         case types.braceL:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });

         case types.braceBarL:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });

         case types.bracketL:
          return this.state.noAnonFunctionType = !1, type = this.flowParseTupleType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, 
          type;

         case types.relational:
          if ("<" === this.state.value) return node.typeParameters = this.flowParseTypeParameterDeclaration(), 
          this.expect(types.parenL), tmp = this.flowParseFunctionTypeParams(), node.params = tmp.params, 
          node.rest = tmp.rest, this.expect(types.parenR), this.expect(types.arrow), node.returnType = this.flowParseType(), 
          this.finishNode(node, "FunctionTypeAnnotation");
          break;

         case types.parenL:
          if (this.next(), !this.match(types.parenR) && !this.match(types.ellipsis)) if (this.match(types.name)) {
            const token = this.lookahead().type;
            isGroupedType = token !== types.question && token !== types.colon;
          } else isGroupedType = !0;
          if (isGroupedType) {
            if (this.state.noAnonFunctionType = !1, type = this.flowParseType(), this.state.noAnonFunctionType = oldNoAnonFunctionType, 
            this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) return this.expect(types.parenR), 
            type;
            this.eat(types.comma);
          }
          return tmp = type ? this.flowParseFunctionTypeParams([ this.reinterpretTypeAsFunctionTypeParam(type) ]) : this.flowParseFunctionTypeParams(), 
          node.params = tmp.params, node.rest = tmp.rest, this.expect(types.parenR), this.expect(types.arrow), 
          node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");

         case types.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

         case types._true:
         case types._false:
          return node.value = this.match(types._true), this.next(), this.finishNode(node, "BooleanLiteralTypeAnnotation");

         case types.plusMin:
          if ("-" === this.state.value) {
            if (this.next(), this.match(types.num)) return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
            if (this.match(types.bigint)) return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
          }
          throw this.unexpected();

         case types.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

         case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

         case types._void:
          return this.next(), this.finishNode(node, "VoidTypeAnnotation");

         case types._null:
          return this.next(), this.finishNode(node, "NullLiteralTypeAnnotation");

         case types._this:
          return this.next(), this.finishNode(node, "ThisTypeAnnotation");

         case types.star:
          return this.next(), this.finishNode(node, "ExistsTypeAnnotation");

         default:
          if ("typeof" === this.state.type.keyword) return this.flowParseTypeofType();
          if (this.state.type.keyword) {
            const label = this.state.type.label;
            return this.next(), super.createIdentifier(node, label);
          }
        }
        throw this.unexpected();
      }
      flowParsePostfixType() {
        const startPos = this.state.start, startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        for (;this.match(types.bracketL) && !this.canInsertSemicolon(); ) {
          const node = this.startNodeAt(startPos, startLoc);
          node.elementType = type, this.expect(types.bracketL), this.expect(types.bracketR), 
          type = this.finishNode(node, "ArrayTypeAnnotation");
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        return this.eat(types.question) ? (node.typeAnnotation = this.flowParsePrefixType(), 
        this.finishNode(node, "NullableTypeAnnotation")) : this.flowParsePostfixType();
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
          const node = this.startNodeAt(param.start, param.loc.start);
          return node.params = [ this.reinterpretTypeAsFunctionTypeParam(param) ], node.rest = null, 
          node.returnType = this.flowParseType(), node.typeParameters = null, this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(types.bitwiseAND);
        const type = this.flowParseAnonFunctionWithoutParens();
        for (node.types = [ type ]; this.eat(types.bitwiseAND); ) node.types.push(this.flowParseAnonFunctionWithoutParens());
        return 1 === node.types.length ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(types.bitwiseOR);
        const type = this.flowParseIntersectionType();
        for (node.types = [ type ]; this.eat(types.bitwiseOR); ) node.types.push(this.flowParseIntersectionType());
        return 1 === node.types.length ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = !0;
        const type = this.flowParseUnionType();
        return this.state.inType = oldInType, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, 
        type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types.name && "_" === this.state.value) {
          const startPos = this.state.start, startLoc = this.state.startLoc, node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        }
        return this.flowParseType();
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        return node.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        return this.match(types.colon) && (ident.typeAnnotation = this.flowParseTypeAnnotation(), 
        this.resetEndLocation(ident)), ident;
      }
      typeCastToParameter(node) {
        return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end), 
        node.expression;
      }
      flowParseVariance() {
        let variance = null;
        return this.match(types.plusMin) && (variance = this.startNode(), "+" === this.state.value ? variance.kind = "plus" : variance.kind = "minus", 
        this.next(), this.finishNode(variance, "Variance")), variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = !1) {
        return allowExpressionBody ? this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, !0, isMethod)) : super.parseFunctionBody(node, !1, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = !1) {
        if (this.match(types.colon)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), 
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatement(context, topLevel) {
        if (this.state.strict && this.match(types.name) && "interface" === this.state.value) {
          const node = this.startNode();
          return this.next(), this.flowParseInterface(node);
        }
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          const node = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(node);
        }
        {
          const stmt = super.parseStatement(context, topLevel);
          return void 0 !== this.flowPragma || this.isValidDirective(stmt) || (this.flowPragma = null), 
          stmt;
        }
      }
      parseExpressionStatement(node, expr) {
        if ("Identifier" === expr.type) if ("declare" === expr.name) {
          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) return this.flowParseDeclare(node);
        } else if (this.match(types.name)) {
          if ("interface" === expr.name) return this.flowParseInterface(node);
          if ("type" === expr.name) return this.flowParseTypeAlias(node);
          if ("opaque" === expr.name) return this.flowParseOpaqueType(node, !1);
        }
        return super.parseExpressionStatement(node, expr);
      }
      shouldParseExportDeclaration() {
        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        return (!this.match(types.name) || !("type" === this.state.value || "interface" === this.state.value || "opaque" === this.state.value || this.shouldParseEnums() && "enum" === this.state.value)) && super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          const node = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        if (!this.match(types.question)) return expr;
        if (refNeedsArrowPos) {
          const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));
          return result.node ? (result.error && (this.state = result.failState), result.node) : (refNeedsArrowPos.start = result.error.pos || this.state.start, 
          expr);
        }
        this.expect(types.question);
        const state = this.state.clone(), originalNoArrowAt = this.state.noArrowAt, node = this.startNodeAt(startPos, startLoc);
        let {consequent: consequent, failed: failed} = this.tryParseConditionalConsequent(), [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [ ...originalNoArrowAt ];
          if (invalid.length > 0) {
            this.state = state, this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) noArrowAt.push(invalid[i].start);
            ({consequent: consequent, failed: failed} = this.tryParseConditionalConsequent()), 
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          failed && valid.length > 1 && this.raise(state.start, FlowErrors.AmbiguousConditionalArrow), 
          failed && 1 === valid.length && (this.state = state, this.state.noArrowAt = noArrowAt.concat(valid[0].start), 
          ({consequent: consequent, failed: failed} = this.tryParseConditionalConsequent()));
        }
        return this.getArrowLikeExpressions(consequent, !0), this.state.noArrowAt = originalNoArrowAt, 
        this.expect(types.colon), node.test = expr, node.consequent = consequent, node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(noIn, void 0, void 0, void 0)), 
        this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssign(), failed = !this.match(types.colon);
        return this.state.noArrowParamsConversionAt.pop(), {
          consequent: consequent,
          failed: failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [ node ], arrows = [];
        for (;0 !== stack.length; ) {
          const node = stack.pop();
          "ArrowFunctionExpression" === node.type ? (node.typeParameters || !node.returnType ? this.finishArrowValidation(node) : arrows.push(node), 
          stack.push(node.body)) : "ConditionalExpression" === node.type && (stack.push(node.consequent), 
          stack.push(node.alternate));
        }
        return disallowInvalid ? (arrows.forEach(node => this.finishArrowValidation(node)), 
        [ arrows, [] ]) : function(list, test) {
          const list1 = [], list2 = [];
          for (let i = 0; i < list.length; i++) (test(list[i], i, list) ? list1 : list2).push(list[i]);
          return [ list1, list2 ];
        }(arrows, node => node.params.every(param => this.isAssignable(param, !0)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, null == (_node$extra = node.extra) ? void 0 : _node$extra.trailingComma), 
        this.scope.enter(6), super.checkParams(node, !1, !0), this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse) {
        let result;
        return -1 !== this.state.noArrowParamsConversionAt.indexOf(node.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), 
        result = parse(), this.state.noArrowParamsConversionAt.pop()) : result = parse(), 
        result;
      }
      parseParenItem(node, startPos, startLoc) {
        if (node = super.parseParenItem(node, startPos, startLoc), this.eat(types.question) && (node.optional = !0, 
        this.resetEndLocation(node)), this.match(types.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.flowParseTypeAnnotation(), 
          this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return node;
      }
      assertModuleNodeAllowed(node) {
        "ImportDeclaration" === node.type && ("type" === node.importKind || "typeof" === node.importKind) || "ExportNamedDeclaration" === node.type && "type" === node.exportKind || "ExportAllDeclaration" === node.type && "type" === node.exportKind || super.assertModuleNodeAllowed(node);
      }
      parseExport(node) {
        const decl = super.parseExport(node);
        return "ExportNamedDeclaration" !== decl.type && "ExportAllDeclaration" !== decl.type || (decl.exportKind = decl.exportKind || "value"), 
        decl;
      }
      parseExportDeclaration(node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          return this.next(), this.match(types.braceL) ? (node.specifiers = this.parseExportSpecifiers(), 
          this.parseExportFrom(node), null) : this.flowParseTypeAlias(declarationNode);
        }
        if (this.isContextual("opaque")) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          return this.next(), this.flowParseOpaqueType(declarationNode, !1);
        }
        if (this.isContextual("interface")) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          return this.next(), this.flowParseInterface(declarationNode);
        }
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          return this.next(), this.flowParseEnumDeclaration(declarationNode);
        }
        return super.parseExportDeclaration(node);
      }
      eatExportStar(node) {
        return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== types.star) && (node.exportKind = "type", 
        this.next(), this.next(), !0);
      }
      maybeParseExportNamespaceSpecifier(node) {
        const pos = this.state.start, hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        return hasNamespace && "type" === node.exportKind && this.unexpected(pos), hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId), this.isRelational("<") && (node.typeParameters = this.flowParseTypeParameterDeclaration());
      }
      parseClassMember(classBody, member, state, constructorAllowsSuper) {
        const pos = this.state.start;
        if (this.isContextual("declare")) {
          if (this.parseClassMemberFromModifier(classBody, member)) return;
          member.declare = !0;
        }
        super.parseClassMember(classBody, member, state, constructorAllowsSuper), member.declare && ("ClassProperty" !== member.type && "ClassPrivateProperty" !== member.type ? this.raise(pos, FlowErrors.DeclareClassElement) : member.value && this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer));
      }
      getTokenFromCode(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        return 123 === code && 124 === next ? this.finishOp(types.braceBarL, 2) : !this.state.inType || 62 !== code && 60 !== code ? function(current, next) {
          return 64 === current && 64 === next;
        }(code, next) ? (this.state.isIterator = !0, super.readWord()) : super.getTokenFromCode(code) : this.finishOp(types.relational, 1);
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
         case "Identifier":
         case "ObjectPattern":
         case "ArrayPattern":
         case "AssignmentPattern":
          return !0;

         case "ObjectExpression":
          {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => "ObjectMethod" !== prop.type && (i === last || "SpreadElement" === prop.type) && this.isAssignable(prop));
          }

         case "ObjectProperty":
          return this.isAssignable(node.value);

         case "SpreadElement":
          return this.isAssignable(node.argument);

         case "ArrayExpression":
          return node.elements.every(element => this.isAssignable(element));

         case "AssignmentExpression":
          return "=" === node.operator;

         case "ParenthesizedExpression":
         case "TypeCastExpression":
          return this.isAssignable(node.expression);

         case "MemberExpression":
         case "OptionalMemberExpression":
          return !isBinding;

         default:
          return !1;
        }
      }
      toAssignable(node) {
        return "TypeCastExpression" === node.type ? super.toAssignable(this.typeCastToParameter(node)) : super.toAssignable(node);
      }
      toAssignableList(exprList, trailingCommaPos) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          "TypeCastExpression" === (null == expr ? void 0 : expr.type) && (exprList[i] = this.typeCastToParameter(expr));
        }
        return super.toAssignableList(exprList, trailingCommaPos);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          expr && "TypeCastExpression" === expr.type && !(null == (_expr$extra = expr.extra) ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr) && this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
        }
        return exprList;
      }
      checkLVal(expr, bindingType = 64, checkClashes, contextDescription) {
        if ("TypeCastExpression" !== expr.type) return super.checkLVal(expr, bindingType, checkClashes, contextDescription);
      }
      parseClassProperty(node) {
        return this.match(types.colon) && (node.typeAnnotation = this.flowParseTypeAnnotation()), 
        super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        return this.match(types.colon) && (node.typeAnnotation = this.flowParseTypeAnnotation()), 
        super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.isRelational("<") || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(types.colon) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(types.colon) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        method.variance && this.unexpected(method.variance.start), delete method.variance, 
        this.isRelational("<") && (method.typeParameters = this.flowParseTypeParameterDeclaration()), 
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        method.variance && this.unexpected(method.variance.start), delete method.variance, 
        this.isRelational("<") && (method.typeParameters = this.flowParseTypeParameterDeclaration()), 
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        if (super.parseClassSuper(node), node.superClass && this.isRelational("<") && (node.superTypeParameters = this.flowParseTypeParameterInstantiation()), 
        this.isContextual("implements")) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node = this.startNode();
            node.id = this.flowParseRestrictedIdentifier(!0), this.isRelational("<") ? node.typeParameters = this.flowParseTypeParameterInstantiation() : node.typeParameters = null, 
            implemented.push(this.finishNode(node, "ClassImplements"));
          } while (this.eat(types.comma));
        }
      }
      parsePropertyName(node, isPrivateNameAllowed) {
        const variance = this.flowParseVariance(), key = super.parsePropertyName(node, isPrivateNameAllowed);
        return node.variance = variance, key;
      }
      parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
        let typeParameters;
        prop.variance && this.unexpected(prop.variance.start), delete prop.variance, this.isRelational("<") && (typeParameters = this.flowParseTypeParameterDeclaration(), 
        this.match(types.parenL) || this.unexpected()), super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc), 
        typeParameters && ((prop.value || prop).typeParameters = typeParameters);
      }
      parseAssignableListItemTypes(param) {
        return this.eat(types.question) && ("Identifier" !== param.type && this.raise(param.start, FlowErrors.OptionalBindingPattern), 
        param.optional = !0), this.match(types.colon) && (param.typeAnnotation = this.flowParseTypeAnnotation()), 
        this.resetEndLocation(param), param;
      }
      parseMaybeDefault(startPos, startLoc, left) {
        const node = super.parseMaybeDefault(startPos, startLoc, left);
        return "AssignmentPattern" === node.type && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer), 
        node;
      }
      shouldParseDefaultImport(node) {
        return hasTypeImportKind(node) ? isMaybeDefaultImport(this.state) : super.shouldParseDefaultImport(node);
      }
      parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), 
        this.checkLVal(specifier.local, 9, void 0, contextDescription), node.specifiers.push(this.finishNode(specifier, type));
      }
      maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        let kind = null;
        if (this.match(types._typeof) ? kind = "typeof" : this.isContextual("type") && (kind = "type"), 
        kind) {
          const lh = this.lookahead();
          "type" === kind && lh.type === types.star && this.unexpected(lh.start), (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) && (this.next(), 
          node.importKind = kind);
        }
        return super.maybeParseDefaultImportSpecifier(node);
      }
      parseImportSpecifier(node) {
        const specifier = this.startNode(), firstIdentLoc = this.state.start, firstIdent = this.parseIdentifier(!0);
        let specifierTypeKind = null;
        "type" === firstIdent.name ? specifierTypeKind = "type" : "typeof" === firstIdent.name && (specifierTypeKind = "typeof");
        let isBinding = !1;
        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(!0);
          null === specifierTypeKind || this.match(types.name) || this.state.type.keyword ? (specifier.imported = firstIdent, 
          specifier.importKind = null, specifier.local = this.parseIdentifier()) : (specifier.imported = as_ident, 
          specifier.importKind = specifierTypeKind, specifier.local = as_ident.__clone());
        } else null !== specifierTypeKind && (this.match(types.name) || this.state.type.keyword) ? (specifier.imported = this.parseIdentifier(!0), 
        specifier.importKind = specifierTypeKind, this.eatContextual("as") ? specifier.local = this.parseIdentifier() : (isBinding = !0, 
        specifier.local = specifier.imported.__clone())) : (isBinding = !0, specifier.imported = firstIdent, 
        specifier.importKind = null, specifier.local = specifier.imported.__clone());
        const nodeIsTypeImport = hasTypeImportKind(node), specifierIsTypeImport = hasTypeImportKind(specifier);
        nodeIsTypeImport && specifierIsTypeImport && this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport), 
        (nodeIsTypeImport || specifierIsTypeImport) && this.checkReservedType(specifier.local.name, specifier.local.start, !0), 
        !isBinding || nodeIsTypeImport || specifierIsTypeImport || this.checkReservedWord(specifier.local.name, specifier.start, !0, !0), 
        this.checkLVal(specifier.local, 9, void 0, "import specifier"), node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      }
      parseFunctionParams(node, allowModifiers) {
        const kind = node.kind;
        "get" !== kind && "set" !== kind && this.isRelational("<") && (node.typeParameters = this.flowParseTypeParameterDeclaration()), 
        super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind), this.match(types.colon) && (decl.id.typeAnnotation = this.flowParseTypeAnnotation(), 
        this.resetEndLocation(decl.id));
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0, node.returnType = this.flowParseTypeAnnotation(), 
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(types.colon) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
        var _jsx;
        let jsx, state = null;
        if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
          if (state = this.state.clone(), jsx = this.tryParse(() => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos), state), 
          !jsx.error) return jsx.node;
          const {context: context} = this.state;
          context[context.length - 1] === types$1.j_oTag ? context.length -= 2 : context[context.length - 1] === types$1.j_expr && (context.length -= 1);
        }
        if ((null == (_jsx = jsx) ? void 0 : _jsx.error) || this.isRelational("<")) {
          var _arrow$node, _jsx2, _jsx3;
          let typeParameters;
          state = state || this.state.clone();
          const arrow = this.tryParse(() => {
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos));
            return arrowExpression.typeParameters = typeParameters, this.resetStartLocationFromNode(arrowExpression, typeParameters), 
            arrowExpression;
          }, state), arrowExpression = "ArrowFunctionExpression" === (null == (_arrow$node = arrow.node) ? void 0 : _arrow$node.type) ? arrow.node : null;
          if (!arrow.error && arrowExpression) return arrowExpression;
          if (null == (_jsx2 = jsx) ? void 0 : _jsx2.node) return this.state = jsx.failState, 
          jsx.node;
          if (arrowExpression) return this.state = arrow.failState, arrowExpression;
          if (null == (_jsx3 = jsx) ? void 0 : _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
        }
        return super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
      }
      parseArrow(node) {
        if (this.match(types.colon)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = !0;
            const typeNode = this.startNode();
            return [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser(), 
            this.state.noAnonFunctionType = oldNoAnonFunctionType, this.canInsertSemicolon() && this.unexpected(), 
            this.match(types.arrow) || this.unexpected(), typeNode;
          });
          if (result.thrown) return null;
          result.error && (this.state = result.failState), node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow() {
        return this.match(types.colon) || super.shouldParseArrow();
      }
      setArrowFunctionParameters(node, params) {
        -1 !== this.state.noArrowParamsConversionAt.indexOf(node.start) ? node.params = params : super.setArrowFunctionParameters(node, params);
      }
      checkParams(node, allowDuplicates, isArrowFunction) {
        if (!isArrowFunction || -1 === this.state.noArrowParamsConversionAt.indexOf(node.start)) return super.checkParams(...arguments);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && -1 === this.state.noArrowAt.indexOf(this.state.start));
      }
      parseSubscripts(base, startPos, startLoc, noCalls) {
        if ("Identifier" === base.type && "async" === base.name && -1 !== this.state.noArrowAt.indexOf(startPos)) {
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base, node.arguments = this.parseCallExpressionArguments(types.parenR, !1), 
          base = this.finishNode(node, "CallExpression");
        } else if ("Identifier" === base.type && "async" === base.name && this.isRelational("<")) {
          const state = this.state.clone(), arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) return this.state = arrow.failState, arrow.node;
          if (result.node) return this.state = result.failState, result.node;
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startPos, startLoc, noCalls);
      }
      parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        if (this.match(types.questionDot) && this.isLookaheadRelational("<")) {
          if (subscriptState.optionalChainMember = !0, noCalls) return subscriptState.stop = !0, 
          base;
          this.next();
          const node = this.startNodeAt(startPos, startLoc);
          return node.callee = base, node.typeArguments = this.flowParseTypeParameterInstantiation(), 
          this.expect(types.parenL), node.arguments = this.parseCallExpressionArguments(types.parenR, !1), 
          node.optional = !0, this.finishCallExpression(node, !0);
        }
        if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const result = this.tryParse(() => (node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), 
          this.expect(types.parenL), node.arguments = this.parseCallExpressionArguments(types.parenR, !1), 
          subscriptState.optionalChainMember && (node.optional = !1), this.finishCallExpression(node, subscriptState.optionalChainMember)));
          if (result.node) return result.error && (this.state = result.failState), result.node;
        }
        return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
      }
      parseNewArguments(node) {
        let targs = null;
        this.shouldParseTypes() && this.isRelational("<") && (targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), 
        node.typeArguments = targs, super.parseNewArguments(node);
      }
      parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        const node = this.startNodeAt(startPos, startLoc);
        if (this.parseFunctionParams(node), this.parseArrow(node)) return this.parseArrowExpression(node, void 0, !0);
      }
      readToken_mult_modulo(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (42 === code && 47 === next && this.state.hasFlowComment) return this.state.hasFlowComment = !1, 
        this.state.pos += 2, void this.nextToken();
        super.readToken_mult_modulo(code);
      }
      readToken_pipe_amp(code) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        124 !== code || 125 !== next ? super.readToken_pipe_amp(code) : this.finishOp(types.braceBarR, 2);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        return this.state.hasFlowComment && this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment), 
        fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) return this.state.hasFlowComment && this.unexpected(null, FlowErrors.NestedFlowComment), 
        this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = !0);
        if (this.state.hasFlowComment) {
          const end = this.input.indexOf("*-/", this.state.pos += 2);
          if (-1 === end) throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
          this.state.pos = end + 3;
        } else super.skipBlockComment();
      }
      skipFlowComment() {
        const {pos: pos} = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        for (;[ 32, 9 ].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace)); ) shiftToFirstNonWhiteSpace++;
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos), ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        return 58 === ch2 && 58 === ch3 ? shiftToFirstNonWhiteSpace + 2 : "flow-include" === this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) ? shiftToFirstNonWhiteSpace + 12 : 58 === ch2 && 58 !== ch3 && shiftToFirstNonWhiteSpace;
      }
      hasFlowCommentCompletion() {
        if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
      }
      flowEnumErrorBooleanMemberNotInitialized(pos, {enumName: enumName, memberName: memberName}) {
        this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
      }
      flowEnumErrorInvalidMemberName(pos, {enumName: enumName, memberName: memberName}) {
        const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
      }
      flowEnumErrorDuplicateMemberName(pos, {enumName: enumName, memberName: memberName}) {
        this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
      }
      flowEnumErrorInconsistentMemberValues(pos, {enumName: enumName}) {
        this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
      }
      flowEnumErrorInvalidExplicitType(pos, {enumName: enumName, suppliedType: suppliedType}) {
        return this.raise(pos, null === suppliedType ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
      }
      flowEnumErrorInvalidMemberInitializer(pos, {enumName: enumName, explicitType: explicitType, memberName: memberName}) {
        let message = null;
        switch (explicitType) {
         case "boolean":
         case "number":
         case "string":
          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
          break;

         case "symbol":
          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
          break;

         default:
          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
        }
        return this.raise(pos, message, enumName, memberName, explicitType);
      }
      flowEnumErrorNumberMemberNotInitialized(pos, {enumName: enumName, memberName: memberName}) {
        this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
      }
      flowEnumErrorStringMemberInconsistentlyInitailized(pos, {enumName: enumName}) {
        this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
      }
      flowEnumMemberInit() {
        const startPos = this.state.start, endOfInit = () => this.match(types.comma) || this.match(types.braceR);
        switch (this.state.type) {
         case types.num:
          {
            const literal = this.parseLiteral(this.state.value, "NumericLiteral");
            return endOfInit() ? {
              type: "number",
              pos: literal.start,
              value: literal
            } : {
              type: "invalid",
              pos: startPos
            };
          }

         case types.string:
          {
            const literal = this.parseLiteral(this.state.value, "StringLiteral");
            return endOfInit() ? {
              type: "string",
              pos: literal.start,
              value: literal
            } : {
              type: "invalid",
              pos: startPos
            };
          }

         case types._true:
         case types._false:
          {
            const literal = this.parseBooleanLiteral();
            return endOfInit() ? {
              type: "boolean",
              pos: literal.start,
              value: literal
            } : {
              type: "invalid",
              pos: startPos
            };
          }

         default:
          return {
            type: "invalid",
            pos: startPos
          };
        }
      }
      flowEnumMemberRaw() {
        const pos = this.state.start;
        return {
          id: this.parseIdentifier(!0),
          init: this.eat(types.eq) ? this.flowEnumMemberInit() : {
            type: "none",
            pos: pos
          }
        };
      }
      flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        const {explicitType: explicitType} = context;
        null !== explicitType && explicitType !== expectedType && this.flowEnumErrorInvalidMemberInitializer(pos, context);
      }
      flowEnumMembers({enumName: enumName, explicitType: explicitType}) {
        const seenNames = new Set, members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        for (;!this.match(types.braceR); ) {
          const memberNode = this.startNode(), {id: id, init: init} = this.flowEnumMemberRaw(), memberName = id.name;
          if ("" === memberName) continue;
          /^[a-z]/.test(memberName) && this.flowEnumErrorInvalidMemberName(id.start, {
            enumName: enumName,
            memberName: memberName
          }), seenNames.has(memberName) && this.flowEnumErrorDuplicateMemberName(id.start, {
            enumName: enumName,
            memberName: memberName
          }), seenNames.add(memberName);
          const context = {
            enumName: enumName,
            explicitType: explicitType,
            memberName: memberName
          };
          switch (memberNode.id = id, init.type) {
           case "boolean":
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean"), memberNode.init = init.value, 
            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
            break;

           case "number":
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number"), memberNode.init = init.value, 
            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
            break;

           case "string":
            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string"), memberNode.init = init.value, 
            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
            break;

           case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);

           case "none":
            switch (explicitType) {
             case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
              break;

             case "number":
              this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
              break;

             default:
              members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
            }
          }
          this.match(types.braceR) || this.expect(types.comma);
        }
        return members;
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {enumName: enumName}) {
        if (0 === initializedMembers.length) return defaultedMembers;
        if (0 === defaultedMembers.length) return initializedMembers;
        if (defaultedMembers.length > initializedMembers.length) {
          for (let _i = 0; _i < initializedMembers.length; _i++) {
            const member = initializedMembers[_i];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName: enumName
            });
          }
          return defaultedMembers;
        }
        for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {
          const member = defaultedMembers[_i2];
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName: enumName
          });
        }
        return initializedMembers;
      }
      flowEnumParseExplicitType({enumName: enumName}) {
        if (this.eatContextual("of")) {
          if (!this.match(types.name)) throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName: enumName,
            suppliedType: null
          });
          const {value: value} = this.state;
          return this.next(), "boolean" !== value && "number" !== value && "string" !== value && "symbol" !== value && this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName: enumName,
            suppliedType: value
          }), value;
        }
        return null;
      }
      flowEnumBody(node, {enumName: enumName, nameLoc: nameLoc}) {
        const explicitType = this.flowEnumParseExplicitType({
          enumName: enumName
        });
        this.expect(types.braceL);
        const members = this.flowEnumMembers({
          enumName: enumName,
          explicitType: explicitType
        });
        switch (explicitType) {
         case "boolean":
          return node.explicitType = !0, node.members = members.booleanMembers, this.expect(types.braceR), 
          this.finishNode(node, "EnumBooleanBody");

         case "number":
          return node.explicitType = !0, node.members = members.numberMembers, this.expect(types.braceR), 
          this.finishNode(node, "EnumNumberBody");

         case "string":
          return node.explicitType = !0, node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName: enumName
          }), this.expect(types.braceR), this.finishNode(node, "EnumStringBody");

         case "symbol":
          return node.members = members.defaultedMembers, this.expect(types.braceR), this.finishNode(node, "EnumSymbolBody");

         default:
          {
            const empty = () => (node.members = [], this.expect(types.braceR), this.finishNode(node, "EnumStringBody"));
            node.explicitType = !1;
            const boolsLen = members.booleanMembers.length, numsLen = members.numberMembers.length, strsLen = members.stringMembers.length, defaultedLen = members.defaultedMembers.length;
            if (boolsLen || numsLen || strsLen || defaultedLen) {
              if (boolsLen || numsLen) {
                if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                  for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {
                    const member = _members$defaultedMem[_i3];
                    this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                      enumName: enumName,
                      memberName: member.id.name
                    });
                  }
                  return node.members = members.booleanMembers, this.expect(types.braceR), this.finishNode(node, "EnumBooleanBody");
                }
                if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                  for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {
                    const member = _members$defaultedMem2[_i4];
                    this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                      enumName: enumName,
                      memberName: member.id.name
                    });
                  }
                  return node.members = members.numberMembers, this.expect(types.braceR), this.finishNode(node, "EnumNumberBody");
                }
                return this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                  enumName: enumName
                }), empty();
              }
              return node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName: enumName
              }), this.expect(types.braceR), this.finishNode(node, "EnumStringBody");
            }
            return empty();
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        return node.id = id, node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start
        }), this.finishNode(node, "EnumDeclaration");
      }
      updateContext(prevType) {
        this.match(types.name) && "of" === this.state.value && prevType === types.name && "interface" === this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ? this.state.exprAllowed = !1 : super.updateContext(prevType);
      }
    },
    typescript: superClass => class extends superClass {
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return this.match(types.name);
      }
      tsNextTokenCanFollowModifier() {
        return this.next(), !(this.hasPrecedingLineBreak() || this.match(types.parenL) || this.match(types.parenR) || this.match(types.colon) || this.match(types.eq) || this.match(types.question) || this.match(types.bang));
      }
      tsParseModifier(allowedModifiers) {
        if (!this.match(types.name)) return;
        const modifier = this.state.value;
        return -1 !== allowedModifiers.indexOf(modifier) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? modifier : void 0;
      }
      tsParseModifiers(modified, allowedModifiers) {
        for (;;) {
          const startPos = this.state.start, modifier = this.tsParseModifier(allowedModifiers);
          if (!modifier) break;
          Object.hasOwnProperty.call(modified, modifier) && this.raise(startPos, TSErrors.DuplicateModifier, modifier), 
          modified[modifier] = !0;
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
         case "EnumMembers":
         case "TypeMembers":
          return this.match(types.braceR);

         case "HeritageClauseElement":
          return this.match(types.braceL);

         case "TupleElementTypes":
          return this.match(types.bracketR);

         case "TypeParametersOrArguments":
          return this.isRelational(">");
        }
        throw new Error("Unreachable");
      }
      tsParseList(kind, parseElement) {
        const result = [];
        for (;!this.tsIsListTerminator(kind); ) result.push(parseElement());
        return result;
      }
      tsParseDelimitedList(kind, parseElement) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, !0));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        const result = [];
        for (;!this.tsIsListTerminator(kind); ) {
          const element = parseElement();
          if (null == element) return;
          if (result.push(element), !this.eat(types.comma)) {
            if (this.tsIsListTerminator(kind)) break;
            return void (expectSuccess && this.expect(types.comma));
          }
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        skipFirstToken || (bracket ? this.expect(types.bracketL) : this.expectRelational("<"));
        const result = this.tsParseDelimitedList(kind, parseElement);
        return bracket ? this.expect(types.bracketR) : this.expectRelational(">"), result;
      }
      tsParseImportType() {
        const node = this.startNode();
        return this.expect(types._import), this.expect(types.parenL), this.match(types.string) || this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument), 
        node.argument = this.parseExprAtom(), this.expect(types.parenR), this.eat(types.dot) && (node.qualifier = this.tsParseEntityName(!0)), 
        this.isRelational("<") && (node.typeParameters = this.tsParseTypeArguments()), this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(allowReservedWords) {
        let entity = this.parseIdentifier();
        for (;this.eat(types.dot); ) {
          const node = this.startNodeAtNode(entity);
          node.left = entity, node.right = this.parseIdentifier(allowReservedWords), entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        return node.typeName = this.tsParseEntityName(!1), !this.hasPrecedingLineBreak() && this.isRelational("<") && (node.typeParameters = this.tsParseTypeArguments()), 
        this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        return node.parameterName = lhs, node.typeAnnotation = this.tsParseTypeAnnotation(!1), 
        this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        return this.next(), this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        return this.expect(types._typeof), this.match(types._import) ? node.exprName = this.tsParseImportType() : node.exprName = this.tsParseEntityName(!0), 
        this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter() {
        const node = this.startNode();
        return node.name = this.parseIdentifierName(node.start), node.constraint = this.tsEatThenParseType(types._extends), 
        node.default = this.tsEatThenParseType(types.eq), this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters() {
        if (this.isRelational("<")) return this.tsParseTypeParameters();
      }
      tsParseTypeParameters() {
        const node = this.startNode();
        return this.isRelational("<") || this.match(types.jsxTagStart) ? this.next() : this.unexpected(), 
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), !1, !0), 
        this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsTryNextParseConstantContext() {
        return this.lookahead().type === types._const ? (this.next(), this.tsParseTypeReference()) : null;
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === types.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters(), this.expect(types.parenL), 
        signature.parameters = this.tsParseBindingListForSignature(), (returnTokenRequired || this.match(returnToken)) && (signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken));
      }
      tsParseBindingListForSignature() {
        return this.parseBindingList(types.parenR, 41).map(pattern => ("Identifier" !== pattern.type && "RestElement" !== pattern.type && "ObjectPattern" !== pattern.type && "ArrayPattern" !== pattern.type && this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type), 
        pattern));
      }
      tsParseTypeMemberSemicolon() {
        this.eat(types.comma) || this.semicolon();
      }
      tsParseSignatureMember(kind, node) {
        return this.tsFillSignature(types.colon, node), this.tsParseTypeMemberSemicolon(), 
        this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        return this.next(), this.eat(types.name) && this.match(types.colon);
      }
      tsTryParseIndexSignature(node) {
        if (!this.match(types.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
        this.expect(types.bracketL);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(id), this.expect(types.bracketR), 
        node.parameters = [ id ];
        const type = this.tsTryParseTypeAnnotation();
        return type && (node.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), 
        this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        this.eat(types.question) && (node.optional = !0);
        const nodeAny = node;
        if (readonly || !this.match(types.parenL) && !this.isRelational("<")) {
          const property = nodeAny;
          readonly && (property.readonly = !0);
          const type = this.tsTryParseTypeAnnotation();
          return type && (property.typeAnnotation = type), this.tsParseTypeMemberSemicolon(), 
          this.finishNode(property, "TSPropertySignature");
        }
        {
          const method = nodeAny;
          return this.tsFillSignature(types.colon, method), this.tsParseTypeMemberSemicolon(), 
          this.finishNode(method, "TSMethodSignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(types.parenL) || this.isRelational("<")) return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        if (this.match(types._new)) {
          const id = this.startNode();
          return this.next(), this.match(types.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", node) : (node.key = this.createIdentifier(id, "new"), 
          this.tsParsePropertyOrMethodSignature(node, !1));
        }
        const readonly = !!this.tsParseModifier([ "readonly" ]), idx = this.tsTryParseIndexSignature(node);
        return idx ? (readonly && (node.readonly = !0), idx) : (this.parsePropertyName(node, !1), 
        this.tsParsePropertyOrMethodSignature(node, readonly));
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        return node.members = this.tsParseObjectTypeMembers(), this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(types.braceL);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        return this.expect(types.braceR), members;
      }
      tsIsStartOfMappedType() {
        return this.next(), this.eat(types.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), 
        !!this.match(types.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), 
        this.match(types._in))));
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        return node.name = this.parseIdentifierName(node.start), node.constraint = this.tsExpectThenParseType(types._in), 
        this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        return this.expect(types.braceL), this.match(types.plusMin) ? (node.readonly = this.state.value, 
        this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (node.readonly = !0), 
        this.expect(types.bracketL), node.typeParameter = this.tsParseMappedTypeParameter(), 
        this.expect(types.bracketR), this.match(types.plusMin) ? (node.optional = this.state.value, 
        this.next(), this.expect(types.question)) : this.eat(types.question) && (node.optional = !0), 
        node.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(types.braceR), 
        this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
        let seenOptionalElement = !1;
        return node.elementTypes.forEach(elementNode => {
          "TSOptionalType" === elementNode.type ? seenOptionalElement = !0 : seenOptionalElement && "TSRestType" !== elementNode.type && this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
        }), this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        if (this.match(types.ellipsis)) {
          const restNode = this.startNode();
          return this.next(), restNode.typeAnnotation = this.tsParseType(), this.match(types.comma) && 93 !== this.lookaheadCharCode() && this.raiseRestNotLast(this.state.start), 
          this.finishNode(restNode, "TSRestType");
        }
        const type = this.tsParseType();
        if (this.eat(types.question)) {
          const optionalTypeNode = this.startNodeAtNode(type);
          return optionalTypeNode.typeAnnotation = type, this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        return this.expect(types.parenL), node.typeAnnotation = this.tsParseType(), this.expect(types.parenR), 
        this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type) {
        const node = this.startNode();
        return "TSConstructorType" === type && this.expect(types._new), this.tsFillSignature(types.arrow, node), 
        this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        return node.literal = (() => {
          switch (this.state.type) {
           case types.num:
           case types.bigint:
           case types.string:
           case types._true:
           case types._false:
            return this.parseExprAtom();

           default:
            throw this.unexpected();
          }
        })(), this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode(), templateNode = this.parseTemplate(!1);
        return templateNode.expressions.length > 0 && this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution), 
        node.literal = templateNode, this.finishNode(node, "TSLiteralType");
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(thisKeyword) : thisKeyword;
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
         case types.name:
         case types._void:
         case types._null:
          {
            const type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : function(value) {
              switch (value) {
               case "any":
                return "TSAnyKeyword";

               case "boolean":
                return "TSBooleanKeyword";

               case "bigint":
                return "TSBigIntKeyword";

               case "never":
                return "TSNeverKeyword";

               case "number":
                return "TSNumberKeyword";

               case "object":
                return "TSObjectKeyword";

               case "string":
                return "TSStringKeyword";

               case "symbol":
                return "TSSymbolKeyword";

               case "undefined":
                return "TSUndefinedKeyword";

               case "unknown":
                return "TSUnknownKeyword";

               default:
                return;
              }
            }(this.state.value);
            if (void 0 !== type && 46 !== this.lookaheadCharCode()) {
              const node = this.startNode();
              return this.next(), this.finishNode(node, type);
            }
            return this.tsParseTypeReference();
          }

         case types.string:
         case types.num:
         case types.bigint:
         case types._true:
         case types._false:
          return this.tsParseLiteralTypeNode();

         case types.plusMin:
          if ("-" === this.state.value) {
            const node = this.startNode(), nextToken = this.lookahead();
            if (nextToken.type !== types.num && nextToken.type !== types.bigint) throw this.unexpected();
            return node.literal = this.parseMaybeUnary(), this.finishNode(node, "TSLiteralType");
          }
          break;

         case types._this:
          return this.tsParseThisTypeOrThisTypePredicate();

         case types._typeof:
          return this.tsParseTypeQuery();

         case types._import:
          return this.tsParseImportType();

         case types.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

         case types.bracketL:
          return this.tsParseTupleType();

         case types.parenL:
          return this.tsParseParenthesizedType();

         case types.backQuote:
          return this.tsParseTemplateLiteralType();
        }
        throw this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        for (;!this.hasPrecedingLineBreak() && this.eat(types.bracketL); ) if (this.match(types.bracketR)) {
          const node = this.startNodeAtNode(type);
          node.elementType = type, this.expect(types.bracketR), type = this.finishNode(node, "TSArrayType");
        } else {
          const node = this.startNodeAtNode(type);
          node.objectType = type, node.indexType = this.tsParseType(), this.expect(types.bracketR), 
          type = this.finishNode(node, "TSIndexedAccessType");
        }
        return type;
      }
      tsParseTypeOperator(operator) {
        const node = this.startNode();
        return this.expectContextual(operator), node.operator = operator, node.typeAnnotation = this.tsParseTypeOperatorOrHigher(), 
        "readonly" === operator && this.tsCheckTypeAnnotationForReadOnly(node), this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
         case "TSTupleType":
         case "TSArrayType":
          return;

         default:
          this.raise(node.start, TSErrors.UnexpectedReadonly);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual("infer");
        const typeParameter = this.startNode();
        return typeParameter.name = this.parseIdentifierName(typeParameter.start), node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter"), 
        this.finishNode(node, "TSInferType");
      }
      tsParseTypeOperatorOrHigher() {
        const operator = [ "keyof", "unique", "readonly" ].find(kw => this.isContextual(kw));
        return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        this.eat(operator);
        let type = parseConstituentType();
        if (this.match(operator)) {
          const types = [ type ];
          for (;this.eat(operator); ) types.push(parseConstituentType());
          const node = this.startNodeAtNode(type);
          node.types = types, type = this.finishNode(node, kind);
        }
        return type;
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
      }
      tsIsStartOfFunctionType() {
        return !!this.isRelational("<") || this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (this.match(types.name) || this.match(types._this)) return this.next(), !0;
        if (this.match(types.braceL)) {
          let braceStackCounter = 1;
          for (this.next(); braceStackCounter > 0; ) this.match(types.braceL) ? ++braceStackCounter : this.match(types.braceR) && --braceStackCounter, 
          this.next();
          return !0;
        }
        if (this.match(types.bracketL)) {
          let braceStackCounter = 1;
          for (this.next(); braceStackCounter > 0; ) this.match(types.bracketL) ? ++braceStackCounter : this.match(types.bracketR) && --braceStackCounter, 
          this.next();
          return !0;
        }
        return !1;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        if (this.next(), this.match(types.parenR) || this.match(types.ellipsis)) return !0;
        if (this.tsSkipParameterStart()) {
          if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) return !0;
          if (this.match(types.parenR) && (this.next(), this.match(types.arrow))) return !0;
        }
        return !1;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const asserts = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(types._this)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if ("TSThisType" === thisTypePredicate.type) {
              const node = this.startNodeAtNode(t);
              node.parameterName = thisTypePredicate, node.asserts = !0, thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else thisTypePredicate.asserts = !0;
            return t.typeAnnotation = thisTypePredicate, this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) return this.tsParseTypeAnnotation(!1, t);
            const node = this.startNodeAtNode(t);
            return node.parameterName = this.parseIdentifier(), node.asserts = asserts, t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), 
            this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(!1), node = this.startNodeAtNode(t);
          return node.parameterName = typePredicateVariable, node.typeAnnotation = type, node.asserts = asserts, 
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate"), this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : void 0;
      }
      tsTryParseTypeAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeAnnotation() : void 0;
      }
      tsTryParseType() {
        return this.tsEatThenParseType(types.colon);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.next(), 
        id;
      }
      tsParseTypePredicateAsserts() {
        if (!this.match(types.name) || "asserts" !== this.state.value || this.hasPrecedingLineBreak()) return !1;
        const containsEsc = this.state.containsEsc;
        return this.next(), !(!this.match(types.name) && !this.match(types._this)) && (containsEsc && this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts"), 
        !0);
      }
      tsParseTypeAnnotation(eatColon = !0, t = this.startNode()) {
        return this.tsInType(() => {
          eatColon && this.expect(types.colon), t.typeAnnotation = this.tsParseType();
        }), this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) return type;
        const node = this.startNodeAtNode(type);
        return node.checkType = type, node.extendsType = this.tsParseNonConditionalType(), 
        this.expect(types.question), node.trueType = this.tsParseType(), this.expect(types.colon), 
        node.falseType = this.tsParseType(), this.finishNode(node, "TSConditionalType");
      }
      tsParseNonConditionalType() {
        return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(types._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        const node = this.startNode(), _const = this.tsTryNextParseConstantContext();
        return node.typeAnnotation = _const || this.tsNextThenParseType(), this.expectRelational(">"), 
        node.expression = this.parseMaybeUnary(), this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(descriptor) {
        const originalStart = this.state.start, delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
        return delimitedList.length || this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor), 
        delimitedList;
      }
      tsParseExpressionWithTypeArguments() {
        const node = this.startNode();
        return node.expression = this.tsParseEntityName(!1), this.isRelational("<") && (node.typeParameters = this.tsParseTypeArguments()), 
        this.finishNode(node, "TSExpressionWithTypeArguments");
      }
      tsParseInterfaceDeclaration(node) {
        node.id = this.parseIdentifier(), this.checkLVal(node.id, 130, void 0, "typescript interface declaration"), 
        node.typeParameters = this.tsTryParseTypeParameters(), this.eat(types._extends) && (node.extends = this.tsParseHeritageClause("extends"));
        const body = this.startNode();
        return body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), node.body = this.finishNode(body, "TSInterfaceBody"), 
        this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        return node.id = this.parseIdentifier(), this.checkLVal(node.id, 2, void 0, "typescript type alias"), 
        node.typeParameters = this.tsTryParseTypeParameters(), node.typeAnnotation = this.tsExpectThenParseType(types.eq), 
        this.semicolon(), this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [ oldContext[0] ];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = !0;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsEatThenParseType(token) {
        return this.match(token) ? this.tsNextThenParseType() : void 0;
      }
      tsExpectThenParseType(token) {
        return this.tsDoThenParseType(() => this.expect(token));
      }
      tsNextThenParseType() {
        return this.tsDoThenParseType(() => this.next());
      }
      tsDoThenParseType(cb) {
        return this.tsInType(() => (cb(), this.tsParseType()));
      }
      tsParseEnumMember() {
        const node = this.startNode();
        return node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(!0), 
        this.eat(types.eq) && (node.initializer = this.parseMaybeAssign()), this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, isConst) {
        return isConst && (node.const = !0), node.id = this.parseIdentifier(), this.checkLVal(node.id, isConst ? 779 : 267, void 0, "typescript enum declaration"), 
        this.expect(types.braceL), node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), 
        this.expect(types.braceR), this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        return this.scope.enter(0), this.expect(types.braceL), this.parseBlockOrModuleBlockBody(node.body = [], void 0, !0, types.braceR), 
        this.scope.exit(), this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = !1) {
        if (node.id = this.parseIdentifier(), nested || this.checkLVal(node.id, 1024, null, "module or namespace declaration"), 
        this.eat(types.dot)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, !0), node.body = inner;
        } else this.scope.enter(128), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), 
        this.prodParam.exit(), this.scope.exit();
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        return this.isContextual("global") ? (node.global = !0, node.id = this.parseIdentifier()) : this.match(types.string) ? node.id = this.parseExprAtom() : this.unexpected(), 
        this.match(types.braceL) ? (this.scope.enter(128), this.prodParam.enter(0), node.body = this.tsParseModuleBlock(), 
        this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, isExport) {
        return node.isExport = isExport || !1, node.id = this.parseIdentifier(), this.checkLVal(node.id, 9, void 0, "import equals declaration"), 
        this.expect(types.eq), node.moduleReference = this.tsParseModuleReference(), this.semicolon(), 
        this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual("require") && 40 === this.lookaheadCharCode();
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        if (this.expectContextual("require"), this.expect(types.parenL), !this.match(types.string)) throw this.unexpected();
        return node.expression = this.parseExprAtom(), this.expect(types.parenR), this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone(), res = f();
        return this.state = state, res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse(abort => f() || abort());
        if (!result.aborted && result.node) return result.error && (this.state = result.failState), 
        result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone(), result = f();
        return void 0 !== result && !1 !== result ? result : void (this.state = state);
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) return;
        let kind, starttype = this.state.type;
        switch (this.isContextual("let") && (starttype = types._var, kind = "let"), starttype) {
         case types._function:
          return this.parseFunctionStatement(nany, !1, !0);

         case types._class:
          return nany.declare = !0, this.parseClass(nany, !0, !1);

         case types._const:
          if (this.match(types._const) && this.isLookaheadContextual("enum")) return this.expect(types._const), 
          this.expectContextual("enum"), this.tsParseEnumDeclaration(nany, !0);

         case types._var:
          return kind = kind || this.state.value, this.parseVarStatement(nany, kind);

         case types.name:
          {
            const value = this.state.value;
            return "global" === value ? this.tsParseAmbientExternalModuleDeclaration(nany) : this.tsParseDeclaration(nany, value, !0);
          }
        }
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, !0);
      }
      tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
         case "declare":
          {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) return declaration.declare = !0, declaration;
            break;
          }

         case "global":
          if (this.match(types.braceL)) {
            this.scope.enter(128), this.prodParam.enter(0);
            const mod = node;
            return mod.global = !0, mod.id = expr, mod.body = this.tsParseModuleBlock(), this.scope.exit(), 
            this.prodParam.exit(), this.finishNode(mod, "TSModuleDeclaration");
          }
          break;

         default:
          return this.tsParseDeclaration(node, expr.name, !1);
        }
      }
      tsParseDeclaration(node, value, next) {
        switch (value) {
         case "abstract":
          if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
            const cls = node;
            return cls.abstract = !0, next && (this.next(), this.match(types._class) || this.unexpected(null, types._class)), 
            this.parseClass(cls, !0, !1);
          }
          break;

         case "enum":
          if (next || this.match(types.name)) return next && this.next(), this.tsParseEnumDeclaration(node, !1);
          break;

         case "interface":
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) return next && this.next(), 
          this.tsParseInterfaceDeclaration(node);
          break;

         case "module":
          if (next && this.next(), this.match(types.string)) return this.tsParseAmbientExternalModuleDeclaration(node);
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) return this.tsParseModuleOrNamespaceDeclaration(node);
          break;

         case "namespace":
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) return next && this.next(), 
          this.tsParseModuleOrNamespaceDeclaration(node);
          break;

         case "type":
          if (this.tsCheckLineTerminatorAndMatch(types.name, next)) return next && this.next(), 
          this.tsParseTypeAliasDeclaration(node);
        }
      }
      tsCheckLineTerminatorAndMatch(tokenType, next) {
        return (next || this.match(tokenType)) && !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        if (!this.isRelational("<")) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startPos, startLoc);
          return node.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(node), 
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(types.arrow), 
          node;
        });
        return this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.yieldPos = oldYieldPos, 
        this.state.awaitPos = oldAwaitPos, res ? this.parseArrowExpression(res, null, !0) : void 0;
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        return node.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), 
        this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 
        this.state.exprAllowed = !1, this.expectRelational(">"), this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        if (this.match(types.name)) switch (this.state.value) {
         case "abstract":
         case "declare":
         case "enum":
         case "interface":
         case "module":
         case "namespace":
         case "type":
          return !0;
        }
        return !1;
      }
      isExportDefaultSpecifier() {
        return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(allowModifiers, decorators) {
        const startPos = this.state.start, startLoc = this.state.startLoc;
        let accessibility, readonly = !1;
        allowModifiers && (accessibility = this.parseAccessModifier(), readonly = !!this.tsParseModifier([ "readonly" ]));
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
        if (accessibility || readonly) {
          const pp = this.startNodeAt(startPos, startLoc);
          return decorators.length && (pp.decorators = decorators), accessibility && (pp.accessibility = accessibility), 
          readonly && (pp.readonly = readonly), "Identifier" !== elt.type && "AssignmentPattern" !== elt.type && this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind), 
          pp.parameter = elt, this.finishNode(pp, "TSParameterProperty");
        }
        return decorators.length && (left.decorators = decorators), elt;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = !1) {
        this.match(types.colon) && (node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon));
        const bodilessType = "FunctionDeclaration" === type ? "TSDeclareFunction" : "ClassMethod" === type ? "TSDeclareMethod" : void 0;
        bodilessType && !this.match(types.braceL) && this.isLineTerminator() ? this.finishNode(node, bodilessType) : super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        !node.body && node.id ? this.checkLVal(node.id, 1024, null, "function name") : super.registerFunctionStatementId(...arguments);
      }
      parseSubscript(base, startPos, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
          this.state.exprAllowed = !1, this.next();
          const nonNullExpression = this.startNodeAt(startPos, startLoc);
          return nonNullExpression.expression = base, this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        if (this.isRelational("<")) {
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);
              if (asyncArrowFn) return asyncArrowFn;
            }
            const node = this.startNodeAt(startPos, startLoc);
            node.callee = base;
            const typeArguments = this.tsParseTypeArguments();
            if (typeArguments) {
              if (!noCalls && this.eat(types.parenL)) return node.arguments = this.parseCallExpressionArguments(types.parenR, !1), 
              node.typeParameters = typeArguments, this.finishCallExpression(node, state.optionalChainMember);
              if (this.match(types.backQuote)) return this.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);
            }
            this.unexpected();
          });
          if (result) return result;
        }
        return super.parseSubscript(base, startPos, startLoc, noCalls, state);
      }
      parseNewArguments(node) {
        if (this.isRelational("<")) {
          const typeParameters = this.tsTryParseAndCatch(() => {
            const args = this.tsParseTypeArguments();
            return this.match(types.parenL) || this.unexpected(), args;
          });
          typeParameters && (node.typeParameters = typeParameters);
        }
        super.parseNewArguments(node);
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;
          const _const = this.tsTryNextParseConstantContext();
          return node.typeAnnotation = _const || this.tsNextThenParseType(), this.finishNode(node, "TSAsExpression"), 
          this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {}
      checkDuplicateExports() {}
      parseImport(node) {
        if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {
          const ahead = this.lookahead();
          if (this.match(types.name) && ahead.type === types.eq) return this.tsParseImportEqualsDeclaration(node);
          !this.isContextual("type") || ahead.type === types.comma || ahead.type === types.name && "from" === ahead.value ? node.importKind = "value" : (node.importKind = "type", 
          this.next());
        }
        const importNode = super.parseImport(node);
        return "type" === importNode.importKind && importNode.specifiers.length > 1 && "ImportDefaultSpecifier" === importNode.specifiers[0].type && this.raise(importNode.start, "A type-only import can specify a default import or named bindings, but not both."), 
        importNode;
      }
      parseExport(node) {
        if (this.match(types._import)) return this.expect(types._import), this.tsParseImportEqualsDeclaration(node, !0);
        if (this.eat(types.eq)) {
          const assign = node;
          return assign.expression = this.parseExpression(), this.semicolon(), this.finishNode(assign, "TSExportAssignment");
        }
        if (this.eatContextual("as")) {
          const decl = node;
          return this.expectContextual("namespace"), decl.id = this.parseIdentifier(), this.semicolon(), 
          this.finishNode(decl, "TSNamespaceExportDeclaration");
        }
        return this.isContextual("type") && this.lookahead().type === types.braceL ? (this.next(), 
        node.exportKind = "type") : node.exportKind = "value", super.parseExport(node);
      }
      isAbstractClass() {
        return this.isContextual("abstract") && this.lookahead().type === types._class;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          return this.next(), this.parseClass(cls, !0, !0), cls.abstract = !0, cls;
        }
        if ("interface" === this.state.value) {
          const result = this.tsParseDeclaration(this.startNode(), this.state.value, !0);
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseStatementContent(context, topLevel) {
        if (this.state.type === types._const) {
          const ahead = this.lookahead();
          if (ahead.type === types.name && "enum" === ahead.value) {
            const node = this.startNode();
            return this.expect(types._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(node, !0);
          }
        }
        return super.parseStatementContent(context, topLevel);
      }
      parseAccessModifier() {
        return this.tsParseModifier([ "public", "protected", "private" ]);
      }
      parseClassMember(classBody, member, state, constructorAllowsSuper) {
        this.tsParseModifiers(member, [ "declare" ]);
        const accessibility = this.parseAccessModifier();
        accessibility && (member.accessibility = accessibility), this.tsParseModifiers(member, [ "declare" ]), 
        super.parseClassMember(classBody, member, state, constructorAllowsSuper);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
        this.tsParseModifiers(member, [ "abstract", "readonly", "declare" ]);
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) return classBody.body.push(idx), member.abstract && this.raise(member.start, TSErrors.IndexSignatureHasAbstract), 
        isStatic && this.raise(member.start, TSErrors.IndexSignatureHasStatic), void (member.accessibility && this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility));
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        this.eat(types.question) && (methodOrProp.optional = !0), methodOrProp.readonly && this.match(types.parenL) && this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly), 
        methodOrProp.declare && this.match(types.parenL) && this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
      }
      parseExpressionStatement(node, expr) {
        return ("Identifier" === expr.type ? this.tsParseExpressionStatement(node, expr) : void 0) || super.parseExpressionStatement(node, expr);
      }
      shouldParseExportDeclaration() {
        return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
      }
      parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
        if (!refNeedsArrowPos || !this.match(types.question)) return super.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
        const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));
        return result.node ? (result.error && (this.state = result.failState), result.node) : (refNeedsArrowPos.start = result.error.pos || this.state.start, 
        expr);
      }
      parseParenItem(node, startPos, startLoc) {
        if (node = super.parseParenItem(node, startPos, startLoc), this.eat(types.question) && (node.optional = !0, 
        this.resetEndLocation(node)), this.match(types.colon)) {
          const typeCastNode = this.startNodeAt(startPos, startLoc);
          return typeCastNode.expression = node, typeCastNode.typeAnnotation = this.tsParseTypeAnnotation(), 
          this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        const startPos = this.state.start, startLoc = this.state.startLoc, isDeclare = this.eatContextual("declare");
        let declaration;
        return this.match(types.name) && (declaration = this.tsTryParseExportDeclaration()), 
        declaration || (declaration = super.parseExportDeclaration(node)), declaration && ("TSInterfaceDeclaration" === declaration.type || "TSTypeAliasDeclaration" === declaration.type || isDeclare) && (node.exportKind = "type"), 
        declaration && isDeclare && (this.resetStartLocation(declaration, startPos, startLoc), 
        declaration.declare = !0), declaration;
      }
      parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual("implements")) return;
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 139);
        const typeParameters = this.tsTryParseTypeParameters();
        typeParameters && (node.typeParameters = typeParameters);
      }
      parseClassPropertyAnnotation(node) {
        !node.optional && this.eat(types.bang) && (node.definite = !0);
        const type = this.tsTryParseTypeAnnotation();
        type && (node.typeAnnotation = type);
      }
      parseClassProperty(node) {
        return this.parseClassPropertyAnnotation(node), node.declare && this.match(types.equal) && this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer), 
        super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        return node.abstract && this.raise(node.start, TSErrors.PrivateElementHasAbstract), 
        node.accessibility && this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility), 
        this.parseClassPropertyAnnotation(node), super.parseClassPrivateProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters();
        typeParameters && (method.typeParameters = typeParameters), super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters();
        typeParameters && (method.typeParameters = typeParameters), super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node), node.superClass && this.isRelational("<") && (node.superTypeParameters = this.tsParseTypeArguments()), 
        this.eatContextual("implements") && (node.implements = this.tsParseHeritageClause("implements"));
      }
      parseObjPropValue(prop, ...args) {
        const typeParameters = this.tsTryParseTypeParameters();
        typeParameters && (prop.typeParameters = typeParameters), super.parseObjPropValue(prop, ...args);
      }
      parseFunctionParams(node, allowModifiers) {
        const typeParameters = this.tsTryParseTypeParameters();
        typeParameters && (node.typeParameters = typeParameters), super.parseFunctionParams(node, allowModifiers);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind), "Identifier" === decl.id.type && this.eat(types.bang) && (decl.definite = !0);
        const type = this.tsTryParseTypeAnnotation();
        type && (decl.id.typeAnnotation = type, this.resetEndLocation(decl.id));
      }
      parseAsyncArrowFromCallExpression(node, call) {
        return this.match(types.colon) && (node.returnType = this.tsParseTypeAnnotation()), 
        super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(...args) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;
        let state, jsx, typeCast, typeParameters;
        if (this.match(types.jsxTagStart)) {
          if (state = this.state.clone(), jsx = this.tryParse(() => super.parseMaybeAssign(...args), state), 
          !jsx.error) return jsx.node;
          const {context: context} = this.state;
          context[context.length - 1] === types$1.j_oTag ? context.length -= 2 : context[context.length - 1] === types$1.j_expr && (context.length -= 1);
        }
        if (!(null == (_jsx = jsx) ? void 0 : _jsx.error) && !this.isRelational("<")) return super.parseMaybeAssign(...args);
        state = state || this.state.clone();
        const arrow = this.tryParse(abort => {
          var _typeParameters;
          typeParameters = this.tsParseTypeParameters();
          const expr = super.parseMaybeAssign(...args);
          return ("ArrowFunctionExpression" !== expr.type || expr.extra && expr.extra.parenthesized) && abort(), 
          0 !== (null == (_typeParameters = typeParameters) ? void 0 : _typeParameters.params.length) && this.resetStartLocationFromNode(expr, typeParameters), 
          expr.typeParameters = typeParameters, expr;
        }, state);
        if (!arrow.error && !arrow.aborted) return arrow.node;
        if (!jsx && (assert(!this.hasPlugin("jsx")), typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state), 
        !typeCast.error)) return typeCast.node;
        if (null == (_jsx2 = jsx) ? void 0 : _jsx2.node) return this.state = jsx.failState, 
        jsx.node;
        if (arrow.node) return this.state = arrow.failState, arrow.node;
        if (null == (_typeCast = typeCast) ? void 0 : _typeCast.node) return this.state = typeCast.failState, 
        typeCast.node;
        if (null == (_jsx3 = jsx) ? void 0 : _jsx3.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        if (null == (_typeCast2 = typeCast) ? void 0 : _typeCast2.thrown) throw typeCast.error;
        throw (null == (_jsx4 = jsx) ? void 0 : _jsx4.error) || arrow.error || (null == (_typeCast3 = typeCast) ? void 0 : _typeCast3.error);
      }
      parseMaybeUnary(refExpressionErrors) {
        return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(refExpressionErrors);
      }
      parseArrow(node) {
        if (this.match(types.colon)) {
          const result = this.tryParse(abort => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
            return !this.canInsertSemicolon() && this.match(types.arrow) || abort(), returnType;
          });
          if (result.aborted) return;
          result.thrown || (result.error && (this.state = result.failState), node.returnType = result.node);
        }
        return super.parseArrow(node);
      }
      parseAssignableListItemTypes(param) {
        this.eat(types.question) && ("Identifier" !== param.type && this.raise(param.start, TSErrors.PatternIsOptional), 
        param.optional = !0);
        const type = this.tsTryParseTypeAnnotation();
        return type && (param.typeAnnotation = type), this.resetEndLocation(param), param;
      }
      toAssignable(node) {
        switch (node.type) {
         case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(node));

         case "TSParameterProperty":
          return super.toAssignable(node);

         case "TSAsExpression":
         case "TSNonNullExpression":
         case "TSTypeAssertion":
          return node.expression = this.toAssignable(node.expression), node;

         default:
          return super.toAssignable(node);
        }
      }
      checkLVal(expr, bindingType = 64, checkClashes, contextDescription) {
        switch (expr.type) {
         case "TSTypeCastExpression":
          return;

         case "TSParameterProperty":
          return void this.checkLVal(expr.parameter, bindingType, checkClashes, "parameter property");

         case "TSAsExpression":
         case "TSNonNullExpression":
         case "TSTypeAssertion":
          return void this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);

         default:
          return void super.checkLVal(expr, bindingType, checkClashes, contextDescription);
        }
      }
      parseBindingAtom() {
        switch (this.state.type) {
         case types._this:
          return this.parseIdentifier(!0);

         default:
          return super.parseBindingAtom();
        }
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.isRelational("<")) {
          const typeArguments = this.tsParseTypeArguments();
          if (this.match(types.parenL)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            return call.typeParameters = typeArguments, call;
          }
          this.unexpected(this.state.start, types.parenL);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      isClassMethod() {
        return this.isRelational("<") || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();
      }
      parseMaybeDefault(...args) {
        const node = super.parseMaybeDefault(...args);
        return "AssignmentPattern" === node.type && node.typeAnnotation && node.right.start < node.typeAnnotation.start && this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign), 
        node;
      }
      getTokenFromCode(code) {
        return !this.state.inType || 62 !== code && 60 !== code ? super.getTokenFromCode(code) : this.finishOp(types.relational, 1);
      }
      toAssignableList(exprList) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if (expr) switch (expr.type) {
           case "TSTypeCastExpression":
            exprList[i] = this.typeCastToParameter(expr);
            break;

           case "TSAsExpression":
           case "TSTypeAssertion":
            this.state.maybeInArrowParameters ? this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter) : exprList[i] = this.typeCastToParameter(expr);
          }
        }
        return super.toAssignableList(...arguments);
      }
      typeCastToParameter(node) {
        return node.expression.typeAnnotation = node.typeAnnotation, this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end), 
        node.expression;
      }
      toReferencedList(exprList, isInParens) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          "TSTypeCastExpression" === (null == expr ? void 0 : expr.type) && this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);
        }
        return exprList;
      }
      shouldParseArrow() {
        return this.match(types.colon) || super.shouldParseArrow();
      }
      shouldParseAsyncArrow() {
        return this.match(types.colon) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.isRelational("<")) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
          typeArguments && (node.typeParameters = typeArguments);
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method), firstParam = method.params[0];
        return firstParam && "Identifier" === firstParam.type && "this" === firstParam.name ? baseCount + 1 : baseCount;
      }
    },
    v8intrinsic: superClass => class extends superClass {
      parseV8Intrinsic() {
        if (this.match(types.modulo)) {
          const v8IntrinsicStart = this.state.start, node = this.startNode();
          if (this.eat(types.modulo), this.match(types.name)) {
            const name = this.parseIdentifierName(this.state.start), identifier = this.createIdentifier(node, name);
            if (identifier.type = "V8IntrinsicIdentifier", this.match(types.parenL)) return identifier;
          }
          this.unexpected(v8IntrinsicStart);
        }
      }
      parseExprAtom() {
        return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
      }
    },
    placeholders: superClass => class extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(types.placeholder)) {
          const node = this.startNode();
          return this.next(), this.assertNoSpace("Unexpected space in placeholder."), node.name = super.parseIdentifier(!0), 
          this.assertNoSpace("Unexpected space in placeholder."), this.expect(types.placeholder), 
          this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        const isFinished = !(!node.expectedNode || "Placeholder" !== node.type);
        return node.expectedNode = expectedNode, isFinished ? node : this.finishNode(node, "Placeholder");
      }
      getTokenFromCode(code) {
        return 37 === code && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(types.placeholder, 2) : super.getTokenFromCode(...arguments);
      }
      parseExprAtom() {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
      }
      parseIdentifier() {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
      }
      checkReservedWord(word) {
        void 0 !== word && super.checkReservedWord(...arguments);
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
      }
      checkLVal(expr) {
        "Placeholder" !== expr.type && super.checkLVal(...arguments);
      }
      toAssignable(node) {
        return node && "Placeholder" === node.type && "Expression" === node.expectedNode ? (node.expectedNode = "Pattern", 
        node) : super.toAssignable(...arguments);
      }
      verifyBreakContinue(node) {
        node.label && "Placeholder" === node.label.type || super.verifyBreakContinue(...arguments);
      }
      parseExpressionStatement(node, expr) {
        if ("Placeholder" !== expr.type || expr.extra && expr.extra.parenthesized) return super.parseExpressionStatement(...arguments);
        if (this.match(types.colon)) {
          const stmt = node;
          return stmt.label = this.finishPlaceholder(expr, "Identifier"), this.next(), stmt.body = this.parseStatement("label"), 
          this.finishNode(stmt, "LabeledStatement");
        }
        return this.semicolon(), node.name = expr.name, this.finishPlaceholder(node, "Statement");
      }
      parseBlock() {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
      }
      parseFunctionId() {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next(), this.takeDecorators(node);
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) node.id = placeholder; else {
          if (optionalId || !isStatement) return node.id = null, node.body = this.finishPlaceholder(placeholder, "ClassBody"), 
          this.finishNode(node, type);
          this.unexpected(null, "A class name is required");
        } else this.parseClassId(node, isStatement, optionalId);
        return this.parseClassSuper(node), node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass), 
        this.finishNode(node, type);
      }
      parseExport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(...arguments);
        if (!this.isContextual("from") && !this.match(types.comma)) return node.specifiers = [], 
        node.source = null, node.declaration = this.finishPlaceholder(placeholder, "Declaration"), 
        this.finishNode(node, "ExportNamedDeclaration");
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        return specifier.exported = placeholder, node.specifiers = [ this.finishNode(specifier, "ExportDefaultSpecifier") ], 
        super.parseExport(node);
      }
      isExportDefaultSpecifier() {
        if (this.match(types._default)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from") && this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) return !0;
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node) {
        return !!(node.specifiers && node.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
      }
      checkExport(node) {
        const {specifiers: specifiers} = node;
        (null == specifiers ? void 0 : specifiers.length) && (node.specifiers = specifiers.filter(node => "Placeholder" === node.exported.type)), 
        super.checkExport(node), node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(...arguments);
        if (node.specifiers = [], !this.isContextual("from") && !this.match(types.comma)) return node.source = this.finishPlaceholder(placeholder, "StringLiteral"), 
        this.semicolon(), this.finishNode(node, "ImportDeclaration");
        const specifier = this.startNodeAtNode(placeholder);
        if (specifier.local = placeholder, this.finishNode(specifier, "ImportDefaultSpecifier"), 
        node.specifiers.push(specifier), this.eat(types.comma)) {
          this.maybeParseStarImportSpecifier(node) || this.parseNamedImportSpecifiers(node);
        }
        return this.expectContextual("from"), node.source = this.parseImportSource(), this.semicolon(), 
        this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
      }
    }
  }, mixinPluginNames = Object.keys(mixinPlugins), defaultOptions = {
    sourceType: "script",
    sourceFilename: void 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1
  };
  class State {
    constructor() {
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], 
      this.inParameters = !1, this.maybeInArrowParameters = !1, this.maybeInAsyncArrowHead = !1, 
      this.inPipeline = !1, this.inType = !1, this.noAnonFunctionType = !1, this.inPropertyName = !1, 
      this.hasFlowComment = !1, this.isIterator = !1, this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], 
      this.decoratorStack = [ [] ], this.yieldPos = -1, this.awaitPos = -1, this.comments = [], 
      this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, 
      this.pos = 0, this.lineStart = 0, this.type = types.eof, this.value = null, this.start = 0, 
      this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, 
      this.lastTokEnd = 0, this.context = [ types$1.braceStatement ], this.exprAllowed = !0, 
      this.containsEsc = !1, this.octalPositions = [], this.exportedIdentifiers = [], 
      this.tokensLength = 0;
    }
    init(options) {
      this.strict = !1 !== options.strictMode && "module" === options.sourceType, this.curLine = options.startLine, 
      this.startLoc = this.endLoc = this.curPosition();
    }
    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }
    clone(skipArrays) {
      const state = new State, keys = Object.keys(this);
      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        let val = this[key];
        !skipArrays && Array.isArray(val) && (val = val.slice()), state[key] = val;
      }
      return state;
    }
  }
  var _isDigit = function(code) {
    return code >= 48 && code <= 57;
  };
  const VALID_REGEX_FLAGS = new Set([ "g", "m", "s", "i", "y", "u" ]), forbiddenNumericSeparatorSiblings = {
    decBinOct: [ 46, 66, 69, 79, 95, 98, 101, 111 ],
    hex: [ 46, 88, 95, 120 ]
  }, allowedNumericSeparatorSiblings = {
    bin: [ 48, 49 ]
  };
  allowedNumericSeparatorSiblings.oct = [ ...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55 ], 
  allowedNumericSeparatorSiblings.dec = [ ...allowedNumericSeparatorSiblings.oct, 56, 57 ], 
  allowedNumericSeparatorSiblings.hex = [ ...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102 ];
  class Token {
    constructor(state) {
      this.type = state.type, this.value = state.value, this.start = state.start, this.end = state.end, 
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }
  }
  class ExpressionErrors {
    constructor() {
      this.shorthandAssign = -1, this.doubleProto = -1;
    }
  }
  class Node {
    constructor(parser, pos, loc) {
      this.type = "", this.start = pos, this.end = 0, this.loc = new SourceLocation(loc), 
      (null == parser ? void 0 : parser.options.ranges) && (this.range = [ pos, 0 ]), 
      (null == parser ? void 0 : parser.filename) && (this.loc.filename = parser.filename);
    }
    __clone() {
      const newNode = new Node, keys = Object.keys(this);
      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        "leadingComments" !== key && "trailingComments" !== key && "innerComments" !== key && (newNode[key] = this[key]);
      }
      return newNode;
    }
  }
  const unwrapParenthesizedExpression = node => "ParenthesizedExpression" === node.type ? unwrapParenthesizedExpression(node.expression) : node;
  const loopLabel = {
    kind: "loop"
  }, switchLabel = {
    kind: "switch"
  };
  class ClassScope {
    constructor() {
      this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map;
    }
  }
  class ClassScopeHandler {
    constructor(raise) {
      this.stack = [], this.undefinedPrivateNames = new Map, this.raise = raise;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new ClassScope);
    }
    exit() {
      const oldClassScope = this.stack.pop(), current = this.current();
      for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {
        const [name, pos] = _Array$from[_i];
        current ? current.undefinedPrivateNames.has(name) || current.undefinedPrivateNames.set(name, pos) : this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }
    declarePrivateName(name, elementType, pos) {
      const classScope = this.current();
      let redefined = classScope.privateNames.has(name);
      if (3 & elementType) {
        const accessor = redefined && classScope.loneAccessors.get(name);
        if (accessor) {
          const oldStatic = 4 & accessor, newStatic = 4 & elementType;
          redefined = (3 & accessor) === (3 & elementType) || oldStatic !== newStatic, redefined || classScope.loneAccessors.delete(name);
        } else redefined || classScope.loneAccessors.set(name, elementType);
      }
      redefined && this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name), classScope.privateNames.add(name), 
      classScope.undefinedPrivateNames.delete(name);
    }
    usePrivateName(name, pos) {
      let classScope;
      for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) if (classScope = _this$stack[_i2], 
      classScope.privateNames.has(name)) return;
      classScope ? classScope.undefinedPrivateNames.set(name, pos) : this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
    }
  }
  class Parser extends class extends class extends class extends class extends class extends class extends class extends class extends class {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(name) {
      return this.plugins.has(name);
    }
    getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }
  } {
    addComment(comment) {
      this.filename && (comment.loc.filename = this.filename), this.state.trailingComments.push(comment), 
      this.state.leadingComments.push(comment);
    }
    adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (0 === this.state.leadingComments.length) return;
      let lastElement = null, i = elements.length;
      for (;null === lastElement && i > 0; ) lastElement = elements[--i];
      if (null === lastElement) return;
      for (let j = 0; j < this.state.leadingComments.length; j++) this.state.leadingComments[j].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(j, 1), 
      j--);
      const newTrailingComments = [];
      for (let i = 0; i < this.state.leadingComments.length; i++) {
        const leadingComment = this.state.leadingComments[i];
        leadingComment.end < node.end ? (newTrailingComments.push(leadingComment), takeAllComments || (this.state.leadingComments.splice(i, 1), 
        i--)) : (void 0 === node.trailingComments && (node.trailingComments = []), node.trailingComments.push(leadingComment));
      }
      takeAllComments && (this.state.leadingComments = []), newTrailingComments.length > 0 ? lastElement.trailingComments = newTrailingComments : void 0 !== lastElement.trailingComments && (lastElement.trailingComments = []);
    }
    processComment(node) {
      if ("Program" === node.type && node.body.length > 0) return;
      const stack = this.state.commentStack;
      let firstChild, lastChild, trailingComments, i, j;
      if (this.state.trailingComments.length > 0) this.state.trailingComments[0].start >= node.end ? (trailingComments = this.state.trailingComments, 
      this.state.trailingComments = []) : this.state.trailingComments.length = 0; else if (stack.length > 0) {
        const lastInStack = last(stack);
        lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end && (trailingComments = lastInStack.trailingComments, 
        delete lastInStack.trailingComments);
      }
      for (stack.length > 0 && last(stack).start >= node.start && (firstChild = stack.pop()); stack.length > 0 && last(stack).start >= node.start; ) lastChild = stack.pop();
      if (!lastChild && firstChild && (lastChild = firstChild), firstChild) switch (node.type) {
       case "ObjectExpression":
        this.adjustCommentsAfterTrailingComma(node, node.properties);
        break;

       case "ObjectPattern":
        this.adjustCommentsAfterTrailingComma(node, node.properties, !0);
        break;

       case "CallExpression":
        this.adjustCommentsAfterTrailingComma(node, node.arguments);
        break;

       case "ArrayExpression":
        this.adjustCommentsAfterTrailingComma(node, node.elements);
        break;

       case "ArrayPattern":
        this.adjustCommentsAfterTrailingComma(node, node.elements, !0);
      } else this.state.commentPreviousNode && ("ImportSpecifier" === this.state.commentPreviousNode.type && "ImportSpecifier" !== node.type || "ExportSpecifier" === this.state.commentPreviousNode.type && "ExportSpecifier" !== node.type) && this.adjustCommentsAfterTrailingComma(node, [ this.state.commentPreviousNode ]);
      if (lastChild) {
        if (lastChild.leadingComments) if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) node.leadingComments = lastChild.leadingComments, 
        delete lastChild.leadingComments; else for (i = lastChild.leadingComments.length - 2; i >= 0; --i) if (lastChild.leadingComments[i].end <= node.start) {
          node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
          break;
        }
      } else if (this.state.leadingComments.length > 0) if (last(this.state.leadingComments).end <= node.start) {
        if (this.state.commentPreviousNode) for (j = 0; j < this.state.leadingComments.length; j++) this.state.leadingComments[j].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(j, 1), 
        j--);
        this.state.leadingComments.length > 0 && (node.leadingComments = this.state.leadingComments, 
        this.state.leadingComments = []);
      } else {
        for (i = 0; i < this.state.leadingComments.length && !(this.state.leadingComments[i].end > node.start); i++) ;
        const leadingComments = this.state.leadingComments.slice(0, i);
        leadingComments.length && (node.leadingComments = leadingComments), trailingComments = this.state.leadingComments.slice(i), 
        0 === trailingComments.length && (trailingComments = null);
      }
      if (this.state.commentPreviousNode = node, trailingComments) if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) node.innerComments = trailingComments; else {
        const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);
        firstTrailingCommentIndex > 0 ? (node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex), 
        node.trailingComments = trailingComments.slice(firstTrailingCommentIndex)) : node.trailingComments = trailingComments;
      }
      stack.push(node);
    }
  } {
    getLocationForPosition(pos) {
      let loc;
      return loc = pos === this.state.start ? this.state.startLoc : pos === this.state.lastTokStart ? this.state.lastTokStartLoc : pos === this.state.end ? this.state.endLoc : pos === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(input, offset) {
        let match, line = 1, lineStart = 0;
        for (lineBreakG.lastIndex = 0; (match = lineBreakG.exec(input)) && match.index < offset; ) line++, 
        lineStart = lineBreakG.lastIndex;
        return new Position(line, offset - lineStart);
      }(this.input, pos), loc;
    }
    raise(pos, errorTemplate, ...params) {
      return this.raiseWithData(pos, void 0, errorTemplate, ...params);
    }
    raiseWithData(pos, data, errorTemplate, ...params) {
      const loc = this.getLocationForPosition(pos), message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
      return this._raise(Object.assign({
        loc: loc,
        pos: pos
      }, data), message);
    }
    _raise(errorContext, message) {
      const err = new SyntaxError(message);
      if (Object.assign(err, errorContext), this.options.errorRecovery) return this.isLookahead || this.state.errors.push(err), 
      err;
      throw err;
    }
  } {
    constructor(options, input) {
      super(), this.tokens = [], this.state = new State, this.state.init(options), this.input = input, 
      this.length = input.length, this.isLookahead = !1;
    }
    pushToken(token) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(token), ++this.state.tokensLength;
    }
    next() {
      this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state))), 
      this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, 
      this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, 
      this.nextToken();
    }
    eat(type) {
      return !!this.match(type) && (this.next(), !0);
    }
    match(type) {
      return this.state.type === type;
    }
    lookahead() {
      const old = this.state;
      this.state = old.clone(!0), this.isLookahead = !0, this.next(), this.isLookahead = !1;
      const curr = this.state;
      return this.state = old, curr;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      return pos + skipWhiteSpace.exec(this.input)[0].length;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    setStrict(strict) {
      if (this.state.strict = strict, this.match(types.num) || this.match(types.string)) {
        for (this.state.pos = this.state.start; this.state.pos < this.state.lineStart; ) this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1, 
        --this.state.curLine;
        this.nextToken();
      }
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      const curContext = this.curContext();
      if ((null == curContext ? void 0 : curContext.preserveSpace) || this.skipSpace(), 
      this.state.octalPositions = [], this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), 
      this.state.pos >= this.length) return void this.finishToken(types.eof);
      const override = null == curContext ? void 0 : curContext.override;
      override ? override(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos));
    }
    pushComment(block, text, start, end, startLoc, endLoc) {
      const comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      this.options.tokens && this.pushToken(comment), this.state.comments.push(comment), 
      this.addComment(comment);
    }
    skipBlockComment() {
      const startLoc = this.state.curPosition(), start = this.state.pos, end = this.input.indexOf("*/", this.state.pos + 2);
      if (-1 === end) throw this.raise(start, ErrorMessages.UnterminatedComment);
      let match;
      for (this.state.pos = end + 2, lineBreakG.lastIndex = start; (match = lineBreakG.exec(this.input)) && match.index < this.state.pos; ) ++this.state.curLine, 
      this.state.lineStart = match.index + match[0].length;
      this.isLookahead || this.pushComment(!0, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    }
    skipLineComment(startSkip) {
      const start = this.state.pos, startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);
      if (this.state.pos < this.length) for (;!isNewLine(ch) && ++this.state.pos < this.length; ) ch = this.input.charCodeAt(this.state.pos);
      this.isLookahead || this.pushComment(!1, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    }
    skipSpace() {
      loop: for (;this.state.pos < this.length; ) {
        const ch = this.input.charCodeAt(this.state.pos);
        switch (ch) {
         case 32:
         case 160:
         case 9:
          ++this.state.pos;
          break;

         case 13:
          10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;

         case 10:
         case 8232:
         case 8233:
          ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
          break;

         case 47:
          switch (this.input.charCodeAt(this.state.pos + 1)) {
           case 42:
            this.skipBlockComment();
            break;

           case 47:
            this.skipLineComment(2);
            break;

           default:
            break loop;
          }
          break;

         default:
          if (!isWhitespace(ch)) break loop;
          ++this.state.pos;
        }
      }
    }
    finishToken(type, val) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      const prevType = this.state.type;
      this.state.type = type, this.state.value = val, this.isLookahead || this.updateContext(prevType);
    }
    readToken_numberSign() {
      if (0 === this.state.pos && this.readToken_interpreter()) return;
      const nextPos = this.state.pos + 1, next = this.input.charCodeAt(nextPos);
      if (next >= 48 && next <= 57) throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      if (123 === next || 91 === next && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), "hash" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, 123 === next ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        123 === next ? this.finishToken(types.braceHashL) : this.finishToken(types.bracketHashL), 
        this.state.pos += 2;
      } else this.finishOp(types.hash, 1);
    }
    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      next >= 48 && next <= 57 ? this.readNumber(!0) : 46 === next && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, 
      this.finishToken(types.ellipsis)) : (++this.state.pos, this.finishToken(types.dot));
    }
    readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) return ++this.state.pos, void this.readRegexp();
      61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(types.assign, 2) : this.finishOp(types.slash, 1);
    }
    readToken_interpreter() {
      if (0 !== this.state.pos || this.length < 2) return !1;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (33 !== ch) return !1;
      const start = this.state.pos;
      for (this.state.pos += 1; !isNewLine(ch) && ++this.state.pos < this.length; ) ch = this.input.charCodeAt(this.state.pos);
      const value = this.input.slice(start + 2, this.state.pos);
      return this.finishToken(types.interpreterDirective, value), !0;
    }
    readToken_mult_modulo(code) {
      let type = 42 === code ? types.star : types.modulo, width = 1, next = this.input.charCodeAt(this.state.pos + 1);
      const exprAllowed = this.state.exprAllowed;
      42 === code && 42 === next && (width++, next = this.input.charCodeAt(this.state.pos + 2), 
      type = types.exponent), 61 !== next || exprAllowed || (width++, type = types.assign), 
      this.finishOp(type, width);
    }
    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next !== code) {
        if (124 === code) {
          if (62 === next) return void this.finishOp(types.pipeline, 2);
          if (this.hasPlugin("recordAndTuple") && 125 === next) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
            return void this.finishOp(types.braceBarR, 2);
          }
          if (this.hasPlugin("recordAndTuple") && 93 === next) {
            if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
            return void this.finishOp(types.bracketBarR, 2);
          }
        }
        61 !== next ? this.finishOp(124 === code ? types.bitwiseOR : types.bitwiseAND, 1) : this.finishOp(types.assign, 2);
      } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(types.assign, 3) : this.finishOp(124 === code ? types.logicalOR : types.logicalAND, 2);
    }
    readToken_caret() {
      61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(types.assign, 2) : this.finishOp(types.bitwiseXOR, 1);
    }
    readToken_plus_min(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (next === code) return 45 !== next || this.inModule || 62 !== this.input.charCodeAt(this.state.pos + 2) || 0 !== this.state.lastTokEnd && !lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)) ? void this.finishOp(types.incDec, 2) : (this.skipLineComment(3), 
      this.skipSpace(), void this.nextToken());
      61 === next ? this.finishOp(types.assign, 2) : this.finishOp(types.plusMin, 1);
    }
    readToken_lt_gt(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      let size = 1;
      return next === code ? (size = 62 === code && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 
      61 === this.input.charCodeAt(this.state.pos + size) ? void this.finishOp(types.assign, size + 1) : void this.finishOp(types.bitShift, size)) : 33 !== next || 60 !== code || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === next && (size = 2), 
      void this.finishOp(types.relational, size)) : (this.skipLineComment(4), this.skipSpace(), 
      void this.nextToken());
    }
    readToken_eq_excl(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      if (61 !== next) return 61 === code && 62 === next ? (this.state.pos += 2, void this.finishToken(types.arrow)) : void this.finishOp(61 === code ? types.eq : types.bang, 1);
      this.finishOp(types.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
    }
    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1), next2 = this.input.charCodeAt(this.state.pos + 2);
      63 !== next || this.state.inType ? 46 !== next || next2 >= 48 && next2 <= 57 ? (++this.state.pos, 
      this.finishToken(types.question)) : (this.state.pos += 2, this.finishToken(types.questionDot)) : 61 === next2 ? this.finishOp(types.assign, 3) : this.finishOp(types.nullishCoalescing, 2);
    }
    getTokenFromCode(code) {
      switch (code) {
       case 46:
        return void this.readToken_dot();

       case 40:
        return ++this.state.pos, void this.finishToken(types.parenL);

       case 41:
        return ++this.state.pos, void this.finishToken(types.parenR);

       case 59:
        return ++this.state.pos, void this.finishToken(types.semi);

       case 44:
        return ++this.state.pos, void this.finishToken(types.comma);

       case 91:
        if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
          if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
          this.finishToken(types.bracketBarL), this.state.pos += 2;
        } else ++this.state.pos, this.finishToken(types.bracketL);
        return;

       case 93:
        return ++this.state.pos, void this.finishToken(types.bracketR);

       case 123:
        if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
          if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
          this.finishToken(types.braceBarL), this.state.pos += 2;
        } else ++this.state.pos, this.finishToken(types.braceL);
        return;

       case 125:
        return ++this.state.pos, void this.finishToken(types.braceR);

       case 58:
        return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(types.doubleColon, 2) : (++this.state.pos, 
        this.finishToken(types.colon)));

       case 63:
        return void this.readToken_question();

       case 96:
        return ++this.state.pos, void this.finishToken(types.backQuote);

       case 48:
        {
          const next = this.input.charCodeAt(this.state.pos + 1);
          if (120 === next || 88 === next) return void this.readRadixNumber(16);
          if (111 === next || 79 === next) return void this.readRadixNumber(8);
          if (98 === next || 66 === next) return void this.readRadixNumber(2);
        }

       case 49:
       case 50:
       case 51:
       case 52:
       case 53:
       case 54:
       case 55:
       case 56:
       case 57:
        return void this.readNumber(!1);

       case 34:
       case 39:
        return void this.readString(code);

       case 47:
        return void this.readToken_slash();

       case 37:
       case 42:
        return void this.readToken_mult_modulo(code);

       case 124:
       case 38:
        return void this.readToken_pipe_amp(code);

       case 94:
        return void this.readToken_caret();

       case 43:
       case 45:
        return void this.readToken_plus_min(code);

       case 60:
       case 62:
        return void this.readToken_lt_gt(code);

       case 61:
       case 33:
        return void this.readToken_eq_excl(code);

       case 126:
        return void this.finishOp(types.tilde, 1);

       case 64:
        return ++this.state.pos, void this.finishToken(types.at);

       case 35:
        return void this.readToken_numberSign();

       case 92:
        return void this.readWord();

       default:
        if (isIdentifierStart(code)) return void this.readWord();
      }
      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    }
    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size, this.finishToken(type, str);
    }
    readRegexp() {
      const start = this.state.pos;
      let escaped, inClass;
      for (;;) {
        if (this.state.pos >= this.length) throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        const ch = this.input.charAt(this.state.pos);
        if (lineBreak.test(ch)) throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        if (escaped) escaped = !1; else {
          if ("[" === ch) inClass = !0; else if ("]" === ch && inClass) inClass = !1; else if ("/" === ch && !inClass) break;
          escaped = "\\" === ch;
        }
        ++this.state.pos;
      }
      const content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      let mods = "";
      for (;this.state.pos < this.length; ) {
        const char = this.input[this.state.pos], charCode = this.input.codePointAt(this.state.pos);
        if (VALID_REGEX_FLAGS.has(char)) mods.indexOf(char) > -1 && this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags); else {
          if (!isIdentifierChar(charCode) && 92 !== charCode) break;
          this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
        }
        ++this.state.pos, mods += char;
      }
      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods
      });
    }
    readInt(radix, len, forceLen, allowNumSeparator = !0) {
      const start = this.state.pos, forbiddenSiblings = 16 === radix ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, allowedSiblings = 16 === radix ? allowedNumericSeparatorSiblings.hex : 10 === radix ? allowedNumericSeparatorSiblings.dec : 8 === radix ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      let invalid = !1, total = 0;
      for (let i = 0, e = null == len ? 1 / 0 : len; i < e; ++i) {
        const code = this.input.charCodeAt(this.state.pos);
        let val;
        if (this.hasPlugin("numericSeparator") && 95 === code) {
          const prev = this.input.charCodeAt(this.state.pos - 1), next = this.input.charCodeAt(this.state.pos + 1);
          (-1 === allowedSiblings.indexOf(next) || forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) && this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator), 
          allowNumSeparator || this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence), 
          ++this.state.pos;
        } else {
          if (val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : _isDigit(code) ? code - 48 : 1 / 0, 
          val >= radix) if (this.options.errorRecovery && val <= 9) val = 0, this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix); else {
            if (!forceLen) break;
            val = 0, invalid = !0;
          }
          ++this.state.pos, total = total * radix + val;
        }
      }
      return this.state.pos === start || null != len && this.state.pos - start !== len || invalid ? null : total;
    }
    readRadixNumber(radix) {
      const start = this.state.pos;
      let isBigInt = !1;
      this.state.pos += 2;
      const val = this.readInt(radix);
      null == val && this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      const next = this.input.charCodeAt(this.state.pos);
      if (95 === next && this.expectPlugin("numericSeparator", this.state.pos), 110 === next && (++this.state.pos, 
      isBigInt = !0), isIdentifierStart(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      if (isBigInt) {
        const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types.bigint, str);
      } else this.finishToken(types.num, val);
    }
    readNumber(startsWithDot) {
      const start = this.state.pos;
      let isFloat = !1, isBigInt = !1, isNonOctalDecimalInt = !1;
      startsWithDot || null !== this.readInt(10) || this.raise(start, ErrorMessages.InvalidNumber);
      let octal = this.state.pos - start >= 2 && 48 === this.input.charCodeAt(start);
      octal && (this.state.strict && this.raise(start, ErrorMessages.StrictOctalLiteral), 
      /[89]/.test(this.input.slice(start, this.state.pos)) && (octal = !1, isNonOctalDecimalInt = !0));
      let next = this.input.charCodeAt(this.state.pos);
      if (46 !== next || octal || (++this.state.pos, this.readInt(10), isFloat = !0, next = this.input.charCodeAt(this.state.pos)), 
      69 !== next && 101 !== next || octal || (next = this.input.charCodeAt(++this.state.pos), 
      43 !== next && 45 !== next || ++this.state.pos, null === this.readInt(10) && this.raise(start, ErrorMessages.InvalidNumber), 
      isFloat = !0, next = this.input.charCodeAt(this.state.pos)), this.hasPlugin("numericSeparator") && (octal || isNonOctalDecimalInt)) {
        const underscorePos = this.input.slice(start, this.state.pos).indexOf("_");
        underscorePos > 0 && this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
      }
      if (95 === next && this.expectPlugin("numericSeparator", this.state.pos), 110 === next && ((isFloat || octal || isNonOctalDecimalInt) && this.raise(start, ErrorMessages.InvalidBigIntLiteral), 
      ++this.state.pos, isBigInt = !0), isIdentifierStart(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
      if (isBigInt) return void this.finishToken(types.bigint, str);
      const val = octal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    }
    readCodePoint(throwOnInvalid) {
      let code;
      if (123 === this.input.charCodeAt(this.state.pos)) {
        const codePos = ++this.state.pos;
        if (code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, !0, throwOnInvalid), 
        ++this.state.pos, null !== code && code > 1114111) {
          if (!throwOnInvalid) return null;
          this.raise(codePos, ErrorMessages.InvalidCodePoint);
        }
      } else code = this.readHexChar(4, !1, throwOnInvalid);
      return code;
    }
    readString(quote) {
      let out = "", chunkStart = ++this.state.pos;
      for (;;) {
        if (this.state.pos >= this.length) throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;
        if (92 === ch) out += this.input.slice(chunkStart, this.state.pos), out += this.readEscapedChar(!1), 
        chunkStart = this.state.pos; else if (8232 === ch || 8233 === ch) ++this.state.pos, 
        ++this.state.curLine, this.state.lineStart = this.state.pos; else {
          if (isNewLine(ch)) throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          ++this.state.pos;
        }
      }
      out += this.input.slice(chunkStart, this.state.pos++), this.finishToken(types.string, out);
    }
    readTmplToken() {
      let out = "", chunkStart = this.state.pos, containsInvalid = !1;
      for (;;) {
        if (this.state.pos >= this.length) throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        const ch = this.input.charCodeAt(this.state.pos);
        if (96 === ch || 36 === ch && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos === this.state.start && this.match(types.template) ? 36 === ch ? (this.state.pos += 2, 
        void this.finishToken(types.dollarBraceL)) : (++this.state.pos, void this.finishToken(types.backQuote)) : (out += this.input.slice(chunkStart, this.state.pos), 
        void this.finishToken(types.template, containsInvalid ? null : out));
        if (92 === ch) {
          out += this.input.slice(chunkStart, this.state.pos);
          const escaped = this.readEscapedChar(!0);
          null === escaped ? containsInvalid = !0 : out += escaped, chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          switch (out += this.input.slice(chunkStart, this.state.pos), ++this.state.pos, ch) {
           case 13:
            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;

           case 10:
            out += "\n";
            break;

           default:
            out += String.fromCharCode(ch);
          }
          ++this.state.curLine, this.state.lineStart = this.state.pos, chunkStart = this.state.pos;
        } else ++this.state.pos;
      }
    }
    readEscapedChar(inTemplate) {
      const throwOnInvalid = !inTemplate, ch = this.input.charCodeAt(++this.state.pos);
      switch (++this.state.pos, ch) {
       case 110:
        return "\n";

       case 114:
        return "\r";

       case 120:
        {
          const code = this.readHexChar(2, !1, throwOnInvalid);
          return null === code ? null : String.fromCharCode(code);
        }

       case 117:
        {
          const code = this.readCodePoint(throwOnInvalid);
          return null === code ? null : String.fromCodePoint(code);
        }

       case 116:
        return "\t";

       case 98:
        return "\b";

       case 118:
        return "\v";

       case 102:
        return "\f";

       case 13:
        10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;

       case 10:
        this.state.lineStart = this.state.pos, ++this.state.curLine;

       case 8232:
       case 8233:
        return "";

       case 56:
       case 57:
        if (inTemplate) return null;

       default:
        if (ch >= 48 && ch <= 55) {
          const codePos = this.state.pos - 1;
          let octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
          octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), 
          this.state.pos += octalStr.length - 1;
          const next = this.input.charCodeAt(this.state.pos);
          if ("0" !== octalStr || 56 === next || 57 === next) {
            if (inTemplate) return null;
            this.state.strict ? this.raise(codePos, ErrorMessages.StrictOctalLiteral) : this.state.octalPositions.push(codePos);
          }
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
      }
    }
    readHexChar(len, forceLen, throwOnInvalid) {
      const codePos = this.state.pos, n = this.readInt(16, len, forceLen, !1);
      return null === n && (throwOnInvalid ? this.raise(codePos, ErrorMessages.InvalidEscapeSequence) : this.state.pos = codePos - 1), 
      n;
    }
    readWord1() {
      let word = "";
      this.state.containsEsc = !1;
      const start = this.state.pos;
      let chunkStart = this.state.pos;
      for (;this.state.pos < this.length; ) {
        const ch = this.input.codePointAt(this.state.pos);
        if (isIdentifierChar(ch)) this.state.pos += ch <= 65535 ? 1 : 2; else if (this.state.isIterator && 64 === ch) ++this.state.pos; else {
          if (92 !== ch) break;
          {
            this.state.containsEsc = !0, word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.pos, identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (117 !== this.input.charCodeAt(++this.state.pos)) {
              this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(!0);
            null !== esc && (identifierCheck(esc) || this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier), 
            word += String.fromCodePoint(esc)), chunkStart = this.state.pos;
          }
        }
      }
      return word + this.input.slice(chunkStart, this.state.pos);
    }
    isIterator(word) {
      return "@@iterator" === word || "@@asyncIterator" === word;
    }
    readWord() {
      const word = this.readWord1(), type = keywords.get(word) || types.name;
      !this.state.isIterator || this.isIterator(word) && this.state.inType || this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word), 
      this.finishToken(type, word);
    }
    checkKeywordEscapes() {
      const kw = this.state.type.keyword;
      kw && this.state.containsEsc && this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
    }
    braceIsBlock(prevType) {
      const parent = this.curContext();
      return parent === types$1.functionExpression || parent === types$1.functionStatement || (prevType !== types.colon || parent !== types$1.braceStatement && parent !== types$1.braceExpression ? prevType === types._return || prevType === types.name && this.state.exprAllowed ? lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)) : prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow || (prevType === types.braceL ? parent === types$1.braceStatement : prevType !== types._var && prevType !== types._const && prevType !== types.name && (prevType === types.relational || !this.state.exprAllowed)) : !parent.isExpr);
    }
    updateContext(prevType) {
      const type = this.state.type;
      let update;
      !type.keyword || prevType !== types.dot && prevType !== types.questionDot ? (update = type.updateContext) ? update.call(this, prevType) : this.state.exprAllowed = type.beforeExpr : this.state.exprAllowed = !1;
    }
  } {
    addExtra(node, key, val) {
      if (!node) return;
      (node.extra = node.extra || {})[key] = val;
    }
    isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    }
    isLookaheadRelational(op) {
      const next = this.nextTokenStart();
      if (this.input.charAt(next) === op) {
        if (next + 1 === this.input.length) return !0;
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== op.charCodeAt(0) && 61 !== afterNext;
      }
      return !1;
    }
    expectRelational(op) {
      this.isRelational(op) ? this.next() : this.unexpected(null, types.relational);
    }
    isContextual(name) {
      return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
    }
    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
    }
    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }
    eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    }
    expectContextual(name, message) {
      this.eatContextual(name) || this.unexpected(null, message);
    }
    canInsertSemicolon() {
      return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }
    isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    }
    semicolon() {
      this.isLineTerminator() || this.unexpected(null, types.semi);
    }
    expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }
    assertNoSpace(message = "Unexpected space.") {
      this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, message);
    }
    unexpected(pos, messageOrType = "Unexpected token") {
      throw "string" != typeof messageOrType && (messageOrType = `Unexpected token, expected "${messageOrType.label}"`), 
      this.raise(null != pos ? pos : this.state.start, messageOrType);
    }
    expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) throw this.raiseWithData(null != pos ? pos : this.state.start, {
        missingPlugin: [ name ]
      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);
      return !0;
    }
    expectOnePlugin(names, pos) {
      if (!names.some(n => this.hasPlugin(n))) throw this.raiseWithData(null != pos ? pos : this.state.start, {
        missingPlugin: names
      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
    }
    checkYieldAwaitInDefaultParams() {
      -1 !== this.state.yieldPos && (-1 === this.state.awaitPos || this.state.yieldPos < this.state.awaitPos) && this.raise(this.state.yieldPos, ErrorMessages.YieldBindingIdentifier), 
      -1 !== this.state.awaitPos && this.raise(this.state.awaitPos, ErrorMessages.AwaitBindingIdentifier);
    }
    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };
      try {
        const node = fn((node = null) => {
          throw abortSignal.node = node, abortSignal;
        });
        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          return this.state = oldState, {
            node: node,
            error: failState.errors[oldState.errors.length],
            thrown: !1,
            aborted: !1,
            failState: failState
          };
        }
        return {
          node: node,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        if (this.state = oldState, error instanceof SyntaxError) return {
          node: null,
          error: error,
          thrown: !0,
          aborted: !1,
          failState: failState
        };
        if (error === abortSignal) return {
          node: abortSignal.node,
          error: null,
          thrown: !1,
          aborted: !0,
          failState: failState
        };
        throw error;
      }
    }
    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return !1;
      const {shorthandAssign: shorthandAssign, doubleProto: doubleProto} = refExpressionErrors;
      if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
      shorthandAssign >= 0 && this.unexpected(shorthandAssign), doubleProto >= 0 && this.raise(doubleProto, ErrorMessages.DuplicateProto);
    }
    isLiteralPropertyName() {
      return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint);
    }
  } {
    startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }
    startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }
    startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }
    finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }
    finishNodeAt(node, type, pos, loc) {
      return node.type = type, node.end = pos, node.loc.end = loc, this.options.ranges && (node.range[1] = pos), 
      this.processComment(node), node;
    }
    resetStartLocation(node, start, startLoc) {
      node.start = start, node.loc.start = startLoc, this.options.ranges && (node.range[0] = start);
    }
    resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
      node.end = end, node.loc.end = endLoc, this.options.ranges && (node.range[1] = end);
    }
    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }
  } {
    toAssignable(node) {
      var _node$extra, _node$extra3;
      let parenthesized = void 0;
      switch (("ParenthesizedExpression" === node.type || (null == (_node$extra = node.extra) ? void 0 : _node$extra.parenthesized)) && (parenthesized = unwrapParenthesizedExpression(node), 
      "Identifier" !== parenthesized.type && "MemberExpression" !== parenthesized.type && this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment)), 
      node.type) {
       case "Identifier":
       case "ObjectPattern":
       case "ArrayPattern":
       case "AssignmentPattern":
        break;

       case "ObjectExpression":
        node.type = "ObjectPattern";
        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
          var _node$extra2;
          const prop = node.properties[i], isLast = i === last;
          this.toAssignableObjectExpressionProp(prop, isLast), isLast && "RestElement" === prop.type && (null == (_node$extra2 = node.extra) ? void 0 : _node$extra2.trailingComma) && this.raiseRestNotLast(node.extra.trailingComma);
        }
        break;

       case "ObjectProperty":
        this.toAssignable(node.value);
        break;

       case "SpreadElement":
        {
          this.checkToRestConversion(node), node.type = "RestElement";
          const arg = node.argument;
          this.toAssignable(arg);
          break;
        }

       case "ArrayExpression":
        node.type = "ArrayPattern", this.toAssignableList(node.elements, null == (_node$extra3 = node.extra) ? void 0 : _node$extra3.trailingComma);
        break;

       case "AssignmentExpression":
        "=" !== node.operator && this.raise(node.left.end, ErrorMessages.MissingEqInAssignment), 
        node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left);
        break;

       case "ParenthesizedExpression":
        this.toAssignable(parenthesized);
      }
      return node;
    }
    toAssignableObjectExpressionProp(prop, isLast) {
      if ("ObjectMethod" === prop.type) {
        const error = "get" === prop.kind || "set" === prop.kind ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else "SpreadElement" !== prop.type || isLast ? this.toAssignable(prop) : this.raiseRestNotLast(prop.start);
    }
    toAssignableList(exprList, trailingCommaPos) {
      let end = exprList.length;
      if (end) {
        const last = exprList[end - 1];
        if ("RestElement" === (null == last ? void 0 : last.type)) --end; else if ("SpreadElement" === (null == last ? void 0 : last.type)) {
          last.type = "RestElement";
          const arg = last.argument;
          this.toAssignable(arg), "Identifier" !== arg.type && "MemberExpression" !== arg.type && "ArrayPattern" !== arg.type && "ObjectPattern" !== arg.type && this.unexpected(arg.start), 
          trailingCommaPos && this.raiseTrailingCommaAfterRest(trailingCommaPos), --end;
        }
      }
      for (let i = 0; i < end; i++) {
        const elt = exprList[i];
        elt && (this.toAssignable(elt), "RestElement" === elt.type && this.raiseRestNotLast(elt.start));
      }
      return exprList;
    }
    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }
    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);
      for (let _i = 0; _i < exprList.length; _i++) {
        const expr = exprList[_i];
        "ArrayExpression" === (null == expr ? void 0 : expr.type) && this.toReferencedListDeep(expr.elements);
      }
    }
    parseSpread(refExpressionErrors, refNeedsArrowPos) {
      const node = this.startNode();
      return this.next(), node.argument = this.parseMaybeAssign(!1, refExpressionErrors, void 0, refNeedsArrowPos), 
      this.finishNode(node, "SpreadElement");
    }
    parseRestBinding() {
      const node = this.startNode();
      return this.next(), node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
       case types.bracketL:
        {
          const node = this.startNode();
          return this.next(), node.elements = this.parseBindingList(types.bracketR, 93, !0), 
          this.finishNode(node, "ArrayPattern");
        }

       case types.braceL:
        return this.parseObj(types.braceR, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      const elts = [];
      let first = !0;
      for (;!this.eat(close); ) if (first ? first = !1 : this.expect(types.comma), allowEmpty && this.match(types.comma)) elts.push(null); else {
        if (this.eat(close)) break;
        if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(closeCharCode), 
          this.expect(close);
          break;
        }
        {
          const decorators = [];
          for (this.match(types.at) && this.hasPlugin("decorators") && this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator); this.match(types.at); ) decorators.push(this.parseDecorator());
          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }
      return elts;
    }
    parseAssignableListItem(allowModifiers, decorators) {
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);
      return decorators.length && (left.decorators = decorators), elt;
    }
    parseAssignableListItemTypes(param) {
      return param;
    }
    parseMaybeDefault(startPos, startLoc, left) {
      if (startLoc = startLoc || this.state.startLoc, startPos = startPos || this.state.start, 
      left = left || this.parseBindingAtom(), !this.eat(types.eq)) return left;
      const node = this.startNodeAt(startPos, startLoc);
      return node.left = left, node.right = this.parseMaybeAssign(), this.finishNode(node, "AssignmentPattern");
    }
    checkLVal(expr, bindingType = 64, checkClashes, contextDescription, disallowLetBinding, strictModeChanged = !1) {
      switch (expr.type) {
       case "Identifier":
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name)) && this.raise(expr.start, 64 === bindingType ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, expr.name), 
        checkClashes) {
          const key = "_" + expr.name;
          checkClashes[key] ? this.raise(expr.start, ErrorMessages.ParamDupe) : checkClashes[key] = !0;
        }
        disallowLetBinding && "let" === expr.name && this.raise(expr.start, ErrorMessages.LetInLexicalBinding), 
        64 & bindingType || this.scope.declareName(expr.name, bindingType, expr.start);
        break;

       case "MemberExpression":
        64 !== bindingType && this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
        break;

       case "ObjectPattern":
        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {
          let prop = _expr$properties[_i2];
          if ("ObjectProperty" === prop.type) prop = prop.value; else if ("ObjectMethod" === prop.type) continue;
          this.checkLVal(prop, bindingType, checkClashes, "object destructuring pattern", disallowLetBinding);
        }
        break;

       case "ArrayPattern":
        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {
          const elem = _expr$elements[_i3];
          elem && this.checkLVal(elem, bindingType, checkClashes, "array destructuring pattern", disallowLetBinding);
        }
        break;

       case "AssignmentPattern":
        this.checkLVal(expr.left, bindingType, checkClashes, "assignment pattern");
        break;

       case "RestElement":
        this.checkLVal(expr.argument, bindingType, checkClashes, "rest element");
        break;

       case "ParenthesizedExpression":
        this.checkLVal(expr.expression, bindingType, checkClashes, "parenthesized expression");
        break;

       default:
        this.raise(expr.start, 64 === bindingType ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
      }
    }
    checkToRestConversion(node) {
      "Identifier" !== node.argument.type && "MemberExpression" !== node.argument.type && this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
    }
    checkCommaAfterRest(close) {
      this.match(types.comma) && (this.lookaheadCharCode() === close ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
    }
    raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }
    raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    }
  } {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if ("SpreadElement" === prop.type || "ObjectMethod" === prop.type || prop.computed || prop.shorthand) return;
      const key = prop.key;
      if ("__proto__" === ("Identifier" === key.type ? key.name : key.value)) {
        if (isRecord) return void this.raise(key.start, ErrorMessages.RecordNoProto);
        protoRef.used && (refExpressionErrors ? -1 === refExpressionErrors.doubleProto && (refExpressionErrors.doubleProto = key.start) : this.raise(key.start, ErrorMessages.DuplicateProto)), 
        protoRef.used = !0;
      }
    }
    getExpression() {
      let paramFlags = 0;
      this.hasPlugin("topLevelAwait") && this.inModule && (paramFlags |= 2), this.scope.enter(1), 
      this.prodParam.enter(paramFlags), this.nextToken();
      const expr = this.parseExpression();
      return this.match(types.eof) || this.unexpected(), expr.comments = this.state.comments, 
      expr.errors = this.state.errors, expr;
    }
    parseExpression(noIn, refExpressionErrors) {
      const startPos = this.state.start, startLoc = this.state.startLoc, expr = this.parseMaybeAssign(noIn, refExpressionErrors);
      if (this.match(types.comma)) {
        const node = this.startNodeAt(startPos, startLoc);
        for (node.expressions = [ expr ]; this.eat(types.comma); ) node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));
        return this.toReferencedList(node.expressions), this.finishNode(node, "SequenceExpression");
      }
      return expr;
    }
    parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      const startPos = this.state.start, startLoc = this.state.startLoc;
      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          let left = this.parseYield(noIn);
          return afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), 
          left;
        }
        this.state.exprAllowed = !1;
      }
      let ownExpressionErrors;
      refExpressionErrors ? ownExpressionErrors = !1 : (refExpressionErrors = new ExpressionErrors, 
      ownExpressionErrors = !0), (this.match(types.parenL) || this.match(types.name)) && (this.state.potentialArrowAt = this.state.start);
      let left = this.parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos);
      if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), 
      this.state.type.isAssign) {
        const node = this.startNodeAt(startPos, startLoc), operator = this.state.value;
        return node.operator = operator, "??=" === operator && this.expectPlugin("logicalAssignment"), 
        "||=" !== operator && "&&=" !== operator || this.expectPlugin("logicalAssignment"), 
        this.match(types.eq) ? (node.left = this.toAssignable(left), refExpressionErrors.doubleProto = -1) : node.left = left, 
        refExpressionErrors.shorthandAssign >= node.left.start && (refExpressionErrors.shorthandAssign = -1), 
        this.checkLVal(left, void 0, void 0, "assignment expression"), this.next(), node.right = this.parseMaybeAssign(noIn), 
        this.finishNode(node, "AssignmentExpression");
      }
      return ownExpressionErrors && this.checkExpressionErrors(refExpressionErrors, !0), 
      left;
    }
    parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos) {
      const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprOps(noIn, refExpressionErrors);
      return "ArrowFunctionExpression" === expr.type && expr.start === potentialArrowAt || this.checkExpressionErrors(refExpressionErrors, !1) ? expr : this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
    }
    parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        const node = this.startNodeAt(startPos, startLoc);
        return node.test = expr, node.consequent = this.parseMaybeAssign(), this.expect(types.colon), 
        node.alternate = this.parseMaybeAssign(noIn), this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    }
    parseExprOps(noIn, refExpressionErrors) {
      const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseMaybeUnary(refExpressionErrors);
      return "ArrowFunctionExpression" === expr.type && expr.start === potentialArrowAt || this.checkExpressionErrors(refExpressionErrors, !1) ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
    }
    parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
      let prec = this.state.type.binop;
      if (!(null == prec || noIn && this.match(types._in)) && prec > minPrec) {
        const operator = this.state.value;
        if ("|>" === operator && this.state.inFSharpPipelineDirectBody) return left;
        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.left = left, node.operator = operator, "**" !== operator || "UnaryExpression" !== left.type || !this.options.createParenthesizedExpressions && left.extra && left.extra.parenthesized || this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
        const op = this.state.type, logical = op === types.logicalOR || op === types.logicalAND, coalesce = op === types.nullishCoalescing;
        if (op === types.pipeline ? (this.expectPlugin("pipelineOperator"), this.state.inPipeline = !0, 
        this.checkPipelineAtInfixOperator(left, leftStartPos)) : coalesce && (prec = types.logicalAND.binop), 
        this.next(), op === types.pipeline && "minimal" === this.getPluginOption("pipelineOperator", "proposal") && this.match(types.name) && "await" === this.state.value && this.prodParam.hasAwait) throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
        node.right = this.parseExprOpRightExpr(op, prec, noIn), this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
        const nextOp = this.state.type;
        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
      }
      return left;
    }
    parseExprOpRightExpr(op, prec, noIn) {
      const startPos = this.state.start, startLoc = this.state.startLoc;
      switch (op) {
       case types.pipeline:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
         case "smart":
          return this.withTopicPermittingContext(() => this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc));

         case "fsharp":
          return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(prec, noIn));
        }

       default:
        return this.parseExprOpBaseRightExpr(op, prec, noIn);
      }
    }
    parseExprOpBaseRightExpr(op, prec, noIn) {
      const startPos = this.state.start, startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);
    }
    parseMaybeUnary(refExpressionErrors) {
      if (this.isContextual("await") && this.isAwaitAllowed()) return this.parseAwait();
      if (this.state.type.prefix) {
        const node = this.startNode(), update = this.match(types.incDec);
        if (node.operator = this.state.value, node.prefix = !0, "throw" === node.operator && this.expectPlugin("throwExpressions"), 
        this.next(), node.argument = this.parseMaybeUnary(), this.checkExpressionErrors(refExpressionErrors, !0), 
        update) this.checkLVal(node.argument, void 0, void 0, "prefix operation"); else if (this.state.strict && "delete" === node.operator) {
          const arg = node.argument;
          "Identifier" === arg.type ? this.raise(node.start, ErrorMessages.StrictDelete) : "MemberExpression" !== arg.type && "OptionalMemberExpression" !== arg.type || "PrivateName" !== arg.property.type || this.raise(node.start, ErrorMessages.DeletePrivateField);
        }
        return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      }
      const startPos = this.state.start, startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, !1)) return expr;
      for (;this.state.type.postfix && !this.canInsertSemicolon(); ) {
        const node = this.startNodeAt(startPos, startLoc);
        node.operator = this.state.value, node.prefix = !1, node.argument = expr, this.checkLVal(expr, void 0, void 0, "postfix operation"), 
        this.next(), expr = this.finishNode(node, "UpdateExpression");
      }
      return expr;
    }
    parseExprSubscripts(refExpressionErrors) {
      const startPos = this.state.start, startLoc = this.state.startLoc, potentialArrowAt = this.state.potentialArrowAt, expr = this.parseExprAtom(refExpressionErrors);
      return "ArrowFunctionExpression" === expr.type && expr.start === potentialArrowAt ? expr : this.parseSubscripts(expr, startPos, startLoc);
    }
    parseSubscripts(base, startPos, startLoc, noCalls) {
      const state = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: !1
      };
      do {
        const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;
        state.maybeAsyncArrow && (this.state.maybeInAsyncArrowHead = !0), base = this.parseSubscript(base, startPos, startLoc, noCalls, state), 
        state.maybeAsyncArrow = !1, this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;
      } while (!state.stop);
      return base;
    }
    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        const node = this.startNodeAt(startPos, startLoc);
        return node.object = base, node.callee = this.parseNoCallExpr(), state.stop = !0, 
        this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
      }
      let optional = !1;
      if (this.match(types.questionDot)) {
        if (state.optionalChainMember = optional = !0, noCalls && 40 === this.lookaheadCharCode()) return state.stop = !0, 
        base;
        this.next();
      }
      const computed = this.eat(types.bracketL);
      if (optional && !this.match(types.parenL) && !this.match(types.backQuote) || computed || this.eat(types.dot)) {
        const node = this.startNodeAt(startPos, startLoc);
        return node.object = base, node.property = computed ? this.parseExpression() : this.parseMaybePrivateName(!0), 
        node.computed = computed, "PrivateName" === node.property.type && ("Super" === node.object.type && this.raise(startPos, ErrorMessages.SuperPrivateField), 
        this.classScope.usePrivateName(node.property.id.name, node.property.start)), computed && this.expect(types.bracketR), 
        state.optionalChainMember ? (node.optional = optional, this.finishNode(node, "OptionalMemberExpression")) : this.finishNode(node, "MemberExpression");
      }
      if (!noCalls && this.match(types.parenL)) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos;
        this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1, 
        this.next();
        let node = this.startNodeAt(startPos, startLoc);
        return node.callee = base, state.optionalChainMember && (node.optional = optional), 
        node.arguments = optional ? this.parseCallExpressionArguments(types.parenR, !1) : this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, "Import" === base.type, "Super" !== base.type, node), 
        this.finishCallExpression(node, state.optionalChainMember), state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional ? (state.stop = !0, 
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node), 
        this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = oldYieldPos, this.state.awaitPos = oldAwaitPos) : (this.toReferencedListDeep(node.arguments), 
        -1 !== oldYieldPos && (this.state.yieldPos = oldYieldPos), (this.isAwaitAllowed() || oldMaybeInArrowParameters) && -1 === oldAwaitPos || (this.state.awaitPos = oldAwaitPos)), 
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters, node;
      }
      return this.match(types.backQuote) ? this.parseTaggedTemplateExpression(startPos, startLoc, base, state) : (state.stop = !0, 
      base);
    }
    parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {
      const node = this.startNodeAt(startPos, startLoc);
      return node.tag = base, node.quasi = this.parseTemplate(!0), typeArguments && (node.typeParameters = typeArguments), 
      state.optionalChainMember && this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate), 
      this.finishNode(node, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(base) {
      return "Identifier" === base.type && "async" === base.name && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start == 5 && base.start === this.state.potentialArrowAt;
    }
    finishCallExpression(node, optional) {
      if ("Import" === node.callee.type) if (2 === node.arguments.length && this.expectPlugin("moduleAttributes"), 
      0 === node.arguments.length || node.arguments.length > 2) this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument"); else for (let _i = 0, _node$arguments = node.arguments; _i < _node$arguments.length; _i++) {
        const arg = _node$arguments[_i];
        "SpreadElement" === arg.type && this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
      }
      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
      const elts = [];
      let innerParenStart, first = !0;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(close); ) {
        if (first) first = !1; else if (this.expect(types.comma), this.match(close)) {
          dynamicImport && !this.hasPlugin("moduleAttributes") && this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma), 
          nodeForExtra && this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart), 
          this.next();
          break;
        }
        this.match(types.parenL) && !innerParenStart && (innerParenStart = this.state.start), 
        elts.push(this.parseExprListItem(!1, possibleAsyncArrow ? new ExpressionErrors : void 0, possibleAsyncArrow ? {
          start: 0
        } : void 0, allowPlaceholder));
      }
      return possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow() && this.unexpected(), 
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, elts;
    }
    shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;
      return this.expect(types.arrow), this.parseArrowExpression(node, call.arguments, !0, null == (_call$extra = call.extra) ? void 0 : _call$extra.trailingComma), 
      node;
    }
    parseNoCallExpr() {
      const startPos = this.state.start, startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, !0);
    }
    parseExprAtom(refExpressionErrors) {
      this.state.type === types.slash && this.readRegexp();
      const canBeArrow = this.state.potentialArrowAt === this.state.start;
      let node;
      switch (this.state.type) {
       case types._super:
        return node = this.startNode(), this.next(), !this.match(types.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(node.start, ErrorMessages.UnexpectedSuper) : this.raise(node.start, ErrorMessages.SuperNotAllowed), 
        this.match(types.parenL) || this.match(types.bracketL) || this.match(types.dot) || this.raise(node.start, ErrorMessages.UnsupportedSuper), 
        this.finishNode(node, "Super");

       case types._import:
        return node = this.startNode(), this.next(), this.match(types.dot) ? this.parseImportMetaProperty(node) : (this.match(types.parenL) || this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport), 
        this.finishNode(node, "Import"));

       case types._this:
        return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");

       case types.name:
        {
          node = this.startNode();
          const containsEsc = this.state.containsEsc, id = this.parseIdentifier();
          if (!containsEsc && "async" === id.name && this.match(types._function) && !this.canInsertSemicolon()) {
            const last = this.state.context.length - 1;
            if (this.state.context[last] !== types$1.functionStatement) throw new Error("Internal error");
            return this.state.context[last] = types$1.functionExpression, this.next(), this.parseFunction(node, void 0, !0);
          }
          if (canBeArrow && !containsEsc && "async" === id.name && this.match(types.name) && !this.canInsertSemicolon()) {
            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead, oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos;
            this.state.maybeInArrowParameters = !0, this.state.maybeInAsyncArrowHead = !0, this.state.yieldPos = -1, 
            this.state.awaitPos = -1;
            const params = [ this.parseIdentifier() ];
            return this.expect(types.arrow), this.checkYieldAwaitInDefaultParams(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, 
            this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead, this.state.yieldPos = oldYieldPos, 
            this.state.awaitPos = oldAwaitPos, this.parseArrowExpression(node, params, !0), 
            node;
          }
          return canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon() ? (this.next(), 
          this.parseArrowExpression(node, [ id ], !1), node) : id;
        }

       case types._do:
        {
          this.expectPlugin("doExpressions");
          const node = this.startNode();
          this.next();
          const oldLabels = this.state.labels;
          return this.state.labels = [], node.body = this.parseBlock(), this.state.labels = oldLabels, 
          this.finishNode(node, "DoExpression");
        }

       case types.regexp:
        {
          const value = this.state.value;
          return node = this.parseLiteral(value.value, "RegExpLiteral"), node.pattern = value.pattern, 
          node.flags = value.flags, node;
        }

       case types.num:
        return this.parseLiteral(this.state.value, "NumericLiteral");

       case types.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteral");

       case types.string:
        return this.parseLiteral(this.state.value, "StringLiteral");

       case types._null:
        return node = this.startNode(), this.next(), this.finishNode(node, "NullLiteral");

       case types._true:
       case types._false:
        return this.parseBooleanLiteral();

       case types.parenL:
        return this.parseParenAndDistinguishExpression(canBeArrow);

       case types.bracketBarL:
       case types.bracketHashL:
        {
          this.expectPlugin("recordAndTuple");
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody, close = this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR;
          return this.state.inFSharpPipelineDirectBody = !1, node = this.startNode(), this.next(), 
          node.elements = this.parseExprList(close, !1, refExpressionErrors, node), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, 
          this.finishNode(node, "TupleExpression");
        }

       case types.bracketL:
        {
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          return this.state.inFSharpPipelineDirectBody = !1, node = this.startNode(), this.next(), 
          node.elements = this.parseExprList(types.bracketR, !0, refExpressionErrors, node), 
          this.state.maybeInArrowParameters || this.toReferencedList(node.elements), this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, 
          this.finishNode(node, "ArrayExpression");
        }

       case types.braceBarL:
       case types.braceHashL:
        {
          this.expectPlugin("recordAndTuple");
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody, close = this.state.type === types.braceBarL ? types.braceBarR : types.braceR;
          this.state.inFSharpPipelineDirectBody = !1;
          const ret = this.parseObj(close, !1, !0, refExpressionErrors);
          return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
        }

       case types.braceL:
        {
          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
          this.state.inFSharpPipelineDirectBody = !1;
          const ret = this.parseObj(types.braceR, !1, !1, refExpressionErrors);
          return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
        }

       case types._function:
        return this.parseFunctionExpression();

       case types.at:
        this.parseDecorators();

       case types._class:
        return node = this.startNode(), this.takeDecorators(node), this.parseClass(node, !1);

       case types._new:
        return this.parseNew();

       case types.backQuote:
        return this.parseTemplate(!1);

       case types.doubleColon:
        {
          node = this.startNode(), this.next(), node.object = null;
          const callee = node.callee = this.parseNoCallExpr();
          if ("MemberExpression" === callee.type) return this.finishNode(node, "BindExpression");
          throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
        }

       case types.hash:
        {
          if (this.state.inPipeline) return node = this.startNode(), "smart" !== this.getPluginOption("pipelineOperator", "proposal") && this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline), 
          this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed), 
          this.registerTopicReference(), this.finishNode(node, "PipelinePrimaryTopicReference");
          const nextCh = this.input.codePointAt(this.state.end);
          if (isIdentifierStart(nextCh) || 92 === nextCh) {
            const start = this.state.start;
            if (node = this.parseMaybePrivateName(!0), this.match(types._in)) this.expectPlugin("privateIn"), 
            this.classScope.usePrivateName(node.id.name, node.start); else {
              if (!this.hasPlugin("privateIn")) throw this.unexpected(start);
              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);
            }
            return node;
          }
        }

       case types.relational:
        if ("<" === this.state.value) {
          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
          (isIdentifierStart(lookaheadCh) || 62 === lookaheadCh) && this.expectOnePlugin([ "jsx", "flow", "typescript" ]);
        }

       default:
        throw this.unexpected();
      }
    }
    parseBooleanLiteral() {
      const node = this.startNode();
      return node.value = this.match(types._true), this.next(), this.finishNode(node, "BooleanLiteral");
    }
    parseMaybePrivateName(isPrivateNameAllowed) {
      if (this.match(types.hash)) {
        this.expectOnePlugin([ "classPrivateProperties", "classPrivateMethods" ]), isPrivateNameAllowed || this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
        const node = this.startNode();
        return this.next(), this.assertNoSpace("Unexpected space between # and identifier"), 
        node.id = this.parseIdentifier(!0), this.finishNode(node, "PrivateName");
      }
      return this.parseIdentifier(!0);
    }
    parseFunctionExpression() {
      const node = this.startNode();
      let meta = this.startNode();
      return this.next(), meta = this.createIdentifier(meta, "function"), this.prodParam.hasYield && this.eat(types.dot) ? this.parseMetaProperty(node, meta, "sent") : this.parseFunction(node);
    }
    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta, "function" === meta.name && "sent" === propertyName && (this.isContextual(propertyName) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
      const containsEsc = this.state.containsEsc;
      return node.property = this.parseIdentifier(!0), (node.property.name !== propertyName || containsEsc) && this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName), 
      this.finishNode(node, "MetaProperty");
    }
    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), "import");
      return this.expect(types.dot), this.isContextual("meta") && (this.inModule || this.raiseWithData(id.start, {
        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      }, ErrorMessages.ImportMetaOutsideModule), this.sawUnambiguousESM = !0), this.parseMetaProperty(node, id, "meta");
    }
    parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start, startLoc = startLoc || this.state.startLoc;
      const node = this.startNodeAt(startPos, startLoc);
      return this.addExtra(node, "rawValue", value), this.addExtra(node, "raw", this.input.slice(startPos, this.state.end)), 
      node.value = value, this.next(), this.finishNode(node, type);
    }
    parseParenAndDistinguishExpression(canBeArrow) {
      const startPos = this.state.start, startLoc = this.state.startLoc;
      let val;
      this.expect(types.parenL);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos, oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1, 
      this.state.inFSharpPipelineDirectBody = !1;
      const innerStartPos = this.state.start, innerStartLoc = this.state.startLoc, exprList = [], refExpressionErrors = new ExpressionErrors, refNeedsArrowPos = {
        start: 0
      };
      let spreadStart, optionalCommaStart, first = !0;
      for (;!this.match(types.parenR); ) {
        if (first) first = !1; else if (this.expect(types.comma, refNeedsArrowPos.start || null), 
        this.match(types.parenR)) {
          optionalCommaStart = this.state.start;
          break;
        }
        if (this.match(types.ellipsis)) {
          const spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start, exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc)), 
          this.checkCommaAfterRest(41);
          break;
        }
        exprList.push(this.parseMaybeAssign(!1, refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
      }
      const innerEndPos = this.state.start, innerEndLoc = this.state.startLoc;
      this.expect(types.parenR), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, 
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startPos, startLoc);
      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        this.isAwaitAllowed() || this.state.maybeInAsyncArrowHead || (this.state.awaitPos = oldAwaitPos), 
        this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = oldYieldPos, this.state.awaitPos = oldAwaitPos;
        for (let _i2 = 0; _i2 < exprList.length; _i2++) {
          const param = exprList[_i2];
          param.extra && param.extra.parenthesized && this.unexpected(param.extra.parenStart);
        }
        return this.parseArrowExpression(arrowNode, exprList, !1), arrowNode;
      }
      if (-1 !== oldYieldPos && (this.state.yieldPos = oldYieldPos), -1 !== oldAwaitPos && (this.state.awaitPos = oldAwaitPos), 
      exprList.length || this.unexpected(this.state.lastTokStart), optionalCommaStart && this.unexpected(optionalCommaStart), 
      spreadStart && this.unexpected(spreadStart), this.checkExpressionErrors(refExpressionErrors, !0), 
      refNeedsArrowPos.start && this.unexpected(refNeedsArrowPos.start), this.toReferencedListDeep(exprList, !0), 
      exprList.length > 1 ? (val = this.startNodeAt(innerStartPos, innerStartLoc), val.expressions = exprList, 
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)) : val = exprList[0], 
      !this.options.createParenthesizedExpressions) return this.addExtra(val, "parenthesized", !0), 
      this.addExtra(val, "parenStart", startPos), val;
      const parenExpression = this.startNodeAt(startPos, startLoc);
      return parenExpression.expression = val, this.finishNode(parenExpression, "ParenthesizedExpression"), 
      parenExpression;
    }
    shouldParseArrow() {
      return !this.canInsertSemicolon();
    }
    parseArrow(node) {
      if (this.eat(types.arrow)) return node;
    }
    parseParenItem(node, startPos, startLoc) {
      return node;
    }
    parseNew() {
      const node = this.startNode();
      let meta = this.startNode();
      if (this.next(), meta = this.createIdentifier(meta, "new"), this.eat(types.dot)) {
        const metaProp = this.parseMetaProperty(node, meta, "target");
        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          let error = ErrorMessages.UnexpectedNewTarget;
          this.hasPlugin("classProperties") && (error += " or class properties"), this.raise(metaProp.start, error);
        }
        return metaProp;
      }
      return node.callee = this.parseNoCallExpr(), "Import" === node.callee.type ? this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression) : "OptionalMemberExpression" === node.callee.type || "OptionalCallExpression" === node.callee.type ? this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew) : this.eat(types.questionDot) && this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew), 
      this.parseNewArguments(node), this.finishNode(node, "NewExpression");
    }
    parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        const args = this.parseExprList(types.parenR);
        this.toReferencedList(args), node.arguments = args;
      } else node.arguments = [];
    }
    parseTemplateElement(isTagged) {
      const elem = this.startNode();
      return null === this.state.value && (isTagged || this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate)), 
      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      }, this.next(), elem.tail = this.match(types.backQuote), this.finishNode(elem, "TemplateElement");
    }
    parseTemplate(isTagged) {
      const node = this.startNode();
      this.next(), node.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      for (node.quasis = [ curElt ]; !curElt.tail; ) this.expect(types.dollarBraceL), 
      node.expressions.push(this.parseExpression()), this.expect(types.braceR), node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      return this.next(), this.finishNode(node, "TemplateLiteral");
    }
    parseObj(close, isPattern, isRecord, refExpressionErrors) {
      const propHash = Object.create(null);
      let first = !0;
      const node = this.startNode();
      for (node.properties = [], this.next(); !this.eat(close); ) {
        if (first) first = !1; else if (this.expect(types.comma), this.match(close)) {
          this.addExtra(node, "trailingComma", this.state.lastTokStart), this.next();
          break;
        }
        const prop = this.parseObjectMember(isPattern, refExpressionErrors);
        isPattern || this.checkProto(prop, isRecord, propHash, refExpressionErrors), isRecord && "ObjectProperty" !== prop.type && "SpreadElement" !== prop.type && this.raise(prop.start, ErrorMessages.InvalidRecordProperty), 
        prop.shorthand && this.addExtra(prop, "shorthand", !0), node.properties.push(prop);
      }
      let type = "ObjectExpression";
      return isPattern ? type = "ObjectPattern" : isRecord && (type = "RecordExpression"), 
      this.finishNode(node, type);
    }
    isAsyncProp(prop) {
      return !prop.computed && "Identifier" === prop.key.type && "async" === prop.key.name && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star)) && !this.hasPrecedingLineBreak();
    }
    parseObjectMember(isPattern, refExpressionErrors) {
      let decorators = [];
      if (this.match(types.at)) for (this.hasPlugin("decorators") && this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator); this.match(types.at); ) decorators.push(this.parseDecorator());
      const prop = this.startNode();
      let startPos, startLoc, isGenerator = !1, isAsync = !1;
      if (this.match(types.ellipsis)) return decorators.length && this.unexpected(), isPattern ? (this.next(), 
      prop.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(prop, "RestElement")) : this.parseSpread();
      decorators.length && (prop.decorators = decorators, decorators = []), prop.method = !1, 
      (isPattern || refExpressionErrors) && (startPos = this.state.start, startLoc = this.state.startLoc), 
      isPattern || (isGenerator = this.eat(types.star));
      const containsEsc = this.state.containsEsc;
      return this.parsePropertyName(prop, !1), isPattern || containsEsc || isGenerator || !this.isAsyncProp(prop) ? isAsync = !1 : (isAsync = !0, 
      isGenerator = this.eat(types.star), this.parsePropertyName(prop, !1)), this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc), 
      prop;
    }
    isGetterOrSetterMethod(prop, isPattern) {
      return !isPattern && !prop.computed && "Identifier" === prop.key.type && ("get" === prop.key.name || "set" === prop.key.name) && (this.isLiteralPropertyName() || this.match(types.bracketL));
    }
    getGetterSetterExpectedParamCount(method) {
      return "get" === method.kind ? 0 : 1;
    }
    checkGetterSetterParams(method) {
      const paramCount = this.getGetterSetterExpectedParamCount(method), start = method.start;
      method.params.length !== paramCount && ("get" === method.kind ? this.raise(start, ErrorMessages.BadGetterArity) : this.raise(start, ErrorMessages.BadSetterArity)), 
      "set" === method.kind && "RestElement" === method.params[method.params.length - 1].type && this.raise(start, ErrorMessages.BadSetterRestParameter);
    }
    parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {
      return isAsync || isGenerator || this.match(types.parenL) ? (isPattern && this.unexpected(), 
      prop.kind = "method", prop.method = !0, this.parseMethod(prop, isGenerator, isAsync, !1, !1, "ObjectMethod")) : !containsEsc && this.isGetterOrSetterMethod(prop, isPattern) ? ((isGenerator || isAsync) && this.unexpected(), 
      prop.kind = prop.key.name, this.parsePropertyName(prop, !1), this.parseMethod(prop, !1, !1, !1, !1, "ObjectMethod"), 
      this.checkGetterSetterParams(prop), prop) : void 0;
    }
    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      return prop.shorthand = !1, this.eat(types.colon) ? (prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(!1, refExpressionErrors), 
      this.finishNode(prop, "ObjectProperty")) : prop.computed || "Identifier" !== prop.key.type ? void 0 : (this.checkReservedWord(prop.key.name, prop.key.start, !0, !0), 
      isPattern ? prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone()) : this.match(types.eq) && refExpressionErrors ? (-1 === refExpressionErrors.shorthandAssign && (refExpressionErrors.shorthandAssign = this.state.start), 
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone())) : prop.value = prop.key.__clone(), 
      prop.shorthand = !0, this.finishNode(prop, "ObjectProperty"));
    }
    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {
      const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      return node || this.unexpected(), node;
    }
    parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types.bracketL)) prop.computed = !0, prop.key = this.parseMaybeAssign(), 
      this.expect(types.bracketR); else {
        const oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = !0, prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed), 
        "PrivateName" !== prop.key.type && (prop.computed = !1), this.state.inPropertyName = oldInPropertyName;
      }
      return prop.key;
    }
    initFunction(node, isAsync) {
      node.id = null, node.generator = !1, node.async = !!isAsync;
    }
    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = !1) {
      const oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos;
      this.state.yieldPos = -1, this.state.awaitPos = -1, this.initFunction(node, isAsync), 
      node.generator = !!isGenerator;
      const allowModifiers = isConstructor;
      return this.scope.enter(18 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0)), 
      this.prodParam.enter(functionFlags(isAsync, node.generator)), this.parseFunctionParams(node, allowModifiers), 
      this.parseFunctionBodyAndFinish(node, type, !0), this.prodParam.exit(), this.scope.exit(), 
      this.state.yieldPos = oldYieldPos, this.state.awaitPos = oldAwaitPos, node;
    }
    parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(6), this.prodParam.enter(functionFlags(isAsync, !1)), this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos;
      return params && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(node, params, trailingCommaPos)), 
      this.state.maybeInArrowParameters = !1, this.state.yieldPos = -1, this.state.awaitPos = -1, 
      this.parseFunctionBody(node, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = oldMaybeInArrowParameters, 
      this.state.yieldPos = oldYieldPos, this.state.awaitPos = oldAwaitPos, this.finishNode(node, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos);
    }
    parseFunctionBodyAndFinish(node, type, isMethod = !1) {
      this.parseFunctionBody(node, !1, isMethod), this.finishNode(node, type);
    }
    parseFunctionBody(node, allowExpression, isMethod = !1) {
      const isExpression = allowExpression && !this.match(types.braceL), oldInParameters = this.state.inParameters;
      if (this.state.inParameters = !1, isExpression) node.body = this.parseMaybeAssign(), 
      this.checkParams(node, !1, allowExpression, !1); else {
        const oldStrict = this.state.strict, oldLabels = this.state.labels;
        this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), 
        node.body = this.parseBlock(!0, !1, hasStrictModeDirective => {
          const nonSimple = !this.isSimpleParamList(node.params);
          if (hasStrictModeDirective && nonSimple) {
            const errorPos = "method" !== node.kind && "constructor" !== node.kind || !node.key ? node.start : node.key.end;
            this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }
          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node, !(this.state.strict || allowExpression || isMethod || nonSimple), allowExpression, strictModeChanged), 
          this.state.strict && node.id && this.checkLVal(node.id, 65, void 0, "function name", void 0, strictModeChanged);
        }), this.prodParam.exit(), this.state.labels = oldLabels;
      }
      this.state.inParameters = oldInParameters;
    }
    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++) if ("Identifier" !== params[i].type) return !1;
      return !0;
    }
    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = !0) {
      const nameHash = Object.create(null);
      for (let i = 0; i < node.params.length; i++) this.checkLVal(node.params[i], 5, allowDuplicates ? null : nameHash, "function parameter list", void 0, strictModeChanged);
    }
    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = !0;
      for (;!this.eat(close); ) {
        if (first) first = !1; else if (this.expect(types.comma), this.match(close)) {
          nodeForExtra && this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart), 
          this.next();
          break;
        }
        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }
      return elts;
    }
    parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
      let elt;
      if (this.match(types.comma)) allowEmpty || this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ","), 
      elt = null; else if (this.match(types.ellipsis)) {
        const spreadNodeStartPos = this.state.start, spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types.question)) {
        this.expectPlugin("partialApplication"), allowPlaceholder || this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        const node = this.startNode();
        this.next(), elt = this.finishNode(node, "ArgumentPlaceholder");
      } else elt = this.parseMaybeAssign(!1, refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
      return elt;
    }
    parseIdentifier(liberal) {
      const node = this.startNode(), name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }
    createIdentifier(node, name) {
      return node.name = name, node.loc.identifierName = name, this.finishNode(node, "Identifier");
    }
    parseIdentifierName(pos, liberal) {
      let name;
      if (this.match(types.name)) name = this.state.value; else {
        if (!this.state.type.keyword) throw this.unexpected();
        {
          name = this.state.type.keyword;
          const context = this.state.context;
          "class" !== name && "function" !== name || "function" !== context[context.length - 1].token || context.pop();
        }
      }
      return liberal ? this.state.type = types.name : this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, !1), 
      this.next(), name;
    }
    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.prodParam.hasYield && "yield" === word) return void this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
      if ("await" === word) {
        if (this.prodParam.hasAwait) return void this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
        -1 === this.state.awaitPos && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed()) && (this.state.awaitPos = this.state.start);
      }
      if (this.scope.inClass && !this.scope.inNonArrowFunction && "arguments" === word) return void this.raise(startLoc, ErrorMessages.ArgumentsDisallowedInInitializer);
      if (checkKeywords && function(word) {
        return keywords$1.has(word);
      }(word)) return void this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
      (this.state.strict ? isBinding ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(word, this.inModule) && (this.prodParam.hasAwait || "await" !== word ? this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word) : this.raise(startLoc, ErrorMessages.AwaitNotInAsyncFunction));
    }
    isAwaitAllowed() {
      return this.scope.inFunction ? this.prodParam.hasAwait : !!this.options.allowAwaitOutsideFunction || !!this.hasPlugin("topLevelAwait") && (this.inModule && this.prodParam.hasAwait);
    }
    parseAwait() {
      const node = this.startNode();
      return this.next(), this.state.inParameters ? this.raise(node.start, ErrorMessages.AwaitExpressionFormalParameter) : -1 === this.state.awaitPos && (this.state.awaitPos = node.start), 
      this.eat(types.star) && this.raise(node.start, ErrorMessages.ObsoleteAwaitStar), 
      this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo) ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), 
      this.state.soloAwait || (node.argument = this.parseMaybeUnary()), this.finishNode(node, "AwaitExpression");
    }
    parseYield(noIn) {
      const node = this.startNode();
      return this.state.inParameters ? this.raise(node.start, ErrorMessages.YieldInParameter) : -1 === this.state.yieldPos && (this.state.yieldPos = node.start), 
      this.next(), this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (node.delegate = !1, 
      node.argument = null) : (node.delegate = this.eat(types.star), node.argument = this.parseMaybeAssign(noIn)), 
      this.finishNode(node, "YieldExpression");
    }
    checkPipelineAtInfixOperator(left, leftStartPos) {
      "smart" === this.getPluginOption("pipelineOperator", "proposal") && "SequenceExpression" === left.type && this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
    }
    parseSmartPipelineBody(childExpression, startPos, startLoc) {
      const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);
      return this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos), 
      this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);
    }
    checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {
      if (this.match(types.arrow)) throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      "PipelineTopicExpression" === pipelineStyle && "SequenceExpression" === childExpression.type && this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
    }
    parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {
      const bodyNode = this.startNodeAt(startPos, startLoc);
      switch (pipelineStyle) {
       case "PipelineBareFunction":
        bodyNode.callee = childExpression;
        break;

       case "PipelineBareConstructor":
        bodyNode.callee = childExpression.callee;
        break;

       case "PipelineBareAwaitedFunction":
        bodyNode.callee = childExpression.argument;
        break;

       case "PipelineTopicExpression":
        this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(startPos, ErrorMessages.PipelineTopicUnused), 
        bodyNode.expression = childExpression;
        break;

       default:
        throw new Error(`Internal @babel/parser error: Unknown pipeline style (${pipelineStyle})`);
      }
      return this.finishNode(bodyNode, pipelineStyle);
    }
    checkSmartPipelineBodyStyle(expression) {
      return expression.type, this.isSimpleReference(expression) ? "PipelineBareFunction" : "PipelineTopicExpression";
    }
    isSimpleReference(expression) {
      switch (expression.type) {
       case "MemberExpression":
        return !expression.computed && this.isSimpleReference(expression.object);

       case "Identifier":
        return !0;

       default:
        return !1;
      }
    }
    withTopicPermittingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withTopicForbiddingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }
    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentTopicContext() {
      return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(prec, noIn) {
      const startPos = this.state.start, startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
      return this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody, ret;
    }
  } {
    parseTopLevel(file, program) {
      if (program.sourceType = this.options.sourceType, program.interpreter = this.parseInterpreterDirective(), 
      this.parseBlockBody(program, !0, !0, types.eof), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {
        const [name] = _Array$from[_i], pos = this.scope.undefinedExports.get(name);
        this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
      }
      return file.program = this.finishNode(program, "Program"), file.comments = this.state.comments, 
      this.options.tokens && (file.tokens = this.tokens), this.finishNode(file, "File");
    }
    stmtToDirective(stmt) {
      const expr = stmt.expression, directiveLiteral = this.startNodeAt(expr.start, expr.loc.start), directive = this.startNodeAt(stmt.start, stmt.loc.start), raw = this.input.slice(expr.start, expr.end), val = directiveLiteral.value = raw.slice(1, -1);
      return this.addExtra(directiveLiteral, "raw", raw), this.addExtra(directiveLiteral, "rawValue", val), 
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end), 
      this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    }
    parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) return null;
      const node = this.startNode();
      return node.value = this.state.value, this.next(), this.finishNode(node, "InterpreterDirective");
    }
    isLet(context) {
      if (!this.isContextual("let")) return !1;
      const next = this.nextTokenStart(), nextCh = this.input.charCodeAt(next);
      if (91 === nextCh) return !0;
      if (context) return !1;
      if (123 === nextCh) return !0;
      if (isIdentifierStart(nextCh)) {
        let pos = next + 1;
        for (;isIdentifierChar(this.input.charCodeAt(pos)); ) ++pos;
        const ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return !0;
      }
      return !1;
    }
    parseStatement(context, topLevel) {
      return this.match(types.at) && this.parseDecorators(!0), this.parseStatementContent(context, topLevel);
    }
    parseStatementContent(context, topLevel) {
      let starttype = this.state.type;
      const node = this.startNode();
      let kind;
      switch (this.isLet(context) && (starttype = types._var, kind = "let"), starttype) {
       case types._break:
       case types._continue:
        return this.parseBreakContinueStatement(node, starttype.keyword);

       case types._debugger:
        return this.parseDebuggerStatement(node);

       case types._do:
        return this.parseDoStatement(node);

       case types._for:
        return this.parseForStatement(node);

       case types._function:
        if (46 === this.lookaheadCharCode()) break;
        return context && (this.state.strict ? this.raise(this.state.start, ErrorMessages.StrictFunction) : "if" !== context && "label" !== context && this.raise(this.state.start, ErrorMessages.SloppyFunction)), 
        this.parseFunctionStatement(node, !1, !context);

       case types._class:
        return context && this.unexpected(), this.parseClass(node, !0);

       case types._if:
        return this.parseIfStatement(node);

       case types._return:
        return this.parseReturnStatement(node);

       case types._switch:
        return this.parseSwitchStatement(node);

       case types._throw:
        return this.parseThrowStatement(node);

       case types._try:
        return this.parseTryStatement(node);

       case types._const:
       case types._var:
        return kind = kind || this.state.value, context && "var" !== kind && this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration), 
        this.parseVarStatement(node, kind);

       case types._while:
        return this.parseWhileStatement(node);

       case types._with:
        return this.parseWithStatement(node);

       case types.braceL:
        return this.parseBlock();

       case types.semi:
        return this.parseEmptyStatement(node);

       case types._export:
       case types._import:
        {
          const nextTokenCharCode = this.lookaheadCharCode();
          if (40 === nextTokenCharCode || 46 === nextTokenCharCode) break;
          let result;
          return this.options.allowImportExportEverywhere || topLevel || this.raise(this.state.start, ErrorMessages.UnexpectedImportExport), 
          this.next(), starttype === types._import ? (result = this.parseImport(node), "ImportDeclaration" !== result.type || result.importKind && "value" !== result.importKind || (this.sawUnambiguousESM = !0)) : (result = this.parseExport(node), 
          ("ExportNamedDeclaration" !== result.type || result.exportKind && "value" !== result.exportKind) && ("ExportAllDeclaration" !== result.type || result.exportKind && "value" !== result.exportKind) && "ExportDefaultDeclaration" !== result.type || (this.sawUnambiguousESM = !0)), 
          this.assertModuleNodeAllowed(node), result;
        }

       default:
        if (this.isAsyncFunction()) return context && this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext), 
        this.next(), this.parseFunctionStatement(node, !0, !context);
      }
      const maybeName = this.state.value, expr = this.parseExpression();
      return starttype === types.name && "Identifier" === expr.type && this.eat(types.colon) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
    }
    assertModuleNodeAllowed(node) {
      this.options.allowImportExportEverywhere || this.inModule || this.raiseWithData(node.start, {
        code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
      }, ErrorMessages.ImportOutsideModule);
    }
    takeDecorators(node) {
      const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      decorators.length && (node.decorators = decorators, this.resetStartLocationFromNode(node, decorators[0]), 
      this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
    }
    canHaveLeadingDecorator() {
      return this.match(types._class);
    }
    parseDecorators(allowExport) {
      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];
      for (;this.match(types.at); ) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }
      if (this.match(types._export)) allowExport || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, ErrorMessages.DecoratorExportClass); else if (!this.canHaveLeadingDecorator()) throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
    }
    parseDecorator() {
      this.expectOnePlugin([ "decorators-legacy", "decorators" ]);
      const node = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const startPos = this.state.start, startLoc = this.state.startLoc;
        let expr;
        if (this.eat(types.parenL)) expr = this.parseExpression(), this.expect(types.parenR); else for (expr = this.parseIdentifier(!1); this.eat(types.dot); ) {
          const node = this.startNodeAt(startPos, startLoc);
          node.object = expr, node.property = this.parseIdentifier(!0), node.computed = !1, 
          expr = this.finishNode(node, "MemberExpression");
        }
        node.expression = this.parseMaybeDecoratorArguments(expr), this.state.decoratorStack.pop();
      } else node.expression = this.parseExprSubscripts();
      return this.finishNode(node, "Decorator");
    }
    parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        const node = this.startNodeAtNode(expr);
        return node.callee = expr, node.arguments = this.parseCallExpressionArguments(types.parenR, !1), 
        this.toReferencedList(node.arguments), this.finishNode(node, "CallExpression");
      }
      return expr;
    }
    parseBreakContinueStatement(node, keyword) {
      const isBreak = "break" === keyword;
      return this.next(), this.isLineTerminator() ? node.label = null : (node.label = this.parseIdentifier(), 
      this.semicolon()), this.verifyBreakContinue(node, keyword), this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(node, keyword) {
      const isBreak = "break" === keyword;
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];
        if (null == node.label || lab.name === node.label.name) {
          if (null != lab.kind && (isBreak || "loop" === lab.kind)) break;
          if (node.label && isBreak) break;
        }
      }
      i === this.state.labels.length && this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
    }
    parseDebuggerStatement(node) {
      return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(types.parenL);
      const val = this.parseExpression();
      return this.expect(types.parenR), val;
    }
    parseDoStatement(node) {
      return this.next(), this.state.labels.push(loopLabel), node.body = this.withTopicForbiddingContext(() => this.parseStatement("do")), 
      this.state.labels.pop(), this.expect(types._while), node.test = this.parseHeaderExpression(), 
      this.eat(types.semi), this.finishNode(node, "DoWhileStatement");
    }
    parseForStatement(node) {
      this.next(), this.state.labels.push(loopLabel);
      let awaitAt = -1;
      if (this.isAwaitAllowed() && this.eatContextual("await") && (awaitAt = this.state.lastTokStart), 
      this.scope.enter(0), this.expect(types.parenL), this.match(types.semi)) return awaitAt > -1 && this.unexpected(awaitAt), 
      this.parseFor(node, null);
      const isLet = this.isLet();
      if (this.match(types._var) || this.match(types._const) || isLet) {
        const init = this.startNode(), kind = isLet ? "let" : this.state.value;
        return this.next(), this.parseVar(init, !0, kind), this.finishNode(init, "VariableDeclaration"), 
        (this.match(types._in) || this.isContextual("of")) && 1 === init.declarations.length ? this.parseForIn(node, init, awaitAt) : (awaitAt > -1 && this.unexpected(awaitAt), 
        this.parseFor(node, init));
      }
      const refExpressionErrors = new ExpressionErrors, init = this.parseExpression(!0, refExpressionErrors);
      if (this.match(types._in) || this.isContextual("of")) {
        this.toAssignable(init);
        const description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        return this.checkLVal(init, void 0, void 0, description), this.parseForIn(node, init, awaitAt);
      }
      return this.checkExpressionErrors(refExpressionErrors, !0), awaitAt > -1 && this.unexpected(awaitAt), 
      this.parseFor(node, init);
    }
    parseFunctionStatement(node, isAsync, declarationPosition) {
      return this.next(), this.parseFunction(node, 1 | (declarationPosition ? 0 : 2), isAsync);
    }
    parseIfStatement(node) {
      return this.next(), node.test = this.parseHeaderExpression(), node.consequent = this.parseStatement("if"), 
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
    }
    parseReturnStatement(node) {
      return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, ErrorMessages.IllegalReturn), 
      this.next(), this.isLineTerminator() ? node.argument = null : (node.argument = this.parseExpression(), 
      this.semicolon()), this.finishNode(node, "ReturnStatement");
    }
    parseSwitchStatement(node) {
      this.next(), node.discriminant = this.parseHeaderExpression();
      const cases = node.cases = [];
      let cur, sawDefault;
      for (this.expect(types.braceL), this.state.labels.push(switchLabel), this.scope.enter(0); !this.match(types.braceR); ) if (this.match(types._case) || this.match(types._default)) {
        const isCase = this.match(types._case);
        cur && this.finishNode(cur, "SwitchCase"), cases.push(cur = this.startNode()), cur.consequent = [], 
        this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch), 
        sawDefault = !0, cur.test = null), this.expect(types.colon);
      } else cur ? cur.consequent.push(this.parseStatement(null)) : this.unexpected();
      return this.scope.exit(), cur && this.finishNode(cur, "SwitchCase"), this.next(), 
      this.state.labels.pop(), this.finishNode(node, "SwitchStatement");
    }
    parseThrowStatement(node) {
      return this.next(), lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start)) && this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow), 
      node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
    }
    parseTryStatement(node) {
      if (this.next(), node.block = this.parseBlock(), node.handler = null, this.match(types._catch)) {
        const clause = this.startNode();
        if (this.next(), this.match(types.parenL)) {
          this.expect(types.parenL), clause.param = this.parseBindingAtom();
          const simple = "Identifier" === clause.param.type;
          this.scope.enter(simple ? 8 : 0), this.checkLVal(clause.param, 9, null, "catch clause"), 
          this.expect(types.parenR);
        } else clause.param = null, this.scope.enter(0);
        clause.body = this.withTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), 
        node.handler = this.finishNode(clause, "CatchClause");
      }
      return node.finalizer = this.eat(types._finally) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(node.start, ErrorMessages.NoCatchOrFinally), 
      this.finishNode(node, "TryStatement");
    }
    parseVarStatement(node, kind) {
      return this.next(), this.parseVar(node, !1, kind), this.semicolon(), this.finishNode(node, "VariableDeclaration");
    }
    parseWhileStatement(node) {
      return this.next(), node.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), 
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("while")), 
      this.state.labels.pop(), this.finishNode(node, "WhileStatement");
    }
    parseWithStatement(node) {
      return this.state.strict && this.raise(this.state.start, ErrorMessages.StrictWith), 
      this.next(), node.object = this.parseHeaderExpression(), node.body = this.withTopicForbiddingContext(() => this.parseStatement("with")), 
      this.finishNode(node, "WithStatement");
    }
    parseEmptyStatement(node) {
      return this.next(), this.finishNode(node, "EmptyStatement");
    }
    parseLabeledStatement(node, maybeName, expr, context) {
      for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {
        _this$state$labels[_i2].name === maybeName && this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
      }
      const kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;
      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];
        if (label.statementStart !== node.start) break;
        label.statementStart = this.state.start, label.kind = kind;
      }
      return this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      }), node.body = this.parseStatement(context ? -1 === context.indexOf("label") ? context + "label" : context : "label"), 
      this.state.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
    }
    parseExpressionStatement(node, expr) {
      return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
    }
    parseBlock(allowDirectives = !1, createNewLexicalScope = !0, afterBlockParse) {
      const node = this.startNode();
      return this.expect(types.braceL), createNewLexicalScope && this.scope.enter(0), 
      this.parseBlockBody(node, allowDirectives, !1, types.braceR, afterBlockParse), createNewLexicalScope && this.scope.exit(), 
      this.finishNode(node, "BlockStatement");
    }
    isValidDirective(stmt) {
      return "ExpressionStatement" === stmt.type && "StringLiteral" === stmt.expression.type && !stmt.expression.extra.parenthesized;
    }
    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node.body = [], directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
    }
    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const octalPositions = [], oldStrict = this.state.strict;
      let hasStrictModeDirective = !1, parsedNonDirective = !1;
      for (;!this.match(end); ) {
        !parsedNonDirective && this.state.octalPositions.length && octalPositions.push(...this.state.octalPositions);
        const stmt = this.parseStatement(null, topLevel);
        if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {
          const directive = this.stmtToDirective(stmt);
          directives.push(directive), hasStrictModeDirective || "use strict" !== directive.value.value || (hasStrictModeDirective = !0, 
          this.setStrict(!0));
        } else parsedNonDirective = !0, body.push(stmt);
      }
      if (this.state.strict && octalPositions.length) for (let _i3 = 0; _i3 < octalPositions.length; _i3++) {
        const pos = octalPositions[_i3];
        this.raise(pos, ErrorMessages.StrictOctalLiteral);
      }
      afterBlockParse && afterBlockParse.call(this, hasStrictModeDirective), oldStrict || this.setStrict(!1), 
      this.next();
    }
    parseFor(node, init) {
      return node.init = init, this.expect(types.semi), node.test = this.match(types.semi) ? null : this.parseExpression(), 
      this.expect(types.semi), node.update = this.match(types.parenR) ? null : this.parseExpression(), 
      this.expect(types.parenR), node.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), 
      this.scope.exit(), this.state.labels.pop(), this.finishNode(node, "ForStatement");
    }
    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(types._in);
      return this.next(), isForIn ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1, 
      "VariableDeclaration" !== init.type || null == init.declarations[0].init || isForIn && !this.state.strict && "var" === init.kind && "Identifier" === init.declarations[0].id.type ? "AssignmentPattern" === init.type && this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop") : this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of"), 
      node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign(), 
      this.expect(types.parenR), node.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), 
      this.scope.exit(), this.state.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(node, isFor, kind) {
      const declarations = node.declarations = [], isTypescript = this.hasPlugin("typescript");
      for (node.kind = kind; ;) {
        const decl = this.startNode();
        if (this.parseVarId(decl, kind), this.eat(types.eq) ? decl.init = this.parseMaybeAssign(isFor) : ("const" !== kind || this.match(types._in) || this.isContextual("of") ? "Identifier" === decl.id.type || isFor && (this.match(types._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns") : isTypescript || this.unexpected(), 
        decl.init = null), declarations.push(this.finishNode(decl, "VariableDeclarator")), 
        !this.eat(types.comma)) break;
      }
      return node;
    }
    parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom(), this.checkLVal(decl.id, "var" === kind ? 5 : 9, void 0, "variable declaration", "var" !== kind);
    }
    parseFunction(node, statement = 0, isAsync = !1) {
      const isStatement = 1 & statement, isHangingStatement = 2 & statement, requireId = !(!isStatement || 4 & statement);
      this.initFunction(node, isAsync), this.match(types.star) && isHangingStatement && this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext), 
      node.generator = this.eat(types.star), isStatement && (node.id = this.parseFunctionId(requireId));
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters, oldYieldPos = this.state.yieldPos, oldAwaitPos = this.state.awaitPos;
      return this.state.maybeInArrowParameters = !1, this.state.yieldPos = -1, this.state.awaitPos = -1, 
      this.scope.enter(2), this.prodParam.enter(functionFlags(isAsync, node.generator)), 
      isStatement || (node.id = this.parseFunctionId()), this.parseFunctionParams(node), 
      this.withTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), isStatement && !isHangingStatement && this.registerFunctionStatementId(node), 
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters, this.state.yieldPos = oldYieldPos, 
      this.state.awaitPos = oldAwaitPos, node;
    }
    parseFunctionId(requireId) {
      return requireId || this.match(types.name) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(node, allowModifiers) {
      const oldInParameters = this.state.inParameters;
      this.state.inParameters = !0, this.expect(types.parenL), node.params = this.parseBindingList(types.parenR, 41, !1, allowModifiers), 
      this.state.inParameters = oldInParameters, this.checkYieldAwaitInDefaultParams();
    }
    registerFunctionStatementId(node) {
      node.id && this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, node.id.start);
    }
    parseClass(node, isStatement, optionalId) {
      this.next(), this.takeDecorators(node);
      const oldStrict = this.state.strict;
      return this.state.strict = !0, this.parseClassId(node, isStatement, optionalId), 
      this.parseClassSuper(node), node.body = this.parseClassBody(!!node.superClass, oldStrict), 
      this.state.strict = oldStrict, this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    }
    isClassMethod() {
      return this.match(types.parenL);
    }
    isNonstaticConstructor(method) {
      return !(method.computed || method.static || "constructor" !== method.key.name && "constructor" !== method.key.value);
    }
    parseClassBody(constructorAllowsSuper, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: !1
      };
      let decorators = [];
      const classBody = this.startNode();
      if (classBody.body = [], this.expect(types.braceL), this.withTopicForbiddingContext(() => {
        for (;!this.match(types.braceR); ) {
          if (this.eat(types.semi)) {
            if (decorators.length > 0) throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            continue;
          }
          if (this.match(types.at)) {
            decorators.push(this.parseDecorator());
            continue;
          }
          const member = this.startNode();
          decorators.length && (member.decorators = decorators, this.resetStartLocationFromNode(member, decorators[0]), 
          decorators = []), this.parseClassMember(classBody, member, state, constructorAllowsSuper), 
          "constructor" === member.kind && member.decorators && member.decorators.length > 0 && this.raise(member.start, ErrorMessages.DecoratorConstructor);
        }
      }), oldStrict || (this.state.strict = !1), this.next(), decorators.length) throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      return this.classScope.exit(), this.finishNode(classBody, "ClassBody");
    }
    parseClassMemberFromModifier(classBody, member) {
      const containsEsc = this.state.containsEsc, key = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        const method = member;
        return method.kind = "method", method.computed = !1, method.key = key, method.static = !1, 
        this.pushClassMethod(classBody, method, !1, !1, !1, !1), !0;
      }
      if (this.isClassProperty()) {
        const prop = member;
        return prop.computed = !1, prop.key = key, prop.static = !1, classBody.body.push(this.parseClassProperty(prop)), 
        !0;
      }
      if (containsEsc) throw this.unexpected();
      return !1;
    }
    parseClassMember(classBody, member, state, constructorAllowsSuper) {
      const isStatic = this.isContextual("static");
      isStatic && this.parseClassMemberFromModifier(classBody, member) || this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);
    }
    parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {
      const publicMethod = member, privateMethod = member, publicProp = member, privateProp = member, method = publicMethod, publicMember = publicMethod;
      if (member.static = isStatic, this.eat(types.star)) return method.kind = "method", 
      this.parseClassPropertyName(method), "PrivateName" === method.key.type ? void this.pushClassPrivateMethod(classBody, privateMethod, !0, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator), 
      void this.pushClassMethod(classBody, publicMethod, !0, !1, !1, !1));
      const containsEsc = this.state.containsEsc, key = this.parseClassPropertyName(member), isPrivate = "PrivateName" === key.type, isSimple = "Identifier" === key.type, maybeQuestionTokenStart = this.state.start;
      if (this.parsePostMemberNameModifiers(publicMember), this.isClassMethod()) {
        if (method.kind = "method", isPrivate) return void this.pushClassPrivateMethod(classBody, privateMethod, !1, !1);
        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = !1;
        isConstructor && (publicMethod.kind = "constructor", state.hadConstructor && !this.hasPlugin("typescript") && this.raise(key.start, ErrorMessages.DuplicateConstructor), 
        state.hadConstructor = !0, allowsDirectSuper = constructorAllowsSuper), this.pushClassMethod(classBody, publicMethod, !1, !1, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp); else if (!isSimple || "async" !== key.name || containsEsc || this.isLineTerminator()) !isSimple || "get" !== key.name && "set" !== key.name || containsEsc || this.match(types.star) && this.isLineTerminator() ? this.isLineTerminator() ? isPrivate ? this.pushClassPrivateProperty(classBody, privateProp) : this.pushClassProperty(classBody, publicProp) : this.unexpected() : (method.kind = key.name, 
      this.parseClassPropertyName(publicMethod), "PrivateName" === method.key.type ? this.pushClassPrivateMethod(classBody, privateMethod, !1, !1) : (this.isNonstaticConstructor(publicMethod) && this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor), 
      this.pushClassMethod(classBody, publicMethod, !1, !1, !1, !1)), this.checkGetterSetterParams(publicMethod)); else {
        const isGenerator = this.eat(types.star);
        publicMember.optional && this.unexpected(maybeQuestionTokenStart), method.kind = "method", 
        this.parseClassPropertyName(method), this.parsePostMemberNameModifiers(publicMember), 
        "PrivateName" === method.key.type ? this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, !0) : (this.isNonstaticConstructor(publicMethod) && this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync), 
        this.pushClassMethod(classBody, publicMethod, isGenerator, !0, !1, !1));
      }
    }
    parseClassPropertyName(member) {
      const key = this.parsePropertyName(member, !0);
      return member.computed || !member.static || "prototype" !== key.name && "prototype" !== key.value || this.raise(key.start, ErrorMessages.StaticPrototype), 
      "PrivateName" === key.type && "constructor" === key.id.name && this.raise(key.start, ErrorMessages.ConstructorClassPrivateField), 
      key;
    }
    pushClassProperty(classBody, prop) {
      prop.computed || "constructor" !== prop.key.name && "constructor" !== prop.key.value || this.raise(prop.key.start, ErrorMessages.ConstructorClassField), 
      classBody.body.push(this.parseClassProperty(prop));
    }
    pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin("classPrivateProperties", prop.key.start);
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node), this.classScope.declarePrivateName(node.key.id.name, 0, node.key.start);
    }
    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", !0));
    }
    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin("classPrivateMethods", method.key.start);
      const node = this.parseMethod(method, isGenerator, isAsync, !1, !1, "ClassPrivateMethod", !0);
      classBody.body.push(node);
      const kind = "get" === node.kind ? node.static ? 6 : 2 : "set" === node.kind ? node.static ? 5 : 1 : 0;
      this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);
    }
    parsePostMemberNameModifiers(methodOrProp) {}
    parseAccessModifier() {}
    parseClassPrivateProperty(node) {
      return this.scope.enter(80), this.prodParam.enter(0), node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null, 
      this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(node, "ClassPrivateProperty");
    }
    parseClassProperty(node) {
      return node.typeAnnotation || this.expectPlugin("classProperties"), this.scope.enter(80), 
      this.prodParam.enter(0), this.match(types.eq) ? (this.expectPlugin("classProperties"), 
      this.next(), node.value = this.parseMaybeAssign()) : node.value = null, this.semicolon(), 
      this.prodParam.exit(), this.scope.exit(), this.finishNode(node, "ClassProperty");
    }
    parseClassId(node, isStatement, optionalId, bindingType = 139) {
      this.match(types.name) ? (node.id = this.parseIdentifier(), isStatement && this.checkLVal(node.id, bindingType, void 0, "class name")) : optionalId || !isStatement ? node.id = null : this.unexpected(null, ErrorMessages.MissingClassName);
    }
    parseClassSuper(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    }
    parseExport(node) {
      const hasDefault = this.maybeParseExportDefaultSpecifier(node), parseAfterDefault = !hasDefault || this.eat(types.comma), hasStar = parseAfterDefault && this.eatExportStar(node), hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node), parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma)), isFromRequired = hasDefault || hasStar;
      if (hasStar && !hasNamespace) return hasDefault && this.unexpected(), this.parseExportFrom(node, !0), 
      this.finishNode(node, "ExportAllDeclaration");
      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) throw this.unexpected(null, types.braceL);
      let hasDeclaration;
      if (isFromRequired || hasSpecifiers ? (hasDeclaration = !1, this.parseExportFrom(node, isFromRequired)) : hasDeclaration = this.maybeParseExportDeclaration(node), 
      isFromRequired || hasSpecifiers || hasDeclaration) return this.checkExport(node, !0, !1, !!node.source), 
      this.finishNode(node, "ExportNamedDeclaration");
      if (this.eat(types._default)) return node.declaration = this.parseExportDefaultExpression(), 
      this.checkExport(node, !0, !0), this.finishNode(node, "ExportDefaultDeclaration");
      throw this.unexpected(null, types.braceL);
    }
    eatExportStar(node) {
      return this.eat(types.star);
    }
    maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        return specifier.exported = this.parseIdentifier(!0), node.specifiers = [ this.finishNode(specifier, "ExportDefaultSpecifier") ], 
        !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        node.specifiers || (node.specifiers = []);
        const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        return this.next(), specifier.exported = this.parseIdentifier(!0), node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier")), 
        !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(node) {
      return !!this.match(types.braceL) && (node.specifiers || (node.specifiers = []), 
      node.specifiers.push(...this.parseExportSpecifiers()), node.source = null, node.declaration = null, 
      !0);
    }
    maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        if (this.isContextual("async")) {
          const next = this.nextTokenStart();
          this.isUnparsedContextual(next, "function") || this.unexpected(next, types._function);
        }
        return node.specifiers = [], node.source = null, node.declaration = this.parseExportDeclaration(node), 
        !0;
      }
      return !1;
    }
    isAsyncFunction() {
      if (!this.isContextual("async")) return !1;
      const next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }
    parseExportDefaultExpression() {
      const expr = this.startNode(), isAsync = this.isAsyncFunction();
      if (this.match(types._function) || isAsync) return this.next(), isAsync && this.next(), 
      this.parseFunction(expr, 5, isAsync);
      if (this.match(types._class)) return this.parseClass(expr, !0, !0);
      if (this.match(types.at)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport), 
      this.parseDecorators(!1), this.parseClass(expr, !0, !0);
      if (this.match(types._const) || this.match(types._var) || this.isLet()) throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      {
        const res = this.parseMaybeAssign();
        return this.semicolon(), res;
      }
    }
    parseExportDeclaration(node) {
      return this.parseStatement(null);
    }
    isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        const value = this.state.value;
        if ("async" === value || "let" === value) return !1;
        if (("type" === value || "interface" === value) && !this.state.containsEsc) {
          const l = this.lookahead();
          if (l.type === types.name && "from" !== l.value || l.type === types.braceL) return this.expectOnePlugin([ "flow", "typescript" ]), 
          !1;
        }
      } else if (!this.match(types._default)) return !1;
      const next = this.nextTokenStart(), hasFrom = this.isUnparsedContextual(next, "from");
      if (44 === this.input.charCodeAt(next) || this.match(types.name) && hasFrom) return !0;
      if (this.match(types._default) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return 34 === nextAfterFrom || 39 === nextAfterFrom;
      }
      return !1;
    }
    parseExportFrom(node, expect) {
      this.eatContextual("from") ? (node.source = this.parseImportSource(), this.checkExport(node)) : expect ? this.unexpected() : node.source = null, 
      this.semicolon();
    }
    shouldParseExportDeclaration() {
      if (this.match(types.at) && (this.expectOnePlugin([ "decorators", "decorators-legacy" ]), 
      this.hasPlugin("decorators"))) {
        if (!this.getPluginOption("decorators", "decoratorsBeforeExport")) return !0;
        this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
      }
      return "var" === this.state.type.keyword || "const" === this.state.type.keyword || "function" === this.state.type.keyword || "class" === this.state.type.keyword || this.isLet() || this.isAsyncFunction();
    }
    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) if (isDefault) {
        if (this.checkDuplicateExports(node, "default"), this.hasPlugin("exportDefaultFrom")) {
          var _declaration$extra;
          const declaration = node.declaration;
          "Identifier" !== declaration.type || "from" !== declaration.name || declaration.end - declaration.start != 4 || (null == (_declaration$extra = declaration.extra) ? void 0 : _declaration$extra.parenthesized) || this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
        }
      } else if (node.specifiers && node.specifiers.length) for (let _i4 = 0, _node$specifiers = node.specifiers; _i4 < _node$specifiers.length; _i4++) {
        const specifier = _node$specifiers[_i4];
        this.checkDuplicateExports(specifier, specifier.exported.name), !isFrom && specifier.local && (this.checkReservedWord(specifier.local.name, specifier.local.start, !0, !1), 
        this.scope.checkLocalExport(specifier.local));
      } else if (node.declaration) if ("FunctionDeclaration" === node.declaration.type || "ClassDeclaration" === node.declaration.type) {
        const id = node.declaration.id;
        if (!id) throw new Error("Assertion failure");
        this.checkDuplicateExports(node, id.name);
      } else if ("VariableDeclaration" === node.declaration.type) for (let _i5 = 0, _node$declaration$dec = node.declaration.declarations; _i5 < _node$declaration$dec.length; _i5++) {
        const declaration = _node$declaration$dec[_i5];
        this.checkDeclaration(declaration.id);
      }
      if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) {
        const isClass = node.declaration && ("ClassDeclaration" === node.declaration.type || "ClassExpression" === node.declaration.type);
        if (!node.declaration || !isClass) throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
        this.takeDecorators(node.declaration);
      }
    }
    checkDeclaration(node) {
      if ("Identifier" === node.type) this.checkDuplicateExports(node, node.name); else if ("ObjectPattern" === node.type) for (let _i6 = 0, _node$properties = node.properties; _i6 < _node$properties.length; _i6++) {
        const prop = _node$properties[_i6];
        this.checkDeclaration(prop);
      } else if ("ArrayPattern" === node.type) for (let _i7 = 0, _node$elements = node.elements; _i7 < _node$elements.length; _i7++) {
        const elem = _node$elements[_i7];
        elem && this.checkDeclaration(elem);
      } else "ObjectProperty" === node.type ? this.checkDeclaration(node.value) : "RestElement" === node.type ? this.checkDeclaration(node.argument) : "AssignmentPattern" === node.type && this.checkDeclaration(node.left);
    }
    checkDuplicateExports(node, name) {
      this.state.exportedIdentifiers.indexOf(name) > -1 && this.raise(node.start, "default" === name ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name), 
      this.state.exportedIdentifiers.push(name);
    }
    parseExportSpecifiers() {
      const nodes = [];
      let first = !0;
      for (this.expect(types.braceL); !this.eat(types.braceR); ) {
        if (first) first = !1; else if (this.expect(types.comma), this.eat(types.braceR)) break;
        const node = this.startNode();
        node.local = this.parseIdentifier(!0), node.exported = this.eatContextual("as") ? this.parseIdentifier(!0) : node.local.__clone(), 
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }
      return nodes;
    }
    parseImport(node) {
      if (node.specifiers = [], !this.match(types.string)) {
        const parseNext = !this.maybeParseDefaultImportSpecifier(node) || this.eat(types.comma), hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        parseNext && !hasStar && this.parseNamedImportSpecifiers(node), this.expectContextual("from");
      }
      node.source = this.parseImportSource();
      const attributes = this.maybeParseModuleAttributes();
      return attributes && (node.attributes = attributes), this.semicolon(), this.finishNode(node, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(types.string) || this.unexpected(), this.parseExprAtom();
    }
    shouldParseDefaultImport(node) {
      return this.match(types.name);
    }
    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier(), this.checkLVal(specifier.local, 9, void 0, contextDescription), 
      node.specifiers.push(this.finishNode(specifier, type));
    }
    maybeParseModuleAttributes() {
      if (!this.match(types._with) || this.hasPrecedingLineBreak()) return this.hasPlugin("moduleAttributes") ? [] : null;
      this.expectPlugin("moduleAttributes"), this.next();
      const attrs = [], attributes = new Set;
      do {
        const node = this.startNode();
        if (node.key = this.parseIdentifier(!0), "type" !== node.key.name && this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name), 
        attributes.has(node.key.name) && this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name), 
        attributes.add(node.key.name), this.expect(types.colon), !this.match(types.string)) throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        node.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(node, "ImportAttribute"), 
        attrs.push(node);
      } while (this.eat(types.comma));
      return attrs;
    }
    maybeParseDefaultImportSpecifier(node) {
      return !!this.shouldParseDefaultImport(node) && (this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), 
      !0);
    }
    maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        const specifier = this.startNode();
        return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier"), 
        !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(node) {
      let first = !0;
      for (this.expect(types.braceL); !this.eat(types.braceR); ) {
        if (first) first = !1; else {
          if (this.eat(types.colon)) throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          if (this.expect(types.comma), this.eat(types.braceR)) break;
        }
        this.parseImportSpecifier(node);
      }
    }
    parseImportSpecifier(node) {
      const specifier = this.startNode();
      specifier.imported = this.parseIdentifier(!0), this.eatContextual("as") ? specifier.local = this.parseIdentifier() : (this.checkReservedWord(specifier.imported.name, specifier.start, !0, !0), 
      specifier.local = specifier.imported.__clone()), this.checkLVal(specifier.local, 9, void 0, "import specifier"), 
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }
  } {
    constructor(options, input) {
      super(options = function(opts) {
        const options = {};
        for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {
          const key = _Object$keys[_i];
          options[key] = opts && null != opts[key] ? opts[key] : defaultOptions[key];
        }
        return options;
      }(options), input);
      const ScopeHandler = this.getScopeHandler();
      this.options = options, this.inModule = "module" === this.options.sourceType, this.scope = new ScopeHandler(this.raise.bind(this), this.inModule), 
      this.prodParam = new ProductionParameterHandler, this.classScope = new ClassScopeHandler(this.raise.bind(this)), 
      this.plugins = function(plugins) {
        const pluginMap = new Map;
        for (let _i = 0; _i < plugins.length; _i++) {
          const plugin = plugins[_i], [name, options] = Array.isArray(plugin) ? plugin : [ plugin, {} ];
          pluginMap.has(name) || pluginMap.set(name, options || {});
        }
        return pluginMap;
      }(this.options.plugins), this.filename = options.sourceFilename;
    }
    getScopeHandler() {
      return ScopeHandler;
    }
    parse() {
      let paramFlags = 0;
      this.hasPlugin("topLevelAwait") && this.inModule && (paramFlags |= 2), this.scope.enter(1), 
      this.prodParam.enter(paramFlags);
      const file = this.startNode(), program = this.startNode();
      return this.nextToken(), file.errors = null, this.parseTopLevel(file, program), 
      file.errors = this.state.errors, file;
    }
  }
  function getParser(options, input) {
    let cls = Parser;
    return (null == options ? void 0 : options.plugins) && (!function(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (null == decoratorsBeforeExport) throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
        if ("boolean" != typeof decoratorsBeforeExport) throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(", "));
      if (hasPlugin(plugins, "moduleAttributes")) {
        if ("may-2020" !== getPluginOption(plugins, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
      }
      if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(", "));
    }(options.plugins), cls = function(pluginsFromOptions) {
      const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name)), key = pluginList.join("/");
      let cls = parserClassCache[key];
      if (!cls) {
        cls = Parser;
        for (let _i = 0; _i < pluginList.length; _i++) {
          const plugin = pluginList[_i];
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }(options.plugins)), new cls(options, input);
  }
  const parserClassCache = {};
  exports.parse = function(input, options) {
    var _options;
    if ("unambiguous" !== (null == (_options = options) ? void 0 : _options.sourceType)) return getParser(options, input).parse();
    options = Object.assign({}, options);
    try {
      options.sourceType = "module";
      const parser = getParser(options, input), ast = parser.parse();
      if (parser.sawUnambiguousESM) return ast;
      if (parser.ambiguousScriptDifferentAst) try {
        return options.sourceType = "script", getParser(options, input).parse();
      } catch (_unused) {} else ast.program.sourceType = "script";
      return ast;
    } catch (moduleError) {
      try {
        return options.sourceType = "script", getParser(options, input).parse();
      } catch (_unused2) {}
      throw moduleError;
    }
  }, exports.parseExpression = function(input, options) {
    const parser = getParser(options, input);
    return parser.options.strictMode && (parser.state.strict = !0), parser.getExpression();
  }, exports.tokTypes = types;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.codeFrameColumns = codeFrameColumns, exports.default = function(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = !0;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) process.emitWarning(message, "DeprecationWarning"); else {
        new Error(message).name = "DeprecationWarning", console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    return codeFrameColumns(rawLines, {
      start: {
        column: colNumber,
        line: lineNumber
      }
    }, opts);
  };
  var _highlight = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(301));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  let deprecationWarningShown = !1;
  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function codeFrameColumns(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts), chalk = (0, 
    _highlight.getChalk)(opts), defs = function(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }(chalk), maybeHighlight = (chalkFn, string) => highlighted ? chalkFn(string) : string, lines = rawLines.split(NEWLINE), {start: start, end: end, markerLines: markerLines} = function(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start), endLoc = Object.assign({}, startLoc, loc.end), {linesAbove: linesAbove = 2, linesBelow: linesBelow = 3} = opts || {}, startLine = startLoc.line, startColumn = startLoc.column, endLine = endLoc.line, endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0), end = Math.min(source.length, endLine + linesBelow);
      -1 === startLine && (start = 0), -1 === endLine && (end = source.length);
      const lineDiff = endLine - startLine, markerLines = {};
      if (lineDiff) for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;
        if (startColumn) if (0 === i) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [ startColumn, sourceLength - startColumn + 1 ];
        } else if (i === lineDiff) markerLines[lineNumber] = [ 0, endColumn ]; else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [ 0, sourceLength ];
        } else markerLines[lineNumber] = !0;
      } else markerLines[startLine] = startColumn === endColumn ? !startColumn || [ startColumn, 0 ] : [ startColumn, endColumn - startColumn ];
      return {
        start: start,
        end: end,
        markerLines: markerLines
      };
    }(loc, lines, opts), hasColumns = loc.start && "number" == typeof loc.start.column, numberMaxWidth = String(end).length;
    let frame = (highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines).split(NEWLINE).slice(start, end).map((line, index) => {
      const number = start + 1 + index, gutter = ` ${(" " + number).slice(-numberMaxWidth)} | `, hasMarker = markerLines[number], lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        let markerLine = "";
        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " "), numberOfMarkers = hasMarker[1] || 1;
          markerLine = [ "\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers) ].join(""), 
          lastMarkerLine && opts.message && (markerLine += " " + maybeHighlight(defs.message, opts.message));
        }
        return [ maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine ].join("");
      }
      return ` ${maybeHighlight(defs.gutter, gutter)}${line}`;
    }).join("\n");
    return opts.message && !hasColumns && (frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`), 
    highlighted ? chalk.reset(frame) : frame;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(metadata, replacements) {
    const ast = t.cloneNode(metadata.ast);
    replacements && (metadata.placeholders.forEach(placeholder => {
      if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
        const placeholderName = placeholder.name;
        throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`);
      }
    }), Object.keys(replacements).forEach(key => {
      if (!metadata.placeholderNames.has(key)) throw new Error(`Unknown substitution "${key}" given`);
    }));
    return metadata.placeholders.slice().reverse().forEach(placeholder => {
      try {
        !function(placeholder, ast, replacement) {
          placeholder.isDuplicate && (Array.isArray(replacement) ? replacement = replacement.map(node => t.cloneNode(node)) : "object" == typeof replacement && (replacement = t.cloneNode(replacement)));
          const {parent: parent, key: key, index: index} = placeholder.resolve(ast);
          if ("string" === placeholder.type) {
            if ("string" == typeof replacement && (replacement = t.stringLiteral(replacement)), 
            !replacement || !t.isStringLiteral(replacement)) throw new Error("Expected string substitution");
          } else if ("statement" === placeholder.type) void 0 === index ? replacement ? Array.isArray(replacement) ? replacement = t.blockStatement(replacement) : "string" == typeof replacement ? replacement = t.expressionStatement(t.identifier(replacement)) : t.isStatement(replacement) || (replacement = t.expressionStatement(replacement)) : replacement = t.emptyStatement() : replacement && !Array.isArray(replacement) && ("string" == typeof replacement && (replacement = t.identifier(replacement)), 
          t.isStatement(replacement) || (replacement = t.expressionStatement(replacement))); else if ("param" === placeholder.type) {
            if ("string" == typeof replacement && (replacement = t.identifier(replacement)), 
            void 0 === index) throw new Error("Assertion failure.");
          } else if ("string" == typeof replacement && (replacement = t.identifier(replacement)), 
          Array.isArray(replacement)) throw new Error("Cannot replace single expression with an array.");
          if (void 0 === index) t.validate(parent, key, replacement), parent[key] = replacement; else {
            const items = parent[key].slice();
            "statement" === placeholder.type || "param" === placeholder.type ? null == replacement ? items.splice(index, 1) : Array.isArray(replacement) ? items.splice(index, 1, ...replacement) : items[index] = replacement : items[index] = replacement, 
            t.validate(parent, key, items), parent[key] = items;
          }
        }(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        throw e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`, 
        e;
      }
    }), ast;
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.createClassFeaturePlugin = function({name: name, feature: feature, loose: loose, manipulateOptions: manipulateOptions}) {
    return {
      name: name,
      manipulateOptions: manipulateOptions,
      pre() {
        (0, _features.enableFeature)(this.file, feature, loose), (!this.file.get(versionKey) || this.file.get(versionKey) < version) && this.file.set(versionKey, version);
      },
      visitor: {
        Class(path, state) {
          if (this.file.get(versionKey) !== version) return;
          (0, _features.verifyUsedFeatures)(path, this.file);
          const loose = (0, _features.isLoose)(this.file, feature);
          let constructor, isDecorated = (0, _decorators.hasOwnDecorators)(path.node);
          const props = [], elements = [], computedPaths = [], privateNames = new Set, body = path.get("body");
          for (const path of body.get("body")) {
            if ((0, _features.verifyUsedFeatures)(path, this.file), path.node.computed && computedPaths.push(path), 
            path.isPrivate()) {
              const {name: name} = path.node.key.id, getName = "get " + name, setName = "set " + name;
              if ("get" === path.node.kind) {
                if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) throw path.buildCodeFrameError("Duplicate private field");
                privateNames.add(getName).add(name);
              } else if ("set" === path.node.kind) {
                if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) throw path.buildCodeFrameError("Duplicate private field");
                privateNames.add(setName).add(name);
              } else {
                if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) throw path.buildCodeFrameError("Duplicate private field");
                privateNames.add(name);
              }
            }
            path.isClassMethod({
              kind: "constructor"
            }) ? constructor = path : (elements.push(path), (path.isProperty() || path.isPrivate()) && props.push(path)), 
            isDecorated || (isDecorated = (0, _decorators.hasOwnDecorators)(path.node));
          }
          if (!props.length && !isDecorated) return;
          let ref;
          path.isClassExpression() || !path.node.id ? ((0, _helperFunctionName.default)(path), 
          ref = path.scope.generateUidIdentifier("class")) : ref = _core.types.cloneNode(path.node.id);
          const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props), privateNamesNodes = (0, 
          _fields.buildPrivateNamesNodes)(privateNamesMap, loose, state);
          let keysNodes, staticNodes, instanceNodes, wrapClass;
          (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, loose, state), 
          isDecorated ? (staticNodes = keysNodes = [], ({instanceNodes: instanceNodes, wrapClass: wrapClass} = (0, 
          _decorators.buildDecoratedClass)(ref, path, elements, this.file))) : (keysNodes = (0, 
          _misc.extractComputedKeys)(ref, path, computedPaths, this.file), ({staticNodes: staticNodes, instanceNodes: instanceNodes, wrapClass: wrapClass} = (0, 
          _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, state, loose))), 
          instanceNodes.length > 0 && (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {
            if (!isDecorated) for (const prop of props) prop.node.static || prop.traverse(referenceVisitor, state);
          }), (path = wrapClass(path)).insertBefore([ ...privateNamesNodes, ...keysNodes ]), 
          path.insertAfter(staticNodes);
        },
        PrivateName(path) {
          if (this.file.get(versionKey) === version) throw path.buildCodeFrameError(`Unknown PrivateName "${path}"`);
        },
        ExportDefaultDeclaration(path) {
          if (this.file.get(versionKey) !== version) return;
          const decl = path.get("declaration");
          decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node) && (decl.node.id ? (0, 
          _helperSplitExportDeclaration.default)(path) : decl.node.type = "ClassExpression");
        }
      }
    };
  }, Object.defineProperty(exports, "injectInitialization", {
    enumerable: !0,
    get: function() {
      return _misc.injectInitialization;
    }
  }), Object.defineProperty(exports, "FEATURES", {
    enumerable: !0,
    get: function() {
      return _features.FEATURES;
    }
  });
  var _core = __webpack_require__(2), _helperFunctionName = _interopRequireDefault(__webpack_require__(8)), _helperSplitExportDeclaration = _interopRequireDefault(__webpack_require__(43)), _fields = __webpack_require__(307), _decorators = __webpack_require__(149), _misc = __webpack_require__(366), _features = __webpack_require__(367);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const version = _interopRequireDefault(__webpack_require__(368)).default.version.split(".").reduce((v, x) => 1e5 * v + +x, 0), versionKey = "@babel/plugin-class-features/version";
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const ReferencedIdentifier = {
    types: [ "Identifier", "JSXIdentifier" ],
    checkPath(path, opts) {
      const {node: node, parent: parent} = path;
      if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
        if (!t.isJSXIdentifier(node, opts)) return !1;
        if (t.react.isCompatTag(node.name)) return !1;
      }
      return t.isReferenced(node, parent, path.parentPath.parent);
    }
  };
  exports.ReferencedIdentifier = ReferencedIdentifier;
  const ReferencedMemberExpression = {
    types: [ "MemberExpression" ],
    checkPath: ({node: node, parent: parent}) => t.isMemberExpression(node) && t.isReferenced(node, parent)
  };
  exports.ReferencedMemberExpression = ReferencedMemberExpression;
  const BindingIdentifier = {
    types: [ "Identifier" ],
    checkPath(path) {
      const {node: node, parent: parent} = path, grandparent = path.parentPath.parent;
      return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);
    }
  };
  exports.BindingIdentifier = BindingIdentifier;
  const Statement = {
    types: [ "Statement" ],
    checkPath({node: node, parent: parent}) {
      if (t.isStatement(node)) {
        if (t.isVariableDeclaration(node)) {
          if (t.isForXStatement(parent, {
            left: node
          })) return !1;
          if (t.isForStatement(parent, {
            init: node
          })) return !1;
        }
        return !0;
      }
      return !1;
    }
  };
  exports.Statement = Statement;
  const Expression = {
    types: [ "Expression" ],
    checkPath: path => path.isIdentifier() ? path.isReferencedIdentifier() : t.isExpression(path.node)
  };
  exports.Expression = Expression;
  const Scope = {
    types: [ "Scopable", "Pattern" ],
    checkPath: path => t.isScope(path.node, path.parent)
  };
  exports.Scope = Scope;
  const Referenced = {
    checkPath: path => t.isReferenced(path.node, path.parent)
  };
  exports.Referenced = Referenced;
  const BlockScoped = {
    checkPath: path => t.isBlockScoped(path.node)
  };
  exports.BlockScoped = BlockScoped;
  const Var = {
    types: [ "VariableDeclaration" ],
    checkPath: path => t.isVar(path.node)
  };
  exports.Var = Var;
  const User = {
    checkPath: path => path.node && !!path.node.loc
  };
  exports.User = User;
  const Generated = {
    checkPath: path => !path.isUser()
  };
  exports.Generated = Generated;
  const Pure = {
    checkPath: (path, opts) => path.scope.isPure(path.node, opts)
  };
  exports.Pure = Pure;
  const Flow = {
    types: [ "Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier" ],
    checkPath: ({node: node}) => !!t.isFlow(node) || (t.isImportDeclaration(node) ? "type" === node.importKind || "typeof" === node.importKind : t.isExportDeclaration(node) ? "type" === node.exportKind : !!t.isImportSpecifier(node) && ("type" === node.importKind || "typeof" === node.importKind))
  };
  exports.Flow = Flow;
  const RestProperty = {
    types: [ "RestElement" ],
    checkPath: path => path.parentPath && path.parentPath.isObjectPattern()
  };
  exports.RestProperty = RestProperty;
  const SpreadProperty = {
    types: [ "RestElement" ],
    checkPath: path => path.parentPath && path.parentPath.isObjectExpression()
  };
  exports.SpreadProperty = SpreadProperty;
  exports.ExistentialTypeParam = {
    types: [ "ExistsTypeAnnotation" ]
  };
  exports.NumericLiteralTypeAnnotation = {
    types: [ "NumberLiteralTypeAnnotation" ]
  };
  const ForAwaitStatement = {
    types: [ "ForOfStatement" ],
    checkPath: ({node: node}) => !0 === node.await
  };
  exports.ForAwaitStatement = ForAwaitStatement;
}, function(module, exports, __webpack_require__) {
  module.exports = function(env) {
    function createDebug(namespace) {
      let prevTime;
      function debug(...args) {
        if (!debug.enabled) return;
        const self = debug, curr = Number(new Date), ms = curr - (prevTime || curr);
        self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), 
        "string" != typeof args[0] && args.unshift("%O");
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if ("%%" === match) return match;
          index++;
          const formatter = createDebug.formatters[format];
          if ("function" == typeof formatter) {
            const val = args[index];
            match = formatter.call(self, val), args.splice(index, 1), index--;
          }
          return match;
        }), createDebug.formatArgs.call(self, args);
        (self.log || createDebug.log).apply(self, args);
      }
      return debug.namespace = namespace, debug.enabled = createDebug.enabled(namespace), 
      debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), 
      debug.destroy = destroy, debug.extend = extend, "function" == typeof createDebug.init && createDebug.init(debug), 
      createDebug.instances.push(debug), debug;
    }
    function destroy() {
      const index = createDebug.instances.indexOf(this);
      return -1 !== index && (createDebug.instances.splice(index, 1), !0);
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (void 0 === delimiter ? ":" : delimiter) + namespace);
      return newDebug.log = this.log, newDebug;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    return createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = function(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }, createDebug.disable = function() {
      const namespaces = [ ...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map(namespace => "-" + namespace) ].join(",");
      return createDebug.enable(""), namespaces;
    }, createDebug.enable = function(namespaces) {
      let i;
      createDebug.save(namespaces), createDebug.names = [], createDebug.skips = [];
      const split = ("string" == typeof namespaces ? namespaces : "").split(/[\s,]+/), len = split.length;
      for (i = 0; i < len; i++) split[i] && ("-" === (namespaces = split[i].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
      for (i = 0; i < createDebug.instances.length; i++) {
        const instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }, createDebug.enabled = function(name) {
      if ("*" === name[name.length - 1]) return !0;
      let i, len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return !1;
      for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return !0;
      return !1;
    }, createDebug.humanize = __webpack_require__(311), Object.keys(env).forEach(key => {
      createDebug[key] = env[key];
    }), createDebug.instances = [], createDebug.names = [], createDebug.skips = [], 
    createDebug.formatters = {}, createDebug.selectColor = function(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), 
      hash |= 0;
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }, createDebug.enable(createDebug.load()), createDebug;
  };
}, function(module, exports) {
  module.exports = require("util");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _renamer = _interopRequireDefault(__webpack_require__(315)), _index = _interopRequireDefault(__webpack_require__(28)), _defaults = _interopRequireDefault(__webpack_require__(316)), _binding = _interopRequireDefault(__webpack_require__(137)), _globals = _interopRequireDefault(__webpack_require__(141)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _cache = __webpack_require__(44);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const collectorVisitor = {
    For(path) {
      for (const key of t.FOR_INIT_KEYS) {
        const declar = path.get(key);
        if (declar.isVar()) {
          (path.scope.getFunctionParent() || path.scope.getProgramParent()).registerBinding("var", declar);
        }
      }
    },
    Declaration(path) {
      if (path.isBlockScoped()) return;
      if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) return;
      (path.scope.getFunctionParent() || path.scope.getProgramParent()).registerDeclaration(path);
    },
    ReferencedIdentifier(path, state) {
      state.references.push(path);
    },
    ForXStatement(path, state) {
      const left = path.get("left");
      (left.isPattern() || left.isIdentifier()) && state.constantViolations.push(path);
    },
    ExportDeclaration: {
      exit(path) {
        const {node: node, scope: scope} = path, declar = node.declaration;
        if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {
          const id = declar.id;
          if (!id) return;
          const binding = scope.getBinding(id.name);
          binding && binding.reference(path);
        } else if (t.isVariableDeclaration(declar)) for (const decl of declar.declarations) for (const name of Object.keys(t.getBindingIdentifiers(decl))) {
          const binding = scope.getBinding(name);
          binding && binding.reference(path);
        }
      }
    },
    LabeledStatement(path) {
      path.scope.getProgramParent().addGlobal(path.node), path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression(path, state) {
      "delete" === path.node.operator && state.constantViolations.push(path);
    },
    BlockScoped(path) {
      let scope = path.scope;
      scope.path === path && (scope = scope.parent);
      if (scope.getBlockParent().registerDeclaration(path), path.isClassDeclaration() && path.node.id) {
        const name = path.node.id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },
    Block(path) {
      const paths = path.get("body");
      for (const bodyPath of paths) bodyPath.isFunctionDeclaration() && path.scope.getBlockParent().registerDeclaration(bodyPath);
    },
    CatchClause(path) {
      path.scope.registerBinding("let", path);
    },
    Function(path) {
      path.isFunctionExpression() && path.has("id") && !path.get("id").node[t.NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path.get("id"), path);
      const params = path.get("params");
      for (const param of params) path.scope.registerBinding("param", param);
    },
    ClassExpression(path) {
      path.has("id") && !path.get("id").node[t.NOT_LOCAL_BINDING] && path.scope.registerBinding("local", path);
    }
  };
  let uid = 0;
  class Scope {
    constructor(path) {
      const {node: node} = path, cached = _cache.scope.get(node);
      if ((null == cached ? void 0 : cached.path) === path) return cached;
      _cache.scope.set(node, this), this.uid = uid++, this.block = node, this.path = path, 
      this.labels = new Map, this.inited = !1;
    }
    get parent() {
      const parent = this.path.findParent(p => p.isScope());
      return null == parent ? void 0 : parent.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(node, opts, state) {
      (0, _index.default)(node, opts, this, state, this.path);
    }
    generateDeclaredUidIdentifier(name) {
      const id = this.generateUidIdentifier(name);
      return this.push({
        id: id
      }), t.cloneNode(id);
    }
    generateUidIdentifier(name) {
      return t.identifier(this.generateUid(name));
    }
    generateUid(name = "temp") {
      let uid;
      name = t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let i = 0;
      do {
        uid = this._generateUid(name, i), i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
      const program = this.getProgramParent();
      return program.references[uid] = !0, program.uids[uid] = !0, uid;
    }
    _generateUid(name, i) {
      let id = name;
      return i > 1 && (id += i), "_" + id;
    }
    generateUidBasedOnNode(node, defaultName) {
      const parts = [];
      !function gatherNodeParts(node, parts) {
        switch (null == node ? void 0 : node.type) {
         default:
          if (t.isModuleDeclaration(node)) if (node.source) gatherNodeParts(node.source, parts); else if (node.specifiers && node.specifiers.length) for (const e of node.specifiers) gatherNodeParts(e, parts); else node.declaration && gatherNodeParts(node.declaration, parts); else t.isModuleSpecifier(node) ? gatherNodeParts(node.local, parts) : t.isLiteral(node) && parts.push(node.value);
          break;

         case "MemberExpression":
         case "OptionalMemberExpression":
         case "JSXMemberExpression":
          gatherNodeParts(node.object, parts), gatherNodeParts(node.property, parts);
          break;

         case "Identifier":
         case "JSXIdentifier":
          parts.push(node.name);
          break;

         case "CallExpression":
         case "OptionalCallExpression":
         case "NewExpression":
          gatherNodeParts(node.callee, parts);
          break;

         case "ObjectExpression":
         case "ObjectPattern":
          for (const e of node.properties) gatherNodeParts(e, parts);
          break;

         case "SpreadElement":
         case "RestElement":
          gatherNodeParts(node.argument, parts);
          break;

         case "ObjectProperty":
         case "ObjectMethod":
         case "ClassProperty":
         case "ClassMethod":
         case "ClassPrivateProperty":
         case "ClassPrivateMethod":
          gatherNodeParts(node.key, parts);
          break;

         case "ThisExpression":
          parts.push("this");
          break;

         case "Super":
          parts.push("super");
          break;

         case "Import":
          parts.push("import");
          break;

         case "DoExpression":
          parts.push("do");
          break;

         case "YieldExpression":
          parts.push("yield"), gatherNodeParts(node.argument, parts);
          break;

         case "AwaitExpression":
          parts.push("await"), gatherNodeParts(node.argument, parts);
          break;

         case "AssignmentExpression":
          gatherNodeParts(node.left, parts);
          break;

         case "VariableDeclarator":
          gatherNodeParts(node.id, parts);
          break;

         case "FunctionExpression":
         case "FunctionDeclaration":
         case "ClassExpression":
         case "ClassDeclaration":
         case "PrivateName":
          gatherNodeParts(node.id, parts);
          break;

         case "ParenthesizedExpression":
          gatherNodeParts(node.expression, parts);
          break;

         case "UnaryExpression":
         case "UpdateExpression":
          gatherNodeParts(node.argument, parts);
          break;

         case "MetaProperty":
          gatherNodeParts(node.meta, parts), gatherNodeParts(node.property, parts);
          break;

         case "JSXElement":
          gatherNodeParts(node.openingElement, parts);
          break;

         case "JSXOpeningElement":
          parts.push(node.name);
          break;

         case "JSXFragment":
          gatherNodeParts(node.openingFragment, parts);
          break;

         case "JSXOpeningFragment":
          parts.push("Fragment");
          break;

         case "JSXNamespacedName":
          gatherNodeParts(node.namespace, parts), gatherNodeParts(node.name, parts);
        }
      }(node, parts);
      let id = parts.join("$");
      return id = id.replace(/^_/, "") || defaultName || "ref", this.generateUid(id.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(node, defaultName) {
      return t.identifier(this.generateUidBasedOnNode(node, defaultName));
    }
    isStatic(node) {
      if (t.isThisExpression(node) || t.isSuper(node)) return !0;
      if (t.isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        return binding ? binding.constant : this.hasBinding(node.name);
      }
      return !1;
    }
    maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) return null;
      {
        const id = this.generateUidIdentifierBasedOnNode(node);
        return dontPush ? id : (this.push({
          id: id
        }), t.cloneNode(id));
      }
    }
    checkBlockScopedCollisions(local, kind, name, id) {
      if ("param" === kind) return;
      if ("local" === local.kind) return;
      if ("let" === kind || "let" === local.kind || "const" === local.kind || "module" === local.kind || "param" === local.kind && ("let" === kind || "const" === kind)) throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
    }
    rename(oldName, newName, block) {
      const binding = this.getBinding(oldName);
      if (binding) return newName = newName || this.generateUidIdentifier(oldName).name, 
      new _renamer.default(binding, oldName, newName).rename(block);
    }
    _renameFromMap(map, oldName, newName, value) {
      map[oldName] && (map[newName] = value, map[oldName] = null);
    }
    dump() {
      const sep = "-".repeat(60);
      console.log(sep);
      let scope = this;
      do {
        console.log("#", scope.block.type);
        for (const name of Object.keys(scope.bindings)) {
          const binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);
      console.log(sep);
    }
    toArray(node, i, allowArrayLike) {
      if (t.isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        if ((null == binding ? void 0 : binding.constant) && binding.path.isGenericType("Array")) return node;
      }
      if (t.isArrayExpression(node)) return node;
      if (t.isIdentifier(node, {
        name: "arguments"
      })) return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier("Array"), t.identifier("prototype")), t.identifier("slice")), t.identifier("call")), [ node ]);
      let helperName;
      const args = [ node ];
      return !0 === i ? helperName = "toConsumableArray" : i ? (args.push(t.numericLiteral(i)), 
      helperName = "slicedToArray") : helperName = "toArray", allowArrayLike && (args.unshift(this.hub.addHelper(helperName)), 
      helperName = "maybeArrayLike"), t.callExpression(this.hub.addHelper(helperName), args);
    }
    hasLabel(name) {
      return !!this.getLabel(name);
    }
    getLabel(name) {
      return this.labels.get(name);
    }
    registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    }
    registerDeclaration(path) {
      if (path.isLabeledStatement()) this.registerLabel(path); else if (path.isFunctionDeclaration()) this.registerBinding("hoisted", path.get("id"), path); else if (path.isVariableDeclaration()) {
        const declarations = path.get("declarations");
        for (const declar of declarations) this.registerBinding(path.node.kind, declar);
      } else if (path.isClassDeclaration()) this.registerBinding("let", path); else if (path.isImportDeclaration()) {
        const specifiers = path.get("specifiers");
        for (const specifier of specifiers) this.registerBinding("module", specifier);
      } else if (path.isExportDeclaration()) {
        const declar = path.get("declaration");
        (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) && this.registerDeclaration(declar);
      } else this.registerBinding("unknown", path);
    }
    buildUndefinedNode() {
      return t.unaryExpression("void", t.numericLiteral(0), !0);
    }
    registerConstantViolation(path) {
      const ids = path.getBindingIdentifiers();
      for (const name of Object.keys(ids)) {
        const binding = this.getBinding(name);
        binding && binding.reassign(path);
      }
    }
    registerBinding(kind, path, bindingPath = path) {
      if (!kind) throw new ReferenceError("no `kind`");
      if (path.isVariableDeclaration()) {
        const declarators = path.get("declarations");
        for (const declar of declarators) this.registerBinding(kind, declar);
        return;
      }
      const parent = this.getProgramParent(), ids = path.getOuterBindingIdentifiers(!0);
      for (const name of Object.keys(ids)) {
        parent.references[name] = !0;
        for (const id of ids[name]) {
          const local = this.getOwnBinding(name);
          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }
          local ? this.registerConstantViolation(bindingPath) : this.bindings[name] = new _binding.default({
            identifier: id,
            scope: this,
            path: bindingPath,
            kind: kind
          });
        }
      }
    }
    addGlobal(node) {
      this.globals[node.name] = node;
    }
    hasUid(name) {
      let scope = this;
      do {
        if (scope.uids[name]) return !0;
      } while (scope = scope.parent);
      return !1;
    }
    hasGlobal(name) {
      let scope = this;
      do {
        if (scope.globals[name]) return !0;
      } while (scope = scope.parent);
      return !1;
    }
    hasReference(name) {
      return !!this.getProgramParent().references[name];
    }
    isPure(node, constantsOnly) {
      if (t.isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        return !!binding && (!constantsOnly || binding.constant);
      }
      if (t.isClass(node)) return !(node.superClass && !this.isPure(node.superClass, constantsOnly)) && this.isPure(node.body, constantsOnly);
      if (t.isClassBody(node)) {
        for (const method of node.body) if (!this.isPure(method, constantsOnly)) return !1;
        return !0;
      }
      if (t.isBinary(node)) return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      if (t.isArrayExpression(node)) {
        for (const elem of node.elements) if (!this.isPure(elem, constantsOnly)) return !1;
        return !0;
      }
      if (t.isObjectExpression(node)) {
        for (const prop of node.properties) if (!this.isPure(prop, constantsOnly)) return !1;
        return !0;
      }
      if (t.isMethod(node)) return !(node.computed && !this.isPure(node.key, constantsOnly)) && ("get" !== node.kind && "set" !== node.kind);
      if (t.isProperty(node)) return !(node.computed && !this.isPure(node.key, constantsOnly)) && this.isPure(node.value, constantsOnly);
      if (t.isUnaryExpression(node)) return this.isPure(node.argument, constantsOnly);
      if (t.isTaggedTemplateExpression(node)) return t.matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(node.quasi, constantsOnly);
      if (t.isTemplateLiteral(node)) {
        for (const expression of node.expressions) if (!this.isPure(expression, constantsOnly)) return !1;
        return !0;
      }
      return t.isPureish(node);
    }
    setData(key, val) {
      return this.data[key] = val;
    }
    getData(key) {
      let scope = this;
      do {
        const data = scope.data[key];
        if (null != data) return data;
      } while (scope = scope.parent);
    }
    removeData(key) {
      let scope = this;
      do {
        null != scope.data[key] && (scope.data[key] = null);
      } while (scope = scope.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      const path = this.path;
      if (this.references = Object.create(null), this.bindings = Object.create(null), 
      this.globals = Object.create(null), this.uids = Object.create(null), this.data = Object.create(null), 
      path.isFunction()) {
        path.isFunctionExpression() && path.has("id") && !path.get("id").node[t.NOT_LOCAL_BINDING] && this.registerBinding("local", path.get("id"), path);
        const params = path.get("params");
        for (const param of params) this.registerBinding("param", param);
      }
      const programParent = this.getProgramParent();
      if (programParent.crawling) return;
      const state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = !0, path.traverse(collectorVisitor, state), this.crawling = !1;
      for (const path of state.assignments) {
        const ids = path.getBindingIdentifiers();
        for (const name of Object.keys(ids)) path.scope.getBinding(name) || programParent.addGlobal(ids[name]);
        path.scope.registerConstantViolation(path);
      }
      for (const ref of state.references) {
        const binding = ref.scope.getBinding(ref.node.name);
        binding ? binding.reference(ref) : programParent.addGlobal(ref.node);
      }
      for (const path of state.constantViolations) path.scope.registerConstantViolation(path);
    }
    push(opts) {
      let path = this.path;
      path.isBlockStatement() || path.isProgram() || (path = this.getBlockParent().path), 
      path.isSwitchStatement() && (path = (this.getFunctionParent() || this.getProgramParent()).path), 
      (path.isLoop() || path.isCatchClause() || path.isFunction()) && (path.ensureBlock(), 
      path = path.get("body"));
      const unique = opts.unique, kind = opts.kind || "var", blockHoist = null == opts._blockHoist ? 2 : opts._blockHoist, dataKey = `declaration:${kind}:${blockHoist}`;
      let declarPath = !unique && path.getData(dataKey);
      if (!declarPath) {
        const declar = t.variableDeclaration(kind, []);
        declar._blockHoist = blockHoist, [declarPath] = path.unshiftContainer("body", [ declar ]), 
        unique || path.setData(dataKey, declarPath);
      }
      const declarator = t.variableDeclarator(opts.id, opts.init);
      declarPath.node.declarations.push(declarator), this.registerBinding(kind, declarPath.get("declarations").pop());
    }
    getProgramParent() {
      let scope = this;
      do {
        if (scope.path.isProgram()) return scope;
      } while (scope = scope.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let scope = this;
      do {
        if (scope.path.isFunctionParent()) return scope;
      } while (scope = scope.parent);
      return null;
    }
    getBlockParent() {
      let scope = this;
      do {
        if (scope.path.isBlockParent()) return scope;
      } while (scope = scope.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const ids = Object.create(null);
      let scope = this;
      do {
        (0, _defaults.default)(ids, scope.bindings), scope = scope.parent;
      } while (scope);
      return ids;
    }
    getAllBindingsOfKind() {
      const ids = Object.create(null);
      for (const kind of arguments) {
        let scope = this;
        do {
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            binding.kind === kind && (ids[name] = binding);
          }
          scope = scope.parent;
        } while (scope);
      }
      return ids;
    }
    bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    }
    getBinding(name) {
      let previousPath, scope = this;
      do {
        const binding = scope.getOwnBinding(name);
        if (binding && !(previousPath && previousPath.isPattern() && previousPath.parentPath.isFunction() && "param" !== binding.kind)) return binding;
        previousPath = scope.path;
      } while (scope = scope.parent);
    }
    getOwnBinding(name) {
      return this.bindings[name];
    }
    getBindingIdentifier(name) {
      var _this$getBinding;
      return null == (_this$getBinding = this.getBinding(name)) ? void 0 : _this$getBinding.identifier;
    }
    getOwnBindingIdentifier(name) {
      const binding = this.bindings[name];
      return null == binding ? void 0 : binding.identifier;
    }
    hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }
    hasBinding(name, noGlobals) {
      return !!name && (!!this.hasOwnBinding(name) || (!!this.parentHasBinding(name, noGlobals) || (!!this.hasUid(name) || (!(noGlobals || !Scope.globals.includes(name)) || !(noGlobals || !Scope.contextVariables.includes(name))))));
    }
    parentHasBinding(name, noGlobals) {
      var _this$parent;
      return null == (_this$parent = this.parent) ? void 0 : _this$parent.hasBinding(name, noGlobals);
    }
    moveBindingTo(name, scope) {
      const info = this.getBinding(name);
      info && (info.scope.removeOwnBinding(name), info.scope = scope, scope.bindings[name] = info);
    }
    removeOwnBinding(name) {
      delete this.bindings[name];
    }
    removeBinding(name) {
      var _this$getBinding2;
      null == (_this$getBinding2 = this.getBinding(name)) || _this$getBinding2.scope.removeOwnBinding(name);
      let scope = this;
      do {
        scope.uids[name] && (scope.uids[name] = !1);
      } while (scope = scope.parent);
    }
  }
  exports.default = Scope, Scope.globals = Object.keys(_globals.default.builtin), 
  Scope.contextVariables = [ "arguments", "undefined", "Infinity", "NaN" ];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  exports.default = class {
    constructor({identifier: identifier, scope: scope, path: path, kind: kind}) {
      this.identifier = identifier, this.scope = scope, this.path = path, this.kind = kind, 
      this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, 
      this.references = 0, this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(value) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = value);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(path) {
      this.constant = !1, -1 === this.constantViolations.indexOf(path) && this.constantViolations.push(path);
    }
    reference(path) {
      -1 === this.referencePaths.indexOf(path) && (this.referenced = !0, this.references++, 
      this.referencePaths.push(path));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
}, function(module, exports, __webpack_require__) {
  var identity = __webpack_require__(139), overRest = __webpack_require__(317), setToString = __webpack_require__(319);
  module.exports = function(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  };
}, function(module, exports) {
  module.exports = function(value) {
    return value;
  };
}, function(module, exports, __webpack_require__) {
  var eq = __webpack_require__(32), isArrayLike = __webpack_require__(62), isIndex = __webpack_require__(59), isObject = __webpack_require__(14);
  module.exports = function(value, index, object) {
    if (!isObject(object)) return !1;
    var type = typeof index;
    return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = __webpack_require__(323);
}, function(module, exports, __webpack_require__) {
  var base64VLQ = __webpack_require__(143), util = __webpack_require__(29), ArraySet = __webpack_require__(144).ArraySet, MappingList = __webpack_require__(328).MappingList;
  function SourceMapGenerator(aArgs) {
    aArgs || (aArgs = {}), this._file = util.getArg(aArgs, "file", null), this._sourceRoot = util.getArg(aArgs, "sourceRoot", null), 
    this._skipValidation = util.getArg(aArgs, "skipValidation", !1), this._sources = new ArraySet, 
    this._names = new ArraySet, this._mappings = new MappingList, this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3, SourceMapGenerator.fromSourceMap = function(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot, generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    return aSourceMapConsumer.eachMapping((function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      null != mapping.source && (newMapping.source = mapping.source, null != sourceRoot && (newMapping.source = util.relative(sourceRoot, newMapping.source)), 
      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      }, null != mapping.name && (newMapping.name = mapping.name)), generator.addMapping(newMapping);
    })), aSourceMapConsumer.sources.forEach((function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      null != content && generator.setSourceContent(sourceFile, content);
    })), generator;
  }, SourceMapGenerator.prototype.addMapping = function(aArgs) {
    var generated = util.getArg(aArgs, "generated"), original = util.getArg(aArgs, "original", null), source = util.getArg(aArgs, "source", null), name = util.getArg(aArgs, "name", null);
    this._skipValidation || this._validateMapping(generated, original, source, name), 
    null != source && (source = String(source), this._sources.has(source) || this._sources.add(source)), 
    null != name && (name = String(name), this._names.has(name) || this._names.add(name)), 
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: null != original && original.line,
      originalColumn: null != original && original.column,
      source: source,
      name: name
    });
  }, SourceMapGenerator.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    null != this._sourceRoot && (source = util.relative(this._sourceRoot, source)), 
    null != aSourceContent ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), 
    this._sourcesContents[util.toSetString(source)] = aSourceContent) : this._sourcesContents && (delete this._sourcesContents[util.toSetString(source)], 
    0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
  }, SourceMapGenerator.prototype.applySourceMap = function(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (null == aSourceFile) {
      if (null == aSourceMapConsumer.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    null != sourceRoot && (sourceFile = util.relative(sourceRoot, sourceFile));
    var newSources = new ArraySet, newNames = new ArraySet;
    this._mappings.unsortedForEach((function(mapping) {
      if (mapping.source === sourceFile && null != mapping.originalLine) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        null != original.source && (mapping.source = original.source, null != aSourceMapPath && (mapping.source = util.join(aSourceMapPath, mapping.source)), 
        null != sourceRoot && (mapping.source = util.relative(sourceRoot, mapping.source)), 
        mapping.originalLine = original.line, mapping.originalColumn = original.column, 
        null != original.name && (mapping.name = original.name));
      }
      var source = mapping.source;
      null == source || newSources.has(source) || newSources.add(source);
      var name = mapping.name;
      null == name || newNames.has(name) || newNames.add(name);
    }), this), this._sources = newSources, this._names = newNames, aSourceMapConsumer.sources.forEach((function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      null != content && (null != aSourceMapPath && (sourceFile = util.join(aSourceMapPath, sourceFile)), 
      null != sourceRoot && (sourceFile = util.relative(sourceRoot, sourceFile)), this.setSourceContent(sourceFile, content));
    }), this);
  }, SourceMapGenerator.prototype._validateMapping = function(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && "number" != typeof aOriginal.line && "number" != typeof aOriginal.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if ((!(aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0) || aOriginal || aSource || aName) && !(aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource)) throw new Error("Invalid mapping: " + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }, SourceMapGenerator.prototype._serializeMappings = function() {
    for (var next, mapping, nameIdx, sourceIdx, previousGeneratedColumn = 0, previousGeneratedLine = 1, previousOriginalColumn = 0, previousOriginalLine = 0, previousName = 0, previousSource = 0, result = "", mappings = this._mappings.toArray(), i = 0, len = mappings.length; i < len; i++) {
      if (next = "", (mapping = mappings[i]).generatedLine !== previousGeneratedLine) for (previousGeneratedColumn = 0; mapping.generatedLine !== previousGeneratedLine; ) next += ";", 
      previousGeneratedLine++; else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) continue;
        next += ",";
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn), previousGeneratedColumn = mapping.generatedColumn, 
      null != mapping.source && (sourceIdx = this._sources.indexOf(mapping.source), next += base64VLQ.encode(sourceIdx - previousSource), 
      previousSource = sourceIdx, next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine), 
      previousOriginalLine = mapping.originalLine - 1, next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn), 
      previousOriginalColumn = mapping.originalColumn, null != mapping.name && (nameIdx = this._names.indexOf(mapping.name), 
      next += base64VLQ.encode(nameIdx - previousName), previousName = nameIdx)), result += next;
    }
    return result;
  }, SourceMapGenerator.prototype._generateSourcesContent = function(aSources, aSourceRoot) {
    return aSources.map((function(source) {
      if (!this._sourcesContents) return null;
      null != aSourceRoot && (source = util.relative(aSourceRoot, source));
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }), this);
  }, SourceMapGenerator.prototype.toJSON = function() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return null != this._file && (map.file = this._file), null != this._sourceRoot && (map.sourceRoot = this._sourceRoot), 
    this._sourcesContents && (map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot)), 
    map;
  }, SourceMapGenerator.prototype.toString = function() {
    return JSON.stringify(this.toJSON());
  }, exports.SourceMapGenerator = SourceMapGenerator;
}, function(module, exports, __webpack_require__) {
  var base64 = __webpack_require__(327);
  exports.encode = function(aValue) {
    var digit, encoded = "", vlq = function(aValue) {
      return aValue < 0 ? 1 + (-aValue << 1) : 0 + (aValue << 1);
    }(aValue);
    do {
      digit = 31 & vlq, (vlq >>>= 5) > 0 && (digit |= 32), encoded += base64.encode(digit);
    } while (vlq > 0);
    return encoded;
  }, exports.decode = function(aStr, aIndex, aOutParam) {
    var continuation, digit, aValue, shifted, strLen = aStr.length, result = 0, shift = 0;
    do {
      if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
      if (-1 === (digit = base64.decode(aStr.charCodeAt(aIndex++)))) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      continuation = !!(32 & digit), result += (digit &= 31) << shift, shift += 5;
    } while (continuation);
    aOutParam.value = (shifted = (aValue = result) >> 1, 1 == (1 & aValue) ? -shifted : shifted), 
    aOutParam.rest = aIndex;
  };
}, function(module, exports, __webpack_require__) {
  var util = __webpack_require__(29), has = Object.prototype.hasOwnProperty, hasNativeMap = "undefined" != typeof Map;
  function ArraySet() {
    this._array = [], this._set = hasNativeMap ? new Map : Object.create(null);
  }
  ArraySet.fromArray = function(aArray, aAllowDuplicates) {
    for (var set = new ArraySet, i = 0, len = aArray.length; i < len; i++) set.add(aArray[i], aAllowDuplicates);
    return set;
  }, ArraySet.prototype.size = function() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  }, ArraySet.prototype.add = function(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr), isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr), idx = this._array.length;
    isDuplicate && !aAllowDuplicates || this._array.push(aStr), isDuplicate || (hasNativeMap ? this._set.set(aStr, idx) : this._set[sStr] = idx);
  }, ArraySet.prototype.has = function(aStr) {
    if (hasNativeMap) return this._set.has(aStr);
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }, ArraySet.prototype.indexOf = function(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) return idx;
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) return this._set[sStr];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  }, ArraySet.prototype.at = function(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
    throw new Error("No element indexed by " + aIdx);
  }, ArraySet.prototype.toArray = function() {
    return this._array.slice();
  }, exports.ArraySet = ArraySet;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.needsWhitespace = needsWhitespace, exports.needsWhitespaceBefore = function(node, parent) {
    return needsWhitespace(node, parent, "before");
  }, exports.needsWhitespaceAfter = function(node, parent) {
    return needsWhitespace(node, parent, "after");
  }, exports.needsParens = function(node, parent, printStack) {
    if (!parent) return !1;
    if (t.isNewExpression(parent) && parent.callee === node && function isOrHasCallExpression(node) {
      if (t.isCallExpression(node)) return !0;
      return t.isMemberExpression(node) && isOrHasCallExpression(node.object);
    }(node)) return !0;
    return find(expandedParens, node, parent, printStack);
  };
  var whitespace = _interopRequireWildcard(__webpack_require__(335)), parens = _interopRequireWildcard(__webpack_require__(336)), t = _interopRequireWildcard(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function expandAliases(obj) {
    const newObj = {};
    function add(type, func) {
      const fn = newObj[type];
      newObj[type] = fn ? function(node, parent, stack) {
        const result = fn(node, parent, stack);
        return null == result ? func(node, parent, stack) : result;
      } : func;
    }
    for (const type of Object.keys(obj)) {
      const aliases = t.FLIPPED_ALIAS_KEYS[type];
      if (aliases) for (const alias of aliases) add(alias, obj[type]); else add(type, obj[type]);
    }
    return newObj;
  }
  const expandedParens = expandAliases(parens), expandedWhitespaceNodes = expandAliases(whitespace.nodes), expandedWhitespaceList = expandAliases(whitespace.list);
  function find(obj, node, parent, printStack) {
    const fn = obj[node.type];
    return fn ? fn(node, parent, printStack) : null;
  }
  function needsWhitespace(node, parent, type) {
    if (!node) return 0;
    t.isExpressionStatement(node) && (node = node.expression);
    let linesInfo = find(expandedWhitespaceNodes, node, parent);
    if (!linesInfo) {
      const items = find(expandedWhitespaceList, node, parent);
      if (items) for (let i = 0; i < items.length && (linesInfo = needsWhitespace(items[i], node, type), 
      !linesInfo); i++) ;
    }
    return "object" == typeof linesInfo && null !== linesInfo && linesInfo[type] || 0;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.ImportSpecifier = function(node) {
    "type" !== node.importKind && "typeof" !== node.importKind || (this.word(node.importKind), 
    this.space());
    this.print(node.imported, node), node.local && node.local.name !== node.imported.name && (this.space(), 
    this.word("as"), this.space(), this.print(node.local, node));
  }, exports.ImportDefaultSpecifier = function(node) {
    this.print(node.local, node);
  }, exports.ExportDefaultSpecifier = function(node) {
    this.print(node.exported, node);
  }, exports.ExportSpecifier = function(node) {
    this.print(node.local, node), node.exported && node.local.name !== node.exported.name && (this.space(), 
    this.word("as"), this.space(), this.print(node.exported, node));
  }, exports.ExportNamespaceSpecifier = function(node) {
    this.token("*"), this.space(), this.word("as"), this.space(), this.print(node.exported, node);
  }, exports.ExportAllDeclaration = function(node) {
    this.word("export"), this.space(), "type" === node.exportKind && (this.word("type"), 
    this.space());
    this.token("*"), this.space(), this.word("from"), this.space(), this.print(node.source, node), 
    this.semicolon();
  }, exports.ExportNamedDeclaration = function(node) {
    this.format.decoratorsBeforeExport && t.isClassDeclaration(node.declaration) && this.printJoin(node.declaration.decorators, node);
    this.word("export"), this.space(), ExportDeclaration.apply(this, arguments);
  }, exports.ExportDefaultDeclaration = function(node) {
    this.format.decoratorsBeforeExport && t.isClassDeclaration(node.declaration) && this.printJoin(node.declaration.decorators, node);
    this.word("export"), this.space(), this.word("default"), this.space(), ExportDeclaration.apply(this, arguments);
  }, exports.ImportDeclaration = function(node) {
    var _node$attributes;
    this.word("import"), this.space(), ("type" === node.importKind || "typeof" === node.importKind) && (this.word(node.importKind), 
    this.space());
    const specifiers = node.specifiers.slice(0);
    if (null == specifiers ? void 0 : specifiers.length) {
      for (;;) {
        const first = specifiers[0];
        if (!t.isImportDefaultSpecifier(first) && !t.isImportNamespaceSpecifier(first)) break;
        this.print(specifiers.shift(), node), specifiers.length && (this.token(","), this.space());
      }
      specifiers.length && (this.token("{"), this.space(), this.printList(specifiers, node), 
      this.space(), this.token("}")), this.space(), this.word("from"), this.space();
    }
    this.print(node.source, node), (null == (_node$attributes = node.attributes) ? void 0 : _node$attributes.length) && (this.space(), 
    this.word("with"), this.space(), this.printList(node.attributes, node));
    this.semicolon();
  }, exports.ImportAttribute = function(node) {
    this.print(node.key), this.token(":"), this.space(), this.print(node.value);
  }, exports.ImportNamespaceSpecifier = function(node) {
    this.token("*"), this.space(), this.word("as"), this.space(), this.print(node.local, node);
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function ExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node), t.isStatement(declar) || this.semicolon();
    } else {
      "type" === node.exportKind && (this.word("type"), this.space());
      const specifiers = node.specifiers.slice(0);
      let hasSpecial = !1;
      for (;;) {
        const first = specifiers[0];
        if (!t.isExportDefaultSpecifier(first) && !t.isExportNamespaceSpecifier(first)) break;
        hasSpecial = !0, this.print(specifiers.shift(), node), specifiers.length && (this.token(","), 
        this.space());
      }
      (specifiers.length || !specifiers.length && !hasSpecial) && (this.token("{"), specifiers.length && (this.space(), 
      this.printList(specifiers, node), this.space()), this.token("}")), node.source && (this.space(), 
      this.word("from"), this.space(), this.print(node.source, node)), this.semicolon();
    }
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.Identifier = function(node) {
    this.exactSource(node.loc, () => {
      this.word(node.name);
    });
  }, exports.ArgumentPlaceholder = function() {
    this.token("?");
  }, exports.SpreadElement = exports.RestElement = function(node) {
    this.token("..."), this.print(node.argument, node);
  }, exports.ObjectPattern = exports.ObjectExpression = function(node) {
    const props = node.properties;
    this.token("{"), this.printInnerComments(node), props.length && (this.space(), this.printList(props, node, {
      indent: !0,
      statement: !0
    }), this.space());
    this.token("}");
  }, exports.ObjectMethod = function(node) {
    this.printJoin(node.decorators, node), this._methodHead(node), this.space(), this.print(node.body, node);
  }, exports.ObjectProperty = function(node) {
    if (this.printJoin(node.decorators, node), node.computed) this.token("["), this.print(node.key, node), 
    this.token("]"); else {
      if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) return void this.print(node.value, node);
      if (this.print(node.key, node), node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) return;
    }
    this.token(":"), this.space(), this.print(node.value, node);
  }, exports.ArrayPattern = exports.ArrayExpression = function(node) {
    const elems = node.elements, len = elems.length;
    this.token("["), this.printInnerComments(node);
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      elem ? (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.token(",")) : this.token(",");
    }
    this.token("]");
  }, exports.RecordExpression = function(node) {
    const props = node.properties;
    let startToken, endToken;
    if ("bar" === this.format.recordAndTupleSyntaxType) startToken = "{|", endToken = "|}"; else {
      if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
      startToken = "#{", endToken = "}";
    }
    this.token(startToken), this.printInnerComments(node), props.length && (this.space(), 
    this.printList(props, node, {
      indent: !0,
      statement: !0
    }), this.space());
    this.token(endToken);
  }, exports.TupleExpression = function(node) {
    const elems = node.elements, len = elems.length;
    let startToken, endToken;
    if ("bar" === this.format.recordAndTupleSyntaxType) startToken = "[|", endToken = "|]"; else {
      if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
      startToken = "#[", endToken = "]";
    }
    this.token(startToken), this.printInnerComments(node);
    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];
      elem && (i > 0 && this.space(), this.print(elem, node), i < len - 1 && this.token(","));
    }
    this.token(endToken);
  }, exports.RegExpLiteral = function(node) {
    this.word(`/${node.pattern}/${node.flags}`);
  }, exports.BooleanLiteral = function(node) {
    this.word(node.value ? "true" : "false");
  }, exports.NullLiteral = function() {
    this.word("null");
  }, exports.NumericLiteral = function(node) {
    const raw = this.getPossibleRaw(node), opts = this.format.jsescOption, value = node.value + "";
    opts.numbers ? this.number((0, _jsesc.default)(node.value, opts)) : null == raw ? this.number(value) : this.format.minified ? this.number(raw.length < value.length ? raw : value) : this.number(raw);
  }, exports.StringLiteral = function(node) {
    const raw = this.getPossibleRaw(node);
    if (!this.format.minified && null != raw) return void this.token(raw);
    const opts = this.format.jsescOption;
    this.format.jsonCompatibleStrings && (opts.json = !0);
    const val = (0, _jsesc.default)(node.value, opts);
    return this.token(val);
  }, exports.BigIntLiteral = function(node) {
    const raw = this.getPossibleRaw(node);
    if (!this.format.minified && null != raw) return void this.token(raw);
    this.token(node.value + "n");
  }, exports.PipelineTopicExpression = function(node) {
    this.print(node.expression, node);
  }, exports.PipelineBareFunction = function(node) {
    this.print(node.callee, node);
  }, exports.PipelinePrimaryTopicReference = function() {
    this.token("#");
  };
  var obj, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _jsesc = (obj = __webpack_require__(343)) && obj.__esModule ? obj : {
    default: obj
  };
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, visitor, state) {
    path.traverse(visitor, Object.assign({}, handle, state, {
      memoiser: new AssignmentMemoiser
    }));
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  class AssignmentMemoiser {
    constructor() {
      this._map = new WeakMap;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key) {
      if (!this.has(key)) return;
      const record = this._map.get(key), {value: value} = record;
      return record.count--, 0 === record.count ? t.assignmentExpression("=", value, key) : value;
    }
    set(key, value, count) {
      return this._map.set(key, {
        count: count,
        value: value
      });
    }
  }
  function toNonOptional(path, base) {
    const {node: node} = path;
    if (path.isOptionalMemberExpression()) return t.memberExpression(base, node.property, node.computed);
    if (path.isOptionalCallExpression()) {
      const callee = path.get("callee");
      if (path.node.optional && callee.isOptionalMemberExpression()) {
        const {object: object} = callee.node, context = path.scope.maybeGenerateMemoised(object) || object;
        return callee.get("object").replaceWith(t.assignmentExpression("=", context, object)), 
        t.callExpression(t.memberExpression(base, t.identifier("call")), [ context, ...node.arguments ]);
      }
      return t.callExpression(base, node.arguments);
    }
    return path.node;
  }
  const handle = {
    memoise() {},
    handle(member) {
      const {node: node, parent: parent, parentPath: parentPath} = member;
      if (member.isOptionalMemberExpression()) {
        if (function(path) {
          for (;path && !path.isProgram(); ) {
            const {parentPath: parentPath, container: container, listKey: listKey} = path, parentNode = parentPath.node;
            if (listKey) {
              if (container !== parentNode[listKey]) return !0;
            } else if (container !== parentNode) return !0;
            path = parentPath;
          }
          return !1;
        }(member)) return;
        const endPath = member.find(({node: node, parent: parent, parentPath: parentPath}) => parentPath.isOptionalMemberExpression() ? parent.optional || parent.object !== node : !parentPath.isOptionalCallExpression() || (node !== member.node && parent.optional || parent.callee !== node)), rootParentPath = endPath.parentPath;
        if (rootParentPath.isUpdateExpression({
          argument: node
        }) || rootParentPath.isAssignmentExpression({
          left: node
        })) throw member.buildCodeFrameError("can't handle assignment");
        const isDeleteOperation = rootParentPath.isUnaryExpression({
          operator: "delete"
        });
        if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) throw member.buildCodeFrameError("can't delete a private class element");
        let startingOptional = member;
        for (;;) if (startingOptional.isOptionalMemberExpression()) {
          if (startingOptional.node.optional) break;
          startingOptional = startingOptional.get("object");
        } else {
          if (!startingOptional.isOptionalCallExpression()) throw new Error("Internal error: unexpected " + startingOptional.node.type);
          if (startingOptional.node.optional) break;
          startingOptional = startingOptional.get("callee");
        }
        const {scope: scope} = member, startingProp = startingOptional.isOptionalMemberExpression() ? "object" : "callee", startingNode = startingOptional.node[startingProp], baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode), baseRef = null != baseNeedsMemoised ? baseNeedsMemoised : startingNode, parentIsOptionalCall = parentPath.isOptionalCallExpression({
          callee: node
        }), parentIsCall = parentPath.isCallExpression({
          callee: node
        });
        startingOptional.replaceWith(toNonOptional(startingOptional, baseRef)), parentIsOptionalCall ? parent.optional ? parentPath.replaceWith(this.optionalCall(member, parent.arguments)) : parentPath.replaceWith(this.call(member, parent.arguments)) : parentIsCall ? member.replaceWith(this.boundGet(member)) : member.replaceWith(this.get(member));
        let context, regular = member.node;
        for (let current = member; current !== endPath; ) {
          const {parentPath: parentPath} = current;
          if (parentPath === endPath && parentIsOptionalCall && parent.optional) {
            regular = parentPath.node;
            break;
          }
          regular = toNonOptional(parentPath, regular), current = parentPath;
        }
        const endParentPath = endPath.parentPath;
        if (t.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
          callee: endPath.node,
          optional: !0
        })) {
          const {object: object} = regular;
          context = member.scope.maybeGenerateMemoised(object), context && (regular.object = t.assignmentExpression("=", context, object));
        }
        let replacementPath = endPath;
        if (isDeleteOperation && (replacementPath = endParentPath, regular = endParentPath.node), 
        replacementPath.replaceWith(t.conditionalExpression(t.logicalExpression("||", t.binaryExpression("===", baseNeedsMemoised ? t.assignmentExpression("=", t.cloneNode(baseRef), t.cloneNode(startingNode)) : t.cloneNode(baseRef), t.nullLiteral()), t.binaryExpression("===", t.cloneNode(baseRef), scope.buildUndefinedNode())), isDeleteOperation ? t.booleanLiteral(!0) : scope.buildUndefinedNode(), regular)), 
        context) {
          const endParent = endParentPath.node;
          endParentPath.replaceWith(t.optionalCallExpression(t.optionalMemberExpression(endParent.callee, t.identifier("call"), !1, !0), [ t.cloneNode(context), ...endParent.arguments ], !1));
        }
      } else if (parentPath.isUpdateExpression({
        argument: node
      })) {
        if (this.simpleSet) return void member.replaceWith(this.simpleSet(member));
        const {operator: operator, prefix: prefix} = parent;
        this.memoise(member, 2);
        const value = t.binaryExpression(operator[0], t.unaryExpression("+", this.get(member)), t.numericLiteral(1));
        if (prefix) parentPath.replaceWith(this.set(member, value)); else {
          const {scope: scope} = member, ref = scope.generateUidIdentifierBasedOnNode(node);
          scope.push({
            id: ref
          }), value.left = t.assignmentExpression("=", t.cloneNode(ref), value.left), parentPath.replaceWith(t.sequenceExpression([ this.set(member, value), t.cloneNode(ref) ]));
        }
      } else {
        if (parentPath.isAssignmentExpression({
          left: node
        })) {
          if (this.simpleSet) return void member.replaceWith(this.simpleSet(member));
          const {operator: operator, right: right} = parent;
          let value = right;
          return "=" !== operator && (this.memoise(member, 2), value = t.binaryExpression(operator.slice(0, -1), this.get(member), value)), 
          void parentPath.replaceWith(this.set(member, value));
        }
        parentPath.isCallExpression({
          callee: node
        }) ? parentPath.replaceWith(this.call(member, parent.arguments)) : parentPath.isOptionalCallExpression({
          callee: node
        }) ? parentPath.replaceWith(this.optionalCall(member, parent.arguments)) : parentPath.isForXStatement({
          left: node
        }) || parentPath.isObjectProperty({
          value: node
        }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
          left: node
        }) && parentPath.parentPath.isObjectProperty({
          value: parent
        }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
          left: node
        }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement() ? member.replaceWith(this.destructureSet(member)) : member.replaceWith(this.get(member));
      }
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.hasOwnDecorators = hasOwnDecorators, exports.hasDecorators = function(node) {
    return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
  }, exports.buildDecoratedClass = function(ref, path, elements, file) {
    const {node: node, scope: scope} = path, initializeId = scope.generateUidIdentifier("initialize"), isDeclaration = node.id && path.isDeclaration(), isStrict = path.isInStrictMode(), {superClass: superClass} = node;
    node.type = "ClassDeclaration", node.id || (node.id = _core.types.cloneNode(ref));
    let superId;
    superClass && (superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super"), 
    node.superClass = superId);
    const classDecorators = takeDecorators(node), definitions = _core.types.arrayExpression(elements.filter(element => !element.node.abstract).map(extractElementDescriptor.bind(file, node.id, superId)));
    let replacement = _core.template.expression.ast`
    ${function(file) {
      try {
        return file.addHelper("decorate");
      } catch (err) {
        throw "BABEL_HELPER_UNKNOWN" === err.code && (err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version."), 
        err;
      }
    }(file)}(
      ${classDecorators || _core.types.nullLiteral()},
      function (${initializeId}, ${superClass ? _core.types.cloneNode(superId) : null}) {
        ${node}
        return { F: ${_core.types.cloneNode(node.id)}, d: ${definitions} };
      },
      ${superClass}
    )
  `, classPathDesc = "arguments.1.body.body.0";
    isStrict || replacement.arguments[1].body.directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
    isDeclaration && (replacement = _core.template.ast`let ${ref} = ${replacement}`, 
    classPathDesc = "declarations.0.init." + classPathDesc);
    return {
      instanceNodes: [ _core.template.statement.ast`${_core.types.cloneNode(initializeId)}(this)` ],
      wrapClass: path => (path.replaceWith(replacement), path.get(classPathDesc))
    };
  };
  var _core = __webpack_require__(2), _helperReplaceSupers = _interopRequireDefault(__webpack_require__(21)), _helperFunctionName = _interopRequireDefault(__webpack_require__(8));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function hasOwnDecorators(node) {
    return !(!node.decorators || !node.decorators.length);
  }
  function prop(key, value) {
    return value ? _core.types.objectProperty(_core.types.identifier(key), value) : null;
  }
  function takeDecorators(node) {
    let result;
    return node.decorators && node.decorators.length > 0 && (result = _core.types.arrayExpression(node.decorators.map(decorator => decorator.expression))), 
    node.decorators = void 0, result;
  }
  function getKey(node) {
    return node.computed ? node.key : _core.types.isIdentifier(node.key) ? _core.types.stringLiteral(node.key.name) : _core.types.stringLiteral(String(node.key.value));
  }
  function extractElementDescriptor(classRef, superRef, path) {
    const {node: node, scope: scope} = path, isMethod = path.isClassMethod();
    if (path.isPrivate()) throw path.buildCodeFrameError(`Private ${isMethod ? "methods" : "fields"} in decorated classes are not supported yet.`);
    new _helperReplaceSupers.default({
      methodPath: path,
      methodNode: node,
      objectRef: classRef,
      isStatic: node.static,
      superRef: superRef,
      scope: scope,
      file: this
    }, !0).replace();
    const properties = [ prop("kind", _core.types.stringLiteral(isMethod ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node.static && _core.types.booleanLiteral(!0)), prop("key", getKey(node)) ].filter(Boolean);
    if (isMethod) {
      const id = node.computed ? null : node.key;
      _core.types.toExpression(node), properties.push(prop("value", (0, _helperFunctionName.default)({
        node: node,
        id: id,
        scope: scope
      }) || node));
    } else node.value ? properties.push((key = "value", body = _core.template.statements.ast`return ${node.value}`, 
    _core.types.objectMethod("method", _core.types.identifier(key), [], _core.types.blockStatement(body)))) : properties.push(prop("value", scope.buildUndefinedNode()));
    var key, body;
    return path.remove(), _core.types.objectExpression(properties);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), Object.defineProperty(exports, "convertFunctionParams", {
    enumerable: !0,
    get: function() {
      return _params.default;
    }
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _params = _interopRequireDefault(__webpack_require__(375)), _rest = _interopRequireDefault(__webpack_require__(376));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose} = options;
    return {
      name: "transform-parameters",
      visitor: {
        Function(path) {
          path.isArrowFunctionExpression() && path.get("params").some(param => param.isRestElement() || param.isAssignmentPattern()) && path.arrowFunctionToExpression();
          const convertedRest = (0, _rest.default)(path), convertedParams = (0, _params.default)(path, loose);
          (convertedRest || convertedParams) && path.scope.crawl();
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.enableFeature = function(features, feature) {
    return features | feature;
  }, exports.hasFeature = function(features, feature) {
    return !!(features & feature);
  }, exports.runtimeKey = exports.featuresKey = exports.FEATURES = void 0;
  const FEATURES = Object.freeze({
    unicodeFlag: 1,
    dotAllFlag: 2,
    unicodePropertyEscape: 4,
    namedCaptureGroups: 8
  });
  exports.FEATURES = FEATURES;
  exports.featuresKey = "@babel/plugin-regexp-features/featuresKey";
  exports.runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.is = function(node, flag) {
    return "RegExpLiteral" === node.type && node.flags.indexOf(flag) >= 0;
  }, exports.pullFlag = function(node, flag) {
    const flags = node.flags.split("");
    if (node.flags.indexOf(flag) < 0) return;
    (0, _pull.default)(flags, flag), node.flags = flags.join("");
  };
  var obj, _pull = (obj = __webpack_require__(384)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports) {
  module.exports = function(array, iteratee) {
    for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; ) result[index] = iteratee(array[index], index, array);
    return result;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path) {
    const {sourceType: sourceType} = path.node;
    if ("module" !== sourceType && "script" !== sourceType) throw path.buildCodeFrameError(`Unknown sourceType "${sourceType}", cannot transform.`);
    return "module" === path.node.sourceType;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, bindingNames) {
    path.traverse(simpleAssignmentVisitor, {
      scope: path.scope,
      bindingNames: bindingNames,
      seen: new WeakSet
    });
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const simpleAssignmentVisitor = {
    UpdateExpression: {
      exit(path) {
        const {scope: scope, bindingNames: bindingNames} = this, arg = path.get("argument");
        if (!arg.isIdentifier()) return;
        const localName = arg.node.name;
        if (bindingNames.has(localName) && scope.getBinding(localName) === path.scope.getBinding(localName)) if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
          const operator = "++" == path.node.operator ? "+=" : "-=";
          path.replaceWith(t.assignmentExpression(operator, arg.node, t.numericLiteral(1)));
        } else if (path.node.prefix) path.replaceWith(t.assignmentExpression("=", t.identifier(localName), t.binaryExpression(path.node.operator[0], t.unaryExpression("+", arg.node), t.numericLiteral(1)))); else {
          const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old"), varName = old.name;
          path.scope.push({
            id: old
          });
          const binary = t.binaryExpression(path.node.operator[0], t.identifier(varName), t.numericLiteral(1));
          path.replaceWith(t.sequenceExpression([ t.assignmentExpression("=", t.identifier(varName), t.unaryExpression("+", arg.node)), t.assignmentExpression("=", t.cloneNode(arg.node), binary), t.identifier(varName) ]));
        }
      }
    },
    AssignmentExpression: {
      exit(path) {
        const {scope: scope, seen: seen, bindingNames: bindingNames} = this;
        if ("=" === path.node.operator) return;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        const left = path.get("left");
        if (!left.isIdentifier()) return;
        const localName = left.node.name;
        bindingNames.has(localName) && scope.getBinding(localName) === path.scope.getBinding(localName) && (path.node.right = t.binaryExpression(path.node.operator.slice(0, -1), t.cloneNode(path.node.left), path.node.right), 
        path.node.operator = "=");
      }
    }
  };
}, function(module, exports) {
  module.exports = require("path");
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _interopRequireWildcard = __webpack_require__(48), _assert = __webpack_require__(49)(__webpack_require__(11)), leap = _interopRequireWildcard(__webpack_require__(450)), meta = _interopRequireWildcard(__webpack_require__(451)), util = _interopRequireWildcard(__webpack_require__(22)), hasOwn = Object.prototype.hasOwnProperty;
  function Emitter(contextId) {
    _assert.default.ok(this instanceof Emitter), util.getTypes().assertIdentifier(contextId), 
    this.nextTempId = 0, this.contextId = contextId, this.listing = [], this.marked = [ !0 ], 
    this.insertedLocs = new Set, this.finalLoc = this.loc(), this.tryEntries = [], this.leapManager = new leap.LeapManager(this);
  }
  var Ep = Emitter.prototype;
  function getDeclError(node) {
    return new Error("all declarations should have been transformed into assignments before the Exploder began its work: " + JSON.stringify(node));
  }
  exports.Emitter = Emitter, Ep.loc = function() {
    var l = util.getTypes().numericLiteral(-1);
    return this.insertedLocs.add(l), l;
  }, Ep.getInsertedLocs = function() {
    return this.insertedLocs;
  }, Ep.getContextId = function() {
    return util.getTypes().clone(this.contextId);
  }, Ep.mark = function(loc) {
    util.getTypes().assertLiteral(loc);
    var index = this.listing.length;
    return -1 === loc.value ? loc.value = index : _assert.default.strictEqual(loc.value, index), 
    this.marked[index] = !0, loc;
  }, Ep.emit = function(node) {
    var t = util.getTypes();
    t.isExpression(node) && (node = t.expressionStatement(node)), t.assertStatement(node), 
    this.listing.push(node);
  }, Ep.emitAssign = function(lhs, rhs) {
    return this.emit(this.assign(lhs, rhs)), lhs;
  }, Ep.assign = function(lhs, rhs) {
    var t = util.getTypes();
    return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
  }, Ep.contextProperty = function(name, computed) {
    var t = util.getTypes();
    return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
  }, Ep.stop = function(rval) {
    rval && this.setReturnValue(rval), this.jump(this.finalLoc);
  }, Ep.setReturnValue = function(valuePath) {
    util.getTypes().assertExpression(valuePath.value), this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
  }, Ep.clearPendingException = function(tryLoc, assignee) {
    var t = util.getTypes();
    t.assertLiteral(tryLoc);
    var catchCall = t.callExpression(this.contextProperty("catch", !0), [ t.clone(tryLoc) ]);
    assignee ? this.emitAssign(assignee, catchCall) : this.emit(catchCall);
  }, Ep.jump = function(toLoc) {
    this.emitAssign(this.contextProperty("next"), toLoc), this.emit(util.getTypes().breakStatement());
  }, Ep.jumpIf = function(test, toLoc) {
    var t = util.getTypes();
    t.assertExpression(test), t.assertLiteral(toLoc), this.emit(t.ifStatement(test, t.blockStatement([ this.assign(this.contextProperty("next"), toLoc), t.breakStatement() ])));
  }, Ep.jumpIfNot = function(test, toLoc) {
    var negatedTest, t = util.getTypes();
    t.assertExpression(test), t.assertLiteral(toLoc), negatedTest = t.isUnaryExpression(test) && "!" === test.operator ? test.argument : t.unaryExpression("!", test), 
    this.emit(t.ifStatement(negatedTest, t.blockStatement([ this.assign(this.contextProperty("next"), toLoc), t.breakStatement() ])));
  }, Ep.makeTempVar = function() {
    return this.contextProperty("t" + this.nextTempId++);
  }, Ep.getContextFunction = function(id) {
    var t = util.getTypes();
    return t.functionExpression(id || null, [ this.getContextId() ], t.blockStatement([ this.getDispatchLoop() ]), !1, !1);
  }, Ep.getDispatchLoop = function() {
    var current, self = this, t = util.getTypes(), cases = [], alreadyEnded = !1;
    return self.listing.forEach((function(stmt, i) {
      self.marked.hasOwnProperty(i) && (cases.push(t.switchCase(t.numericLiteral(i), current = [])), 
      alreadyEnded = !1), alreadyEnded || (current.push(stmt), t.isCompletionStatement(stmt) && (alreadyEnded = !0));
    })), this.finalLoc.value = this.listing.length, cases.push(t.switchCase(this.finalLoc, []), t.switchCase(t.stringLiteral("end"), [ t.returnStatement(t.callExpression(this.contextProperty("stop"), [])) ])), 
    t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
  }, Ep.getTryLocsList = function() {
    if (0 === this.tryEntries.length) return null;
    var t = util.getTypes(), lastLocValue = 0;
    return t.arrayExpression(this.tryEntries.map((function(tryEntry) {
      var thisLocValue = tryEntry.firstLoc.value;
      _assert.default.ok(thisLocValue >= lastLocValue, "try entries out of order"), lastLocValue = thisLocValue;
      var ce = tryEntry.catchEntry, fe = tryEntry.finallyEntry, locs = [ tryEntry.firstLoc, ce ? ce.firstLoc : null ];
      return fe && (locs[2] = fe.firstLoc, locs[3] = fe.afterLoc), t.arrayExpression(locs.map((function(loc) {
        return loc && t.clone(loc);
      })));
    })));
  }, Ep.explode = function(path, ignoreResult) {
    var t = util.getTypes(), node = path.node;
    if (t.assertNode(node), t.isDeclaration(node)) throw getDeclError(node);
    if (t.isStatement(node)) return this.explodeStatement(path);
    if (t.isExpression(node)) return this.explodeExpression(path, ignoreResult);
    switch (node.type) {
     case "Program":
      return path.get("body").map(this.explodeStatement, this);

     case "VariableDeclarator":
      throw getDeclError(node);

     case "Property":
     case "SwitchCase":
     case "CatchClause":
      throw new Error(node.type + " nodes should be handled by their parents");

     default:
      throw new Error("unknown Node of type " + JSON.stringify(node.type));
    }
  }, Ep.explodeStatement = function(path, labelId) {
    var before, after, head, t = util.getTypes(), stmt = path.node, self = this;
    if (t.assertStatement(stmt), labelId ? t.assertIdentifier(labelId) : labelId = null, 
    t.isBlockStatement(stmt)) path.get("body").forEach((function(path) {
      self.explodeStatement(path);
    })); else if (meta.containsLeap(stmt)) switch (stmt.type) {
     case "ExpressionStatement":
      self.explodeExpression(path.get("expression"), !0);
      break;

     case "LabeledStatement":
      after = this.loc(), self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), (function() {
        self.explodeStatement(path.get("body"), stmt.label);
      })), self.mark(after);
      break;

     case "WhileStatement":
      before = this.loc(), after = this.loc(), self.mark(before), self.jumpIfNot(self.explodeExpression(path.get("test")), after), 
      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), (function() {
        self.explodeStatement(path.get("body"));
      })), self.jump(before), self.mark(after);
      break;

     case "DoWhileStatement":
      var first = this.loc(), test = this.loc();
      after = this.loc(), self.mark(first), self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), (function() {
        self.explode(path.get("body"));
      })), self.mark(test), self.jumpIf(self.explodeExpression(path.get("test")), first), 
      self.mark(after);
      break;

     case "ForStatement":
      head = this.loc();
      var update = this.loc();
      after = this.loc(), stmt.init && self.explode(path.get("init"), !0), self.mark(head), 
      stmt.test && self.jumpIfNot(self.explodeExpression(path.get("test")), after), self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), (function() {
        self.explodeStatement(path.get("body"));
      })), self.mark(update), stmt.update && self.explode(path.get("update"), !0), self.jump(head), 
      self.mark(after);
      break;

     case "TypeCastExpression":
      return self.explodeExpression(path.get("expression"));

     case "ForInStatement":
      head = this.loc(), after = this.loc();
      var keyIterNextFn = self.makeTempVar();
      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty("keys"), [ self.explodeExpression(path.get("right")) ])), 
      self.mark(head);
      var keyInfoTmpVar = self.makeTempVar();
      self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), !1), after), 
      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), !1)), 
      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), (function() {
        self.explodeStatement(path.get("body"));
      })), self.jump(head), self.mark(after);
      break;

     case "BreakStatement":
      self.emitAbruptCompletion({
        type: "break",
        target: self.leapManager.getBreakLoc(stmt.label)
      });
      break;

     case "ContinueStatement":
      self.emitAbruptCompletion({
        type: "continue",
        target: self.leapManager.getContinueLoc(stmt.label)
      });
      break;

     case "SwitchStatement":
      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
      after = this.loc();
      for (var defaultLoc = this.loc(), condition = defaultLoc, caseLocs = [], cases = stmt.cases || [], i = cases.length - 1; i >= 0; --i) {
        var c = cases[i];
        t.assertSwitchCase(c), c.test ? condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition) : caseLocs[i] = defaultLoc;
      }
      var discriminant = path.get("discriminant");
      util.replaceWithOrRemove(discriminant, condition), self.jump(self.explodeExpression(discriminant)), 
      self.leapManager.withEntry(new leap.SwitchEntry(after), (function() {
        path.get("cases").forEach((function(casePath) {
          var i = casePath.key;
          self.mark(caseLocs[i]), casePath.get("consequent").forEach((function(path) {
            self.explodeStatement(path);
          }));
        }));
      })), self.mark(after), -1 === defaultLoc.value && (self.mark(defaultLoc), _assert.default.strictEqual(after.value, defaultLoc.value));
      break;

     case "IfStatement":
      var elseLoc = stmt.alternate && this.loc();
      after = this.loc(), self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after), 
      self.explodeStatement(path.get("consequent")), elseLoc && (self.jump(after), self.mark(elseLoc), 
      self.explodeStatement(path.get("alternate"))), self.mark(after);
      break;

     case "ReturnStatement":
      self.emitAbruptCompletion({
        type: "return",
        value: self.explodeExpression(path.get("argument"))
      });
      break;

     case "WithStatement":
      throw new Error("WithStatement not supported in generator functions.");

     case "TryStatement":
      after = this.loc();
      var handler = stmt.handler, catchLoc = handler && this.loc(), catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param), finallyLoc = stmt.finalizer && this.loc(), finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after), tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
      self.tryEntries.push(tryEntry), self.updateContextPrevLoc(tryEntry.firstLoc), self.leapManager.withEntry(tryEntry, (function() {
        if (self.explodeStatement(path.get("block")), catchLoc) {
          finallyLoc ? self.jump(finallyLoc) : self.jump(after), self.updateContextPrevLoc(self.mark(catchLoc));
          var bodyPath = path.get("handler.body"), safeParam = self.makeTempVar();
          self.clearPendingException(tryEntry.firstLoc, safeParam), bodyPath.traverse(catchParamVisitor, {
            getSafeParam: function() {
              return t.cloneDeep(safeParam);
            },
            catchParamName: handler.param.name
          }), self.leapManager.withEntry(catchEntry, (function() {
            self.explodeStatement(bodyPath);
          }));
        }
        finallyLoc && (self.updateContextPrevLoc(self.mark(finallyLoc)), self.leapManager.withEntry(finallyEntry, (function() {
          self.explodeStatement(path.get("finalizer"));
        })), self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [ finallyEntry.firstLoc ]))));
      })), self.mark(after);
      break;

     case "ThrowStatement":
      self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
      break;

     default:
      throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
    } else self.emit(stmt);
  };
  var catchParamVisitor = {
    Identifier: function(path, state) {
      path.node.name === state.catchParamName && util.isReference(path) && util.replaceWithOrRemove(path, state.getSafeParam());
    },
    Scope: function(path, state) {
      path.scope.hasOwnBinding(state.catchParamName) && path.skip();
    }
  };
  Ep.emitAbruptCompletion = function(record) {
    (function(record) {
      var type = record.type;
      if ("normal" === type) return !hasOwn.call(record, "target");
      if ("break" === type || "continue" === type) return !hasOwn.call(record, "value") && util.getTypes().isLiteral(record.target);
      if ("return" === type || "throw" === type) return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
      return !1;
    })(record) || _assert.default.ok(!1, "invalid completion record: " + JSON.stringify(record)), 
    _assert.default.notStrictEqual(record.type, "normal", "normal completions are not abrupt");
    var t = util.getTypes(), abruptArgs = [ t.stringLiteral(record.type) ];
    "break" === record.type || "continue" === record.type ? (t.assertLiteral(record.target), 
    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target)) : "return" !== record.type && "throw" !== record.type || record.value && (t.assertExpression(record.value), 
    abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value)), 
    this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
  }, Ep.getUnmarkedCurrentLoc = function() {
    return util.getTypes().numericLiteral(this.listing.length);
  }, Ep.updateContextPrevLoc = function(loc) {
    var t = util.getTypes();
    loc ? (t.assertLiteral(loc), -1 === loc.value ? loc.value = this.listing.length : _assert.default.strictEqual(loc.value, this.listing.length)) : loc = this.getUnmarkedCurrentLoc(), 
    this.emitAssign(this.contextProperty("prev"), loc);
  }, Ep.explodeExpression = function(path, ignoreResult) {
    var t = util.getTypes(), expr = path.node;
    if (!expr) return expr;
    t.assertExpression(expr);
    var result, after, self = this;
    function finish(expr) {
      if (t.assertExpression(expr), !ignoreResult) return expr;
      self.emit(expr);
    }
    if (!meta.containsLeap(expr)) return finish(expr);
    var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);
    function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
      _assert.default.ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to be assigned to a temporary variable?");
      var result = self.explodeExpression(childPath, ignoreChildResult);
      return ignoreChildResult || (tempVar || hasLeapingChildren && !t.isLiteral(result)) && (result = self.emitAssign(tempVar || self.makeTempVar(), result)), 
      result;
    }
    switch (expr.type) {
     case "MemberExpression":
      return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));

     case "CallExpression":
      var newCallee, newArgs, calleePath = path.get("callee"), argsPath = path.get("arguments"), hasLeapingArgs = argsPath.some((function(argPath) {
        return meta.containsLeap(argPath.node);
      })), injectFirstArg = null;
      if (t.isMemberExpression(calleePath.node)) if (hasLeapingArgs) {
        var newObject = explodeViaTempVar(self.makeTempVar(), calleePath.get("object")), newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.node.property;
        injectFirstArg = newObject, newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), !1);
      } else newCallee = self.explodeExpression(calleePath); else newCallee = explodeViaTempVar(null, calleePath), 
      t.isMemberExpression(newCallee) && (newCallee = t.sequenceExpression([ t.numericLiteral(0), t.cloneDeep(newCallee) ]));
      return hasLeapingArgs ? (newArgs = argsPath.map((function(argPath) {
        return explodeViaTempVar(null, argPath);
      })), injectFirstArg && newArgs.unshift(injectFirstArg), newArgs = newArgs.map((function(arg) {
        return t.cloneDeep(arg);
      }))) : newArgs = path.node.arguments, finish(t.callExpression(newCallee, newArgs));

     case "NewExpression":
      return finish(t.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map((function(argPath) {
        return explodeViaTempVar(null, argPath);
      }))));

     case "ObjectExpression":
      return finish(t.objectExpression(path.get("properties").map((function(propPath) {
        return propPath.isObjectProperty() ? t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get("value")), propPath.node.computed) : propPath.node;
      }))));

     case "ArrayExpression":
      return finish(t.arrayExpression(path.get("elements").map((function(elemPath) {
        return elemPath.isSpreadElement() ? t.spreadElement(explodeViaTempVar(null, elemPath.get("argument"))) : explodeViaTempVar(null, elemPath);
      }))));

     case "SequenceExpression":
      var lastIndex = expr.expressions.length - 1;
      return path.get("expressions").forEach((function(exprPath) {
        exprPath.key === lastIndex ? result = self.explodeExpression(exprPath, ignoreResult) : self.explodeExpression(exprPath, !0);
      })), result;

     case "LogicalExpression":
      after = this.loc(), ignoreResult || (result = self.makeTempVar());
      var left = explodeViaTempVar(result, path.get("left"));
      return "&&" === expr.operator ? self.jumpIfNot(left, after) : (_assert.default.strictEqual(expr.operator, "||"), 
      self.jumpIf(left, after)), explodeViaTempVar(result, path.get("right"), ignoreResult), 
      self.mark(after), result;

     case "ConditionalExpression":
      var elseLoc = this.loc();
      after = this.loc();
      var test = self.explodeExpression(path.get("test"));
      return self.jumpIfNot(test, elseLoc), ignoreResult || (result = self.makeTempVar()), 
      explodeViaTempVar(result, path.get("consequent"), ignoreResult), self.jump(after), 
      self.mark(elseLoc), explodeViaTempVar(result, path.get("alternate"), ignoreResult), 
      self.mark(after), result;

     case "UnaryExpression":
      return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));

     case "BinaryExpression":
      return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));

     case "AssignmentExpression":
      if ("=" === expr.operator) return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
      var lhs = self.explodeExpression(path.get("left")), temp = self.emitAssign(self.makeTempVar(), lhs);
      return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

     case "UpdateExpression":
      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

     case "YieldExpression":
      after = this.loc();
      var arg = expr.argument && self.explodeExpression(path.get("argument"));
      if (arg && expr.delegate) {
        var _result = self.makeTempVar(), _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [ arg, t.stringLiteral(_result.property.name), after ]));
        return _ret.loc = expr.loc, self.emit(_ret), self.mark(after), _result;
      }
      self.emitAssign(self.contextProperty("next"), after);
      var ret = t.returnStatement(t.cloneDeep(arg) || null);
      return ret.loc = expr.loc, self.emit(ret), self.mark(after), self.contextProperty("sent");

     default:
      throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {compare: compare, intersection: intersection, semver: semver} = __webpack_require__(476), modulesByVersions = __webpack_require__(487), modules = __webpack_require__(488);
  module.exports = function(raw) {
    const corejs = semver(raw);
    if (3 !== corejs.major) throw RangeError("This version of `core-js-compat` works only with `core-js@3`.");
    const result = [];
    for (const version of Object.keys(modulesByVersions)) compare(version, "<=", corejs) && result.push(...modulesByVersions[version]);
    return intersection(result, modules);
  };
}, function(module, exports) {
  const debug = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const array = [], charCodeCache = [], leven = (left, right) => {
    if (left === right) return 0;
    const swap = left;
    left.length > right.length && (left = right, right = swap);
    let leftLength = left.length, rightLength = right.length;
    for (;leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength); ) leftLength--, 
    rightLength--;
    let bCharCode, result, temp, temp2, start = 0;
    for (;start < leftLength && left.charCodeAt(start) === right.charCodeAt(start); ) start++;
    if (leftLength -= start, rightLength -= start, 0 === leftLength) return rightLength;
    let i = 0, j = 0;
    for (;i < leftLength; ) charCodeCache[i] = left.charCodeAt(start + i), array[i] = ++i;
    for (;j < rightLength; ) for (bCharCode = right.charCodeAt(start + j), temp = j++, 
    result = j, i = 0; i < leftLength; i++) temp2 = bCharCode === charCodeCache[i] ? temp : temp + 1, 
    temp = array[i], result = array[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
    return result;
  };
  module.exports = leven, module.exports.default = leven;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.isPluginRequired = function(targets, support) {
    return (0, _helperCompilationTargets.isRequired)("fake-name", targets, {
      compatData: {
        "fake-name": support
      }
    });
  }, exports.default = exports.getPolyfillPlugins = exports.getModulesPluginNames = exports.transformIncludesAndExcludes = void 0;
  __webpack_require__(19);
  var _debug = __webpack_require__(24), _getOptionSpecificExcludes = _interopRequireDefault(__webpack_require__(169)), _filterItems = __webpack_require__(170), _moduleTransformations = _interopRequireDefault(__webpack_require__(83)), _normalizeOptions = _interopRequireDefault(__webpack_require__(171)), _shippedProposals = __webpack_require__(468), _pluginsCompatData = __webpack_require__(84), _overlappingPlugins = _interopRequireDefault(__webpack_require__(469)), _usagePlugin = _interopRequireDefault(__webpack_require__(471)), _usagePlugin2 = _interopRequireDefault(__webpack_require__(473)), _usagePlugin3 = _interopRequireDefault(__webpack_require__(490)), _entryPlugin = _interopRequireDefault(__webpack_require__(491)), _entryPlugin2 = _interopRequireDefault(__webpack_require__(492)), _entryPlugin3 = _interopRequireDefault(__webpack_require__(494)), _helperCompilationTargets = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(20)), _availablePlugins = _interopRequireDefault(__webpack_require__(85)), _utils = __webpack_require__(18), _helperPluginUtils = __webpack_require__(0);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const pluginLists = {
    withProposals: {
      withoutBugfixes: _pluginsCompatData.plugins,
      withBugfixes: Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes)
    },
    withoutProposals: {
      withoutBugfixes: (0, _utils.filterStageFromList)(_pluginsCompatData.plugins, _shippedProposals.proposalPlugins),
      withBugfixes: (0, _utils.filterStageFromList)(Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes), _shippedProposals.proposalPlugins)
    }
  };
  const getPlugin = pluginName => {
    const plugin = _availablePlugins.default[pluginName];
    if (!plugin) throw new Error(`Could not find plugin "${pluginName}". Ensure there is an entry in ./available-plugins.js for it.`);
    return plugin;
  }, transformIncludesAndExcludes = opts => opts.reduce((result, opt) => (result[opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins"].add(opt), 
  result), {
    all: opts,
    plugins: new Set,
    builtIns: new Set
  });
  exports.transformIncludesAndExcludes = transformIncludesAndExcludes;
  const getModulesPluginNames = ({modules: modules, transformations: transformations, shouldTransformESM: shouldTransformESM, shouldTransformDynamicImport: shouldTransformDynamicImport, shouldParseTopLevelAwait: shouldParseTopLevelAwait}) => {
    const modulesPluginNames = [];
    return !1 !== modules && transformations[modules] ? (shouldTransformESM && modulesPluginNames.push(transformations[modules]), 
    shouldTransformDynamicImport && shouldTransformESM && "umd" !== modules ? modulesPluginNames.push("proposal-dynamic-import") : (shouldTransformDynamicImport && console.warn("Dynamic import can only be supported when transforming ES modules to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled."), 
    modulesPluginNames.push("syntax-dynamic-import"))) : modulesPluginNames.push("syntax-dynamic-import"), 
    shouldParseTopLevelAwait && modulesPluginNames.push("syntax-top-level-await"), modulesPluginNames;
  };
  exports.getModulesPluginNames = getModulesPluginNames;
  const getPolyfillPlugins = ({useBuiltIns: useBuiltIns, corejs: corejs, polyfillTargets: polyfillTargets, include: include, exclude: exclude, proposals: proposals, shippedProposals: shippedProposals, regenerator: regenerator, debug: debug}) => {
    const polyfillPlugins = [];
    if ("usage" === useBuiltIns || "entry" === useBuiltIns) {
      const pluginOptions = {
        corejs: corejs,
        polyfillTargets: polyfillTargets,
        include: include,
        exclude: exclude,
        proposals: proposals,
        shippedProposals: shippedProposals,
        regenerator: regenerator,
        debug: debug
      };
      corejs && ("usage" === useBuiltIns ? (2 === corejs.major ? polyfillPlugins.push([ _usagePlugin.default, pluginOptions ]) : polyfillPlugins.push([ _usagePlugin2.default, pluginOptions ]), 
      regenerator && polyfillPlugins.push([ _usagePlugin3.default, pluginOptions ])) : 2 === corejs.major ? polyfillPlugins.push([ _entryPlugin.default, pluginOptions ]) : (polyfillPlugins.push([ _entryPlugin2.default, pluginOptions ]), 
      regenerator || polyfillPlugins.push([ _entryPlugin3.default, pluginOptions ])));
    }
    return polyfillPlugins;
  };
  function supportsStaticESM(caller) {
    return !!(null == caller ? void 0 : caller.supportsStaticESM);
  }
  function supportsDynamicImport(caller) {
    return !!(null == caller ? void 0 : caller.supportsDynamicImport);
  }
  function supportsTopLevelAwait(caller) {
    return !!(null == caller ? void 0 : caller.supportsTopLevelAwait);
  }
  exports.getPolyfillPlugins = getPolyfillPlugins;
  var _default = (0, _helperPluginUtils.declare)((api, opts) => {
    api.assertVersion(7);
    const {bugfixes: bugfixes, configPath: configPath, debug: debug, exclude: optionsExclude, forceAllTransforms: forceAllTransforms, ignoreBrowserslistConfig: ignoreBrowserslistConfig, include: optionsInclude, loose: loose, modules: modules, shippedProposals: shippedProposals, spec: spec, targets: optionsTargets, useBuiltIns: useBuiltIns, corejs: {version: corejs, proposals: proposals}, browserslistEnv: browserslistEnv} = (0, 
    _normalizeOptions.default)(opts);
    let hasUglifyTarget = !1;
    (null == optionsTargets ? void 0 : optionsTargets.uglify) && (hasUglifyTarget = !0, 
    delete optionsTargets.uglify, console.log(""), console.log("The uglify target has been deprecated. Set the top level"), 
    console.log("option `forceAllTransforms: true` instead."), console.log("")), (null == optionsTargets ? void 0 : optionsTargets.esmodules) && optionsTargets.browsers && (console.log(""), 
    console.log("@babel/preset-env: esmodules and browsers targets have been specified together."), 
    console.log(`\`browsers\` target, \`${optionsTargets.browsers}\` will be ignored.`), 
    console.log(""));
    const targets = (0, _helperCompilationTargets.default)(optionsTargets, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath,
      browserslistEnv: browserslistEnv
    }), include = transformIncludesAndExcludes(optionsInclude), exclude = transformIncludesAndExcludes(optionsExclude), transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets, modulesPluginNames = getModulesPluginNames({
      modules: modules,
      transformations: _moduleTransformations.default,
      shouldTransformESM: "auto" !== modules || !(null == api.caller ? void 0 : api.caller(supportsStaticESM)),
      shouldTransformDynamicImport: "auto" !== modules || !(null == api.caller ? void 0 : api.caller(supportsDynamicImport)),
      shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
    }), pluginNames = (0, _helperCompilationTargets.filterItems)(function(proposals, bugfixes) {
      return proposals ? bugfixes ? pluginLists.withProposals.withBugfixes : pluginLists.withProposals.withoutBugfixes : bugfixes ? pluginLists.withoutProposals.withBugfixes : pluginLists.withoutProposals.withoutBugfixes;
    }(shippedProposals, bugfixes), include.plugins, exclude.plugins, transformTargets, modulesPluginNames, (0, 
    _getOptionSpecificExcludes.default)({
      loose: loose
    }), _shippedProposals.pluginSyntaxMap);
    (0, _filterItems.removeUnnecessaryItems)(pluginNames, _overlappingPlugins.default);
    const polyfillPlugins = getPolyfillPlugins({
      useBuiltIns: useBuiltIns,
      corejs: corejs,
      polyfillTargets: targets,
      include: include.builtIns,
      exclude: exclude.builtIns,
      proposals: proposals,
      shippedProposals: shippedProposals,
      regenerator: pluginNames.has("transform-regenerator"),
      debug: debug
    }), pluginUseBuiltIns = !1 !== useBuiltIns, plugins = Array.from(pluginNames).map(pluginName => "proposal-class-properties" === pluginName || "proposal-private-methods" === pluginName || "proposal-private-property-in-object" === pluginName ? [ getPlugin(pluginName), {
      loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
    } ] : [ getPlugin(pluginName), {
      spec: spec,
      loose: loose,
      useBuiltIns: pluginUseBuiltIns
    } ]).concat(polyfillPlugins);
    return debug && (console.log("@babel/preset-env: `DEBUG` option"), console.log("\nUsing targets:"), 
    console.log(JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2)), 
    console.log("\nUsing modules transform: " + modules.toString()), console.log("\nUsing plugins:"), 
    pluginNames.forEach(pluginName => {
      (0, _debug.logPluginOrPolyfill)(pluginName, targets, _pluginsCompatData.plugins);
    }), useBuiltIns ? console.log(`\nUsing polyfills with \`${useBuiltIns}\` option:`) : console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.")), 
    {
      plugins: plugins
    };
  });
  exports.default = _default;
}, function(module, exports) {
  module.exports = require("browserslist");
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(164);
}, function(module) {
  module.exports = JSON.parse('{"es6.module":{"edge":"16","firefox":"60","chrome":"61","safari":"10.1","opera":"48","ios_saf":"10.3","android":"61","op_mob":"48","and_chr":"61","and_ff":"60","samsung":"8.2"}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.TargetNames = void 0;
  exports.TargetNames = {
    node: "node",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung"
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.getInclusionReasons = function(item, targetVersions, list) {
    const minVersions = list[item] || {};
    return Object.keys(targetVersions).reduce((result, env) => {
      const minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env), targetVersion = targetVersions[env];
      if (minVersion) {
        const minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env);
        (0, _utils.isUnreleasedVersion)(targetVersion, env) || !minIsUnreleased && !_semver.default.lt(targetVersion.toString(), (0, 
        _utils.semverify)(minVersion)) || (result[env] = (0, _pretty.prettifyVersion)(targetVersion));
      } else result[env] = (0, _pretty.prettifyVersion)(targetVersion);
      return result;
    }, {});
  };
  var obj, _semver = (obj = __webpack_require__(19)) && obj.__esModule ? obj : {
    default: obj
  }, _pretty = __webpack_require__(81), _utils = __webpack_require__(51);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.targetsSupported = targetsSupported, exports.isRequired = isRequired, 
  exports.default = function(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
    const result = new Set, options = {
      compatData: list,
      includes: includes,
      excludes: excludes
    };
    for (const item in list) if (isRequired(item, targets, options)) result.add(item); else if (pluginSyntaxMap) {
      const shippedProposalsSyntax = pluginSyntaxMap.get(item);
      shippedProposalsSyntax && result.add(shippedProposalsSyntax);
    }
    defaultIncludes && defaultIncludes.forEach(item => !excludes.has(item) && result.add(item));
    defaultExcludes && defaultExcludes.forEach(item => !includes.has(item) && result.delete(item));
    return result;
  };
  var _semver = _interopRequireDefault(__webpack_require__(19)), _plugins = _interopRequireDefault(__webpack_require__(82)), _utils = __webpack_require__(51);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function targetsSupported(target, support) {
    const targetEnvironments = Object.keys(target);
    if (0 === targetEnvironments.length) return !1;
    return 0 === targetEnvironments.filter(environment => {
      const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
      if (!lowestImplementedVersion) return !0;
      const lowestTargetedVersion = target[environment];
      if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) return !1;
      if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) return !0;
      if (!_semver.default.valid(lowestTargetedVersion.toString())) throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". Versions must be in semver format (major.minor.patch)`);
      return _semver.default.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
    }).length;
  }
  function isRequired(name, targets, {compatData: compatData = _plugins.default, includes: includes, excludes: excludes} = {}) {
    return !(null == excludes ? void 0 : excludes.has(name)) && (!!(null == includes ? void 0 : includes.has(name)) || !targetsSupported(targets, compatData[name]));
  }
}, function(module) {
  module.exports = JSON.parse('{"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","ios":"13","samsung":"11","electron":"6"},"proposal-class-properties":{"chrome":"74","opera":"61","edge":"79","node":"12","samsung":"11","electron":"6"},"proposal-private-methods":{"chrome":"84"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","electron":"8.1"},"proposal-optional-chaining":{"chrome":"80","opera":"67","edge":"80","firefox":"74","safari":"13.1","node":"14","electron":"8.1"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","ios":"12","samsung":"9","electron":"3"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","ios":"12","samsung":"8","electron":"3"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","ios":"11.3","samsung":"8","electron":"2"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","ios":"11.3","samsung":"8","electron":"3"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","ios":"11","samsung":"6","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","ios":"10.3","samsung":"6","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","ios":"13","samsung":"3.4","electron":"0.22"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"45","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","ie":"11","ios":"10","samsung":"3.4","electron":"0.22"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.28"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","ios":"8","samsung":"4","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","ios":"12","samsung":"5","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"36","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-block-scoping":{"chrome":"49","opera":"36","edge":"14","firefox":"51","safari":"11","node":"6","ios":"11","samsung":"5","electron":"0.37"},"transform-typeof-symbol":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","ios":"9","samsung":"3","electron":"0.20"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4.4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function({loose: loose}) {
    return loose ? defaultExcludesForLooseMode : null;
  };
  const defaultExcludesForLooseMode = [ "transform-typeof-symbol" ];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.removeUnnecessaryItems = function(items, overlapping) {
    items.forEach(item => {
      var _overlapping$item;
      null == (_overlapping$item = overlapping[item]) || _overlapping$item.forEach(name => items.delete(name));
    });
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.normalizeCoreJSOption = normalizeCoreJSOption, exports.default = function(opts) {
    (options => {
      const validOptions = Object.keys(_options.TopLevelOptions);
      for (const option in options) if (!_options.TopLevelOptions[option]) throw new Error(`Invalid Option: ${option} is not a valid top-level option.\n        Maybe you meant to use '${(0, 
      _levenary.default)(option, validOptions)}'?`);
    })(opts);
    const useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns), corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns), include = expandIncludesAndExcludes(opts.include, _options.TopLevelOptions.include, !!corejs.version && corejs.version.major), exclude = expandIncludesAndExcludes(opts.exclude, _options.TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
    checkDuplicateIncludeExcludes(include, exclude);
    const shippedProposals = validateBoolOption(_options.TopLevelOptions.shippedProposals, opts.shippedProposals, !1);
    return {
      bugfixes: validateBoolOption(_options.TopLevelOptions.bugfixes, opts.bugfixes, !1),
      configPath: validateConfigPathOption(opts.configPath),
      corejs: corejs,
      debug: validateBoolOption(_options.TopLevelOptions.debug, opts.debug, !1),
      include: include,
      exclude: exclude,
      forceAllTransforms: validateBoolOption(_options.TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, !1),
      ignoreBrowserslistConfig: validateIgnoreBrowserslistConfig(opts.ignoreBrowserslistConfig),
      loose: validateBoolOption(_options.TopLevelOptions.loose, opts.loose, !1),
      modules: validateModulesOption(opts.modules),
      shippedProposals: shippedProposals,
      spec: validateBoolOption(_options.TopLevelOptions.spec, opts.spec, !1),
      targets: normalizeTargets(opts.targets),
      useBuiltIns: useBuiltIns,
      browserslistEnv: validateStringOption(_options.TopLevelOptions.browserslistEnv, opts.browserslistEnv)
    };
  }, exports.validateUseBuiltInsOption = exports.validateModulesOption = exports.validateIgnoreBrowserslistConfig = exports.validateStringOption = exports.validateBoolOption = exports.validateConfigPathOption = exports.checkDuplicateIncludeExcludes = exports.normalizePluginName = void 0;
  var _data = _interopRequireDefault(__webpack_require__(53)), _levenary = _interopRequireDefault(__webpack_require__(80)), _invariant = _interopRequireDefault(__webpack_require__(50)), _semver = __webpack_require__(19), _corejs2BuiltIns = _interopRequireDefault(__webpack_require__(54)), _pluginsCompatData = __webpack_require__(84), _moduleTransformations = _interopRequireDefault(__webpack_require__(83)), _options = __webpack_require__(467), _getPlatformSpecificDefault = __webpack_require__(76);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const allPluginsList = Object.keys(_pluginsCompatData.plugins), modulePlugins = [ "proposal-dynamic-import", ...Object.keys(_moduleTransformations.default).map(m => _moduleTransformations.default[m]) ], selectPlugins = (regexp, type, corejs) => Array.from(((type, corejs) => new Set([ ...allPluginsList, ..."exclude" === type ? modulePlugins : [], ...corejs ? 2 == corejs ? [ ...Object.keys(_corejs2BuiltIns.default), ..._getPlatformSpecificDefault.defaultWebIncludes ] : Object.keys(_data.default) : [] ]))(type, corejs)).filter(item => regexp instanceof RegExp && regexp.test(item)), expandIncludesAndExcludes = (plugins = [], type, corejs) => {
    if (0 === plugins.length) return [];
    const selectedPlugins = plugins.map(plugin => selectPlugins((plugin => {
      if (plugin instanceof RegExp) return plugin;
      try {
        return new RegExp(`^${normalizePluginName(plugin)}$`);
      } catch (e) {
        return null;
      }
    })(plugin), type, corejs)), invalidRegExpList = plugins.filter((p, i) => 0 === selectedPlugins[i].length);
    return (0, _invariant.default)(0 === invalidRegExpList.length, `Invalid Option: The plugins/built-ins '${invalidRegExpList.join(", ")}' passed to the '${type}' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`), 
    array = selectedPlugins, [].concat(...array);
    var array;
  }, normalizePluginName = plugin => plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
  exports.normalizePluginName = normalizePluginName;
  const checkDuplicateIncludeExcludes = (include = [], exclude = []) => {
    const duplicates = include.filter(opt => exclude.indexOf(opt) >= 0);
    (0, _invariant.default)(0 === duplicates.length, `Invalid Option: The plugins/built-ins '${duplicates.join(", ")}' were found in both the "include" and\n    "exclude" options.`);
  };
  exports.checkDuplicateIncludeExcludes = checkDuplicateIncludeExcludes;
  const normalizeTargets = targets => "string" == typeof targets || Array.isArray(targets) ? {
    browsers: targets
  } : Object.assign({}, targets), validateConfigPathOption = (configPath = process.cwd()) => ((0, 
  _invariant.default)("string" == typeof configPath, `Invalid Option: The configPath option '${configPath}' is invalid, only strings are allowed.`), 
  configPath);
  exports.validateConfigPathOption = validateConfigPathOption;
  const validateBoolOption = (name, value, defaultValue) => {
    if (void 0 === value && (value = defaultValue), "boolean" != typeof value) throw new Error(`Preset env: '${name}' option must be a boolean.`);
    return value;
  };
  exports.validateBoolOption = validateBoolOption;
  const validateStringOption = (name, value, defaultValue) => {
    if (void 0 === value) value = defaultValue; else if ("string" != typeof value) throw new Error(`Preset env: '${name}' option must be a string.`);
    return value;
  };
  exports.validateStringOption = validateStringOption;
  const validateIgnoreBrowserslistConfig = ignoreBrowserslistConfig => validateBoolOption(_options.TopLevelOptions.ignoreBrowserslistConfig, ignoreBrowserslistConfig, !1);
  exports.validateIgnoreBrowserslistConfig = validateIgnoreBrowserslistConfig;
  const validateModulesOption = (modulesOpt = _options.ModulesOption.auto) => ((0, 
  _invariant.default)(_options.ModulesOption[modulesOpt.toString()] || modulesOpt === _options.ModulesOption.false, "Invalid Option: The 'modules' option must be one of \n - 'false' to indicate no module processing\n - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs' - 'auto' (default) which will automatically select 'false' if the current\n   process is known to support ES module syntax, or \"commonjs\" otherwise\n"), 
  modulesOpt);
  exports.validateModulesOption = validateModulesOption;
  const validateUseBuiltInsOption = (builtInsOpt = !1) => ((0, _invariant.default)(_options.UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === _options.UseBuiltInsOption.false, "Invalid Option: The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file"), 
  builtInsOpt);
  function normalizeCoreJSOption(corejs, useBuiltIns) {
    let rawVersion, proposals = !1;
    useBuiltIns && void 0 === corejs ? (rawVersion = 2, console.warn("\nWARNING: We noticed you're using the `useBuiltIns` option without declaring a core-js version. Currently, we assume version 2.x when no version is passed. Since this default version will likely change in future versions of Babel, we recommend explicitly setting the core-js version you are using via the `corejs` option.\n\nYou should also be sure that the version you pass to the `corejs` option matches the version specified in your `package.json`'s `dependencies` section. If it doesn't, you need to run one of the following commands:\n\n  npm install --save core-js@2    npm install --save core-js@3\n  yarn add core-js@2              yarn add core-js@3\n")) : "object" == typeof corejs && null !== corejs ? (rawVersion = corejs.version, 
    proposals = Boolean(corejs.proposals)) : rawVersion = corejs;
    const version = !!rawVersion && (0, _semver.coerce)(String(rawVersion));
    if (!useBuiltIns && version && console.log("\nThe `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n"), 
    useBuiltIns && (!version || version.major < 2 || version.major > 3)) throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, only core-js@2 and core-js@3 are supported.");
    return {
      version: version,
      proposals: proposals
    };
  }
  exports.validateUseBuiltInsOption = validateUseBuiltInsOption;
}, function(module) {
  module.exports = JSON.parse('{"es6.array.copy-within":{"chrome":"45","opera":"32","edge":"12","firefox":"32","safari":"9","node":"4","ios":"9","samsung":"5","electron":"0.32"},"es6.array.every":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.fill":{"chrome":"45","opera":"32","edge":"12","firefox":"31","safari":"7.1","node":"4","ios":"8","samsung":"5","electron":"0.32"},"es6.array.filter":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.find":{"chrome":"45","opera":"32","edge":"12","firefox":"25","safari":"7.1","node":"4","ios":"8","samsung":"5","electron":"0.32"},"es6.array.find-index":{"chrome":"45","opera":"32","edge":"12","firefox":"25","safari":"7.1","node":"4","ios":"8","samsung":"5","electron":"0.32"},"es7.array.flat-map":{"chrome":"69","opera":"56","edge":"79","firefox":"62","safari":"12","node":"11","ios":"12","samsung":"10","electron":"4"},"es6.array.for-each":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.from":{"chrome":"51","opera":"38","edge":"15","firefox":"36","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es7.array.includes":{"chrome":"47","opera":"34","edge":"14","firefox":"43","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.36"},"es6.array.index-of":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.is-array":{"chrome":"5","opera":"10.50","edge":"12","firefox":"4","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.iterator":{"chrome":"38","opera":"25","edge":"12","firefox":"28","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.array.last-index-of":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.map":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.of":{"chrome":"45","opera":"32","edge":"12","firefox":"25","safari":"9","node":"4","ios":"9","samsung":"5","electron":"0.32"},"es6.array.reduce":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.reduce-right":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.some":{"chrome":"5","opera":"10.10","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.array.sort":{"chrome":"63","opera":"50","edge":"12","firefox":"5","safari":"12","node":"10","ie":"9","ios":"12","samsung":"8","electron":"3"},"es6.array.species":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.date.now":{"chrome":"5","opera":"10.50","edge":"12","firefox":"2","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.date.to-iso-string":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3.5","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.date.to-json":{"chrome":"5","opera":"12.10","edge":"12","firefox":"4","safari":"10","node":"0.10","ie":"9","android":"4","ios":"10","samsung":"1","electron":"0.20"},"es6.date.to-primitive":{"chrome":"47","opera":"34","edge":"15","firefox":"44","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.36"},"es6.date.to-string":{"chrome":"5","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"10","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.function.bind":{"chrome":"7","opera":"12","edge":"12","firefox":"4","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.function.has-instance":{"chrome":"51","opera":"38","edge":"15","firefox":"50","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.function.name":{"chrome":"5","opera":"10.50","edge":"14","firefox":"2","safari":"4","node":"0.10","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.map":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.math.acosh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.asinh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.atanh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.cbrt":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.clz32":{"chrome":"38","opera":"25","edge":"12","firefox":"31","safari":"9","node":"0.12","ios":"9","samsung":"3","electron":"0.20"},"es6.math.cosh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.expm1":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.fround":{"chrome":"38","opera":"25","edge":"12","firefox":"26","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.hypot":{"chrome":"38","opera":"25","edge":"12","firefox":"27","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.imul":{"chrome":"30","opera":"17","edge":"12","firefox":"23","safari":"7","node":"0.12","android":"4.4","ios":"7","samsung":"2","electron":"0.20"},"es6.math.log1p":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.log10":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.log2":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.sign":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"3","electron":"0.20"},"es6.math.sinh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.tanh":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.math.trunc":{"chrome":"38","opera":"25","edge":"12","firefox":"25","safari":"7.1","node":"0.12","ios":"8","samsung":"3","electron":"0.20"},"es6.number.constructor":{"chrome":"41","opera":"28","edge":"12","firefox":"36","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.number.epsilon":{"chrome":"34","opera":"21","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.number.is-finite":{"chrome":"19","opera":"15","edge":"12","firefox":"16","safari":"9","node":"0.12","android":"4.1","ios":"9","samsung":"1.5","electron":"0.20"},"es6.number.is-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"16","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.number.is-nan":{"chrome":"19","opera":"15","edge":"12","firefox":"15","safari":"9","node":"0.12","android":"4.1","ios":"9","samsung":"1.5","electron":"0.20"},"es6.number.is-safe-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"32","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.number.max-safe-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"31","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.number.min-safe-integer":{"chrome":"34","opera":"21","edge":"12","firefox":"31","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.number.parse-float":{"chrome":"34","opera":"21","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.number.parse-int":{"chrome":"34","opera":"21","edge":"12","firefox":"25","safari":"9","node":"0.12","ios":"9","samsung":"2","electron":"0.20"},"es6.object.assign":{"chrome":"49","opera":"36","edge":"13","firefox":"36","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.object.create":{"chrome":"5","opera":"12","edge":"12","firefox":"4","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es7.object.define-getter":{"chrome":"62","opera":"49","edge":"16","firefox":"48","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3"},"es7.object.define-setter":{"chrome":"62","opera":"49","edge":"16","firefox":"48","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3"},"es6.object.define-property":{"chrome":"5","opera":"12","edge":"12","firefox":"4","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.object.define-properties":{"chrome":"5","opera":"12","edge":"12","firefox":"4","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es7.object.entries":{"chrome":"54","opera":"41","edge":"14","firefox":"47","safari":"10.1","node":"7","ios":"10.3","samsung":"6","electron":"1.5"},"es6.object.freeze":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es6.object.get-own-property-descriptor":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es7.object.get-own-property-descriptors":{"chrome":"54","opera":"41","edge":"15","firefox":"50","safari":"10.1","node":"7","ios":"10.3","samsung":"6","electron":"1.5"},"es6.object.get-own-property-names":{"chrome":"40","opera":"27","edge":"12","firefox":"33","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.21"},"es6.object.get-prototype-of":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es7.object.lookup-getter":{"chrome":"62","opera":"49","edge":"79","firefox":"36","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3"},"es7.object.lookup-setter":{"chrome":"62","opera":"49","edge":"79","firefox":"36","safari":"9","node":"8.10","ios":"9","samsung":"8","electron":"3"},"es6.object.prevent-extensions":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es6.object.to-string":{"chrome":"57","opera":"44","edge":"15","firefox":"51","safari":"10","node":"8","ios":"10","samsung":"7","electron":"1.7"},"es6.object.is":{"chrome":"19","opera":"15","edge":"12","firefox":"22","safari":"9","node":"0.12","android":"4.1","ios":"9","samsung":"1.5","electron":"0.20"},"es6.object.is-frozen":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es6.object.is-sealed":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es6.object.is-extensible":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es6.object.keys":{"chrome":"40","opera":"27","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.21"},"es6.object.seal":{"chrome":"44","opera":"31","edge":"12","firefox":"35","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"es6.object.set-prototype-of":{"chrome":"34","opera":"21","edge":"12","firefox":"31","safari":"9","node":"0.12","ie":"11","ios":"9","samsung":"2","electron":"0.20"},"es7.object.values":{"chrome":"54","opera":"41","edge":"14","firefox":"47","safari":"10.1","node":"7","ios":"10.3","samsung":"6","electron":"1.5"},"es6.promise":{"chrome":"51","opera":"38","edge":"14","firefox":"45","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es7.promise.finally":{"chrome":"63","opera":"50","edge":"18","firefox":"58","safari":"11.1","node":"10","ios":"11.3","samsung":"8","electron":"3"},"es6.reflect.apply":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.construct":{"chrome":"49","opera":"36","edge":"13","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.define-property":{"chrome":"49","opera":"36","edge":"13","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.delete-property":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.get":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.get-own-property-descriptor":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.get-prototype-of":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.has":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.is-extensible":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.own-keys":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.prevent-extensions":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.set":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.reflect.set-prototype-of":{"chrome":"49","opera":"36","edge":"12","firefox":"42","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"es6.regexp.constructor":{"chrome":"50","opera":"37","edge":"79","firefox":"40","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.flags":{"chrome":"49","opera":"36","edge":"79","firefox":"37","safari":"9","node":"6","ios":"9","samsung":"5","electron":"0.37"},"es6.regexp.match":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.replace":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.split":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.search":{"chrome":"50","opera":"37","edge":"79","firefox":"49","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.regexp.to-string":{"chrome":"50","opera":"37","edge":"79","firefox":"39","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"es6.set":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.symbol":{"chrome":"51","opera":"38","edge":"79","firefox":"51","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es7.symbol.async-iterator":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","ios":"12","samsung":"8","electron":"3"},"es6.string.anchor":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.big":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.blink":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.bold":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.code-point-at":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.ends-with":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.fixed":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.fontcolor":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.fontsize":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.from-code-point":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.includes":{"chrome":"41","opera":"28","edge":"12","firefox":"40","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.italics":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.iterator":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","ios":"9","samsung":"3","electron":"0.20"},"es6.string.link":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es7.string.pad-start":{"chrome":"57","opera":"44","edge":"15","firefox":"48","safari":"10","node":"8","ios":"10","samsung":"7","electron":"1.7"},"es7.string.pad-end":{"chrome":"57","opera":"44","edge":"15","firefox":"48","safari":"10","node":"8","ios":"10","samsung":"7","electron":"1.7"},"es6.string.raw":{"chrome":"41","opera":"28","edge":"12","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.repeat":{"chrome":"41","opera":"28","edge":"12","firefox":"24","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.small":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.starts-with":{"chrome":"41","opera":"28","edge":"12","firefox":"29","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"es6.string.strike":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.sub":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.sup":{"chrome":"5","opera":"15","edge":"12","firefox":"17","safari":"6","node":"0.10","android":"4","ios":"7","phantom":"2","samsung":"1","electron":"0.20"},"es6.string.trim":{"chrome":"5","opera":"10.50","edge":"12","firefox":"3.5","safari":"4","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es7.string.trim-left":{"chrome":"66","opera":"53","edge":"79","firefox":"61","safari":"12","node":"10","ios":"12","samsung":"9","electron":"3"},"es7.string.trim-right":{"chrome":"66","opera":"53","edge":"79","firefox":"61","safari":"12","node":"10","ios":"12","samsung":"9","electron":"3"},"es6.typed.array-buffer":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.data-view":{"chrome":"5","opera":"12","edge":"12","firefox":"15","safari":"5.1","node":"0.10","ie":"10","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"es6.typed.int8-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint8-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint8-clamped-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.int16-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint16-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.int32-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.uint32-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.float32-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.typed.float64-array":{"chrome":"51","opera":"38","edge":"13","firefox":"48","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"es6.weak-map":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"9","node":"6.5","ios":"9","samsung":"5","electron":"1.2"},"es6.weak-set":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"9","node":"6.5","ios":"9","samsung":"5","electron":"1.2"}}');
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(174);
}, function(module) {
  module.exports = JSON.parse('{"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"10.1","node":"7.6","ios":"10.3","samsung":"6","electron":"1.6"},"bugfix/transform-async-arrows-in-class":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","ios":"11","samsung":"6","electron":"1.6"},"transform-parameters":{"chrome":"49","opera":"36","edge":"15","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"bugfix/transform-edge-default-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"52","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"transform-function-name":{"chrome":"51","opera":"38","edge":"14","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"bugfix/transform-edge-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-block-scoping":{"chrome":"49","opera":"36","edge":"14","firefox":"51","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"bugfix/transform-safari-block-shadowing":{"chrome":"49","opera":"36","edge":"12","firefox":"44","safari":"11","node":"6","ie":"11","ios":"11","samsung":"5","electron":"0.37"},"bugfix/transform-safari-for-shadowing":{"chrome":"49","opera":"36","edge":"12","firefox":"4","safari":"11","node":"6","ie":"11","ios":"11","samsung":"5","electron":"0.37"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.22"},"bugfix/transform-tagged-template-caching":{"chrome":"41","opera":"28","edge":"12","firefox":"34","safari":"13","node":"4","ios":"13","samsung":"3.4","electron":"0.22"}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-class-properties",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "syntax-top-level-await",
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("topLevelAwait");
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _helperRemapAsyncToGenerator = _interopRequireDefault(__webpack_require__(94)), _pluginSyntaxAsyncGenerators = _interopRequireDefault(__webpack_require__(86)), _core = __webpack_require__(2), _forAwait = _interopRequireDefault(__webpack_require__(305));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var _default = (0, _helperPluginUtils.declare)(api => {
    api.assertVersion(7);
    const yieldStarVisitor = {
      Function(path) {
        path.skip();
      },
      YieldExpression({node: node}, state) {
        if (!node.delegate) return;
        const callee = state.addHelper("asyncGeneratorDelegate");
        node.argument = _core.types.callExpression(callee, [ _core.types.callExpression(state.addHelper("asyncIterator"), [ node.argument ]), state.addHelper("awaitAsyncGenerator") ]);
      }
    }, forAwaitVisitor = {
      Function(path) {
        path.skip();
      },
      ForOfStatement(path, {file: file}) {
        const {node: node} = path;
        if (!node.await) return;
        const build = (0, _forAwait.default)(path, {
          getAsyncIterator: file.addHelper("asyncIterator")
        }), {declar: declar, loop: loop} = build, block = loop.body;
        path.ensureBlock(), declar && block.body.push(declar), block.body = block.body.concat(node.body.body), 
        _core.types.inherits(loop, node), _core.types.inherits(loop.body, node.body), build.replaceParent ? path.parentPath.replaceWithMultiple(build.node) : path.replaceWithMultiple(build.node);
      }
    }, visitor = {
      Function(path, state) {
        path.node.async && (path.traverse(forAwaitVisitor, state), path.node.generator && (path.traverse(yieldStarVisitor, state), 
        (0, _helperRemapAsyncToGenerator.default)(path, {
          wrapAsync: state.addHelper("wrapAsyncGenerator"),
          wrapAwait: state.addHelper("awaitAsyncGenerator")
        })));
      }
    };
    return {
      name: "proposal-async-generator-functions",
      inherits: _pluginSyntaxAsyncGenerators.default,
      visitor: {
        Program(path, state) {
          path.traverse(visitor, state);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, callId) {
    path.isClassMethod() || path.isObjectMethod() ? function(path, callId) {
      const node = path.node, body = node.body, container = t.functionExpression(null, [], t.blockStatement(body.body), !0);
      body.body = [ t.returnStatement(t.callExpression(t.callExpression(callId, [ container ]), [])) ], 
      node.async = !1, node.generator = !1, path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
    }(path, callId) : function(path, callId) {
      const node = path.node, isDeclaration = path.isFunctionDeclaration(), functionId = node.id, wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;
      path.isArrowFunctionExpression() && path.arrowFunctionToExpression();
      node.id = null, isDeclaration && (node.type = "FunctionExpression");
      const built = t.callExpression(callId, [ node ]), container = wrapper({
        NAME: functionId || null,
        REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
        FUNCTION: built,
        PARAMS: node.params.reduce((acc, param) => (acc.done = acc.done || t.isAssignmentPattern(param) || t.isRestElement(param), 
        acc.done || acc.params.push(path.scope.generateUidIdentifier("x")), acc), {
          params: [],
          done: !1
        }).params
      });
      if (isDeclaration) path.replaceWith(container[0]), path.insertAfter(container[1]); else {
        const retFunction = container.callee.body.body[1].argument;
        functionId || (0, _helperFunctionName.default)({
          node: retFunction,
          parent: path.parent,
          scope: path.scope
        }), !retFunction || retFunction.id || node.params.length ? path.replaceWith(container) : path.replaceWith(built);
      }
    }(path, callId);
  };
  var _helperFunctionName = _interopRequireDefault(__webpack_require__(8)), _template = _interopRequireDefault(__webpack_require__(41)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const buildAnonymousExpressionWrapper = _template.default.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n"), buildNamedExpressionWrapper = _template.default.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n"), buildDeclarationWrapper = (0, 
  _template.default)("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    const params = node.params;
    for (let i = 0; i < params.length; i++) {
      const param = params[i];
      if (t.isAssignmentPattern(param) || t.isRestElement(param)) return i;
    }
    return params.length;
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  var obj;
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, ((obj = __webpack_require__(95)) && obj.__esModule ? obj : {
    default: obj
  }).default)("React.Component");
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    const elements = [];
    for (let i = 0; i < node.children.length; i++) {
      let child = node.children[i];
      (0, _generated.isJSXText)(child) ? (0, _cleanJSXElementLiteralChild.default)(child, elements) : ((0, 
      _generated.isJSXExpressionContainer)(child) && (child = child.expression), (0, _generated.isJSXEmptyExpression)(child) || elements.push(child));
    }
    return elements;
  };
  var obj, _generated = __webpack_require__(3), _cleanJSXElementLiteralChild = (obj = __webpack_require__(183)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;
    for (let i = 0; i < lines.length; i++) lines[i].match(/[^ \t]/) && (lastNonEmptyLine = i);
    let str = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i], isFirstLine = 0 === i, isLastLine = i === lines.length - 1, isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");
      isFirstLine || (trimmedLine = trimmedLine.replace(/^[ ]+/, "")), isLastLine || (trimmedLine = trimmedLine.replace(/[ ]+$/, "")), 
      trimmedLine && (isLastNonEmptyLine || (trimmedLine += " "), str += trimmedLine);
    }
    str && args.push((0, _generated.stringLiteral)(str));
  };
  var _generated = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(type, ...args) {
    const keys = _definitions.BUILDER_KEYS[type], countArgs = args.length;
    if (countArgs > keys.length) throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
    const node = {
      type: type
    };
    let i = 0;
    keys.forEach(key => {
      const field = _definitions.NODE_FIELDS[type][key];
      let arg;
      i < countArgs && (arg = args[i]), void 0 === arg && (arg = (0, _clone.default)(field.default)), 
      node[key] = arg, i++;
    });
    for (const key of Object.keys(node)) (0, _validate.default)(node, key, node[key]);
    return node;
  };
  var _clone = _interopRequireDefault(__webpack_require__(185)), _definitions = __webpack_require__(5), _validate = _interopRequireDefault(__webpack_require__(69));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  var baseClone = __webpack_require__(186);
  module.exports = function(value) {
    return baseClone(value, 4);
  };
}, function(module, exports, __webpack_require__) {
  var Stack = __webpack_require__(187), arrayEach = __webpack_require__(216), assignValue = __webpack_require__(101), baseAssign = __webpack_require__(217), baseAssignIn = __webpack_require__(225), cloneBuffer = __webpack_require__(228), copyArray = __webpack_require__(108), copySymbols = __webpack_require__(229), copySymbolsIn = __webpack_require__(231), getAllKeys = __webpack_require__(232), getAllKeysIn = __webpack_require__(233), getTag = __webpack_require__(65), initCloneArray = __webpack_require__(238), initCloneByTag = __webpack_require__(239), initCloneObject = __webpack_require__(245), isArray = __webpack_require__(15), isBuffer = __webpack_require__(106), isMap = __webpack_require__(247), isObject = __webpack_require__(14), isSet = __webpack_require__(249), keys = __webpack_require__(57), keysIn = __webpack_require__(38), cloneableTags = {};
  cloneableTags["[object Arguments]"] = cloneableTags["[object Array]"] = cloneableTags["[object ArrayBuffer]"] = cloneableTags["[object DataView]"] = cloneableTags["[object Boolean]"] = cloneableTags["[object Date]"] = cloneableTags["[object Float32Array]"] = cloneableTags["[object Float64Array]"] = cloneableTags["[object Int8Array]"] = cloneableTags["[object Int16Array]"] = cloneableTags["[object Int32Array]"] = cloneableTags["[object Map]"] = cloneableTags["[object Number]"] = cloneableTags["[object Object]"] = cloneableTags["[object RegExp]"] = cloneableTags["[object Set]"] = cloneableTags["[object String]"] = cloneableTags["[object Symbol]"] = cloneableTags["[object Uint8Array]"] = cloneableTags["[object Uint8ClampedArray]"] = cloneableTags["[object Uint16Array]"] = cloneableTags["[object Uint32Array]"] = !0, 
  cloneableTags["[object Error]"] = cloneableTags["[object Function]"] = cloneableTags["[object WeakMap]"] = !1, 
  module.exports = function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = 1 & bitmask, isFlat = 2 & bitmask, isFull = 4 & bitmask;
    if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), 
    void 0 !== result) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
      if (result = initCloneArray(value), !isDeep) return copyArray(value, result);
    } else {
      var tag = getTag(value), isFunc = "[object Function]" == tag || "[object GeneratorFunction]" == tag;
      if (isBuffer(value)) return cloneBuffer(value, isDeep);
      if ("[object Object]" == tag || "[object Arguments]" == tag || isFunc && !object) {
        if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      } else {
        if (!cloneableTags[tag]) return object ? value : {};
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result), isSet(value) ? value.forEach((function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    })) : isMap(value) && value.forEach((function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    }));
    var props = isArr ? void 0 : (isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys)(value);
    return arrayEach(props || value, (function(subValue, key) {
      props && (subValue = value[key = subValue]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    })), result;
  };
}, function(module, exports, __webpack_require__) {
  var ListCache = __webpack_require__(30), stackClear = __webpack_require__(193), stackDelete = __webpack_require__(194), stackGet = __webpack_require__(195), stackHas = __webpack_require__(196), stackSet = __webpack_require__(197);
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, 
  Stack.prototype.has = stackHas, Stack.prototype.set = stackSet, module.exports = Stack;
}, function(module, exports) {
  module.exports = function() {
    this.__data__ = [], this.size = 0;
  };
}, function(module, exports, __webpack_require__) {
  var assocIndexOf = __webpack_require__(31), splice = Array.prototype.splice;
  module.exports = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return !(index < 0) && (index == data.length - 1 ? data.pop() : splice.call(data, index, 1), 
    --this.size, !0);
  };
}, function(module, exports, __webpack_require__) {
  var assocIndexOf = __webpack_require__(31);
  module.exports = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  };
}, function(module, exports, __webpack_require__) {
  var assocIndexOf = __webpack_require__(31);
  module.exports = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
}, function(module, exports, __webpack_require__) {
  var assocIndexOf = __webpack_require__(31);
  module.exports = function(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? (++this.size, data.push([ key, value ])) : data[index][1] = value, 
    this;
  };
}, function(module, exports, __webpack_require__) {
  var ListCache = __webpack_require__(30);
  module.exports = function() {
    this.__data__ = new ListCache, this.size = 0;
  };
}, function(module, exports) {
  module.exports = function(key) {
    var data = this.__data__, result = data.delete(key);
    return this.size = data.size, result;
  };
}, function(module, exports) {
  module.exports = function(key) {
    return this.__data__.get(key);
  };
}, function(module, exports) {
  module.exports = function(key) {
    return this.__data__.has(key);
  };
}, function(module, exports, __webpack_require__) {
  var ListCache = __webpack_require__(30), Map = __webpack_require__(56), MapCache = __webpack_require__(100);
  module.exports = function(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || pairs.length < 199) return pairs.push([ key, value ]), this.size = ++data.size, 
      this;
      data = this.__data__ = new MapCache(pairs);
    }
    return data.set(key, value), this.size = data.size, this;
  };
}, function(module, exports, __webpack_require__) {
  var isFunction = __webpack_require__(97), isMasked = __webpack_require__(201), isObject = __webpack_require__(14), toSource = __webpack_require__(99), reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = function(value) {
    return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value));
  };
}, function(module, exports, __webpack_require__) {
  var Symbol = __webpack_require__(33), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol ? Symbol.toStringTag : void 0;
  module.exports = function(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = !0;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
    result;
  };
}, function(module, exports) {
  var nativeObjectToString = Object.prototype.toString;
  module.exports = function(value) {
    return nativeObjectToString.call(value);
  };
}, function(module, exports, __webpack_require__) {
  var uid, coreJsData = __webpack_require__(202), maskSrcKey = (uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "")) ? "Symbol(src)_1." + uid : "";
  module.exports = function(func) {
    return !!maskSrcKey && maskSrcKey in func;
  };
}, function(module, exports, __webpack_require__) {
  var coreJsData = __webpack_require__(6)["__core-js_shared__"];
  module.exports = coreJsData;
}, function(module, exports) {
  module.exports = function(object, key) {
    return null == object ? void 0 : object[key];
  };
}, function(module, exports, __webpack_require__) {
  var Hash = __webpack_require__(205), ListCache = __webpack_require__(30), Map = __webpack_require__(56);
  module.exports = function() {
    this.size = 0, this.__data__ = {
      hash: new Hash,
      map: new (Map || ListCache),
      string: new Hash
    };
  };
}, function(module, exports, __webpack_require__) {
  var hashClear = __webpack_require__(206), hashDelete = __webpack_require__(207), hashGet = __webpack_require__(208), hashHas = __webpack_require__(209), hashSet = __webpack_require__(210);
  function Hash(entries) {
    var index = -1, length = null == entries ? 0 : entries.length;
    for (this.clear(); ++index < length; ) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, 
  Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, module.exports = Hash;
}, function(module, exports, __webpack_require__) {
  var nativeCreate = __webpack_require__(34);
  module.exports = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
  };
}, function(module, exports) {
  module.exports = function(key) {
    var result = this.has(key) && delete this.__data__[key];
    return this.size -= result ? 1 : 0, result;
  };
}, function(module, exports, __webpack_require__) {
  var nativeCreate = __webpack_require__(34), hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return "__lodash_hash_undefined__" === result ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  };
}, function(module, exports, __webpack_require__) {
  var nativeCreate = __webpack_require__(34), hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(key) {
    var data = this.__data__;
    return nativeCreate ? void 0 !== data[key] : hasOwnProperty.call(data, key);
  };
}, function(module, exports, __webpack_require__) {
  var nativeCreate = __webpack_require__(34);
  module.exports = function(key, value) {
    var data = this.__data__;
    return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && void 0 === value ? "__lodash_hash_undefined__" : value, 
    this;
  };
}, function(module, exports, __webpack_require__) {
  var getMapData = __webpack_require__(35);
  module.exports = function(key) {
    var result = getMapData(this, key).delete(key);
    return this.size -= result ? 1 : 0, result;
  };
}, function(module, exports) {
  module.exports = function(value) {
    var type = typeof value;
    return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
  };
}, function(module, exports, __webpack_require__) {
  var getMapData = __webpack_require__(35);
  module.exports = function(key) {
    return getMapData(this, key).get(key);
  };
}, function(module, exports, __webpack_require__) {
  var getMapData = __webpack_require__(35);
  module.exports = function(key) {
    return getMapData(this, key).has(key);
  };
}, function(module, exports, __webpack_require__) {
  var getMapData = __webpack_require__(35);
  module.exports = function(key, value) {
    var data = getMapData(this, key), size = data.size;
    return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
  };
}, function(module, exports) {
  module.exports = function(array, iteratee) {
    for (var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array); ) ;
    return array;
  };
}, function(module, exports, __webpack_require__) {
  var copyObject = __webpack_require__(36), keys = __webpack_require__(57);
  module.exports = function(object, source) {
    return object && copyObject(source, keys(source), object);
  };
}, function(module, exports) {
  module.exports = function(n, iteratee) {
    for (var index = -1, result = Array(n); ++index < n; ) result[index] = iteratee(index);
    return result;
  };
}, function(module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(13), isObjectLike = __webpack_require__(9);
  module.exports = function(value) {
    return isObjectLike(value) && "[object Arguments]" == baseGetTag(value);
  };
}, function(module, exports) {
  module.exports = function() {
    return !1;
  };
}, function(module, exports, __webpack_require__) {
  var baseIsTypedArray = __webpack_require__(222), baseUnary = __webpack_require__(25), nodeUtil = __webpack_require__(37), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
}, function(module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(13), isLength = __webpack_require__(60), isObjectLike = __webpack_require__(9), typedArrayTags = {};
  typedArrayTags["[object Float32Array]"] = typedArrayTags["[object Float64Array]"] = typedArrayTags["[object Int8Array]"] = typedArrayTags["[object Int16Array]"] = typedArrayTags["[object Int32Array]"] = typedArrayTags["[object Uint8Array]"] = typedArrayTags["[object Uint8ClampedArray]"] = typedArrayTags["[object Uint16Array]"] = typedArrayTags["[object Uint32Array]"] = !0, 
  typedArrayTags["[object Arguments]"] = typedArrayTags["[object Array]"] = typedArrayTags["[object ArrayBuffer]"] = typedArrayTags["[object Boolean]"] = typedArrayTags["[object DataView]"] = typedArrayTags["[object Date]"] = typedArrayTags["[object Error]"] = typedArrayTags["[object Function]"] = typedArrayTags["[object Map]"] = typedArrayTags["[object Number]"] = typedArrayTags["[object Object]"] = typedArrayTags["[object RegExp]"] = typedArrayTags["[object Set]"] = typedArrayTags["[object String]"] = typedArrayTags["[object WeakMap]"] = !1, 
  module.exports = function(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  };
}, function(module, exports, __webpack_require__) {
  var isPrototype = __webpack_require__(61), nativeKeys = __webpack_require__(224), hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
    return result;
  };
}, function(module, exports, __webpack_require__) {
  var nativeKeys = __webpack_require__(107)(Object.keys, Object);
  module.exports = nativeKeys;
}, function(module, exports, __webpack_require__) {
  var copyObject = __webpack_require__(36), keysIn = __webpack_require__(38);
  module.exports = function(object, source) {
    return object && copyObject(source, keysIn(source), object);
  };
}, function(module, exports, __webpack_require__) {
  var isObject = __webpack_require__(14), isPrototype = __webpack_require__(61), nativeKeysIn = __webpack_require__(227), hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(object) {
    if (!isObject(object)) return nativeKeysIn(object);
    var isProto = isPrototype(object), result = [];
    for (var key in object) ("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
    return result;
  };
}, function(module, exports) {
  module.exports = function(object) {
    var result = [];
    if (null != object) for (var key in Object(object)) result.push(key);
    return result;
  };
}, function(module, exports, __webpack_require__) {
  (function(module) {
    var root = __webpack_require__(6), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module, Buffer = freeModule && freeModule.exports === freeExports ? root.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    module.exports = function(buffer, isDeep) {
      if (isDeep) return buffer.slice();
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      return buffer.copy(result), result;
    };
  }).call(this, __webpack_require__(58)(module));
}, function(module, exports, __webpack_require__) {
  var copyObject = __webpack_require__(36), getSymbols = __webpack_require__(63);
  module.exports = function(source, object) {
    return copyObject(source, getSymbols(source), object);
  };
}, function(module, exports) {
  module.exports = function(array, predicate) {
    for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
      var value = array[index];
      predicate(value, index, array) && (result[resIndex++] = value);
    }
    return result;
  };
}, function(module, exports, __webpack_require__) {
  var copyObject = __webpack_require__(36), getSymbolsIn = __webpack_require__(110);
  module.exports = function(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  };
}, function(module, exports, __webpack_require__) {
  var baseGetAllKeys = __webpack_require__(112), getSymbols = __webpack_require__(63), keys = __webpack_require__(57);
  module.exports = function(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  };
}, function(module, exports, __webpack_require__) {
  var baseGetAllKeys = __webpack_require__(112), getSymbolsIn = __webpack_require__(110), keysIn = __webpack_require__(38);
  module.exports = function(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  };
}, function(module, exports, __webpack_require__) {
  var DataView = __webpack_require__(12)(__webpack_require__(6), "DataView");
  module.exports = DataView;
}, function(module, exports, __webpack_require__) {
  var Promise = __webpack_require__(12)(__webpack_require__(6), "Promise");
  module.exports = Promise;
}, function(module, exports, __webpack_require__) {
  var Set = __webpack_require__(12)(__webpack_require__(6), "Set");
  module.exports = Set;
}, function(module, exports, __webpack_require__) {
  var WeakMap = __webpack_require__(12)(__webpack_require__(6), "WeakMap");
  module.exports = WeakMap;
}, function(module, exports) {
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(array) {
    var length = array.length, result = new array.constructor(length);
    return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, 
    result.input = array.input), result;
  };
}, function(module, exports, __webpack_require__) {
  var cloneArrayBuffer = __webpack_require__(66), cloneDataView = __webpack_require__(241), cloneRegExp = __webpack_require__(242), cloneSymbol = __webpack_require__(243), cloneTypedArray = __webpack_require__(244);
  module.exports = function(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
     case "[object ArrayBuffer]":
      return cloneArrayBuffer(object);

     case "[object Boolean]":
     case "[object Date]":
      return new Ctor(+object);

     case "[object DataView]":
      return cloneDataView(object, isDeep);

     case "[object Float32Array]":
     case "[object Float64Array]":
     case "[object Int8Array]":
     case "[object Int16Array]":
     case "[object Int32Array]":
     case "[object Uint8Array]":
     case "[object Uint8ClampedArray]":
     case "[object Uint16Array]":
     case "[object Uint32Array]":
      return cloneTypedArray(object, isDeep);

     case "[object Map]":
      return new Ctor;

     case "[object Number]":
     case "[object String]":
      return new Ctor(object);

     case "[object RegExp]":
      return cloneRegExp(object);

     case "[object Set]":
      return new Ctor;

     case "[object Symbol]":
      return cloneSymbol(object);
    }
  };
}, function(module, exports, __webpack_require__) {
  var Uint8Array = __webpack_require__(6).Uint8Array;
  module.exports = Uint8Array;
}, function(module, exports, __webpack_require__) {
  var cloneArrayBuffer = __webpack_require__(66);
  module.exports = function(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  };
}, function(module, exports) {
  var reFlags = /\w*$/;
  module.exports = function(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    return result.lastIndex = regexp.lastIndex, result;
  };
}, function(module, exports, __webpack_require__) {
  var Symbol = __webpack_require__(33), symbolProto = Symbol ? Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  module.exports = function(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  };
}, function(module, exports, __webpack_require__) {
  var cloneArrayBuffer = __webpack_require__(66);
  module.exports = function(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  };
}, function(module, exports, __webpack_require__) {
  var baseCreate = __webpack_require__(246), getPrototype = __webpack_require__(64), isPrototype = __webpack_require__(61);
  module.exports = function(object) {
    return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
  };
}, function(module, exports, __webpack_require__) {
  var isObject = __webpack_require__(14), objectCreate = Object.create, baseCreate = function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) return {};
      if (objectCreate) return objectCreate(proto);
      object.prototype = proto;
      var result = new object;
      return object.prototype = void 0, result;
    };
  }();
  module.exports = baseCreate;
}, function(module, exports, __webpack_require__) {
  var baseIsMap = __webpack_require__(248), baseUnary = __webpack_require__(25), nodeUtil = __webpack_require__(37), nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  module.exports = isMap;
}, function(module, exports, __webpack_require__) {
  var getTag = __webpack_require__(65), isObjectLike = __webpack_require__(9);
  module.exports = function(value) {
    return isObjectLike(value) && "[object Map]" == getTag(value);
  };
}, function(module, exports, __webpack_require__) {
  var baseIsSet = __webpack_require__(250), baseUnary = __webpack_require__(25), nodeUtil = __webpack_require__(37), nodeIsSet = nodeUtil && nodeUtil.isSet, isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  module.exports = isSet;
}, function(module, exports, __webpack_require__) {
  var getTag = __webpack_require__(65), isObjectLike = __webpack_require__(9);
  module.exports = function(value) {
    return isObjectLike(value) && "[object Set]" == getTag(value);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  let fastProto = null;
  function FastObject(o) {
    if (null !== fastProto && (fastProto.property, 1)) {
      const result = fastProto;
      return fastProto = FastObject.prototype = null, result;
    }
    return fastProto = FastObject.prototype = null == o ? Object.create(null) : o, new FastObject;
  }
  FastObject(), module.exports = function(o) {
    return FastObject(o);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.isIdentifierStart = isIdentifierStart, exports.isIdentifierChar = isIdentifierChar, 
  exports.isIdentifierName = function(name) {
    let isFirst = !0;
    for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {
      const cp = _Array$from[_i].codePointAt(0);
      if (isFirst) {
        if (!isIdentifierStart(cp)) return !1;
        isFirst = !1;
      } else if (!isIdentifierChar(cp)) return !1;
    }
    return !isFirst;
  };
  let nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938 ], astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239 ];
  function isInAstralSet(code, set) {
    let pos = 65536;
    for (let i = 0, length = set.length; i < length; i += 2) {
      if (pos += set[i], pos > code) return !1;
      if (pos += set[i + 1], pos >= code) return !0;
    }
    return !1;
  }
  function isIdentifierStart(code) {
    return code < 65 ? 36 === code : code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes)));
  }
  function isIdentifierChar(code) {
    return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code <= 90 || (code < 97 ? 95 === code : code <= 122 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes))));
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.isReservedWord = isReservedWord, exports.isStrictReservedWord = isStrictReservedWord, 
  exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord, exports.isStrictBindReservedWord = function(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }, exports.isKeyword = function(word) {
    return keywords.has(word);
  };
  const reservedWords_strict = [ "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield" ], reservedWords_strictBind = [ "eval", "arguments" ], keywords = new Set([ "break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete" ]), reservedWordsStrictSet = new Set(reservedWords_strict), reservedWordsStrictBindSet = new Set(reservedWords_strictBind);
  function isReservedWord(word, inModule) {
    return inModule && "await" === word || "enum" === word;
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
    (0, _utils.default)(name, {
      builder: [ "id", "typeParameters", "extends", "body" ],
      visitor: [ "id", "typeParameters", "extends", "mixins", "implements", "body" ],
      aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
  };
  (0, _utils.default)("AnyTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("ArrayTypeAnnotation", {
    visitor: [ "elementType" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("BooleanTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("BooleanLiteralTypeAnnotation", {
    builder: [ "value" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  }), (0, _utils.default)("NullLiteralTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("ClassImplements", {
    visitor: [ "id", "typeParameters" ],
    aliases: [ "Flow" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  }), defineInterfaceishType("DeclareClass"), (0, _utils.default)("DeclareFunction", {
    visitor: [ "id" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  }), defineInterfaceishType("DeclareInterface"), (0, _utils.default)("DeclareModule", {
    builder: [ "id", "body", "kind" ],
    visitor: [ "id", "body" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  }), (0, _utils.default)("DeclareModuleExports", {
    visitor: [ "typeAnnotation" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  }), (0, _utils.default)("DeclareTypeAlias", {
    visitor: [ "id", "typeParameters", "right" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("DeclareOpaqueType", {
    visitor: [ "id", "typeParameters", "supertype" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType")
    }
  }), (0, _utils.default)("DeclareVariable", {
    visitor: [ "id" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  }), (0, _utils.default)("DeclareExportDeclaration", {
    visitor: [ "declaration", "specifiers", "source" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)([ "ExportSpecifier", "ExportNamespaceSpecifier" ])),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  }), (0, _utils.default)("DeclareExportAllDeclaration", {
    visitor: [ "source" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }
  }), (0, _utils.default)("DeclaredPredicate", {
    visitor: [ "value" ],
    aliases: [ "Flow", "FlowPredicate" ],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  }), (0, _utils.default)("ExistsTypeAnnotation", {
    aliases: [ "Flow", "FlowType" ]
  }), (0, _utils.default)("FunctionTypeAnnotation", {
    visitor: [ "typeParameters", "params", "rest", "returnType" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("FunctionTypeParam", {
    visitor: [ "name", "typeAnnotation" ],
    aliases: [ "Flow" ],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  }), (0, _utils.default)("GenericTypeAnnotation", {
    visitor: [ "id", "typeParameters" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      id: (0, _utils.validateType)([ "Identifier", "QualifiedTypeIdentifier" ]),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  }), (0, _utils.default)("InferredPredicate", {
    aliases: [ "Flow", "FlowPredicate" ]
  }), (0, _utils.default)("InterfaceExtends", {
    visitor: [ "id", "typeParameters" ],
    aliases: [ "Flow" ],
    fields: {
      id: (0, _utils.validateType)([ "Identifier", "QualifiedTypeIdentifier" ]),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  }), defineInterfaceishType("InterfaceDeclaration"), (0, _utils.default)("InterfaceTypeAnnotation", {
    visitor: [ "extends", "body" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  }), (0, _utils.default)("IntersectionTypeAnnotation", {
    visitor: [ "types" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  }), (0, _utils.default)("MixedTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("EmptyTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("NullableTypeAnnotation", {
    visitor: [ "typeAnnotation" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("NumberLiteralTypeAnnotation", {
    builder: [ "value" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  }), (0, _utils.default)("NumberTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("ObjectTypeAnnotation", {
    visitor: [ "properties", "indexers", "callProperties", "internalSlots" ],
    aliases: [ "Flow", "FlowType" ],
    builder: [ "properties", "indexers", "callProperties", "internalSlots", "exact" ],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)([ "ObjectTypeProperty", "ObjectTypeSpreadProperty" ])),
      indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
      callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
      internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  }), (0, _utils.default)("ObjectTypeInternalSlot", {
    visitor: [ "id", "value", "optional", "static", "method" ],
    aliases: [ "Flow", "UserWhitespacable" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  }), (0, _utils.default)("ObjectTypeCallProperty", {
    visitor: [ "value" ],
    aliases: [ "Flow", "UserWhitespacable" ],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  }), (0, _utils.default)("ObjectTypeIndexer", {
    visitor: [ "id", "key", "value", "variance" ],
    aliases: [ "Flow", "UserWhitespacable" ],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  }), (0, _utils.default)("ObjectTypeProperty", {
    visitor: [ "key", "value", "variance" ],
    aliases: [ "Flow", "UserWhitespacable" ],
    fields: {
      key: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  }), (0, _utils.default)("ObjectTypeSpreadProperty", {
    visitor: [ "argument" ],
    aliases: [ "Flow", "UserWhitespacable" ],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("OpaqueType", {
    visitor: [ "id", "typeParameters", "supertype", "impltype" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("QualifiedTypeIdentifier", {
    visitor: [ "id", "qualification" ],
    aliases: [ "Flow" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)([ "Identifier", "QualifiedTypeIdentifier" ])
    }
  }), (0, _utils.default)("StringLiteralTypeAnnotation", {
    builder: [ "value" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  }), (0, _utils.default)("StringTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("SymbolTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("ThisTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("TupleTypeAnnotation", {
    visitor: [ "types" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  }), (0, _utils.default)("TypeofTypeAnnotation", {
    visitor: [ "argument" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("TypeAlias", {
    visitor: [ "id", "typeParameters", "right" ],
    aliases: [ "Flow", "FlowDeclaration", "Statement", "Declaration" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("TypeAnnotation", {
    aliases: [ "Flow" ],
    visitor: [ "typeAnnotation" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  }), (0, _utils.default)("TypeCastExpression", {
    visitor: [ "expression", "typeAnnotation" ],
    aliases: [ "Flow", "ExpressionWrapper", "Expression" ],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  }), (0, _utils.default)("TypeParameter", {
    aliases: [ "Flow" ],
    visitor: [ "bound", "default", "variance" ],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  }), (0, _utils.default)("TypeParameterDeclaration", {
    aliases: [ "Flow" ],
    visitor: [ "params" ],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  }), (0, _utils.default)("TypeParameterInstantiation", {
    aliases: [ "Flow" ],
    visitor: [ "params" ],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  }), (0, _utils.default)("UnionTypeAnnotation", {
    visitor: [ "types" ],
    aliases: [ "Flow", "FlowType" ],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  }), (0, _utils.default)("Variance", {
    aliases: [ "Flow" ],
    builder: [ "kind" ],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  }), (0, _utils.default)("VoidTypeAnnotation", {
    aliases: [ "Flow", "FlowType", "FlowBaseAnnotation" ]
  }), (0, _utils.default)("EnumDeclaration", {
    aliases: [ "Statement", "Declaration" ],
    visitor: [ "id", "body" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)([ "EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody" ])
    }
  }), (0, _utils.default)("EnumBooleanBody", {
    aliases: [ "EnumBody" ],
    visitor: [ "members" ],
    fields: {
      explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember")
    }
  }), (0, _utils.default)("EnumNumberBody", {
    aliases: [ "EnumBody" ],
    visitor: [ "members" ],
    fields: {
      explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember")
    }
  }), (0, _utils.default)("EnumStringBody", {
    aliases: [ "EnumBody" ],
    visitor: [ "members" ],
    fields: {
      explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)([ "EnumStringMember", "EnumDefaultedMember" ])
    }
  }), (0, _utils.default)("EnumSymbolBody", {
    aliases: [ "EnumBody" ],
    visitor: [ "members" ],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember")
    }
  }), (0, _utils.default)("EnumBooleanMember", {
    aliases: [ "EnumMember" ],
    visitor: [ "id" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  }), (0, _utils.default)("EnumNumberMember", {
    aliases: [ "EnumMember" ],
    visitor: [ "id", "init" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  }), (0, _utils.default)("EnumStringMember", {
    aliases: [ "EnumMember" ],
    visitor: [ "id", "init" ],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  }), (0, _utils.default)("EnumDefaultedMember", {
    aliases: [ "EnumMember" ],
    visitor: [ "id" ],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  (0, _utils.default)("JSXAttribute", {
    visitor: [ "name", "value" ],
    aliases: [ "JSX", "Immutable" ],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  }), (0, _utils.default)("JSXClosingElement", {
    visitor: [ "name" ],
    aliases: [ "JSX", "Immutable" ],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  }), (0, _utils.default)("JSXElement", {
    builder: [ "openingElement", "closingElement", "children", "selfClosing" ],
    visitor: [ "openingElement", "children", "closingElement" ],
    aliases: [ "JSX", "Immutable", "Expression" ],
    fields: {
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      },
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      }
    }
  }), (0, _utils.default)("JSXEmptyExpression", {
    aliases: [ "JSX" ]
  }), (0, _utils.default)("JSXExpressionContainer", {
    visitor: [ "expression" ],
    aliases: [ "JSX", "Immutable" ],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  }), (0, _utils.default)("JSXSpreadChild", {
    visitor: [ "expression" ],
    aliases: [ "JSX", "Immutable" ],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("JSXIdentifier", {
    builder: [ "name" ],
    aliases: [ "JSX" ],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  }), (0, _utils.default)("JSXMemberExpression", {
    visitor: [ "object", "property" ],
    aliases: [ "JSX" ],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  }), (0, _utils.default)("JSXNamespacedName", {
    visitor: [ "namespace", "name" ],
    aliases: [ "JSX" ],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  }), (0, _utils.default)("JSXOpeningElement", {
    builder: [ "name", "attributes", "selfClosing" ],
    visitor: [ "name", "attributes" ],
    aliases: [ "JSX", "Immutable" ],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), (0, _utils.default)("JSXSpreadAttribute", {
    visitor: [ "argument" ],
    aliases: [ "JSX" ],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("JSXText", {
    aliases: [ "JSX", "Immutable" ],
    builder: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  }), (0, _utils.default)("JSXFragment", {
    builder: [ "openingFragment", "closingFragment", "children" ],
    visitor: [ "openingFragment", "children", "closingFragment" ],
    aliases: [ "JSX", "Immutable", "Expression" ],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  }), (0, _utils.default)("JSXOpeningFragment", {
    aliases: [ "JSX", "Immutable" ]
  }), (0, _utils.default)("JSXClosingFragment", {
    aliases: [ "JSX", "Immutable" ]
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7)), _placeholders = __webpack_require__(114);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  (0, _utils.default)("Noop", {
    visitor: []
  }), (0, _utils.default)("Placeholder", {
    visitor: [],
    builder: [ "expectedNode", "name" ],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }
  }), (0, _utils.default)("V8IntrinsicIdentifier", {
    builder: [ "name" ],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7)), _es = __webpack_require__(70), _core = __webpack_require__(39);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  (0, _utils.default)("ArgumentPlaceholder", {}), (0, _utils.default)("AwaitExpression", {
    builder: [ "argument" ],
    visitor: [ "argument" ],
    aliases: [ "Expression", "Terminatorless" ],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("BindExpression", {
    visitor: [ "object", "callee" ],
    aliases: [ "Expression" ],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {}, {
          oneOfNodeTypes: [ "Expression" ]
        })
      },
      callee: {
        validate: Object.assign(() => {}, {
          oneOfNodeTypes: [ "Expression" ]
        })
      }
    }
  }), (0, _utils.default)("ClassProperty", {
    visitor: [ "key", "value", "typeAnnotation", "decorators" ],
    builder: [ "key", "value", "typeAnnotation", "decorators", "computed", "static" ],
    aliases: [ "Property" ],
    fields: Object.assign({}, _es.classMethodOrPropertyCommon, {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), (0, _utils.default)("OptionalMemberExpression", {
    builder: [ "object", "property", "computed", "optional" ],
    visitor: [ "object", "property" ],
    aliases: [ "Expression" ],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const normal = (0, _utils.assertNodeType)("Identifier"), computed = (0, _utils.assertNodeType)("Expression"), validator = function(node, key, val) {
            (node.computed ? computed : normal)(node, key, val);
          };
          return validator.oneOfNodeTypes = [ "Expression", "Identifier" ], validator;
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, 
        _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean")
      }
    }
  }), (0, _utils.default)("PipelineTopicExpression", {
    builder: [ "expression" ],
    visitor: [ "expression" ],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("PipelineBareFunction", {
    builder: [ "callee" ],
    visitor: [ "callee" ],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("PipelinePrimaryTopicReference", {
    aliases: [ "Expression" ]
  }), (0, _utils.default)("OptionalCallExpression", {
    visitor: [ "callee", "arguments", "typeParameters", "typeArguments" ],
    builder: [ "callee", "arguments", "optional" ],
    aliases: [ "Expression" ],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, 
        _utils.assertOptionalChainStart)()) : (0, _utils.assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), (0, _utils.default)("ClassPrivateProperty", {
    visitor: [ "key", "value", "decorators" ],
    builder: [ "key", "value", "decorators" ],
    aliases: [ "Property", "Private" ],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: !0
      },
      decorators: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  }), (0, _utils.default)("ClassPrivateMethod", {
    builder: [ "kind", "key", "params", "body", "static" ],
    visitor: [ "key", "params", "body", "decorators", "returnType", "typeParameters" ],
    aliases: [ "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private" ],
    fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  }), (0, _utils.default)("Import", {
    aliases: [ "Expression" ]
  }), (0, _utils.default)("ImportAttribute", {
    visitor: [ "key", "value" ],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  }), (0, _utils.default)("Decorator", {
    visitor: [ "expression" ],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  }), (0, _utils.default)("DoExpression", {
    visitor: [ "body" ],
    aliases: [ "Expression" ],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  }), (0, _utils.default)("ExportDefaultSpecifier", {
    visitor: [ "exported" ],
    aliases: [ "ModuleSpecifier" ],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  }), (0, _utils.default)("ExportNamespaceSpecifier", {
    visitor: [ "exported" ],
    aliases: [ "ModuleSpecifier" ],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  }), (0, _utils.default)("PrivateName", {
    visitor: [ "id" ],
    aliases: [ "Private" ],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  }), (0, _utils.default)("BigIntLiteral", {
    builder: [ "value" ],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: [ "Expression", "Pureish", "Literal", "Immutable" ]
  }), (0, _utils.default)("RecordExpression", {
    visitor: [ "properties" ],
    aliases: [ "Expression" ],
    fields: {
      properties: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  }), (0, _utils.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: [ "elements" ],
    aliases: [ "Expression" ]
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _utils = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(7)), _core = __webpack_require__(39), _es = __webpack_require__(70);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const bool = (0, _utils.assertValueType)("boolean"), tSFunctionTypeAnnotationCommon = {
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  };
  (0, _utils.default)("TSParameterProperty", {
    aliases: [ "LVal" ],
    visitor: [ "parameter" ],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      }
    }
  }), (0, _utils.default)("TSDeclareFunction", {
    aliases: [ "Statement", "Declaration" ],
    visitor: [ "id", "typeParameters", "params", "returnType" ],
    fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
  }), (0, _utils.default)("TSDeclareMethod", {
    visitor: [ "decorators", "key", "typeParameters", "params", "returnType" ],
    fields: Object.assign({}, _es.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
  }), (0, _utils.default)("TSQualifiedName", {
    aliases: [ "TSEntityName" ],
    visitor: [ "left", "right" ],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  const signatureDeclarationCommon = {
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, _utils.validateArrayOfType)([ "Identifier", "RestElement" ]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  }, callConstructSignatureDeclaration = {
    aliases: [ "TSTypeElement" ],
    visitor: [ "typeParameters", "parameters", "typeAnnotation" ],
    fields: signatureDeclarationCommon
  };
  (0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration), 
  (0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  const namedTypeElementCommon = {
    key: (0, _utils.validateType)("Expression"),
    computed: (0, _utils.validate)(bool),
    optional: (0, _utils.validateOptional)(bool)
  };
  (0, _utils.default)("TSPropertySignature", {
    aliases: [ "TSTypeElement" ],
    visitor: [ "key", "typeAnnotation", "initializer" ],
    fields: Object.assign({}, namedTypeElementCommon, {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    })
  }), (0, _utils.default)("TSMethodSignature", {
    aliases: [ "TSTypeElement" ],
    visitor: [ "key", "typeParameters", "parameters", "typeAnnotation" ],
    fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
  }), (0, _utils.default)("TSIndexSignature", {
    aliases: [ "TSTypeElement" ],
    visitor: [ "parameters", "typeAnnotation" ],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const tsKeywordTypes = [ "TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword" ];
  for (const type of tsKeywordTypes) (0, _utils.default)(type, {
    aliases: [ "TSType", "TSBaseType" ],
    visitor: [],
    fields: {}
  });
  (0, _utils.default)("TSThisType", {
    aliases: [ "TSType", "TSBaseType" ],
    visitor: [],
    fields: {}
  });
  const fnOrCtr = {
    aliases: [ "TSType" ],
    visitor: [ "typeParameters", "parameters", "typeAnnotation" ],
    fields: signatureDeclarationCommon
  };
  (0, _utils.default)("TSFunctionType", fnOrCtr), (0, _utils.default)("TSConstructorType", fnOrCtr), 
  (0, _utils.default)("TSTypeReference", {
    aliases: [ "TSType" ],
    visitor: [ "typeName", "typeParameters" ],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), (0, _utils.default)("TSTypePredicate", {
    aliases: [ "TSType" ],
    visitor: [ "parameterName", "typeAnnotation" ],
    builder: [ "parameterName", "typeAnnotation", "asserts" ],
    fields: {
      parameterName: (0, _utils.validateType)([ "Identifier", "TSThisType" ]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  }), (0, _utils.default)("TSTypeQuery", {
    aliases: [ "TSType" ],
    visitor: [ "exprName" ],
    fields: {
      exprName: (0, _utils.validateType)([ "TSEntityName", "TSImportType" ])
    }
  }), (0, _utils.default)("TSTypeLiteral", {
    aliases: [ "TSType" ],
    visitor: [ "members" ],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  }), (0, _utils.default)("TSArrayType", {
    aliases: [ "TSType" ],
    visitor: [ "elementType" ],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSTupleType", {
    aliases: [ "TSType" ],
    visitor: [ "elementTypes" ],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)("TSType")
    }
  }), (0, _utils.default)("TSOptionalType", {
    aliases: [ "TSType" ],
    visitor: [ "typeAnnotation" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSRestType", {
    aliases: [ "TSType" ],
    visitor: [ "typeAnnotation" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  const unionOrIntersection = {
    aliases: [ "TSType" ],
    visitor: [ "types" ],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  (0, _utils.default)("TSUnionType", unionOrIntersection), (0, _utils.default)("TSIntersectionType", unionOrIntersection), 
  (0, _utils.default)("TSConditionalType", {
    aliases: [ "TSType" ],
    visitor: [ "checkType", "extendsType", "trueType", "falseType" ],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSInferType", {
    aliases: [ "TSType" ],
    visitor: [ "typeParameter" ],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  }), (0, _utils.default)("TSParenthesizedType", {
    aliases: [ "TSType" ],
    visitor: [ "typeAnnotation" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSTypeOperator", {
    aliases: [ "TSType" ],
    visitor: [ "typeAnnotation" ],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSIndexedAccessType", {
    aliases: [ "TSType" ],
    visitor: [ "objectType", "indexType" ],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSMappedType", {
    aliases: [ "TSType" ],
    visitor: [ "typeParameter", "typeAnnotation" ],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      typeParameter: (0, _utils.validateType)("TSTypeParameter"),
      optional: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType")
    }
  }), (0, _utils.default)("TSLiteralType", {
    aliases: [ "TSType", "TSBaseType" ],
    visitor: [ "literal" ],
    fields: {
      literal: (0, _utils.validateType)([ "NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral" ])
    }
  }), (0, _utils.default)("TSExpressionWithTypeArguments", {
    aliases: [ "TSType" ],
    visitor: [ "expression", "typeParameters" ],
    fields: {
      expression: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), (0, _utils.default)("TSInterfaceDeclaration", {
    aliases: [ "Statement", "Declaration" ],
    visitor: [ "id", "typeParameters", "extends", "body" ],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  }), (0, _utils.default)("TSInterfaceBody", {
    visitor: [ "body" ],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  }), (0, _utils.default)("TSTypeAliasDeclaration", {
    aliases: [ "Statement", "Declaration" ],
    visitor: [ "id", "typeParameters", "typeAnnotation" ],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSAsExpression", {
    aliases: [ "Expression" ],
    visitor: [ "expression", "typeAnnotation" ],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  }), (0, _utils.default)("TSTypeAssertion", {
    aliases: [ "Expression" ],
    visitor: [ "typeAnnotation", "expression" ],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  }), (0, _utils.default)("TSEnumDeclaration", {
    aliases: [ "Statement", "Declaration" ],
    visitor: [ "id", "members" ],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      const: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      members: (0, _utils.validateArrayOfType)("TSEnumMember"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  }), (0, _utils.default)("TSEnumMember", {
    visitor: [ "id", "initializer" ],
    fields: {
      id: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  }), (0, _utils.default)("TSModuleDeclaration", {
    aliases: [ "Statement", "Declaration" ],
    visitor: [ "id", "body" ],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      global: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)([ "Identifier", "StringLiteral" ]),
      body: (0, _utils.validateType)([ "TSModuleBlock", "TSModuleDeclaration" ])
    }
  }), (0, _utils.default)("TSModuleBlock", {
    aliases: [ "Scopable", "Block", "BlockParent" ],
    visitor: [ "body" ],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  }), (0, _utils.default)("TSImportType", {
    aliases: [ "TSType" ],
    visitor: [ "argument", "qualifier", "typeParameters" ],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), (0, _utils.default)("TSImportEqualsDeclaration", {
    aliases: [ "Statement" ],
    visitor: [ "id", "moduleReference" ],
    fields: {
      isExport: (0, _utils.validate)(bool),
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)([ "TSEntityName", "TSExternalModuleReference" ])
    }
  }), (0, _utils.default)("TSExternalModuleReference", {
    visitor: [ "expression" ],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  }), (0, _utils.default)("TSNonNullExpression", {
    aliases: [ "Expression" ],
    visitor: [ "expression" ],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  }), (0, _utils.default)("TSExportAssignment", {
    aliases: [ "Statement" ],
    visitor: [ "expression" ],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  }), (0, _utils.default)("TSNamespaceExportDeclaration", {
    aliases: [ "Statement" ],
    visitor: [ "id" ],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  }), (0, _utils.default)("TSTypeAnnotation", {
    visitor: [ "typeAnnotation" ],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  }), (0, _utils.default)("TSTypeParameterInstantiation", {
    visitor: [ "params" ],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("TSType")))
      }
    }
  }), (0, _utils.default)("TSTypeParameterDeclaration", {
    visitor: [ "params" ],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, 
        _utils.assertNodeType)("TSTypeParameter")))
      }
    }
  }), (0, _utils.default)("TSTypeParameter", {
    builder: [ "constraint", "default", "name" ],
    visitor: [ "constraint", "default" ],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    if (!(0, _isNode.default)(node)) {
      var _node$type;
      const type = null != (_node$type = null == node ? void 0 : node.type) ? _node$type : JSON.stringify(node);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  };
  var obj, _isNode = (obj = __webpack_require__(115)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.assertArrayExpression = function(node, opts = {}) {
    assert("ArrayExpression", node, opts);
  }, exports.assertAssignmentExpression = function(node, opts = {}) {
    assert("AssignmentExpression", node, opts);
  }, exports.assertBinaryExpression = function(node, opts = {}) {
    assert("BinaryExpression", node, opts);
  }, exports.assertInterpreterDirective = function(node, opts = {}) {
    assert("InterpreterDirective", node, opts);
  }, exports.assertDirective = function(node, opts = {}) {
    assert("Directive", node, opts);
  }, exports.assertDirectiveLiteral = function(node, opts = {}) {
    assert("DirectiveLiteral", node, opts);
  }, exports.assertBlockStatement = function(node, opts = {}) {
    assert("BlockStatement", node, opts);
  }, exports.assertBreakStatement = function(node, opts = {}) {
    assert("BreakStatement", node, opts);
  }, exports.assertCallExpression = function(node, opts = {}) {
    assert("CallExpression", node, opts);
  }, exports.assertCatchClause = function(node, opts = {}) {
    assert("CatchClause", node, opts);
  }, exports.assertConditionalExpression = function(node, opts = {}) {
    assert("ConditionalExpression", node, opts);
  }, exports.assertContinueStatement = function(node, opts = {}) {
    assert("ContinueStatement", node, opts);
  }, exports.assertDebuggerStatement = function(node, opts = {}) {
    assert("DebuggerStatement", node, opts);
  }, exports.assertDoWhileStatement = function(node, opts = {}) {
    assert("DoWhileStatement", node, opts);
  }, exports.assertEmptyStatement = function(node, opts = {}) {
    assert("EmptyStatement", node, opts);
  }, exports.assertExpressionStatement = function(node, opts = {}) {
    assert("ExpressionStatement", node, opts);
  }, exports.assertFile = function(node, opts = {}) {
    assert("File", node, opts);
  }, exports.assertForInStatement = function(node, opts = {}) {
    assert("ForInStatement", node, opts);
  }, exports.assertForStatement = function(node, opts = {}) {
    assert("ForStatement", node, opts);
  }, exports.assertFunctionDeclaration = function(node, opts = {}) {
    assert("FunctionDeclaration", node, opts);
  }, exports.assertFunctionExpression = function(node, opts = {}) {
    assert("FunctionExpression", node, opts);
  }, exports.assertIdentifier = function(node, opts = {}) {
    assert("Identifier", node, opts);
  }, exports.assertIfStatement = function(node, opts = {}) {
    assert("IfStatement", node, opts);
  }, exports.assertLabeledStatement = function(node, opts = {}) {
    assert("LabeledStatement", node, opts);
  }, exports.assertStringLiteral = function(node, opts = {}) {
    assert("StringLiteral", node, opts);
  }, exports.assertNumericLiteral = function(node, opts = {}) {
    assert("NumericLiteral", node, opts);
  }, exports.assertNullLiteral = function(node, opts = {}) {
    assert("NullLiteral", node, opts);
  }, exports.assertBooleanLiteral = function(node, opts = {}) {
    assert("BooleanLiteral", node, opts);
  }, exports.assertRegExpLiteral = function(node, opts = {}) {
    assert("RegExpLiteral", node, opts);
  }, exports.assertLogicalExpression = function(node, opts = {}) {
    assert("LogicalExpression", node, opts);
  }, exports.assertMemberExpression = function(node, opts = {}) {
    assert("MemberExpression", node, opts);
  }, exports.assertNewExpression = function(node, opts = {}) {
    assert("NewExpression", node, opts);
  }, exports.assertProgram = function(node, opts = {}) {
    assert("Program", node, opts);
  }, exports.assertObjectExpression = function(node, opts = {}) {
    assert("ObjectExpression", node, opts);
  }, exports.assertObjectMethod = function(node, opts = {}) {
    assert("ObjectMethod", node, opts);
  }, exports.assertObjectProperty = function(node, opts = {}) {
    assert("ObjectProperty", node, opts);
  }, exports.assertRestElement = function(node, opts = {}) {
    assert("RestElement", node, opts);
  }, exports.assertReturnStatement = function(node, opts = {}) {
    assert("ReturnStatement", node, opts);
  }, exports.assertSequenceExpression = function(node, opts = {}) {
    assert("SequenceExpression", node, opts);
  }, exports.assertParenthesizedExpression = function(node, opts = {}) {
    assert("ParenthesizedExpression", node, opts);
  }, exports.assertSwitchCase = function(node, opts = {}) {
    assert("SwitchCase", node, opts);
  }, exports.assertSwitchStatement = function(node, opts = {}) {
    assert("SwitchStatement", node, opts);
  }, exports.assertThisExpression = function(node, opts = {}) {
    assert("ThisExpression", node, opts);
  }, exports.assertThrowStatement = function(node, opts = {}) {
    assert("ThrowStatement", node, opts);
  }, exports.assertTryStatement = function(node, opts = {}) {
    assert("TryStatement", node, opts);
  }, exports.assertUnaryExpression = function(node, opts = {}) {
    assert("UnaryExpression", node, opts);
  }, exports.assertUpdateExpression = function(node, opts = {}) {
    assert("UpdateExpression", node, opts);
  }, exports.assertVariableDeclaration = function(node, opts = {}) {
    assert("VariableDeclaration", node, opts);
  }, exports.assertVariableDeclarator = function(node, opts = {}) {
    assert("VariableDeclarator", node, opts);
  }, exports.assertWhileStatement = function(node, opts = {}) {
    assert("WhileStatement", node, opts);
  }, exports.assertWithStatement = function(node, opts = {}) {
    assert("WithStatement", node, opts);
  }, exports.assertAssignmentPattern = function(node, opts = {}) {
    assert("AssignmentPattern", node, opts);
  }, exports.assertArrayPattern = function(node, opts = {}) {
    assert("ArrayPattern", node, opts);
  }, exports.assertArrowFunctionExpression = function(node, opts = {}) {
    assert("ArrowFunctionExpression", node, opts);
  }, exports.assertClassBody = function(node, opts = {}) {
    assert("ClassBody", node, opts);
  }, exports.assertClassExpression = function(node, opts = {}) {
    assert("ClassExpression", node, opts);
  }, exports.assertClassDeclaration = function(node, opts = {}) {
    assert("ClassDeclaration", node, opts);
  }, exports.assertExportAllDeclaration = function(node, opts = {}) {
    assert("ExportAllDeclaration", node, opts);
  }, exports.assertExportDefaultDeclaration = function(node, opts = {}) {
    assert("ExportDefaultDeclaration", node, opts);
  }, exports.assertExportNamedDeclaration = function(node, opts = {}) {
    assert("ExportNamedDeclaration", node, opts);
  }, exports.assertExportSpecifier = function(node, opts = {}) {
    assert("ExportSpecifier", node, opts);
  }, exports.assertForOfStatement = function(node, opts = {}) {
    assert("ForOfStatement", node, opts);
  }, exports.assertImportDeclaration = function(node, opts = {}) {
    assert("ImportDeclaration", node, opts);
  }, exports.assertImportDefaultSpecifier = function(node, opts = {}) {
    assert("ImportDefaultSpecifier", node, opts);
  }, exports.assertImportNamespaceSpecifier = function(node, opts = {}) {
    assert("ImportNamespaceSpecifier", node, opts);
  }, exports.assertImportSpecifier = function(node, opts = {}) {
    assert("ImportSpecifier", node, opts);
  }, exports.assertMetaProperty = function(node, opts = {}) {
    assert("MetaProperty", node, opts);
  }, exports.assertClassMethod = function(node, opts = {}) {
    assert("ClassMethod", node, opts);
  }, exports.assertObjectPattern = function(node, opts = {}) {
    assert("ObjectPattern", node, opts);
  }, exports.assertSpreadElement = function(node, opts = {}) {
    assert("SpreadElement", node, opts);
  }, exports.assertSuper = function(node, opts = {}) {
    assert("Super", node, opts);
  }, exports.assertTaggedTemplateExpression = function(node, opts = {}) {
    assert("TaggedTemplateExpression", node, opts);
  }, exports.assertTemplateElement = function(node, opts = {}) {
    assert("TemplateElement", node, opts);
  }, exports.assertTemplateLiteral = function(node, opts = {}) {
    assert("TemplateLiteral", node, opts);
  }, exports.assertYieldExpression = function(node, opts = {}) {
    assert("YieldExpression", node, opts);
  }, exports.assertAnyTypeAnnotation = function(node, opts = {}) {
    assert("AnyTypeAnnotation", node, opts);
  }, exports.assertArrayTypeAnnotation = function(node, opts = {}) {
    assert("ArrayTypeAnnotation", node, opts);
  }, exports.assertBooleanTypeAnnotation = function(node, opts = {}) {
    assert("BooleanTypeAnnotation", node, opts);
  }, exports.assertBooleanLiteralTypeAnnotation = function(node, opts = {}) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  }, exports.assertNullLiteralTypeAnnotation = function(node, opts = {}) {
    assert("NullLiteralTypeAnnotation", node, opts);
  }, exports.assertClassImplements = function(node, opts = {}) {
    assert("ClassImplements", node, opts);
  }, exports.assertDeclareClass = function(node, opts = {}) {
    assert("DeclareClass", node, opts);
  }, exports.assertDeclareFunction = function(node, opts = {}) {
    assert("DeclareFunction", node, opts);
  }, exports.assertDeclareInterface = function(node, opts = {}) {
    assert("DeclareInterface", node, opts);
  }, exports.assertDeclareModule = function(node, opts = {}) {
    assert("DeclareModule", node, opts);
  }, exports.assertDeclareModuleExports = function(node, opts = {}) {
    assert("DeclareModuleExports", node, opts);
  }, exports.assertDeclareTypeAlias = function(node, opts = {}) {
    assert("DeclareTypeAlias", node, opts);
  }, exports.assertDeclareOpaqueType = function(node, opts = {}) {
    assert("DeclareOpaqueType", node, opts);
  }, exports.assertDeclareVariable = function(node, opts = {}) {
    assert("DeclareVariable", node, opts);
  }, exports.assertDeclareExportDeclaration = function(node, opts = {}) {
    assert("DeclareExportDeclaration", node, opts);
  }, exports.assertDeclareExportAllDeclaration = function(node, opts = {}) {
    assert("DeclareExportAllDeclaration", node, opts);
  }, exports.assertDeclaredPredicate = function(node, opts = {}) {
    assert("DeclaredPredicate", node, opts);
  }, exports.assertExistsTypeAnnotation = function(node, opts = {}) {
    assert("ExistsTypeAnnotation", node, opts);
  }, exports.assertFunctionTypeAnnotation = function(node, opts = {}) {
    assert("FunctionTypeAnnotation", node, opts);
  }, exports.assertFunctionTypeParam = function(node, opts = {}) {
    assert("FunctionTypeParam", node, opts);
  }, exports.assertGenericTypeAnnotation = function(node, opts = {}) {
    assert("GenericTypeAnnotation", node, opts);
  }, exports.assertInferredPredicate = function(node, opts = {}) {
    assert("InferredPredicate", node, opts);
  }, exports.assertInterfaceExtends = function(node, opts = {}) {
    assert("InterfaceExtends", node, opts);
  }, exports.assertInterfaceDeclaration = function(node, opts = {}) {
    assert("InterfaceDeclaration", node, opts);
  }, exports.assertInterfaceTypeAnnotation = function(node, opts = {}) {
    assert("InterfaceTypeAnnotation", node, opts);
  }, exports.assertIntersectionTypeAnnotation = function(node, opts = {}) {
    assert("IntersectionTypeAnnotation", node, opts);
  }, exports.assertMixedTypeAnnotation = function(node, opts = {}) {
    assert("MixedTypeAnnotation", node, opts);
  }, exports.assertEmptyTypeAnnotation = function(node, opts = {}) {
    assert("EmptyTypeAnnotation", node, opts);
  }, exports.assertNullableTypeAnnotation = function(node, opts = {}) {
    assert("NullableTypeAnnotation", node, opts);
  }, exports.assertNumberLiteralTypeAnnotation = function(node, opts = {}) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  }, exports.assertNumberTypeAnnotation = function(node, opts = {}) {
    assert("NumberTypeAnnotation", node, opts);
  }, exports.assertObjectTypeAnnotation = function(node, opts = {}) {
    assert("ObjectTypeAnnotation", node, opts);
  }, exports.assertObjectTypeInternalSlot = function(node, opts = {}) {
    assert("ObjectTypeInternalSlot", node, opts);
  }, exports.assertObjectTypeCallProperty = function(node, opts = {}) {
    assert("ObjectTypeCallProperty", node, opts);
  }, exports.assertObjectTypeIndexer = function(node, opts = {}) {
    assert("ObjectTypeIndexer", node, opts);
  }, exports.assertObjectTypeProperty = function(node, opts = {}) {
    assert("ObjectTypeProperty", node, opts);
  }, exports.assertObjectTypeSpreadProperty = function(node, opts = {}) {
    assert("ObjectTypeSpreadProperty", node, opts);
  }, exports.assertOpaqueType = function(node, opts = {}) {
    assert("OpaqueType", node, opts);
  }, exports.assertQualifiedTypeIdentifier = function(node, opts = {}) {
    assert("QualifiedTypeIdentifier", node, opts);
  }, exports.assertStringLiteralTypeAnnotation = function(node, opts = {}) {
    assert("StringLiteralTypeAnnotation", node, opts);
  }, exports.assertStringTypeAnnotation = function(node, opts = {}) {
    assert("StringTypeAnnotation", node, opts);
  }, exports.assertSymbolTypeAnnotation = function(node, opts = {}) {
    assert("SymbolTypeAnnotation", node, opts);
  }, exports.assertThisTypeAnnotation = function(node, opts = {}) {
    assert("ThisTypeAnnotation", node, opts);
  }, exports.assertTupleTypeAnnotation = function(node, opts = {}) {
    assert("TupleTypeAnnotation", node, opts);
  }, exports.assertTypeofTypeAnnotation = function(node, opts = {}) {
    assert("TypeofTypeAnnotation", node, opts);
  }, exports.assertTypeAlias = function(node, opts = {}) {
    assert("TypeAlias", node, opts);
  }, exports.assertTypeAnnotation = function(node, opts = {}) {
    assert("TypeAnnotation", node, opts);
  }, exports.assertTypeCastExpression = function(node, opts = {}) {
    assert("TypeCastExpression", node, opts);
  }, exports.assertTypeParameter = function(node, opts = {}) {
    assert("TypeParameter", node, opts);
  }, exports.assertTypeParameterDeclaration = function(node, opts = {}) {
    assert("TypeParameterDeclaration", node, opts);
  }, exports.assertTypeParameterInstantiation = function(node, opts = {}) {
    assert("TypeParameterInstantiation", node, opts);
  }, exports.assertUnionTypeAnnotation = function(node, opts = {}) {
    assert("UnionTypeAnnotation", node, opts);
  }, exports.assertVariance = function(node, opts = {}) {
    assert("Variance", node, opts);
  }, exports.assertVoidTypeAnnotation = function(node, opts = {}) {
    assert("VoidTypeAnnotation", node, opts);
  }, exports.assertEnumDeclaration = function(node, opts = {}) {
    assert("EnumDeclaration", node, opts);
  }, exports.assertEnumBooleanBody = function(node, opts = {}) {
    assert("EnumBooleanBody", node, opts);
  }, exports.assertEnumNumberBody = function(node, opts = {}) {
    assert("EnumNumberBody", node, opts);
  }, exports.assertEnumStringBody = function(node, opts = {}) {
    assert("EnumStringBody", node, opts);
  }, exports.assertEnumSymbolBody = function(node, opts = {}) {
    assert("EnumSymbolBody", node, opts);
  }, exports.assertEnumBooleanMember = function(node, opts = {}) {
    assert("EnumBooleanMember", node, opts);
  }, exports.assertEnumNumberMember = function(node, opts = {}) {
    assert("EnumNumberMember", node, opts);
  }, exports.assertEnumStringMember = function(node, opts = {}) {
    assert("EnumStringMember", node, opts);
  }, exports.assertEnumDefaultedMember = function(node, opts = {}) {
    assert("EnumDefaultedMember", node, opts);
  }, exports.assertJSXAttribute = function(node, opts = {}) {
    assert("JSXAttribute", node, opts);
  }, exports.assertJSXClosingElement = function(node, opts = {}) {
    assert("JSXClosingElement", node, opts);
  }, exports.assertJSXElement = function(node, opts = {}) {
    assert("JSXElement", node, opts);
  }, exports.assertJSXEmptyExpression = function(node, opts = {}) {
    assert("JSXEmptyExpression", node, opts);
  }, exports.assertJSXExpressionContainer = function(node, opts = {}) {
    assert("JSXExpressionContainer", node, opts);
  }, exports.assertJSXSpreadChild = function(node, opts = {}) {
    assert("JSXSpreadChild", node, opts);
  }, exports.assertJSXIdentifier = function(node, opts = {}) {
    assert("JSXIdentifier", node, opts);
  }, exports.assertJSXMemberExpression = function(node, opts = {}) {
    assert("JSXMemberExpression", node, opts);
  }, exports.assertJSXNamespacedName = function(node, opts = {}) {
    assert("JSXNamespacedName", node, opts);
  }, exports.assertJSXOpeningElement = function(node, opts = {}) {
    assert("JSXOpeningElement", node, opts);
  }, exports.assertJSXSpreadAttribute = function(node, opts = {}) {
    assert("JSXSpreadAttribute", node, opts);
  }, exports.assertJSXText = function(node, opts = {}) {
    assert("JSXText", node, opts);
  }, exports.assertJSXFragment = function(node, opts = {}) {
    assert("JSXFragment", node, opts);
  }, exports.assertJSXOpeningFragment = function(node, opts = {}) {
    assert("JSXOpeningFragment", node, opts);
  }, exports.assertJSXClosingFragment = function(node, opts = {}) {
    assert("JSXClosingFragment", node, opts);
  }, exports.assertNoop = function(node, opts = {}) {
    assert("Noop", node, opts);
  }, exports.assertPlaceholder = function(node, opts = {}) {
    assert("Placeholder", node, opts);
  }, exports.assertV8IntrinsicIdentifier = function(node, opts = {}) {
    assert("V8IntrinsicIdentifier", node, opts);
  }, exports.assertArgumentPlaceholder = function(node, opts = {}) {
    assert("ArgumentPlaceholder", node, opts);
  }, exports.assertAwaitExpression = function(node, opts = {}) {
    assert("AwaitExpression", node, opts);
  }, exports.assertBindExpression = function(node, opts = {}) {
    assert("BindExpression", node, opts);
  }, exports.assertClassProperty = function(node, opts = {}) {
    assert("ClassProperty", node, opts);
  }, exports.assertOptionalMemberExpression = function(node, opts = {}) {
    assert("OptionalMemberExpression", node, opts);
  }, exports.assertPipelineTopicExpression = function(node, opts = {}) {
    assert("PipelineTopicExpression", node, opts);
  }, exports.assertPipelineBareFunction = function(node, opts = {}) {
    assert("PipelineBareFunction", node, opts);
  }, exports.assertPipelinePrimaryTopicReference = function(node, opts = {}) {
    assert("PipelinePrimaryTopicReference", node, opts);
  }, exports.assertOptionalCallExpression = function(node, opts = {}) {
    assert("OptionalCallExpression", node, opts);
  }, exports.assertClassPrivateProperty = function(node, opts = {}) {
    assert("ClassPrivateProperty", node, opts);
  }, exports.assertClassPrivateMethod = function(node, opts = {}) {
    assert("ClassPrivateMethod", node, opts);
  }, exports.assertImport = function(node, opts = {}) {
    assert("Import", node, opts);
  }, exports.assertImportAttribute = function(node, opts = {}) {
    assert("ImportAttribute", node, opts);
  }, exports.assertDecorator = function(node, opts = {}) {
    assert("Decorator", node, opts);
  }, exports.assertDoExpression = function(node, opts = {}) {
    assert("DoExpression", node, opts);
  }, exports.assertExportDefaultSpecifier = function(node, opts = {}) {
    assert("ExportDefaultSpecifier", node, opts);
  }, exports.assertExportNamespaceSpecifier = function(node, opts = {}) {
    assert("ExportNamespaceSpecifier", node, opts);
  }, exports.assertPrivateName = function(node, opts = {}) {
    assert("PrivateName", node, opts);
  }, exports.assertBigIntLiteral = function(node, opts = {}) {
    assert("BigIntLiteral", node, opts);
  }, exports.assertRecordExpression = function(node, opts = {}) {
    assert("RecordExpression", node, opts);
  }, exports.assertTupleExpression = function(node, opts = {}) {
    assert("TupleExpression", node, opts);
  }, exports.assertTSParameterProperty = function(node, opts = {}) {
    assert("TSParameterProperty", node, opts);
  }, exports.assertTSDeclareFunction = function(node, opts = {}) {
    assert("TSDeclareFunction", node, opts);
  }, exports.assertTSDeclareMethod = function(node, opts = {}) {
    assert("TSDeclareMethod", node, opts);
  }, exports.assertTSQualifiedName = function(node, opts = {}) {
    assert("TSQualifiedName", node, opts);
  }, exports.assertTSCallSignatureDeclaration = function(node, opts = {}) {
    assert("TSCallSignatureDeclaration", node, opts);
  }, exports.assertTSConstructSignatureDeclaration = function(node, opts = {}) {
    assert("TSConstructSignatureDeclaration", node, opts);
  }, exports.assertTSPropertySignature = function(node, opts = {}) {
    assert("TSPropertySignature", node, opts);
  }, exports.assertTSMethodSignature = function(node, opts = {}) {
    assert("TSMethodSignature", node, opts);
  }, exports.assertTSIndexSignature = function(node, opts = {}) {
    assert("TSIndexSignature", node, opts);
  }, exports.assertTSAnyKeyword = function(node, opts = {}) {
    assert("TSAnyKeyword", node, opts);
  }, exports.assertTSBooleanKeyword = function(node, opts = {}) {
    assert("TSBooleanKeyword", node, opts);
  }, exports.assertTSBigIntKeyword = function(node, opts = {}) {
    assert("TSBigIntKeyword", node, opts);
  }, exports.assertTSNeverKeyword = function(node, opts = {}) {
    assert("TSNeverKeyword", node, opts);
  }, exports.assertTSNullKeyword = function(node, opts = {}) {
    assert("TSNullKeyword", node, opts);
  }, exports.assertTSNumberKeyword = function(node, opts = {}) {
    assert("TSNumberKeyword", node, opts);
  }, exports.assertTSObjectKeyword = function(node, opts = {}) {
    assert("TSObjectKeyword", node, opts);
  }, exports.assertTSStringKeyword = function(node, opts = {}) {
    assert("TSStringKeyword", node, opts);
  }, exports.assertTSSymbolKeyword = function(node, opts = {}) {
    assert("TSSymbolKeyword", node, opts);
  }, exports.assertTSUndefinedKeyword = function(node, opts = {}) {
    assert("TSUndefinedKeyword", node, opts);
  }, exports.assertTSUnknownKeyword = function(node, opts = {}) {
    assert("TSUnknownKeyword", node, opts);
  }, exports.assertTSVoidKeyword = function(node, opts = {}) {
    assert("TSVoidKeyword", node, opts);
  }, exports.assertTSThisType = function(node, opts = {}) {
    assert("TSThisType", node, opts);
  }, exports.assertTSFunctionType = function(node, opts = {}) {
    assert("TSFunctionType", node, opts);
  }, exports.assertTSConstructorType = function(node, opts = {}) {
    assert("TSConstructorType", node, opts);
  }, exports.assertTSTypeReference = function(node, opts = {}) {
    assert("TSTypeReference", node, opts);
  }, exports.assertTSTypePredicate = function(node, opts = {}) {
    assert("TSTypePredicate", node, opts);
  }, exports.assertTSTypeQuery = function(node, opts = {}) {
    assert("TSTypeQuery", node, opts);
  }, exports.assertTSTypeLiteral = function(node, opts = {}) {
    assert("TSTypeLiteral", node, opts);
  }, exports.assertTSArrayType = function(node, opts = {}) {
    assert("TSArrayType", node, opts);
  }, exports.assertTSTupleType = function(node, opts = {}) {
    assert("TSTupleType", node, opts);
  }, exports.assertTSOptionalType = function(node, opts = {}) {
    assert("TSOptionalType", node, opts);
  }, exports.assertTSRestType = function(node, opts = {}) {
    assert("TSRestType", node, opts);
  }, exports.assertTSUnionType = function(node, opts = {}) {
    assert("TSUnionType", node, opts);
  }, exports.assertTSIntersectionType = function(node, opts = {}) {
    assert("TSIntersectionType", node, opts);
  }, exports.assertTSConditionalType = function(node, opts = {}) {
    assert("TSConditionalType", node, opts);
  }, exports.assertTSInferType = function(node, opts = {}) {
    assert("TSInferType", node, opts);
  }, exports.assertTSParenthesizedType = function(node, opts = {}) {
    assert("TSParenthesizedType", node, opts);
  }, exports.assertTSTypeOperator = function(node, opts = {}) {
    assert("TSTypeOperator", node, opts);
  }, exports.assertTSIndexedAccessType = function(node, opts = {}) {
    assert("TSIndexedAccessType", node, opts);
  }, exports.assertTSMappedType = function(node, opts = {}) {
    assert("TSMappedType", node, opts);
  }, exports.assertTSLiteralType = function(node, opts = {}) {
    assert("TSLiteralType", node, opts);
  }, exports.assertTSExpressionWithTypeArguments = function(node, opts = {}) {
    assert("TSExpressionWithTypeArguments", node, opts);
  }, exports.assertTSInterfaceDeclaration = function(node, opts = {}) {
    assert("TSInterfaceDeclaration", node, opts);
  }, exports.assertTSInterfaceBody = function(node, opts = {}) {
    assert("TSInterfaceBody", node, opts);
  }, exports.assertTSTypeAliasDeclaration = function(node, opts = {}) {
    assert("TSTypeAliasDeclaration", node, opts);
  }, exports.assertTSAsExpression = function(node, opts = {}) {
    assert("TSAsExpression", node, opts);
  }, exports.assertTSTypeAssertion = function(node, opts = {}) {
    assert("TSTypeAssertion", node, opts);
  }, exports.assertTSEnumDeclaration = function(node, opts = {}) {
    assert("TSEnumDeclaration", node, opts);
  }, exports.assertTSEnumMember = function(node, opts = {}) {
    assert("TSEnumMember", node, opts);
  }, exports.assertTSModuleDeclaration = function(node, opts = {}) {
    assert("TSModuleDeclaration", node, opts);
  }, exports.assertTSModuleBlock = function(node, opts = {}) {
    assert("TSModuleBlock", node, opts);
  }, exports.assertTSImportType = function(node, opts = {}) {
    assert("TSImportType", node, opts);
  }, exports.assertTSImportEqualsDeclaration = function(node, opts = {}) {
    assert("TSImportEqualsDeclaration", node, opts);
  }, exports.assertTSExternalModuleReference = function(node, opts = {}) {
    assert("TSExternalModuleReference", node, opts);
  }, exports.assertTSNonNullExpression = function(node, opts = {}) {
    assert("TSNonNullExpression", node, opts);
  }, exports.assertTSExportAssignment = function(node, opts = {}) {
    assert("TSExportAssignment", node, opts);
  }, exports.assertTSNamespaceExportDeclaration = function(node, opts = {}) {
    assert("TSNamespaceExportDeclaration", node, opts);
  }, exports.assertTSTypeAnnotation = function(node, opts = {}) {
    assert("TSTypeAnnotation", node, opts);
  }, exports.assertTSTypeParameterInstantiation = function(node, opts = {}) {
    assert("TSTypeParameterInstantiation", node, opts);
  }, exports.assertTSTypeParameterDeclaration = function(node, opts = {}) {
    assert("TSTypeParameterDeclaration", node, opts);
  }, exports.assertTSTypeParameter = function(node, opts = {}) {
    assert("TSTypeParameter", node, opts);
  }, exports.assertExpression = function(node, opts = {}) {
    assert("Expression", node, opts);
  }, exports.assertBinary = function(node, opts = {}) {
    assert("Binary", node, opts);
  }, exports.assertScopable = function(node, opts = {}) {
    assert("Scopable", node, opts);
  }, exports.assertBlockParent = function(node, opts = {}) {
    assert("BlockParent", node, opts);
  }, exports.assertBlock = function(node, opts = {}) {
    assert("Block", node, opts);
  }, exports.assertStatement = function(node, opts = {}) {
    assert("Statement", node, opts);
  }, exports.assertTerminatorless = function(node, opts = {}) {
    assert("Terminatorless", node, opts);
  }, exports.assertCompletionStatement = function(node, opts = {}) {
    assert("CompletionStatement", node, opts);
  }, exports.assertConditional = function(node, opts = {}) {
    assert("Conditional", node, opts);
  }, exports.assertLoop = function(node, opts = {}) {
    assert("Loop", node, opts);
  }, exports.assertWhile = function(node, opts = {}) {
    assert("While", node, opts);
  }, exports.assertExpressionWrapper = function(node, opts = {}) {
    assert("ExpressionWrapper", node, opts);
  }, exports.assertFor = function(node, opts = {}) {
    assert("For", node, opts);
  }, exports.assertForXStatement = function(node, opts = {}) {
    assert("ForXStatement", node, opts);
  }, exports.assertFunction = function(node, opts = {}) {
    assert("Function", node, opts);
  }, exports.assertFunctionParent = function(node, opts = {}) {
    assert("FunctionParent", node, opts);
  }, exports.assertPureish = function(node, opts = {}) {
    assert("Pureish", node, opts);
  }, exports.assertDeclaration = function(node, opts = {}) {
    assert("Declaration", node, opts);
  }, exports.assertPatternLike = function(node, opts = {}) {
    assert("PatternLike", node, opts);
  }, exports.assertLVal = function(node, opts = {}) {
    assert("LVal", node, opts);
  }, exports.assertTSEntityName = function(node, opts = {}) {
    assert("TSEntityName", node, opts);
  }, exports.assertLiteral = function(node, opts = {}) {
    assert("Literal", node, opts);
  }, exports.assertImmutable = function(node, opts = {}) {
    assert("Immutable", node, opts);
  }, exports.assertUserWhitespacable = function(node, opts = {}) {
    assert("UserWhitespacable", node, opts);
  }, exports.assertMethod = function(node, opts = {}) {
    assert("Method", node, opts);
  }, exports.assertObjectMember = function(node, opts = {}) {
    assert("ObjectMember", node, opts);
  }, exports.assertProperty = function(node, opts = {}) {
    assert("Property", node, opts);
  }, exports.assertUnaryLike = function(node, opts = {}) {
    assert("UnaryLike", node, opts);
  }, exports.assertPattern = function(node, opts = {}) {
    assert("Pattern", node, opts);
  }, exports.assertClass = function(node, opts = {}) {
    assert("Class", node, opts);
  }, exports.assertModuleDeclaration = function(node, opts = {}) {
    assert("ModuleDeclaration", node, opts);
  }, exports.assertExportDeclaration = function(node, opts = {}) {
    assert("ExportDeclaration", node, opts);
  }, exports.assertModuleSpecifier = function(node, opts = {}) {
    assert("ModuleSpecifier", node, opts);
  }, exports.assertFlow = function(node, opts = {}) {
    assert("Flow", node, opts);
  }, exports.assertFlowType = function(node, opts = {}) {
    assert("FlowType", node, opts);
  }, exports.assertFlowBaseAnnotation = function(node, opts = {}) {
    assert("FlowBaseAnnotation", node, opts);
  }, exports.assertFlowDeclaration = function(node, opts = {}) {
    assert("FlowDeclaration", node, opts);
  }, exports.assertFlowPredicate = function(node, opts = {}) {
    assert("FlowPredicate", node, opts);
  }, exports.assertEnumBody = function(node, opts = {}) {
    assert("EnumBody", node, opts);
  }, exports.assertEnumMember = function(node, opts = {}) {
    assert("EnumMember", node, opts);
  }, exports.assertJSX = function(node, opts = {}) {
    assert("JSX", node, opts);
  }, exports.assertPrivate = function(node, opts = {}) {
    assert("Private", node, opts);
  }, exports.assertTSTypeElement = function(node, opts = {}) {
    assert("TSTypeElement", node, opts);
  }, exports.assertTSType = function(node, opts = {}) {
    assert("TSType", node, opts);
  }, exports.assertTSBaseType = function(node, opts = {}) {
    assert("TSBaseType", node, opts);
  }, exports.assertNumberLiteral = function(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral"), 
    assert("NumberLiteral", node, opts);
  }, exports.assertRegexLiteral = function(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral"), assert("RegexLiteral", node, opts);
  }, exports.assertRestProperty = function(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement"), assert("RestProperty", node, opts);
  }, exports.assertSpreadProperty = function(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement"), 
    assert("SpreadProperty", node, opts);
  };
  var obj, _is = (obj = __webpack_require__(26)) && obj.__esModule ? obj : {
    default: obj
  };
  function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node.type}".`);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(type) {
    if ("string" === type) return (0, _generated.stringTypeAnnotation)();
    if ("number" === type) return (0, _generated.numberTypeAnnotation)();
    if ("undefined" === type) return (0, _generated.voidTypeAnnotation)();
    if ("boolean" === type) return (0, _generated.booleanTypeAnnotation)();
    if ("function" === type) return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
    if ("object" === type) return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
    if ("symbol" === type) return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
    throw new Error("Invalid typeof value");
  };
  var _generated = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(types) {
    const flattened = (0, _removeTypeDuplicates.default)(types);
    return 1 === flattened.length ? flattened[0] : (0, _generated.unionTypeAnnotation)(flattened);
  };
  var obj, _generated = __webpack_require__(4), _removeTypeDuplicates = (obj = __webpack_require__(116)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(typeAnnotations) {
    const types = typeAnnotations.map(type => type.typeAnnotations), flattened = (0, 
    _removeTypeDuplicates.default)(types);
    return 1 === flattened.length ? flattened[0] : (0, _generated.tsUnionType)(flattened);
  };
  var obj, _generated = __webpack_require__(4), _removeTypeDuplicates = (obj = __webpack_require__(264)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(nodes) {
    const generics = {}, bases = {}, typeGroups = [], types = [];
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node && !(types.indexOf(node) >= 0)) {
        if ((0, _generated.isTSAnyKeyword)(node.type)) return [ node ];
        (0, _generated.isTSBaseType)(node) ? bases[node.type] = node : (0, _generated.isTSUnionType)(node) ? typeGroups.indexOf(node.types) < 0 && (nodes = nodes.concat(node.types), 
        typeGroups.push(node.types)) : types.push(node);
      }
    }
    for (const type of Object.keys(bases)) types.push(bases[type]);
    for (const name of Object.keys(generics)) types.push(generics[name]);
    return types;
  };
  var _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _cloneNode.default)(node, !1);
  };
  var obj, _cloneNode = (obj = __webpack_require__(17)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _cloneNode.default)(node);
  };
  var obj, _cloneNode = (obj = __webpack_require__(17)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _cloneNode.default)(node, !0, !0);
  };
  var obj, _cloneNode = (obj = __webpack_require__(17)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _cloneNode.default)(node, !1, !0);
  };
  var obj, _cloneNode = (obj = __webpack_require__(17)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, type, content, line) {
    return (0, _addComments.default)(node, type, [ {
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    } ]);
  };
  var obj, _addComments = (obj = __webpack_require__(117)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return _constants.COMMENT_KEYS.forEach(key => {
      node[key] = null;
    }), node;
  };
  var _constants = __webpack_require__(16);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;
  var _definitions = __webpack_require__(5);
  const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Expression;
  exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
  const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Binary;
  exports.BINARY_TYPES = BINARY_TYPES;
  const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Scopable;
  exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
  const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.BlockParent;
  exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
  const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Block;
  exports.BLOCK_TYPES = BLOCK_TYPES;
  const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Statement;
  exports.STATEMENT_TYPES = STATEMENT_TYPES;
  const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Terminatorless;
  exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
  const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.CompletionStatement;
  exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
  const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Conditional;
  exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
  const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Loop;
  exports.LOOP_TYPES = LOOP_TYPES;
  const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.While;
  exports.WHILE_TYPES = WHILE_TYPES;
  const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
  exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
  const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS.For;
  exports.FOR_TYPES = FOR_TYPES;
  const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ForXStatement;
  exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
  const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Function;
  exports.FUNCTION_TYPES = FUNCTION_TYPES;
  const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FunctionParent;
  exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
  const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pureish;
  exports.PUREISH_TYPES = PUREISH_TYPES;
  const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Declaration;
  exports.DECLARATION_TYPES = DECLARATION_TYPES;
  const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.PatternLike;
  exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
  const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.LVal;
  exports.LVAL_TYPES = LVAL_TYPES;
  const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSEntityName;
  exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
  const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Literal;
  exports.LITERAL_TYPES = LITERAL_TYPES;
  const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Immutable;
  exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
  const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UserWhitespacable;
  exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
  const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Method;
  exports.METHOD_TYPES = METHOD_TYPES;
  const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ObjectMember;
  exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
  const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Property;
  exports.PROPERTY_TYPES = PROPERTY_TYPES;
  const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.UnaryLike;
  exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
  const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Pattern;
  exports.PATTERN_TYPES = PATTERN_TYPES;
  const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Class;
  exports.CLASS_TYPES = CLASS_TYPES;
  const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
  exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
  const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ExportDeclaration;
  exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
  const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
  exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
  const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Flow;
  exports.FLOW_TYPES = FLOW_TYPES;
  const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowType;
  exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
  const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
  exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
  const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowDeclaration;
  exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
  const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.FlowPredicate;
  exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
  const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumBody;
  exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
  const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS.EnumMember;
  exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
  const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS.JSX;
  exports.JSX_TYPES = JSX_TYPES;
  const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.Private;
  exports.PRIVATE_TYPES = PRIVATE_TYPES;
  const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSTypeElement;
  exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
  const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSType;
  exports.TSTYPE_TYPES = TSTYPE_TYPES;
  const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS.TSBaseType;
  exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, key = "body") {
    return node[key] = (0, _toBlock.default)(node[key], node);
  };
  var obj, _toBlock = (obj = __webpack_require__(122)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(name) {
    "eval" !== (name = (0, _toIdentifier.default)(name)) && "arguments" !== name || (name = "_" + name);
    return name;
  };
  var obj, _toIdentifier = (obj = __webpack_require__(123)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, key = node.key || node.property) {
    !node.computed && (0, _generated.isIdentifier)(key) && (key = (0, _generated2.stringLiteral)(key.name));
    return key;
  };
  var _generated = __webpack_require__(3), _generated2 = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    (0, _generated.isExpressionStatement)(node) && (node = node.expression);
    if ((0, _generated.isExpression)(node)) return node;
    (0, _generated.isClass)(node) ? node.type = "ClassExpression" : (0, _generated.isFunction)(node) && (node.type = "FunctionExpression");
    if (!(0, _generated.isExpression)(node)) throw new Error(`cannot turn ${node.type} to an expression`);
    return node;
  };
  var _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = toKeyAlias;
  var _generated = __webpack_require__(3), _cloneNode = _interopRequireDefault(__webpack_require__(17)), _removePropertiesDeep = _interopRequireDefault(__webpack_require__(124));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function toKeyAlias(node, key = node.key) {
    let alias;
    return "method" === node.kind ? toKeyAlias.increment() + "" : (alias = (0, _generated.isIdentifier)(key) ? key.name : (0, 
    _generated.isStringLiteral)(key) ? JSON.stringify(key.value) : JSON.stringify((0, 
    _removePropertiesDeep.default)((0, _cloneNode.default)(key))), node.computed && (alias = `[${alias}]`), 
    node.static && (alias = "static:" + alias), alias);
  }
  toKeyAlias.uid = 0, toKeyAlias.increment = function() {
    return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(nodes, scope) {
    if (!(null == nodes ? void 0 : nodes.length)) return;
    const declars = [], result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result) return;
    for (const declar of declars) scope.push(declar);
    return result;
  };
  var obj, _gatherSequenceExpressions = (obj = __webpack_require__(278)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = !0;
    for (const node of nodes) if ((0, _generated.isEmptyStatement)(node) || (ensureLastUndefined = !1), 
    (0, _generated.isExpression)(node)) exprs.push(node); else if ((0, _generated.isExpressionStatement)(node)) exprs.push(node.expression); else if ((0, 
    _generated.isVariableDeclaration)(node)) {
      if ("var" !== node.kind) return;
      for (const declar of node.declarations) {
        const bindings = (0, _getBindingIdentifiers.default)(declar);
        for (const key of Object.keys(bindings)) declars.push({
          kind: node.kind,
          id: (0, _cloneNode.default)(bindings[key])
        });
        declar.init && exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
      }
      ensureLastUndefined = !0;
    } else if ((0, _generated.isIfStatement)(node)) {
      const consequent = node.consequent ? gatherSequenceExpressions([ node.consequent ], scope, declars) : scope.buildUndefinedNode(), alternate = node.alternate ? gatherSequenceExpressions([ node.alternate ], scope, declars) : scope.buildUndefinedNode();
      if (!consequent || !alternate) return;
      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
    } else if ((0, _generated.isBlockStatement)(node)) {
      const body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return;
      exprs.push(body);
    } else {
      if (!(0, _generated.isEmptyStatement)(node)) return;
      0 === nodes.indexOf(node) && (ensureLastUndefined = !0);
    }
    ensureLastUndefined && exprs.push(scope.buildUndefinedNode());
    return 1 === exprs.length ? exprs[0] : (0, _generated2.sequenceExpression)(exprs);
  };
  var _getBindingIdentifiers = _interopRequireDefault(__webpack_require__(40)), _generated = __webpack_require__(3), _generated2 = __webpack_require__(4), _cloneNode = _interopRequireDefault(__webpack_require__(17));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, ignore) {
    if ((0, _generated.isStatement)(node)) return node;
    let newType, mustHaveId = !1;
    if ((0, _generated.isClass)(node)) mustHaveId = !0, newType = "ClassDeclaration"; else if ((0, 
    _generated.isFunction)(node)) mustHaveId = !0, newType = "FunctionDeclaration"; else if ((0, 
    _generated.isAssignmentExpression)(node)) return (0, _generated2.expressionStatement)(node);
    mustHaveId && !node.id && (newType = !1);
    if (!newType) {
      if (ignore) return !1;
      throw new Error(`cannot turn ${node.type} to a statement`);
    }
    return node.type = newType, node;
  };
  var _generated = __webpack_require__(3), _generated2 = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function valueToNode(value) {
    if (void 0 === value) return (0, _generated.identifier)("undefined");
    if (!0 === value || !1 === value) return (0, _generated.booleanLiteral)(value);
    if (null === value) return (0, _generated.nullLiteral)();
    if ("string" == typeof value) return (0, _generated.stringLiteral)(value);
    if ("number" == typeof value) {
      let result;
      if (Number.isFinite(value)) result = (0, _generated.numericLiteral)(Math.abs(value)); else {
        let numerator;
        numerator = Number.isNaN(value) ? (0, _generated.numericLiteral)(0) : (0, _generated.numericLiteral)(1), 
        result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
      }
      return (value < 0 || Object.is(value, -0)) && (result = (0, _generated.unaryExpression)("-", result)), 
      result;
    }
    if ((0, _isRegExp.default)(value)) {
      const pattern = value.source, flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return (0, _generated.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) return (0, _generated.arrayExpression)(value.map(valueToNode));
    if ((0, _isPlainObject.default)(value)) {
      const props = [];
      for (const key of Object.keys(value)) {
        let nodeKey;
        nodeKey = (0, _isValidIdentifier.default)(key) ? (0, _generated.identifier)(key) : (0, 
        _generated.stringLiteral)(key), props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
      }
      return (0, _generated.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  };
  var _isPlainObject = _interopRequireDefault(__webpack_require__(281)), _isRegExp = _interopRequireDefault(__webpack_require__(282)), _isValidIdentifier = _interopRequireDefault(__webpack_require__(27)), _generated = __webpack_require__(4);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(13), getPrototype = __webpack_require__(64), isObjectLike = __webpack_require__(9), funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object);
  module.exports = function(value) {
    if (!isObjectLike(value) || "[object Object]" != baseGetTag(value)) return !1;
    var proto = getPrototype(value);
    if (null === proto) return !0;
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  };
}, function(module, exports, __webpack_require__) {
  var baseIsRegExp = __webpack_require__(283), baseUnary = __webpack_require__(25), nodeUtil = __webpack_require__(37), nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
  module.exports = isRegExp;
}, function(module, exports, __webpack_require__) {
  var baseGetTag = __webpack_require__(13), isObjectLike = __webpack_require__(9);
  module.exports = function(value) {
    return isObjectLike(value) && "[object RegExp]" == baseGetTag(value);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(member, append, computed = !1) {
    return member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed), 
    member.property = append, member.computed = !!computed, member;
  };
  var _generated = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(child, parent) {
    if (!child || !parent) return child;
    for (const key of _constants.INHERIT_KEYS.optional) null == child[key] && (child[key] = parent[key]);
    for (const key of Object.keys(parent)) "_" === key[0] && "__clone" !== key && (child[key] = parent[key]);
    for (const key of _constants.INHERIT_KEYS.force) child[key] = parent[key];
    return (0, _inheritsComments.default)(child, parent), child;
  };
  var obj, _constants = __webpack_require__(16), _inheritsComments = (obj = __webpack_require__(120)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(member, prepend) {
    return member.object = (0, _generated.memberExpression)(prepend, member.object), 
    member;
  };
  var _generated = __webpack_require__(4);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, duplicates) {
    return (0, _getBindingIdentifiers.default)(node, duplicates, !0);
  };
  var obj, _getBindingIdentifiers = (obj = __webpack_require__(40)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, handlers, state) {
    "function" == typeof handlers && (handlers = {
      enter: handlers
    });
    const {enter: enter, exit: exit} = handlers;
    !function traverseSimpleImpl(node, enter, exit, state, ancestors) {
      const keys = _definitions.VISITOR_KEYS[node.type];
      if (!keys) return;
      enter && enter(node, ancestors, state);
      for (const key of keys) {
        const subNode = node[key];
        if (Array.isArray(subNode)) for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];
          child && (ancestors.push({
            node: node,
            key: key,
            index: i
          }), traverseSimpleImpl(child, enter, exit, state, ancestors), ancestors.pop());
        } else subNode && (ancestors.push({
          node: node,
          key: key
        }), traverseSimpleImpl(subNode, enter, exit, state, ancestors), ancestors.pop());
      }
      exit && exit(node, ancestors, state);
    }(node, enter, exit, state, []);
  };
  var _definitions = __webpack_require__(5);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, parent, grandparent) {
    if (grandparent && "Identifier" === node.type && "ObjectProperty" === parent.type && "ObjectExpression" === grandparent.type) return !1;
    const keys = _getBindingIdentifiers.default.keys[parent.type];
    if (keys) for (let i = 0; i < keys.length; i++) {
      const key = keys[i], val = parent[key];
      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return !0;
      } else if (val === node) return !0;
    }
    return !1;
  };
  var obj, _getBindingIdentifiers = (obj = __webpack_require__(40)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, 
    _isLet.default)(node);
  };
  var obj, _generated = __webpack_require__(3), _isLet = (obj = __webpack_require__(127)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return !0;
    if ((0, _generated.isIdentifier)(node)) return "undefined" === node.name;
    return !1;
  };
  var obj, _isType = (obj = __webpack_require__(67)) && obj.__esModule ? obj : {
    default: obj
  }, _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function isNodesEquivalent(a, b) {
    if ("object" != typeof a || "object" != typeof b || null == a || null == b) return a === b;
    if (a.type !== b.type) return !1;
    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type), visitorKeys = _definitions.VISITOR_KEYS[a.type];
    for (const field of fields) {
      if (typeof a[field] != typeof b[field]) return !1;
      if (null != a[field] || null != b[field]) {
        if (null == a[field] || null == b[field]) return !1;
        if (Array.isArray(a[field])) {
          if (!Array.isArray(b[field])) return !1;
          if (a[field].length !== b[field].length) return !1;
          for (let i = 0; i < a[field].length; i++) if (!isNodesEquivalent(a[field][i], b[field][i])) return !1;
        } else if ("object" != typeof a[field] || (null == visitorKeys ? void 0 : visitorKeys.includes(field))) {
          if (!isNodesEquivalent(a[field], b[field])) return !1;
        } else for (const key of Object.keys(a[field])) if (a[field][key] !== b[field][key]) return !1;
      }
    }
    return !0;
  };
  var _definitions = __webpack_require__(5);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, parent, grandparent) {
    switch (parent.type) {
     case "MemberExpression":
     case "JSXMemberExpression":
     case "OptionalMemberExpression":
      return parent.property === node ? !!parent.computed : parent.object === node;

     case "VariableDeclarator":
      return parent.init === node;

     case "ArrowFunctionExpression":
      return parent.body === node;

     case "ExportSpecifier":
      return !parent.source && parent.local === node;

     case "PrivateName":
      return !1;

     case "ClassMethod":
     case "ClassPrivateMethod":
     case "ObjectMethod":
      if (parent.params.includes(node)) return !1;

     case "ObjectProperty":
     case "ClassProperty":
     case "ClassPrivateProperty":
      return parent.key === node ? !!parent.computed : parent.value !== node || (!grandparent || "ObjectPattern" !== grandparent.type);

     case "ClassDeclaration":
     case "ClassExpression":
      return parent.superClass === node;

     case "AssignmentExpression":
     case "AssignmentPattern":
      return parent.right === node;

     case "LabeledStatement":
     case "CatchClause":
     case "RestElement":
      return !1;

     case "BreakStatement":
     case "ContinueStatement":
      return !1;

     case "FunctionDeclaration":
     case "FunctionExpression":
      return !1;

     case "ExportNamespaceSpecifier":
     case "ExportDefaultSpecifier":
      return !1;

     case "ImportDefaultSpecifier":
     case "ImportNamespaceSpecifier":
     case "ImportSpecifier":
     case "JSXAttribute":
      return !1;

     case "ObjectPattern":
     case "ArrayPattern":
     case "MetaProperty":
      return !1;

     case "ObjectTypeProperty":
      return parent.key !== node;

     case "TSEnumMember":
      return parent.id !== node;

     case "TSPropertySignature":
      return parent.key !== node || !!parent.computed;
    }
    return !0;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, parent) {
    if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
      body: node
    })) return !1;
    if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
      body: node
    })) return !1;
    if ((0, _generated.isPattern)(node) && (0, _generated.isFunction)(parent)) return !0;
    return (0, _generated.isScopable)(node);
  };
  var _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(specifier) {
    return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  };
  var _generated = __webpack_require__(3);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  };
  var obj, _isValidIdentifier = (obj = __webpack_require__(27)) && obj.__esModule ? obj : {
    default: obj
  };
  const RESERVED_WORDS_ES3_ONLY = new Set([ "abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile" ]);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    return (0, _generated.isVariableDeclaration)(node, {
      kind: "var"
    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
  };
  var _generated = __webpack_require__(3), _constants = __webpack_require__(16);
}, function(module, exports, __webpack_require__) {
  "use strict";
  function makeStatementFormatter(fn) {
    return {
      code: str => "/* @babel/template */;\n" + str,
      validate: () => {},
      unwrap: ast => fn(ast.program.body.slice(1))
    };
  }
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.program = exports.expression = exports.statement = exports.statements = exports.smart = void 0;
  const smart = makeStatementFormatter(body => body.length > 1 ? body : body[0]);
  exports.smart = smart;
  const statements = makeStatementFormatter(body => body);
  exports.statements = statements;
  const statement = makeStatementFormatter(body => {
    if (0 === body.length) throw new Error("Found nothing to return.");
    if (body.length > 1) throw new Error("Found multiple statements but wanted one");
    return body[0];
  });
  exports.statement = statement;
  const expression = {
    code: str => `(\n${str}\n)`,
    validate: ({program: program}) => {
      if (program.body.length > 1) throw new Error("Found multiple statements but wanted one");
      if (0 === program.body[0].expression.start) throw new Error("Parse result included parens.");
    },
    unwrap: ast => ast.program.body[0].expression
  };
  exports.expression = expression;
  exports.program = {
    code: str => str,
    validate: () => {},
    unwrap: ast => ast.program
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = new WeakMap, templateAstCache = new WeakMap, cachedOpts = defaultOpts || (0, 
    _options.validate)(null);
    return Object.assign((tpl, ...args) => {
      if ("string" == typeof tpl) {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, 
        _options.validate)(args[0]))));
      }
      if (Array.isArray(tpl)) {
        let builder = templateFnCache.get(tpl);
        return builder || (builder = (0, _literal.default)(formatter, tpl, cachedOpts), 
        templateFnCache.set(tpl, builder)), extendedTrace(builder(args));
      }
      if ("object" == typeof tpl && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }
      throw new Error("Unexpected template param " + typeof tpl);
    }, {
      ast: (tpl, ...args) => {
        if ("string" == typeof tpl) {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, 
          _options.validate)(args[0])), NO_PLACEHOLDER))();
        }
        if (Array.isArray(tpl)) {
          let builder = templateAstCache.get(tpl);
          return builder || (builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER)), 
          templateAstCache.set(tpl, builder)), builder(args)();
        }
        throw new Error("Unexpected template param " + typeof tpl);
      }
    });
  };
  var _options = __webpack_require__(72), _string = _interopRequireDefault(__webpack_require__(300)), _literal = _interopRequireDefault(__webpack_require__(304));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: !1
  });
  function extendedTrace(fn) {
    let rootStack = "";
    try {
      throw new Error;
    } catch (error) {
      error.stack && (rootStack = error.stack.split("\n").slice(3).join("\n"));
    }
    return arg => {
      try {
        return fn(arg);
      } catch (err) {
        throw err.stack += "\n    =============\n" + rootStack, err;
      }
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(formatter, code, opts) {
    let metadata;
    return code = formatter.code(code), arg => {
      const replacements = (0, _options.normalizeReplacements)(arg);
      return metadata || (metadata = (0, _parse.default)(formatter, code, opts)), formatter.unwrap((0, 
      _populate.default)(metadata, replacements));
    };
  };
  var _options = __webpack_require__(72), _parse = _interopRequireDefault(__webpack_require__(128)), _populate = _interopRequireDefault(__webpack_require__(131));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.shouldHighlight = shouldHighlight, exports.getChalk = getChalk, exports.default = function(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk = getChalk(options);
      return function(defs, text) {
        return text.replace(_jsTokens.default, (function(...args) {
          const type = function(match) {
            const [offset, text] = match.slice(-2), token = (0, _jsTokens.matchToToken)(match);
            if ("name" === token.type) {
              if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isReservedWord)(token.value)) return "keyword";
              if (JSX_TAG.test(token.value) && ("<" === text[offset - 1] || "</" == text.substr(offset - 2, 2))) return "jsx_tag";
              if (token.value[0] !== token.value[0].toLowerCase()) return "capitalized";
            }
            if ("punctuator" === token.type && BRACKET.test(token.value)) return "bracket";
            if ("invalid" === token.type && ("@" === token.value || "#" === token.value)) return "punctuator";
            return token.type;
          }(args), colorize = defs[type];
          return colorize ? args[0].split(NEWLINE).map(str => colorize(str)).join("\n") : args[0];
        }));
      }(function(chalk) {
        return {
          keyword: chalk.cyan,
          capitalized: chalk.yellow,
          jsx_tag: chalk.yellow,
          punctuator: chalk.yellow,
          number: chalk.magenta,
          string: chalk.green,
          regex: chalk.magenta,
          comment: chalk.grey,
          invalid: chalk.white.bgRed.bold
        };
      }(chalk), code);
    }
    return code;
  };
  var obj, _jsTokens = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(302)), _helperValidatorIdentifier = __webpack_require__(68), _chalk = (obj = __webpack_require__(303)) && obj.__esModule ? obj : {
    default: obj
  };
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/, JSX_TAG = /^[a-z][\w-]*$/i, BRACKET = /^[()[\]{}]$/;
  function shouldHighlight(options) {
    return _chalk.default.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    let chalk = _chalk.default;
    return options.forceColor && (chalk = new _chalk.default.constructor({
      enabled: !0,
      level: 1
    })), chalk;
  }
}, function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, 
  exports.matchToToken = function(match) {
    var token = {
      type: "invalid",
      value: match[0],
      closed: void 0
    };
    return match[1] ? (token.type = "string", token.closed = !(!match[3] && !match[4])) : match[5] ? token.type = "comment" : match[6] ? (token.type = "comment", 
    token.closed = !!match[7]) : match[8] ? token.type = "regex" : match[9] ? token.type = "number" : match[10] ? token.type = "name" : match[11] ? token.type = "punctuator" : match[12] && (token.type = "whitespace"), 
    token;
  };
}, function(module, exports) {
  module.exports = require("chalk");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(formatter, tpl, opts) {
    const {metadata: metadata, names: names} = function(formatter, tpl, opts) {
      let names, nameSet, metadata, prefix = "";
      do {
        prefix += "$";
        const result = buildTemplateCode(tpl, prefix);
        names = result.names, nameSet = new Set(names), metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
          parser: opts.parser,
          placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
          placeholderPattern: opts.placeholderPattern,
          preserveComments: opts.preserveComments,
          syntacticPlaceholders: opts.syntacticPlaceholders
        });
      } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));
      return {
        metadata: metadata,
        names: names
      };
    }(formatter, tpl, opts);
    return arg => {
      const defaultReplacements = arg.reduce((acc, replacement, i) => (acc[names[i]] = replacement, 
      acc), {});
      return arg => {
        const replacements = (0, _options.normalizeReplacements)(arg);
        return replacements && Object.keys(replacements).forEach(key => {
          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) throw new Error("Unexpected replacement overlap.");
        }), formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  };
  var _options = __webpack_require__(72), _parse = _interopRequireDefault(__webpack_require__(128)), _populate = _interopRequireDefault(__webpack_require__(131));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];
    for (let i = 1; i < tpl.length; i++) {
      const value = `${prefix}${i - 1}`;
      names.push(value), code += value + tpl[i];
    }
    return {
      names: names,
      code: code
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, {getAsyncIterator: getAsyncIterator}) {
    const {node: node, scope: scope, parent: parent} = path, stepKey = scope.generateUidIdentifier("step"), stepValue = scope.generateUidIdentifier("value"), left = node.left;
    let declar;
    _core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left) ? declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue)) : _core.types.isVariableDeclaration(left) && (declar = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, stepValue) ]));
    let template = buildForAwait({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      GET_ITERATOR: getAsyncIterator,
      OBJECT: node.right,
      STEP_VALUE: _core.types.cloneNode(stepValue),
      STEP_KEY: stepKey
    });
    template = template.body.body;
    const isLabeledParent = _core.types.isLabeledStatement(parent), tryBody = template[3].block.body, loop = tryBody[0];
    isLabeledParent && (tryBody[0] = _core.types.labeledStatement(parent.label, loop));
    return {
      replaceParent: isLabeledParent,
      node: template,
      declar: declar,
      loop: loop
    };
  };
  var _core = __webpack_require__(2);
  const buildForAwait = (0, _core.template)("\n  async function wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = await ITERATOR_KEY.next(),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = await STEP_KEY.value,\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _helperCreateClassFeaturesPlugin = __webpack_require__(132), _default = (0, 
  _helperPluginUtils.declare)((api, options) => (api.assertVersion(7), (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
    name: "proposal-class-properties",
    feature: _helperCreateClassFeaturesPlugin.FEATURES.fields,
    loose: options.loose,
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classProperties", "classPrivateProperties");
    }
  })));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.buildPrivateNamesMap = function(props) {
    const privateNamesMap = new Map;
    for (const prop of props) {
      const isPrivate = prop.isPrivate(), isMethod = !prop.isProperty(), isInstance = !prop.node.static;
      if (isPrivate) {
        const {name: name} = prop.node.key.id, update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
          id: prop.scope.generateUidIdentifier(name),
          static: !isInstance,
          method: isMethod
        };
        "get" === prop.node.kind ? update.getId = prop.scope.generateUidIdentifier("get_" + name) : "set" === prop.node.kind ? update.setId = prop.scope.generateUidIdentifier("set_" + name) : "method" === prop.node.kind && (update.methodId = prop.scope.generateUidIdentifier(name)), 
        privateNamesMap.set(name, update);
      }
    }
    return privateNamesMap;
  }, exports.buildPrivateNamesNodes = function(privateNamesMap, loose, state) {
    const initNodes = [];
    for (const [name, value] of privateNamesMap) {
      const {static: isStatic, method: isMethod, getId: getId, setId: setId} = value, isAccessor = getId || setId, id = _core.types.cloneNode(value.id);
      loose ? initNodes.push(_core.template.statement.ast`
          var ${id} = ${state.addHelper("classPrivateFieldLooseKey")}("${name}")
        `) : isMethod && !isStatic ? isAccessor ? initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`) : initNodes.push(_core.template.statement.ast`var ${id} = new WeakSet();`) : isStatic || initNodes.push(_core.template.statement.ast`var ${id} = new WeakMap();`);
    }
    return initNodes;
  }, exports.transformPrivateNamesUsage = function(ref, path, privateNamesMap, loose, state) {
    if (!privateNamesMap.size) return;
    const body = path.get("body"), handler = loose ? privateNameHandlerLoose : privateNameHandlerSpec;
    (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({
      privateNamesMap: privateNamesMap,
      classRef: ref,
      file: state
    }, handler)), body.traverse(privateInVisitor, {
      privateNamesMap: privateNamesMap,
      classRef: ref,
      file: state,
      loose: loose
    });
  }, exports.buildFieldsInitNodes = function(ref, superRef, props, privateNamesMap, state, loose) {
    const staticNodes = [], instanceNodes = [];
    let needsClassRef = !1;
    for (const prop of props) {
      ts.assertFieldTransformed(prop);
      const isStatic = prop.node.static, isInstance = !isStatic, isPrivate = prop.isPrivate(), isPublic = !isPrivate, isField = prop.isProperty(), isMethod = !isField;
      if (isStatic || isMethod && isPrivate) {
        const replaced = replaceThisContext(prop, ref, superRef, state, loose);
        needsClassRef = needsClassRef || replaced;
      }
      switch (!0) {
       case isStatic && isPrivate && isField && loose:
        needsClassRef = !0, staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));
        break;

       case isStatic && isPrivate && isField && !loose:
        needsClassRef = !0, staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
        break;

       case isStatic && isPublic && isField && loose:
        needsClassRef = !0, staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));
        break;

       case isStatic && isPublic && isField && !loose:
        needsClassRef = !0, staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));
        break;

       case isInstance && isPrivate && isField && loose:
        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));
        break;

       case isInstance && isPrivate && isField && !loose:
        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap));
        break;

       case isInstance && isPrivate && isMethod && loose:
        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap)), 
        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
        break;

       case isInstance && isPrivate && isMethod && !loose:
        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap)), 
        staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
        break;

       case isStatic && isPrivate && isMethod && !loose:
        needsClassRef = !0, staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap)), 
        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
        break;

       case isStatic && isPrivate && isMethod && loose:
        needsClassRef = !0, staticNodes.push(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap)), 
        staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
        break;

       case isInstance && isPublic && isField && loose:
        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));
        break;

       case isInstance && isPublic && isField && !loose:
        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));
        break;

       default:
        throw new Error("Unreachable.");
      }
    }
    return {
      staticNodes: staticNodes.filter(Boolean),
      instanceNodes: instanceNodes.filter(Boolean),
      wrapClass(path) {
        for (const prop of props) prop.remove();
        return needsClassRef ? (path.isClassExpression() ? (path.scope.push({
          id: ref
        }), path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(ref), path.node))) : path.node.id || (path.node.id = ref), 
        path) : path;
      }
    };
  };
  var _core = __webpack_require__(2), _helperReplaceSupers = _interopRequireWildcard(__webpack_require__(21)), _helperMemberExpressionToFunctions = _interopRequireDefault(__webpack_require__(148)), _helperOptimiseCallExpression = _interopRequireDefault(__webpack_require__(73)), ts = _interopRequireWildcard(__webpack_require__(365));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function privateNameVisitorFactory(visitor) {
    const privateNameVisitor = Object.assign({}, visitor, {
      Class(path) {
        const {privateNamesMap: privateNamesMap} = this, body = path.get("body.body"), visiblePrivateNames = new Map(privateNamesMap), redeclared = [];
        for (const prop of body) {
          if (!prop.isPrivate()) continue;
          const {name: name} = prop.node.key.id;
          visiblePrivateNames.delete(name), redeclared.push(name);
        }
        redeclared.length && (path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
          redeclared: redeclared
        })), path.traverse(privateNameVisitor, Object.assign({}, this, {
          privateNamesMap: visiblePrivateNames
        })), path.skipKey("body"));
      }
    }), nestedVisitor = _core.traverse.visitors.merge([ Object.assign({}, visitor), _helperReplaceSupers.environmentVisitor ]);
    return privateNameVisitor;
  }
  const privateNameVisitor = privateNameVisitorFactory({
    PrivateName(path) {
      const {privateNamesMap: privateNamesMap, redeclared: redeclared} = this, {node: node, parentPath: parentPath} = path;
      if (!parentPath.isMemberExpression({
        property: node
      }) && !parentPath.isOptionalMemberExpression({
        property: node
      })) return;
      const {name: name} = node.id;
      privateNamesMap.has(name) && (redeclared && redeclared.includes(name) || this.handle(parentPath));
    }
  }), privateInVisitor = privateNameVisitorFactory({
    BinaryExpression(path) {
      const {operator: operator, left: left, right: right} = path.node;
      if ("in" !== operator) return;
      if (!path.get("left").isPrivateName()) return;
      const {loose: loose, privateNamesMap: privateNamesMap, redeclared: redeclared} = this, {name: name} = left.id;
      if (!privateNamesMap.has(name)) return;
      if (redeclared && redeclared.includes(name)) return;
      if (loose) {
        const {id: id} = privateNamesMap.get(name);
        return void path.replaceWith(_core.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${right}, ${_core.types.cloneNode(id)})
      `);
      }
      const {id: id, static: isStatic} = privateNamesMap.get(name);
      isStatic ? path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`) : path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${right})`);
    }
  }), privateNameHandlerSpec = {
    memoise(member, count) {
      const {scope: scope} = member, {object: object} = member.node, memo = scope.maybeGenerateMemoised(object);
      memo && this.memoiser.set(object, memo, count);
    },
    receiver(member) {
      const {object: object} = member.node;
      return this.memoiser.has(object) ? _core.types.cloneNode(this.memoiser.get(object)) : _core.types.cloneNode(object);
    },
    get(member) {
      const {classRef: classRef, privateNamesMap: privateNamesMap, file: file} = this, {name: name} = member.node.property.id, {id: id, static: isStatic, method: isMethod, methodId: methodId, getId: getId, setId: setId} = privateNamesMap.get(name), isAccessor = getId || setId;
      if (isStatic) {
        const helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
        return _core.types.callExpression(file.addHelper(helperName), [ this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id) ]);
      }
      return isMethod ? isAccessor ? _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [ this.receiver(member), _core.types.cloneNode(id) ]) : _core.types.callExpression(file.addHelper("classPrivateMethodGet"), [ this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId) ]) : _core.types.callExpression(file.addHelper("classPrivateFieldGet"), [ this.receiver(member), _core.types.cloneNode(id) ]);
    },
    boundGet(member) {
      return this.memoise(member, 1), _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [ this.receiver(member) ]);
    },
    set(member, value) {
      const {classRef: classRef, privateNamesMap: privateNamesMap, file: file} = this, {name: name} = member.node.property.id, {id: id, static: isStatic, method: isMethod, setId: setId, getId: getId} = privateNamesMap.get(name);
      if (isStatic) {
        const helperName = isMethod && !(getId || setId) ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
        return _core.types.callExpression(file.addHelper(helperName), [ this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value ]);
      }
      return isMethod ? setId ? _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [ this.receiver(member), _core.types.cloneNode(id), value ]) : _core.types.callExpression(file.addHelper("classPrivateMethodSet"), []) : _core.types.callExpression(file.addHelper("classPrivateFieldSet"), [ this.receiver(member), _core.types.cloneNode(id), value ]);
    },
    destructureSet(member) {
      const {privateNamesMap: privateNamesMap, file: file} = this, {name: name} = member.node.property.id, {id: id} = privateNamesMap.get(name);
      return _core.types.memberExpression(_core.types.callExpression(file.addHelper("classPrivateFieldDestructureSet"), [ this.receiver(member), _core.types.cloneNode(id) ]), _core.types.identifier("value"));
    },
    call(member, args) {
      return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, !1);
    },
    optionalCall(member, args) {
      return this.memoise(member, 1), (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, !0);
    }
  }, privateNameHandlerLoose = {
    get(member) {
      const {privateNamesMap: privateNamesMap, file: file} = this, {object: object} = member.node, {name: name} = member.node.property.id;
      return _core.template.expression`BASE(REF, PROP)[PROP]`({
        BASE: file.addHelper("classPrivateFieldLooseBase"),
        REF: _core.types.cloneNode(object),
        PROP: _core.types.cloneNode(privateNamesMap.get(name).id)
      });
    },
    boundGet(member) {
      return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier("bind")), [ _core.types.cloneNode(member.node.object) ]);
    },
    simpleSet(member) {
      return this.get(member);
    },
    destructureSet(member) {
      return this.get(member);
    },
    call(member, args) {
      return _core.types.callExpression(this.get(member), args);
    },
    optionalCall(member, args) {
      return _core.types.optionalCallExpression(this.get(member), args, !0);
    }
  };
  function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
    const {id: id} = privateNamesMap.get(prop.node.key.id.name), value = prop.node.value || prop.scope.buildUndefinedNode();
    return _core.template.statement.ast`
    Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    });
  `;
  }
  function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {
    const {id: id} = privateNamesMap.get(prop.node.key.id.name), value = prop.node.value || prop.scope.buildUndefinedNode();
    return _core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {
    // configurable is always false for private elements
    // enumerable is always false for private elements
    writable: true,
    value: ${value},
  })`;
  }
  function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name), {id: id, getId: getId, setId: setId, initAdded: initAdded} = privateName, isAccessor = getId || setId;
    if (!prop.isProperty() && (initAdded || !isAccessor)) return;
    if (isAccessor) return privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: !0
    })), _core.template.statement.ast`
      var ${_core.types.cloneNode(id)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      }
    `;
    const value = prop.node.value || prop.scope.buildUndefinedNode();
    return _core.template.statement.ast`
    var ${_core.types.cloneNode(id)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${value}
    };
  `;
  }
  function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name), {methodId: methodId, id: id, getId: getId, setId: setId, initAdded: initAdded} = privateName;
    if (initAdded) return;
    if (methodId) return _core.template.statement.ast`
        Object.defineProperty(${ref}, ${id}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${methodId.name}
        });
      `;
    return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: !0
    })), _core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      });
    `) : void 0;
  }
  function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name), {id: id, getId: getId, setId: setId, initAdded: initAdded} = privateName;
    if (initAdded) return;
    return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: !0
    })), _core.template.statement.ast`
      ${id}.set(${ref}, {
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      });
    `) : _core.template.statement.ast`${id}.add(${ref})`;
  }
  function buildPublicFieldInitLoose(ref, prop) {
    const {key: key, computed: computed} = prop.node, value = prop.node.value || prop.scope.buildUndefinedNode();
    return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));
  }
  function buildPublicFieldInitSpec(ref, prop, state) {
    const {key: key, computed: computed} = prop.node, value = prop.node.value || prop.scope.buildUndefinedNode();
    return _core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value ]));
  }
  function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
    const privateName = privateNamesMap.get(prop.node.key.id.name), {id: id, methodId: methodId, getId: getId, setId: setId, initAdded: initAdded} = privateName;
    if (initAdded) return;
    return getId || setId ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      initAdded: !0
    })), _core.template.statement.ast`
      Object.defineProperty(${ref}, ${id}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},
        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}
      })
    `) : _core.template.statement.ast`
    Object.defineProperty(${ref}, ${id}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${methodId.name}
    });
  `;
  }
  function buildPrivateMethodDeclaration(prop, privateNamesMap, loose = !1) {
    const privateName = privateNamesMap.get(prop.node.key.id.name), {id: id, methodId: methodId, getId: getId, setId: setId, getterDeclared: getterDeclared, setterDeclared: setterDeclared, static: isStatic} = privateName, {params: params, body: body, generator: generator, async: async} = prop.node, methodValue = _core.types.functionExpression(methodId, params, body, generator, async), isGetter = getId && !getterDeclared && 0 === params.length, isSetter = setId && !setterDeclared && params.length > 0;
    return isGetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      getterDeclared: !0
    })), _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(getId, methodValue) ])) : isSetter ? (privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
      setterDeclared: !0
    })), _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(setId, methodValue) ])) : isStatic && !loose ? _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.functionExpression(id, params, body, generator, async)) ]) : _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.cloneNode(methodId), methodValue) ]);
  }
  const thisContextVisitor = _core.traverse.visitors.merge([ {
    ThisExpression(path, state) {
      state.needsClassRef = !0, path.replaceWith(_core.types.cloneNode(state.classRef));
    }
  }, _helperReplaceSupers.environmentVisitor ]);
  function replaceThisContext(path, ref, superRef, file, loose) {
    const state = {
      classRef: ref,
      needsClassRef: !1
    };
    return new _helperReplaceSupers.default({
      methodPath: path,
      isLoose: loose,
      superRef: superRef,
      file: file,
      getObjectRef: () => (state.needsClassRef = !0, path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier("prototype")))
    }).replace(), path.isProperty() && path.traverse(thisContextVisitor, state), state.needsClassRef;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _path = (obj = __webpack_require__(10)) && obj.__esModule ? obj : {
    default: obj
  }, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const testing = "test" === process.env.NODE_ENV;
  exports.default = class {
    constructor(scope, opts, state, parentPath) {
      this.queue = null, this.parentPath = parentPath, this.scope = scope, this.state = state, 
      this.opts = opts;
    }
    shouldVisit(node) {
      const opts = this.opts;
      if (opts.enter || opts.exit) return !0;
      if (opts[node.type]) return !0;
      const keys = t.VISITOR_KEYS[node.type];
      if (!(null == keys ? void 0 : keys.length)) return !1;
      for (const key of keys) if (node[key]) return !0;
      return !1;
    }
    create(node, obj, key, listKey) {
      return _path.default.get({
        parentPath: this.parentPath,
        parent: node,
        container: obj,
        key: key,
        listKey: listKey
      });
    }
    maybeQueue(path, notPriority) {
      if (this.trap) throw new Error("Infinite cycle detected");
      this.queue && (notPriority ? this.queue.push(path) : this.priorityQueue.push(path));
    }
    visitMultiple(container, parent, listKey) {
      if (0 === container.length) return !1;
      const queue = [];
      for (let key = 0; key < container.length; key++) {
        const node = container[key];
        node && this.shouldVisit(node) && queue.push(this.create(parent, container, key, listKey));
      }
      return this.visitQueue(queue);
    }
    visitSingle(node, key) {
      return !!this.shouldVisit(node[key]) && this.visitQueue([ this.create(node, node, key) ]);
    }
    visitQueue(queue) {
      this.queue = queue, this.priorityQueue = [];
      const visited = [];
      let stop = !1;
      for (const path of queue) if (path.resync(), 0 !== path.contexts.length && path.contexts[path.contexts.length - 1] === this || path.pushContext(this), 
      null !== path.key && (testing && queue.length >= 1e4 && (this.trap = !0), !(visited.indexOf(path.node) >= 0))) {
        if (visited.push(path.node), path.visit()) {
          stop = !0;
          break;
        }
        if (this.priorityQueue.length && (stop = this.visitQueue(this.priorityQueue), this.priorityQueue = [], 
        this.queue = queue, stop)) break;
      }
      for (const path of queue) path.popContext();
      return this.queue = null, stop;
    }
    visit(node, key) {
      const nodes = node[key];
      return !!nodes && (Array.isArray(nodes) ? this.visitMultiple(nodes, node, key) : this.visitSingle(node, key));
    }
  };
}, function(module, exports, __webpack_require__) {
  "undefined" == typeof process || "renderer" === process.type || !0 === process.browser || process.__nwjs ? module.exports = __webpack_require__(310) : module.exports = __webpack_require__(312);
}, function(module, exports, __webpack_require__) {
  exports.formatArgs = function(args) {
    if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), 
    !this.useColors) return;
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0, lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      "%%" !== match && (index++, "%c" === match && (lastC = index));
    }), args.splice(lastC, 0, c);
  }, exports.save = function(namespaces) {
    try {
      namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
    } catch (error) {}
  }, exports.load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {}
    !r && "undefined" != typeof process && "env" in process && (r = process.env.DEBUG);
    return r;
  }, exports.useColors = function() {
    if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return !0;
    if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
    return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }, exports.storage = function() {
    try {
      return localStorage;
    } catch (error) {}
  }(), exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ], 
  exports.log = console.debug || console.log || (() => {}), module.exports = __webpack_require__(134)(exports);
  const {formatters: formatters} = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
}, function(module, exports) {
  var s = 1e3, m = 6e4, h = 60 * m, d = 24 * h;
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= 1.5 * n;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if ("string" === type && val.length > 0) return function(str) {
      if ((str = String(str)).length > 100) return;
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      switch ((match[2] || "ms").toLowerCase()) {
       case "years":
       case "year":
       case "yrs":
       case "yr":
       case "y":
        return 315576e5 * n;

       case "weeks":
       case "week":
       case "w":
        return 6048e5 * n;

       case "days":
       case "day":
       case "d":
        return n * d;

       case "hours":
       case "hour":
       case "hrs":
       case "hr":
       case "h":
        return n * h;

       case "minutes":
       case "minute":
       case "mins":
       case "min":
       case "m":
        return n * m;

       case "seconds":
       case "second":
       case "secs":
       case "sec":
       case "s":
        return n * s;

       case "milliseconds":
       case "millisecond":
       case "msecs":
       case "msec":
       case "ms":
        return n;

       default:
        return;
      }
    }(val);
    if ("number" === type && isFinite(val)) return options.long ? function(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) return plural(ms, msAbs, d, "day");
      if (msAbs >= h) return plural(ms, msAbs, h, "hour");
      if (msAbs >= m) return plural(ms, msAbs, m, "minute");
      if (msAbs >= s) return plural(ms, msAbs, s, "second");
      return ms + " ms";
    }(val) : function(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) return Math.round(ms / d) + "d";
      if (msAbs >= h) return Math.round(ms / h) + "h";
      if (msAbs >= m) return Math.round(ms / m) + "m";
      if (msAbs >= s) return Math.round(ms / s) + "s";
      return ms + "ms";
    }(val);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
}, function(module, exports, __webpack_require__) {
  const tty = __webpack_require__(313), util = __webpack_require__(135);
  exports.init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0; i < keys.length; i++) debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }, exports.log = function(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }, exports.formatArgs = function(args) {
    const {namespace: name, useColors: useColors} = this;
    if (useColors) {
      const c = this.color, colorCode = "[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "[0m");
    } else args[0] = function() {
      if (exports.inspectOpts.hideDate) return "";
      return (new Date).toISOString() + " ";
    }() + name + " " + args[0];
  }, exports.save = function(namespaces) {
    namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;
  }, exports.load = function() {
    return process.env.DEBUG;
  }, exports.useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }, exports.colors = [ 6, 2, 3, 4, 5, 1 ];
  try {
    const supportsColor = __webpack_require__(314);
    supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [ 20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221 ]);
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter(key => /^debug_/i.test(key)).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase());
    let val = process.env[key];
    return val = !!/^(yes|on|true|enabled)$/i.test(val) || !/^(no|off|false|disabled)$/i.test(val) && ("null" === val ? null : Number(val)), 
    obj[prop] = val, obj;
  }, {}), module.exports = __webpack_require__(134)(exports);
  const {formatters: formatters} = module.exports;
  formatters.o = function(v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
  }, formatters.O = function(v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
  };
}, function(module, exports) {
  module.exports = require("tty");
}, function(module, exports) {
  module.exports = require("supports-color");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  _interopRequireDefault(__webpack_require__(137));
  var _helperSplitExportDeclaration = _interopRequireDefault(__webpack_require__(43));
  !function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const renameVisitor = {
    ReferencedIdentifier({node: node}, state) {
      node.name === state.oldName && (node.name = state.newName);
    },
    Scope(path, state) {
      path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier) || path.skip();
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
      if (path.isVariableDeclaration()) return;
      const ids = path.getOuterBindingIdentifiers();
      for (const name in ids) name === state.oldName && (ids[name].name = state.newName);
    }
  };
  exports.default = class {
    constructor(binding, oldName, newName) {
      this.newName = newName, this.oldName = oldName, this.binding = binding;
    }
    maybeConvertFromExportDeclaration(parentDeclar) {
      const maybeExportDeclar = parentDeclar.parentPath;
      maybeExportDeclar.isExportDeclaration() && (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id || (0, 
      _helperSplitExportDeclaration.default)(maybeExportDeclar));
    }
    maybeConvertFromClassFunctionDeclaration(path) {}
    maybeConvertFromClassFunctionExpression(path) {}
    rename(block) {
      const {binding: binding, oldName: oldName, newName: newName} = this, {scope: scope, path: path} = binding, parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());
      if (parentDeclar) {
        parentDeclar.getOuterBindingIdentifiers()[oldName] === binding.identifier && this.maybeConvertFromExportDeclaration(parentDeclar);
      }
      scope.traverse(block || scope.block, renameVisitor, this), block || (scope.removeOwnBinding(oldName), 
      scope.bindings[newName] = binding, this.binding.identifier.name = newName), binding.type, 
      parentDeclar && (this.maybeConvertFromClassFunctionDeclaration(parentDeclar), this.maybeConvertFromClassFunctionExpression(parentDeclar));
    }
  };
}, function(module, exports, __webpack_require__) {
  var baseRest = __webpack_require__(138), eq = __webpack_require__(32), isIterateeCall = __webpack_require__(140), keysIn = __webpack_require__(38), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, defaults = baseRest((function(object, sources) {
    object = Object(object);
    var index = -1, length = sources.length, guard = length > 2 ? sources[2] : void 0;
    for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; ) for (var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
      var key = props[propsIndex], value = object[key];
      (void 0 === value || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key]);
    }
    return object;
  }));
  module.exports = defaults;
}, function(module, exports, __webpack_require__) {
  var apply = __webpack_require__(318), nativeMax = Math.max;
  module.exports = function(func, start, transform) {
    return start = nativeMax(void 0 === start ? func.length - 1 : start, 0), function() {
      for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; ) array[index] = args[start + index];
      index = -1;
      for (var otherArgs = Array(start + 1); ++index < start; ) otherArgs[index] = args[index];
      return otherArgs[start] = transform(array), apply(func, this, otherArgs);
    };
  };
}, function(module, exports) {
  module.exports = function(func, thisArg, args) {
    switch (args.length) {
     case 0:
      return func.call(thisArg);

     case 1:
      return func.call(thisArg, args[0]);

     case 2:
      return func.call(thisArg, args[0], args[1]);

     case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  };
}, function(module, exports, __webpack_require__) {
  var baseSetToString = __webpack_require__(320), setToString = __webpack_require__(322)(baseSetToString);
  module.exports = setToString;
}, function(module, exports, __webpack_require__) {
  var constant = __webpack_require__(321), defineProperty = __webpack_require__(103), identity = __webpack_require__(139), baseSetToString = defineProperty ? function(func, string) {
    return defineProperty(func, "toString", {
      configurable: !0,
      enumerable: !1,
      value: constant(string),
      writable: !0
    });
  } : identity;
  module.exports = baseSetToString;
}, function(module, exports) {
  module.exports = function(value) {
    return function() {
      return value;
    };
  };
}, function(module, exports) {
  var nativeNow = Date.now;
  module.exports = function(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = 16 - (stamp - lastCalled);
      if (lastCalled = stamp, remaining > 0) {
        if (++count >= 800) return arguments[0];
      } else count = 0;
      return func.apply(void 0, arguments);
    };
  };
}, function(module) {
  module.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(ast, opts, code) {
    return new Generator(ast, opts, code).generate();
  }, exports.CodeGenerator = void 0;
  var _sourceMap = _interopRequireDefault(__webpack_require__(325)), _printer = _interopRequireDefault(__webpack_require__(333));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  class Generator extends _printer.default {
    constructor(ast, opts = {}, code) {
      super(function(code, opts) {
        const format = {
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          shouldPrintComment: opts.shouldPrintComment,
          retainLines: opts.retainLines,
          retainFunctionParens: opts.retainFunctionParens,
          comments: null == opts.comments || opts.comments,
          compact: opts.compact,
          minified: opts.minified,
          concise: opts.concise,
          jsonCompatibleStrings: opts.jsonCompatibleStrings,
          indent: {
            adjustMultilineComment: !0,
            style: "  ",
            base: 0
          },
          decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
          jsescOption: Object.assign({
            quotes: "double",
            wrap: !0
          }, opts.jsescOption),
          recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType
        };
        format.minified ? (format.compact = !0, format.shouldPrintComment = format.shouldPrintComment || (() => format.comments)) : format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
        "auto" === format.compact && (format.compact = code.length > 5e5, format.compact && console.error("[BABEL] Note: The code generator has deoptimised the styling of " + opts.filename + " as it exceeds the max of 500KB."));
        format.compact && (format.indent.adjustMultilineComment = !1);
        return format;
      }(code, opts), opts.sourceMaps ? new _sourceMap.default(opts, code) : null), this.ast = ast;
    }
    generate() {
      return super.generate(this.ast);
    }
  }
  exports.CodeGenerator = class {
    constructor(ast, opts, code) {
      this._generator = new Generator(ast, opts, code);
    }
    generate() {
      return this._generator.generate();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _sourceMap = (obj = __webpack_require__(326)) && obj.__esModule ? obj : {
    default: obj
  };
  exports.default = class {
    constructor(opts, code) {
      this._cachedMap = null, this._code = code, this._opts = opts, this._rawMappings = [];
    }
    get() {
      if (!this._cachedMap) {
        const map = this._cachedMap = new _sourceMap.default.SourceMapGenerator({
          sourceRoot: this._opts.sourceRoot
        }), code = this._code;
        "string" == typeof code ? map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code) : "object" == typeof code && Object.keys(code).forEach(sourceFileName => {
          map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }), this._rawMappings.forEach(mapping => map.addMapping(mapping), map);
      }
      return this._cachedMap.toJSON();
    }
    getRawMappings() {
      return this._rawMappings.slice();
    }
    mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
      this._lastGenLine !== generatedLine && null === line || (force || this._lastGenLine !== generatedLine || this._lastSourceLine !== line || this._lastSourceColumn !== column) && (this._cachedMap = null, 
      this._lastGenLine = generatedLine, this._lastSourceLine = line, this._lastSourceColumn = column, 
      this._rawMappings.push({
        name: identifierName || void 0,
        generated: {
          line: generatedLine,
          column: generatedColumn
        },
        source: null == line ? void 0 : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
        original: null == line ? void 0 : {
          line: line,
          column: column
        }
      }));
    }
  };
}, function(module, exports, __webpack_require__) {
  exports.SourceMapGenerator = __webpack_require__(142).SourceMapGenerator, exports.SourceMapConsumer = __webpack_require__(329).SourceMapConsumer, 
  exports.SourceNode = __webpack_require__(332).SourceNode;
}, function(module, exports) {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) return intToCharMap[number];
    throw new TypeError("Must be between 0 and 63: " + number);
  }, exports.decode = function(charCode) {
    return 65 <= charCode && charCode <= 90 ? charCode - 65 : 97 <= charCode && charCode <= 122 ? charCode - 97 + 26 : 48 <= charCode && charCode <= 57 ? charCode - 48 + 52 : 43 == charCode ? 62 : 47 == charCode ? 63 : -1;
  };
}, function(module, exports, __webpack_require__) {
  var util = __webpack_require__(29);
  function MappingList() {
    this._array = [], this._sorted = !0, this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }
  MappingList.prototype.unsortedForEach = function(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  }, MappingList.prototype.add = function(aMapping) {
    var mappingA, mappingB, lineA, lineB, columnA, columnB;
    mappingA = this._last, mappingB = aMapping, lineA = mappingA.generatedLine, lineB = mappingB.generatedLine, 
    columnA = mappingA.generatedColumn, columnB = mappingB.generatedColumn, lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0 ? (this._last = aMapping, 
    this._array.push(aMapping)) : (this._sorted = !1, this._array.push(aMapping));
  }, MappingList.prototype.toArray = function() {
    return this._sorted || (this._array.sort(util.compareByGeneratedPositionsInflated), 
    this._sorted = !0), this._array;
  }, exports.MappingList = MappingList;
}, function(module, exports, __webpack_require__) {
  var util = __webpack_require__(29), binarySearch = __webpack_require__(330), ArraySet = __webpack_require__(144).ArraySet, base64VLQ = __webpack_require__(143), quickSort = __webpack_require__(331).quickSort;
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    return "string" == typeof aSourceMap && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ""))), 
    null != sourceMap.sections ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    "string" == typeof aSourceMap && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, "")));
    var version = util.getArg(sourceMap, "version"), sources = util.getArg(sourceMap, "sources"), names = util.getArg(sourceMap, "names", []), sourceRoot = util.getArg(sourceMap, "sourceRoot", null), sourcesContent = util.getArg(sourceMap, "sourcesContent", null), mappings = util.getArg(sourceMap, "mappings"), file = util.getArg(sourceMap, "file", null);
    if (version != this._version) throw new Error("Unsupported version: " + version);
    sources = sources.map(String).map(util.normalize).map((function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    })), this._names = ArraySet.fromArray(names.map(String), !0), this._sources = ArraySet.fromArray(sources, !0), 
    this.sourceRoot = sourceRoot, this.sourcesContent = sourcesContent, this._mappings = mappings, 
    this.file = file;
  }
  function Mapping() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, 
    this.originalColumn = null, this.name = null;
  }
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    "string" == typeof aSourceMap && (sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, "")));
    var version = util.getArg(sourceMap, "version"), sections = util.getArg(sourceMap, "sections");
    if (version != this._version) throw new Error("Unsupported version: " + version);
    this._sources = new ArraySet, this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map((function(s) {
      if (s.url) throw new Error("Support for url field in sections not implemented.");
      var offset = util.getArg(s, "offset"), offsetLine = util.getArg(offset, "line"), offsetColumn = util.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return lastOffset = offset, {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"))
      };
    }));
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  }, SourceMapConsumer.prototype._version = 3, SourceMapConsumer.prototype.__generatedMappings = null, 
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    get: function() {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), 
      this.__generatedMappings;
    }
  }), SourceMapConsumer.prototype.__originalMappings = null, Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    get: function() {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), 
      this.__originalMappings;
    }
  }), SourceMapConsumer.prototype._charIsMappingSeparator = function(aStr, index) {
    var c = aStr.charAt(index);
    return ";" === c || "," === c;
  }, SourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  }, SourceMapConsumer.GENERATED_ORDER = 1, SourceMapConsumer.ORIGINAL_ORDER = 2, 
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1, SourceMapConsumer.LEAST_UPPER_BOUND = 2, 
  SourceMapConsumer.prototype.eachMapping = function(aCallback, aContext, aOrder) {
    var mappings, context = aContext || null;
    switch (aOrder || SourceMapConsumer.GENERATED_ORDER) {
     case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

     case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

     default:
      throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map((function(mapping) {
      var source = null === mapping.source ? null : this._sources.at(mapping.source);
      return null != source && null != sourceRoot && (source = util.join(sourceRoot, source)), 
      {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: null === mapping.name ? null : this._names.at(mapping.name)
      };
    }), this).forEach(aCallback, context);
  }, SourceMapConsumer.prototype.allGeneratedPositionsFor = function(aArgs) {
    var line = util.getArg(aArgs, "line"), needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    if (null != this.sourceRoot && (needle.source = util.relative(this.sourceRoot, needle.source)), 
    !this._sources.has(needle.source)) return [];
    needle.source = this._sources.indexOf(needle.source);
    var mappings = [], index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (void 0 === aArgs.column) for (var originalLine = mapping.originalLine; mapping && mapping.originalLine === originalLine; ) mappings.push({
        line: util.getArg(mapping, "generatedLine", null),
        column: util.getArg(mapping, "generatedColumn", null),
        lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
      }), mapping = this._originalMappings[++index]; else for (var originalColumn = mapping.originalColumn; mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn; ) mappings.push({
        line: util.getArg(mapping, "generatedLine", null),
        column: util.getArg(mapping, "generatedColumn", null),
        lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
      }), mapping = this._originalMappings[++index];
    }
    return mappings;
  }, exports.SourceMapConsumer = SourceMapConsumer, BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), 
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer, BasicSourceMapConsumer.fromSourceMap = function(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype), names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), !0), sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), !0);
    smc.sourceRoot = aSourceMap._sourceRoot, smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot), 
    smc.file = aSourceMap._file;
    for (var generatedMappings = aSourceMap._mappings.toArray().slice(), destGeneratedMappings = smc.__generatedMappings = [], destOriginalMappings = smc.__originalMappings = [], i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i], destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine, destMapping.generatedColumn = srcMapping.generatedColumn, 
      srcMapping.source && (destMapping.source = sources.indexOf(srcMapping.source), destMapping.originalLine = srcMapping.originalLine, 
      destMapping.originalColumn = srcMapping.originalColumn, srcMapping.name && (destMapping.name = names.indexOf(srcMapping.name)), 
      destOriginalMappings.push(destMapping)), destGeneratedMappings.push(destMapping);
    }
    return quickSort(smc.__originalMappings, util.compareByOriginalPositions), smc;
  }, BasicSourceMapConsumer.prototype._version = 3, Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._sources.toArray().map((function(s) {
        return null != this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }), this);
    }
  }), BasicSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    for (var mapping, str, segment, end, value, generatedLine = 1, previousGeneratedColumn = 0, previousOriginalLine = 0, previousOriginalColumn = 0, previousSource = 0, previousName = 0, length = aStr.length, index = 0, cachedSegments = {}, temp = {}, originalMappings = [], generatedMappings = []; index < length; ) if (";" === aStr.charAt(index)) generatedLine++, 
    index++, previousGeneratedColumn = 0; else if ("," === aStr.charAt(index)) index++; else {
      for ((mapping = new Mapping).generatedLine = generatedLine, end = index; end < length && !this._charIsMappingSeparator(aStr, end); end++) ;
      if (segment = cachedSegments[str = aStr.slice(index, end)]) index += str.length; else {
        for (segment = []; index < end; ) base64VLQ.decode(aStr, index, temp), value = temp.value, 
        index = temp.rest, segment.push(value);
        if (2 === segment.length) throw new Error("Found a source, but no line and column");
        if (3 === segment.length) throw new Error("Found a source and line, but no column");
        cachedSegments[str] = segment;
      }
      mapping.generatedColumn = previousGeneratedColumn + segment[0], previousGeneratedColumn = mapping.generatedColumn, 
      segment.length > 1 && (mapping.source = previousSource + segment[1], previousSource += segment[1], 
      mapping.originalLine = previousOriginalLine + segment[2], previousOriginalLine = mapping.originalLine, 
      mapping.originalLine += 1, mapping.originalColumn = previousOriginalColumn + segment[3], 
      previousOriginalColumn = mapping.originalColumn, segment.length > 4 && (mapping.name = previousName + segment[4], 
      previousName += segment[4])), generatedMappings.push(mapping), "number" == typeof mapping.originalLine && originalMappings.push(mapping);
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated), this.__generatedMappings = generatedMappings, 
    quickSort(originalMappings, util.compareByOriginalPositions), this.__originalMappings = originalMappings;
  }, BasicSourceMapConsumer.prototype._findMapping = function(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  }, BasicSourceMapConsumer.prototype.computeColumnSpans = function() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = 1 / 0;
    }
  }, BasicSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    }, index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        null !== source && (source = this._sources.at(source), null != this.sourceRoot && (source = util.join(this.sourceRoot, source)));
        var name = util.getArg(mapping, "name", null);
        return null !== name && (name = this._names.at(name)), {
          source: source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name: name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
    return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some((function(sc) {
      return null == sc;
    })));
  }, BasicSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
    if (!this.sourcesContent) return null;
    if (null != this.sourceRoot && (aSource = util.relative(this.sourceRoot, aSource)), 
    this._sources.has(aSource)) return this.sourcesContent[this._sources.indexOf(aSource)];
    var url;
    if (null != this.sourceRoot && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if ("file" == url.scheme && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      if ((!url.path || "/" == url.path) && this._sources.has("/" + aSource)) return this.sourcesContent[this._sources.indexOf("/" + aSource)];
    }
    if (nullOnMissing) return null;
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }, BasicSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
    var source = util.getArg(aArgs, "source");
    if (null != this.sourceRoot && (source = util.relative(this.sourceRoot, source)), 
    !this._sources.has(source)) return {
      line: null,
      column: null,
      lastColumn: null
    };
    var needle = {
      source: source = this._sources.indexOf(source),
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    }, index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) return {
        line: util.getArg(mapping, "generatedLine", null),
        column: util.getArg(mapping, "generatedColumn", null),
        lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
      };
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }, exports.BasicSourceMapConsumer = BasicSourceMapConsumer, IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype), 
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer, IndexedSourceMapConsumer.prototype._version = 3, 
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      for (var sources = [], i = 0; i < this._sections.length; i++) for (var j = 0; j < this._sections[i].consumer.sources.length; j++) sources.push(this._sections[i].consumer.sources[j]);
      return sources;
    }
  }), IndexedSourceMapConsumer.prototype.originalPositionFor = function(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    }, sectionIndex = binarySearch.search(needle, this._sections, (function(needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
      return cmp || needle.generatedColumn - section.generatedOffset.generatedColumn;
    })), section = this._sections[sectionIndex];
    return section ? section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }, IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function() {
    return this._sections.every((function(s) {
      return s.consumer.hasContentsOfAllSources();
    }));
  }, IndexedSourceMapConsumer.prototype.sourceContentFor = function(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var content = this._sections[i].consumer.sourceContentFor(aSource, !0);
      if (content) return content;
    }
    if (nullOnMissing) return null;
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }, IndexedSourceMapConsumer.prototype.generatedPositionFor = function(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (-1 !== section.consumer.sources.indexOf(util.getArg(aArgs, "source"))) {
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) return {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
      }
    }
    return {
      line: null,
      column: null
    };
  }, IndexedSourceMapConsumer.prototype._parseMappings = function(aStr, aSourceRoot) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) for (var section = this._sections[i], sectionMappings = section.consumer._generatedMappings, j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j], source = section.consumer._sources.at(mapping.source);
      null !== section.consumer.sourceRoot && (source = util.join(section.consumer.sourceRoot, source)), 
      this._sources.add(source), source = this._sources.indexOf(source);
      var name = section.consumer._names.at(mapping.name);
      this._names.add(name), name = this._names.indexOf(name);
      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };
      this.__generatedMappings.push(adjustedMapping), "number" == typeof adjustedMapping.originalLine && this.__originalMappings.push(adjustedMapping);
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated), quickSort(this.__originalMappings, util.compareByOriginalPositions);
  }, exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
}, function(module, exports) {
  exports.GREATEST_LOWER_BOUND = 1, exports.LEAST_UPPER_BOUND = 2, exports.search = function(aNeedle, aHaystack, aCompare, aBias) {
    if (0 === aHaystack.length) return -1;
    var index = function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow, cmp = aCompare(aNeedle, aHaystack[mid], !0);
      return 0 === cmp ? mid : cmp > 0 ? aHigh - mid > 1 ? recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? aHigh < aHaystack.length ? aHigh : -1 : mid : mid - aLow > 1 ? recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias) : aBias == exports.LEAST_UPPER_BOUND ? mid : aLow < 0 ? -1 : aLow;
    }(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) return -1;
    for (;index - 1 >= 0 && 0 === aCompare(aHaystack[index], aHaystack[index - 1], !0); ) --index;
    return index;
  };
}, function(module, exports) {
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y], ary[y] = temp;
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var i = p - 1;
      swap(ary, (low = p, high = r, Math.round(low + Math.random() * (high - low))), r);
      for (var pivot = ary[r], j = p; j < r; j++) comparator(ary[j], pivot) <= 0 && swap(ary, i += 1, j);
      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1), doQuickSort(ary, comparator, q + 1, r);
    }
    var low, high;
  }
  exports.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
}, function(module, exports, __webpack_require__) {
  var SourceMapGenerator = __webpack_require__(142).SourceMapGenerator, util = __webpack_require__(29), REGEX_NEWLINE = /(\r?\n)/, isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [], this.sourceContents = {}, this.line = null == aLine ? null : aLine, 
    this.column = null == aColumn ? null : aColumn, this.source = null == aSource ? null : aSource, 
    this.name = null == aName ? null : aName, this[isSourceNode] = !0, null != aChunks && this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode, remainingLines = aGeneratedCode.split(REGEX_NEWLINE), remainingLinesIndex = 0, shiftNextLine = function() {
      return getNextLine() + (getNextLine() || "");
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    }, lastGeneratedLine = 1, lastGeneratedColumn = 0, lastMapping = null;
    return aSourceMapConsumer.eachMapping((function(mapping) {
      if (null !== lastMapping) {
        if (!(lastGeneratedLine < mapping.generatedLine)) {
          var code = (nextLine = remainingLines[remainingLinesIndex]).substr(0, mapping.generatedColumn - lastGeneratedColumn);
          return remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn), 
          lastGeneratedColumn = mapping.generatedColumn, addMappingWithCode(lastMapping, code), 
          void (lastMapping = mapping);
        }
        addMappingWithCode(lastMapping, shiftNextLine()), lastGeneratedLine++, lastGeneratedColumn = 0;
      }
      for (;lastGeneratedLine < mapping.generatedLine; ) node.add(shiftNextLine()), lastGeneratedLine++;
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn)), remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn), 
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }), this), remainingLinesIndex < remainingLines.length && (lastMapping && addMappingWithCode(lastMapping, shiftNextLine()), 
    node.add(remainingLines.splice(remainingLinesIndex).join(""))), aSourceMapConsumer.sources.forEach((function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      null != content && (null != aRelativePath && (sourceFile = util.join(aRelativePath, sourceFile)), 
      node.setSourceContent(sourceFile, content));
    })), node;
    function addMappingWithCode(mapping, code) {
      if (null === mapping || void 0 === mapping.source) node.add(code); else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  }, SourceNode.prototype.add = function(aChunk) {
    if (Array.isArray(aChunk)) aChunk.forEach((function(chunk) {
      this.add(chunk);
    }), this); else {
      if (!aChunk[isSourceNode] && "string" != typeof aChunk) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      aChunk && this.children.push(aChunk);
    }
    return this;
  }, SourceNode.prototype.prepend = function(aChunk) {
    if (Array.isArray(aChunk)) for (var i = aChunk.length - 1; i >= 0; i--) this.prepend(aChunk[i]); else {
      if (!aChunk[isSourceNode] && "string" != typeof aChunk) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      this.children.unshift(aChunk);
    }
    return this;
  }, SourceNode.prototype.walk = function(aFn) {
    for (var chunk, i = 0, len = this.children.length; i < len; i++) (chunk = this.children[i])[isSourceNode] ? chunk.walk(aFn) : "" !== chunk && aFn(chunk, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    });
  }, SourceNode.prototype.join = function(aSep) {
    var newChildren, i, len = this.children.length;
    if (len > 0) {
      for (newChildren = [], i = 0; i < len - 1; i++) newChildren.push(this.children[i]), 
      newChildren.push(aSep);
      newChildren.push(this.children[i]), this.children = newChildren;
    }
    return this;
  }, SourceNode.prototype.replaceRight = function(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    return lastChild[isSourceNode] ? lastChild.replaceRight(aPattern, aReplacement) : "string" == typeof lastChild ? this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement) : this.children.push("".replace(aPattern, aReplacement)), 
    this;
  }, SourceNode.prototype.setSourceContent = function(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  }, SourceNode.prototype.walkSourceContents = function(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) this.children[i][isSourceNode] && this.children[i].walkSourceContents(aFn);
    var sources = Object.keys(this.sourceContents);
    for (i = 0, len = sources.length; i < len; i++) aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }, SourceNode.prototype.toString = function() {
    var str = "";
    return this.walk((function(chunk) {
      str += chunk;
    })), str;
  }, SourceNode.prototype.toStringWithSourceMap = function(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    }, map = new SourceMapGenerator(aArgs), sourceMappingActive = !1, lastOriginalSource = null, lastOriginalLine = null, lastOriginalColumn = null, lastOriginalName = null;
    return this.walk((function(chunk, original) {
      generated.code += chunk, null !== original.source && null !== original.line && null !== original.column ? (lastOriginalSource === original.source && lastOriginalLine === original.line && lastOriginalColumn === original.column && lastOriginalName === original.name || map.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      }), lastOriginalSource = original.source, lastOriginalLine = original.line, lastOriginalColumn = original.column, 
      lastOriginalName = original.name, sourceMappingActive = !0) : sourceMappingActive && (map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      }), lastOriginalSource = null, sourceMappingActive = !1);
      for (var idx = 0, length = chunk.length; idx < length; idx++) 10 === chunk.charCodeAt(idx) ? (generated.line++, 
      generated.column = 0, idx + 1 === length ? (lastOriginalSource = null, sourceMappingActive = !1) : sourceMappingActive && map.addMapping({
        source: original.source,
        original: {
          line: original.line,
          column: original.column
        },
        generated: {
          line: generated.line,
          column: generated.column
        },
        name: original.name
      })) : generated.column++;
    })), this.walkSourceContents((function(sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    })), {
      code: generated.code,
      map: map
    };
  }, exports.SourceNode = SourceNode;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _buffer = (obj = __webpack_require__(334)) && obj.__esModule ? obj : {
    default: obj
  }, n = _interopRequireWildcard(__webpack_require__(145)), t = _interopRequireWildcard(__webpack_require__(1)), generatorFunctions = _interopRequireWildcard(__webpack_require__(337));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  const SCIENTIFIC_NOTATION = /e/i, ZERO_DECIMAL_INTEGER = /\.0+$/, NON_DECIMAL_LITERAL = /^0[box]/, PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
  class Printer {
    constructor(format, map) {
      this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._insideAux = !1, 
      this._printedCommentStarts = {}, this._parenPushNewlineState = null, this._noLineTerminator = !1, 
      this._printAuxAfterOnNextUserNode = !1, this._printedComments = new WeakSet, this._endsWithInteger = !1, 
      this._endsWithWord = !1, this.format = format || {}, this._buf = new _buffer.default(map);
    }
    generate(ast) {
      return this.print(ast), this._maybeAddAuxComment(), this._buf.get();
    }
    indent() {
      this.format.compact || this.format.concise || this._indent++;
    }
    dedent() {
      this.format.compact || this.format.concise || this._indent--;
    }
    semicolon(force = !1) {
      this._maybeAddAuxComment(), this._append(";", !force);
    }
    rightBrace() {
      this.format.minified && this._buf.removeLastSemicolon(), this.token("}");
    }
    space(force = !1) {
      this.format.compact || (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) && this._space();
    }
    word(str) {
      (this._endsWithWord || this.endsWith("/") && 0 === str.indexOf("/")) && this._space(), 
      this._maybeAddAuxComment(), this._append(str), this._endsWithWord = !0;
    }
    number(str) {
      this.word(str), this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && "." !== str[str.length - 1];
    }
    token(str) {
      ("--" === str && this.endsWith("!") || "+" === str[0] && this.endsWith("+") || "-" === str[0] && this.endsWith("-") || "." === str[0] && this._endsWithInteger) && this._space(), 
      this._maybeAddAuxComment(), this._append(str);
    }
    newline(i) {
      if (!this.format.retainLines && !this.format.compact) if (this.format.concise) this.space(); else if (!(this.endsWith("\n\n") || ("number" != typeof i && (i = 1), 
      i = Math.min(2, i), (this.endsWith("{\n") || this.endsWith(":\n")) && i--, i <= 0))) for (let j = 0; j < i; j++) this._newline();
    }
    endsWith(str) {
      return this._buf.endsWith(str);
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(loc, cb) {
      this._catchUp("start", loc), this._buf.exactSource(loc, cb);
    }
    source(prop, loc) {
      this._catchUp(prop, loc), this._buf.source(prop, loc);
    }
    withSource(prop, loc, cb) {
      this._catchUp(prop, loc), this._buf.withSource(prop, loc, cb);
    }
    _space() {
      this._append(" ", !0);
    }
    _newline() {
      this._append("\n", !0);
    }
    _append(str, queue = !1) {
      this._maybeAddParen(str), this._maybeIndent(str), queue ? this._buf.queue(str) : this._buf.append(str), 
      this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(str) {
      this._indent && this.endsWith("\n") && "\n" !== str[0] && this._buf.queue(this._getIndent());
    }
    _maybeAddParen(str) {
      const parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      let i;
      for (i = 0; i < str.length && " " === str[i]; i++) continue;
      if (i === str.length) return;
      const cha = str[i];
      if ("\n" !== cha) {
        if ("/" !== cha || i + 1 === str.length) return void (this._parenPushNewlineState = null);
        const chaPost = str[i + 1];
        if ("*" === chaPost) {
          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) return;
        } else if ("/" !== chaPost) return void (this._parenPushNewlineState = null);
      }
      this.token("("), this.indent(), parenPushNewlineState.printed = !0;
    }
    _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      const pos = loc ? loc[prop] : null;
      if (null != (null == pos ? void 0 : pos.line)) {
        const count = pos.line - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) this._newline();
      }
    }
    _getIndent() {
      return this.format.indent.style.repeat(this._indent);
    }
    startTerminatorless(isLabel = !1) {
      return isLabel ? (this._noLineTerminator = !0, null) : this._parenPushNewlineState = {
        printed: !1
      };
    }
    endTerminatorless(state) {
      this._noLineTerminator = !1, (null == state ? void 0 : state.printed) && (this.dedent(), 
      this.newline(), this.token(")"));
    }
    print(node, parent) {
      if (!node) return;
      const oldConcise = this.format.concise;
      node._compact && (this.format.concise = !0);
      const printMethod = this[node.type];
      if (!printMethod) throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(null == node ? void 0 : node.constructor.name)}`);
      this._printStack.push(node);
      const oldInAux = this._insideAux;
      this._insideAux = !node.loc, this._maybeAddAuxComment(this._insideAux && !oldInAux);
      let needsParens = n.needsParens(node, parent, this._printStack);
      this.format.retainFunctionParens && "FunctionExpression" === node.type && node.extra && node.extra.parenthesized && (needsParens = !0), 
      needsParens && this.token("("), this._printLeadingComments(node);
      const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;
      this.withSource("start", loc, () => {
        printMethod.call(this, node, parent);
      }), this._printTrailingComments(node), needsParens && this.token(")"), this._printStack.pop(), 
      this.format.concise = oldConcise, this._insideAux = oldInAux;
    }
    _maybeAddAuxComment(enteredPositionlessNode) {
      enteredPositionlessNode && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      const comment = this.format.auxiliaryCommentBefore;
      comment && this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      const comment = this.format.auxiliaryCommentAfter;
      comment && this._printComment({
        type: "CommentBlock",
        value: comment
      });
    }
    getPossibleRaw(node) {
      const extra = node.extra;
      if (extra && null != extra.raw && null != extra.rawValue && node.value === extra.rawValue) return extra.raw;
    }
    printJoin(nodes, parent, opts = {}) {
      if (!(null == nodes ? void 0 : nodes.length)) return;
      opts.indent && this.indent();
      const newlineOpts = {
        addNewlines: opts.addNewlines
      };
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        node && (opts.statement && this._printNewline(!0, node, parent, newlineOpts), this.print(node, parent), 
        opts.iterator && opts.iterator(node, i), opts.separator && i < nodes.length - 1 && opts.separator.call(this), 
        opts.statement && this._printNewline(!1, node, parent, newlineOpts));
      }
      opts.indent && this.dedent();
    }
    printAndIndentOnComments(node, parent) {
      const indent = node.leadingComments && node.leadingComments.length > 0;
      indent && this.indent(), this.print(node, parent), indent && this.dedent();
    }
    printBlock(parent) {
      const node = parent.body;
      t.isEmptyStatement(node) || this.space(), this.print(node, parent);
    }
    _printTrailingComments(node) {
      this._printComments(this._getComments(!1, node));
    }
    _printLeadingComments(node) {
      this._printComments(this._getComments(!0, node), !0);
    }
    printInnerComments(node, indent = !0) {
      var _node$innerComments;
      (null == (_node$innerComments = node.innerComments) ? void 0 : _node$innerComments.length) && (indent && this.indent(), 
      this._printComments(node.innerComments), indent && this.dedent());
    }
    printSequence(nodes, parent, opts = {}) {
      return opts.statement = !0, this.printJoin(nodes, parent, opts);
    }
    printList(items, parent, opts = {}) {
      return null == opts.separator && (opts.separator = commaSeparator), this.printJoin(items, parent, opts);
    }
    _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;
      if (this.format.concise) return void this.space();
      let lines = 0;
      if (this._buf.hasContent()) {
        leading || lines++, opts.addNewlines && (lines += opts.addNewlines(leading, node) || 0);
        (leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter)(node, parent) && lines++;
      }
      this.newline(lines);
    }
    _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    }
    _printComment(comment, skipNewLines) {
      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;
      if (this._printedComments.add(comment), null != comment.start) {
        if (this._printedCommentStarts[comment.start]) return;
        this._printedCommentStarts[comment.start] = !0;
      }
      const isBlockComment = "CommentBlock" === comment.type, printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
      printNewLines && this._buf.hasContent() && this.newline(1), this.endsWith("[") || this.endsWith("{") || this.space();
      let val = isBlockComment || this._noLineTerminator ? `/*${comment.value}*/` : `//${comment.value}\n`;
      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var _comment$loc;
        const offset = null == (_comment$loc = comment.loc) ? void 0 : _comment$loc.start.column;
        if (offset) {
          const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }
        const indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, "\n" + " ".repeat(indentSize));
      }
      this.endsWith("/") && this._space(), this.withSource("start", comment.loc, () => {
        this._append(val);
      }), printNewLines && this.newline(1);
    }
    _printComments(comments, inlinePureAnnotation) {
      if (null == comments ? void 0 : comments.length) if (inlinePureAnnotation && 1 === comments.length && PURE_ANNOTATION_RE.test(comments[0].value)) this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\n")); else for (const comment of comments) this._printComment(comment);
    }
  }
  function commaSeparator() {
    this.token(","), this.space();
  }
  exports.default = Printer, Object.assign(Printer.prototype, generatorFunctions);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  const SPACES_RE = /^[ \t]+$/;
  exports.default = class {
    constructor(map) {
      this._map = null, this._buf = [], this._last = "", this._queue = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: null,
        line: null,
        column: null,
        filename: null
      }, this._disallowedPop = null, this._map = map;
    }
    get() {
      this._flush();
      const map = this._map, result = {
        code: this._buf.join("").trimRight(),
        map: null,
        rawMappings: null == map ? void 0 : map.getRawMappings()
      };
      return map && Object.defineProperty(result, "map", {
        configurable: !0,
        enumerable: !0,
        get() {
          return this.map = map.get();
        },
        set(value) {
          Object.defineProperty(this, "map", {
            value: value,
            writable: !0
          });
        }
      }), result;
    }
    append(str) {
      this._flush();
      const {line: line, column: column, filename: filename, identifierName: identifierName, force: force} = this._sourcePosition;
      this._append(str, line, column, identifierName, filename, force);
    }
    queue(str) {
      if ("\n" === str) for (;this._queue.length > 0 && SPACES_RE.test(this._queue[0][0]); ) this._queue.shift();
      const {line: line, column: column, filename: filename, identifierName: identifierName, force: force} = this._sourcePosition;
      this._queue.unshift([ str, line, column, identifierName, filename, force ]);
    }
    _flush() {
      let item;
      for (;item = this._queue.pop(); ) this._append(...item);
    }
    _append(str, line, column, identifierName, filename, force) {
      this._map && "\n" !== str[0] && this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force), 
      this._buf.push(str), this._last = str[str.length - 1];
      for (let i = 0; i < str.length; i++) "\n" === str[i] ? (this._position.line++, this._position.column = 0) : this._position.column++;
    }
    removeTrailingNewline() {
      this._queue.length > 0 && "\n" === this._queue[0][0] && this._queue.shift();
    }
    removeLastSemicolon() {
      this._queue.length > 0 && ";" === this._queue[0][0] && this._queue.shift();
    }
    endsWith(suffix) {
      if (1 === suffix.length) {
        let last;
        if (this._queue.length > 0) {
          const str = this._queue[0][0];
          last = str[str.length - 1];
        } else last = this._last;
        return last === suffix;
      }
      const end = this._last + this._queue.reduce((acc, item) => item[0] + acc, "");
      return suffix.length <= end.length && end.slice(-suffix.length) === suffix;
    }
    hasContent() {
      return this._queue.length > 0 || !!this._last;
    }
    exactSource(loc, cb) {
      this.source("start", loc, !0), cb(), this.source("end", loc), this._disallowPop("start", loc);
    }
    source(prop, loc, force) {
      prop && !loc || this._normalizePosition(prop, loc, this._sourcePosition, force);
    }
    withSource(prop, loc, cb) {
      if (!this._map) return cb();
      const originalLine = this._sourcePosition.line, originalColumn = this._sourcePosition.column, originalFilename = this._sourcePosition.filename, originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc), cb(), this._sourcePosition.force && this._sourcePosition.line === originalLine && this._sourcePosition.column === originalColumn && this._sourcePosition.filename === originalFilename || this._disallowedPop && this._disallowedPop.line === originalLine && this._disallowedPop.column === originalColumn && this._disallowedPop.filename === originalFilename || (this._sourcePosition.line = originalLine, 
      this._sourcePosition.column = originalColumn, this._sourcePosition.filename = originalFilename, 
      this._sourcePosition.identifierName = originalIdentifierName, this._sourcePosition.force = !1, 
      this._disallowedPop = null);
    }
    _disallowPop(prop, loc) {
      prop && !loc || (this._disallowedPop = this._normalizePosition(prop, loc));
    }
    _normalizePosition(prop, loc, targetObj, force) {
      const pos = loc ? loc[prop] : null;
      void 0 === targetObj && (targetObj = {
        identifierName: null,
        line: null,
        column: null,
        filename: null,
        force: !1
      });
      const origLine = targetObj.line, origColumn = targetObj.column, origFilename = targetObj.filename;
      return targetObj.identifierName = "start" === prop && (null == loc ? void 0 : loc.identifierName) || null, 
      targetObj.line = null == pos ? void 0 : pos.line, targetObj.column = null == pos ? void 0 : pos.column, 
      targetObj.filename = null == loc ? void 0 : loc.filename, (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) && (targetObj.force = force), 
      targetObj;
    }
    getCurrentColumn() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, ""), lastIndex = extra.lastIndexOf("\n");
      return -1 === lastIndex ? this._position.column + extra.length : extra.length - 1 - lastIndex;
    }
    getCurrentLine() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, "");
      let count = 0;
      for (let i = 0; i < extra.length; i++) "\n" === extra[i] && count++;
      return this._position.line + count;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.list = exports.nodes = void 0;
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function crawl(node, state = {}) {
    return t.isMemberExpression(node) || t.isOptionalMemberExpression(node) ? (crawl(node.object, state), 
    node.computed && crawl(node.property, state)) : t.isBinary(node) || t.isAssignmentExpression(node) ? (crawl(node.left, state), 
    crawl(node.right, state)) : t.isCallExpression(node) || t.isOptionalCallExpression(node) ? (state.hasCall = !0, 
    crawl(node.callee, state)) : t.isFunction(node) ? state.hasFunction = !0 : t.isIdentifier(node) && (state.hasHelper = state.hasHelper || isHelper(node.callee)), 
    state;
  }
  function isHelper(node) {
    return t.isMemberExpression(node) ? isHelper(node.object) || isHelper(node.property) : t.isIdentifier(node) ? "require" === node.name || "_" === node.name[0] : t.isCallExpression(node) ? isHelper(node.callee) : !(!t.isBinary(node) && !t.isAssignmentExpression(node)) && (t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right));
  }
  function isType(node) {
    return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);
  }
  const nodes = {
    AssignmentExpression(node) {
      const state = crawl(node.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) return {
        before: state.hasFunction,
        after: !0
      };
    },
    SwitchCase: (node, parent) => ({
      before: node.consequent.length || parent.cases[0] === node,
      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
    }),
    LogicalExpression(node) {
      if (t.isFunction(node.left) || t.isFunction(node.right)) return {
        after: !0
      };
    },
    Literal(node) {
      if ("use strict" === node.value) return {
        after: !0
      };
    },
    CallExpression(node) {
      if (t.isFunction(node.callee) || isHelper(node)) return {
        before: !0,
        after: !0
      };
    },
    OptionalCallExpression(node) {
      if (t.isFunction(node.callee)) return {
        before: !0,
        after: !0
      };
    },
    VariableDeclaration(node) {
      for (let i = 0; i < node.declarations.length; i++) {
        const declar = node.declarations[i];
        let enabled = isHelper(declar.id) && !isType(declar.init);
        if (!enabled) {
          const state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) return {
          before: !0,
          after: !0
        };
      }
    },
    IfStatement(node) {
      if (t.isBlockStatement(node.consequent)) return {
        before: !0,
        after: !0
      };
    }
  };
  exports.nodes = nodes, nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {
    if (parent.properties[0] === node) return {
      before: !0
    };
  }, nodes.ObjectTypeCallProperty = function(node, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node && !(null == (_parent$properties = parent.properties) ? void 0 : _parent$properties.length)) return {
      before: !0
    };
  }, nodes.ObjectTypeIndexer = function(node, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node && !(null == (_parent$properties2 = parent.properties) ? void 0 : _parent$properties2.length) && !(null == (_parent$callPropertie = parent.callProperties) ? void 0 : _parent$callPropertie.length)) return {
      before: !0
    };
  }, nodes.ObjectTypeInternalSlot = function(node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node && !(null == (_parent$properties3 = parent.properties) ? void 0 : _parent$properties3.length) && !(null == (_parent$callPropertie2 = parent.callProperties) ? void 0 : _parent$callPropertie2.length) && !(null == (_parent$indexers = parent.indexers) ? void 0 : _parent$indexers.length)) return {
      before: !0
    };
  };
  const list = {
    VariableDeclaration: node => node.declarations.map(decl => decl.init),
    ArrayExpression: node => node.elements,
    ObjectExpression: node => node.properties
  };
  exports.list = list, [ [ "Function", !0 ], [ "Class", !0 ], [ "Loop", !0 ], [ "LabeledStatement", !0 ], [ "SwitchStatement", !0 ], [ "TryStatement", !0 ] ].forEach((function([type, amounts]) {
    "boolean" == typeof amounts && (amounts = {
      after: amounts,
      before: amounts
    }), [ type ].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach((function(type) {
      nodes[type] = function() {
        return amounts;
      };
    }));
  }));
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.NullableTypeAnnotation = function(node, parent) {
    return t.isArrayTypeAnnotation(parent);
  }, exports.FunctionTypeAnnotation = function(node, parent, printStack) {
    return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);
  }, exports.UpdateExpression = function(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }, exports.ObjectExpression = function(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerArrow: !0
    });
  }, exports.DoExpression = function(node, parent, printStack) {
    return isFirstInStatement(printStack);
  }, exports.Binary = function(node, parent) {
    if ("**" === node.operator && t.isBinaryExpression(parent, {
      operator: "**"
    })) return parent.left === node;
    if (isClassExtendsClause(node, parent)) return !0;
    if (hasPostfixPart(node, parent) || t.isUnaryLike(parent) || t.isAwaitExpression(parent)) return !0;
    if (t.isBinary(parent)) {
      const parentOp = parent.operator, parentPos = PRECEDENCE[parentOp], nodeOp = node.operator, nodePos = PRECEDENCE[nodeOp];
      if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) return !0;
    }
  }, exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = function(node, parent) {
    return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);
  }, exports.TSAsExpression = function() {
    return !0;
  }, exports.TSTypeAssertion = function() {
    return !0;
  }, exports.TSIntersectionType = exports.TSUnionType = function(node, parent) {
    return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);
  }, exports.TSInferType = function(node, parent) {
    return t.isTSArrayType(parent) || t.isTSOptionalType(parent);
  }, exports.BinaryExpression = function(node, parent) {
    return "in" === node.operator && (t.isVariableDeclarator(parent) || t.isFor(parent));
  }, exports.SequenceExpression = function(node, parent) {
    if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) return !1;
    return !0;
  }, exports.AwaitExpression = exports.YieldExpression = function(node, parent) {
    return t.isBinary(parent) || t.isUnaryLike(parent) || hasPostfixPart(node, parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
  }, exports.ClassExpression = function(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerDefaultExports: !0
    });
  }, exports.UnaryLike = UnaryLike, exports.FunctionExpression = function(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerDefaultExports: !0
    });
  }, exports.ArrowFunctionExpression = function(node, parent) {
    return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);
  }, exports.ConditionalExpression = ConditionalExpression, exports.OptionalCallExpression = exports.OptionalMemberExpression = function(node, parent) {
    return t.isCallExpression(parent, {
      callee: node
    }) || t.isMemberExpression(parent, {
      object: node
    });
  }, exports.AssignmentExpression = function(node, parent, printStack) {
    return !!t.isObjectPattern(node.left) || ConditionalExpression(node, parent);
  }, exports.LogicalExpression = function(node, parent) {
    switch (node.operator) {
     case "||":
      return !!t.isLogicalExpression(parent) && ("??" === parent.operator || "&&" === parent.operator);

     case "&&":
      return t.isLogicalExpression(parent, {
        operator: "??"
      });

     case "??":
      return t.isLogicalExpression(parent) && "??" !== parent.operator;
    }
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const PRECEDENCE = {
    "||": 0,
    "??": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    in: 6,
    instanceof: 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10
  }, isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node, hasPostfixPart = (node, parent) => (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isTaggedTemplateExpression(parent) && parent.tag === node || t.isTSNonNullExpression(parent);
  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || t.isBinaryExpression(parent, {
      operator: "**",
      left: node
    }) || isClassExtendsClause(node, parent);
  }
  function ConditionalExpression(node, parent) {
    return !!(t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {
      test: node
    }) || t.isAwaitExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) || UnaryLike(node, parent);
  }
  function isFirstInStatement(printStack, {considerArrow: considerArrow = !1, considerDefaultExports: considerDefaultExports = !1} = {}) {
    let i = printStack.length - 1, node = printStack[i];
    i--;
    let parent = printStack[i];
    for (;i > 0; ) {
      if (t.isExpressionStatement(parent, {
        expression: node
      }) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {
        declaration: node
      }) || considerArrow && t.isArrowFunctionExpression(parent, {
        body: node
      })) return !0;
      if (!(hasPostfixPart(node, parent) && !t.isNewExpression(parent) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isConditional(parent, {
        test: node
      }) || t.isBinary(parent, {
        left: node
      }) || t.isAssignmentExpression(parent, {
        left: node
      }))) return !1;
      node = parent, i--, parent = printStack[i];
    }
    return !1;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var _templateLiterals = __webpack_require__(338);
  Object.keys(_templateLiterals).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _templateLiterals[key];
      }
    });
  }));
  var _expressions = __webpack_require__(339);
  Object.keys(_expressions).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _expressions[key];
      }
    });
  }));
  var _statements = __webpack_require__(340);
  Object.keys(_statements).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _statements[key];
      }
    });
  }));
  var _classes = __webpack_require__(341);
  Object.keys(_classes).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _classes[key];
      }
    });
  }));
  var _methods = __webpack_require__(342);
  Object.keys(_methods).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _methods[key];
      }
    });
  }));
  var _modules = __webpack_require__(146);
  Object.keys(_modules).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _modules[key];
      }
    });
  }));
  var _types = __webpack_require__(147);
  Object.keys(_types).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _types[key];
      }
    });
  }));
  var _flow = __webpack_require__(344);
  Object.keys(_flow).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _flow[key];
      }
    });
  }));
  var _base = __webpack_require__(345);
  Object.keys(_base).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _base[key];
      }
    });
  }));
  var _jsx = __webpack_require__(346);
  Object.keys(_jsx).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _jsx[key];
      }
    });
  }));
  var _typescript = __webpack_require__(347);
  Object.keys(_typescript).forEach((function(key) {
    "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
      enumerable: !0,
      get: function() {
        return _typescript[key];
      }
    });
  }));
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.TaggedTemplateExpression = function(node) {
    this.print(node.tag, node), this.print(node.typeParameters, node), this.print(node.quasi, node);
  }, exports.TemplateElement = function(node, parent) {
    const isFirst = parent.quasis[0] === node, isLast = parent.quasis[parent.quasis.length - 1] === node, value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
    this.token(value);
  }, exports.TemplateLiteral = function(node) {
    const quasis = node.quasis;
    for (let i = 0; i < quasis.length; i++) this.print(quasis[i], node), i + 1 < quasis.length && this.print(node.expressions[i], node);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.UnaryExpression = function(node) {
    "void" === node.operator || "delete" === node.operator || "typeof" === node.operator || "throw" === node.operator ? (this.word(node.operator), 
    this.space()) : this.token(node.operator);
    this.print(node.argument, node);
  }, exports.DoExpression = function(node) {
    this.word("do"), this.space(), this.print(node.body, node);
  }, exports.ParenthesizedExpression = function(node) {
    this.token("("), this.print(node.expression, node), this.token(")");
  }, exports.UpdateExpression = function(node) {
    node.prefix ? (this.token(node.operator), this.print(node.argument, node)) : (this.startTerminatorless(!0), 
    this.print(node.argument, node), this.endTerminatorless(), this.token(node.operator));
  }, exports.ConditionalExpression = function(node) {
    this.print(node.test, node), this.space(), this.token("?"), this.space(), this.print(node.consequent, node), 
    this.space(), this.token(":"), this.space(), this.print(node.alternate, node);
  }, exports.NewExpression = function(node, parent) {
    if (this.word("new"), this.space(), this.print(node.callee, node), this.format.minified && 0 === node.arguments.length && !node.optional && !t.isCallExpression(parent, {
      callee: node
    }) && !t.isMemberExpression(parent) && !t.isNewExpression(parent)) return;
    this.print(node.typeArguments, node), this.print(node.typeParameters, node), node.optional && this.token("?.");
    this.token("("), this.printList(node.arguments, node), this.token(")");
  }, exports.SequenceExpression = function(node) {
    this.printList(node.expressions, node);
  }, exports.ThisExpression = function() {
    this.word("this");
  }, exports.Super = function() {
    this.word("super");
  }, exports.Decorator = function(node) {
    this.token("@"), this.print(node.expression, node), this.newline();
  }, exports.OptionalMemberExpression = function(node) {
    if (this.print(node.object, node), !node.computed && t.isMemberExpression(node.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
    let computed = node.computed;
    t.isLiteral(node.property) && "number" == typeof node.property.value && (computed = !0);
    node.optional && this.token("?.");
    computed ? (this.token("["), this.print(node.property, node), this.token("]")) : (node.optional || this.token("."), 
    this.print(node.property, node));
  }, exports.OptionalCallExpression = function(node) {
    this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), 
    node.optional && this.token("?.");
    this.token("("), this.printList(node.arguments, node), this.token(")");
  }, exports.CallExpression = function(node) {
    this.print(node.callee, node), this.print(node.typeArguments, node), this.print(node.typeParameters, node), 
    this.token("("), this.printList(node.arguments, node), this.token(")");
  }, exports.Import = function() {
    this.word("import");
  }, exports.EmptyStatement = function() {
    this.semicolon(!0);
  }, exports.ExpressionStatement = function(node) {
    this.print(node.expression, node), this.semicolon();
  }, exports.AssignmentPattern = function(node) {
    this.print(node.left, node), node.left.optional && this.token("?");
    this.print(node.left.typeAnnotation, node), this.space(), this.token("="), this.space(), 
    this.print(node.right, node);
  }, exports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = function(node, parent) {
    const parens = this.inForStatementInitCounter && "in" === node.operator && !n.needsParens(node, parent);
    parens && this.token("(");
    this.print(node.left, node), this.space(), "in" === node.operator || "instanceof" === node.operator ? this.word(node.operator) : this.token(node.operator);
    this.space(), this.print(node.right, node), parens && this.token(")");
  }, exports.BindExpression = function(node) {
    this.print(node.object, node), this.token("::"), this.print(node.callee, node);
  }, exports.MemberExpression = function(node) {
    if (this.print(node.object, node), !node.computed && t.isMemberExpression(node.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
    let computed = node.computed;
    t.isLiteral(node.property) && "number" == typeof node.property.value && (computed = !0);
    computed ? (this.token("["), this.print(node.property, node), this.token("]")) : (this.token("."), 
    this.print(node.property, node));
  }, exports.MetaProperty = function(node) {
    this.print(node.meta, node), this.token("."), this.print(node.property, node);
  }, exports.PrivateName = function(node) {
    this.token("#"), this.print(node.id, node);
  }, exports.V8IntrinsicIdentifier = function(node) {
    this.token("%"), this.word(node.name);
  }, exports.AwaitExpression = exports.YieldExpression = void 0;
  var t = _interopRequireWildcard(__webpack_require__(1)), n = _interopRequireWildcard(__webpack_require__(145));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function buildYieldAwait(keyword) {
    return function(node) {
      if (this.word(keyword), node.delegate && this.token("*"), node.argument) {
        this.space();
        const terminatorState = this.startTerminatorless();
        this.print(node.argument, node), this.endTerminatorless(terminatorState);
      }
    };
  }
  const YieldExpression = buildYieldAwait("yield");
  exports.YieldExpression = YieldExpression;
  const AwaitExpression = buildYieldAwait("await");
  exports.AwaitExpression = AwaitExpression;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.WithStatement = function(node) {
    this.word("with"), this.space(), this.token("("), this.print(node.object, node), 
    this.token(")"), this.printBlock(node);
  }, exports.IfStatement = function(node) {
    this.word("if"), this.space(), this.token("("), this.print(node.test, node), this.token(")"), 
    this.space();
    const needsBlock = node.alternate && t.isIfStatement(function getLastStatement(statement) {
      return t.isStatement(statement.body) ? getLastStatement(statement.body) : statement;
    }(node.consequent));
    needsBlock && (this.token("{"), this.newline(), this.indent());
    this.printAndIndentOnComments(node.consequent, node), needsBlock && (this.dedent(), 
    this.newline(), this.token("}"));
    node.alternate && (this.endsWith("}") && this.space(), this.word("else"), this.space(), 
    this.printAndIndentOnComments(node.alternate, node));
  }, exports.ForStatement = function(node) {
    this.word("for"), this.space(), this.token("("), this.inForStatementInitCounter++, 
    this.print(node.init, node), this.inForStatementInitCounter--, this.token(";"), 
    node.test && (this.space(), this.print(node.test, node));
    this.token(";"), node.update && (this.space(), this.print(node.update, node));
    this.token(")"), this.printBlock(node);
  }, exports.WhileStatement = function(node) {
    this.word("while"), this.space(), this.token("("), this.print(node.test, node), 
    this.token(")"), this.printBlock(node);
  }, exports.DoWhileStatement = function(node) {
    this.word("do"), this.space(), this.print(node.body, node), this.space(), this.word("while"), 
    this.space(), this.token("("), this.print(node.test, node), this.token(")"), this.semicolon();
  }, exports.LabeledStatement = function(node) {
    this.print(node.label, node), this.token(":"), this.space(), this.print(node.body, node);
  }, exports.TryStatement = function(node) {
    this.word("try"), this.space(), this.print(node.block, node), this.space(), node.handlers ? this.print(node.handlers[0], node) : this.print(node.handler, node);
    node.finalizer && (this.space(), this.word("finally"), this.space(), this.print(node.finalizer, node));
  }, exports.CatchClause = function(node) {
    this.word("catch"), this.space(), node.param && (this.token("("), this.print(node.param, node), 
    this.token(")"), this.space());
    this.print(node.body, node);
  }, exports.SwitchStatement = function(node) {
    this.word("switch"), this.space(), this.token("("), this.print(node.discriminant, node), 
    this.token(")"), this.space(), this.token("{"), this.printSequence(node.cases, node, {
      indent: !0,
      addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      }
    }), this.token("}");
  }, exports.SwitchCase = function(node) {
    node.test ? (this.word("case"), this.space(), this.print(node.test, node), this.token(":")) : (this.word("default"), 
    this.token(":"));
    node.consequent.length && (this.newline(), this.printSequence(node.consequent, node, {
      indent: !0
    }));
  }, exports.DebuggerStatement = function() {
    this.word("debugger"), this.semicolon();
  }, exports.VariableDeclaration = function(node, parent) {
    node.declare && (this.word("declare"), this.space());
    this.word(node.kind), this.space();
    let separator, hasInits = !1;
    if (!t.isFor(parent)) for (const declar of node.declarations) declar.init && (hasInits = !0);
    hasInits && (separator = "const" === node.kind ? constDeclarationIndent : variableDeclarationIndent);
    if (this.printList(node.declarations, node, {
      separator: separator
    }), t.isFor(parent) && (parent.left === node || parent.init === node)) return;
    this.semicolon();
  }, exports.VariableDeclarator = function(node) {
    this.print(node.id, node), node.definite && this.token("!");
    this.print(node.id.typeAnnotation, node), node.init && (this.space(), this.token("="), 
    this.space(), this.print(node.init, node));
  }, exports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const buildForXStatement = function(op) {
    return function(node) {
      this.word("for"), this.space(), "of" === op && node.await && (this.word("await"), 
      this.space()), this.token("("), this.print(node.left, node), this.space(), this.word(op), 
      this.space(), this.print(node.right, node), this.token(")"), this.printBlock(node);
    };
  }, ForInStatement = buildForXStatement("in");
  exports.ForInStatement = ForInStatement;
  const ForOfStatement = buildForXStatement("of");
  function buildLabelStatement(prefix, key = "label") {
    return function(node) {
      this.word(prefix);
      const label = node[key];
      if (label) {
        this.space();
        const isLabel = "label" == key, terminatorState = this.startTerminatorless(isLabel);
        this.print(label, node), this.endTerminatorless(terminatorState);
      }
      this.semicolon();
    };
  }
  exports.ForOfStatement = ForOfStatement;
  const ContinueStatement = buildLabelStatement("continue");
  exports.ContinueStatement = ContinueStatement;
  const ReturnStatement = buildLabelStatement("return", "argument");
  exports.ReturnStatement = ReturnStatement;
  const BreakStatement = buildLabelStatement("break");
  exports.BreakStatement = BreakStatement;
  const ThrowStatement = buildLabelStatement("throw", "argument");
  function variableDeclarationIndent() {
    if (this.token(","), this.newline(), this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(!0);
  }
  function constDeclarationIndent() {
    if (this.token(","), this.newline(), this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(!0);
  }
  exports.ThrowStatement = ThrowStatement;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.ClassExpression = exports.ClassDeclaration = function(node, parent) {
    this.format.decoratorsBeforeExport && (t.isExportDefaultDeclaration(parent) || t.isExportNamedDeclaration(parent)) || this.printJoin(node.decorators, node);
    node.declare && (this.word("declare"), this.space());
    node.abstract && (this.word("abstract"), this.space());
    this.word("class"), node.id && (this.space(), this.print(node.id, node));
    this.print(node.typeParameters, node), node.superClass && (this.space(), this.word("extends"), 
    this.space(), this.print(node.superClass, node), this.print(node.superTypeParameters, node));
    node.implements && (this.space(), this.word("implements"), this.space(), this.printList(node.implements, node));
    this.space(), this.print(node.body, node);
  }, exports.ClassBody = function(node) {
    this.token("{"), this.printInnerComments(node), 0 === node.body.length ? this.token("}") : (this.newline(), 
    this.indent(), this.printSequence(node.body, node), this.dedent(), this.endsWith("\n") || this.newline(), 
    this.rightBrace());
  }, exports.ClassProperty = function(node) {
    this.printJoin(node.decorators, node), this.tsPrintClassMemberModifiers(node, !0), 
    node.computed ? (this.token("["), this.print(node.key, node), this.token("]")) : (this._variance(node), 
    this.print(node.key, node));
    node.optional && this.token("?");
    node.definite && this.token("!");
    this.print(node.typeAnnotation, node), node.value && (this.space(), this.token("="), 
    this.space(), this.print(node.value, node));
    this.semicolon();
  }, exports.ClassPrivateProperty = function(node) {
    node.static && (this.word("static"), this.space());
    this.print(node.key, node), this.print(node.typeAnnotation, node), node.value && (this.space(), 
    this.token("="), this.space(), this.print(node.value, node));
    this.semicolon();
  }, exports.ClassMethod = function(node) {
    this._classMethodHead(node), this.space(), this.print(node.body, node);
  }, exports.ClassPrivateMethod = function(node) {
    this._classMethodHead(node), this.space(), this.print(node.body, node);
  }, exports._classMethodHead = function(node) {
    this.printJoin(node.decorators, node), this.tsPrintClassMemberModifiers(node, !1), 
    this._methodHead(node);
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports._params = function(node) {
    this.print(node.typeParameters, node), this.token("("), this._parameters(node.params, node), 
    this.token(")"), this.print(node.returnType, node);
  }, exports._parameters = function(parameters, parent) {
    for (let i = 0; i < parameters.length; i++) this._param(parameters[i], parent), 
    i < parameters.length - 1 && (this.token(","), this.space());
  }, exports._param = function(parameter, parent) {
    this.printJoin(parameter.decorators, parameter), this.print(parameter, parent), 
    parameter.optional && this.token("?");
    this.print(parameter.typeAnnotation, parameter);
  }, exports._methodHead = function(node) {
    const kind = node.kind, key = node.key;
    "get" !== kind && "set" !== kind || (this.word(kind), this.space());
    node.async && (this.word("async"), this.space());
    "method" !== kind && "init" !== kind || node.generator && this.token("*");
    node.computed ? (this.token("["), this.print(key, node), this.token("]")) : this.print(key, node);
    node.optional && this.token("?");
    this._params(node);
  }, exports._predicate = function(node) {
    node.predicate && (node.returnType || this.token(":"), this.space(), this.print(node.predicate, node));
  }, exports._functionHead = function(node) {
    node.async && (this.word("async"), this.space());
    this.word("function"), node.generator && this.token("*");
    this.space(), node.id && this.print(node.id, node);
    this._params(node), this._predicate(node);
  }, exports.FunctionDeclaration = exports.FunctionExpression = function(node) {
    this._functionHead(node), this.space(), this.print(node.body, node);
  }, exports.ArrowFunctionExpression = function(node) {
    node.async && (this.word("async"), this.space());
    const firstParam = node.params[0];
    1 === node.params.length && t.isIdentifier(firstParam) && !function(node, param) {
      return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
    }(node, firstParam) ? this.format.retainLines && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line ? (this.token("("), 
    firstParam.loc && firstParam.loc.start.line > node.loc.start.line ? (this.indent(), 
    this.print(firstParam, node), this.dedent(), this._catchUp("start", node.body.loc)) : this.print(firstParam, node), 
    this.token(")")) : this.print(firstParam, node) : this._params(node);
    this._predicate(node), this.space(), this.token("=>"), this.space(), this.print(node.body, node);
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  const object = {}, hasOwnProperty = object.hasOwnProperty, forOwn = (object, callback) => {
    for (const key in object) hasOwnProperty.call(object, key) && callback(key, object[key]);
  }, toString = object.toString, isArray = Array.isArray, isBuffer = Buffer.isBuffer, singleEscapes = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t"
  }, regexSingleEscape = /["'\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitelist = /[ !#-&\(-\[\]-_a-~]/, jsesc = (argument, options) => {
    const increaseIndentation = () => {
      oldIndent = indent, ++options.indentLevel, indent = options.indent.repeat(options.indentLevel);
    }, defaults = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "\t",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, json = options && options.json;
    var destination, source;
    json && (defaults.quotes = "double", defaults.wrap = !0), destination = defaults, 
    "single" != (options = (source = options) ? (forOwn(source, (key, value) => {
      destination[key] = value;
    }), destination) : destination).quotes && "double" != options.quotes && "backtick" != options.quotes && (options.quotes = "single");
    const quote = "double" == options.quotes ? '"' : "backtick" == options.quotes ? "`" : "'", compact = options.compact, lowercaseHex = options.lowercaseHex;
    let indent = options.indent.repeat(options.indentLevel), oldIndent = "";
    const inline1 = options.__inline1__, inline2 = options.__inline2__, newLine = compact ? "" : "\n";
    let result, isEmpty = !0;
    const useBinNumbers = "binary" == options.numbers, useOctNumbers = "octal" == options.numbers, useDecNumbers = "decimal" == options.numbers, useHexNumbers = "hexadecimal" == options.numbers;
    if (json && argument && "function" == typeof argument.toJSON && (argument = argument.toJSON()), 
    !(value => "string" == typeof value || "[object String]" == toString.call(value))(argument)) {
      if ((value => "[object Map]" == toString.call(value))(argument)) return 0 == argument.size ? "new Map()" : (compact || (options.__inline1__ = !0, 
      options.__inline2__ = !1), "new Map(" + jsesc(Array.from(argument), options) + ")");
      if ((value => "[object Set]" == toString.call(value))(argument)) return 0 == argument.size ? "new Set()" : "new Set(" + jsesc(Array.from(argument), options) + ")";
      if (isBuffer(argument)) return 0 == argument.length ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(argument), options) + ")";
      if (isArray(argument)) return result = [], options.wrap = !0, inline1 && (options.__inline1__ = !1, 
      options.__inline2__ = !0), inline2 || increaseIndentation(), ((array, callback) => {
        const length = array.length;
        let index = -1;
        for (;++index < length; ) callback(array[index]);
      })(argument, value => {
        isEmpty = !1, inline2 && (options.__inline2__ = !1), result.push((compact || inline2 ? "" : indent) + jsesc(value, options));
      }), isEmpty ? "[]" : inline2 ? "[" + result.join(", ") + "]" : "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
      if (!(value => "number" == typeof value || "[object Number]" == toString.call(value))(argument)) return (value => "[object Object]" == toString.call(value))(argument) ? (result = [], 
      options.wrap = !0, increaseIndentation(), forOwn(argument, (key, value) => {
        isEmpty = !1, result.push((compact ? "" : indent) + jsesc(key, options) + ":" + (compact ? "" : " ") + jsesc(value, options));
      }), isEmpty ? "{}" : "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}") : json ? JSON.stringify(argument) || "null" : String(argument);
      if (json) return JSON.stringify(argument);
      if (useDecNumbers) return String(argument);
      if (useHexNumbers) {
        let hexadecimal = argument.toString(16);
        return lowercaseHex || (hexadecimal = hexadecimal.toUpperCase()), "0x" + hexadecimal;
      }
      if (useBinNumbers) return "0b" + argument.toString(2);
      if (useOctNumbers) return "0o" + argument.toString(8);
    }
    const string = argument;
    let index = -1;
    const length = string.length;
    for (result = ""; ++index < length; ) {
      const character = string.charAt(index);
      if (options.es6) {
        const first = string.charCodeAt(index);
        if (first >= 55296 && first <= 56319 && length > index + 1) {
          const second = string.charCodeAt(index + 1);
          if (second >= 56320 && second <= 57343) {
            let hexadecimal = (1024 * (first - 55296) + second - 56320 + 65536).toString(16);
            lowercaseHex || (hexadecimal = hexadecimal.toUpperCase()), result += "\\u{" + hexadecimal + "}", 
            ++index;
            continue;
          }
        }
      }
      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }
        if ('"' == character) {
          result += quote == character ? '\\"' : character;
          continue;
        }
        if ("`" == character) {
          result += quote == character ? "\\`" : character;
          continue;
        }
        if ("'" == character) {
          result += quote == character ? "\\'" : character;
          continue;
        }
      }
      if ("\0" == character && !json && !regexDigit.test(string.charAt(index + 1))) {
        result += "\\0";
        continue;
      }
      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }
      const charCode = character.charCodeAt(0);
      if (options.minimal && 8232 != charCode && 8233 != charCode) {
        result += character;
        continue;
      }
      let hexadecimal = charCode.toString(16);
      lowercaseHex || (hexadecimal = hexadecimal.toUpperCase());
      const longhand = hexadecimal.length > 2 || json, escaped = "\\" + (longhand ? "u" : "x") + ("0000" + hexadecimal).slice(longhand ? -4 : -2);
      result += escaped;
    }
    return options.wrap && (result = quote + result + quote), "`" == quote && (result = result.replace(/\$\{/g, "\\${")), 
    options.isScriptContext ? result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--") : result;
  };
  jsesc.version = "2.5.2", module.exports = jsesc;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.AnyTypeAnnotation = function() {
    this.word("any");
  }, exports.ArrayTypeAnnotation = function(node) {
    this.print(node.elementType, node), this.token("["), this.token("]");
  }, exports.BooleanTypeAnnotation = function() {
    this.word("boolean");
  }, exports.BooleanLiteralTypeAnnotation = function(node) {
    this.word(node.value ? "true" : "false");
  }, exports.NullLiteralTypeAnnotation = function() {
    this.word("null");
  }, exports.DeclareClass = function(node, parent) {
    t.isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
    this.word("class"), this.space(), this._interfaceish(node);
  }, exports.DeclareFunction = function(node, parent) {
    t.isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
    this.word("function"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation.typeAnnotation, node), 
    node.predicate && (this.space(), this.print(node.predicate, node));
    this.semicolon();
  }, exports.InferredPredicate = function() {
    this.token("%"), this.word("checks");
  }, exports.DeclaredPredicate = function(node) {
    this.token("%"), this.word("checks"), this.token("("), this.print(node.value, node), 
    this.token(")");
  }, exports.DeclareInterface = function(node) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(node);
  }, exports.DeclareModule = function(node) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(node.id, node), 
    this.space(), this.print(node.body, node);
  }, exports.DeclareModuleExports = function(node) {
    this.word("declare"), this.space(), this.word("module"), this.token("."), this.word("exports"), 
    this.print(node.typeAnnotation, node);
  }, exports.DeclareTypeAlias = function(node) {
    this.word("declare"), this.space(), this.TypeAlias(node);
  }, exports.DeclareOpaqueType = function(node, parent) {
    t.isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
    this.OpaqueType(node);
  }, exports.DeclareVariable = function(node, parent) {
    t.isDeclareExportDeclaration(parent) || (this.word("declare"), this.space());
    this.word("var"), this.space(), this.print(node.id, node), this.print(node.id.typeAnnotation, node), 
    this.semicolon();
  }, exports.DeclareExportDeclaration = function(node) {
    this.word("declare"), this.space(), this.word("export"), this.space(), node.default && (this.word("default"), 
    this.space());
    FlowExportDeclaration.apply(this, arguments);
  }, exports.DeclareExportAllDeclaration = function() {
    this.word("declare"), this.space(), _modules.ExportAllDeclaration.apply(this, arguments);
  }, exports.EnumDeclaration = function(node) {
    const {id: id, body: body} = node;
    this.word("enum"), this.space(), this.print(id, node), this.print(body, node);
  }, exports.EnumBooleanBody = function(node) {
    const {explicitType: explicitType} = node;
    enumExplicitType(this, "boolean", explicitType), enumBody(this, node);
  }, exports.EnumNumberBody = function(node) {
    const {explicitType: explicitType} = node;
    enumExplicitType(this, "number", explicitType), enumBody(this, node);
  }, exports.EnumStringBody = function(node) {
    const {explicitType: explicitType} = node;
    enumExplicitType(this, "string", explicitType), enumBody(this, node);
  }, exports.EnumSymbolBody = function(node) {
    enumExplicitType(this, "symbol", !0), enumBody(this, node);
  }, exports.EnumDefaultedMember = function(node) {
    const {id: id} = node;
    this.print(id, node), this.token(",");
  }, exports.EnumBooleanMember = function(node) {
    enumInitializedMember(this, node);
  }, exports.EnumNumberMember = function(node) {
    enumInitializedMember(this, node);
  }, exports.EnumStringMember = function(node) {
    enumInitializedMember(this, node);
  }, exports.ExistsTypeAnnotation = function() {
    this.token("*");
  }, exports.FunctionTypeAnnotation = function(node, parent) {
    this.print(node.typeParameters, node), this.token("("), this.printList(node.params, node), 
    node.rest && (node.params.length && (this.token(","), this.space()), this.token("..."), 
    this.print(node.rest, node));
    this.token(")"), "ObjectTypeCallProperty" === parent.type || "DeclareFunction" === parent.type || "ObjectTypeProperty" === parent.type && parent.method ? this.token(":") : (this.space(), 
    this.token("=>"));
    this.space(), this.print(node.returnType, node);
  }, exports.FunctionTypeParam = function(node) {
    this.print(node.name, node), node.optional && this.token("?");
    node.name && (this.token(":"), this.space());
    this.print(node.typeAnnotation, node);
  }, exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = function(node) {
    this.print(node.id, node), this.print(node.typeParameters, node);
  }, exports._interfaceish = function(node) {
    this.print(node.id, node), this.print(node.typeParameters, node), node.extends.length && (this.space(), 
    this.word("extends"), this.space(), this.printList(node.extends, node));
    node.mixins && node.mixins.length && (this.space(), this.word("mixins"), this.space(), 
    this.printList(node.mixins, node));
    node.implements && node.implements.length && (this.space(), this.word("implements"), 
    this.space(), this.printList(node.implements, node));
    this.space(), this.print(node.body, node);
  }, exports._variance = function(node) {
    node.variance && ("plus" === node.variance.kind ? this.token("+") : "minus" === node.variance.kind && this.token("-"));
  }, exports.InterfaceDeclaration = function(node) {
    this.word("interface"), this.space(), this._interfaceish(node);
  }, exports.InterfaceTypeAnnotation = function(node) {
    this.word("interface"), node.extends && node.extends.length && (this.space(), this.word("extends"), 
    this.space(), this.printList(node.extends, node));
    this.space(), this.print(node.body, node);
  }, exports.IntersectionTypeAnnotation = function(node) {
    this.printJoin(node.types, node, {
      separator: andSeparator
    });
  }, exports.MixedTypeAnnotation = function() {
    this.word("mixed");
  }, exports.EmptyTypeAnnotation = function() {
    this.word("empty");
  }, exports.NullableTypeAnnotation = function(node) {
    this.token("?"), this.print(node.typeAnnotation, node);
  }, exports.NumberTypeAnnotation = function() {
    this.word("number");
  }, exports.StringTypeAnnotation = function() {
    this.word("string");
  }, exports.ThisTypeAnnotation = function() {
    this.word("this");
  }, exports.TupleTypeAnnotation = function(node) {
    this.token("["), this.printList(node.types, node), this.token("]");
  }, exports.TypeofTypeAnnotation = function(node) {
    this.word("typeof"), this.space(), this.print(node.argument, node);
  }, exports.TypeAlias = function(node) {
    this.word("type"), this.space(), this.print(node.id, node), this.print(node.typeParameters, node), 
    this.space(), this.token("="), this.space(), this.print(node.right, node), this.semicolon();
  }, exports.TypeAnnotation = function(node) {
    this.token(":"), this.space(), node.optional && this.token("?");
    this.print(node.typeAnnotation, node);
  }, exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = function(node) {
    this.token("<"), this.printList(node.params, node, {}), this.token(">");
  }, exports.TypeParameter = function(node) {
    this._variance(node), this.word(node.name), node.bound && this.print(node.bound, node);
    node.default && (this.space(), this.token("="), this.space(), this.print(node.default, node));
  }, exports.OpaqueType = function(node) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(node.id, node), 
    this.print(node.typeParameters, node), node.supertype && (this.token(":"), this.space(), 
    this.print(node.supertype, node));
    node.impltype && (this.space(), this.token("="), this.space(), this.print(node.impltype, node));
    this.semicolon();
  }, exports.ObjectTypeAnnotation = function(node) {
    node.exact ? this.token("{|") : this.token("{");
    const props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);
    props.length && (this.space(), this.printJoin(props, node, {
      addNewlines(leading) {
        if (leading && !props[0]) return 1;
      },
      indent: !0,
      statement: !0,
      iterator: () => {
        (1 !== props.length || node.inexact) && (this.token(","), this.space());
      }
    }), this.space());
    node.inexact && (this.indent(), this.token("..."), props.length && this.newline(), 
    this.dedent());
    node.exact ? this.token("|}") : this.token("}");
  }, exports.ObjectTypeInternalSlot = function(node) {
    node.static && (this.word("static"), this.space());
    this.token("["), this.token("["), this.print(node.id, node), this.token("]"), this.token("]"), 
    node.optional && this.token("?");
    node.method || (this.token(":"), this.space());
    this.print(node.value, node);
  }, exports.ObjectTypeCallProperty = function(node) {
    node.static && (this.word("static"), this.space());
    this.print(node.value, node);
  }, exports.ObjectTypeIndexer = function(node) {
    node.static && (this.word("static"), this.space());
    this._variance(node), this.token("["), node.id && (this.print(node.id, node), this.token(":"), 
    this.space());
    this.print(node.key, node), this.token("]"), this.token(":"), this.space(), this.print(node.value, node);
  }, exports.ObjectTypeProperty = function(node) {
    node.proto && (this.word("proto"), this.space());
    node.static && (this.word("static"), this.space());
    "get" !== node.kind && "set" !== node.kind || (this.word(node.kind), this.space());
    this._variance(node), this.print(node.key, node), node.optional && this.token("?");
    node.method || (this.token(":"), this.space());
    this.print(node.value, node);
  }, exports.ObjectTypeSpreadProperty = function(node) {
    this.token("..."), this.print(node.argument, node);
  }, exports.QualifiedTypeIdentifier = function(node) {
    this.print(node.qualification, node), this.token("."), this.print(node.id, node);
  }, exports.SymbolTypeAnnotation = function() {
    this.word("symbol");
  }, exports.UnionTypeAnnotation = function(node) {
    this.printJoin(node.types, node, {
      separator: orSeparator
    });
  }, exports.TypeCastExpression = function(node) {
    this.token("("), this.print(node.expression, node), this.print(node.typeAnnotation, node), 
    this.token(")");
  }, exports.Variance = function(node) {
    "plus" === node.kind ? this.token("+") : this.token("-");
  }, exports.VoidTypeAnnotation = function() {
    this.word("void");
  }, Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return _types2.NumericLiteral;
    }
  }), Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return _types2.StringLiteral;
    }
  });
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _modules = __webpack_require__(146), _types2 = __webpack_require__(147);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function enumExplicitType(context, name, hasExplicitType) {
    hasExplicitType && (context.space(), context.word("of"), context.space(), context.word(name)), 
    context.space();
  }
  function enumBody(context, node) {
    const {members: members} = node;
    context.token("{"), context.indent(), context.newline();
    for (const member of members) context.print(member, node), context.newline();
    context.dedent(), context.token("}");
  }
  function enumInitializedMember(context, node) {
    const {id: id, init: init} = node;
    context.print(id, node), context.space(), context.token("="), context.space(), context.print(init, node), 
    context.token(",");
  }
  function FlowExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node), t.isStatement(declar) || this.semicolon();
    } else this.token("{"), node.specifiers.length && (this.space(), this.printList(node.specifiers, node), 
    this.space()), this.token("}"), node.source && (this.space(), this.word("from"), 
    this.space(), this.print(node.source, node)), this.semicolon();
  }
  function andSeparator() {
    this.space(), this.token("&"), this.space();
  }
  function orSeparator() {
    this.space(), this.token("|"), this.space();
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.File = function(node) {
    node.program && this.print(node.program.interpreter, node);
    this.print(node.program, node);
  }, exports.Program = function(node) {
    this.printInnerComments(node, !1), this.printSequence(node.directives, node), node.directives && node.directives.length && this.newline();
    this.printSequence(node.body, node);
  }, exports.BlockStatement = function(node) {
    var _node$directives;
    this.token("{"), this.printInnerComments(node);
    const hasDirectives = null == (_node$directives = node.directives) ? void 0 : _node$directives.length;
    node.body.length || hasDirectives ? (this.newline(), this.printSequence(node.directives, node, {
      indent: !0
    }), hasDirectives && this.newline(), this.printSequence(node.body, node, {
      indent: !0
    }), this.removeTrailingNewline(), this.source("end", node.loc), this.endsWith("\n") || this.newline(), 
    this.rightBrace()) : (this.source("end", node.loc), this.token("}"));
  }, exports.Noop = function() {}, exports.Directive = function(node) {
    this.print(node.value, node), this.semicolon();
  }, exports.DirectiveLiteral = function(node) {
    const raw = this.getPossibleRaw(node);
    if (null != raw) return void this.token(raw);
    const {value: value} = node;
    if (unescapedDoubleQuoteRE.test(value)) {
      if (unescapedSingleQuoteRE.test(value)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      this.token(`'${value}'`);
    } else this.token(`"${value}"`);
  }, exports.InterpreterDirective = function(node) {
    this.token(`#!${node.value}\n`);
  }, exports.Placeholder = function(node) {
    this.token("%%"), this.print(node.name), this.token("%%"), "Statement" === node.expectedNode && this.semicolon();
  };
  const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/, unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
}, function(module, exports, __webpack_require__) {
  "use strict";
  function spaceSeparator() {
    this.space();
  }
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.JSXAttribute = function(node) {
    this.print(node.name, node), node.value && (this.token("="), this.print(node.value, node));
  }, exports.JSXIdentifier = function(node) {
    this.word(node.name);
  }, exports.JSXNamespacedName = function(node) {
    this.print(node.namespace, node), this.token(":"), this.print(node.name, node);
  }, exports.JSXMemberExpression = function(node) {
    this.print(node.object, node), this.token("."), this.print(node.property, node);
  }, exports.JSXSpreadAttribute = function(node) {
    this.token("{"), this.token("..."), this.print(node.argument, node), this.token("}");
  }, exports.JSXExpressionContainer = function(node) {
    this.token("{"), this.print(node.expression, node), this.token("}");
  }, exports.JSXSpreadChild = function(node) {
    this.token("{"), this.token("..."), this.print(node.expression, node), this.token("}");
  }, exports.JSXText = function(node) {
    const raw = this.getPossibleRaw(node);
    null != raw ? this.token(raw) : this.token(node.value);
  }, exports.JSXElement = function(node) {
    const open = node.openingElement;
    if (this.print(open, node), open.selfClosing) return;
    this.indent();
    for (const child of node.children) this.print(child, node);
    this.dedent(), this.print(node.closingElement, node);
  }, exports.JSXOpeningElement = function(node) {
    this.token("<"), this.print(node.name, node), this.print(node.typeParameters, node), 
    node.attributes.length > 0 && (this.space(), this.printJoin(node.attributes, node, {
      separator: spaceSeparator
    }));
    node.selfClosing ? (this.space(), this.token("/>")) : this.token(">");
  }, exports.JSXClosingElement = function(node) {
    this.token("</"), this.print(node.name, node), this.token(">");
  }, exports.JSXEmptyExpression = function(node) {
    this.printInnerComments(node);
  }, exports.JSXFragment = function(node) {
    this.print(node.openingFragment, node), this.indent();
    for (const child of node.children) this.print(child, node);
    this.dedent(), this.print(node.closingFragment, node);
  }, exports.JSXOpeningFragment = function() {
    this.token("<"), this.token(">");
  }, exports.JSXClosingFragment = function() {
    this.token("</"), this.token(">");
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  function tokenIfPlusMinus(self, tok) {
    !0 !== tok && self.token(tok);
  }
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.TSTypeAnnotation = function(node) {
    this.token(":"), this.space(), node.optional && this.token("?");
    this.print(node.typeAnnotation, node);
  }, exports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = function(node) {
    this.token("<"), this.printList(node.params, node, {}), this.token(">");
  }, exports.TSTypeParameter = function(node) {
    this.word(node.name), node.constraint && (this.space(), this.word("extends"), this.space(), 
    this.print(node.constraint, node));
    node.default && (this.space(), this.token("="), this.space(), this.print(node.default, node));
  }, exports.TSParameterProperty = function(node) {
    node.accessibility && (this.word(node.accessibility), this.space());
    node.readonly && (this.word("readonly"), this.space());
    this._param(node.parameter);
  }, exports.TSDeclareFunction = function(node) {
    node.declare && (this.word("declare"), this.space());
    this._functionHead(node), this.token(";");
  }, exports.TSDeclareMethod = function(node) {
    this._classMethodHead(node), this.token(";");
  }, exports.TSQualifiedName = function(node) {
    this.print(node.left, node), this.token("."), this.print(node.right, node);
  }, exports.TSCallSignatureDeclaration = function(node) {
    this.tsPrintSignatureDeclarationBase(node), this.token(";");
  }, exports.TSConstructSignatureDeclaration = function(node) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(node), this.token(";");
  }, exports.TSPropertySignature = function(node) {
    const {readonly: readonly, initializer: initializer} = node;
    readonly && (this.word("readonly"), this.space());
    this.tsPrintPropertyOrMethodName(node), this.print(node.typeAnnotation, node), initializer && (this.space(), 
    this.token("="), this.space(), this.print(initializer, node));
    this.token(";");
  }, exports.tsPrintPropertyOrMethodName = function(node) {
    node.computed && this.token("[");
    this.print(node.key, node), node.computed && this.token("]");
    node.optional && this.token("?");
  }, exports.TSMethodSignature = function(node) {
    this.tsPrintPropertyOrMethodName(node), this.tsPrintSignatureDeclarationBase(node), 
    this.token(";");
  }, exports.TSIndexSignature = function(node) {
    const {readonly: readonly} = node;
    readonly && (this.word("readonly"), this.space());
    this.token("["), this._parameters(node.parameters, node), this.token("]"), this.print(node.typeAnnotation, node), 
    this.token(";");
  }, exports.TSAnyKeyword = function() {
    this.word("any");
  }, exports.TSBigIntKeyword = function() {
    this.word("bigint");
  }, exports.TSUnknownKeyword = function() {
    this.word("unknown");
  }, exports.TSNumberKeyword = function() {
    this.word("number");
  }, exports.TSObjectKeyword = function() {
    this.word("object");
  }, exports.TSBooleanKeyword = function() {
    this.word("boolean");
  }, exports.TSStringKeyword = function() {
    this.word("string");
  }, exports.TSSymbolKeyword = function() {
    this.word("symbol");
  }, exports.TSVoidKeyword = function() {
    this.word("void");
  }, exports.TSUndefinedKeyword = function() {
    this.word("undefined");
  }, exports.TSNullKeyword = function() {
    this.word("null");
  }, exports.TSNeverKeyword = function() {
    this.word("never");
  }, exports.TSThisType = function() {
    this.word("this");
  }, exports.TSFunctionType = function(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }, exports.TSConstructorType = function(node) {
    this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(node);
  }, exports.tsPrintFunctionOrConstructorType = function(node) {
    const {typeParameters: typeParameters, parameters: parameters} = node;
    this.print(typeParameters, node), this.token("("), this._parameters(parameters, node), 
    this.token(")"), this.space(), this.token("=>"), this.space(), this.print(node.typeAnnotation.typeAnnotation, node);
  }, exports.TSTypeReference = function(node) {
    this.print(node.typeName, node), this.print(node.typeParameters, node);
  }, exports.TSTypePredicate = function(node) {
    node.asserts && (this.word("asserts"), this.space());
    this.print(node.parameterName), node.typeAnnotation && (this.space(), this.word("is"), 
    this.space(), this.print(node.typeAnnotation.typeAnnotation));
  }, exports.TSTypeQuery = function(node) {
    this.word("typeof"), this.space(), this.print(node.exprName);
  }, exports.TSTypeLiteral = function(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
  }, exports.tsPrintTypeLiteralOrInterfaceBody = function(members, node) {
    this.tsPrintBraced(members, node);
  }, exports.tsPrintBraced = function(members, node) {
    if (this.token("{"), members.length) {
      this.indent(), this.newline();
      for (const member of members) this.print(member, node), this.newline();
      this.dedent(), this.rightBrace();
    } else this.token("}");
  }, exports.TSArrayType = function(node) {
    this.print(node.elementType, node), this.token("[]");
  }, exports.TSTupleType = function(node) {
    this.token("["), this.printList(node.elementTypes, node), this.token("]");
  }, exports.TSOptionalType = function(node) {
    this.print(node.typeAnnotation, node), this.token("?");
  }, exports.TSRestType = function(node) {
    this.token("..."), this.print(node.typeAnnotation, node);
  }, exports.TSUnionType = function(node) {
    this.tsPrintUnionOrIntersectionType(node, "|");
  }, exports.TSIntersectionType = function(node) {
    this.tsPrintUnionOrIntersectionType(node, "&");
  }, exports.tsPrintUnionOrIntersectionType = function(node, sep) {
    this.printJoin(node.types, node, {
      separator() {
        this.space(), this.token(sep), this.space();
      }
    });
  }, exports.TSConditionalType = function(node) {
    this.print(node.checkType), this.space(), this.word("extends"), this.space(), this.print(node.extendsType), 
    this.space(), this.token("?"), this.space(), this.print(node.trueType), this.space(), 
    this.token(":"), this.space(), this.print(node.falseType);
  }, exports.TSInferType = function(node) {
    this.token("infer"), this.space(), this.print(node.typeParameter);
  }, exports.TSParenthesizedType = function(node) {
    this.token("("), this.print(node.typeAnnotation, node), this.token(")");
  }, exports.TSTypeOperator = function(node) {
    this.token(node.operator), this.space(), this.print(node.typeAnnotation, node);
  }, exports.TSIndexedAccessType = function(node) {
    this.print(node.objectType, node), this.token("["), this.print(node.indexType, node), 
    this.token("]");
  }, exports.TSMappedType = function(node) {
    const {readonly: readonly, typeParameter: typeParameter, optional: optional} = node;
    this.token("{"), this.space(), readonly && (tokenIfPlusMinus(this, readonly), this.word("readonly"), 
    this.space());
    this.token("["), this.word(typeParameter.name), this.space(), this.word("in"), this.space(), 
    this.print(typeParameter.constraint, typeParameter), this.token("]"), optional && (tokenIfPlusMinus(this, optional), 
    this.token("?"));
    this.token(":"), this.space(), this.print(node.typeAnnotation, node), this.space(), 
    this.token("}");
  }, exports.TSLiteralType = function(node) {
    this.print(node.literal, node);
  }, exports.TSExpressionWithTypeArguments = function(node) {
    this.print(node.expression, node), this.print(node.typeParameters, node);
  }, exports.TSInterfaceDeclaration = function(node) {
    const {declare: declare, id: id, typeParameters: typeParameters, extends: extendz, body: body} = node;
    declare && (this.word("declare"), this.space());
    this.word("interface"), this.space(), this.print(id, node), this.print(typeParameters, node), 
    extendz && (this.space(), this.word("extends"), this.space(), this.printList(extendz, node));
    this.space(), this.print(body, node);
  }, exports.TSInterfaceBody = function(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
  }, exports.TSTypeAliasDeclaration = function(node) {
    const {declare: declare, id: id, typeParameters: typeParameters, typeAnnotation: typeAnnotation} = node;
    declare && (this.word("declare"), this.space());
    this.word("type"), this.space(), this.print(id, node), this.print(typeParameters, node), 
    this.space(), this.token("="), this.space(), this.print(typeAnnotation, node), this.token(";");
  }, exports.TSAsExpression = function(node) {
    const {expression: expression, typeAnnotation: typeAnnotation} = node;
    this.print(expression, node), this.space(), this.word("as"), this.space(), this.print(typeAnnotation, node);
  }, exports.TSTypeAssertion = function(node) {
    const {typeAnnotation: typeAnnotation, expression: expression} = node;
    this.token("<"), this.print(typeAnnotation, node), this.token(">"), this.space(), 
    this.print(expression, node);
  }, exports.TSEnumDeclaration = function(node) {
    const {declare: declare, const: isConst, id: id, members: members} = node;
    declare && (this.word("declare"), this.space());
    isConst && (this.word("const"), this.space());
    this.word("enum"), this.space(), this.print(id, node), this.space(), this.tsPrintBraced(members, node);
  }, exports.TSEnumMember = function(node) {
    const {id: id, initializer: initializer} = node;
    this.print(id, node), initializer && (this.space(), this.token("="), this.space(), 
    this.print(initializer, node));
    this.token(",");
  }, exports.TSModuleDeclaration = function(node) {
    const {declare: declare, id: id} = node;
    declare && (this.word("declare"), this.space());
    node.global || (this.word("Identifier" === id.type ? "namespace" : "module"), this.space());
    if (this.print(id, node), !node.body) return void this.token(";");
    let body = node.body;
    for (;"TSModuleDeclaration" === body.type; ) this.token("."), this.print(body.id, body), 
    body = body.body;
    this.space(), this.print(body, node);
  }, exports.TSModuleBlock = function(node) {
    this.tsPrintBraced(node.body, node);
  }, exports.TSImportType = function(node) {
    const {argument: argument, qualifier: qualifier, typeParameters: typeParameters} = node;
    this.word("import"), this.token("("), this.print(argument, node), this.token(")"), 
    qualifier && (this.token("."), this.print(qualifier, node));
    typeParameters && this.print(typeParameters, node);
  }, exports.TSImportEqualsDeclaration = function(node) {
    const {isExport: isExport, id: id, moduleReference: moduleReference} = node;
    isExport && (this.word("export"), this.space());
    this.word("import"), this.space(), this.print(id, node), this.space(), this.token("="), 
    this.space(), this.print(moduleReference, node), this.token(";");
  }, exports.TSExternalModuleReference = function(node) {
    this.token("require("), this.print(node.expression, node), this.token(")");
  }, exports.TSNonNullExpression = function(node) {
    this.print(node.expression, node), this.token("!");
  }, exports.TSExportAssignment = function(node) {
    this.word("export"), this.space(), this.token("="), this.space(), this.print(node.expression, node), 
    this.token(";");
  }, exports.TSNamespaceExportDeclaration = function(node) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), 
    this.space(), this.print(node.id, node);
  }, exports.tsPrintSignatureDeclarationBase = function(node) {
    const {typeParameters: typeParameters, parameters: parameters} = node;
    this.print(typeParameters, node), this.token("("), this._parameters(parameters, node), 
    this.token(")"), this.print(node.typeAnnotation, node);
  }, exports.tsPrintClassMemberModifiers = function(node, isField) {
    isField && node.declare && (this.word("declare"), this.space());
    node.accessibility && (this.word(node.accessibility), this.space());
    node.static && (this.word("static"), this.space());
    node.abstract && (this.word("abstract"), this.space());
    isField && node.readonly && (this.word("readonly"), this.space());
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.findParent = function(callback) {
    let path = this;
    for (;path = path.parentPath; ) if (callback(path)) return path;
    return null;
  }, exports.find = function(callback) {
    let path = this;
    do {
      if (callback(path)) return path;
    } while (path = path.parentPath);
    return null;
  }, exports.getFunctionParent = function() {
    return this.findParent(p => p.isFunction());
  }, exports.getStatementParent = function() {
    let path = this;
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) break;
      path = path.parentPath;
    } while (path);
    if (path && (path.isProgram() || path.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return path;
  }, exports.getEarliestCommonAncestorFrom = function(paths) {
    return this.getDeepestCommonAncestorFrom(paths, (function(deepest, i, ancestries) {
      let earliest;
      const keys = t.VISITOR_KEYS[deepest.type];
      for (const ancestry of ancestries) {
        const path = ancestry[i + 1];
        if (!earliest) {
          earliest = path;
          continue;
        }
        if (path.listKey && earliest.listKey === path.listKey && path.key < earliest.key) {
          earliest = path;
          continue;
        }
        keys.indexOf(earliest.parentKey) > keys.indexOf(path.parentKey) && (earliest = path);
      }
      return earliest;
    }));
  }, exports.getDeepestCommonAncestorFrom = function(paths, filter) {
    if (!paths.length) return this;
    if (1 === paths.length) return paths[0];
    let lastCommonIndex, lastCommon, minDepth = 1 / 0;
    const ancestries = paths.map(path => {
      const ancestry = [];
      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== this);
      return ancestry.length < minDepth && (minDepth = ancestry.length), ancestry;
    }), first = ancestries[0];
    depthLoop: for (let i = 0; i < minDepth; i++) {
      const shouldMatch = first[i];
      for (const ancestry of ancestries) if (ancestry[i] !== shouldMatch) break depthLoop;
      lastCommonIndex = i, lastCommon = shouldMatch;
    }
    if (lastCommon) return filter ? filter(lastCommon, lastCommonIndex, ancestries) : lastCommon;
    throw new Error("Couldn't find intersection");
  }, exports.getAncestry = function() {
    let path = this;
    const paths = [];
    do {
      paths.push(path);
    } while (path = path.parentPath);
    return paths;
  }, exports.isAncestor = function(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }, exports.isDescendant = function(maybeAncestor) {
    return !!this.findParent(parent => parent === maybeAncestor);
  }, exports.inType = function() {
    let path = this;
    for (;path; ) {
      for (const type of arguments) if (path.node.type === type) return !0;
      path = path.parentPath;
    }
    return !1;
  };
  var obj, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  (obj = __webpack_require__(10)) && obj.__esModule;
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.getTypeAnnotation = function() {
    if (this.typeAnnotation) return this.typeAnnotation;
    let type = this._getTypeAnnotation() || t.anyTypeAnnotation();
    t.isTypeAnnotation(type) && (type = type.typeAnnotation);
    return this.typeAnnotation = type;
  }, exports._getTypeAnnotation = function() {
    var _inferer;
    const node = this.node;
    if (!node) {
      if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath, declarParent = declar.parentPath;
        return "left" === declar.key && declarParent.isForInStatement() ? t.stringTypeAnnotation() : "left" === declar.key && declarParent.isForOfStatement() ? t.anyTypeAnnotation() : t.voidTypeAnnotation();
      }
      return;
    }
    if (node.typeAnnotation) return node.typeAnnotation;
    let inferer = inferers[node.type];
    if (inferer) return inferer.call(this, node);
    if (inferer = inferers[this.parentPath.type], null == (_inferer = inferer) ? void 0 : _inferer.validParent) return this.parentPath.getTypeAnnotation();
  }, exports.isBaseType = function(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }, exports.couldBeBaseType = function(name) {
    const type = this.getTypeAnnotation();
    if (t.isAnyTypeAnnotation(type)) return !0;
    if (t.isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, !0)) return !0;
      return !1;
    }
    return _isBaseType(name, type, !0);
  }, exports.baseTypeStrictlyMatches = function(right) {
    const left = this.getTypeAnnotation();
    if (right = right.getTypeAnnotation(), !t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) return right.type === left.type;
  }, exports.isGenericType = function(genericName) {
    const type = this.getTypeAnnotation();
    return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {
      name: genericName
    });
  };
  var inferers = _interopRequireWildcard(__webpack_require__(350)), t = _interopRequireWildcard(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function _isBaseType(baseName, type, soft) {
    if ("string" === baseName) return t.isStringTypeAnnotation(type);
    if ("number" === baseName) return t.isNumberTypeAnnotation(type);
    if ("boolean" === baseName) return t.isBooleanTypeAnnotation(type);
    if ("any" === baseName) return t.isAnyTypeAnnotation(type);
    if ("mixed" === baseName) return t.isMixedTypeAnnotation(type);
    if ("empty" === baseName) return t.isEmptyTypeAnnotation(type);
    if ("void" === baseName) return t.isVoidTypeAnnotation(type);
    if (soft) return !1;
    throw new Error("Unknown base type " + baseName);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.VariableDeclarator = function() {
    var _type;
    if (!this.get("id").isIdentifier()) return;
    const init = this.get("init");
    let type = init.getTypeAnnotation();
    "AnyTypeAnnotation" === (null == (_type = type) ? void 0 : _type.type) && init.isCallExpression() && init.get("callee").isIdentifier({
      name: "Array"
    }) && !init.scope.hasBinding("Array", !0) && (type = ArrayExpression());
    return type;
  }, exports.TypeCastExpression = TypeCastExpression, exports.NewExpression = function(node) {
    if (this.get("callee").isIdentifier()) return t.genericTypeAnnotation(node.callee);
  }, exports.TemplateLiteral = function() {
    return t.stringTypeAnnotation();
  }, exports.UnaryExpression = function(node) {
    const operator = node.operator;
    if ("void" === operator) return t.voidTypeAnnotation();
    if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) return t.numberTypeAnnotation();
    if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) return t.stringTypeAnnotation();
    if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) return t.booleanTypeAnnotation();
  }, exports.BinaryExpression = function(node) {
    const operator = node.operator;
    if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) return t.numberTypeAnnotation();
    if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) return t.booleanTypeAnnotation();
    if ("+" === operator) {
      const right = this.get("right"), left = this.get("left");
      return left.isBaseType("number") && right.isBaseType("number") ? t.numberTypeAnnotation() : left.isBaseType("string") || right.isBaseType("string") ? t.stringTypeAnnotation() : t.unionTypeAnnotation([ t.stringTypeAnnotation(), t.numberTypeAnnotation() ]);
    }
  }, exports.LogicalExpression = function() {
    const argumentTypes = [ this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation() ];
    if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) return t.createTSUnionType(argumentTypes);
    if (t.createFlowUnionType) return t.createFlowUnionType(argumentTypes);
    return t.createUnionTypeAnnotation(argumentTypes);
  }, exports.ConditionalExpression = function() {
    const argumentTypes = [ this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation() ];
    if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) return t.createTSUnionType(argumentTypes);
    if (t.createFlowUnionType) return t.createFlowUnionType(argumentTypes);
    return t.createUnionTypeAnnotation(argumentTypes);
  }, exports.SequenceExpression = function() {
    return this.get("expressions").pop().getTypeAnnotation();
  }, exports.ParenthesizedExpression = function() {
    return this.get("expression").getTypeAnnotation();
  }, exports.AssignmentExpression = function() {
    return this.get("right").getTypeAnnotation();
  }, exports.UpdateExpression = function(node) {
    const operator = node.operator;
    if ("++" === operator || "--" === operator) return t.numberTypeAnnotation();
  }, exports.StringLiteral = function() {
    return t.stringTypeAnnotation();
  }, exports.NumericLiteral = function() {
    return t.numberTypeAnnotation();
  }, exports.BooleanLiteral = function() {
    return t.booleanTypeAnnotation();
  }, exports.NullLiteral = function() {
    return t.nullLiteralTypeAnnotation();
  }, exports.RegExpLiteral = function() {
    return t.genericTypeAnnotation(t.identifier("RegExp"));
  }, exports.ObjectExpression = function() {
    return t.genericTypeAnnotation(t.identifier("Object"));
  }, exports.ArrayExpression = ArrayExpression, exports.RestElement = RestElement, 
  exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = function() {
    return t.genericTypeAnnotation(t.identifier("Function"));
  }, exports.CallExpression = function() {
    const {callee: callee} = this.node;
    if (isObjectKeys(callee)) return t.arrayTypeAnnotation(t.stringTypeAnnotation());
    if (isArrayFrom(callee) || isObjectValues(callee)) return t.arrayTypeAnnotation(t.anyTypeAnnotation());
    if (isObjectEntries(callee)) return t.arrayTypeAnnotation(t.tupleTypeAnnotation([ t.stringTypeAnnotation(), t.anyTypeAnnotation() ]));
    return resolveCall(this.get("callee"));
  }, exports.TaggedTemplateExpression = function() {
    return resolveCall(this.get("tag"));
  }, Object.defineProperty(exports, "Identifier", {
    enumerable: !0,
    get: function() {
      return _infererReference.default;
    }
  });
  var obj, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _infererReference = (obj = __webpack_require__(351)) && obj.__esModule ? obj : {
    default: obj
  };
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function TypeCastExpression(node) {
    return node.typeAnnotation;
  }
  function ArrayExpression() {
    return t.genericTypeAnnotation(t.identifier("Array"));
  }
  function RestElement() {
    return ArrayExpression();
  }
  TypeCastExpression.validParent = !0, RestElement.validParent = !0;
  const isArrayFrom = t.buildMatchMemberExpression("Array.from"), isObjectKeys = t.buildMatchMemberExpression("Object.keys"), isObjectValues = t.buildMatchMemberExpression("Object.values"), isObjectEntries = t.buildMatchMemberExpression("Object.entries");
  function resolveCall(callee) {
    if ((callee = callee.resolve()).isFunction()) {
      if (callee.is("async")) return callee.is("generator") ? t.genericTypeAnnotation(t.identifier("AsyncIterator")) : t.genericTypeAnnotation(t.identifier("Promise"));
      if (callee.node.returnType) return callee.node.returnType;
    }
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node) {
    if (!this.isReferenced()) return;
    const binding = this.scope.getBinding(node.name);
    if (binding) return binding.identifier.typeAnnotation ? binding.identifier.typeAnnotation : function(binding, path, name) {
      const types = [], functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
      const testType = function getConditionalAnnotation(binding, path, name) {
        const ifStatement = function(binding, path, name) {
          let parentPath;
          for (;parentPath = path.parentPath; ) {
            if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
              if ("test" === path.key) return;
              return parentPath;
            }
            if (parentPath.isFunction() && parentPath.parentPath.scope.getBinding(name) !== binding) return;
            path = parentPath;
          }
        }(binding, path, name);
        if (!ifStatement) return;
        const paths = [ ifStatement.get("test") ], types = [];
        for (let i = 0; i < paths.length; i++) {
          const path = paths[i];
          if (path.isLogicalExpression()) "&&" === path.node.operator && (paths.push(path.get("left")), 
          paths.push(path.get("right"))); else if (path.isBinaryExpression()) {
            const type = inferAnnotationFromBinaryExpression(name, path);
            type && types.push(type);
          }
        }
        if (types.length) return t.isTSTypeAnnotation(types[0]) && t.createTSUnionType ? {
          typeAnnotation: t.createTSUnionType(types),
          ifStatement: ifStatement
        } : t.createFlowUnionType ? {
          typeAnnotation: t.createFlowUnionType(types),
          ifStatement: ifStatement
        } : {
          typeAnnotation: t.createUnionTypeAnnotation(types),
          ifStatement: ifStatement
        };
        return getConditionalAnnotation(ifStatement, name);
      }(binding, path, name);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0), 
        types.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations = constantViolations.concat(functionConstantViolations);
        for (const violation of constantViolations) types.push(violation.getTypeAnnotation());
      }
      if (!types.length) return;
      if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) return t.createTSUnionType(types);
      if (t.createFlowUnionType) return t.createFlowUnionType(types);
      return t.createUnionTypeAnnotation(types);
    }(binding, this, node.name);
    if ("undefined" === node.name) return t.voidTypeAnnotation();
    if ("NaN" === node.name || "Infinity" === node.name) return t.numberTypeAnnotation();
    node.name;
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function getConstantViolationsBefore(binding, path, functions) {
    const violations = binding.constantViolations.slice();
    return violations.unshift(binding.path), violations.filter(violation => {
      const status = (violation = violation.resolve())._guessExecutionStatusRelativeTo(path);
      return functions && "unknown" === status && functions.push(violation), "before" === status;
    });
  }
  function inferAnnotationFromBinaryExpression(name, path) {
    const operator = path.node.operator, right = path.get("right").resolve(), left = path.get("left").resolve();
    let target, typeofPath, typePath;
    if (left.isIdentifier({
      name: name
    }) ? target = right : right.isIdentifier({
      name: name
    }) && (target = left), target) return "===" === operator ? target.getTypeAnnotation() : t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0 ? t.numberTypeAnnotation() : void 0;
    if ("===" !== operator && "==" !== operator) return;
    if (left.isUnaryExpression({
      operator: "typeof"
    }) ? (typeofPath = left, typePath = right) : right.isUnaryExpression({
      operator: "typeof"
    }) && (typeofPath = right, typePath = left), !typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name: name
    })) return;
    if (typePath = typePath.resolve(), !typePath.isLiteral()) return;
    const typeValue = typePath.node.value;
    return "string" == typeof typeValue ? t.createTypeAnnotationBasedOnTypeof(typeValue) : void 0;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.replaceWithMultiple = function(nodes) {
    this.resync(), nodes = this._verifyNodeList(nodes), t.inheritLeadingComments(nodes[0], this.node), 
    t.inheritTrailingComments(nodes[nodes.length - 1], this.node), this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);
    this.node ? this.requeue() : this.remove();
    return paths;
  }, exports.replaceWithSourceString = function(replacement) {
    this.resync();
    try {
      replacement = `(${replacement})`, replacement = (0, _parser.parse)(replacement);
    } catch (err) {
      const loc = err.loc;
      throw loc && (err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      }), err.code = "BABEL_REPLACE_SOURCE_ERROR"), err;
    }
    return replacement = replacement.program.body[0].expression, _index.default.removeProperties(replacement), 
    this.replaceWith(replacement);
  }, exports.replaceWith = function(replacement) {
    if (this.resync(), this.removed) throw new Error("You can't replace this node, we've already removed it");
    replacement instanceof _index2.default && (replacement = replacement.node);
    if (!replacement) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === replacement) return [ this ];
    if (this.isProgram() && !t.isProgram(replacement)) throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(replacement)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if ("string" == typeof replacement) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let nodePath = "";
    this.isNodeType("Statement") && t.isExpression(replacement) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(replacement) || this.parentPath.isExportDefaultDeclaration() || (replacement = t.expressionStatement(replacement), 
    nodePath = "expression"));
    if (this.isNodeType("Expression") && t.isStatement(replacement) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) return this.replaceExpressionWithStatements([ replacement ]);
    const oldNode = this.node;
    oldNode && (t.inheritsComments(replacement, oldNode), t.removeComments(oldNode));
    return this._replaceWith(replacement), this.type = replacement.type, this.setScope(), 
    this.requeue(), [ nodePath ? this.get(nodePath) : this ];
  }, exports._replaceWith = function(node) {
    if (!this.container) throw new ReferenceError("Container is falsy");
    this.inList ? t.validate(this.parent, this.key, [ node ]) : t.validate(this.parent, this.key, node);
    this.debug("Replace with " + (null == node ? void 0 : node.type)), this.node = this.container[this.key] = node;
  }, exports.replaceExpressionWithStatements = function(nodes) {
    this.resync();
    const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);
    if (toSequenceExpression) return this.replaceWith(toSequenceExpression)[0].get("expressions");
    const functionParent = this.getFunctionParent(), isParentAsync = null == functionParent ? void 0 : functionParent.is("async"), container = t.arrowFunctionExpression([], t.blockStatement(nodes));
    this.replaceWith(t.callExpression(container, [])), this.traverse(hoistVariablesVisitor);
    const completionRecords = this.get("callee").getCompletionRecords();
    for (const path of completionRecords) {
      if (!path.isExpressionStatement()) continue;
      const loop = path.findParent(path => path.isLoop());
      if (loop) {
        let uid = loop.getData("expressionReplacementReturnUid");
        if (uid) uid = t.identifier(uid.name); else {
          const callee = this.get("callee");
          uid = callee.scope.generateDeclaredUidIdentifier("ret"), callee.get("body").pushContainer("body", t.returnStatement(t.cloneNode(uid))), 
          loop.setData("expressionReplacementReturnUid", uid);
        }
        path.get("expression").replaceWith(t.assignmentExpression("=", t.cloneNode(uid), path.node.expression));
      } else path.replaceWith(t.returnStatement(path.node.expression));
    }
    const callee = this.get("callee");
    callee.arrowFunctionToExpression(), isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", t.FUNCTION_TYPES) && (callee.set("async", !0), 
    this.replaceWith(t.awaitExpression(this.node)));
    return callee.get("body.body");
  }, exports.replaceInline = function(nodes) {
    if (this.resync(), Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);
        const paths = this._containerInsertAfter(nodes);
        return this.remove(), paths;
      }
      return this.replaceWithMultiple(nodes);
    }
    return this.replaceWith(nodes);
  };
  var _codeFrame = __webpack_require__(130), _index = _interopRequireDefault(__webpack_require__(28)), _index2 = _interopRequireDefault(__webpack_require__(10)), _parser = __webpack_require__(129), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const hoistVariablesVisitor = {
    Function(path) {
      path.skip();
    },
    VariableDeclaration(path) {
      if ("var" !== path.node.kind) return;
      const bindings = path.getBindingIdentifiers();
      for (const key of Object.keys(bindings)) path.scope.push({
        id: bindings[key]
      });
      const exprs = [];
      for (const declar of path.node.declarations) declar.init && exprs.push(t.expressionStatement(t.assignmentExpression("=", declar.id, declar.init)));
      path.replaceWithMultiple(exprs);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.evaluateTruthy = function() {
    const res = this.evaluate();
    if (res.confident) return !!res.value;
  }, exports.evaluate = function() {
    const state = {
      confident: !0,
      deoptPath: null,
      seen: new Map
    };
    let value = evaluateCached(this, state);
    state.confident || (value = void 0);
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value
    };
  };
  const VALID_CALLEES = [ "String", "Number", "Math" ], INVALID_METHODS = [ "random" ];
  function deopt(path, state) {
    state.confident && (state.deoptPath = path, state.confident = !1);
  }
  function evaluateCached(path, state) {
    const {node: node} = path, {seen: seen} = state;
    if (seen.has(node)) {
      const existing = seen.get(node);
      return existing.resolved ? existing.value : void deopt(path, state);
    }
    {
      const item = {
        resolved: !1
      };
      seen.set(node, item);
      const val = function(path, state) {
        if (!state.confident) return;
        const {node: node} = path;
        if (path.isSequenceExpression()) {
          const exprs = path.get("expressions");
          return evaluateCached(exprs[exprs.length - 1], state);
        }
        if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) return node.value;
        if (path.isNullLiteral()) return null;
        if (path.isTemplateLiteral()) return evaluateQuasis(path, node.quasis, state);
        if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
          const object = path.get("tag.object"), {node: {name: name}} = object, property = path.get("tag.property");
          if (object.isIdentifier() && "String" === name && !path.scope.getBinding(name, !0) && property.isIdentifier && "raw" === property.node.name) return evaluateQuasis(path, node.quasi.quasis, state, !0);
        }
        if (path.isConditionalExpression()) {
          const testResult = evaluateCached(path.get("test"), state);
          if (!state.confident) return;
          return evaluateCached(testResult ? path.get("consequent") : path.get("alternate"), state);
        }
        if (path.isExpressionWrapper()) return evaluateCached(path.get("expression"), state);
        if (path.isMemberExpression() && !path.parentPath.isCallExpression({
          callee: node
        })) {
          const property = path.get("property"), object = path.get("object");
          if (object.isLiteral() && property.isIdentifier()) {
            const value = object.node.value, type = typeof value;
            if ("number" === type || "string" === type) return value[property.node.name];
          }
        }
        if (path.isReferencedIdentifier()) {
          const binding = path.scope.getBinding(node.name);
          if (binding && binding.constantViolations.length > 0) return deopt(binding.path, state);
          if (binding && path.node.start < binding.path.node.end) return deopt(binding.path, state);
          if (null == binding ? void 0 : binding.hasValue) return binding.value;
          {
            if ("undefined" === node.name) return binding ? deopt(binding.path, state) : void 0;
            if ("Infinity" === node.name) return binding ? deopt(binding.path, state) : 1 / 0;
            if ("NaN" === node.name) return binding ? deopt(binding.path, state) : NaN;
            const resolved = path.resolve();
            return resolved === path ? deopt(path, state) : evaluateCached(resolved, state);
          }
        }
        if (path.isUnaryExpression({
          prefix: !0
        })) {
          if ("void" === node.operator) return;
          const argument = path.get("argument");
          if ("typeof" === node.operator && (argument.isFunction() || argument.isClass())) return "function";
          const arg = evaluateCached(argument, state);
          if (!state.confident) return;
          switch (node.operator) {
           case "!":
            return !arg;

           case "+":
            return +arg;

           case "-":
            return -arg;

           case "~":
            return ~arg;

           case "typeof":
            return typeof arg;
          }
        }
        if (path.isArrayExpression()) {
          const arr = [], elems = path.get("elements");
          for (const elem of elems) {
            const elemValue = elem.evaluate();
            if (!elemValue.confident) return deopt(elem, state);
            arr.push(elemValue.value);
          }
          return arr;
        }
        if (path.isObjectExpression()) {
          const obj = {}, props = path.get("properties");
          for (const prop of props) {
            if (prop.isObjectMethod() || prop.isSpreadElement()) return deopt(prop, state);
            const keyPath = prop.get("key");
            let key = keyPath;
            if (prop.node.computed) {
              if (key = key.evaluate(), !key.confident) return deopt(keyPath, state);
              key = key.value;
            } else key = key.isIdentifier() ? key.node.name : key.node.value;
            const valuePath = prop.get("value");
            let value = valuePath.evaluate();
            if (!value.confident) return deopt(valuePath, state);
            value = value.value, obj[key] = value;
          }
          return obj;
        }
        if (path.isLogicalExpression()) {
          const wasConfident = state.confident, left = evaluateCached(path.get("left"), state), leftConfident = state.confident;
          state.confident = wasConfident;
          const right = evaluateCached(path.get("right"), state), rightConfident = state.confident;
          switch (node.operator) {
           case "||":
            if (state.confident = leftConfident && (!!left || rightConfident), !state.confident) return;
            return left || right;

           case "&&":
            if (state.confident = leftConfident && (!left || rightConfident), !state.confident) return;
            return left && right;
          }
        }
        if (path.isBinaryExpression()) {
          const left = evaluateCached(path.get("left"), state);
          if (!state.confident) return;
          const right = evaluateCached(path.get("right"), state);
          if (!state.confident) return;
          switch (node.operator) {
           case "-":
            return left - right;

           case "+":
            return left + right;

           case "/":
            return left / right;

           case "*":
            return left * right;

           case "%":
            return left % right;

           case "**":
            return Math.pow(left, right);

           case "<":
            return left < right;

           case ">":
            return left > right;

           case "<=":
            return left <= right;

           case ">=":
            return left >= right;

           case "==":
            return left == right;

           case "!=":
            return left != right;

           case "===":
            return left === right;

           case "!==":
            return left !== right;

           case "|":
            return left | right;

           case "&":
            return left & right;

           case "^":
            return left ^ right;

           case "<<":
            return left << right;

           case ">>":
            return left >> right;

           case ">>>":
            return left >>> right;
          }
        }
        if (path.isCallExpression()) {
          const callee = path.get("callee");
          let context, func;
          if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, !0) && VALID_CALLEES.indexOf(callee.node.name) >= 0 && (func = global[node.callee.name]), 
          callee.isMemberExpression()) {
            const object = callee.get("object"), property = callee.get("property");
            if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0 && (context = global[object.node.name], 
            func = context[property.node.name]), object.isLiteral() && property.isIdentifier()) {
              const type = typeof object.node.value;
              "string" !== type && "number" !== type || (context = object.node.value, func = context[property.node.name]);
            }
          }
          if (func) {
            const args = path.get("arguments").map(arg => evaluateCached(arg, state));
            if (!state.confident) return;
            return func.apply(context, args);
          }
        }
        deopt(path, state);
      }(path, state);
      return state.confident && (item.resolved = !0, item.value = val), val;
    }
  }
  function evaluateQuasis(path, quasis, state, raw = !1) {
    let str = "", i = 0;
    const exprs = path.get("expressions");
    for (const elem of quasis) {
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      expr && (str += String(evaluateCached(expr, state)));
    }
    if (state.confident) return str;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.toComputedKey = function() {
    const node = this.node;
    let key;
    if (this.isMemberExpression()) key = node.property; else {
      if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
      key = node.key;
    }
    node.computed || t.isIdentifier(key) && (key = t.stringLiteral(key.name));
    return key;
  }, exports.ensureBlock = function() {
    const body = this.get("body"), bodyNode = body.node;
    if (Array.isArray(body)) throw new Error("Can't convert array path to a block statement");
    if (!bodyNode) throw new Error("Can't convert node without a body");
    if (body.isBlockStatement()) return bodyNode;
    const statements = [];
    let key, listKey, stringPath = "body";
    body.isStatement() ? (listKey = "body", key = 0, statements.push(body.node)) : (stringPath += ".body.0", 
    this.isFunction() ? (key = "argument", statements.push(t.returnStatement(body.node))) : (key = "expression", 
    statements.push(t.expressionStatement(body.node))));
    this.node.body = t.blockStatement(statements);
    const parentPath = this.get(stringPath);
    return body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key), 
    this.node;
  }, exports.arrowFunctionToShadowed = function() {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  }, exports.unwrapFunctionEnvironment = function() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    hoistFunctionEnvironment(this);
  }, exports.arrowFunctionToExpression = function({allowInsertArrow: allowInsertArrow = !0, specCompliant: specCompliant = !1} = {}) {
    if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);
    if (this.ensureBlock(), this.node.type = "FunctionExpression", specCompliant) {
      const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");
      checkBinding && this.parentPath.scope.push({
        id: checkBinding,
        init: t.objectExpression([])
      }), this.get("body").unshiftContainer("body", t.expressionStatement(t.callExpression(this.hub.addHelper("newArrowCheck"), [ t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding) ]))), 
      this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, !0) || this.node, t.identifier("bind")), [ checkBinding ? t.identifier(checkBinding.name) : t.thisExpression() ]));
    }
  };
  var obj, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _helperFunctionName = (obj = __webpack_require__(8)) && obj.__esModule ? obj : {
    default: obj
  };
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function hoistFunctionEnvironment(fnPath, specCompliant = !1, allowInsertArrow = !0) {
    const thisEnvFn = fnPath.findParent(p => p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
      static: !1
    })), inConstructor = "constructor" === (null == thisEnvFn ? void 0 : thisEnvFn.node.kind);
    if (thisEnvFn.isClassProperty()) throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    const {thisPaths: thisPaths, argumentsPaths: argumentsPaths, newTargetPaths: newTargetPaths, superProps: superProps, superCalls: superCalls} = function(fnPath) {
      const thisPaths = [], argumentsPaths = [], newTargetPaths = [], superProps = [], superCalls = [];
      return fnPath.traverse({
        ClassProperty(child) {
          child.skip();
        },
        Function(child) {
          child.isArrowFunctionExpression() || child.skip();
        },
        ThisExpression(child) {
          thisPaths.push(child);
        },
        JSXIdentifier(child) {
          "this" === child.node.name && (child.parentPath.isJSXMemberExpression({
            object: child.node
          }) || child.parentPath.isJSXOpeningElement({
            name: child.node
          })) && thisPaths.push(child);
        },
        CallExpression(child) {
          child.get("callee").isSuper() && superCalls.push(child);
        },
        MemberExpression(child) {
          child.get("object").isSuper() && superProps.push(child);
        },
        ReferencedIdentifier(child) {
          "arguments" === child.node.name && argumentsPaths.push(child);
        },
        MetaProperty(child) {
          child.get("meta").isIdentifier({
            name: "new"
          }) && child.get("property").isIdentifier({
            name: "target"
          }) && newTargetPaths.push(child);
        }
      }), {
        thisPaths: thisPaths,
        argumentsPaths: argumentsPaths,
        newTargetPaths: newTargetPaths,
        superProps: superProps,
        superCalls: superCalls
      };
    }(fnPath);
    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
      const allSuperCalls = [];
      thisEnvFn.traverse({
        Function(child) {
          child.isArrowFunctionExpression() || child.skip();
        },
        ClassProperty(child) {
          child.skip();
        },
        CallExpression(child) {
          child.get("callee").isSuper() && allSuperCalls.push(child);
        }
      });
      const superBinding = function(thisEnvFn) {
        return getBinding(thisEnvFn, "supercall", () => {
          const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
          return t.arrowFunctionExpression([ t.restElement(argsBinding) ], t.callExpression(t.super(), [ t.spreadElement(t.identifier(argsBinding.name)) ]));
        });
      }(thisEnvFn);
      allSuperCalls.forEach(superCall => {
        const callee = t.identifier(superBinding);
        callee.loc = superCall.node.callee.loc, superCall.get("callee").replaceWith(callee);
      });
    }
    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, "arguments", () => t.identifier("arguments"));
      argumentsPaths.forEach(argumentsChild => {
        const argsRef = t.identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc, argumentsChild.replaceWith(argsRef);
      });
    }
    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => t.metaProperty(t.identifier("new"), t.identifier("target")));
      newTargetPaths.forEach(targetChild => {
        const targetRef = t.identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc, targetChild.replaceWith(targetRef);
      });
    }
    if (superProps.length > 0) {
      if (!allowInsertArrow) throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
      superProps.reduce((acc, superProp) => acc.concat(function(superProp) {
        if (superProp.parentPath.isAssignmentExpression() && "=" !== superProp.parentPath.node.operator) {
          const assignmentPath = superProp.parentPath, op = assignmentPath.node.operator.slice(0, -1), value = assignmentPath.node.right;
          if (assignmentPath.node.operator = "=", superProp.node.computed) {
            const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
            assignmentPath.get("left").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression("=", tmp, superProp.node.property), !0)), 
            assignmentPath.get("right").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), !0), value));
          } else assignmentPath.get("left").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property)), 
          assignmentPath.get("right").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));
          return [ assignmentPath.get("left"), assignmentPath.get("right").get("left") ];
        }
        if (superProp.parentPath.isUpdateExpression()) {
          const updateExpr = superProp.parentPath, tmp = superProp.scope.generateDeclaredUidIdentifier("tmp"), computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null, parts = [ t.assignmentExpression("=", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression("=", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression("+", t.identifier(tmp.name), t.numericLiteral(1))) ];
          superProp.parentPath.node.prefix || parts.push(t.identifier(tmp.name)), updateExpr.replaceWith(t.sequenceExpression(parts));
          const left = updateExpr.get("expressions.0.right"), right = updateExpr.get("expressions.1.left");
          return [ left, right ];
        }
        return [ superProp ];
      }(superProp)), []).forEach(superProp => {
        const key = superProp.node.computed ? "" : superProp.get("property").node.name, isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node
        }), isCall = superProp.parentPath.isCallExpression({
          callee: superProp.node
        }), superBinding = function(thisEnvFn, isAssignment, propName) {
          return getBinding(thisEnvFn, `superprop_${isAssignment ? "set" : "get"}:${propName || ""}`, () => {
            const argsList = [];
            let fnBody;
            if (propName) fnBody = t.memberExpression(t.super(), t.identifier(propName)); else {
              const method = thisEnvFn.scope.generateUidIdentifier("prop");
              argsList.unshift(method), fnBody = t.memberExpression(t.super(), t.identifier(method.name), !0);
            }
            if (isAssignment) {
              const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
              argsList.push(valueIdent), fnBody = t.assignmentExpression("=", fnBody, t.identifier(valueIdent.name));
            }
            return t.arrowFunctionExpression(argsList, fnBody);
          });
        }(thisEnvFn, isAssignment, key), args = [];
        if (superProp.node.computed && args.push(superProp.get("property").node), isAssignment) {
          const value = superProp.parentPath.node.right;
          args.push(value);
        }
        const call = t.callExpression(t.identifier(superBinding), args);
        isCall ? (superProp.parentPath.unshiftContainer("arguments", t.thisExpression()), 
        superProp.replaceWith(t.memberExpression(call, t.identifier("call"))), thisPaths.push(superProp.parentPath.get("arguments.0"))) : isAssignment ? superProp.parentPath.replaceWith(call) : superProp.replaceWith(call);
      });
    }
    let thisBinding;
    return (thisPaths.length > 0 || specCompliant) && (thisBinding = function(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", thisBinding => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();
        const supers = new WeakSet;
        thisEnvFn.traverse({
          Function(child) {
            child.isArrowFunctionExpression() || child.skip();
          },
          ClassProperty(child) {
            child.skip();
          },
          CallExpression(child) {
            child.get("callee").isSuper() && (supers.has(child.node) || (supers.add(child.node), 
            child.replaceWithMultiple([ child.node, t.assignmentExpression("=", t.identifier(thisBinding), t.identifier("this")) ])));
          }
        });
      });
    }(thisEnvFn, inConstructor), (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) && (thisPaths.forEach(thisChild => {
      const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);
      thisRef.loc = thisChild.node.loc, thisChild.replaceWith(thisRef);
    }), specCompliant && (thisBinding = null))), thisBinding;
  }
  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }
  function getBinding(thisEnvFn, key, init) {
    const cacheKey = "binding:" + key;
    let data = thisEnvFn.getData(cacheKey);
    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name, thisEnvFn.setData(cacheKey, data), thisEnvFn.scope.push({
        id: id,
        init: init(data)
      });
    }
    return data;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.matchesPattern = function(pattern, allowPartial) {
    return t.matchesPattern(this.node, pattern, allowPartial);
  }, exports.has = has, exports.isStatic = function() {
    return this.scope.isStatic(this.node);
  }, exports.isnt = function(key) {
    return !this.has(key);
  }, exports.equals = function(key, value) {
    return this.node[key] === value;
  }, exports.isNodeType = function(type) {
    return t.isType(this.type, type);
  }, exports.canHaveVariableDeclarationOrExpression = function() {
    return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
  }, exports.canSwapBetweenExpressionAndStatement = function(replacement) {
    if ("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) return !1;
    if (this.isExpression()) return t.isBlockStatement(replacement);
    if (this.isBlockStatement()) return t.isExpression(replacement);
    return !1;
  }, exports.isCompletionRecord = function(allowInsideFunction) {
    let path = this, first = !0;
    do {
      const container = path.container;
      if (path.isFunction() && !first) return !!allowInsideFunction;
      if (first = !1, Array.isArray(container) && path.key !== container.length - 1) return !1;
    } while ((path = path.parentPath) && !path.isProgram());
    return !0;
  }, exports.isStatementOrBlock = function() {
    return !this.parentPath.isLabeledStatement() && !t.isBlockStatement(this.container) && t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);
  }, exports.referencesImport = function(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) return !1;
    const binding = this.scope.getBinding(this.node.name);
    if (!binding || "module" !== binding.kind) return !1;
    const path = binding.path, parent = path.parentPath;
    if (!parent.isImportDeclaration()) return !1;
    if (parent.node.source.value !== moduleSource) return !1;
    if (!importName) return !0;
    if (path.isImportDefaultSpecifier() && "default" === importName) return !0;
    if (path.isImportNamespaceSpecifier() && "*" === importName) return !0;
    if (path.isImportSpecifier() && path.node.imported.name === importName) return !0;
    return !1;
  }, exports.getSource = function() {
    const node = this.node;
    if (node.end) {
      const code = this.hub.getCode();
      if (code) return code.slice(node.start, node.end);
    }
    return "";
  }, exports.willIMaybeExecuteBefore = function(target) {
    return "after" !== this._guessExecutionStatusRelativeTo(target);
  }, exports._guessExecutionStatusRelativeTo = function(target) {
    const funcParent = {
      this: getOuterFunction(this),
      target: getOuterFunction(target)
    };
    if (funcParent.target.node !== funcParent.this.node) return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
    const paths = {
      target: target.getAncestry(),
      this: this.getAncestry()
    };
    if (paths.target.indexOf(this) >= 0) return "after";
    if (paths.this.indexOf(target) >= 0) return "before";
    let commonPath;
    const commonIndex = {
      target: 0,
      this: 0
    };
    for (;!commonPath && commonIndex.this < paths.this.length; ) {
      const path = paths.this[commonIndex.this];
      commonIndex.target = paths.target.indexOf(path), commonIndex.target >= 0 ? commonPath = path : commonIndex.this++;
    }
    if (!commonPath) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) return "unknown";
    const divergence = {
      this: paths.this[commonIndex.this - 1],
      target: paths.target[commonIndex.target - 1]
    };
    if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) return divergence.target.key > divergence.this.key ? "before" : "after";
    const keys = t.VISITOR_KEYS[commonPath.type], keyPosition = {
      this: keys.indexOf(divergence.this.parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition.this ? "before" : "after";
  }, exports._guessExecutionStatusRelativeToDifferentFunctions = function(target) {
    if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) return "unknown";
    const binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references) return "before";
    const referencePaths = binding.referencePaths;
    let allStatus;
    for (const path of referencePaths) {
      if (!!path.find(path => path.node === target.node)) continue;
      if ("callee" !== path.key || !path.parentPath.isCallExpression()) return "unknown";
      if (executionOrderCheckedNodes.has(path.node)) continue;
      executionOrderCheckedNodes.add(path.node);
      const status = this._guessExecutionStatusRelativeTo(path);
      if (executionOrderCheckedNodes.delete(path.node), allStatus && allStatus !== status) return "unknown";
      allStatus = status;
    }
    return allStatus;
  }, exports.resolve = function(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  }, exports._resolve = function(dangerous, resolved) {
    if (resolved && resolved.indexOf(this) >= 0) return;
    if ((resolved = resolved || []).push(this), this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) return this.get("init").resolve(dangerous, resolved);
    } else if (this.isReferencedIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding) return;
      if (!binding.constant) return;
      if ("module" === binding.kind) return;
      if (binding.path !== this) {
        const ret = binding.path.resolve(dangerous, resolved);
        if (this.find(parent => parent.node === ret.node)) return;
        return ret;
      }
    } else {
      if (this.isTypeCastExpression()) return this.get("expression").resolve(dangerous, resolved);
      if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!t.isLiteral(targetKey)) return;
        const targetName = targetKey.value, target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get("key");
            let match = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            if (match = match || key.isLiteral({
              value: targetName
            }), match) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elem = target.get("elements")[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
  }, exports.isConstantExpression = function() {
    if (this.isIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      return !!binding && binding.constant;
    }
    if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every(expression => expression.isConstantExpression()));
    if (this.isUnaryExpression()) return "void" === this.get("operator").node && this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    return !1;
  }, exports.isInStrictMode = function() {
    const start = this.isProgram() ? this : this.parentPath;
    return !!start.find(path => {
      if (path.isProgram({
        sourceType: "module"
      })) return !0;
      if (path.isClass()) return !0;
      if (!path.isProgram() && !path.isFunction()) return !1;
      if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) return !1;
      let {node: node} = path;
      path.isFunction() && (node = node.body);
      for (const directive of node.directives) if ("use strict" === directive.value.value) return !0;
    });
  }, exports.is = void 0;
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function has(key) {
    const val = this.node && this.node[key];
    return val && Array.isArray(val) ? !!val.length : !!val;
  }
  const is = has;
  function getOuterFunction(path) {
    return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
  }
  function isExecutionUncertain(type, key) {
    switch (type) {
     case "LogicalExpression":
      return "right" === key;

     case "ConditionalExpression":
     case "IfStatement":
      return "consequent" === key || "alternate" === key;

     case "WhileStatement":
     case "DoWhileStatement":
     case "ForInStatement":
     case "ForOfStatement":
      return "body" === key;

     case "ForStatement":
      return "body" === key || "update" === key;

     case "SwitchStatement":
      return "cases" === key;

     case "TryStatement":
      return "handler" === key;

     case "AssignmentPattern":
      return "right" === key;

     case "OptionalMemberExpression":
      return "property" === key;

     case "OptionalCallExpression":
      return "arguments" === key;

     default:
      return !1;
    }
  }
  function isExecutionUncertainInList(paths, maxIndex) {
    for (let i = 0; i < maxIndex; i++) {
      const path = paths[i];
      if (isExecutionUncertain(path.parent.type, path.parentKey)) return !0;
    }
    return !1;
  }
  exports.is = is;
  const executionOrderCheckedNodes = new WeakSet;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.call = function(key) {
    const opts = this.opts;
    if (this.debug(key), this.node && this._call(opts[key])) return !0;
    if (this.node) return this._call(opts[this.node.type] && opts[this.node.type][key]);
    return !1;
  }, exports._call = function(fns) {
    if (!fns) return !1;
    for (const fn of fns) {
      if (!fn) continue;
      const node = this.node;
      if (!node) return !0;
      const ret = fn.call(this.state, this, this.state);
      if (ret && "object" == typeof ret && "function" == typeof ret.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (ret) throw new Error("Unexpected return value from visitor method " + fn);
      if (this.node !== node) return !0;
      if (this._traverseFlags > 0) return !0;
    }
    return !1;
  }, exports.isBlacklisted = function() {
    const blacklist = this.opts.blacklist;
    return blacklist && blacklist.indexOf(this.node.type) > -1;
  }, exports.visit = function() {
    if (!this.node) return !1;
    if (this.isBlacklisted()) return !1;
    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) return !1;
    if (this.shouldSkip || this.call("enter") || this.shouldSkip) return this.debug("Skip..."), 
    this.shouldStop;
    return this.debug("Recursing into..."), _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys), 
    this.call("exit"), this.shouldStop;
  }, exports.skip = function() {
    this.shouldSkip = !0;
  }, exports.skipKey = function(key) {
    null == this.skipKeys && (this.skipKeys = {});
    this.skipKeys[key] = !0;
  }, exports.stop = function() {
    this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;
  }, exports.setScope = function() {
    if (this.opts && this.opts.noScope) return;
    let target, path = this.parentPath;
    for (;path && !target; ) {
      if (path.opts && path.opts.noScope) return;
      target = path.scope, path = path.parentPath;
    }
    this.scope = this.getScope(target), this.scope && this.scope.init();
  }, exports.setContext = function(context) {
    null != this.skipKeys && (this.skipKeys = {});
    this._traverseFlags = 0, context && (this.context = context, this.state = context.state, 
    this.opts = context.opts);
    return this.setScope(), this;
  }, exports.resync = function() {
    if (this.removed) return;
    this._resyncParent(), this._resyncList(), this._resyncKey();
  }, exports._resyncParent = function() {
    this.parentPath && (this.parent = this.parentPath.node);
  }, exports._resyncKey = function() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) return;
    if (Array.isArray(this.container)) {
      for (let i = 0; i < this.container.length; i++) if (this.container[i] === this.node) return this.setKey(i);
    } else for (const key of Object.keys(this.container)) if (this.container[key] === this.node) return this.setKey(key);
    this.key = null;
  }, exports._resyncList = function() {
    if (!this.parent || !this.inList) return;
    const newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }, exports._resyncRemoved = function() {
    null != this.key && this.container && this.container[this.key] === this.node || this._markRemoved();
  }, exports.popContext = function() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }, exports.pushContext = function(context) {
    this.contexts.push(context), this.setContext(context);
  }, exports.setup = function(parentPath, container, listKey, key) {
    this.listKey = listKey, this.container = container, this.parentPath = parentPath || this.parentPath, 
    this.setKey(key);
  }, exports.setKey = function(key) {
    var _this$node;
    this.key = key, this.node = this.container[this.key], this.type = null == (_this$node = this.node) ? void 0 : _this$node.type;
  }, exports.requeue = function(pathToQueue = this) {
    if (pathToQueue.removed) return;
    const contexts = this.contexts;
    for (const context of contexts) context.maybeQueue(pathToQueue);
  }, exports._getQueueContexts = function() {
    let path = this, contexts = this.contexts;
    for (;!contexts.length && (path = path.parentPath, path); ) contexts = path.contexts;
    return contexts;
  };
  var obj, _index = (obj = __webpack_require__(28)) && obj.__esModule ? obj : {
    default: obj
  }, _index2 = __webpack_require__(10);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.remove = function() {
    var _this$opts;
    this._assertUnremoved(), this.resync(), (null == (_this$opts = this.opts) ? void 0 : _this$opts.noScope) || this._removeFromScope();
    if (this._callRemovalHooks()) return void this._markRemoved();
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }, exports._removeFromScope = function() {
    const bindings = this.getBindingIdentifiers();
    Object.keys(bindings).forEach(name => this.scope.removeBinding(name));
  }, exports._callRemovalHooks = function() {
    for (const fn of _removalHooks.hooks) if (fn(this, this.parentPath)) return !0;
  }, exports._remove = function() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }, exports._markRemoved = function() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED, this.node = null;
  }, exports._assertUnremoved = function() {
    if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  };
  var _removalHooks = __webpack_require__(358), _index = __webpack_require__(10);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.hooks = void 0;
  exports.hooks = [ function(self, parent) {
    if ("test" === self.key && (parent.isWhile() || parent.isSwitchCase()) || "declaration" === self.key && parent.isExportDeclaration() || "body" === self.key && parent.isLabeledStatement() || "declarations" === self.listKey && parent.isVariableDeclaration() && 1 === parent.node.declarations.length || "expression" === self.key && parent.isExpressionStatement()) return parent.remove(), 
    !0;
  }, function(self, parent) {
    if (parent.isSequenceExpression() && 1 === parent.node.expressions.length) return parent.replaceWith(parent.node.expressions[0]), 
    !0;
  }, function(self, parent) {
    if (parent.isBinary()) return "left" === self.key ? parent.replaceWith(parent.node.right) : parent.replaceWith(parent.node.left), 
    !0;
  }, function(self, parent) {
    if (parent.isIfStatement() && ("consequent" === self.key || "alternate" === self.key) || "body" === self.key && (parent.isLoop() || parent.isArrowFunctionExpression())) return self.replaceWith({
      type: "BlockStatement",
      body: []
    }), !0;
  } ];
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.insertBefore = function(nodes) {
    this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
    const {parentPath: parentPath} = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) return parentPath.insertBefore(nodes);
    if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && "init" === this.key) return this.node && nodes.push(this.node), 
    this.replaceExpressionWithStatements(nodes);
    if (Array.isArray(this.container)) return this._containerInsertBefore(nodes);
    if (this.isStatementOrBlock()) {
      const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || null != this.node.expression);
      return this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [ this.node ] : [])), 
      this.unshiftContainer("body", nodes);
    }
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }, exports._containerInsert = function(from, nodes) {
    this.updateSiblingKeys(from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);
    for (let i = 0; i < nodes.length; i++) {
      const to = from + i, path = this.getSibling(to);
      paths.push(path), this.context && this.context.queue && path.pushContext(this.context);
    }
    const contexts = this._getQueueContexts();
    for (const path of paths) {
      path.setScope(), path.debug("Inserted.");
      for (const context of contexts) context.maybeQueue(path, !0);
    }
    return paths;
  }, exports._containerInsertBefore = function(nodes) {
    return this._containerInsert(this.key, nodes);
  }, exports._containerInsertAfter = function(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }, exports.insertAfter = function(nodes) {
    this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
    const {parentPath: parentPath} = this;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) return parentPath.insertAfter(nodes.map(node => t.isExpression(node) ? t.expressionStatement(node) : node));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && "init" === this.key) {
      if (this.node) {
        let {scope: scope} = this;
        parentPath.isMethod({
          computed: !0,
          key: this.node
        }) && (scope = scope.parent);
        const temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(temp), this.node))), 
        nodes.push(t.expressionStatement(t.cloneNode(temp)));
      }
      return this.replaceExpressionWithStatements(nodes);
    }
    if (Array.isArray(this.container)) return this._containerInsertAfter(nodes);
    if (this.isStatementOrBlock()) {
      const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || null != this.node.expression);
      return this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [ this.node ] : [])), 
      this.pushContainer("body", nodes);
    }
    throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }, exports.updateSiblingKeys = function(fromIndex, incrementBy) {
    if (!this.parent) return;
    const paths = _cache.path.get(this.parent);
    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];
      path.key >= fromIndex && (path.key += incrementBy);
    }
  }, exports._verifyNodeList = function(nodes) {
    if (!nodes) return [];
    nodes.constructor !== Array && (nodes = [ nodes ]);
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      let msg;
      if (node ? "object" != typeof node ? msg = "contains a non-object node" : node.type ? node instanceof _index.default && (msg = "has a NodePath when it expected a raw object") : msg = "without a type" : msg = "has falsy node", 
      msg) {
        const type = Array.isArray(node) ? "array" : typeof node;
        throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
      }
    }
    return nodes;
  }, exports.unshiftContainer = function(listKey, nodes) {
    this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
    return _index.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey: listKey,
      key: 0
    })._containerInsertBefore(nodes);
  }, exports.pushContainer = function(listKey, nodes) {
    this._assertUnremoved(), nodes = this._verifyNodeList(nodes);
    const container = this.node[listKey];
    return _index.default.get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey: listKey,
      key: container.length
    }).replaceWithMultiple(nodes);
  }, exports.hoist = function(scope = this.scope) {
    return new _hoister.default(this, scope).run();
  };
  var _cache = __webpack_require__(44), _hoister = _interopRequireDefault(__webpack_require__(360)), _index = _interopRequireDefault(__webpack_require__(10)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const referenceVisitor = {
    ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) return;
      if ("this" === path.node.name) {
        let scope = path.scope;
        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) break;
        } while (scope = scope.parent);
        scope && state.breakOnScopePaths.push(scope.path);
      }
      const binding = path.scope.getBinding(path.node.name);
      if (binding) {
        for (const violation of binding.constantViolations) if (violation.scope !== binding.path.scope) return state.mutableBinding = !0, 
        void path.stop();
        binding === state.scope.getBinding(path.node.name) && (state.bindings[path.node.name] = binding);
      }
    }
  };
  exports.default = class {
    constructor(path, scope) {
      this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], 
      this.scope = scope, this.path = path, this.attachAfter = !1;
    }
    isCompatibleScope(scope) {
      for (const key of Object.keys(this.bindings)) {
        const binding = this.bindings[key];
        if (!scope.bindingIdentifierEquals(key, binding.identifier)) return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let scope = this.path.scope;
      do {
        if (!this.isCompatibleScope(scope)) break;
        if (this.scopes.push(scope), this.breakOnScopePaths.indexOf(scope.path) >= 0) break;
      } while (scope = scope.parent);
    }
    getAttachmentPath() {
      let path = this._getAttachmentPath();
      if (!path) return;
      let targetScope = path.scope;
      if (targetScope.path === path && (targetScope = path.scope.parent), targetScope.path.isProgram() || targetScope.path.isFunction()) for (const name of Object.keys(this.bindings)) {
        if (!targetScope.hasOwnBinding(name)) continue;
        const binding = this.bindings[name];
        if ("param" === binding.kind || "params" === binding.path.parentKey) continue;
        if (this.getAttachmentParentForPath(binding.path).key >= path.key) {
          this.attachAfter = !0, path = binding.path;
          for (const violationPath of binding.constantViolations) this.getAttachmentParentForPath(violationPath).key > path.key && (path = violationPath);
        }
      }
      return path;
    }
    _getAttachmentPath() {
      const scope = this.scopes.pop();
      if (scope) if (scope.path.isFunction()) {
        if (!this.hasOwnParamBindings(scope)) return this.getNextScopeAttachmentParent();
        {
          if (this.scope === scope) return;
          const bodies = scope.path.get("body").get("body");
          for (let i = 0; i < bodies.length; i++) if (!bodies[i].node._blockHoist) return bodies[i];
        }
      } else if (scope.path.isProgram()) return this.getNextScopeAttachmentParent();
    }
    getNextScopeAttachmentParent() {
      const scope = this.scopes.pop();
      if (scope) return this.getAttachmentParentForPath(scope.path);
    }
    getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) return path;
      } while (path = path.parentPath);
    }
    hasOwnParamBindings(scope) {
      for (const name of Object.keys(this.bindings)) {
        if (!scope.hasOwnBinding(name)) continue;
        const binding = this.bindings[name];
        if ("param" === binding.kind && binding.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(referenceVisitor, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      const attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      let uid = attachTo.scope.generateUidIdentifier("ref");
      const declarator = t.variableDeclarator(uid, this.path.node), insertFn = this.attachAfter ? "insertAfter" : "insertBefore", [attached] = attachTo[insertFn]([ attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration("var", [ declarator ]) ]), parent = this.path.parentPath;
      return parent.isJSXElement() && this.path.container === parent.node.children && (uid = t.JSXExpressionContainer(uid)), 
      this.path.replaceWith(t.cloneNode(uid)), attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.getOpposite = function() {
    if ("left" === this.key) return this.getSibling("right");
    if ("right" === this.key) return this.getSibling("left");
  }, exports.getCompletionRecords = function() {
    let paths = [];
    if (this.isIfStatement()) paths = addCompletionRecords(this.get("consequent"), paths), 
    paths = addCompletionRecords(this.get("alternate"), paths); else if (this.isDoExpression() || this.isFor() || this.isWhile()) paths = addCompletionRecords(this.get("body"), paths); else if (this.isProgram() || this.isBlockStatement()) paths = addCompletionRecords(this.get("body").pop(), paths); else {
      if (this.isFunction()) return this.get("body").getCompletionRecords();
      this.isTryStatement() ? (paths = addCompletionRecords(this.get("block"), paths), 
      paths = addCompletionRecords(this.get("handler"), paths)) : this.isCatchClause() ? paths = addCompletionRecords(this.get("body"), paths) : this.isSwitchStatement() ? paths = function(cases, paths) {
        let isLastCaseWithConsequent = !0;
        for (let i = cases.length - 1; i >= 0; i--) {
          const consequent = cases[i].get("consequent");
          let breakStatement;
          findBreak: for (const statement of consequent) if (statement.isBlockStatement()) {
            for (const statementInBlock of statement.get("body")) if (statementInBlock.isBreakStatement()) {
              breakStatement = statementInBlock;
              break findBreak;
            }
          } else if (statement.isBreakStatement()) {
            breakStatement = statement;
            break;
          }
          if (breakStatement) {
            for (;0 === breakStatement.key && breakStatement.parentPath.isBlockStatement(); ) breakStatement = breakStatement.parentPath;
            const prevSibling = breakStatement.getPrevSibling();
            breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement()) ? (paths = addCompletionRecords(prevSibling, paths), 
            breakStatement.remove()) : (breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode()), 
            paths = addCompletionRecords(breakStatement, paths));
          } else if (isLastCaseWithConsequent) {
            const statementFinder = statement => !statement.isBlockStatement() || statement.get("body").some(statementFinder);
            consequent.some(statementFinder) && (paths = addCompletionRecords(consequent[consequent.length - 1], paths), 
            isLastCaseWithConsequent = !1);
          }
        }
        return paths;
      }(this.get("cases"), paths) : paths.push(this);
    }
    return paths;
  }, exports.getSibling = function(key) {
    return _index.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    });
  }, exports.getPrevSibling = function() {
    return this.getSibling(this.key - 1);
  }, exports.getNextSibling = function() {
    return this.getSibling(this.key + 1);
  }, exports.getAllNextSiblings = function() {
    let _key = this.key, sibling = this.getSibling(++_key);
    const siblings = [];
    for (;sibling.node; ) siblings.push(sibling), sibling = this.getSibling(++_key);
    return siblings;
  }, exports.getAllPrevSiblings = function() {
    let _key = this.key, sibling = this.getSibling(--_key);
    const siblings = [];
    for (;sibling.node; ) siblings.push(sibling), sibling = this.getSibling(--_key);
    return siblings;
  }, exports.get = function(key, context) {
    !0 === context && (context = this.context);
    const parts = key.split(".");
    return 1 === parts.length ? this._getKey(key, context) : this._getPattern(parts, context);
  }, exports._getKey = function(key, context) {
    const node = this.node, container = node[key];
    return Array.isArray(container) ? container.map((_, i) => _index.default.get({
      listKey: key,
      parentPath: this,
      parent: node,
      container: container,
      key: i
    }).setContext(context)) : _index.default.get({
      parentPath: this,
      parent: node,
      container: node,
      key: key
    }).setContext(context);
  }, exports._getPattern = function(parts, context) {
    let path = this;
    for (const part of parts) path = "." === part ? path.parentPath : Array.isArray(path) ? path[part] : path.get(part, context);
    return path;
  }, exports.getBindingIdentifiers = function(duplicates) {
    return t.getBindingIdentifiers(this.node, duplicates);
  }, exports.getOuterBindingIdentifiers = function(duplicates) {
    return t.getOuterBindingIdentifiers(this.node, duplicates);
  }, exports.getBindingIdentifierPaths = function(duplicates = !1, outerOnly = !1) {
    let search = [].concat(this);
    const ids = Object.create(null);
    for (;search.length; ) {
      const id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      const keys = t.getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) if (duplicates) {
        (ids[id.node.name] = ids[id.node.name] || []).push(id);
      } else ids[id.node.name] = id; else if (id.isExportDeclaration()) {
        const declaration = id.get("declaration");
        declaration.isDeclaration() && search.push(declaration);
      } else {
        if (outerOnly) {
          if (id.isFunctionDeclaration()) {
            search.push(id.get("id"));
            continue;
          }
          if (id.isFunctionExpression()) continue;
        }
        if (keys) for (let i = 0; i < keys.length; i++) {
          const key = keys[i], child = id.get(key);
          (Array.isArray(child) || child.node) && (search = search.concat(child));
        }
      }
    }
    return ids;
  }, exports.getOuterBindingIdentifierPaths = function(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, !0);
  };
  var obj, _index = (obj = __webpack_require__(10)) && obj.__esModule ? obj : {
    default: obj
  }, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function addCompletionRecords(path, paths) {
    return path ? paths.concat(path.getCompletionRecords()) : paths;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.shareCommentsWithSiblings = function() {
    if ("string" == typeof this.key) return;
    const node = this.node;
    if (!node) return;
    const trailing = node.trailingComments, leading = node.leadingComments;
    if (!trailing && !leading) return;
    const prev = this.getSibling(this.key - 1), next = this.getSibling(this.key + 1), hasPrev = Boolean(prev.node), hasNext = Boolean(next.node);
    hasPrev && !hasNext ? prev.addComments("trailing", trailing) : hasNext && !hasPrev && next.addComments("leading", leading);
  }, exports.addComment = function(type, content, line) {
    t.addComment(this.node, type, content, line);
  }, exports.addComments = function(type, comments) {
    t.addComments(this.node, type, comments);
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.explode = explode, exports.verify = verify, exports.merge = function(visitors, states = [], wrapper) {
    const rootVisitor = {};
    for (let i = 0; i < visitors.length; i++) {
      const visitor = visitors[i], state = states[i];
      explode(visitor);
      for (const type of Object.keys(visitor)) {
        let visitorType = visitor[type];
        (state || wrapper) && (visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper));
        mergePair(rootVisitor[type] = rootVisitor[type] || {}, visitorType);
      }
    }
    return rootVisitor;
  };
  var virtualTypes = _interopRequireWildcard(__webpack_require__(133)), t = _interopRequireWildcard(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function explode(visitor) {
    if (visitor._exploded) return visitor;
    visitor._exploded = !0;
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const parts = nodeType.split("|");
      if (1 === parts.length) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];
      for (const part of parts) visitor[part] = fns;
    }
    verify(visitor), delete visitor.__esModule, function(obj) {
      for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key)) continue;
        const fns = obj[key];
        "function" == typeof fns && (obj[key] = {
          enter: fns
        });
      }
    }(visitor), ensureCallbackArrays(visitor);
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const wrapper = virtualTypes[nodeType];
      if (!wrapper) continue;
      const fns = visitor[nodeType];
      for (const type of Object.keys(fns)) fns[type] = wrapCheck(wrapper, fns[type]);
      if (delete visitor[nodeType], wrapper.types) for (const type of wrapper.types) visitor[type] ? mergePair(visitor[type], fns) : visitor[type] = fns; else mergePair(visitor, fns);
    }
    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const fns = visitor[nodeType];
      let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];
      const deprecratedKey = t.DEPRECATED_KEYS[nodeType];
      if (deprecratedKey && (console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`), 
      aliases = [ deprecratedKey ]), aliases) {
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          existing ? mergePair(existing, fns) : visitor[alias] = Object.assign({}, fns);
        }
      }
    }
    for (const nodeType of Object.keys(visitor)) shouldIgnoreKey(nodeType) || ensureCallbackArrays(visitor[nodeType]);
    return visitor;
  }
  function verify(visitor) {
    if (!visitor._verified) {
      if ("function" == typeof visitor) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      for (const nodeType of Object.keys(visitor)) {
        if ("enter" !== nodeType && "exit" !== nodeType || validateVisitorMethods(nodeType, visitor[nodeType]), 
        shouldIgnoreKey(nodeType)) continue;
        if (t.TYPES.indexOf(nodeType) < 0) throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
        const visitors = visitor[nodeType];
        if ("object" == typeof visitors) for (const visitorKey of Object.keys(visitors)) {
          if ("enter" !== visitorKey && "exit" !== visitorKey) throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
        }
      }
      visitor._verified = !0;
    }
  }
  function validateVisitorMethods(path, val) {
    const fns = [].concat(val);
    for (const fn of fns) if ("function" != typeof fn) throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};
    for (const key of Object.keys(oldVisitor)) {
      let fns = oldVisitor[key];
      Array.isArray(fns) && (fns = fns.map((function(fn) {
        let newFn = fn;
        return state && (newFn = function(path) {
          return fn.call(state, path, state);
        }), wrapper && (newFn = wrapper(state.key, key, newFn)), newFn !== fn && (newFn.toString = () => fn.toString()), 
        newFn;
      })), newVisitor[key] = fns);
    }
    return newVisitor;
  }
  function ensureCallbackArrays(obj) {
    obj.enter && !Array.isArray(obj.enter) && (obj.enter = [ obj.enter ]), obj.exit && !Array.isArray(obj.exit) && (obj.exit = [ obj.exit ]);
  }
  function wrapCheck(wrapper, fn) {
    const newFn = function(path) {
      if (wrapper.checkPath(path)) return fn.apply(this, arguments);
    };
    return newFn.toString = () => fn.toString(), newFn;
  }
  function shouldIgnoreKey(key) {
    return "_" === key[0] || ("enter" === key || "exit" === key || "shouldSkip" === key || ("blacklist" === key || "noScope" === key || "skipKeys" === key));
  }
  function mergePair(dest, src) {
    for (const key of Object.keys(src)) dest[key] = [].concat(dest[key] || [], src[key]);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  exports.default = class {
    getCode() {}
    getScope() {}
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(node, msg, Error = TypeError) {
      return new Error(msg);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.assertFieldTransformed = function(path) {
    if (path.node.declare) throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators");
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.injectInitialization = function(path, constructor, nodes, renamer) {
    if (!nodes.length) return;
    const isDerived = !!path.node.superClass;
    if (!constructor) {
      const newConstructor = _core.types.classMethod("constructor", _core.types.identifier("constructor"), [], _core.types.blockStatement([]));
      isDerived && (newConstructor.params = [ _core.types.restElement(_core.types.identifier("args")) ], 
      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`)), [constructor] = path.get("body").unshiftContainer("body", newConstructor);
    }
    renamer && renamer(referenceVisitor, {
      scope: constructor.scope
    });
    if (isDerived) {
      const bareSupers = [];
      constructor.traverse(findBareSupers, bareSupers);
      let isFirst = !0;
      for (const bareSuper of bareSupers) isFirst ? (bareSuper.insertAfter(nodes), isFirst = !1) : bareSuper.insertAfter(nodes.map(n => _core.types.cloneNode(n)));
    } else constructor.get("body").unshiftContainer("body", nodes);
  }, exports.extractComputedKeys = function(ref, path, computedPaths, file) {
    const declarations = [], state = {
      classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
      file: file
    };
    for (const computedPath of computedPaths) {
      const computedKey = computedPath.get("key");
      computedKey.isReferencedIdentifier() ? handleClassTDZ(computedKey, state) : computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
      const computedNode = computedPath.node;
      if (!computedKey.isConstantExpression()) {
        const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
        path.scope.push({
          id: ident,
          kind: "let"
        }), declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(ident), computedNode.key))), 
        computedNode.key = _core.types.cloneNode(ident);
      }
    }
    return declarations;
  };
  var _core = __webpack_require__(2), _helperReplaceSupers = __webpack_require__(21);
  const findBareSupers = _core.traverse.visitors.merge([ {
    Super(path) {
      const {node: node, parentPath: parentPath} = path;
      parentPath.isCallExpression({
        callee: node
      }) && this.push(parentPath);
    }
  }, _helperReplaceSupers.environmentVisitor ]), referenceVisitor = {
    "TSTypeAnnotation|TypeAnnotation"(path) {
      path.skip();
    },
    ReferencedIdentifier(path) {
      this.scope.hasOwnBinding(path.node.name) && (this.scope.rename(path.node.name), 
      path.skip());
    }
  };
  function handleClassTDZ(path, state) {
    if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
      const classNameTDZError = state.file.addHelper("classNameTDZError"), throwNode = _core.types.callExpression(classNameTDZError, [ _core.types.stringLiteral(path.node.name) ]);
      path.replaceWith(_core.types.sequenceExpression([ throwNode, path.node ])), path.skip();
    }
  }
  const classFieldDefinitionEvaluationTDZVisitor = {
    ReferencedIdentifier: handleClassTDZ
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.enableFeature = function(file, feature, loose) {
    hasFeature(file, feature) && !canIgnoreLoose(file, feature) || (file.set(featuresKey, file.get(featuresKey) | feature), 
    "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" === loose ? (setLoose(file, feature, !0), 
    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" === loose ? (setLoose(file, feature, !1), 
    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature)) : setLoose(file, feature, loose));
    let resolvedLoose, higherPriorityPluginName;
    for (const [mask, name] of featuresSameLoose) {
      if (!hasFeature(file, mask)) continue;
      const loose = isLoose(file, mask);
      if (!canIgnoreLoose(file, mask)) {
        if (resolvedLoose === !loose) throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");
        resolvedLoose = loose, higherPriorityPluginName = name;
      }
    }
    if (void 0 !== resolvedLoose) for (const [mask, name] of featuresSameLoose) hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose && (setLoose(file, mask, resolvedLoose), 
    console.warn(`Though the "loose" option was set to "${!resolvedLoose}" in your @babel/preset-env config, it will not be used for ${name} since the "loose" mode option was set to "${resolvedLoose}" for ${higherPriorityPluginName}.\nThe "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${name}", { "loose": ${resolvedLoose} }]\nto the "plugins" section of your Babel config.`));
  }, exports.isLoose = isLoose, exports.verifyUsedFeatures = function(path, file) {
    if ((0, _decorators.hasOwnDecorators)(path.node)) {
      if (!hasFeature(file, FEATURES.decorators)) throw path.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
      if (path.isPrivate()) throw path.buildCodeFrameError(`Private ${path.isClassMethod() ? "methods" : "fields"} in decorated classes are not supported yet.`);
    }
    if (path.isPrivate() && path.isMethod() && !hasFeature(file, FEATURES.privateMethods)) throw path.buildCodeFrameError("Class private methods are not enabled.");
    if (path.isPrivateName() && path.parentPath.isBinaryExpression({
      operator: "in",
      left: path.node
    }) && !hasFeature(file, FEATURES.privateIn)) throw path.buildCodeFrameError("Private property in checks are not enabled.");
    if (path.isProperty() && !hasFeature(file, FEATURES.fields)) throw path.buildCodeFrameError("Class fields are not enabled.");
  }, exports.FEATURES = void 0;
  var _decorators = __webpack_require__(149);
  const FEATURES = Object.freeze({
    fields: 2,
    privateMethods: 4,
    decorators: 8,
    privateIn: 16
  });
  exports.FEATURES = FEATURES;
  const featuresSameLoose = new Map([ [ FEATURES.fields, "@babel/plugin-proposal-class-properties" ], [ FEATURES.privateMethods, "@babel/plugin-proposal-private-methods" ], [ FEATURES.privateIn, "@babel/plugin-proposal-private-private-property-in-object" ] ]), featuresKey = "@babel/plugin-class-features/featuresKey", looseKey = "@babel/plugin-class-features/looseKey", looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  function hasFeature(file, feature) {
    return !!(file.get(featuresKey) & feature);
  }
  function isLoose(file, feature) {
    return !!(file.get(looseKey) & feature);
  }
  function setLoose(file, feature, loose) {
    loose ? file.set(looseKey, file.get(looseKey) | feature) : file.set(looseKey, file.get(looseKey) & ~feature), 
    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
  }
  function canIgnoreLoose(file, feature) {
    return !!(file.get(looseLowPriorityKey) & feature);
  }
}, function(module) {
  module.exports = JSON.parse('{"name":"@babel/helper-create-class-features-plugin","version":"7.10.5"}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxDynamicImport = (obj = __webpack_require__(87)) && obj.__esModule ? obj : {
    default: obj
  }, _package = __webpack_require__(370);
  const SUPPORTED_MODULES = [ "commonjs", "amd", "systemjs" ];
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "proposal-dynamic-import",
    inherits: _pluginSyntaxDynamicImport.default,
    pre() {
      this.file.set("@babel/plugin-proposal-dynamic-import", _package.version);
    },
    visitor: {
      Program() {
        const modules = this.file.get("@babel/plugin-transform-modules-*");
        if (!SUPPORTED_MODULES.includes(modules)) throw new Error("@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n");
      }
    }
  }));
  exports.default = _default;
}, function(module) {
  module.exports = JSON.parse('{"name":"@babel/plugin-proposal-dynamic-import","version":"7.10.4"}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxJsonStrings = (obj = __webpack_require__(88)) && obj.__esModule ? obj : {
    default: obj
  };
  var _default = (0, _helperPluginUtils.declare)(api => {
    api.assertVersion(7);
    const regex = /(\\*)([\u2028\u2029])/g;
    function replace(match, escapes, separator) {
      return escapes.length % 2 == 1 ? match : `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
    }
    return {
      name: "proposal-json-strings",
      inherits: _pluginSyntaxJsonStrings.default,
      visitor: {
        "DirectiveLiteral|StringLiteral"({node: node}) {
          const {extra: extra} = node;
          (null == extra ? void 0 : extra.raw) && (extra.raw = extra.raw.replace(regex, replace));
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxNullishCoalescingOperator = (obj = __webpack_require__(89)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2);
  var _default = (0, _helperPluginUtils.declare)((api, {loose: loose = !1}) => (api.assertVersion(7), 
  {
    name: "proposal-nullish-coalescing-operator",
    inherits: _pluginSyntaxNullishCoalescingOperator.default,
    visitor: {
      LogicalExpression(path) {
        const {node: node, scope: scope} = path;
        if ("??" !== node.operator) return;
        let assignment, ref = scope.maybeGenerateMemoised(node.left);
        null === ref ? (ref = node.left, assignment = _core.types.cloneNode(node.left)) : assignment = _core.types.assignmentExpression("=", ref, node.left), 
        path.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxNumericSeparator = (obj = __webpack_require__(90)) && obj.__esModule ? obj : {
    default: obj
  };
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "proposal-numeric-separator",
    inherits: _pluginSyntaxNumericSeparator.default,
    visitor: {
      NumericLiteral({node: node}) {
        const {extra: extra} = node;
        extra && /_/.test(extra.raw) && (extra.raw = extra.raw.replace(/_/g, ""));
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxObjectRestSpread = (obj = __webpack_require__(91)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2), _pluginTransformParameters = __webpack_require__(150);
  const ZERO_REFS = (() => {
    const node = _core.types.identifier("a"), property = _core.types.objectProperty(_core.types.identifier("key"), node), pattern = _core.types.objectPattern([ property ]);
    return _core.types.isReferenced(node, property, pattern) ? 1 : 0;
  })();
  var _default = (0, _helperPluginUtils.declare)((api, opts) => {
    api.assertVersion(7);
    const {useBuiltIns: useBuiltIns = !1, loose: loose = !1} = opts;
    if ("boolean" != typeof loose) throw new Error(".loose must be a boolean, or undefined");
    function getExtendsHelper(file) {
      return useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
    }
    function hasRestElement(path) {
      let foundRestElement = !1;
      return visitRestElements(path, restElement => {
        foundRestElement = !0, restElement.stop();
      }), foundRestElement;
    }
    function hasObjectPatternRestElement(path) {
      let foundRestElement = !1;
      return visitRestElements(path, restElement => {
        restElement.parentPath.isObjectPattern() && (foundRestElement = !0, restElement.stop());
      }), foundRestElement;
    }
    function visitRestElements(path, visitor) {
      path.traverse({
        Expression(path) {
          const parentType = path.parent.type;
          ("AssignmentPattern" === parentType && "right" === path.key || "ObjectProperty" === parentType && path.parent.computed && "key" === path.key) && path.skip();
        },
        RestElement: visitor
      });
    }
    function replaceImpureComputedKeys(properties, scope) {
      const impureComputedPropertyDeclarators = [];
      for (const propPath of properties) {
        const key = propPath.get("key");
        if (propPath.node.computed && !key.isPure()) {
          const name = scope.generateUidBasedOnNode(key.node), declarator = _core.types.variableDeclarator(_core.types.identifier(name), key.node);
          impureComputedPropertyDeclarators.push(declarator), key.replaceWith(_core.types.identifier(name));
        }
      }
      return impureComputedPropertyDeclarators;
    }
    function createObjectSpread(path, file, objRef) {
      const props = path.get("properties"), last = props[props.length - 1];
      _core.types.assertRestElement(last.node);
      const restElement = _core.types.cloneNode(last.node);
      last.remove();
      const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope), {keys: keys, allLiteral: allLiteral} = function(path) {
        const props = path.node.properties, keys = [];
        let allLiteral = !0;
        for (const prop of props) _core.types.isIdentifier(prop.key) && !prop.computed ? keys.push(_core.types.stringLiteral(prop.key.name)) : _core.types.isTemplateLiteral(prop.key) ? keys.push(_core.types.cloneNode(prop.key)) : _core.types.isLiteral(prop.key) ? keys.push(_core.types.stringLiteral(String(prop.key.value))) : (keys.push(_core.types.cloneNode(prop.key)), 
        allLiteral = !1);
        return {
          keys: keys,
          allLiteral: allLiteral
        };
      }(path);
      if (0 === keys.length) return [ impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(getExtendsHelper(file), [ _core.types.objectExpression([]), _core.types.cloneNode(objRef) ]) ];
      let keyExpression;
      return keyExpression = allLiteral ? _core.types.arrayExpression(keys) : _core.types.callExpression(_core.types.memberExpression(_core.types.arrayExpression(keys), _core.types.identifier("map")), [ file.addHelper("toPropertyKey") ]), 
      [ impureComputedPropertyDeclarators, restElement.argument, _core.types.callExpression(file.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [ _core.types.cloneNode(objRef), keyExpression ]) ];
    }
    function replaceRestElement(parentPath, paramPath, container) {
      if (paramPath.isAssignmentPattern()) replaceRestElement(parentPath, paramPath.get("left"), container); else {
        if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
          const elements = paramPath.get("elements");
          for (let i = 0; i < elements.length; i++) replaceRestElement(parentPath, elements[i], container);
        }
        if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
          const uid = parentPath.scope.generateUidIdentifier("ref"), declar = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(paramPath.node, uid) ]);
          container ? container.push(declar) : (parentPath.ensureBlock(), parentPath.get("body").unshiftContainer("body", declar)), 
          paramPath.replaceWith(_core.types.cloneNode(uid));
        }
      }
    }
    return {
      name: "proposal-object-rest-spread",
      inherits: _pluginSyntaxObjectRestSpread.default,
      visitor: {
        Function(path) {
          const params = path.get("params"), paramsWithRestElement = new Set, idsInRestParams = new Set;
          for (let i = 0; i < params.length; ++i) {
            const param = params[i];
            if (hasRestElement(param)) {
              paramsWithRestElement.add(i);
              for (const name of Object.keys(param.getBindingIdentifiers())) idsInRestParams.add(name);
            }
          }
          let idInRest = !1;
          const IdentifierHandler = function(path, functionScope) {
            const name = path.node.name;
            path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name) && (idInRest = !0, 
            path.stop());
          };
          let i;
          for (i = 0; i < params.length && !idInRest; ++i) {
            const param = params[i];
            paramsWithRestElement.has(i) || (param.isReferencedIdentifier() || param.isBindingIdentifier() ? IdentifierHandler(path, path.scope) : param.traverse({
              "Scope|TypeAnnotation|TSTypeAnnotation": path => path.skip(),
              "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
            }, path.scope));
          }
          if (idInRest) {
            const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);
            (0, _pluginTransformParameters.convertFunctionParams)(path, loose, shouldTransformParam, replaceRestElement);
          } else for (let i = 0; i < params.length; ++i) {
            const param = params[i];
            paramsWithRestElement.has(i) && replaceRestElement(param.parentPath, param);
          }
        },
        VariableDeclarator(path, file) {
          if (!path.get("id").isObjectPattern()) return;
          let insertionPath = path;
          const originalPath = path;
          visitRestElements(path.get("id"), path => {
            if (!path.parentPath.isObjectPattern()) return;
            if (originalPath.node.id.properties.length > 1 && !_core.types.isIdentifier(originalPath.node.init)) {
              const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
              return originalPath.insertBefore(_core.types.variableDeclarator(initRef, originalPath.node.init)), 
              void originalPath.replaceWith(_core.types.variableDeclarator(originalPath.node.id, _core.types.cloneNode(initRef)));
            }
            let ref = originalPath.node.init;
            const refPropertyPath = [];
            let kind;
            path.findParent(path => {
              if (path.isObjectProperty()) refPropertyPath.unshift(path); else if (path.isVariableDeclarator()) return kind = path.parentPath.node.kind, 
              !0;
            });
            const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
            refPropertyPath.forEach(prop => {
              const {node: node} = prop;
              ref = _core.types.memberExpression(ref, _core.types.cloneNode(node.key), node.computed || _core.types.isLiteral(node.key));
            });
            const objectPatternPath = path.findParent(path => path.isObjectPattern()), [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(objectPatternPath, file, ref);
            loose && function(path) {
              const bindings = path.getOuterBindingIdentifierPaths();
              Object.keys(bindings).forEach(bindingName => {
                const bindingParentPath = bindings[bindingName].parentPath;
                path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty() || bindingParentPath.remove();
              });
            }(objectPatternPath), _core.types.assertIdentifier(argument), insertionPath.insertBefore(impureComputedPropertyDeclarators), 
            insertionPath.insertBefore(impureObjRefComputedDeclarators), insertionPath.insertAfter(_core.types.variableDeclarator(argument, callExpression)), 
            insertionPath = insertionPath.getSibling(insertionPath.key + 1), path.scope.registerBinding(kind, insertionPath), 
            0 === objectPatternPath.node.properties.length && objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();
          });
        },
        ExportNamedDeclaration(path) {
          const declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          if (!declaration.get("declarations").some(path => hasObjectPatternRestElement(path.get("id")))) return;
          const specifiers = [];
          for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));
          path.replaceWith(declaration.node), path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));
        },
        CatchClause(path) {
          const paramPath = path.get("param");
          replaceRestElement(paramPath.parentPath, paramPath);
        },
        AssignmentExpression(path, file) {
          const leftPath = path.get("left");
          if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
            const nodes = [], refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
            nodes.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(refName), path.node.right) ]));
            const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectSpread(leftPath, file, _core.types.identifier(refName));
            impureComputedPropertyDeclarators.length > 0 && nodes.push(_core.types.variableDeclaration("var", impureComputedPropertyDeclarators));
            const nodeWithoutSpread = _core.types.cloneNode(path.node);
            nodeWithoutSpread.right = _core.types.identifier(refName), nodes.push(_core.types.expressionStatement(nodeWithoutSpread)), 
            nodes.push(_core.types.toStatement(_core.types.assignmentExpression("=", argument, callExpression))), 
            nodes.push(_core.types.expressionStatement(_core.types.identifier(refName))), path.replaceWithMultiple(nodes);
          }
        },
        ForXStatement(path) {
          const {node: node, scope: scope} = path, leftPath = path.get("left"), left = node.left;
          if (hasObjectPatternRestElement(leftPath)) if (_core.types.isVariableDeclaration(left)) {
            const pattern = left.declarations[0].id, key = scope.generateUidIdentifier("ref");
            node.left = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(key, null) ]), 
            path.ensureBlock(), node.body.body.unshift(_core.types.variableDeclaration(node.left.kind, [ _core.types.variableDeclarator(pattern, _core.types.cloneNode(key)) ]));
          } else {
            const temp = scope.generateUidIdentifier("ref");
            node.left = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(temp) ]), 
            path.ensureBlock(), 0 === node.body.body.length && path.isCompletionRecord() && node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode())), 
            node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, _core.types.cloneNode(temp))));
          }
        },
        ArrayPattern(path) {
          const objectPatterns = [];
          if (visitRestElements(path, path => {
            if (!path.parentPath.isObjectPattern()) return;
            const objectPattern = path.parentPath, uid = path.scope.generateUidIdentifier("ref");
            objectPatterns.push(_core.types.variableDeclarator(objectPattern.node, uid)), objectPattern.replaceWith(_core.types.cloneNode(uid)), 
            path.skip();
          }), objectPatterns.length > 0) {
            const statementPath = path.getStatementParent();
            statementPath.insertAfter(_core.types.variableDeclaration(statementPath.node.kind || "var", objectPatterns));
          }
        },
        ObjectExpression(path, file) {
          if (!function(node) {
            for (const prop of node.properties) if (_core.types.isSpreadElement(prop)) return !0;
            return !1;
          }(path.node)) return;
          let helper;
          if (loose) helper = getExtendsHelper(file); else try {
            helper = file.addHelper("objectSpread2");
          } catch (_unused) {
            this.file.declarations.objectSpread2 = null, helper = file.addHelper("objectSpread");
          }
          let exp = null, props = [];
          function make() {
            const hadProps = props.length > 0, obj = _core.types.objectExpression(props);
            props = [], exp ? loose ? hadProps && exp.arguments.push(obj) : exp = _core.types.callExpression(_core.types.cloneNode(helper), [ exp, ...hadProps ? [ _core.types.objectExpression([]), obj ] : [] ]) : exp = _core.types.callExpression(helper, [ obj ]);
          }
          for (const prop of path.node.properties) _core.types.isSpreadElement(prop) ? (make(), 
          exp.arguments.push(prop.argument)) : props.push(prop);
          props.length && make(), path.replaceWith(exp);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, loose, shouldTransformParam, replaceRestElement) {
    const params = path.get("params");
    if (params.every(param => param.isIdentifier())) return !1;
    const {node: node, scope: scope} = path, state = {
      stop: !1,
      needsOuterBinding: !1,
      scope: scope
    }, body = [], shadowedParams = new Set;
    for (const param of params) for (const name of Object.keys(param.getBindingIdentifiers())) {
      var _scope$bindings$name;
      const constantViolations = null == (_scope$bindings$name = scope.bindings[name]) ? void 0 : _scope$bindings$name.constantViolations;
      if (constantViolations) for (const redeclarator of constantViolations) {
        const node = redeclarator.node;
        switch (node.type) {
         case "VariableDeclarator":
          if (null === node.init) {
            const declaration = redeclarator.parentPath;
            if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
              redeclarator.remove();
              break;
            }
          }
          shadowedParams.add(name);
          break;

         case "FunctionDeclaration":
          shadowedParams.add(name);
        }
      }
    }
    if (0 === shadowedParams.size) for (const param of params) if (param.isIdentifier() || param.traverse(iifeVisitor, state), 
    state.needsOuterBinding) break;
    let firstOptionalIndex = null;
    for (let i = 0; i < params.length; i++) {
      const param = params[i];
      if (shouldTransformParam && !shouldTransformParam(i)) continue;
      const transformedRestNodes = [];
      replaceRestElement && replaceRestElement(param.parentPath, param, transformedRestNodes);
      const paramIsAssignmentPattern = param.isAssignmentPattern();
      if (paramIsAssignmentPattern && (loose || "set" === node.kind)) {
        const left = param.get("left"), right = param.get("right"), undefinedNode = scope.buildUndefinedNode();
        if (left.isIdentifier()) body.push(buildLooseDefaultParam({
          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),
          DEFAULT_VALUE: right.node,
          UNDEFINED: undefinedNode
        })), param.replaceWith(left.node); else if (left.isObjectPattern() || left.isArrayPattern()) {
          const paramName = scope.generateUidIdentifier();
          body.push(buildLooseDestructuredDefaultParam({
            ASSIGNMENT_IDENTIFIER: left.node,
            DEFAULT_VALUE: right.node,
            PARAMETER_NAME: _core.types.cloneNode(paramName),
            UNDEFINED: undefinedNode
          })), param.replaceWith(paramName);
        }
      } else if (paramIsAssignmentPattern) {
        null === firstOptionalIndex && (firstOptionalIndex = i);
        const left = param.get("left"), right = param.get("right"), defNode = buildDefaultParam({
          VARIABLE_NAME: left.node,
          DEFAULT_VALUE: right.node,
          ARGUMENT_KEY: _core.types.numericLiteral(i)
        });
        body.push(defNode);
      } else if (null !== firstOptionalIndex) {
        const defNode = buildSafeArgumentsAccess([ param.node, _core.types.numericLiteral(i) ]);
        body.push(defNode);
      } else if (param.isObjectPattern() || param.isArrayPattern()) {
        const uid = path.scope.generateUidIdentifier("ref"), defNode = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(param.node, uid) ]);
        body.push(defNode), param.replaceWith(_core.types.cloneNode(uid));
      }
      if (transformedRestNodes) for (const transformedNode of transformedRestNodes) body.push(transformedNode);
    }
    null !== firstOptionalIndex && (node.params = node.params.slice(0, firstOptionalIndex));
    if (path.ensureBlock(), state.needsOuterBinding || shadowedParams.size > 0) {
      body.push(function(shadowedParams, body) {
        const args = [], params = [];
        for (const name of shadowedParams) args.push(_core.types.identifier(name)), params.push(_core.types.identifier(name));
        return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));
      }(shadowedParams, path.get("body").node)), path.set("body", _core.types.blockStatement(body));
      const bodyPath = path.get("body.body"), arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
      arrowPath.arrowFunctionToExpression(), arrowPath.node.generator = path.node.generator, 
      arrowPath.node.async = path.node.async, path.node.generator = !1;
    } else path.get("body").unshiftContainer("body", body);
    return !0;
  };
  var _core = __webpack_require__(2);
  const buildDefaultParam = (0, _core.template)("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n"), buildLooseDefaultParam = (0, 
  _core.template)("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n"), buildLooseDestructuredDefaultParam = (0, 
  _core.template)("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n"), buildSafeArgumentsAccess = (0, 
  _core.template)("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n"), iifeVisitor = {
    "ReferencedIdentifier|BindingIdentifier"(path, state) {
      const {scope: scope, node: node} = path, {name: name} = node;
      ("eval" === name || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) && (state.needsOuterBinding = !0, 
      path.stop());
    },
    "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": path => path.skip()
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path) {
    const {node: node, scope: scope} = path;
    if (!function(node) {
      const length = node.params.length;
      return length > 0 && _core.types.isRestElement(node.params[length - 1]);
    }(node)) return !1;
    let rest = node.params.pop().argument;
    const argsId = _core.types.identifier("arguments");
    if (_core.types.isPattern(rest)) {
      const pattern = rest;
      rest = scope.generateUidIdentifier("ref");
      const declar = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(pattern, rest) ]);
      node.body.body.unshift(declar);
    }
    const paramsCount = function(node) {
      let count = node.params.length;
      count > 0 && _core.types.isIdentifier(node.params[0], {
        name: "this"
      }) && (count -= 1);
      return count;
    }(node), state = {
      references: [],
      offset: paramsCount,
      argumentsNode: argsId,
      outerBinding: scope.getBindingIdentifier(rest.name),
      candidates: [],
      name: rest.name,
      deopted: !1
    };
    if (path.traverse(memberExpressionOptimisationVisitor, state), !state.deopted && !state.references.length) {
      for (const {path: path, cause: cause} of state.candidates) {
        const clonedArgsId = _core.types.cloneNode(argsId);
        switch (cause) {
         case "indexGetter":
          optimiseIndexGetter(path, clonedArgsId, state.offset);
          break;

         case "lengthGetter":
          optimiseLengthGetter(path, clonedArgsId, state.offset);
          break;

         default:
          path.replaceWith(clonedArgsId);
        }
      }
      return !0;
    }
    state.references = state.references.concat(state.candidates.map(({path: path}) => path));
    const start = _core.types.numericLiteral(paramsCount), key = scope.generateUidIdentifier("key"), len = scope.generateUidIdentifier("len");
    let arrKey, arrLen;
    paramsCount ? (arrKey = _core.types.binaryExpression("-", _core.types.cloneNode(key), _core.types.cloneNode(start)), 
    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(">", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression("-", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0))) : (arrKey = _core.types.identifier(key.name), 
    arrLen = _core.types.identifier(len.name));
    const loop = buildRest({
      ARGUMENTS: argsId,
      ARRAY_KEY: arrKey,
      ARRAY_LEN: arrLen,
      START: start,
      ARRAY: rest,
      KEY: key,
      LEN: len
    });
    if (state.deopted) node.body.body.unshift(loop); else {
      let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
      target.findParent(path => {
        if (!path.isLoop()) return path.isFunction();
        target = path;
      }), target.insertBefore(loop);
    }
    return !0;
  };
  var _core = __webpack_require__(2);
  const buildRest = (0, _core.template)("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n"), restIndex = (0, 
  _core.template)("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n"), restIndexImpure = (0, 
  _core.template)("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n"), restLength = (0, 
  _core.template)("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");
  function referencesRest(path, state) {
    return path.node.name === state.name && path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
  }
  const memberExpressionOptimisationVisitor = {
    Scope(path, state) {
      path.scope.bindingIdentifierEquals(state.name, state.outerBinding) || path.skip();
    },
    Flow(path) {
      path.isTypeCastExpression() || path.skip();
    },
    Function(path, state) {
      const oldNoOptimise = state.noOptimise;
      state.noOptimise = !0, path.traverse(memberExpressionOptimisationVisitor, state), 
      state.noOptimise = oldNoOptimise, path.skip();
    },
    ReferencedIdentifier(path, state) {
      const {node: node} = path;
      if ("arguments" === node.name && (state.deopted = !0), referencesRest(path, state)) if (state.noOptimise) state.deopted = !0; else {
        const {parentPath: parentPath} = path;
        if ("params" === parentPath.listKey && parentPath.key < state.offset) return;
        if (parentPath.isMemberExpression({
          object: node
        })) {
          const grandparentPath = parentPath.parentPath;
          if (!state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
            operator: "delete"
          }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee)) if (parentPath.node.computed) {
            if (parentPath.get("property").isBaseType("number")) return void state.candidates.push({
              cause: "indexGetter",
              path: path
            });
          } else if ("length" === parentPath.node.property.name) return void state.candidates.push({
            cause: "lengthGetter",
            path: path
          });
        }
        if (0 === state.offset && parentPath.isSpreadElement()) {
          const call = parentPath.parentPath;
          if (call.isCallExpression() && 1 === call.node.arguments.length) return void state.candidates.push({
            cause: "argSpread",
            path: path
          });
        }
        state.references.push(path);
      }
    },
    BindingIdentifier(path, state) {
      referencesRest(path, state) && (state.deopted = !0);
    }
  };
  function optimiseIndexGetter(path, argsId, offset) {
    const offsetLiteral = _core.types.numericLiteral(offset);
    let index;
    index = _core.types.isNumericLiteral(path.parent.property) ? _core.types.numericLiteral(path.parent.property.value + offset) : 0 === offset ? path.parent.property : _core.types.binaryExpression("+", path.parent.property, _core.types.cloneNode(offsetLiteral));
    const {scope: scope} = path;
    if (scope.isPure(index)) {
      const parentPath = path.parentPath;
      parentPath.replaceWith(restIndex({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index
      }));
      const valRes = parentPath.get("test").get("left").evaluate();
      valRes.confident && (!0 === valRes.value ? parentPath.replaceWith(parentPath.scope.buildUndefinedNode()) : parentPath.get("test").replaceWith(parentPath.get("test").get("right")));
    } else {
      const temp = scope.generateUidIdentifierBasedOnNode(index);
      scope.push({
        id: temp,
        kind: "var"
      }), path.parentPath.replaceWith(restIndexImpure({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index,
        REF: _core.types.cloneNode(temp)
      }));
    }
  }
  function optimiseLengthGetter(path, argsId, offset) {
    offset ? path.parentPath.replaceWith(restLength({
      ARGUMENTS: argsId,
      OFFSET: _core.types.numericLiteral(offset)
    })) : path.replaceWith(argsId);
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxOptionalCatchBinding = (obj = __webpack_require__(92)) && obj.__esModule ? obj : {
    default: obj
  };
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "proposal-optional-catch-binding",
    inherits: _pluginSyntaxOptionalCatchBinding.default,
    visitor: {
      CatchClause(path) {
        if (!path.node.param) {
          const uid = path.scope.generateUidIdentifier("unused");
          path.get("param").replaceWith(uid);
        }
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _pluginSyntaxOptionalChaining = (obj = __webpack_require__(93)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2);
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose = !1} = options;
    function isSimpleMemberExpression(expression) {
      return _core.types.isIdentifier(expression) || _core.types.isSuper(expression) || _core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
    }
    return {
      name: "proposal-optional-chaining",
      inherits: _pluginSyntaxOptionalChaining.default,
      visitor: {
        "OptionalCallExpression|OptionalMemberExpression"(path) {
          const {scope: scope} = path;
          let maybeParenthesized = path;
          const parentPath = path.findParent(p => {
            if (!p.isParenthesizedExpression()) return !0;
            maybeParenthesized = p;
          });
          let isDeleteOperation = !1;
          const parentIsCall = parentPath.isCallExpression({
            callee: maybeParenthesized.node
          }) && path.isOptionalMemberExpression(), optionals = [];
          let optionalPath = path;
          for (;optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression() || optionalPath.isParenthesizedExpression() || optionalPath.isTSNonNullExpression(); ) {
            const {node: node} = optionalPath;
            node.optional && optionals.push(node), optionalPath.isOptionalMemberExpression() ? (optionalPath.node.type = "MemberExpression", 
            optionalPath = optionalPath.get("object")) : optionalPath.isOptionalCallExpression() ? (optionalPath.node.type = "CallExpression", 
            optionalPath = optionalPath.get("callee")) : optionalPath = optionalPath.get("expression");
          }
          let replacementPath = path;
          parentPath.isUnaryExpression({
            operator: "delete"
          }) && (replacementPath = parentPath, isDeleteOperation = !0);
          for (let i = optionals.length - 1; i >= 0; i--) {
            const node = optionals[i], isCall = _core.types.isCallExpression(node), replaceKey = isCall ? "callee" : "object", chain = node[replaceKey];
            let ref, check;
            if (loose && isCall && isSimpleMemberExpression(chain) ? check = ref = chain : (ref = scope.maybeGenerateMemoised(chain), 
            ref ? (check = _core.types.assignmentExpression("=", _core.types.cloneNode(ref), chain), 
            node[replaceKey] = ref) : check = ref = chain), isCall && _core.types.isMemberExpression(chain)) if (loose && isSimpleMemberExpression(chain)) node.callee = chain; else {
              const {object: object} = chain;
              let context = scope.maybeGenerateMemoised(object);
              context ? chain.object = _core.types.assignmentExpression("=", context, object) : context = _core.types.isSuper(object) ? _core.types.thisExpression() : object, 
              node.arguments.unshift(_core.types.cloneNode(context)), node.callee = _core.types.memberExpression(node.callee, _core.types.identifier("call"));
            }
            let replacement = replacementPath.node;
            if (0 === i && parentIsCall) {
              var _baseRef;
              const {object: object} = replacement;
              let baseRef;
              loose && isSimpleMemberExpression(object) || (baseRef = scope.maybeGenerateMemoised(object), 
              baseRef && (replacement.object = _core.types.assignmentExpression("=", baseRef, object))), 
              replacement = _core.types.callExpression(_core.types.memberExpression(replacement, _core.types.identifier("bind")), [ _core.types.cloneNode(null != (_baseRef = baseRef) ? _baseRef : object) ]);
            }
            replacementPath.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression("==", _core.types.cloneNode(check), _core.types.nullLiteral()) : _core.types.logicalExpression("||", _core.types.binaryExpression("===", _core.types.cloneNode(check), _core.types.nullLiteral()), _core.types.binaryExpression("===", _core.types.cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? _core.types.booleanLiteral(!0) : scope.buildUndefinedNode(), replacement)), 
            replacementPath = replacementPath.get("alternate");
          }
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _helperCreateClassFeaturesPlugin = __webpack_require__(132), _default = (0, 
  _helperPluginUtils.declare)((api, options) => (api.assertVersion(7), (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
    name: "proposal-private-methods",
    feature: _helperCreateClassFeaturesPlugin.FEATURES.privateMethods,
    loose: options.loose,
    manipulateOptions(opts, parserOpts) {
      parserOpts.plugins.push("classPrivateMethods");
    }
  })));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperCreateRegexpFeaturesPlugin = __webpack_require__(45), _default = (0, 
  __webpack_require__(0).declare)((api, options) => {
    api.assertVersion(7);
    const {useUnicodeFlag: useUnicodeFlag = !0} = options;
    if ("boolean" != typeof useUnicodeFlag) throw new Error(".useUnicodeFlag must be a boolean, or undefined");
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
      name: "proposal-unicode-property-regex",
      feature: "unicodePropertyEscape",
      options: {
        useUnicodeFlag: useUnicodeFlag
      }
    });
  });
  exports.default = _default;
}, function(module, exports) {
  module.exports = require("regexpu-core");
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.generateRegexpuOptions = function(node, features) {
    let useUnicodeFlag = !1, dotAllFlag = !1, unicodePropertyEscape = !1, namedGroup = !1;
    const {flags: flags, pattern: pattern} = node, flagsIncludesU = flags.includes("u");
    flagsIncludesU && ((0, _features.hasFeature)(features, _features.FEATURES.unicodeFlag) || (useUnicodeFlag = !0), 
    (0, _features.hasFeature)(features, _features.FEATURES.unicodePropertyEscape) && /\\[pP]{/.test(pattern) && (unicodePropertyEscape = !0));
    (0, _features.hasFeature)(features, _features.FEATURES.dotAllFlag) && flags.indexOf("s") >= 0 && (dotAllFlag = !0);
    (0, _features.hasFeature)(features, _features.FEATURES.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern) && (namedGroup = !0);
    if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) return null;
    flagsIncludesU && flags.indexOf("s") >= 0 && (dotAllFlag = !0);
    return {
      useUnicodeFlag: useUnicodeFlag,
      onNamedGroup: () => {},
      namedGroup: namedGroup,
      unicodePropertyEscape: unicodePropertyEscape,
      dotAllFlag: dotAllFlag,
      lookbehind: !0
    };
  };
  var _features = __webpack_require__(151);
}, function(module) {
  module.exports = JSON.parse('{"name":"@babel/helper-create-regexp-features-plugin","version":"7.10.4"}');
}, function(module, exports, __webpack_require__) {
  var pull = __webpack_require__(138)(__webpack_require__(385));
  module.exports = pull;
}, function(module, exports, __webpack_require__) {
  var basePullAll = __webpack_require__(386);
  module.exports = function(array, values) {
    return array && array.length && values && values.length ? basePullAll(array, values) : array;
  };
}, function(module, exports, __webpack_require__) {
  var arrayMap = __webpack_require__(153), baseIndexOf = __webpack_require__(387), baseIndexOfWith = __webpack_require__(391), baseUnary = __webpack_require__(25), copyArray = __webpack_require__(108), splice = Array.prototype.splice;
  module.exports = function(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
    for (array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length; ) for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1; ) seen !== array && splice.call(seen, fromIndex, 1), 
    splice.call(array, fromIndex, 1);
    return array;
  };
}, function(module, exports, __webpack_require__) {
  var baseFindIndex = __webpack_require__(388), baseIsNaN = __webpack_require__(389), strictIndexOf = __webpack_require__(390);
  module.exports = function(array, value, fromIndex) {
    return value == value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  };
}, function(module, exports) {
  module.exports = function(array, predicate, fromIndex, fromRight) {
    for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; ) if (predicate(array[index], index, array)) return index;
    return -1;
  };
}, function(module, exports) {
  module.exports = function(value) {
    return value != value;
  };
}, function(module, exports) {
  module.exports = function(array, value, fromIndex) {
    for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (array[index] === value) return index;
    return -1;
  };
}, function(module, exports) {
  module.exports = function(array, value, fromIndex, comparator) {
    for (var index = fromIndex - 1, length = array.length; ++index < length; ) if (comparator(array[index], value)) return index;
    return -1;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _helperRemapAsyncToGenerator = (obj = __webpack_require__(94)) && obj.__esModule ? obj : {
    default: obj
  }, _helperModuleImports = __webpack_require__(74), _core = __webpack_require__(2);
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {method: method, module: module} = options;
    return method && module ? {
      name: "transform-async-to-generator",
      visitor: {
        Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          let wrapAsync = state.methodWrapper;
          wrapAsync = wrapAsync ? _core.types.cloneNode(wrapAsync) : state.methodWrapper = (0, 
          _helperModuleImports.addNamed)(path, method, module), (0, _helperRemapAsyncToGenerator.default)(path, {
            wrapAsync: wrapAsync
          });
        }
      }
    } : {
      name: "transform-async-to-generator",
      visitor: {
        Function(path, state) {
          path.node.async && !path.node.generator && (0, _helperRemapAsyncToGenerator.default)(path, {
            wrapAsync: state.addHelper("asyncToGenerator")
          });
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _assert = _interopRequireDefault(__webpack_require__(11)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _importBuilder = _interopRequireDefault(__webpack_require__(394)), _isModule = _interopRequireDefault(__webpack_require__(154));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  exports.default = class {
    constructor(path, importedSource, opts) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: !1,
        ensureNoContext: !1
      };
      const programPath = path.find(p => p.isProgram());
      this._programPath = programPath, this._programScope = programPath.scope, this._hub = programPath.hub, 
      this._defaultOpts = this._applyDefaults(importedSource, opts, !0);
    }
    addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    }
    addNamed(importName, importedSourceIn, opts) {
      return (0, _assert.default)("string" == typeof importName), this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    }
    addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    }
    addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), !1);
    }
    _applyDefaults(importedSource, opts, isInit = !1) {
      const optsList = [];
      "string" == typeof importedSource ? (optsList.push({
        importedSource: importedSource
      }), optsList.push(opts)) : ((0, _assert.default)(!opts, "Unexpected secondary arguments."), 
      optsList.push(importedSource));
      const newOpts = Object.assign({}, this._defaultOpts);
      for (const opts of optsList) opts && (Object.keys(newOpts).forEach(key => {
        void 0 !== opts[key] && (newOpts[key] = opts[key]);
      }), isInit || (void 0 !== opts.nameHint && (newOpts.nameHint = opts.nameHint), void 0 !== opts.blockHoist && (newOpts.blockHoist = opts.blockHoist)));
      return newOpts;
    }
    _generateImport(opts, importName) {
      const isDefault = "default" === importName, isNamed = !!importName && !isDefault, isNamespace = null === importName, {importedSource: importedSource, importedType: importedType, importedInterop: importedInterop, importingInterop: importingInterop, ensureLiveReference: ensureLiveReference, ensureNoContext: ensureNoContext, nameHint: nameHint, blockHoist: blockHoist} = opts;
      let name = nameHint || importName;
      const isMod = (0, _isModule.default)(this._programPath), isModuleForNode = isMod && "node" === importingInterop, isModuleForBabel = isMod && "babel" === importingInterop, builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
      if ("es6" === importedType) {
        if (!isModuleForNode && !isModuleForBabel) throw new Error("Cannot import an ES6 module from CommonJS");
        builder.import(), isNamespace ? builder.namespace(nameHint || importedSource) : (isDefault || isNamed) && builder.named(name, importName);
      } else {
        if ("commonjs" !== importedType) throw new Error(`Unexpected interopType "${importedType}"`);
        if ("babel" === importedInterop) if (isModuleForNode) {
          name = "default" !== name ? name : importedSource;
          const es6Default = importedSource + "$es6Default";
          builder.import(), isNamespace ? builder.default(es6Default).var(name || importedSource).wildcardInterop() : isDefault ? ensureLiveReference ? builder.default(es6Default).var(name || importedSource).defaultInterop().read("default") : builder.default(es6Default).var(name).defaultInterop().prop(importName) : isNamed && builder.default(es6Default).read(importName);
        } else isModuleForBabel ? (builder.import(), isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), 
        isNamespace ? builder.var(name || importedSource).wildcardInterop() : (isDefault || isNamed) && ensureLiveReference ? isDefault ? (name = "default" !== name ? name : importedSource, 
        builder.var(name).read(importName), builder.defaultInterop()) : builder.var(importedSource).read(importName) : isDefault ? builder.var(name).defaultInterop().prop(importName) : isNamed && builder.var(name).prop(importName)); else if ("compiled" === importedInterop) isModuleForNode ? (builder.import(), 
        isNamespace ? builder.default(name || importedSource) : (isDefault || isNamed) && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), 
        isNamespace ? builder.namespace(name || importedSource) : (isDefault || isNamed) && builder.named(name, importName)) : (builder.require(), 
        isNamespace ? builder.var(name || importedSource) : (isDefault || isNamed) && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.prop(importName).var(name))); else {
          if ("uncompiled" !== importedInterop) throw new Error(`Unknown importedInterop "${importedInterop}".`);
          if (isDefault && ensureLiveReference) throw new Error("No live reference for commonjs default");
          isModuleForNode ? (builder.import(), isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.default(importedSource).read(name)) : isModuleForBabel ? (builder.import(), 
          isNamespace ? builder.default(name || importedSource) : isDefault ? builder.default(name) : isNamed && builder.named(name, importName)) : (builder.require(), 
          isNamespace ? builder.var(name || importedSource) : isDefault ? builder.var(name) : isNamed && (ensureLiveReference ? builder.var(importedSource).read(name) : builder.var(name).prop(importName)));
        }
      }
      const {statements: statements, resultName: resultName} = builder.done();
      return this._insertStatements(statements, blockHoist), (isDefault || isNamed) && ensureNoContext && "Identifier" !== resultName.type ? t.sequenceExpression([ t.numericLiteral(0), resultName ]) : resultName;
    }
    _insertStatements(statements, blockHoist = 3) {
      statements.forEach(node => {
        node._blockHoist = blockHoist;
      });
      const targetPath = this._programPath.get("body").find(p => {
        const val = p.node._blockHoist;
        return Number.isFinite(val) && val < 4;
      });
      targetPath ? targetPath.insertBefore(statements) : this._programPath.unshiftContainer("body", statements);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _assert = (obj = __webpack_require__(11)) && obj.__esModule ? obj : {
    default: obj
  }, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  exports.default = class {
    constructor(importedSource, scope, hub) {
      this._statements = [], this._resultName = null, this._scope = null, this._hub = null, 
      this._scope = scope, this._hub = hub, this._importedSource = importedSource;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(t.importDeclaration([], t.stringLiteral(this._importedSource))), 
      this;
    }
    require() {
      return this._statements.push(t.expressionStatement(t.callExpression(t.identifier("require"), [ t.stringLiteral(this._importedSource) ]))), 
      this;
    }
    namespace(name = "namespace") {
      name = this._scope.generateUidIdentifier(name);
      const statement = this._statements[this._statements.length - 1];
      return (0, _assert.default)("ImportDeclaration" === statement.type), (0, _assert.default)(0 === statement.specifiers.length), 
      statement.specifiers = [ t.importNamespaceSpecifier(name) ], this._resultName = t.cloneNode(name), 
      this;
    }
    default(name) {
      name = this._scope.generateUidIdentifier(name);
      const statement = this._statements[this._statements.length - 1];
      return (0, _assert.default)("ImportDeclaration" === statement.type), (0, _assert.default)(0 === statement.specifiers.length), 
      statement.specifiers = [ t.importDefaultSpecifier(name) ], this._resultName = t.cloneNode(name), 
      this;
    }
    named(name, importName) {
      if ("default" === importName) return this.default(name);
      name = this._scope.generateUidIdentifier(name);
      const statement = this._statements[this._statements.length - 1];
      return (0, _assert.default)("ImportDeclaration" === statement.type), (0, _assert.default)(0 === statement.specifiers.length), 
      statement.specifiers = [ t.importSpecifier(name, t.identifier(importName)) ], this._resultName = t.cloneNode(name), 
      this;
    }
    var(name) {
      name = this._scope.generateUidIdentifier(name);
      let statement = this._statements[this._statements.length - 1];
      return "ExpressionStatement" !== statement.type && ((0, _assert.default)(this._resultName), 
      statement = t.expressionStatement(this._resultName), this._statements.push(statement)), 
      this._statements[this._statements.length - 1] = t.variableDeclaration("var", [ t.variableDeclarator(name, statement.expression) ]), 
      this._resultName = t.cloneNode(name), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(callee) {
      const statement = this._statements[this._statements.length - 1];
      return "ExpressionStatement" === statement.type ? statement.expression = t.callExpression(callee, [ statement.expression ]) : "VariableDeclaration" === statement.type ? ((0, 
      _assert.default)(1 === statement.declarations.length), statement.declarations[0].init = t.callExpression(callee, [ statement.declarations[0].init ])) : _assert.default.fail("Unexpected type."), 
      this;
    }
    prop(name) {
      const statement = this._statements[this._statements.length - 1];
      return "ExpressionStatement" === statement.type ? statement.expression = t.memberExpression(statement.expression, t.identifier(name)) : "VariableDeclaration" === statement.type ? ((0, 
      _assert.default)(1 === statement.declarations.length), statement.declarations[0].init = t.memberExpression(statement.declarations[0].init, t.identifier(name))) : _assert.default.fail("Unexpected type:" + statement.type), 
      this;
    }
    read(name) {
      this._resultName = t.memberExpression(this._resultName, t.identifier(name));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)((api, options) => {
    api.assertVersion(7);
    const {spec: spec} = options;
    return {
      name: "transform-arrow-functions",
      visitor: {
        ArrowFunctionExpression(path) {
          path.isArrowFunctionExpression() && path.arrowFunctionToExpression({
            allowInsertArrow: !1,
            specCompliant: !!spec
          });
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => {
    function statementList(key, path) {
      const paths = path.get(key);
      for (const path of paths) {
        const func = path.node;
        if (!path.isFunctionDeclaration()) continue;
        const declar = _core.types.variableDeclaration("let", [ _core.types.variableDeclarator(func.id, _core.types.toExpression(func)) ]);
        declar._blockHoist = 2, func.id = null, path.replaceWith(declar);
      }
    }
    return api.assertVersion(7), {
      name: "transform-block-scoped-functions",
      visitor: {
        BlockStatement(path) {
          const {node: node, parent: parent} = path;
          _core.types.isFunction(parent, {
            body: node
          }) || _core.types.isExportDeclaration(parent) || statementList("body", path);
        },
        SwitchCase(path) {
          statementList("consequent", path);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _tdz = __webpack_require__(398), _core = __webpack_require__(2);
  const DONE = new WeakSet;
  var _default = (0, _helperPluginUtils.declare)((api, opts) => {
    api.assertVersion(7);
    const {throwIfClosureRequired: throwIfClosureRequired = !1, tdz: tdzEnabled = !1} = opts;
    if ("boolean" != typeof throwIfClosureRequired) throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
    if ("boolean" != typeof tdzEnabled) throw new Error(".tdz must be a boolean, or undefined");
    return {
      name: "transform-block-scoping",
      visitor: {
        VariableDeclaration(path) {
          const {node: node, parent: parent, scope: scope} = path;
          if (isBlockScoped(node) && (convertBlockScopedToVar(path, null, parent, scope, !0), 
          node._tdzThis)) {
            const nodes = [ node ];
            for (let i = 0; i < node.declarations.length; i++) {
              const decl = node.declarations[i], assign = _core.types.assignmentExpression("=", _core.types.cloneNode(decl.id), decl.init || scope.buildUndefinedNode());
              assign._ignoreBlockScopingTDZ = !0, nodes.push(_core.types.expressionStatement(assign)), 
              decl.init = this.addHelper("temporalUndefined");
            }
            node._blockHoist = 2, path.isCompletionRecord() && nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode())), 
            path.replaceWithMultiple(nodes);
          }
        },
        Loop(path, state) {
          const {parent: parent, scope: scope} = path;
          path.ensureBlock();
          const replace = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state).run();
          replace && path.replaceWith(replace);
        },
        CatchClause(path, state) {
          const {parent: parent, scope: scope} = path;
          new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state).run();
        },
        "BlockStatement|SwitchStatement|Program"(path, state) {
          if (!function(path) {
            return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);
          }(path)) {
            new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state).run();
          }
        }
      }
    };
  });
  exports.default = _default;
  const buildRetCheck = (0, _core.template)('\n  if (typeof RETURN === "object") return RETURN.v;\n');
  function isBlockScoped(node) {
    return !!_core.types.isVariableDeclaration(node) && (!!node[_core.types.BLOCK_SCOPED_SYMBOL] || ("let" === node.kind || "const" === node.kind));
  }
  function isInLoop(path) {
    const loopOrFunctionParent = path.find(path => path.isLoop() || path.isFunction());
    return null == loopOrFunctionParent ? void 0 : loopOrFunctionParent.isLoop();
  }
  function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent = !1) {
    if (node || (node = path.node), isInLoop(path) && !_core.types.isFor(parent)) for (let i = 0; i < node.declarations.length; i++) {
      const declar = node.declarations[i];
      declar.init = declar.init || scope.buildUndefinedNode();
    }
    if (node[_core.types.BLOCK_SCOPED_SYMBOL] = !0, node.kind = "var", moveBindingsToParent) {
      const parentScope = scope.getFunctionParent() || scope.getProgramParent();
      for (const name of Object.keys(path.getBindingIdentifiers())) {
        const binding = scope.getOwnBinding(name);
        binding && (binding.kind = "var"), scope.moveBindingTo(name, parentScope);
      }
    }
  }
  function isVar(node) {
    return _core.types.isVariableDeclaration(node, {
      kind: "var"
    }) && !isBlockScoped(node);
  }
  const letReferenceBlockVisitor = _core.traverse.visitors.merge([ {
    Loop: {
      enter(path, state) {
        state.loopDepth++;
      },
      exit(path, state) {
        state.loopDepth--;
      }
    },
    Function: (path, state) => (state.loopDepth > 0 ? path.traverse(letReferenceFunctionVisitor, state) : path.traverse(_tdz.visitor, state), 
    path.skip())
  }, _tdz.visitor ]), letReferenceFunctionVisitor = _core.traverse.visitors.merge([ {
    ReferencedIdentifier(path, state) {
      const ref = state.letReferences.get(path.node.name);
      if (!ref) return;
      const localBinding = path.scope.getBindingIdentifier(path.node.name);
      localBinding && localBinding !== ref || (state.closurify = !0);
    }
  }, _tdz.visitor ]), hoistVarDeclarationsVisitor = {
    enter(path, self) {
      const {node: node, parent: parent} = path;
      if (path.isForStatement()) {
        if (isVar(node.init)) {
          const nodes = self.pushDeclar(node.init);
          1 === nodes.length ? node.init = nodes[0] : node.init = _core.types.sequenceExpression(nodes);
        }
      } else if (path.isFor()) isVar(node.left) && (self.pushDeclar(node.left), node.left = node.left.declarations[0].id); else if (isVar(node)) path.replaceWithMultiple(self.pushDeclar(node).map(expr => _core.types.expressionStatement(expr))); else if (path.isFunction()) return path.skip();
    }
  }, loopLabelVisitor = {
    LabeledStatement({node: node}, state) {
      state.innerLabels.push(node.label.name);
    }
  }, continuationVisitor = {
    enter(path, state) {
      if (path.isAssignmentExpression() || path.isUpdateExpression()) for (const name of Object.keys(path.getBindingIdentifiers())) state.outsideReferences.get(name) === path.scope.getBindingIdentifier(name) && (state.reassignments[name] = !0); else path.isReturnStatement() && state.returnStatements.push(path);
    }
  };
  const loopVisitor = {
    Loop(path, state) {
      const oldIgnoreLabeless = state.ignoreLabeless;
      state.ignoreLabeless = !0, path.traverse(loopVisitor, state), state.ignoreLabeless = oldIgnoreLabeless, 
      path.skip();
    },
    Function(path) {
      path.skip();
    },
    SwitchCase(path, state) {
      const oldInSwitchCase = state.inSwitchCase;
      state.inSwitchCase = !0, path.traverse(loopVisitor, state), state.inSwitchCase = oldInSwitchCase, 
      path.skip();
    },
    "BreakStatement|ContinueStatement|ReturnStatement"(path, state) {
      const {node: node, scope: scope} = path;
      if (node[this.LOOP_IGNORE]) return;
      let replace, loopText = function(node) {
        return _core.types.isBreakStatement(node) ? "break" : _core.types.isContinueStatement(node) ? "continue" : void 0;
      }(node);
      if (loopText) {
        if (node.label) {
          if (state.innerLabels.indexOf(node.label.name) >= 0) return;
          loopText = `${loopText}|${node.label.name}`;
        } else {
          if (state.ignoreLabeless) return;
          if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;
        }
        state.hasBreakContinue = !0, state.map[loopText] = node, replace = _core.types.stringLiteral(loopText);
      }
      path.isReturnStatement() && (state.hasReturn = !0, replace = _core.types.objectExpression([ _core.types.objectProperty(_core.types.identifier("v"), node.argument || scope.buildUndefinedNode()) ])), 
      replace && (replace = _core.types.returnStatement(replace), replace[this.LOOP_IGNORE] = !0, 
      path.skip(), path.replaceWith(_core.types.inherits(replace, node)));
    }
  };
  class BlockScoping {
    constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
      this.parent = parent, this.scope = scope, this.state = state, this.throwIfClosureRequired = throwIfClosureRequired, 
      this.tdzEnabled = tdzEnabled, this.blockPath = blockPath, this.block = blockPath.node, 
      this.outsideLetReferences = new Map, this.hasLetReferences = !1, this.letReferences = new Map, 
      this.body = [], loopPath && (this.loopParent = loopPath.parent, this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label, 
      this.loopPath = loopPath, this.loop = loopPath.node);
    }
    run() {
      const block = this.block;
      if (DONE.has(block)) return;
      DONE.add(block);
      const needsClosure = this.getLetReferences();
      if (this.checkConstants(), _core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) this.updateScopeInfo(); else if (this.hasLetReferences) return needsClosure ? this.wrapClosure() : this.remap(), 
      this.updateScopeInfo(needsClosure), this.loopLabel && !_core.types.isLabeledStatement(this.loopParent) ? _core.types.labeledStatement(this.loopLabel, this.loop) : void 0;
    }
    checkConstants() {
      const scope = this.scope, state = this.state;
      for (const name of Object.keys(scope.bindings)) {
        const binding = scope.bindings[name];
        if ("const" === binding.kind) for (const violation of binding.constantViolations) {
          const readOnlyError = state.addHelper("readOnlyError"), throwNode = _core.types.callExpression(readOnlyError, [ _core.types.stringLiteral(name) ]);
          violation.isAssignmentExpression() ? violation.get("right").replaceWith(_core.types.sequenceExpression([ throwNode, violation.get("right").node ])) : violation.isUpdateExpression() ? violation.replaceWith(_core.types.sequenceExpression([ throwNode, violation.node ])) : violation.isForXStatement() && (violation.ensureBlock(), 
          violation.node.body.body.unshift(_core.types.expressionStatement(throwNode)));
        }
      }
    }
    updateScopeInfo(wrappedInClosure) {
      const blockScope = this.blockPath.scope, parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent(), letRefs = this.letReferences;
      for (const key of letRefs.keys()) {
        const ref = letRefs.get(key), binding = blockScope.getBinding(ref.name);
        binding && ("let" !== binding.kind && "const" !== binding.kind || (binding.kind = "var", 
        wrappedInClosure ? blockScope.hasOwnBinding(ref.name) && blockScope.removeBinding(ref.name) : blockScope.moveBindingTo(ref.name, parentScope)));
      }
    }
    remap() {
      const letRefs = this.letReferences, outsideLetRefs = this.outsideLetReferences, scope = this.scope, blockPathScope = this.blockPath.scope;
      for (const key of letRefs.keys()) {
        const ref = letRefs.get(key);
        (scope.parentHasBinding(key) || scope.hasGlobal(key)) && (scope.hasOwnBinding(key) && scope.rename(ref.name), 
        blockPathScope.hasOwnBinding(key) && blockPathScope.rename(ref.name));
      }
      for (const key of outsideLetRefs.keys()) {
        const ref = letRefs.get(key);
        isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key) && blockPathScope.rename(ref.name);
      }
    }
    wrapClosure() {
      if (this.throwIfClosureRequired) throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure (throwIfClosureRequired).");
      const block = this.block, outsideRefs = this.outsideLetReferences;
      if (this.loop) for (const name of [ ...outsideRefs.keys() ]) {
        const id = outsideRefs.get(name);
        (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) && (outsideRefs.delete(id.name), 
        this.letReferences.delete(id.name), this.scope.rename(id.name), this.letReferences.set(id.name, id), 
        outsideRefs.set(id.name, id));
      }
      this.has = this.checkLoop(), this.hoistVarDeclarations();
      const args = Array.from(outsideRefs.values(), node => _core.types.cloneNode(node)), params = args.map(id => _core.types.cloneNode(id)), isSwitch = this.blockPath.isSwitchStatement(), fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [ block ] : block.body));
      this.addContinuations(fn);
      let call = _core.types.callExpression(_core.types.nullLiteral(), args), basePath = ".callee";
      _core.traverse.hasType(fn.body, "YieldExpression", _core.types.FUNCTION_TYPES) && (fn.generator = !0, 
      call = _core.types.yieldExpression(call, !0), basePath = ".argument" + basePath);
      let placeholderPath, index, callPath;
      if (_core.traverse.hasType(fn.body, "AwaitExpression", _core.types.FUNCTION_TYPES) && (fn.async = !0, 
      call = _core.types.awaitExpression(call), basePath = ".argument" + basePath), this.has.hasReturn || this.has.hasBreakContinue) {
        const ret = this.scope.generateUid("ret");
        this.body.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(ret), call) ])), 
        placeholderPath = "declarations.0.init" + basePath, index = this.body.length - 1, 
        this.buildHas(ret);
      } else this.body.push(_core.types.expressionStatement(call)), placeholderPath = "expression" + basePath, 
      index = this.body.length - 1;
      if (isSwitch) {
        const {parentPath: parentPath, listKey: listKey, key: key} = this.blockPath;
        this.blockPath.replaceWithMultiple(this.body), callPath = parentPath.get(listKey)[key + index];
      } else block.body = this.body, callPath = this.blockPath.get("body")[index];
      const placeholder = callPath.get(placeholderPath);
      let fnPath;
      if (this.loop) {
        const loopId = this.scope.generateUid("loop"), p = this.loopPath.insertBefore(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(loopId), fn) ]));
        placeholder.replaceWith(_core.types.identifier(loopId)), fnPath = p[0].get("declarations.0.init");
      } else placeholder.replaceWith(fn), fnPath = placeholder;
      fnPath.unwrapFunctionEnvironment();
    }
    addContinuations(fn) {
      const state = {
        reassignments: {},
        returnStatements: [],
        outsideReferences: this.outsideLetReferences
      };
      this.scope.traverse(fn, continuationVisitor, state);
      for (let i = 0; i < fn.params.length; i++) {
        const param = fn.params[i];
        if (!state.reassignments[param.name]) continue;
        const paramName = param.name, newParamName = this.scope.generateUid(param.name);
        fn.params[i] = _core.types.identifier(newParamName), this.scope.rename(paramName, newParamName, fn), 
        state.returnStatements.forEach(returnStatement => {
          returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(paramName), _core.types.identifier(newParamName))));
        }), fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(paramName), _core.types.identifier(newParamName))));
      }
    }
    getLetReferences() {
      const block = this.block;
      let declarators = [];
      if (this.loop) {
        const init = this.loop.left || this.loop.init;
        if (isBlockScoped(init)) {
          declarators.push(init);
          const names = _core.types.getBindingIdentifiers(init);
          for (const name of Object.keys(names)) this.outsideLetReferences.set(name, names[name]);
        }
      }
      const addDeclarationsFromChild = (path, node) => {
        node = node || path.node, (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) && (isBlockScoped(node) && convertBlockScopedToVar(path, node, block, this.scope), 
        declarators = declarators.concat(node.declarations || node)), _core.types.isLabeledStatement(node) && addDeclarationsFromChild(path.get("body"), node.body);
      };
      if (block.body) {
        const declarPaths = this.blockPath.get("body");
        for (let i = 0; i < block.body.length; i++) addDeclarationsFromChild(declarPaths[i]);
      }
      if (block.cases) {
        const declarPaths = this.blockPath.get("cases");
        for (let i = 0; i < block.cases.length; i++) {
          const consequents = block.cases[i].consequent;
          for (let j = 0; j < consequents.length; j++) {
            const declar = consequents[j];
            addDeclarationsFromChild(declarPaths[i], declar);
          }
        }
      }
      for (let i = 0; i < declarators.length; i++) {
        const declar = declarators[i], keys = _core.types.getBindingIdentifiers(declar, !1, !0);
        for (const key of Object.keys(keys)) this.letReferences.set(key, keys[key]);
        this.hasLetReferences = !0;
      }
      if (!this.hasLetReferences) return;
      const state = {
        letReferences: this.letReferences,
        closurify: !1,
        loopDepth: 0,
        tdzEnabled: this.tdzEnabled,
        addHelper: name => this.state.addHelper(name)
      };
      return isInLoop(this.blockPath) && state.loopDepth++, this.blockPath.traverse(letReferenceBlockVisitor, state), 
      state.closurify;
    }
    checkLoop() {
      const state = {
        hasBreakContinue: !1,
        ignoreLabeless: !1,
        inSwitchCase: !1,
        innerLabels: [],
        hasReturn: !1,
        isLoop: !!this.loop,
        map: {},
        LOOP_IGNORE: Symbol()
      };
      return this.blockPath.traverse(loopLabelVisitor, state), this.blockPath.traverse(loopVisitor, state), 
      state;
    }
    hoistVarDeclarations() {
      this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
    }
    pushDeclar(node) {
      const declars = [], names = _core.types.getBindingIdentifiers(node);
      for (const name of Object.keys(names)) declars.push(_core.types.variableDeclarator(names[name]));
      this.body.push(_core.types.variableDeclaration(node.kind, declars));
      const replace = [];
      for (let i = 0; i < node.declarations.length; i++) {
        const declar = node.declarations[i];
        if (!declar.init) continue;
        const expr = _core.types.assignmentExpression("=", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));
        replace.push(_core.types.inherits(expr, declar));
      }
      return replace;
    }
    buildHas(ret) {
      const body = this.body, has = this.has;
      if (has.hasBreakContinue) for (const key of Object.keys(has.map)) body.push(_core.types.ifStatement(_core.types.binaryExpression("===", _core.types.identifier(ret), _core.types.stringLiteral(key)), has.map[key]));
      has.hasReturn && body.push(buildRetCheck({
        RETURN: _core.types.identifier(ret)
      }));
    }
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.visitor = void 0;
  var _core = __webpack_require__(2);
  function isReference(node, scope, state) {
    const declared = state.letReferences.get(node.name);
    return !!declared && scope.getBindingIdentifier(node.name) === declared;
  }
  const visitor = {
    ReferencedIdentifier(path, state) {
      if (!state.tdzEnabled) return;
      const {node: node, parent: parent, scope: scope} = path;
      if (path.parentPath.isFor({
        left: node
      })) return;
      if (!isReference(node, scope, state)) return;
      const bindingPath = scope.getBinding(node.name).path;
      if (bindingPath.isFunctionDeclaration()) return;
      const status = function(refPath, bindingPath) {
        const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
        return "before" === executionStatus ? "outside" : "after" === executionStatus ? "inside" : "maybe";
      }(path, bindingPath);
      if ("outside" !== status) if ("maybe" === status) {
        const assert = function(node, state) {
          return _core.types.callExpression(state.addHelper("temporalRef"), [ node, _core.types.stringLiteral(node.name) ]);
        }(node, state);
        if (bindingPath.parent._tdzThis = !0, path.skip(), path.parentPath.isUpdateExpression()) {
          if (parent._ignoreBlockScopingTDZ) return;
          path.parentPath.replaceWith(_core.types.sequenceExpression([ assert, parent ]));
        } else path.replaceWith(assert);
      } else "inside" === status && path.replaceWith(_core.template.ast`${state.addHelper("tdz")}("${node.name}")`);
    },
    AssignmentExpression: {
      exit(path, state) {
        if (!state.tdzEnabled) return;
        const {node: node} = path;
        if (node._ignoreBlockScopingTDZ) return;
        const nodes = [], ids = path.getBindingIdentifiers();
        for (const name of Object.keys(ids)) {
          const id = ids[name];
          isReference(id, path.scope, state) && nodes.push(id);
        }
        nodes.length && (node._ignoreBlockScopingTDZ = !0, nodes.push(node), path.replaceWithMultiple(nodes.map(n => _core.types.expressionStatement(n))));
      }
    }
  };
  exports.visitor = visitor;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _helperAnnotateAsPure = _interopRequireDefault(__webpack_require__(42)), _helperFunctionName = _interopRequireDefault(__webpack_require__(8)), _helperSplitExportDeclaration = _interopRequireDefault(__webpack_require__(43)), _core = __webpack_require__(2), _globals = _interopRequireDefault(__webpack_require__(141)), _transformClass = _interopRequireDefault(__webpack_require__(400));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const getBuiltinClasses = category => Object.keys(_globals.default[category]).filter(name => /^[A-Z]/.test(name)), builtinClasses = new Set([ ...getBuiltinClasses("builtin"), ...getBuiltinClasses("browser") ]);
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose} = options, VISITED = Symbol();
    return {
      name: "transform-classes",
      visitor: {
        ExportDefaultDeclaration(path) {
          path.get("declaration").isClassDeclaration() && (0, _helperSplitExportDeclaration.default)(path);
        },
        ClassDeclaration(path) {
          const {node: node} = path, ref = node.id || path.scope.generateUidIdentifier("class");
          path.replaceWith(_core.types.variableDeclaration("let", [ _core.types.variableDeclarator(ref, _core.types.toExpression(node)) ]));
        },
        ClassExpression(path, state) {
          const {node: node} = path;
          if (node[VISITED]) return;
          const inferred = (0, _helperFunctionName.default)(path);
          inferred && inferred !== node ? path.replaceWith(inferred) : (node[VISITED] = !0, 
          path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose)), 
          path.isCallExpression() && ((0, _helperAnnotateAsPure.default)(path), path.get("callee").isArrowFunctionExpression() && path.get("callee").arrowFunctionToExpression()));
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, file, builtinClasses, isLoose) {
    const classState = {
      parent: void 0,
      scope: void 0,
      node: void 0,
      path: void 0,
      file: void 0,
      classId: void 0,
      classRef: void 0,
      superFnId: void 0,
      superName: void 0,
      superReturns: [],
      isDerived: !1,
      extendsNative: !1,
      construct: void 0,
      constructorBody: void 0,
      userConstructor: void 0,
      userConstructorPath: void 0,
      hasConstructor: !1,
      instancePropBody: [],
      instancePropRefs: {},
      staticPropBody: [],
      body: [],
      superThises: [],
      pushedConstructor: !1,
      pushedInherits: !1,
      protoAlias: null,
      isLoose: !1,
      hasInstanceDescriptors: !1,
      hasStaticDescriptors: !1,
      instanceMutatorMap: {},
      staticMutatorMap: {}
    }, setState = newState => {
      Object.assign(classState, newState);
    }, findThisesVisitor = _core.traverse.visitors.merge([ _helperReplaceSupers.environmentVisitor, {
      ThisExpression(path) {
        classState.superThises.push(path);
      }
    } ]);
    function buildBody() {
      if (function() {
        let hasConstructor = !1;
        const paths = classState.path.get("body.body");
        for (const path of paths) if (hasConstructor = path.equals("kind", "constructor"), 
        hasConstructor) break;
        if (hasConstructor) return;
        let params, body;
        if (classState.isDerived) {
          const constructor = _core.template.expression.ast`
        (function () {
          super(...arguments);
        })
      `;
          params = constructor.params, body = constructor.body;
        } else params = [], body = _core.types.blockStatement([]);
        classState.path.get("body").unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
      }(), function() {
        const classBodyPaths = classState.path.get("body.body");
        for (const path of classBodyPaths) {
          const node = path.node;
          if (path.isClassProperty()) throw path.buildCodeFrameError("Missing class properties transform.");
          if (node.decorators) throw path.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
          if (_core.types.isClassMethod(node)) {
            const isConstructor = "constructor" === node.kind;
            new _helperReplaceSupers.default({
              methodPath: path,
              objectRef: classState.classRef,
              superRef: classState.superName,
              isLoose: classState.isLoose,
              file: classState.file
            }).replace();
            const superReturns = [];
            path.traverse(_core.traverse.visitors.merge([ _helperReplaceSupers.environmentVisitor, {
              ReturnStatement(path) {
                path.getFunctionParent().isArrowFunctionExpression() || superReturns.push(path);
              }
            } ])), isConstructor ? pushConstructor(superReturns, node, path) : pushMethod(node, path);
          }
        }
      }(), function() {
        if (!classState.isDerived) return;
        const path = classState.userConstructorPath, body = path.get("body");
        path.traverse(findThisesVisitor);
        let thisRef = function() {
          const ref = path.scope.generateDeclaredUidIdentifier("this");
          return thisRef = () => _core.types.cloneNode(ref), ref;
        };
        for (const thisPath of classState.superThises) {
          const {node: node, parentPath: parentPath} = thisPath;
          parentPath.isMemberExpression({
            object: node
          }) ? thisPath.replaceWith(thisRef()) : thisPath.replaceWith(_core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [ thisRef() ]));
        }
        const bareSupers = new Set;
        path.traverse(_core.traverse.visitors.merge([ _helperReplaceSupers.environmentVisitor, {
          Super(path) {
            const {node: node, parentPath: parentPath} = path;
            parentPath.isCallExpression({
              callee: node
            }) && bareSupers.add(parentPath);
          }
        } ]));
        let wrapReturn, guaranteedSuperBeforeFinish = !!bareSupers.size;
        for (const bareSuper of bareSupers) wrapSuperCall(bareSuper, classState.superName, thisRef, body), 
        guaranteedSuperBeforeFinish && bareSuper.find((function(parentPath) {
          return parentPath === path || (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression() ? (guaranteedSuperBeforeFinish = !1, 
          !0) : void 0);
        }));
        wrapReturn = classState.isLoose ? returnArg => {
          const thisExpr = _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [ thisRef() ]);
          return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
        } : returnArg => _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), [ thisRef() ].concat(returnArg || []));
        const bodyPaths = body.get("body");
        bodyPaths.length && bodyPaths.pop().isReturnStatement() || body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : wrapReturn()));
        for (const returnPath of classState.superReturns) returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
      }(), classState.userConstructor) {
        const {constructorBody: constructorBody, userConstructor: userConstructor, construct: construct} = classState;
        constructorBody.body = constructorBody.body.concat(userConstructor.body.body), _core.types.inherits(construct, userConstructor), 
        _core.types.inherits(constructorBody, userConstructor.body);
      }
      pushDescriptors();
    }
    function pushDescriptors() {
      pushInheritsToBody();
      const {body: body} = classState;
      let instanceProps, staticProps;
      if (classState.hasInstanceDescriptors && (instanceProps = defineMap.toClassObject(classState.instanceMutatorMap)), 
      classState.hasStaticDescriptors && (staticProps = defineMap.toClassObject(classState.staticMutatorMap)), 
      instanceProps || staticProps) {
        instanceProps && (instanceProps = defineMap.toComputedObjectFromClass(instanceProps)), 
        staticProps && (staticProps = defineMap.toComputedObjectFromClass(staticProps));
        let args = [ _core.types.cloneNode(classState.classRef), _core.types.nullLiteral(), _core.types.nullLiteral() ];
        instanceProps && (args[1] = instanceProps), staticProps && (args[2] = staticProps);
        let lastNonNullIndex = 0;
        for (let i = 0; i < args.length; i++) _core.types.isNullLiteral(args[i]) || (lastNonNullIndex = i);
        args = args.slice(0, lastNonNullIndex + 1), body.push(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("createClass"), args)));
      }
      setState({
        hasInstanceDescriptors: !1,
        hasStaticDescriptors: !1,
        instanceMutatorMap: {},
        staticMutatorMap: {}
      });
    }
    function wrapSuperCall(bareSuper, superRef, thisRef, body) {
      const bareSuperNode = bareSuper.node;
      let call;
      classState.isLoose ? (bareSuperNode.arguments.unshift(_core.types.thisExpression()), 
      2 === bareSuperNode.arguments.length && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
        name: "arguments"
      }) ? (bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument, bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"))) : bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call")), 
      call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression())) : call = (0, 
      _helperOptimiseCallExpression.default)(_core.types.cloneNode(classState.superFnId), _core.types.thisExpression(), bareSuperNode.arguments), 
      bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key ? (classState.superThises.length && (call = _core.types.assignmentExpression("=", thisRef(), call)), 
      bareSuper.parentPath.replaceWith(_core.types.returnStatement(call))) : bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
    }
    function pushMethod(node, path) {
      const scope = path ? path.scope : classState.scope;
      "method" === node.kind && function(node, scope) {
        if (classState.isLoose && !node.decorators) {
          let {classRef: classRef} = classState;
          node.static || (!function() {
            if (null === classState.protoAlias) {
              setState({
                protoAlias: classState.scope.generateUidIdentifier("proto")
              });
              const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype")), protoDeclaration = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(classState.protoAlias, classProto) ]);
              classState.body.push(protoDeclaration);
            }
          }(), classRef = classState.protoAlias);
          const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));
          let func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
          _core.types.inherits(func, node);
          const key = _core.types.toComputedKey(node, node.key);
          _core.types.isStringLiteral(key) && (func = (0, _helperFunctionName.default)({
            node: func,
            id: key,
            scope: scope
          }));
          const expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));
          return _core.types.inheritsComments(expr, node), classState.body.push(expr), !0;
        }
        return !1;
      }(node, scope) || function(node, enumerable, kind = "value", scope) {
        let mutatorMap;
        node.static ? (setState({
          hasStaticDescriptors: !0
        }), mutatorMap = classState.staticMutatorMap) : (setState({
          hasInstanceDescriptors: !0
        }), mutatorMap = classState.instanceMutatorMap);
        const map = defineMap.push(mutatorMap, node, kind, classState.file, scope);
        enumerable && (map.enumerable = _core.types.booleanLiteral(!0));
      }(node, !1, null, scope);
    }
    function pushConstructor(superReturns, method, path) {
      path.scope.hasOwnBinding(classState.classRef.name) && path.scope.rename(classState.classRef.name), 
      setState({
        userConstructorPath: path,
        userConstructor: method,
        hasConstructor: !0,
        superReturns: superReturns
      });
      const {construct: construct} = classState;
      _core.types.inheritsComments(construct, method), construct.params = method.params, 
      _core.types.inherits(construct.body, method.body), construct.body.directives = method.body.directives, 
      function() {
        if (classState.pushedConstructor) return;
        classState.pushedConstructor = !0, (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) && pushDescriptors();
        classState.body.push(classState.construct), pushInheritsToBody();
      }();
    }
    function pushInheritsToBody() {
      if (!classState.isDerived || classState.pushedInherits) return;
      const superFnId = path.scope.generateUidIdentifier("super");
      setState({
        pushedInherits: !0,
        superFnId: superFnId
      }), classState.isLoose || classState.body.unshift(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(superFnId, _core.types.callExpression((0, 
      _inlineCreateSuperHelpers.default)(classState.file), [ _core.types.cloneNode(classState.classRef) ])) ])), 
      classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [ _core.types.cloneNode(classState.classRef), _core.types.cloneNode(classState.superName) ])));
    }
    return function(path, file, builtinClasses, isLoose) {
      setState({
        parent: path.parent,
        scope: path.scope,
        node: path.node,
        path: path,
        file: file,
        isLoose: isLoose
      }), setState({
        classId: classState.node.id,
        classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
        superName: classState.node.superClass,
        isDerived: !!classState.node.superClass,
        constructorBody: _core.types.blockStatement([])
      }), setState({
        extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, !0)
      });
      const {classRef: classRef, node: node, constructorBody: constructorBody} = classState;
      setState({
        construct: buildConstructor(classRef, constructorBody, node)
      });
      let {body: body} = classState;
      const {closureParams: closureParams, closureArgs: closureArgs} = function() {
        const {superName: superName} = classState, closureParams = [], closureArgs = [];
        if (classState.isDerived) {
          let arg = _core.types.cloneNode(superName);
          classState.extendsNative && (arg = _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [ arg ]), 
          (0, _helperAnnotateAsPure.default)(arg));
          const param = classState.scope.generateUidIdentifierBasedOnNode(superName);
          closureParams.push(param), closureArgs.push(arg), setState({
            superName: _core.types.cloneNode(param)
          });
        }
        return {
          closureParams: closureParams,
          closureArgs: closureArgs
        };
      }();
      buildBody(), classState.isLoose || constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [ _core.types.thisExpression(), _core.types.cloneNode(classState.classRef) ]))), 
      body = body.concat(classState.staticPropBody.map(fn => fn(_core.types.cloneNode(classState.classRef))));
      const isStrict = path.isInStrictMode();
      let constructorOnly = classState.classId && 1 === body.length;
      if (constructorOnly && !isStrict) for (const param of classState.construct.params) if (!_core.types.isIdentifier(param)) {
        constructorOnly = !1;
        break;
      }
      const directives = constructorOnly ? body[0].body.directives : [];
      if (isStrict || directives.push(_core.types.directive(_core.types.directiveLiteral("use strict"))), 
      constructorOnly) return _core.types.toExpression(body[0]);
      body.push(_core.types.returnStatement(_core.types.cloneNode(classState.classRef)));
      const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));
      return _core.types.callExpression(container, closureArgs);
    }(path, file, builtinClasses, isLoose);
  };
  var _helperFunctionName = _interopRequireDefault(__webpack_require__(8)), _helperReplaceSupers = _interopRequireWildcard(__webpack_require__(21)), _helperOptimiseCallExpression = _interopRequireDefault(__webpack_require__(73)), defineMap = _interopRequireWildcard(__webpack_require__(401)), _core = __webpack_require__(2), _helperAnnotateAsPure = _interopRequireDefault(__webpack_require__(42)), _inlineCreateSuperHelpers = _interopRequireDefault(__webpack_require__(413));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function buildConstructor(classRef, constructorBody, node) {
    const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);
    return _core.types.inherits(func, node), func;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.push = function(mutatorMap, node, kind, file, scope) {
    const alias = t.toKeyAlias(node);
    let key, value, map = {};
    (0, _has.default)(mutatorMap, alias) && (map = mutatorMap[alias]);
    mutatorMap[alias] = map, map._inherits = map._inherits || [], map._inherits.push(node), 
    map._key = node.key, node.computed && (map._computed = !0);
    if (node.decorators) {
      const decorators = map.decorators = map.decorators || t.arrayExpression([]);
      decorators.elements = decorators.elements.concat(node.decorators.map(dec => dec.expression).reverse());
    }
    if (map.value || map.initializer) throw file.buildCodeFrameError(node, "Key conflict with sibling node");
    (t.isObjectProperty(node) || t.isObjectMethod(node) || t.isClassMethod(node)) && (key = t.toComputedKey(node, node.key));
    t.isProperty(node) ? value = node.value : (t.isObjectMethod(node) || t.isClassMethod(node)) && (value = t.functionExpression(null, node.params, node.body, node.generator, node.async), 
    value.returnType = node.returnType);
    const inheritedKind = function(node) {
      if ((t.isClassMethod(node) || t.isObjectMethod(node)) && ("get" === node.kind || "set" === node.kind)) return node.kind;
      return "value";
    }(node);
    kind && "value" === inheritedKind || (kind = inheritedKind);
    scope && t.isStringLiteral(key) && ("value" === kind || "initializer" === kind) && t.isFunctionExpression(value) && (value = (0, 
    _helperFunctionName.default)({
      id: key,
      node: value,
      scope: scope
    }));
    value && (t.inheritsComments(value, node), map[kind] = value);
    return map;
  }, exports.hasComputed = function(mutatorMap) {
    for (const key of Object.keys(mutatorMap)) if (mutatorMap[key]._computed) return !0;
    return !1;
  }, exports.toComputedObjectFromClass = function(obj) {
    const objExpr = t.arrayExpression([]);
    for (let i = 0; i < obj.properties.length; i++) {
      const prop = obj.properties[i], val = prop.value;
      val.properties.unshift(t.objectProperty(t.identifier("key"), t.toComputedKey(prop))), 
      objExpr.elements.push(val);
    }
    return objExpr;
  }, exports.toClassObject = toClassObject, exports.toDefineObject = function(mutatorMap) {
    return Object.keys(mutatorMap).forEach((function(key) {
      const map = mutatorMap[key];
      map.value && (map.writable = t.booleanLiteral(!0)), map.configurable = t.booleanLiteral(!0), 
      map.enumerable = t.booleanLiteral(!0);
    })), toClassObject(mutatorMap);
  };
  var _helperFunctionName = _interopRequireDefault(__webpack_require__(8)), _has = _interopRequireDefault(__webpack_require__(402)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function toClassObject(mutatorMap) {
    const objExpr = t.objectExpression([]);
    return Object.keys(mutatorMap).forEach((function(mutatorMapKey) {
      const map = mutatorMap[mutatorMapKey], mapNode = t.objectExpression([]), propNode = t.objectProperty(map._key, mapNode, map._computed);
      Object.keys(map).forEach((function(key) {
        const node = map[key];
        if ("_" === key[0]) return;
        const prop = t.objectProperty(t.identifier(key), node);
        t.inheritsComments(prop, node), t.removeComments(node), mapNode.properties.push(prop);
      })), objExpr.properties.push(propNode);
    })), objExpr;
  }
}, function(module, exports, __webpack_require__) {
  var baseHas = __webpack_require__(403), hasPath = __webpack_require__(404);
  module.exports = function(object, path) {
    return null != object && hasPath(object, path, baseHas);
  };
}, function(module, exports) {
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  module.exports = function(object, key) {
    return null != object && hasOwnProperty.call(object, key);
  };
}, function(module, exports, __webpack_require__) {
  var castPath = __webpack_require__(405), isArguments = __webpack_require__(105), isArray = __webpack_require__(15), isIndex = __webpack_require__(59), isLength = __webpack_require__(60), toKey = __webpack_require__(412);
  module.exports = function(object, path, hasFunc) {
    for (var index = -1, length = (path = castPath(path, object)).length, result = !1; ++index < length; ) {
      var key = toKey(path[index]);
      if (!(result = null != object && hasFunc(object, key))) break;
      object = object[key];
    }
    return result || ++index != length ? result : !!(length = null == object ? 0 : object.length) && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  };
}, function(module, exports, __webpack_require__) {
  var isArray = __webpack_require__(15), isKey = __webpack_require__(406), stringToPath = __webpack_require__(407), toString = __webpack_require__(410);
  module.exports = function(value, object) {
    return isArray(value) ? value : isKey(value, object) ? [ value ] : stringToPath(toString(value));
  };
}, function(module, exports, __webpack_require__) {
  var isArray = __webpack_require__(15), isSymbol = __webpack_require__(46), reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  module.exports = function(value, object) {
    if (isArray(value)) return !1;
    var type = typeof value;
    return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || (reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object));
  };
}, function(module, exports, __webpack_require__) {
  var memoizeCapped = __webpack_require__(408), rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped((function(string) {
    var result = [];
    return 46 === string.charCodeAt(0) && result.push(""), string.replace(rePropName, (function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    })), result;
  }));
  module.exports = stringToPath;
}, function(module, exports, __webpack_require__) {
  var memoize = __webpack_require__(409);
  module.exports = function(func) {
    var result = memoize(func, (function(key) {
      return 500 === cache.size && cache.clear(), key;
    })), cache = result.cache;
    return result;
  };
}, function(module, exports, __webpack_require__) {
  var MapCache = __webpack_require__(100);
  function memoize(func, resolver) {
    if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError("Expected a function");
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) return cache.get(key);
      var result = func.apply(this, args);
      return memoized.cache = cache.set(key, result) || cache, result;
    };
    return memoized.cache = new (memoize.Cache || MapCache), memoized;
  }
  memoize.Cache = MapCache, module.exports = memoize;
}, function(module, exports, __webpack_require__) {
  var baseToString = __webpack_require__(411);
  module.exports = function(value) {
    return null == value ? "" : baseToString(value);
  };
}, function(module, exports, __webpack_require__) {
  var Symbol = __webpack_require__(33), arrayMap = __webpack_require__(153), isArray = __webpack_require__(15), isSymbol = __webpack_require__(46), symbolProto = Symbol ? Symbol.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  module.exports = function baseToString(value) {
    if ("string" == typeof value) return value;
    if (isArray(value)) return arrayMap(value, baseToString) + "";
    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
    var result = value + "";
    return "0" == result && 1 / value == -1 / 0 ? "-0" : result;
  };
}, function(module, exports, __webpack_require__) {
  var isSymbol = __webpack_require__(46);
  module.exports = function(value) {
    if ("string" == typeof value || isSymbol(value)) return value;
    var result = value + "";
    return "0" == result && 1 / value == -1 / 0 ? "-0" : result;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(file) {
    if (helperIDs.has(file)) return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));
    try {
      return file.addHelper("createSuper");
    } catch (_unused) {}
    const id = file.scope.generateUidIdentifier("createSuper");
    helperIDs.set(file, id);
    const fn = helper({
      CREATE_SUPER: id,
      GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
      POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
    });
    return file.path.unshiftContainer("body", [ fn ]), file.scope.registerDeclaration(file.path.get("body.0")), 
    _core.types.cloneNode(id);
  };
  var _core = __webpack_require__(2);
  const helperIDs = new WeakMap;
  const helper = _core.template.statement`
  function CREATE_SUPER(Derived) {
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;

      // core-js@3
      if (Reflect.construct.sham) return false;

      // Proxy can't be polyfilled. Every browser implemented
      // proxies before or at the same time as Reflect.construct,
      // so if they support Proxy they also support Reflect.construct.
      if (typeof Proxy === "function") return true;

      // Since Reflect.construct can't be properly polyfilled, some
      // implementations (e.g. core-js@2) don't set the correct internal slots.
      // Those polyfills don't allow us to subclass built-ins, so we need to
      // use our fallback implementation.
      try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Date object.
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    return function () {
      var Super = GET_PROTOTYPE_OF(Derived), result;
      if (isNativeReflectConstruct()) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = GET_PROTOTYPE_OF(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);
    }
  }
`;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose} = options, pushComputedProps = loose ? function(info) {
      for (const prop of info.computedProps) "get" === prop.kind || "set" === prop.kind ? pushMutatorDefine(info, prop) : pushAssign(_core.types.cloneNode(info.objId), prop, info.body);
    } : function(info) {
      const {objId: objId, body: body, computedProps: computedProps, state: state} = info;
      for (const prop of computedProps) {
        const key = _core.types.toComputedKey(prop);
        if ("get" === prop.kind || "set" === prop.kind) pushMutatorDefine(info, prop); else if (_core.types.isStringLiteral(key, {
          value: "__proto__"
        })) pushAssign(objId, prop, body); else {
          if (1 === computedProps.length) return _core.types.callExpression(state.addHelper("defineProperty"), [ info.initPropExpression, key, getValue(prop) ]);
          body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineProperty"), [ _core.types.cloneNode(objId), key, getValue(prop) ])));
        }
      }
    }, buildMutatorMapAssign = (0, _core.template)("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");
    function getValue(prop) {
      return _core.types.isObjectProperty(prop) ? prop.value : _core.types.isObjectMethod(prop) ? _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async) : void 0;
    }
    function pushAssign(objId, prop, body) {
      "get" === prop.kind && "set" === prop.kind ? pushMutatorDefine(objId, prop) : body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));
    }
    function pushMutatorDefine({body: body, getMutatorId: getMutatorId, scope: scope}, prop) {
      let key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;
      const maybeMemoise = scope.maybeGenerateMemoised(key);
      maybeMemoise && (body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", maybeMemoise, key))), 
      key = maybeMemoise), body.push(...buildMutatorMapAssign({
        MUTATOR_MAP_REF: getMutatorId(),
        KEY: _core.types.cloneNode(key),
        VALUE: getValue(prop),
        KIND: _core.types.identifier(prop.kind)
      }));
    }
    return {
      name: "transform-computed-properties",
      visitor: {
        ObjectExpression: {
          exit(path, state) {
            const {node: node, parent: parent, scope: scope} = path;
            let hasComputed = !1;
            for (const prop of node.properties) if (hasComputed = !0 === prop.computed, hasComputed) break;
            if (!hasComputed) return;
            const initProps = [], computedProps = [];
            let foundComputed = !1;
            for (const prop of node.properties) prop.computed && (foundComputed = !0), foundComputed ? computedProps.push(prop) : initProps.push(prop);
            const objId = scope.generateUidIdentifierBasedOnNode(parent), initPropExpression = _core.types.objectExpression(initProps), body = [];
            let mutatorRef;
            body.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(objId, initPropExpression) ]));
            const single = pushComputedProps({
              scope: scope,
              objId: objId,
              body: body,
              computedProps: computedProps,
              initPropExpression: initPropExpression,
              getMutatorId: function() {
                return mutatorRef || (mutatorRef = scope.generateUidIdentifier("mutatorMap"), body.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(mutatorRef, _core.types.objectExpression([])) ]))), 
                _core.types.cloneNode(mutatorRef);
              },
              state: state
            });
            mutatorRef && body.push(_core.types.expressionStatement(_core.types.callExpression(state.addHelper("defineEnumerableProperties"), [ _core.types.cloneNode(objId), _core.types.cloneNode(mutatorRef) ]))), 
            single ? path.replaceWith(single) : (body.push(_core.types.expressionStatement(_core.types.cloneNode(objId))), 
            path.replaceWithMultiple(body));
          }
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose = !1, useBuiltIns: useBuiltIns = !1, allowArrayLike: allowArrayLike = !1} = options;
    if ("boolean" != typeof loose) throw new Error(".loose must be a boolean or undefined");
    const arrayOnlySpread = loose;
    function variableDeclarationHasPattern(node) {
      for (const declar of node.declarations) if (_core.types.isPattern(declar.id)) return !0;
      return !1;
    }
    function hasRest(pattern) {
      for (const elem of pattern.elements) if (_core.types.isRestElement(elem)) return !0;
      return !1;
    }
    const STOP_TRAVERSAL = {}, arrayUnpackVisitor = (node, ancestors, state) => {
      if (ancestors.length && _core.types.isIdentifier(node) && _core.types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) throw state.deopt = !0, 
      STOP_TRAVERSAL;
    };
    class DestructuringTransformer {
      constructor(opts) {
        this.blockHoist = opts.blockHoist, this.operator = opts.operator, this.arrays = {}, 
        this.nodes = opts.nodes || [], this.scope = opts.scope, this.kind = opts.kind, this.arrayOnlySpread = opts.arrayOnlySpread, 
        this.allowArrayLike = opts.allowArrayLike, this.addHelper = opts.addHelper;
      }
      buildVariableAssignment(id, init) {
        let node, op = this.operator;
        return _core.types.isMemberExpression(id) && (op = "="), node = op ? _core.types.expressionStatement(_core.types.assignmentExpression(op, id, _core.types.cloneNode(init) || this.scope.buildUndefinedNode())) : _core.types.variableDeclaration(this.kind, [ _core.types.variableDeclarator(id, _core.types.cloneNode(init)) ]), 
        node._blockHoist = this.blockHoist, node;
      }
      buildVariableDeclaration(id, init) {
        const declar = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.cloneNode(init)) ]);
        return declar._blockHoist = this.blockHoist, declar;
      }
      push(id, _init) {
        const init = _core.types.cloneNode(_init);
        _core.types.isObjectPattern(id) ? this.pushObjectPattern(id, init) : _core.types.isArrayPattern(id) ? this.pushArrayPattern(id, init) : _core.types.isAssignmentPattern(id) ? this.pushAssignmentPattern(id, init) : this.nodes.push(this.buildVariableAssignment(id, init));
      }
      toArray(node, count) {
        return this.arrayOnlySpread || _core.types.isIdentifier(node) && this.arrays[node.name] ? node : this.scope.toArray(node, count, this.allowArrayLike);
      }
      pushAssignmentPattern({left: left, right: right}, valueRef) {
        const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
        this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
        const tempConditional = _core.types.conditionalExpression(_core.types.binaryExpression("===", _core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core.types.cloneNode(tempId));
        if (_core.types.isPattern(left)) {
          let patternId, node;
          "const" === this.kind || "let" === this.kind ? (patternId = this.scope.generateUidIdentifier(tempId.name), 
          node = this.buildVariableDeclaration(patternId, tempConditional)) : (patternId = tempId, 
          node = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(tempId), tempConditional))), 
          this.nodes.push(node), this.push(left, patternId);
        } else this.nodes.push(this.buildVariableAssignment(left, tempConditional));
      }
      pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
        const keys = [];
        let value, allLiteral = !0;
        for (let i = 0; i < pattern.properties.length; i++) {
          const prop = pattern.properties[i];
          if (i >= spreadPropIndex) break;
          if (_core.types.isRestElement(prop)) continue;
          const key = prop.key;
          _core.types.isIdentifier(key) && !prop.computed ? keys.push(_core.types.stringLiteral(key.name)) : _core.types.isTemplateLiteral(prop.key) ? keys.push(_core.types.cloneNode(prop.key)) : _core.types.isLiteral(key) ? keys.push(_core.types.stringLiteral(String(key.value))) : (keys.push(_core.types.cloneNode(key)), 
          allLiteral = !1);
        }
        if (0 === keys.length) value = _core.types.callExpression((file = this, useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends")), [ _core.types.objectExpression([]), _core.types.cloneNode(objRef) ]); else {
          let keyExpression = _core.types.arrayExpression(keys);
          allLiteral || (keyExpression = _core.types.callExpression(_core.types.memberExpression(keyExpression, _core.types.identifier("map")), [ this.addHelper("toPropertyKey") ])), 
          value = _core.types.callExpression(this.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [ _core.types.cloneNode(objRef), keyExpression ]);
        }
        var file;
        this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
      }
      pushObjectProperty(prop, propRef) {
        _core.types.isLiteral(prop.key) && (prop.computed = !0);
        const pattern = prop.value, objRef = _core.types.memberExpression(_core.types.cloneNode(propRef), prop.key, prop.computed);
        _core.types.isPattern(pattern) ? this.push(pattern, objRef) : this.nodes.push(this.buildVariableAssignment(pattern, objRef));
      }
      pushObjectPattern(pattern, objRef) {
        if (pattern.properties.length || this.nodes.push(_core.types.expressionStatement(_core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [ objRef ]))), 
        pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
          const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
          this.nodes.push(this.buildVariableDeclaration(temp, objRef)), objRef = temp;
        }
        if (function(pattern) {
          for (const elem of pattern.properties) if (_core.types.isRestElement(elem)) return !0;
          return !1;
        }(pattern)) {
          let copiedPattern;
          for (let i = 0; i < pattern.properties.length; i++) {
            const prop = pattern.properties[i];
            if (_core.types.isRestElement(prop)) break;
            const key = prop.key;
            if (prop.computed && !this.scope.isPure(key)) {
              const name = this.scope.generateUidIdentifierBasedOnNode(key);
              this.nodes.push(this.buildVariableDeclaration(name, key)), copiedPattern || (copiedPattern = pattern = Object.assign({}, pattern, {
                properties: pattern.properties.slice()
              })), copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                key: name
              });
            }
          }
        }
        for (let i = 0; i < pattern.properties.length; i++) {
          const prop = pattern.properties[i];
          _core.types.isRestElement(prop) ? this.pushObjectRest(pattern, objRef, prop, i) : this.pushObjectProperty(prop, objRef);
        }
      }
      canUnpackArrayPattern(pattern, arr) {
        if (!_core.types.isArrayExpression(arr)) return !1;
        if (pattern.elements.length > arr.elements.length) return;
        if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return !1;
        for (const elem of pattern.elements) {
          if (!elem) return !1;
          if (_core.types.isMemberExpression(elem)) return !1;
        }
        for (const elem of arr.elements) {
          if (_core.types.isSpreadElement(elem)) return !1;
          if (_core.types.isCallExpression(elem)) return !1;
          if (_core.types.isMemberExpression(elem)) return !1;
        }
        const state = {
          deopt: !1,
          bindings: _core.types.getBindingIdentifiers(pattern)
        };
        try {
          _core.types.traverse(arr, arrayUnpackVisitor, state);
        } catch (e) {
          if (e !== STOP_TRAVERSAL) throw e;
        }
        return !state.deopt;
      }
      pushUnpackedArrayPattern(pattern, arr) {
        for (let i = 0; i < pattern.elements.length; i++) {
          const elem = pattern.elements[i];
          _core.types.isRestElement(elem) ? this.push(elem.argument, _core.types.arrayExpression(arr.elements.slice(i))) : this.push(elem, arr.elements[i]);
        }
      }
      pushArrayPattern(pattern, arrayRef) {
        if (!pattern.elements) return;
        if (this.canUnpackArrayPattern(pattern, arrayRef)) return this.pushUnpackedArrayPattern(pattern, arrayRef);
        const count = !hasRest(pattern) && pattern.elements.length, toArray = this.toArray(arrayRef, count);
        _core.types.isIdentifier(toArray) ? arrayRef = toArray : (arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef), 
        this.arrays[arrayRef.name] = !0, this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray)));
        for (let i = 0; i < pattern.elements.length; i++) {
          let elemRef, elem = pattern.elements[i];
          elem && (_core.types.isRestElement(elem) ? (elemRef = this.toArray(arrayRef), elemRef = _core.types.callExpression(_core.types.memberExpression(elemRef, _core.types.identifier("slice")), [ _core.types.numericLiteral(i) ]), 
          elem = elem.argument) : elemRef = _core.types.memberExpression(arrayRef, _core.types.numericLiteral(i), !0), 
          this.push(elem, elemRef));
        }
      }
      init(pattern, ref) {
        if (!_core.types.isArrayExpression(ref) && !_core.types.isMemberExpression(ref)) {
          const memo = this.scope.maybeGenerateMemoised(ref, !0);
          memo && (this.nodes.push(this.buildVariableDeclaration(memo, _core.types.cloneNode(ref))), 
          ref = memo);
        }
        return this.push(pattern, ref), this.nodes;
      }
    }
    return {
      name: "transform-destructuring",
      visitor: {
        ExportNamedDeclaration(path) {
          const declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          if (!variableDeclarationHasPattern(declaration.node)) return;
          const specifiers = [];
          for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));
          path.replaceWith(declaration.node), path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));
        },
        ForXStatement(path) {
          const {node: node, scope: scope} = path, left = node.left;
          if (_core.types.isPattern(left)) {
            const temp = scope.generateUidIdentifier("ref");
            return node.left = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(temp) ]), 
            path.ensureBlock(), 0 === node.body.body.length && path.isCompletionRecord() && node.body.body.unshift(_core.types.expressionStatement(scope.buildUndefinedNode())), 
            void node.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, temp)));
          }
          if (!_core.types.isVariableDeclaration(left)) return;
          const pattern = left.declarations[0].id;
          if (!_core.types.isPattern(pattern)) return;
          const key = scope.generateUidIdentifier("ref");
          node.left = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(key, null) ]);
          const nodes = [];
          new DestructuringTransformer({
            kind: left.kind,
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            allowArrayLike: allowArrayLike,
            addHelper: name => this.addHelper(name)
          }).init(pattern, key), path.ensureBlock();
          const block = node.body;
          block.body = nodes.concat(block.body);
        },
        CatchClause({node: node, scope: scope}) {
          const pattern = node.param;
          if (!_core.types.isPattern(pattern)) return;
          const ref = scope.generateUidIdentifier("ref");
          node.param = ref;
          const nodes = [];
          new DestructuringTransformer({
            kind: "let",
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            allowArrayLike: allowArrayLike,
            addHelper: name => this.addHelper(name)
          }).init(pattern, ref), node.body.body = nodes.concat(node.body.body);
        },
        AssignmentExpression(path) {
          const {node: node, scope: scope} = path;
          if (!_core.types.isPattern(node.left)) return;
          const nodes = [], destructuring = new DestructuringTransformer({
            operator: node.operator,
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            allowArrayLike: allowArrayLike,
            addHelper: name => this.addHelper(name)
          });
          let ref;
          !path.isCompletionRecord() && path.parentPath.isExpressionStatement() || (ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref"), 
          nodes.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(ref, node.right) ])), 
          _core.types.isArrayExpression(node.right) && (destructuring.arrays[ref.name] = !0)), 
          destructuring.init(node.left, ref || node.right), ref && (path.parentPath.isArrowFunctionExpression() ? (path.replaceWith(_core.types.blockStatement([])), 
          nodes.push(_core.types.returnStatement(_core.types.cloneNode(ref)))) : nodes.push(_core.types.expressionStatement(_core.types.cloneNode(ref)))), 
          path.replaceWithMultiple(nodes), path.scope.crawl();
        },
        VariableDeclaration(path) {
          const {node: node, scope: scope, parent: parent} = path;
          if (_core.types.isForXStatement(parent)) return;
          if (!parent || !path.container) return;
          if (!variableDeclarationHasPattern(node)) return;
          const nodeKind = node.kind, nodes = [];
          let declar;
          for (let i = 0; i < node.declarations.length; i++) {
            declar = node.declarations[i];
            const patternId = declar.init, pattern = declar.id, destructuring = new DestructuringTransformer({
              blockHoist: node._blockHoist,
              nodes: nodes,
              scope: scope,
              kind: node.kind,
              arrayOnlySpread: arrayOnlySpread,
              allowArrayLike: allowArrayLike,
              addHelper: name => this.addHelper(name)
            });
            _core.types.isPattern(pattern) ? (destructuring.init(pattern, patternId), +i != node.declarations.length - 1 && _core.types.inherits(nodes[nodes.length - 1], declar)) : nodes.push(_core.types.inherits(destructuring.buildVariableAssignment(declar.id, _core.types.cloneNode(declar.init)), declar));
          }
          let tail = null;
          const nodesOut = [];
          for (const node of nodes) null !== tail && _core.types.isVariableDeclaration(node) ? tail.declarations.push(...node.declarations) : (node.kind = nodeKind, 
          nodesOut.push(node), tail = _core.types.isVariableDeclaration(node) ? node : null);
          for (const nodeOut of nodesOut) if (nodeOut.declarations) for (const declaration of nodeOut.declarations) {
            const {name: name} = declaration.id;
            scope.bindings[name] && (scope.bindings[name].kind = nodeOut.kind);
          }
          1 === nodesOut.length ? path.replaceWith(nodesOut[0]) : path.replaceWithMultiple(nodesOut);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperCreateRegexpFeaturesPlugin = __webpack_require__(45), _default = (0, 
  __webpack_require__(0).declare)(api => (api.assertVersion(7), (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-dotall-regex",
    feature: "dotAllFlag"
  })));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2);
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-duplicate-keys",
    visitor: {
      ObjectExpression(path) {
        const {node: node} = path, plainProps = node.properties.filter(prop => !_core.types.isSpreadElement(prop) && !prop.computed), alreadySeenData = Object.create(null), alreadySeenGetters = Object.create(null), alreadySeenSetters = Object.create(null);
        for (const prop of plainProps) {
          const name = (key = prop.key, _core.types.isIdentifier(key) ? key.name : key.value.toString());
          let isDuplicate = !1;
          switch (prop.kind) {
           case "get":
            (alreadySeenData[name] || alreadySeenGetters[name]) && (isDuplicate = !0), alreadySeenGetters[name] = !0;
            break;

           case "set":
            (alreadySeenData[name] || alreadySeenSetters[name]) && (isDuplicate = !0), alreadySeenSetters[name] = !0;
            break;

           default:
            (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) && (isDuplicate = !0), 
            alreadySeenData[name] = !0;
          }
          isDuplicate && (prop.computed = !0, prop.key = _core.types.stringLiteral(name));
        }
        var key;
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _helperBuilderBinaryAssignmentOperatorVisitor = (obj = __webpack_require__(419)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2);
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-exponentiation-operator",
    visitor: (0, _helperBuilderBinaryAssignmentOperatorVisitor.default)({
      operator: "**",
      build: (left, right) => _core.types.callExpression(_core.types.memberExpression(_core.types.identifier("Math"), _core.types.identifier("pow")), [ left, right ])
    })
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(opts) {
    const {build: build, operator: operator} = opts;
    return {
      AssignmentExpression(path) {
        const {node: node, scope: scope} = path;
        if (node.operator !== operator + "=") return;
        const nodes = [], exploded = (0, _helperExplodeAssignableExpression.default)(node.left, nodes, this, scope);
        nodes.push(t.assignmentExpression("=", exploded.ref, build(exploded.uid, node.right))), 
        path.replaceWith(t.sequenceExpression(nodes));
      },
      BinaryExpression(path) {
        const {node: node} = path;
        node.operator === operator && path.replaceWith(build(node.left, node.right));
      }
    };
  };
  var obj, _helperExplodeAssignableExpression = (obj = __webpack_require__(420)) && obj.__esModule ? obj : {
    default: obj
  }, t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(node, nodes, file, scope, allowedSingleIdent) {
    let obj, ref, uid;
    obj = t.isIdentifier(node) && allowedSingleIdent ? node : function(node, nodes, file, scope) {
      let ref;
      if (t.isSuper(node)) return node;
      if (t.isIdentifier(node)) {
        if (scope.hasBinding(node.name)) return node;
        ref = node;
      } else {
        if (!t.isMemberExpression(node)) throw new Error("We can't explode this node type " + node.type);
        if (ref = node.object, t.isSuper(ref) || t.isIdentifier(ref) && scope.hasBinding(ref.name)) return ref;
      }
      const temp = scope.generateUidIdentifierBasedOnNode(ref);
      return scope.push({
        id: temp
      }), nodes.push(t.assignmentExpression("=", t.cloneNode(temp), t.cloneNode(ref))), 
      temp;
    }(node, nodes, 0, scope);
    if (t.isIdentifier(node)) ref = t.cloneNode(node), uid = obj; else {
      const prop = function(node, nodes, file, scope) {
        const prop = node.property, key = t.toComputedKey(node, prop);
        if (t.isLiteral(key) && t.isPureish(key)) return key;
        const temp = scope.generateUidIdentifierBasedOnNode(prop);
        return scope.push({
          id: temp
        }), nodes.push(t.assignmentExpression("=", t.cloneNode(temp), t.cloneNode(prop))), 
        temp;
      }(node, nodes, 0, scope), computed = node.computed || t.isLiteral(prop);
      uid = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed), ref = t.memberExpression(t.cloneNode(obj), t.cloneNode(prop), computed);
    }
    return {
      uid: uid,
      ref: ref
    };
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _noHelperImplementation = (obj = __webpack_require__(422)) && obj.__esModule ? obj : {
    default: obj
  };
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose, assumeArray: assumeArray, allowArrayLike: allowArrayLike} = options;
    if (!0 === loose && !0 === assumeArray) throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
    if (!0 === assumeArray && !0 === allowArrayLike) throw new Error("The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of");
    if (allowArrayLike && /^7\.\d\./.test(api.version)) throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
    if (assumeArray) return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement(path) {
          const {scope: scope} = path, {left: left, right: right, await: isAwait} = path.node;
          if (isAwait) return;
          const i = scope.generateUidIdentifier("i");
          let array = scope.maybeGenerateMemoised(right, !0);
          const inits = [ _core.types.variableDeclarator(i, _core.types.numericLiteral(0)) ];
          array ? inits.push(_core.types.variableDeclarator(array, right)) : array = right;
          const item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), !0);
          let assignment, blockBody;
          _core.types.isVariableDeclaration(left) ? (assignment = left, assignment.declarations[0].init = item) : assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, item));
          const body = path.get("body");
          body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(id => body.scope.hasOwnBinding(id)) ? blockBody = _core.types.blockStatement([ assignment, body.node ]) : (blockBody = _core.types.toBlock(body.node), 
          blockBody.body.unshift(assignment)), path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration("let", inits), _core.types.binaryExpression("<", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier("length"))), _core.types.updateExpression("++", _core.types.cloneNode(i)), blockBody));
        }
      }
    };
    const buildForOfArray = (0, _core.template)("\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  "), buildForOfLoose = _core.template.statements("\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ALLOW_ARRAY_LIKE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  "), buildForOf = _core.template.statements("\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ALLOW_ARRAY_LIKE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  "), builder = loose ? {
      build: buildForOfLoose,
      helper: "createForOfIteratorHelperLoose",
      getContainer: nodes => nodes
    } : {
      build: buildForOf,
      helper: "createForOfIteratorHelper",
      getContainer: nodes => nodes[1].block.body
    };
    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement(path, state) {
          const right = path.get("right");
          if (right.isArrayExpression() || right.isGenericType("Array") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) return void path.replaceWith(function(path) {
            const {node: node, scope: scope} = path, right = scope.generateUidIdentifierBasedOnNode(node.right, "arr"), iterationKey = scope.generateUidIdentifier("i"), loop = buildForOfArray({
              BODY: node.body,
              KEY: iterationKey,
              NAME: right,
              ARR: node.right
            });
            _core.types.inherits(loop, node), _core.types.ensureBlock(loop);
            const iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), !0), left = node.left;
            return _core.types.isVariableDeclaration(left) ? (left.declarations[0].init = iterationValue, 
            loop.body.body.unshift(left)) : loop.body.body.unshift(_core.types.expressionStatement(_core.types.assignmentExpression("=", left, iterationValue))), 
            loop;
          }(path));
          if (!state.availableHelper(builder.helper)) return void (0, _noHelperImplementation.default)(loose, path, state);
          const {node: node, parent: parent, scope: scope} = path, left = node.left;
          let declar;
          const stepKey = scope.generateUid("step"), stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
          declar = _core.types.isVariableDeclaration(left) ? _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, stepValue) ]) : _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue)), 
          path.ensureBlock(), node.body.body.unshift(declar);
          const nodes = builder.build({
            CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
            ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
            ALLOW_ARRAY_LIKE: allowArrayLike ? _core.types.booleanLiteral(!0) : null,
            STEP_KEY: _core.types.identifier(stepKey),
            OBJECT: node.right,
            BODY: node.body
          }), container = builder.getContainer(nodes);
          _core.types.inherits(container[0], node), _core.types.inherits(container[0].body, node.body), 
          _core.types.isLabeledStatement(parent) ? (container[0] = _core.types.labeledStatement(parent.label, container[0]), 
          path.parentPath.replaceWithMultiple(nodes), path.remove()) : path.replaceWithMultiple(nodes);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(loose, path, state) {
    const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec, {node: node} = path, build = pushComputedProps(path, state), declar = build.declar, loop = build.loop, block = loop.body;
    path.ensureBlock(), declar && block.body.push(declar);
    block.body = block.body.concat(node.body.body), _core.types.inherits(loop, node), 
    _core.types.inherits(loop.body, node.body), build.replaceParent ? (path.parentPath.replaceWithMultiple(build.node), 
    path.remove()) : path.replaceWithMultiple(build.node);
  };
  var _core = __webpack_require__(2);
  const buildForOfLoose = (0, _core.template)("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n"), buildForOf = (0, 
  _core.template)("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");
  function pushComputedPropsLoose(path, file) {
    const {node: node, scope: scope, parent: parent} = path, {left: left} = node;
    let declar, id, intermediate;
    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) id = left, 
    intermediate = null; else {
      if (!_core.types.isVariableDeclaration(left)) throw file.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
      id = scope.generateUidIdentifier("ref"), declar = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, _core.types.identifier(id.name)) ]), 
      intermediate = _core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(id.name)) ]);
    }
    const iteratorKey = scope.generateUidIdentifier("iterator"), isArrayKey = scope.generateUidIdentifier("isArray"), loop = buildForOfLoose({
      LOOP_OBJECT: iteratorKey,
      IS_ARRAY: isArrayKey,
      OBJECT: node.right,
      INDEX: scope.generateUidIdentifier("i"),
      ID: id,
      INTERMEDIATE: intermediate
    }), isLabeledParent = _core.types.isLabeledStatement(parent);
    let labeled;
    return isLabeledParent && (labeled = _core.types.labeledStatement(parent.label, loop)), 
    {
      replaceParent: isLabeledParent,
      declar: declar,
      node: labeled || loop,
      loop: loop
    };
  }
  function pushComputedPropsSpec(path, file) {
    const {node: node, scope: scope, parent: parent} = path, left = node.left;
    let declar;
    const stepKey = scope.generateUid("step"), stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue)); else {
      if (!_core.types.isVariableDeclaration(left)) throw file.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
      declar = _core.types.variableDeclaration(left.kind, [ _core.types.variableDeclarator(left.declarations[0].id, stepValue) ]);
    }
    const template = buildForOf({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      STEP_KEY: _core.types.identifier(stepKey),
      OBJECT: node.right
    }), isLabeledParent = _core.types.isLabeledStatement(parent), tryBody = template[3].block.body, loop = tryBody[0];
    return isLabeledParent && (tryBody[0] = _core.types.labeledStatement(parent.label, loop)), 
    {
      replaceParent: isLabeledParent,
      declar: declar,
      loop: loop,
      node: template
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _helperFunctionName = (obj = __webpack_require__(8)) && obj.__esModule ? obj : {
    default: obj
  };
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-function-name",
    visitor: {
      FunctionExpression: {
        exit(path) {
          if ("value" !== path.key && !path.parentPath.isObjectProperty()) {
            const replacement = (0, _helperFunctionName.default)(path);
            replacement && path.replaceWith(replacement);
          }
        }
      },
      ObjectProperty(path) {
        const value = path.get("value");
        if (value.isFunction()) {
          const newNode = (0, _helperFunctionName.default)(value);
          newNode && value.replaceWith(newNode);
        }
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _default = (0, __webpack_require__(0).declare)(api => (api.assertVersion(7), 
  {
    name: "transform-literals",
    visitor: {
      NumericLiteral({node: node}) {
        node.extra && /^0[ob]/i.test(node.extra.raw) && (node.extra = void 0);
      },
      StringLiteral({node: node}) {
        node.extra && /\\[u]/gi.test(node.extra.raw) && (node.extra = void 0);
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-member-expression-literals",
    visitor: {
      MemberExpression: {
        exit({node: node}) {
          const prop = node.property;
          node.computed || !_core.types.isIdentifier(prop) || _core.types.isValidES3Identifier(prop.name) || (node.property = _core.types.stringLiteral(prop.name), 
          node.computed = !0);
        }
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _helperModuleTransforms = __webpack_require__(47), _core = __webpack_require__(2), _utils = __webpack_require__(75);
  const buildWrapper = (0, _core.template)("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n"), buildAnonymousWrapper = (0, 
  _core.template)('\n  define(["require"], function(REQUIRE) {\n  })\n');
  function injectWrapper(path, wrapper) {
    const {body: body, directives: directives} = path.node;
    path.node.directives = [], path.node.body = [];
    const amdFactory = path.pushContainer("body", wrapper)[0].get("expression.arguments").filter(arg => arg.isFunctionExpression())[0].get("body");
    amdFactory.pushContainer("directives", directives), amdFactory.pushContainer("body", body);
  }
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose, allowTopLevelThis: allowTopLevelThis, strict: strict, strictMode: strictMode, noInterop: noInterop} = options;
    return {
      name: "transform-modules-amd",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "amd");
      },
      visitor: {
        CallExpression(path, state) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          let {requireId: requireId, resolveId: resolveId, rejectId: rejectId} = state;
          requireId || (requireId = path.scope.generateUidIdentifier("require"), state.requireId = requireId), 
          resolveId && rejectId || (resolveId = path.scope.generateUidIdentifier("resolve"), 
          rejectId = path.scope.generateUidIdentifier("reject"), state.resolveId = resolveId, 
          state.rejectId = rejectId);
          let result = _core.types.identifier("imported");
          noInterop || (result = (0, _helperModuleTransforms.wrapInterop)(path, result, "namespace")), 
          path.replaceWith(_core.template.expression.ast`
            new Promise((${resolveId}, ${rejectId}) =>
              ${requireId}(
                [${(0, _utils.getImportSource)(_core.types, path.node)}],
                imported => ${_core.types.cloneNode(resolveId)}(${result}),
                ${_core.types.cloneNode(rejectId)}
              )
            )`);
        },
        Program: {
          exit(path, {requireId: requireId}) {
            if (!(0, _helperModuleTransforms.isModule)(path)) return void (requireId && injectWrapper(path, buildAnonymousWrapper({
              REQUIRE: _core.types.cloneNode(requireId)
            })));
            const amdArgs = [], importNames = [];
            requireId && (amdArgs.push(_core.types.stringLiteral("require")), importNames.push(_core.types.cloneNode(requireId)));
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            moduleName && (moduleName = _core.types.stringLiteral(moduleName));
            const {meta: meta, headers: headers} = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop
            });
            (0, _helperModuleTransforms.hasExports)(meta) && (amdArgs.push(_core.types.stringLiteral("exports")), 
            importNames.push(_core.types.identifier(meta.exportName)));
            for (const [source, metadata] of meta.source) {
              if (amdArgs.push(_core.types.stringLiteral(source)), importNames.push(_core.types.identifier(metadata.name)), 
              !(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
                if (interop) {
                  const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                  header.loc = metadata.loc, headers.push(header);
                }
              }
              headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose));
            }
            (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers), 
            injectWrapper(path, buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
              IMPORT_NAMES: importNames
            }));
          }
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  var baseSlice = __webpack_require__(428), isIterateeCall = __webpack_require__(140), toInteger = __webpack_require__(429), nativeCeil = Math.ceil, nativeMax = Math.max;
  module.exports = function(array, size, guard) {
    size = (guard ? isIterateeCall(array, size, guard) : void 0 === size) ? 1 : nativeMax(toInteger(size), 0);
    var length = null == array ? 0 : array.length;
    if (!length || size < 1) return [];
    for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length; ) result[resIndex++] = baseSlice(array, index, index += size);
    return result;
  };
}, function(module, exports) {
  module.exports = function(array, start, end) {
    var index = -1, length = array.length;
    start < 0 && (start = -start > length ? 0 : length + start), (end = end > length ? length : end) < 0 && (end += length), 
    length = start > end ? 0 : end - start >>> 0, start >>>= 0;
    for (var result = Array(length); ++index < length; ) result[index] = array[index + start];
    return result;
  };
}, function(module, exports, __webpack_require__) {
  var toFinite = __webpack_require__(430);
  module.exports = function(value) {
    var result = toFinite(value), remainder = result % 1;
    return result == result ? remainder ? result - remainder : result : 0;
  };
}, function(module, exports, __webpack_require__) {
  var toNumber = __webpack_require__(431);
  module.exports = function(value) {
    return value ? (value = toNumber(value)) === 1 / 0 || value === -1 / 0 ? 17976931348623157e292 * (value < 0 ? -1 : 1) : value == value ? value : 0 : 0 === value ? value : 0;
  };
}, function(module, exports, __webpack_require__) {
  var isObject = __webpack_require__(14), isSymbol = __webpack_require__(46), reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
  module.exports = function(value) {
    if ("number" == typeof value) return value;
    if (isSymbol(value)) return NaN;
    if (isObject(value)) {
      var other = "function" == typeof value.valueOf ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if ("string" != typeof value) return 0 === value ? value : +value;
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(programPath) {
    programPath.traverse(rewriteThisVisitor);
  };
  var _helperReplaceSupers = __webpack_require__(21);
  const rewriteThisVisitor = {
    ThisExpression(path) {
      path.replaceWith(path.scope.buildUndefinedNode());
    },
    Function(path) {
      path.isMethod() ? (0, _helperReplaceSupers.skipAllButComputedKey)(path) : path.isArrowFunctionExpression() || path.skip();
    },
    ClassProperty(path) {
      (0, _helperReplaceSupers.skipAllButComputedKey)(path);
    },
    ClassPrivateProperty(path) {
      path.skip();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(programPath, metadata) {
    const imported = new Map, exported = new Map, requeueInParent = path => {
      programPath.requeue(path);
    };
    for (const [source, data] of metadata.source) {
      for (const [localName, importName] of data.imports) imported.set(localName, [ source, importName, null ]);
      for (const localName of data.importsNamespace) imported.set(localName, [ source, null, localName ]);
    }
    for (const [local, data] of metadata.local) {
      let exportMeta = exported.get(local);
      exportMeta || (exportMeta = [], exported.set(local, exportMeta)), exportMeta.push(...data.names);
    }
    programPath.traverse(rewriteBindingInitVisitor, {
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      exported: exported
    }), (0, _helperSimpleAccess.default)(programPath, new Set([ ...Array.from(imported.keys()), ...Array.from(exported.keys()) ])), 
    programPath.traverse(rewriteReferencesVisitor, {
      seen: new WeakSet,
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      imported: imported,
      exported: exported,
      buildImportReference: ([source, importName, localName], identNode) => {
        const meta = metadata.source.get(source);
        if (localName) return meta.lazy && (identNode = t.callExpression(identNode, [])), 
        identNode;
        let namespace = t.identifier(meta.name);
        return meta.lazy && (namespace = t.callExpression(namespace, [])), t.memberExpression(namespace, t.identifier(importName));
      }
    });
  };
  var _assert = _interopRequireDefault(__webpack_require__(11)), t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1)), _template = _interopRequireDefault(__webpack_require__(41)), _helperSimpleAccess = _interopRequireDefault(__webpack_require__(155));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const rewriteBindingInitVisitor = {
    Scope(path) {
      path.skip();
    },
    ClassDeclaration(path) {
      const {requeueInParent: requeueInParent, exported: exported, metadata: metadata} = this, {id: id} = path.node;
      if (!id) throw new Error("Expected class to have a name");
      const localName = id.name, exportNames = exported.get(localName) || [];
      if (exportNames.length > 0) {
        const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));
        statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
      }
    },
    VariableDeclaration(path) {
      const {requeueInParent: requeueInParent, exported: exported, metadata: metadata} = this;
      Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {
        const exportNames = exported.get(localName) || [];
        if (exportNames.length > 0) {
          const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));
          statement._blockHoist = path.node._blockHoist, requeueInParent(path.insertAfter(statement)[0]);
        }
      });
    }
  }, buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => (exportNames || []).reduce((expr, exportName) => t.assignmentExpression("=", t.memberExpression(t.identifier(metadata.exportName), t.identifier(exportName)), expr), localExpr), buildImportThrow = localName => _template.default.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `, rewriteReferencesVisitor = {
    ReferencedIdentifier(path) {
      const {seen: seen, buildImportReference: buildImportReference, scope: scope, imported: imported, requeueInParent: requeueInParent} = this;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      const localName = path.node.name, localBinding = path.scope.getBinding(localName);
      if (scope.getBinding(localName) !== localBinding) return;
      const importData = imported.get(localName);
      if (importData) {
        const ref = buildImportReference(importData, path.node);
        if (ref.loc = path.node.loc, (path.parentPath.isCallExpression({
          callee: path.node
        }) || path.parentPath.isOptionalCallExpression({
          callee: path.node
        }) || path.parentPath.isTaggedTemplateExpression({
          tag: path.node
        })) && t.isMemberExpression(ref)) path.replaceWith(t.sequenceExpression([ t.numericLiteral(0), ref ])); else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {
          const {object: object, property: property} = ref;
          path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name)));
        } else path.replaceWith(ref);
        requeueInParent(path), path.skip();
      }
    },
    AssignmentExpression: {
      exit(path) {
        const {scope: scope, seen: seen, imported: imported, exported: exported, requeueInParent: requeueInParent, buildImportReference: buildImportReference} = this;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        const left = path.get("left");
        if (!left.isMemberExpression()) if (left.isIdentifier()) {
          const localName = left.node.name;
          if (scope.getBinding(localName) !== path.scope.getBinding(localName)) return;
          const exportedNames = exported.get(localName), importData = imported.get(localName);
          if ((null == exportedNames ? void 0 : exportedNames.length) > 0 || importData) {
            (0, _assert.default)("=" === path.node.operator, "Path was not simplified");
            const assignment = path.node;
            importData && (assignment.left = buildImportReference(importData, assignment.left), 
            assignment.right = t.sequenceExpression([ assignment.right, buildImportThrow(localName) ])), 
            path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment)), 
            requeueInParent(path);
          }
        } else {
          const ids = left.getOuterBindingIdentifiers(), programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName)), id = programScopeIds.find(localName => imported.has(localName));
          id && (path.node.right = t.sequenceExpression([ path.node.right, buildImportThrow(id) ]));
          const items = [];
          if (programScopeIds.forEach(localName => {
            const exportedNames = exported.get(localName) || [];
            exportedNames.length > 0 && items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, t.identifier(localName)));
          }), items.length > 0) {
            let node = t.sequenceExpression(items);
            path.parentPath.isExpressionStatement() && (node = t.expressionStatement(node), 
            node._blockHoist = path.parentPath.node._blockHoist);
            requeueInParent(path.insertAfter(node)[0]);
          }
        }
      }
    },
    "ForOfStatement|ForInStatement"(path) {
      const {scope: scope, node: node} = path, {left: left} = node, {exported: exported, scope: programScope} = this;
      if (!t.isVariableDeclaration(left)) {
        let didTransform = !1;
        const bodyPath = path.get("body"), loopBodyScope = bodyPath.scope;
        for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) exported.get(name) && programScope.getBinding(name) === scope.getBinding(name) && (didTransform = !0, 
        loopBodyScope.hasOwnBinding(name) && loopBodyScope.rename(name));
        if (!didTransform) return;
        const newLoopId = scope.generateUidIdentifierBasedOnNode(left);
        bodyPath.unshiftContainer("body", t.expressionStatement(t.assignmentExpression("=", left, newLoopId))), 
        path.get("left").replaceWith(t.variableDeclaration("let", [ t.variableDeclarator(t.cloneNode(newLoopId)) ])), 
        scope.registerDeclaration(path.get("left"));
      }
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.hasExports = function(metadata) {
    return metadata.hasExports;
  }, exports.isSideEffectImport = isSideEffectImport, exports.default = function(programPath, exportName, {noInterop: noInterop = !1, loose: loose = !1, lazy: lazy = !1, esNamespaceOnly: esNamespaceOnly = !1} = {}) {
    exportName || (exportName = programPath.scope.generateUidIdentifier("exports").name);
    !function(programPath) {
      programPath.get("body").forEach(child => {
        child.isExportDefaultDeclaration() && (0, _helperSplitExportDeclaration.default)(child);
      });
    }(programPath);
    const {local: local, source: source, hasExports: hasExports} = function(programPath, {loose: loose, lazy: lazy}) {
      const localData = function(programPath, loose) {
        const bindingKindLookup = new Map;
        programPath.get("body").forEach(child => {
          let kind;
          if (child.isImportDeclaration()) kind = "import"; else {
            if (child.isExportDefaultDeclaration() && (child = child.get("declaration")), child.isExportNamedDeclaration()) if (child.node.declaration) child = child.get("declaration"); else if (loose && child.node.source && child.get("source").isStringLiteral()) return void child.node.specifiers.forEach(specifier => {
              bindingKindLookup.set(specifier.local.name, "block");
            });
            if (child.isFunctionDeclaration()) kind = "hoisted"; else if (child.isClassDeclaration()) kind = "block"; else if (child.isVariableDeclaration({
              kind: "var"
            })) kind = "var"; else {
              if (!child.isVariableDeclaration()) return;
              kind = "block";
            }
          }
          Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {
            bindingKindLookup.set(name, kind);
          });
        });
        const localMetadata = new Map, getLocalMetadata = idPath => {
          const localName = idPath.node.name;
          let metadata = localMetadata.get(localName);
          if (!metadata) {
            const kind = bindingKindLookup.get(localName);
            if (void 0 === kind) throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
            metadata = {
              names: [],
              kind: kind
            }, localMetadata.set(localName, metadata);
          }
          return metadata;
        };
        return programPath.get("body").forEach(child => {
          if (!child.isExportNamedDeclaration() || !loose && child.node.source) {
            if (child.isExportDefaultDeclaration()) {
              const declaration = child.get("declaration");
              if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration()) throw declaration.buildCodeFrameError("Unexpected default expression export.");
              getLocalMetadata(declaration.get("id")).names.push("default");
            }
          } else if (child.node.declaration) {
            const declaration = child.get("declaration"), ids = declaration.getOuterBindingIdentifierPaths();
            Object.keys(ids).forEach(name => {
              if ("__esModule" === name) throw declaration.buildCodeFrameError('Illegal export "__esModule".');
              getLocalMetadata(ids[name]).names.push(name);
            });
          } else child.get("specifiers").forEach(spec => {
            const local = spec.get("local"), exported = spec.get("exported");
            if ("__esModule" === exported.node.name) throw exported.buildCodeFrameError('Illegal export "__esModule".');
            getLocalMetadata(local).names.push(exported.node.name);
          });
        }), localMetadata;
      }(programPath, loose), sourceData = new Map, getData = sourceNode => {
        const source = sourceNode.value;
        let data = sourceData.get(source);
        return data || (data = {
          name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
          interop: "none",
          loc: null,
          imports: new Map,
          importsNamespace: new Set,
          reexports: new Map,
          reexportNamespace: new Set,
          reexportAll: null,
          lazy: !1
        }, sourceData.set(source, data)), data;
      };
      let hasExports = !1;
      programPath.get("body").forEach(child => {
        if (child.isImportDeclaration()) {
          const data = getData(child.node.source);
          data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach(spec => {
            if (spec.isImportDefaultSpecifier()) {
              const localName = spec.get("local").node.name;
              data.imports.set(localName, "default");
              const reexport = localData.get(localName);
              reexport && (localData.delete(localName), reexport.names.forEach(name => {
                data.reexports.set(name, "default");
              }));
            } else if (spec.isImportNamespaceSpecifier()) {
              const localName = spec.get("local").node.name;
              data.importsNamespace.add(localName);
              const reexport = localData.get(localName);
              reexport && (localData.delete(localName), reexport.names.forEach(name => {
                data.reexportNamespace.add(name);
              }));
            } else if (spec.isImportSpecifier()) {
              const importName = spec.get("imported").node.name, localName = spec.get("local").node.name;
              data.imports.set(localName, importName);
              const reexport = localData.get(localName);
              reexport && (localData.delete(localName), reexport.names.forEach(name => {
                data.reexports.set(name, importName);
              }));
            }
          });
        } else if (child.isExportAllDeclaration()) {
          hasExports = !0;
          const data = getData(child.node.source);
          data.loc || (data.loc = child.node.loc), data.reexportAll = {
            loc: child.node.loc
          };
        } else if (child.isExportNamedDeclaration() && child.node.source) {
          hasExports = !0;
          const data = getData(child.node.source);
          data.loc || (data.loc = child.node.loc), child.get("specifiers").forEach(spec => {
            if (!spec.isExportSpecifier()) throw spec.buildCodeFrameError("Unexpected export specifier type");
            const importName = spec.get("local").node.name, exportName = spec.get("exported").node.name;
            if (data.reexports.set(exportName, importName), "__esModule" === exportName) throw exportName.buildCodeFrameError('Illegal export "__esModule".');
          });
        } else (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) && (hasExports = !0);
      });
      for (const metadata of sourceData.values()) {
        let needsDefault = !1, needsNamed = !1;
        metadata.importsNamespace.size > 0 && (needsDefault = !0, needsNamed = !0), metadata.reexportAll && (needsNamed = !0);
        for (const importName of metadata.imports.values()) "default" === importName ? needsDefault = !0 : needsNamed = !0;
        for (const importName of metadata.reexports.values()) "default" === importName ? needsDefault = !0 : needsNamed = !0;
        needsDefault && needsNamed ? metadata.interop = "namespace" : needsDefault && (metadata.interop = "default");
      }
      for (const [source, metadata] of sourceData) if (!1 !== lazy && !isSideEffectImport(metadata) && !metadata.reexportAll) if (!0 === lazy) metadata.lazy = !/\./.test(source); else if (Array.isArray(lazy)) metadata.lazy = -1 !== lazy.indexOf(source); else {
        if ("function" != typeof lazy) throw new Error(".lazy must be a boolean, string array, or function");
        metadata.lazy = lazy(source);
      }
      return {
        hasExports: hasExports,
        local: localData,
        source: sourceData
      };
    }(programPath, {
      loose: loose,
      lazy: lazy
    });
    !function(programPath) {
      programPath.get("body").forEach(child => {
        if (child.isImportDeclaration()) child.remove(); else if (child.isExportNamedDeclaration()) child.node.declaration ? (child.node.declaration._blockHoist = child.node._blockHoist, 
        child.replaceWith(child.node.declaration)) : child.remove(); else if (child.isExportDefaultDeclaration()) {
          const declaration = child.get("declaration");
          if (!declaration.isFunctionDeclaration() && !declaration.isClassDeclaration()) throw declaration.buildCodeFrameError("Unexpected default expression export.");
          declaration._blockHoist = child.node._blockHoist, child.replaceWith(declaration);
        } else child.isExportAllDeclaration() && child.remove();
      });
    }(programPath);
    for (const [, metadata] of source) metadata.importsNamespace.size > 0 && (metadata.name = metadata.importsNamespace.values().next().value), 
    noInterop ? metadata.interop = "none" : esNamespaceOnly && "namespace" === metadata.interop && (metadata.interop = "default");
    return {
      exportName: exportName,
      exportNameListName: null,
      hasExports: hasExports,
      local: local,
      source: source
    };
  };
  var obj, _path = __webpack_require__(156), _helperSplitExportDeclaration = (obj = __webpack_require__(43)) && obj.__esModule ? obj : {
    default: obj
  };
  function isSideEffectImport(source) {
    return 0 === source.imports.size && 0 === source.importsNamespace.size && 0 === source.reexports.size && 0 === source.reexportNamespace.size && !source.reexportAll;
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(rootOpts, pluginOpts) {
    var _pluginOpts$moduleRoo, _rootOpts$moduleIds, _rootOpts$moduleRoot;
    const {filename: filename, filenameRelative: filenameRelative = filename, sourceRoot: sourceRoot = (null != (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) ? _pluginOpts$moduleRoo : rootOpts.moduleRoot)} = rootOpts, {moduleId: moduleId = rootOpts.moduleId, moduleIds: moduleIds = (null != (_rootOpts$moduleIds = rootOpts.moduleIds) ? _rootOpts$moduleIds : !!moduleId), getModuleId: getModuleId = rootOpts.getModuleId, moduleRoot: moduleRoot = (null != (_rootOpts$moduleRoot = rootOpts.moduleRoot) ? _rootOpts$moduleRoot : sourceRoot)} = pluginOpts;
    if (!moduleIds) return null;
    if (null != moduleId && !getModuleId) return moduleId;
    let moduleName = null != moduleRoot ? moduleRoot + "/" : "";
    if (filenameRelative) {
      const sourceRootReplacer = null != sourceRoot ? new RegExp("^" + sourceRoot + "/?") : "";
      moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
    }
    return moduleName = moduleName.replace(/\\/g, "/"), getModuleId && getModuleId(moduleName) || moduleName;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var _slicedToArray = function(arr, i) {
    if (Array.isArray(arr)) return arr;
    if (Symbol.iterator in Object(arr)) return function(arr, i) {
      var _arr = [], _n = !0, _d = !1, _e = void 0;
      try {
        for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
        !i || _arr.length !== i); _n = !0) ;
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          !_n && _i.return && _i.return();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }(arr, i);
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
  function getImportSource(t, callNode) {
    var importArguments = callNode.arguments, importPath = _slicedToArray(importArguments, 1)[0];
    return t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath) ? (t.removeComments(importPath), 
    importPath) : t.templateLiteral([ t.templateElement({
      raw: "",
      cooked: ""
    }), t.templateElement({
      raw: "",
      cooked: ""
    }, !0) ], importArguments);
  }
  exports.getImportSource = getImportSource, exports.createDynamicImportTransform = function(_ref) {
    var template = _ref.template, t = _ref.types, builders = {
      static: {
        interop: template("Promise.resolve().then(() => INTEROP(require(SOURCE)))"),
        noInterop: template("Promise.resolve().then(() => require(SOURCE))")
      },
      dynamic: {
        interop: template("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"),
        noInterop: template("Promise.resolve(SOURCE).then(s => require(s))")
      }
    }, visited = "function" == typeof WeakSet && new WeakSet;
    return function(context, path) {
      if (visited) {
        if (visited.has(path)) return;
        visited.add(path);
      }
      var node, SOURCE = getImportSource(t, path.parent), builder = (node = SOURCE, t.isStringLiteral(node) || t.isTemplateLiteral(node) && 0 === node.expressions.length ? builders.static : builders.dynamic), newImport = context.opts.noInterop ? builder.noInterop({
        SOURCE: SOURCE
      }) : builder.interop({
        SOURCE: SOURCE,
        INTEROP: context.addHelper("interopRequireWildcard")
      });
      path.parentPath.replaceWith(newImport);
    };
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _helperModuleTransforms = __webpack_require__(47), _helperSimpleAccess = (obj = __webpack_require__(155)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2), _utils = __webpack_require__(75);
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const transformImportCall = (0, _utils.createDynamicImportTransform)(api), {loose: loose, strictNamespace: strictNamespace = !1, mjsStrictNamespace: mjsStrictNamespace = !0, allowTopLevelThis: allowTopLevelThis, strict: strict, strictMode: strictMode, noInterop: noInterop, lazy: lazy = !1, allowCommonJSExports: allowCommonJSExports = !0} = options;
    if (!("boolean" == typeof lazy || "function" == typeof lazy || Array.isArray(lazy) && lazy.every(item => "string" == typeof item))) throw new Error(".lazy must be a boolean, array of strings, or a function");
    if ("boolean" != typeof strictNamespace) throw new Error(".strictNamespace must be a boolean, or undefined");
    if ("boolean" != typeof mjsStrictNamespace) throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    const getAssertion = localName => _core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, moduleExportsVisitor = {
      ReferencedIdentifier(path) {
        const localName = path.node.name;
        if ("module" !== localName && "exports" !== localName) return;
        const localBinding = path.scope.getBinding(localName);
        this.scope.getBinding(localName) !== localBinding || path.parentPath.isObjectProperty({
          value: path.node
        }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
          left: path.node
        }) || path.isAssignmentExpression({
          left: path.node
        }) || path.replaceWith(getAssertion(localName));
      },
      AssignmentExpression(path) {
        const left = path.get("left");
        if (left.isIdentifier()) {
          const localName = path.node.name;
          if ("module" !== localName && "exports" !== localName) return;
          const localBinding = path.scope.getBinding(localName);
          if (this.scope.getBinding(localName) !== localBinding) return;
          const right = path.get("right");
          right.replaceWith(_core.types.sequenceExpression([ right.node, getAssertion(localName) ]));
        } else if (left.isPattern()) {
          const ids = left.getOuterBindingIdentifiers(), localName = Object.keys(ids).filter(localName => ("module" === localName || "exports" === localName) && this.scope.getBinding(localName) === path.scope.getBinding(localName))[0];
          if (localName) {
            const right = path.get("right");
            right.replaceWith(_core.types.sequenceExpression([ right.node, getAssertion(localName) ]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
      },
      visitor: {
        CallExpression(path) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          let {scope: scope} = path;
          do {
            scope.rename("require");
          } while (scope = scope.parent);
          transformImportCall(this, path.get("callee"));
        },
        Program: {
          exit(path, state) {
            if (!(0, _helperModuleTransforms.isModule)(path)) return;
            path.scope.rename("exports"), path.scope.rename("module"), path.scope.rename("require"), 
            path.scope.rename("__filename"), path.scope.rename("__dirname"), allowCommonJSExports || ((0, 
            _helperSimpleAccess.default)(path, new Set([ "module", "exports" ])), path.traverse(moduleExportsVisitor, {
              scope: path.scope
            }));
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            moduleName && (moduleName = _core.types.stringLiteral(moduleName));
            const {meta: meta, headers: headers} = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
              exportName: "exports",
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop,
              lazy: lazy,
              esNamespaceOnly: "string" == typeof state.filename && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace
            });
            for (const [source, metadata] of meta.source) {
              const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [ _core.types.stringLiteral(source) ]);
              let header;
              if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                if (metadata.lazy) throw new Error("Assertion failure");
                header = _core.types.expressionStatement(loadExpr);
              } else {
                const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
                header = metadata.lazy ? _core.template.ast`
                  function ${metadata.name}() {
                    const data = ${init};
                    ${metadata.name} = function(){ return data; };
                    return data;
                  }
                ` : _core.template.ast`
                  var ${metadata.name} = ${init};
                `;
              }
              header.loc = metadata.loc, headers.push(header), headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose));
            }
            (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers);
          }
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _helperHoistVariables = (obj = __webpack_require__(439)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2), _utils = __webpack_require__(75), _helperModuleTransforms = __webpack_require__(47);
  const buildTemplate = (0, _core.template)('\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    "use strict";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: function () {\n        BODY;\n      }\n    };\n  });\n'), buildExportAll = (0, 
  _core.template)('\n  for (var KEY in TARGET) {\n    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n');
  function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {
    const statements = [];
    if (1 === exportNames.length) statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [ _core.types.stringLiteral(exportNames[0]), exportValues[0] ]))); else if (exportStarTarget) {
      const exportObj = path.scope.generateUid("exportObj");
      statements.push(_core.types.variableDeclaration("var", [ _core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([])) ])), 
      statements.push(buildExportAll({
        KEY: path.scope.generateUidIdentifier("key"),
        EXPORT_OBJ: _core.types.identifier(exportObj),
        TARGET: exportStarTarget
      }));
      for (let i = 0; i < exportNames.length; i++) {
        const exportName = exportNames[i], exportValue = exportValues[i];
        statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
      }
      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [ _core.types.identifier(exportObj) ])));
    } else {
      const objectProperties = [];
      for (let i = 0; i < exportNames.length; i++) {
        const exportName = exportNames[i], exportValue = exportValues[i];
        objectProperties.push(_core.types.objectProperty(_core.types.identifier(exportName), exportValue));
      }
      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [ _core.types.objectExpression(objectProperties) ])));
    }
    return statements;
  }
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {systemGlobal: systemGlobal = "System", allowTopLevelThis: allowTopLevelThis = !1} = options, IGNORE_REASSIGNMENT_SYMBOL = Symbol(), reassignmentVisitor = {
      "AssignmentExpression|UpdateExpression"(path) {
        if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
        path.node[IGNORE_REASSIGNMENT_SYMBOL] = !0;
        const arg = path.get(path.isAssignmentExpression() ? "left" : "argument");
        if (arg.isObjectPattern() || arg.isArrayPattern()) {
          const exprs = [ path.node ];
          for (const name of Object.keys(arg.getBindingIdentifiers())) {
            if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
            const exportedNames = this.exports[name];
            if (!exportedNames) return;
            for (const exportedName of exportedNames) exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);
          }
          return void path.replaceWith(_core.types.sequenceExpression(exprs));
        }
        if (!arg.isIdentifier()) return;
        const name = arg.node.name;
        if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
        const exportedNames = this.exports[name];
        if (!exportedNames) return;
        let node = path.node;
        const isPostUpdateExpression = path.isUpdateExpression({
          prefix: !1
        });
        isPostUpdateExpression && (node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1)));
        for (const exportedName of exportedNames) node = this.buildCall(exportedName, node).expression;
        isPostUpdateExpression && (node = _core.types.sequenceExpression([ node, path.node ])), 
        path.replaceWith(node);
      }
    };
    return {
      name: "transform-modules-systemjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "systemjs");
      },
      visitor: {
        CallExpression(path, state) {
          _core.types.isImport(path.node.callee) && (this.file.has("@babel/plugin-proposal-dynamic-import") || console.warn("WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n"), 
          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [ (0, 
          _utils.getImportSource)(_core.types, path.node) ])));
        },
        MetaProperty(path, state) {
          "import" === path.node.meta.name && "meta" === path.node.property.name && path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
        },
        ReferencedIdentifier(path, state) {
          "__moduleName" !== path.node.name || path.scope.hasBinding("__moduleName") || path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
        },
        Program: {
          enter(path, state) {
            state.contextIdent = path.scope.generateUid("context"), allowTopLevelThis || (0, 
            _helperModuleTransforms.rewriteThis)(path);
          },
          exit(path, state) {
            const scope = path.scope, exportIdent = scope.generateUid("export"), contextIdent = state.contextIdent, exportMap = Object.create(null), modules = [];
            let beforeBody = [];
            const setters = [], sources = [], variableIds = [], removedPaths = [];
            function addExportName(key, val) {
              exportMap[key] = exportMap[key] || [], exportMap[key].push(val);
            }
            function pushModule(source, key, specifiers) {
              let module;
              modules.forEach((function(m) {
                m.key === source && (module = m);
              })), module || modules.push(module = {
                key: source,
                imports: [],
                exports: []
              }), module[key] = module[key].concat(specifiers);
            }
            function buildExportCall(name, val) {
              return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [ _core.types.stringLiteral(name), val ]));
            }
            const exportNames = [], exportValues = [], body = path.get("body");
            for (const path of body) if (path.isFunctionDeclaration()) beforeBody.push(path.node), 
            removedPaths.push(path); else if (path.isClassDeclaration()) variableIds.push(_core.types.cloneNode(path.node.id)), 
            path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node)))); else if (path.isImportDeclaration()) {
              pushModule(path.node.source.value, "imports", path.node.specifiers);
              for (const name of Object.keys(path.getBindingIdentifiers())) scope.removeBinding(name), 
              variableIds.push(_core.types.identifier(name));
              path.remove();
            } else if (path.isExportAllDeclaration()) pushModule(path.node.source.value, "exports", path.node), 
            path.remove(); else if (path.isExportDefaultDeclaration()) {
              const declar = path.get("declaration"), id = declar.node.id;
              declar.isClassDeclaration() ? id ? (exportNames.push("default"), exportValues.push(scope.buildUndefinedNode()), 
              variableIds.push(_core.types.cloneNode(id)), addExportName(id.name, "default"), 
              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar.node))))) : (exportNames.push("default"), 
              exportValues.push(_core.types.toExpression(declar.node)), removedPaths.push(path)) : declar.isFunctionDeclaration() ? (id ? (beforeBody.push(declar.node), 
              exportNames.push("default"), exportValues.push(_core.types.cloneNode(id)), addExportName(id.name, "default")) : (exportNames.push("default"), 
              exportValues.push(_core.types.toExpression(declar.node))), removedPaths.push(path)) : path.replaceWith(buildExportCall("default", declar.node));
            } else if (path.isExportNamedDeclaration()) {
              const declar = path.get("declaration");
              if (declar.node) if (path.replaceWith(declar), path.isFunction()) {
                const node = declar.node, name = node.id.name;
                addExportName(name, name), beforeBody.push(node), exportNames.push(name), exportValues.push(_core.types.cloneNode(node.id)), 
                removedPaths.push(path);
              } else if (path.isClass()) {
                const name = declar.node.id.name;
                exportNames.push(name), exportValues.push(scope.buildUndefinedNode()), variableIds.push(_core.types.cloneNode(declar.node.id)), 
                path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node)))), 
                addExportName(name, name);
              } else for (const name of Object.keys(declar.getBindingIdentifiers())) addExportName(name, name); else {
                const specifiers = path.node.specifiers;
                if (null == specifiers ? void 0 : specifiers.length) if (path.node.source) pushModule(path.node.source.value, "exports", specifiers), 
                path.remove(); else {
                  const nodes = [];
                  for (const specifier of specifiers) {
                    const binding = scope.getBinding(specifier.local.name);
                    binding && _core.types.isFunctionDeclaration(binding.path.node) ? (exportNames.push(specifier.exported.name), 
                    exportValues.push(_core.types.cloneNode(specifier.local))) : binding || nodes.push(buildExportCall(specifier.exported.name, specifier.local)), 
                    addExportName(specifier.local.name, specifier.exported.name);
                  }
                  path.replaceWithMultiple(nodes);
                } else path.remove();
              }
            }
            modules.forEach((function(specifiers) {
              let setterBody = [];
              const target = scope.generateUid(specifiers.key);
              for (let specifier of specifiers.imports) _core.types.isImportNamespaceSpecifier(specifier) ? setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target)))) : _core.types.isImportDefaultSpecifier(specifier) && (specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"))), 
              _core.types.isImportSpecifier(specifier) && setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported))));
              if (specifiers.exports.length) {
                const exportNames = [], exportValues = [];
                let hasExportStar = !1;
                for (const node of specifiers.exports) _core.types.isExportAllDeclaration(node) ? hasExportStar = !0 : _core.types.isExportSpecifier(node) && (exportNames.push(node.exported.name), 
                exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local)));
                setterBody = setterBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null));
              }
              sources.push(_core.types.stringLiteral(specifiers.key)), setters.push(_core.types.functionExpression(null, [ _core.types.identifier(target) ], _core.types.blockStatement(setterBody)));
            }));
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            moduleName && (moduleName = _core.types.stringLiteral(moduleName)), (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {
              variableIds.push(id), hasInit || (exportNames.push(name), exportValues.push(scope.buildUndefinedNode()));
            }, null), variableIds.length && beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map(id => _core.types.variableDeclarator(id)))), 
            exportNames.length && (beforeBody = beforeBody.concat(constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null))), 
            path.traverse(reassignmentVisitor, {
              exports: exportMap,
              buildCall: buildExportCall,
              scope: scope
            });
            for (const path of removedPaths) path.remove();
            path.node.body = [ buildTemplate({
              SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
              BEFORE_BODY: beforeBody,
              MODULE_NAME: moduleName,
              SETTERS: _core.types.arrayExpression(setters),
              SOURCES: _core.types.arrayExpression(sources),
              BODY: path.node.body,
              EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
              CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
            }) ];
          }
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(path, emit, kind = "var") {
    path.traverse(visitor, {
      kind: kind,
      emit: emit
    });
  };
  var t = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(1));
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  const visitor = {
    Scope(path, state) {
      "let" === state.kind && path.skip();
    },
    Function(path) {
      path.skip();
    },
    VariableDeclaration(path, state) {
      if (state.kind && path.node.kind !== state.kind) return;
      const nodes = [], declarations = path.get("declarations");
      let firstId;
      for (const declar of declarations) {
        firstId = declar.node.id, declar.node.init && nodes.push(t.expressionStatement(t.assignmentExpression("=", declar.node.id, declar.node.init)));
        for (const name of Object.keys(declar.getBindingIdentifiers())) state.emit(t.identifier(name), name, null !== declar.node.init);
      }
      path.parentPath.isFor({
        left: path.node
      }) ? path.replaceWith(firstId) : path.replaceWithMultiple(nodes);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _path = __webpack_require__(156), _helperModuleTransforms = __webpack_require__(47), _core = __webpack_require__(2);
  const buildPrerequisiteAssignment = (0, _core.template)("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n"), buildWrapper = (0, 
  _core.template)('\n  (function (global, factory) {\n    if (typeof define === "function" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== "undefined") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== "undefined" ? globalThis\n      : typeof self !== "undefined" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n');
  var _default = (0, _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {globals: globals, exactGlobals: exactGlobals, loose: loose, allowTopLevelThis: allowTopLevelThis, strict: strict, strictMode: strictMode, noInterop: noInterop} = options;
    function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
      const moduleNameOrBasename = moduleName ? moduleName.value : (0, _path.basename)(filename, (0, 
      _path.extname)(filename));
      let globalToAssign = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(moduleNameOrBasename))), initAssignments = [];
      if (exactGlobals) {
        const globalName = browserGlobals[moduleNameOrBasename];
        if (globalName) {
          initAssignments = [];
          const members = globalName.split(".");
          globalToAssign = members.slice(1).reduce((accum, curr) => (initAssignments.push(buildPrerequisiteAssignment({
            GLOBAL_REFERENCE: _core.types.cloneNode(accum)
          })), _core.types.memberExpression(accum, _core.types.identifier(curr))), _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(members[0])));
        }
      }
      return initAssignments.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", globalToAssign, _core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports"))))), 
      initAssignments;
    }
    function buildBrowserArg(browserGlobals, exactGlobals, source) {
      let memberExpression;
      if (exactGlobals) {
        const globalRef = browserGlobals[source];
        memberExpression = globalRef ? globalRef.split(".").reduce((accum, curr) => _core.types.memberExpression(accum, _core.types.identifier(curr)), _core.types.identifier("global")) : _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(source)));
      } else {
        const requireName = (0, _path.basename)(source, (0, _path.extname)(source)), globalName = browserGlobals[requireName] || requireName;
        memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(globalName)));
      }
      return memberExpression;
    }
    return {
      name: "transform-modules-umd",
      visitor: {
        Program: {
          exit(path) {
            if (!(0, _helperModuleTransforms.isModule)(path)) return;
            const browserGlobals = globals || {};
            let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
            moduleName && (moduleName = _core.types.stringLiteral(moduleName));
            const {meta: meta, headers: headers} = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop
            }), amdArgs = [], commonjsArgs = [], browserArgs = [], importNames = [];
            (0, _helperModuleTransforms.hasExports)(meta) && (amdArgs.push(_core.types.stringLiteral("exports")), 
            commonjsArgs.push(_core.types.identifier("exports")), browserArgs.push(_core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports"))), 
            importNames.push(_core.types.identifier(meta.exportName)));
            for (const [source, metadata] of meta.source) {
              if (amdArgs.push(_core.types.stringLiteral(source)), commonjsArgs.push(_core.types.callExpression(_core.types.identifier("require"), [ _core.types.stringLiteral(source) ])), 
              browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source)), importNames.push(_core.types.identifier(metadata.name)), 
              !(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
                if (interop) {
                  const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                  header.loc = meta.loc, headers.push(header);
                }
              }
              headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, loose));
            }
            (0, _helperModuleTransforms.ensureStatementsHoisted)(headers), path.unshiftContainer("body", headers);
            const {body: body, directives: directives} = path.node;
            path.node.directives = [], path.node.body = [];
            const umdFactory = path.pushContainer("body", [ buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
              COMMONJS_ARGUMENTS: commonjsArgs,
              BROWSER_ARGUMENTS: browserArgs,
              IMPORT_NAMES: importNames,
              GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
            }) ])[0].get("expression.arguments")[1].get("body");
            umdFactory.pushContainer("directives", directives), umdFactory.pushContainer("body", body);
          }
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(core, options) {
    const {runtime: runtime = !0} = options;
    if ("boolean" != typeof runtime) throw new Error("The 'runtime' option must be boolean");
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
      name: "transform-named-capturing-groups-regex",
      feature: "namedCaptureGroups",
      options: {
        runtime: runtime
      }
    });
  };
  var _helperCreateRegexpFeaturesPlugin = __webpack_require__(45);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-new-target",
    visitor: {
      MetaProperty(path) {
        const meta = path.get("meta"), property = path.get("property"), {scope: scope} = path;
        if (meta.isIdentifier({
          name: "new"
        }) && property.isIdentifier({
          name: "target"
        })) {
          const func = path.findParent(path => !!path.isClass() || !(!path.isFunction() || path.isArrowFunctionExpression()) && !path.isClassMethod({
            kind: "constructor"
          }));
          if (!func) throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
          const {node: node} = func;
          if (!node.id) {
            if (func.isMethod()) return void path.replaceWith(scope.buildUndefinedNode());
            node.id = scope.generateUidIdentifier("target");
          }
          const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));
          if (func.isClass()) return void path.replaceWith(constructor);
          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
        }
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var obj, _helperPluginUtils = __webpack_require__(0), _helperReplaceSupers = (obj = __webpack_require__(21)) && obj.__esModule ? obj : {
    default: obj
  }, _core = __webpack_require__(2);
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-object-super",
    visitor: {
      ObjectExpression(path, state) {
        let objectRef;
        const getObjectRef = () => objectRef = objectRef || path.scope.generateUidIdentifier("obj");
        path.get("properties").forEach(propPath => {
          propPath.isMethod() && function(path, getObjectRef, file) {
            new _helperReplaceSupers.default({
              getObjectRef: getObjectRef,
              methodPath: path,
              file: file
            }).replace();
          }(propPath, getObjectRef, state);
        }), objectRef && (path.scope.push({
          id: _core.types.cloneNode(objectRef)
        }), path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(objectRef), path.node)));
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-property-literals",
    visitor: {
      ObjectProperty: {
        exit({node: node}) {
          const key = node.key;
          node.computed || !_core.types.isIdentifier(key) || _core.types.isValidES3Identifier(key.name) || (node.key = _core.types.stringLiteral(key.name));
        }
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), Object.defineProperty(exports, "default", {
    enumerable: !0,
    get: function() {
      return _regeneratorTransform.default;
    }
  });
  var obj, _regeneratorTransform = (obj = __webpack_require__(446)) && obj.__esModule ? obj : {
    default: obj
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.default = function(context) {
    var plugin = {
      visitor: (0, _visit.getVisitor)(context)
    }, version = context && context.version;
    version && parseInt(version, 10) >= 7 && (plugin.name = "regenerator-transform");
    return plugin;
  };
  var _visit = __webpack_require__(447);
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _interopRequireWildcard = __webpack_require__(48), _interopRequireDefault = __webpack_require__(49), _assert = _interopRequireDefault(__webpack_require__(11)), _hoist = __webpack_require__(449), _emit = __webpack_require__(157), _replaceShorthandObjectMethod = _interopRequireDefault(__webpack_require__(452)), util = _interopRequireWildcard(__webpack_require__(22));
  function shouldRegenerate(node, state) {
    return node.generator ? node.async ? !1 !== state.opts.asyncGenerators : !1 !== state.opts.generators : !!node.async && !1 !== state.opts.async;
  }
  exports.getVisitor = function(_ref) {
    var t = _ref.types;
    return {
      Method: function(path, state) {
        var node = path.node;
        if (shouldRegenerate(node, state)) {
          var container = t.functionExpression(null, [], t.cloneNode(node.body, !1), node.generator, node.async);
          path.get("body").set("body", [ t.returnStatement(t.callExpression(container, [])) ]), 
          node.async = !1, node.generator = !1, path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
        }
      },
      Function: {
        exit: util.wrapWithTypes(t, (function(path, state) {
          var node = path.node;
          if (shouldRegenerate(node, state)) {
            node = (path = (0, _replaceShorthandObjectMethod.default)(path)).node;
            var contextId = path.scope.generateUidIdentifier("context"), argsId = path.scope.generateUidIdentifier("args");
            path.ensureBlock();
            var bodyBlockPath = path.get("body");
            node.async && bodyBlockPath.traverse(awaitVisitor), bodyBlockPath.traverse(functionSentVisitor, {
              context: contextId
            });
            var outerBody = [], innerBody = [];
            bodyBlockPath.get("body").forEach((function(childPath) {
              var node = childPath.node;
              t.isExpressionStatement(node) && t.isStringLiteral(node.expression) || node && null != node._blockHoist ? outerBody.push(node) : innerBody.push(node);
            })), outerBody.length > 0 && (bodyBlockPath.node.body = innerBody);
            var outerFnExpr = function(funPath) {
              var t = util.getTypes(), node = funPath.node;
              t.assertFunction(node), node.id || (node.id = funPath.scope.parent.generateUidIdentifier("callee"));
              if (node.generator && t.isFunctionDeclaration(node)) return function(funPath) {
                var t = util.getTypes(), node = funPath.node;
                t.assertIdentifier(node.id);
                var blockPath = funPath.findParent((function(path) {
                  return path.isProgram() || path.isBlockStatement();
                }));
                if (!blockPath) return node.id;
                var block = blockPath.node;
                _assert.default.ok(Array.isArray(block.body));
                var info = function(node) {
                  markInfo.has(node) || markInfo.set(node, {});
                  return markInfo.get(node);
                }(block);
                info.decl || (info.decl = t.variableDeclaration("var", []), blockPath.unshiftContainer("body", info.decl), 
                info.declPath = blockPath.get("body.0"));
                _assert.default.strictEqual(info.declPath.node, info.decl);
                var markedId = blockPath.scope.generateUidIdentifier("marked"), markCallExp = t.callExpression(util.runtimeProperty("mark"), [ t.clone(node.id) ]), index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1, markCallExpPath = info.declPath.get("declarations." + index + ".init");
                return _assert.default.strictEqual(markCallExpPath.node, markCallExp), markCallExpPath.addComment("leading", "#__PURE__"), 
                t.clone(markedId);
              }(funPath);
              return t.clone(node.id);
            }(path);
            t.assertIdentifier(node.id);
            var innerFnId = t.identifier(node.id.name + "$"), vars = (0, _hoist.hoist)(path), context = {
              usesThis: !1,
              usesArguments: !1,
              getArgsId: function() {
                return t.clone(argsId);
              }
            };
            path.traverse(argumentsThisVisitor, context), context.usesArguments && (vars = vars || t.variableDeclaration("var", [])).declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier("arguments")));
            var emitter = new _emit.Emitter(contextId);
            emitter.explode(path.get("body")), vars && vars.declarations.length > 0 && outerBody.push(vars);
            var wrapArgs = [ emitter.getContextFunction(innerFnId) ], tryLocsList = emitter.getTryLocsList();
            if (node.generator ? wrapArgs.push(outerFnExpr) : (context.usesThis || tryLocsList || node.async) && wrapArgs.push(t.nullLiteral()), 
            context.usesThis ? wrapArgs.push(t.thisExpression()) : (tryLocsList || node.async) && wrapArgs.push(t.nullLiteral()), 
            tryLocsList ? wrapArgs.push(tryLocsList) : node.async && wrapArgs.push(t.nullLiteral()), 
            node.async) {
              var currentScope = path.scope;
              do {
                currentScope.hasOwnBinding("Promise") && currentScope.rename("Promise");
              } while (currentScope = currentScope.parent);
              wrapArgs.push(t.identifier("Promise"));
            }
            var wrapCall = t.callExpression(util.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
            outerBody.push(t.returnStatement(wrapCall)), node.body = t.blockStatement(outerBody), 
            path.get("body.body").forEach((function(p) {
              return p.scope.registerDeclaration(p);
            }));
            var oldDirectives = bodyBlockPath.node.directives;
            oldDirectives && (node.body.directives = oldDirectives);
            var wasGeneratorFunction = node.generator;
            wasGeneratorFunction && (node.generator = !1), node.async && (node.async = !1), 
            wasGeneratorFunction && t.isExpression(node) && (util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty("mark"), [ node ])), 
            path.addComment("leading", "#__PURE__"));
            var insertedLocs = emitter.getInsertedLocs();
            path.traverse({
              NumericLiteral: function(path) {
                insertedLocs.has(path.node) && path.replaceWith(t.numericLiteral(path.node.value));
              }
            }), path.requeue();
          }
        }))
      }
    };
  };
  var markInfo = new WeakMap;
  var argumentsThisVisitor = {
    "FunctionExpression|FunctionDeclaration|Method": function(path) {
      path.skip();
    },
    Identifier: function(path, state) {
      "arguments" === path.node.name && util.isReference(path) && (util.replaceWithOrRemove(path, state.getArgsId()), 
      state.usesArguments = !0);
    },
    ThisExpression: function(path, state) {
      state.usesThis = !0;
    }
  }, functionSentVisitor = {
    MetaProperty: function(path) {
      var node = path.node;
      if ("function" === node.meta.name && "sent" === node.property.name) {
        var t = util.getTypes();
        util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
      }
    }
  }, awaitVisitor = {
    Function: function(path) {
      path.skip();
    },
    AwaitExpression: function(path) {
      var t = util.getTypes(), argument = path.node.argument;
      util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty("awrap"), [ argument ]), !1));
    }
  };
}, function(module, exports) {
  function _typeof(obj) {
    return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? module.exports = _typeof = function(obj) {
      return typeof obj;
    } : module.exports = _typeof = function(obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  module.exports = _typeof;
}, function(module, exports, __webpack_require__) {
  "use strict";
  var util = __webpack_require__(48)(__webpack_require__(22)), hasOwn = Object.prototype.hasOwnProperty;
  exports.hoist = function(funPath) {
    var t = util.getTypes();
    t.assertFunction(funPath.node);
    var vars = {};
    function varDeclToExpr(_ref, includeIdentifiers) {
      var vdec = _ref.node, scope = _ref.scope;
      t.assertVariableDeclaration(vdec);
      var exprs = [];
      return vdec.declarations.forEach((function(dec) {
        vars[dec.id.name] = t.identifier(dec.id.name), scope.removeBinding(dec.id.name), 
        dec.init ? exprs.push(t.assignmentExpression("=", dec.id, dec.init)) : includeIdentifiers && exprs.push(dec.id);
      })), 0 === exprs.length ? null : 1 === exprs.length ? exprs[0] : t.sequenceExpression(exprs);
    }
    funPath.get("body").traverse({
      VariableDeclaration: {
        exit: function(path) {
          var expr = varDeclToExpr(path, !1);
          null === expr ? path.remove() : util.replaceWithOrRemove(path, t.expressionStatement(expr)), 
          path.skip();
        }
      },
      ForStatement: function(path) {
        var init = path.get("init");
        init.isVariableDeclaration() && util.replaceWithOrRemove(init, varDeclToExpr(init, !1));
      },
      ForXStatement: function(path) {
        var left = path.get("left");
        left.isVariableDeclaration() && util.replaceWithOrRemove(left, varDeclToExpr(left, !0));
      },
      FunctionDeclaration: function(path) {
        var node = path.node;
        vars[node.id.name] = node.id;
        var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
        path.parentPath.isBlockStatement() ? (path.parentPath.unshiftContainer("body", assignment), 
        path.remove()) : util.replaceWithOrRemove(path, assignment), path.scope.removeBinding(node.id.name), 
        path.skip();
      },
      FunctionExpression: function(path) {
        path.skip();
      },
      ArrowFunctionExpression: function(path) {
        path.skip();
      }
    });
    var paramNames = {};
    funPath.get("params").forEach((function(paramPath) {
      var param = paramPath.node;
      t.isIdentifier(param) && (paramNames[param.name] = param);
    }));
    var declarations = [];
    return Object.keys(vars).forEach((function(name) {
      hasOwn.call(paramNames, name) || declarations.push(t.variableDeclarator(vars[name], null));
    })), 0 === declarations.length ? null : t.variableDeclaration("var", declarations);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _assert = __webpack_require__(49)(__webpack_require__(11)), _emit = __webpack_require__(157), _util = __webpack_require__(135), _util2 = __webpack_require__(22);
  function Entry() {
    _assert.default.ok(this instanceof Entry);
  }
  function FunctionEntry(returnLoc) {
    Entry.call(this), (0, _util2.getTypes)().assertLiteral(returnLoc), this.returnLoc = returnLoc;
  }
  function LoopEntry(breakLoc, continueLoc, label) {
    Entry.call(this);
    var t = (0, _util2.getTypes)();
    t.assertLiteral(breakLoc), t.assertLiteral(continueLoc), label ? t.assertIdentifier(label) : label = null, 
    this.breakLoc = breakLoc, this.continueLoc = continueLoc, this.label = label;
  }
  function SwitchEntry(breakLoc) {
    Entry.call(this), (0, _util2.getTypes)().assertLiteral(breakLoc), this.breakLoc = breakLoc;
  }
  function TryEntry(firstLoc, catchEntry, finallyEntry) {
    Entry.call(this), (0, _util2.getTypes)().assertLiteral(firstLoc), catchEntry ? _assert.default.ok(catchEntry instanceof CatchEntry) : catchEntry = null, 
    finallyEntry ? _assert.default.ok(finallyEntry instanceof FinallyEntry) : finallyEntry = null, 
    _assert.default.ok(catchEntry || finallyEntry), this.firstLoc = firstLoc, this.catchEntry = catchEntry, 
    this.finallyEntry = finallyEntry;
  }
  function CatchEntry(firstLoc, paramId) {
    Entry.call(this);
    var t = (0, _util2.getTypes)();
    t.assertLiteral(firstLoc), t.assertIdentifier(paramId), this.firstLoc = firstLoc, 
    this.paramId = paramId;
  }
  function FinallyEntry(firstLoc, afterLoc) {
    Entry.call(this);
    var t = (0, _util2.getTypes)();
    t.assertLiteral(firstLoc), t.assertLiteral(afterLoc), this.firstLoc = firstLoc, 
    this.afterLoc = afterLoc;
  }
  function LabeledEntry(breakLoc, label) {
    Entry.call(this);
    var t = (0, _util2.getTypes)();
    t.assertLiteral(breakLoc), t.assertIdentifier(label), this.breakLoc = breakLoc, 
    this.label = label;
  }
  function LeapManager(emitter) {
    _assert.default.ok(this instanceof LeapManager), _assert.default.ok(emitter instanceof _emit.Emitter), 
    this.emitter = emitter, this.entryStack = [ new FunctionEntry(emitter.finalLoc) ];
  }
  (0, _util.inherits)(FunctionEntry, Entry), exports.FunctionEntry = FunctionEntry, 
  (0, _util.inherits)(LoopEntry, Entry), exports.LoopEntry = LoopEntry, (0, _util.inherits)(SwitchEntry, Entry), 
  exports.SwitchEntry = SwitchEntry, (0, _util.inherits)(TryEntry, Entry), exports.TryEntry = TryEntry, 
  (0, _util.inherits)(CatchEntry, Entry), exports.CatchEntry = CatchEntry, (0, _util.inherits)(FinallyEntry, Entry), 
  exports.FinallyEntry = FinallyEntry, (0, _util.inherits)(LabeledEntry, Entry), exports.LabeledEntry = LabeledEntry;
  var LMp = LeapManager.prototype;
  exports.LeapManager = LeapManager, LMp.withEntry = function(entry, callback) {
    _assert.default.ok(entry instanceof Entry), this.entryStack.push(entry);
    try {
      callback.call(this.emitter);
    } finally {
      var popped = this.entryStack.pop();
      _assert.default.strictEqual(popped, entry);
    }
  }, LMp._findLeapLocation = function(property, label) {
    for (var i = this.entryStack.length - 1; i >= 0; --i) {
      var entry = this.entryStack[i], loc = entry[property];
      if (loc) if (label) {
        if (entry.label && entry.label.name === label.name) return loc;
      } else if (!(entry instanceof LabeledEntry)) return loc;
    }
    return null;
  }, LMp.getBreakLoc = function(label) {
    return this._findLeapLocation("breakLoc", label);
  }, LMp.getContinueLoc = function(label) {
    return this._findLeapLocation("continueLoc", label);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _assert = __webpack_require__(49)(__webpack_require__(11)), _util = __webpack_require__(22), mMap = new WeakMap;
  var hasOwn = Object.prototype.hasOwnProperty;
  function makePredicate(propertyName, knownTypes) {
    function onlyChildren(node) {
      var t = (0, _util.getTypes)();
      t.assertNode(node);
      var result = !1;
      function check(child) {
        return result || (Array.isArray(child) ? child.some(check) : t.isNode(child) && (_assert.default.strictEqual(result, !1), 
        result = predicate(child))), result;
      }
      var keys = t.VISITOR_KEYS[node.type];
      if (keys) for (var i = 0; i < keys.length; i++) {
        check(node[keys[i]]);
      }
      return result;
    }
    function predicate(node) {
      (0, _util.getTypes)().assertNode(node);
      var meta = function(node) {
        return mMap.has(node) || mMap.set(node, {}), mMap.get(node);
      }(node);
      return hasOwn.call(meta, propertyName) ? meta[propertyName] : hasOwn.call(opaqueTypes, node.type) ? meta[propertyName] = !1 : hasOwn.call(knownTypes, node.type) ? meta[propertyName] = !0 : meta[propertyName] = onlyChildren(node);
    }
    return predicate.onlyChildren = onlyChildren, predicate;
  }
  var opaqueTypes = {
    FunctionExpression: !0,
    ArrowFunctionExpression: !0
  }, sideEffectTypes = {
    CallExpression: !0,
    ForInStatement: !0,
    UnaryExpression: !0,
    BinaryExpression: !0,
    AssignmentExpression: !0,
    UpdateExpression: !0,
    NewExpression: !0
  }, leapTypes = {
    YieldExpression: !0,
    BreakStatement: !0,
    ContinueStatement: !0,
    ReturnStatement: !0,
    ThrowStatement: !0
  };
  for (var type in leapTypes) hasOwn.call(leapTypes, type) && (sideEffectTypes[type] = leapTypes[type]);
  exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes), exports.containsLeap = makePredicate("containsLeap", leapTypes);
}, function(module, exports, __webpack_require__) {
  "use strict";
  var _interopRequireWildcard = __webpack_require__(48);
  exports.__esModule = !0, exports.default = function(path) {
    var t = util.getTypes();
    if (!path.node || !t.isFunction(path.node)) throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
    if (!t.isObjectMethod(path.node)) return path;
    if (!path.node.generator) return path;
    var parameters = path.node.params.map((function(param) {
      return t.cloneDeep(param);
    })), functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
    return util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, !1)), 
    path.get("value");
  };
  var util = _interopRequireWildcard(__webpack_require__(22));
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-reserved-words",
    visitor: {
      "BindingIdentifier|ReferencedIdentifier"(path) {
        _core.types.isValidES3Identifier(path.node.name) || path.scope.rename(path.node.name);
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-shorthand-properties",
    visitor: {
      ObjectMethod(path) {
        const {node: node} = path;
        if ("method" === node.kind) {
          const func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
          func.returnType = node.returnType, path.replaceWith(_core.types.objectProperty(node.key, func, node.computed));
        }
      },
      ObjectProperty({node: node}) {
        node.shorthand && (node.shorthand = !1);
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose, allowArrayLike: allowArrayLike} = options;
    function getSpreadLiteral(spread, scope) {
      return loose && !_core.types.isIdentifier(spread.argument, {
        name: "arguments"
      }) ? spread.argument : scope.toArray(spread.argument, !0, allowArrayLike);
    }
    function hasSpread(nodes) {
      for (let i = 0; i < nodes.length; i++) if (_core.types.isSpreadElement(nodes[i])) return !0;
      return !1;
    }
    function push(_props, nodes) {
      return _props.length ? (nodes.push(_core.types.arrayExpression(_props)), []) : _props;
    }
    function build(props, scope) {
      const nodes = [];
      let _props = [];
      for (const prop of props) _core.types.isSpreadElement(prop) ? (_props = push(_props, nodes), 
      nodes.push(getSpreadLiteral(prop, scope))) : _props.push(prop);
      return push(_props, nodes), nodes;
    }
    return {
      name: "transform-spread",
      visitor: {
        ArrayExpression(path) {
          const {node: node, scope: scope} = path, elements = node.elements;
          if (!hasSpread(elements)) return;
          const nodes = build(elements, scope);
          let first = nodes[0];
          1 !== nodes.length || first === elements[0].argument ? (_core.types.isArrayExpression(first) ? nodes.shift() : first = _core.types.arrayExpression([]), 
          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes))) : path.replaceWith(first);
        },
        CallExpression(path) {
          const {node: node, scope: scope} = path, args = node.arguments;
          if (!hasSpread(args)) return;
          const calleePath = path.get("callee");
          if (calleePath.isSuper()) return;
          let nodes, contextLiteral = scope.buildUndefinedNode();
          node.arguments = [], nodes = 1 === args.length && "arguments" === args[0].argument.name ? [ args[0].argument ] : build(args, scope);
          const first = nodes.shift();
          nodes.length ? node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes)) : node.arguments.push(first);
          const callee = node.callee;
          if (calleePath.isMemberExpression()) {
            const temp = scope.maybeGenerateMemoised(callee.object);
            temp ? (callee.object = _core.types.assignmentExpression("=", temp, callee.object), 
            contextLiteral = temp) : contextLiteral = _core.types.cloneNode(callee.object), 
            _core.types.appendToMemberExpression(callee, _core.types.identifier("apply"));
          } else node.callee = _core.types.memberExpression(node.callee, _core.types.identifier("apply"));
          _core.types.isSuper(contextLiteral) && (contextLiteral = _core.types.thisExpression()), 
          node.arguments.unshift(_core.types.cloneNode(contextLiteral));
        },
        NewExpression(path) {
          const {node: node, scope: scope} = path;
          let args = node.arguments;
          if (!hasSpread(args)) return;
          const nodes = build(args, scope), first = nodes.shift();
          args = nodes.length ? _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes) : first, 
          path.replaceWith(_core.types.callExpression(path.hub.addHelper("construct"), [ node.callee, args ]));
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), regex = function(obj) {
    if (obj && obj.__esModule) return obj;
    if (null === obj || "object" != typeof obj && "function" != typeof obj) return {
      default: obj
    };
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) return cache.get(obj);
    var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
    }
    newObj.default = obj, cache && cache.set(obj, newObj);
    return newObj;
  }(__webpack_require__(152)), _core = __webpack_require__(2);
  function _getRequireWildcardCache() {
    if ("function" != typeof WeakMap) return null;
    var cache = new WeakMap;
    return _getRequireWildcardCache = function() {
      return cache;
    }, cache;
  }
  var _default = (0, _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-sticky-regex",
    visitor: {
      RegExpLiteral(path) {
        const {node: node} = path;
        regex.is(node, "y") && path.replaceWith(_core.types.newExpression(_core.types.identifier("RegExp"), [ _core.types.stringLiteral(node.pattern), _core.types.stringLiteral(node.flags) ]));
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)((api, options) => {
    api.assertVersion(7);
    const {loose: loose} = options;
    let helperName = "taggedTemplateLiteral";
    return loose && (helperName += "Loose"), {
      name: "transform-template-literals",
      visitor: {
        TaggedTemplateExpression(path) {
          const {node: node} = path, {quasi: quasi} = node, strings = [], raws = [];
          let isStringsRawEqual = !0;
          for (const elem of quasi.quasis) {
            const {raw: raw, cooked: cooked} = elem.value, value = null == cooked ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
            strings.push(value), raws.push(_core.types.stringLiteral(raw)), raw !== cooked && (isStringsRawEqual = !1);
          }
          const scope = path.scope.getProgramParent(), templateObject = scope.generateUidIdentifier("templateObject"), helperId = this.addHelper(helperName), callExpressionInput = [ _core.types.arrayExpression(strings) ];
          isStringsRawEqual || callExpressionInput.push(_core.types.arrayExpression(raws));
          const lazyLoad = _core.template.ast`
          function ${templateObject}() {
            const data = ${_core.types.callExpression(helperId, callExpressionInput)};
            ${_core.types.cloneNode(templateObject)} = function() { return data };
            return data;
          }
        `;
          scope.path.unshiftContainer("body", lazyLoad), path.replaceWith(_core.types.callExpression(node.tag, [ _core.types.callExpression(_core.types.cloneNode(templateObject), []), ...quasi.expressions ]));
        },
        TemplateLiteral(path) {
          const nodes = [], expressions = path.get("expressions");
          let index = 0;
          for (const elem of path.node.quasis) if (elem.value.cooked && nodes.push(_core.types.stringLiteral(elem.value.cooked)), 
          index < expressions.length) {
            const node = expressions[index++].node;
            _core.types.isStringLiteral(node, {
              value: ""
            }) || nodes.push(node);
          }
          const considerSecondNode = !loose || !_core.types.isStringLiteral(nodes[1]);
          !_core.types.isStringLiteral(nodes[0]) && considerSecondNode && nodes.unshift(_core.types.stringLiteral(""));
          let root = nodes[0];
          if (loose) for (let i = 1; i < nodes.length; i++) root = _core.types.binaryExpression("+", root, nodes[i]); else nodes.length > 1 && (root = function(items) {
            let avail = !0;
            return items.reduce((function(left, right) {
              let canBeInserted = _core.types.isLiteral(right);
              return !canBeInserted && avail && (canBeInserted = !0, avail = !1), canBeInserted && _core.types.isCallExpression(left) ? (left.arguments.push(right), 
              left) : _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [ right ]);
            }));
          }(nodes));
          path.replaceWith(root);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => (api.assertVersion(7), {
    name: "transform-typeof-symbol",
    visitor: {
      Scope({scope: scope}) {
        scope.getBinding("Symbol") && scope.rename("Symbol");
      },
      UnaryExpression(path) {
        const {node: node, parent: parent} = path;
        if ("typeof" !== node.operator) return;
        if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
          const opposite = path.getOpposite();
          if (opposite.isLiteral() && "symbol" !== opposite.node.value && "object" !== opposite.node.value) return;
        }
        let isUnderHelper = path.findParent(path => {
          var _path$get;
          if (path.isFunction()) return "@babel/helpers - typeof" === (null == (_path$get = path.get("body.directives.0")) ? void 0 : _path$get.node.value.value);
        });
        if (isUnderHelper) return;
        const helper = this.addHelper("typeof");
        if (isUnderHelper = path.findParent(path => path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name), 
        isUnderHelper) return;
        const call = _core.types.callExpression(helper, [ node.argument ]), arg = path.get("argument");
        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, !0)) {
          const unary = _core.types.unaryExpression("typeof", _core.types.cloneNode(node.argument));
          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("===", unary, _core.types.stringLiteral("undefined")), _core.types.stringLiteral("undefined"), call));
        } else path.replaceWith(call);
      }
    }
  }));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperPluginUtils = __webpack_require__(0), _core = __webpack_require__(2), _default = (0, 
  _helperPluginUtils.declare)(api => {
    api.assertVersion(7);
    const surrogate = /[\ud800-\udfff]/g, unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;
    function escape(code) {
      let str = code.toString(16);
      for (;str.length < 4; ) str = "0" + str;
      return "\\u" + str;
    }
    function replacer(match, backslashes, code) {
      if (backslashes.length % 2 == 0) return match;
      const char = String.fromCodePoint(parseInt(code, 16)), escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));
      return 1 === char.length ? escaped : escaped + escape(char.charCodeAt(1));
    }
    function replaceUnicodeEscapes(str) {
      return str.replace(unicodeEscape, replacer);
    }
    return {
      name: "transform-unicode-escapes",
      visitor: {
        Identifier(path) {
          const {node: node, key: key} = path, {name: name} = node, replaced = name.replace(surrogate, c => "_u" + c.charCodeAt(0).toString(16));
          if (name === replaced) return;
          const str = _core.types.inherits(_core.types.stringLiteral(name), node);
          if ("key" === key) return void path.replaceWith(str);
          const {parentPath: parentPath, scope: scope} = path;
          if (parentPath.isMemberExpression({
            property: node
          }) || parentPath.isOptionalMemberExpression({
            property: node
          })) return parentPath.node.computed = !0, void path.replaceWith(str);
          if (!scope.getBinding(name)) throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);
          scope.rename(name, scope.generateUid(replaced));
        },
        "StringLiteral|DirectiveLiteral"(path) {
          const {node: node} = path, {extra: extra} = node;
          (null == extra ? void 0 : extra.raw) && (extra.raw = replaceUnicodeEscapes(extra.raw));
        },
        TemplateElement(path) {
          const {node: node, parentPath: parentPath} = path, {value: value} = node, firstEscape = function(str) {
            let match;
            for (;match = unicodeEscape.exec(str); ) if (match[1].length % 2 != 0) return unicodeEscape.lastIndex = 0, 
            match[0];
            return null;
          }(value.raw);
          if (!firstEscape) return;
          if (parentPath.parentPath.isTaggedTemplateExpression()) throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);
          value.raw = replaceUnicodeEscapes(value.raw);
        }
      }
    };
  });
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = void 0;
  var _helperCreateRegexpFeaturesPlugin = __webpack_require__(45), _default = (0, 
  __webpack_require__(0).declare)(api => (api.assertVersion(7), (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
    name: "transform-unicode-regex",
    feature: "unicodeFlag"
  })));
  exports.default = _default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.default = void 0;
  const OPTS = {
    allowInsertArrow: !1,
    specCompliant: !1
  };
  exports.default = ({types: t}) => ({
    name: "transform-async-arrows-in-class",
    visitor: {
      ArrowFunctionExpression(path) {
        path.node.async && path.findParent(t.isClassMethod) && path.arrowFunctionToExpression(OPTS);
      }
    }
  }), module.exports = exports.default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.default = void 0;
  exports.default = ({types: t}) => {
    const isArrowParent = p => "params" === p.parentKey && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
    return {
      name: "transform-edge-default-parameters",
      visitor: {
        AssignmentPattern(path) {
          path.find(isArrowParent) && path.parent.shorthand && (path.parent.shorthand = !1, 
          (path.parent.extra || {}).shorthand = !1, path.scope.rename(path.parent.key.name));
        }
      }
    };
  }, module.exports = exports.default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.default = void 0;
  exports.default = ({types: t}) => ({
    name: "transform-edge-function-name",
    visitor: {
      FunctionExpression: {
        exit(path) {
          if (!path.node.id && t.isIdentifier(path.parent.id)) {
            const id = t.cloneNode(path.parent.id);
            path.scope.getBinding(id.name).constantViolations.length && path.scope.rename(id.name), 
            path.node.id = id;
          }
        }
      }
    }
  }), module.exports = exports.default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.default = void 0;
  exports.default = ({types: t}) => ({
    name: "transform-tagged-template-caching",
    visitor: {
      TaggedTemplateExpression(path, state) {
        let processed = state.get("processed");
        if (processed || (processed = new Map, state.set("processed", processed)), processed.has(path.node)) return path.skip();
        const expressions = path.node.quasi.expressions;
        let identity = state.get("identity");
        if (!identity) {
          identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_"), state.set("identity", identity);
          path.scope.getBinding(identity.name).path.get("init").replaceWith(t.arrowFunctionExpression([ t.identifier("t") ], t.identifier("t")));
        }
        const template = t.taggedTemplateExpression(identity, t.templateLiteral(path.node.quasi.quasis, expressions.map(() => t.numericLiteral(0))));
        processed.set(template, !0);
        const ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
        path.scope.getBinding(ident.name).path.parent.kind = "let";
        const inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", ident, template)), node = t.callExpression(path.node.tag, [ inlineCache, ...expressions ]);
        path.replaceWith(node);
      }
    }
  }), module.exports = exports.default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.default = function({types: t}) {
    return {
      name: "transform-safari-block-shadowing",
      visitor: {
        VariableDeclarator(path) {
          const kind = path.parent.kind;
          if ("let" !== kind && "const" !== kind) return;
          const block = path.scope.block;
          if (t.isFunction(block) || t.isProgram(block)) return;
          const bindings = t.getOuterBindingIdentifiers(path.node.id);
          for (const name of Object.keys(bindings)) {
            let scope = path.scope;
            if (scope.hasOwnBinding(name)) for (;scope = scope.parent; ) {
              if (scope.hasOwnBinding(name)) {
                path.scope.rename(name);
                break;
              }
              if (t.isFunction(scope.block) || t.isProgram(scope.block)) break;
            }
          }
        }
      }
    };
  }, module.exports = exports.default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  function handle(declaration) {
    if (!declaration.isVariableDeclaration()) return;
    const fn = declaration.getFunctionParent(), {name: name} = declaration.node.declarations[0].id;
    fn && fn.scope.hasOwnBinding(name) && "param" === fn.scope.getOwnBinding(name).kind && declaration.scope.rename(name);
  }
  exports.__esModule = !0, exports.default = void 0;
  exports.default = () => ({
    name: "transform-safari-for-shadowing",
    visitor: {
      ForXStatement(path) {
        handle(path.get("left"));
      },
      ForStatement(path) {
        handle(path.get("init"));
      }
    }
  }), module.exports = exports.default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.UseBuiltInsOption = exports.ModulesOption = exports.TopLevelOptions = void 0;
  exports.TopLevelOptions = {
    bugfixes: "bugfixes",
    configPath: "configPath",
    corejs: "corejs",
    debug: "debug",
    exclude: "exclude",
    forceAllTransforms: "forceAllTransforms",
    ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
    include: "include",
    loose: "loose",
    modules: "modules",
    shippedProposals: "shippedProposals",
    spec: "spec",
    targets: "targets",
    useBuiltIns: "useBuiltIns",
    browserslistEnv: "browserslistEnv"
  };
  exports.ModulesOption = {
    false: !1,
    auto: "auto",
    amd: "amd",
    commonjs: "commonjs",
    cjs: "cjs",
    systemjs: "systemjs",
    umd: "umd"
  };
  exports.UseBuiltInsOption = {
    false: !1,
    entry: "entry",
    usage: "usage"
  };
}, function(module, exports) {
  const proposalPlugins = new Set([ "proposal-class-properties", "proposal-numeric-separator", "proposal-private-methods" ]), pluginSyntaxObject = {
    "proposal-async-generator-functions": "syntax-async-generators",
    "proposal-class-properties": "syntax-class-properties",
    "proposal-json-strings": "syntax-json-strings",
    "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
    "proposal-numeric-separator": "syntax-numeric-separator",
    "proposal-object-rest-spread": "syntax-object-rest-spread",
    "proposal-optional-catch-binding": "syntax-optional-catch-binding",
    "proposal-optional-chaining": "syntax-optional-chaining",
    "proposal-private-methods": "syntax-class-properties",
    "proposal-unicode-property-regex": null
  }, pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map((function(key) {
    return [ key, pluginSyntaxObject[key] ];
  })), pluginSyntaxMap = new Map(pluginSyntaxEntries);
  module.exports = {
    pluginSyntaxMap: pluginSyntaxMap,
    proposalPlugins: proposalPlugins
  };
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(470);
}, function(module) {
  module.exports = JSON.parse('{"transform-async-to-generator":["bugfix/transform-async-arrows-in-class"],"transform-parameters":["bugfix/transform-edge-default-parameters"],"transform-function-name":["bugfix/transform-edge-function-name"],"transform-block-scoping":["bugfix/transform-safari-block-shadowing","bugfix/transform-safari-for-shadowing"],"transform-template-literals":["bugfix/transform-tagged-template-caching"]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function({types: t}, {include: include, exclude: exclude, polyfillTargets: polyfillTargets, debug: debug}) {
    const polyfills = (0, _helperCompilationTargets.filterItems)(_corejs2BuiltIns.default, include, exclude, polyfillTargets, (0, 
    _getPlatformSpecificDefault.default)(polyfillTargets));
    return {
      name: "corejs2-usage",
      pre({path: path}) {
        this.polyfillsSet = new Set, this.addImport = function(builtIn) {
          this.polyfillsSet.has(builtIn) || (this.polyfillsSet.add(builtIn), (0, _utils.createImport)(path, builtIn));
        }, this.addUnsupported = function(builtIn) {
          const modules = Array.isArray(builtIn) ? builtIn : [ builtIn ];
          for (const module of modules) polyfills.has(module) && this.addImport(module);
        };
      },
      post() {
        debug && (0, _debug.logUsagePolyfills)(this.polyfillsSet, this.file.opts.filename, polyfillTargets, _corejs2BuiltIns.default);
      },
      visitor: {
        ImportDeclaration(path) {
          (0, _utils.isPolyfillSource)((0, _utils.getImportSource)(path)) && (console.warn(NO_DIRECT_POLYFILL_IMPORT), 
          path.remove());
        },
        Program(path) {
          path.get("body").forEach(bodyPath => {
            (0, _utils.isPolyfillSource)((0, _utils.getRequireSource)(bodyPath)) && (console.warn(NO_DIRECT_POLYFILL_IMPORT), 
            bodyPath.remove());
          });
        },
        ReferencedIdentifier({node: {name: name}, parent: parent, scope: scope}) {
          if (t.isMemberExpression(parent)) return;
          if (!(0, _utils.has)(_builtInDefinitions.BuiltIns, name)) return;
          if (scope.getBindingIdentifier(name)) return;
          const BuiltInDependencies = _builtInDefinitions.BuiltIns[name];
          this.addUnsupported(BuiltInDependencies);
        },
        CallExpression(path) {
          if (path.node.arguments.length) return;
          const callee = path.node.callee;
          t.isMemberExpression(callee) && callee.computed && path.get("callee.property").matchesPattern("Symbol.iterator") && this.addImport("web.dom.iterable");
        },
        BinaryExpression(path) {
          "in" === path.node.operator && path.get("left").matchesPattern("Symbol.iterator") && this.addImport("web.dom.iterable");
        },
        YieldExpression(path) {
          path.node.delegate && this.addImport("web.dom.iterable");
        },
        MemberExpression: {
          enter(path) {
            const {node: node} = path, {object: object, property: property} = node;
            if ((0, _utils.isNamespaced)(path.get("object"))) return;
            let evaluatedPropType = object.name, propertyName = "", instanceType = "";
            if (node.computed) if (t.isStringLiteral(property)) propertyName = property.value; else {
              const result = path.get("property").evaluate();
              result.confident && result.value && (propertyName = result.value);
            } else propertyName = property.name;
            if (path.scope.getBindingIdentifier(object.name)) {
              const result = path.get("object").evaluate();
              result.value ? instanceType = (0, _utils.getType)(result.value) : result.deopt && result.deopt.isIdentifier() && (evaluatedPropType = result.deopt.node.name);
            }
            if ((0, _utils.has)(_builtInDefinitions.StaticProperties, evaluatedPropType)) {
              const BuiltInProperties = _builtInDefinitions.StaticProperties[evaluatedPropType];
              if ((0, _utils.has)(BuiltInProperties, propertyName)) {
                const StaticPropertyDependencies = BuiltInProperties[propertyName];
                this.addUnsupported(StaticPropertyDependencies);
              }
            }
            if ((0, _utils.has)(_builtInDefinitions.InstanceProperties, propertyName)) {
              let InstancePropertyDependencies = _builtInDefinitions.InstanceProperties[propertyName];
              instanceType && (InstancePropertyDependencies = InstancePropertyDependencies.filter(module => module.includes(instanceType))), 
              this.addUnsupported(InstancePropertyDependencies);
            }
          },
          exit(path) {
            const {name: name} = path.node.object;
            if (!(0, _utils.has)(_builtInDefinitions.BuiltIns, name)) return;
            if (path.scope.getBindingIdentifier(name)) return;
            const BuiltInDependencies = _builtInDefinitions.BuiltIns[name];
            this.addUnsupported(BuiltInDependencies);
          }
        },
        VariableDeclarator(path) {
          const {node: node} = path, {id: id, init: init} = node;
          if (t.isObjectPattern(id) && (!init || !path.scope.getBindingIdentifier(init.name))) for (const {key: key} of id.properties) if (!node.computed && t.isIdentifier(key) && (0, 
          _utils.has)(_builtInDefinitions.InstanceProperties, key.name)) {
            const InstancePropertyDependencies = _builtInDefinitions.InstanceProperties[key.name];
            this.addUnsupported(InstancePropertyDependencies);
          }
        }
      }
    };
  };
  var _corejs2BuiltIns = _interopRequireDefault(__webpack_require__(54)), _helperCompilationTargets = __webpack_require__(20), _getPlatformSpecificDefault = _interopRequireDefault(__webpack_require__(76)), _builtInDefinitions = __webpack_require__(472), _utils = __webpack_require__(18), _debug = __webpack_require__(24);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `import '@babel/polyfill'` call or use `useBuiltIns: 'entry'` instead.";
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.StaticProperties = exports.InstanceProperties = exports.BuiltIns = void 0;
  const ArrayNatureIterators = [ "es6.object.to-string", "es6.array.iterator", "web.dom.iterable" ], CommonIterators = [ "es6.string.iterator", ...ArrayNatureIterators ], PromiseDependencies = [ "es6.object.to-string", "es6.promise" ], BuiltIns = {
    DataView: "es6.typed.data-view",
    Float32Array: "es6.typed.float32-array",
    Float64Array: "es6.typed.float64-array",
    Int8Array: "es6.typed.int8-array",
    Int16Array: "es6.typed.int16-array",
    Int32Array: "es6.typed.int32-array",
    Map: [ "es6.map", ...CommonIterators ],
    Number: "es6.number.constructor",
    Promise: PromiseDependencies,
    RegExp: [ "es6.regexp.constructor" ],
    Set: [ "es6.set", ...CommonIterators ],
    Symbol: [ "es6.symbol", "es7.symbol.async-iterator" ],
    Uint8Array: "es6.typed.uint8-array",
    Uint8ClampedArray: "es6.typed.uint8-clamped-array",
    Uint16Array: "es6.typed.uint16-array",
    Uint32Array: "es6.typed.uint32-array",
    WeakMap: [ "es6.weak-map", ...CommonIterators ],
    WeakSet: [ "es6.weak-set", ...CommonIterators ]
  };
  exports.BuiltIns = BuiltIns;
  const InstanceProperties = {
    __defineGetter__: [ "es7.object.define-getter" ],
    __defineSetter__: [ "es7.object.define-setter" ],
    __lookupGetter__: [ "es7.object.lookup-getter" ],
    __lookupSetter__: [ "es7.object.lookup-setter" ],
    anchor: [ "es6.string.anchor" ],
    big: [ "es6.string.big" ],
    bind: [ "es6.function.bind" ],
    blink: [ "es6.string.blink" ],
    bold: [ "es6.string.bold" ],
    codePointAt: [ "es6.string.code-point-at" ],
    copyWithin: [ "es6.array.copy-within" ],
    endsWith: [ "es6.string.ends-with" ],
    entries: ArrayNatureIterators,
    every: [ "es6.array.is-array" ],
    fill: [ "es6.array.fill" ],
    filter: [ "es6.array.filter" ],
    finally: [ "es7.promise.finally", ...PromiseDependencies ],
    find: [ "es6.array.find" ],
    findIndex: [ "es6.array.find-index" ],
    fixed: [ "es6.string.fixed" ],
    flags: [ "es6.regexp.flags" ],
    flatMap: [ "es7.array.flat-map" ],
    fontcolor: [ "es6.string.fontcolor" ],
    fontsize: [ "es6.string.fontsize" ],
    forEach: [ "es6.array.for-each" ],
    includes: [ "es6.string.includes", "es7.array.includes" ],
    indexOf: [ "es6.array.index-of" ],
    italics: [ "es6.string.italics" ],
    keys: ArrayNatureIterators,
    lastIndexOf: [ "es6.array.last-index-of" ],
    link: [ "es6.string.link" ],
    map: [ "es6.array.map" ],
    match: [ "es6.regexp.match" ],
    name: [ "es6.function.name" ],
    padStart: [ "es7.string.pad-start" ],
    padEnd: [ "es7.string.pad-end" ],
    reduce: [ "es6.array.reduce" ],
    reduceRight: [ "es6.array.reduce-right" ],
    repeat: [ "es6.string.repeat" ],
    replace: [ "es6.regexp.replace" ],
    search: [ "es6.regexp.search" ],
    slice: [ "es6.array.slice" ],
    small: [ "es6.string.small" ],
    some: [ "es6.array.some" ],
    sort: [ "es6.array.sort" ],
    split: [ "es6.regexp.split" ],
    startsWith: [ "es6.string.starts-with" ],
    strike: [ "es6.string.strike" ],
    sub: [ "es6.string.sub" ],
    sup: [ "es6.string.sup" ],
    toISOString: [ "es6.date.to-iso-string" ],
    toJSON: [ "es6.date.to-json" ],
    toString: [ "es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string" ],
    trim: [ "es6.string.trim" ],
    trimEnd: [ "es7.string.trim-right" ],
    trimLeft: [ "es7.string.trim-left" ],
    trimRight: [ "es7.string.trim-right" ],
    trimStart: [ "es7.string.trim-left" ],
    values: ArrayNatureIterators
  };
  exports.InstanceProperties = InstanceProperties;
  const StaticProperties = {
    Array: {
      from: [ "es6.array.from", "es6.string.iterator" ],
      isArray: "es6.array.is-array",
      of: "es6.array.of"
    },
    Date: {
      now: "es6.date.now"
    },
    Object: {
      assign: "es6.object.assign",
      create: "es6.object.create",
      defineProperty: "es6.object.define-property",
      defineProperties: "es6.object.define-properties",
      entries: "es7.object.entries",
      freeze: "es6.object.freeze",
      getOwnPropertyDescriptors: "es7.object.get-own-property-descriptors",
      getOwnPropertySymbols: "es6.symbol",
      is: "es6.object.is",
      isExtensible: "es6.object.is-extensible",
      isFrozen: "es6.object.is-frozen",
      isSealed: "es6.object.is-sealed",
      keys: "es6.object.keys",
      preventExtensions: "es6.object.prevent-extensions",
      seal: "es6.object.seal",
      setPrototypeOf: "es6.object.set-prototype-of",
      values: "es7.object.values"
    },
    Math: {
      acosh: "es6.math.acosh",
      asinh: "es6.math.asinh",
      atanh: "es6.math.atanh",
      cbrt: "es6.math.cbrt",
      clz32: "es6.math.clz32",
      cosh: "es6.math.cosh",
      expm1: "es6.math.expm1",
      fround: "es6.math.fround",
      hypot: "es6.math.hypot",
      imul: "es6.math.imul",
      log1p: "es6.math.log1p",
      log10: "es6.math.log10",
      log2: "es6.math.log2",
      sign: "es6.math.sign",
      sinh: "es6.math.sinh",
      tanh: "es6.math.tanh",
      trunc: "es6.math.trunc"
    },
    String: {
      fromCodePoint: "es6.string.from-code-point",
      raw: "es6.string.raw"
    },
    Number: {
      EPSILON: "es6.number.epsilon",
      MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
      isFinite: "es6.number.is-finite",
      isInteger: "es6.number.is-integer",
      isSafeInteger: "es6.number.is-safe-integer",
      isNaN: "es6.number.is-nan",
      parseFloat: "es6.number.parse-float",
      parseInt: "es6.number.parse-int"
    },
    Promise: {
      all: CommonIterators,
      race: CommonIterators
    },
    Reflect: {
      apply: "es6.reflect.apply",
      construct: "es6.reflect.construct",
      defineProperty: "es6.reflect.define-property",
      deleteProperty: "es6.reflect.delete-property",
      get: "es6.reflect.get",
      getOwnPropertyDescriptor: "es6.reflect.get-own-property-descriptor",
      getPrototypeOf: "es6.reflect.get-prototype-of",
      has: "es6.reflect.has",
      isExtensible: "es6.reflect.is-extensible",
      ownKeys: "es6.reflect.own-keys",
      preventExtensions: "es6.reflect.prevent-extensions",
      set: "es6.reflect.set",
      setPrototypeOf: "es6.reflect.set-prototype-of"
    }
  };
  exports.StaticProperties = StaticProperties;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(_, {corejs: corejs, include: include, exclude: exclude, polyfillTargets: polyfillTargets, proposals: proposals, shippedProposals: shippedProposals, debug: debug}) {
    const polyfills = (0, _helperCompilationTargets.filterItems)(proposals ? _data.default : shippedProposals ? corejs3PolyfillsWithShippedProposals : corejs3PolyfillsWithoutProposals, include, exclude, polyfillTargets, null), available = new Set((0, 
    _getModulesListForTargetVersion.default)(corejs.version));
    function resolveKey(path, computed) {
      const {node: node, parent: parent, scope: scope} = path;
      if (path.isStringLiteral()) return node.value;
      const {name: name} = node, isIdentifier = path.isIdentifier();
      if (isIdentifier && !computed && !parent.computed) return name;
      if (!isIdentifier || scope.getBindingIdentifier(name)) {
        const {value: value} = path.evaluate();
        if ("string" == typeof value) return value;
      }
    }
    function resolveSource(path) {
      const {node: node, scope: scope} = path;
      let builtIn, instanceType;
      if (node && (builtIn = node.name, !path.isIdentifier() || scope.getBindingIdentifier(builtIn))) {
        const {deopt: deopt, value: value} = path.evaluate();
        void 0 !== value ? instanceType = (0, _utils.getType)(value) : (null == deopt ? void 0 : deopt.isIdentifier()) && (builtIn = deopt.node.name);
      }
      return {
        builtIn: builtIn,
        instanceType: instanceType,
        isNamespaced: (0, _utils.isNamespaced)(path)
      };
    }
    return {
      name: "corejs3-usage",
      pre() {
        this.injectedPolyfills = new Set, this.polyfillsSet = new Set, this.addUnsupported = function(builtIn) {
          const modules = Array.isArray(builtIn) ? builtIn : [ builtIn ];
          for (const module of modules) this.polyfillsSet.add(module);
        }, this.addBuiltInDependencies = function(builtIn) {
          if ((0, _utils.has)(_builtInDefinitions.BuiltIns, builtIn)) {
            const BuiltInDependencies = _builtInDefinitions.BuiltIns[builtIn];
            this.addUnsupported(BuiltInDependencies);
          }
        }, this.addPropertyDependencies = function(source = {}, key) {
          const {builtIn: builtIn, instanceType: instanceType, isNamespaced: isNamespaced} = source;
          if (isNamespaced) return;
          if (_builtInDefinitions.PossibleGlobalObjects.has(builtIn)) this.addBuiltInDependencies(key); else if ((0, 
          _utils.has)(_builtInDefinitions.StaticProperties, builtIn)) {
            const BuiltInProperties = _builtInDefinitions.StaticProperties[builtIn];
            if ((0, _utils.has)(BuiltInProperties, key)) {
              const StaticPropertyDependencies = BuiltInProperties[key];
              return this.addUnsupported(StaticPropertyDependencies);
            }
          }
          if (!(0, _utils.has)(_builtInDefinitions.InstanceProperties, key)) return;
          let InstancePropertyDependencies = _builtInDefinitions.InstanceProperties[key];
          instanceType && (InstancePropertyDependencies = InstancePropertyDependencies.filter(m => m.includes(instanceType) || _builtInDefinitions.CommonInstanceDependencies.has(m))), 
          this.addUnsupported(InstancePropertyDependencies);
        };
      },
      post() {
        debug && (0, _debug.logUsagePolyfills)(this.injectedPolyfills, this.file.opts.filename, polyfillTargets, _data.default);
      },
      visitor: {
        ImportDeclaration(path) {
          (0, _utils.isPolyfillSource)((0, _utils.getImportSource)(path)) && (console.warn(NO_DIRECT_POLYFILL_IMPORT), 
          path.remove());
        },
        Program: {
          enter(path) {
            path.get("body").forEach(bodyPath => {
              (0, _utils.isPolyfillSource)((0, _utils.getRequireSource)(bodyPath)) && (console.warn(NO_DIRECT_POLYFILL_IMPORT), 
              bodyPath.remove());
            });
          },
          exit(path) {
            const filtered = (0, _utils.intersection)(polyfills, this.polyfillsSet, available), reversed = Array.from(filtered).reverse();
            for (const module of reversed) this.injectedPolyfills.has(module) || (0, _utils.createImport)(path, module);
            filtered.forEach(module => this.injectedPolyfills.add(module));
          }
        },
        Import() {
          this.addUnsupported(_builtInDefinitions.PromiseDependencies);
        },
        Function({node: node}) {
          node.async && this.addUnsupported(_builtInDefinitions.PromiseDependencies);
        },
        "ForOfStatement|ArrayPattern"() {
          this.addUnsupported(_builtInDefinitions.CommonIterators);
        },
        SpreadElement({parentPath: parentPath}) {
          parentPath.isObjectExpression() || this.addUnsupported(_builtInDefinitions.CommonIterators);
        },
        YieldExpression({node: node}) {
          node.delegate && this.addUnsupported(_builtInDefinitions.CommonIterators);
        },
        ReferencedIdentifier({node: {name: name}, scope: scope}) {
          scope.getBindingIdentifier(name) || this.addBuiltInDependencies(name);
        },
        MemberExpression(path) {
          const source = resolveSource(path.get("object")), key = resolveKey(path.get("property"));
          this.addPropertyDependencies(source, key);
        },
        ObjectPattern(path) {
          const {parentPath: parentPath, parent: parent, key: key} = path;
          let source;
          if (parentPath.isVariableDeclarator()) source = resolveSource(parentPath.get("init")); else if (parentPath.isAssignmentExpression()) source = resolveSource(parentPath.get("right")); else if (parentPath.isFunctionExpression()) {
            const grand = parentPath.parentPath;
            (grand.isCallExpression() || grand.isNewExpression()) && grand.node.callee === parent && (source = resolveSource(grand.get("arguments")[key]));
          }
          for (const property of path.get("properties")) if (property.isObjectProperty()) {
            const key = resolveKey(property.get("key"));
            this.addPropertyDependencies(source, key);
          }
        },
        BinaryExpression(path) {
          if ("in" !== path.node.operator) return;
          const source = resolveSource(path.get("right")), key = resolveKey(path.get("left"), !0);
          this.addPropertyDependencies(source, key);
        }
      }
    };
  };
  var _data = _interopRequireDefault(__webpack_require__(53)), _corejs3ShippedProposals = _interopRequireDefault(__webpack_require__(474)), _getModulesListForTargetVersion = _interopRequireDefault(__webpack_require__(158)), _helperCompilationTargets = __webpack_require__(20), _builtInDefinitions = __webpack_require__(489), _utils = __webpack_require__(18), _debug = __webpack_require__(24);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `core-js` or use `useBuiltIns: 'entry'` instead.", corejs3PolyfillsWithoutProposals = Object.keys(_data.default).filter(name => !name.startsWith("esnext.")).reduce((memo, key) => (memo[key] = _data.default[key], 
  memo), {}), corejs3PolyfillsWithShippedProposals = _corejs3ShippedProposals.default.reduce((memo, key) => (memo[key] = _data.default[key], 
  memo), Object.assign({}, corejs3PolyfillsWithoutProposals));
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(475);
}, function(module) {
  module.exports = JSON.parse('["esnext.global-this","esnext.promise.all-settled","esnext.string.match-all"]');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const cmp = __webpack_require__(477), semver = __webpack_require__(485), has = Function.call.bind({}.hasOwnProperty);
  module.exports = {
    compare: function(a, operator, b) {
      return cmp(semver(a), operator, semver(b));
    },
    has: has,
    intersection: function(list, order) {
      const set = list instanceof Set ? list : new Set(list);
      return order.filter(name => set.has(name));
    },
    semver: semver,
    sortObjectByKey: function(object, fn) {
      return Object.keys(object).sort(fn).reduce((memo, key) => (memo[key] = object[key], 
      memo), {});
    }
  };
}, function(module, exports, __webpack_require__) {
  const eq = __webpack_require__(478), neq = __webpack_require__(480), gt = __webpack_require__(481), gte = __webpack_require__(482), lt = __webpack_require__(483), lte = __webpack_require__(484);
  module.exports = (a, op, b, loose) => {
    switch (op) {
     case "===":
      return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
      a === b;

     case "!==":
      return "object" == typeof a && (a = a.version), "object" == typeof b && (b = b.version), 
      a !== b;

     case "":
     case "=":
     case "==":
      return eq(a, b, loose);

     case "!=":
      return neq(a, b, loose);

     case ">":
      return gt(a, b, loose);

     case ">=":
      return gte(a, b, loose);

     case "<":
      return lt(a, b, loose);

     case "<=":
      return lte(a, b, loose);

     default:
      throw new TypeError("Invalid operator: " + op);
    }
  };
}, function(module, exports, __webpack_require__) {
  const compare = __webpack_require__(23);
  module.exports = (a, b, loose) => 0 === compare(a, b, loose);
}, function(module, exports) {
  const numeric = /^[0-9]+$/, compareIdentifiers = (a, b) => {
    const anum = numeric.test(a), bnum = numeric.test(b);
    return anum && bnum && (a = +a, b = +b), a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  module.exports = {
    compareIdentifiers: compareIdentifiers,
    rcompareIdentifiers: (a, b) => compareIdentifiers(b, a)
  };
}, function(module, exports, __webpack_require__) {
  const compare = __webpack_require__(23);
  module.exports = (a, b, loose) => 0 !== compare(a, b, loose);
}, function(module, exports, __webpack_require__) {
  const compare = __webpack_require__(23);
  module.exports = (a, b, loose) => compare(a, b, loose) > 0;
}, function(module, exports, __webpack_require__) {
  const compare = __webpack_require__(23);
  module.exports = (a, b, loose) => compare(a, b, loose) >= 0;
}, function(module, exports, __webpack_require__) {
  const compare = __webpack_require__(23);
  module.exports = (a, b, loose) => compare(a, b, loose) < 0;
}, function(module, exports, __webpack_require__) {
  const compare = __webpack_require__(23);
  module.exports = (a, b, loose) => compare(a, b, loose) <= 0;
}, function(module, exports, __webpack_require__) {
  const SemVer = __webpack_require__(77), parse = __webpack_require__(486), {re: re, t: t} = __webpack_require__(79);
  module.exports = (version, options) => {
    if (version instanceof SemVer) return version;
    if ("number" == typeof version && (version = String(version)), "string" != typeof version) return null;
    let match = null;
    if ((options = options || {}).rtl) {
      let next;
      for (;(next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length); ) match && next.index + next[0].length === match.index + match[0].length || (match = next), 
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      re[t.COERCERTL].lastIndex = -1;
    } else match = version.match(re[t.COERCE]);
    return null === match ? null : parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
  };
}, function(module, exports, __webpack_require__) {
  const {MAX_LENGTH: MAX_LENGTH} = __webpack_require__(78), {re: re, t: t} = __webpack_require__(79), SemVer = __webpack_require__(77);
  module.exports = (version, options) => {
    if (options && "object" == typeof options || (options = {
      loose: !!options,
      includePrerelease: !1
    }), version instanceof SemVer) return version;
    if ("string" != typeof version) return null;
    if (version.length > MAX_LENGTH) return null;
    if (!(options.loose ? re[t.LOOSE] : re[t.FULL]).test(version)) return null;
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"3.0":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.last-index","esnext.array.last-item","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"],"3.1":["es.string.match-all","es.symbol.match-all","esnext.symbol.replace-all"],"3.2":["es.promise.all-settled","esnext.array.is-template-object","esnext.map.update-or-insert","esnext.symbol.async-dispose"],"3.3":["es.global-this","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.upsert","esnext.weak-map.upsert"],"3.4":["es.json.stringify"],"3.5":["esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values"],"3.6":["es.regexp.sticky","es.regexp.test"]}');
}, function(module) {
  module.exports = JSON.parse('["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"]');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.PossibleGlobalObjects = exports.CommonInstanceDependencies = exports.StaticProperties = exports.InstanceProperties = exports.BuiltIns = exports.PromiseDependencies = exports.CommonIterators = void 0;
  const ArrayNatureIterators = [ "es.array.iterator", "web.dom-collections.iterator" ], CommonIterators = [ "es.string.iterator", ...ArrayNatureIterators ];
  exports.CommonIterators = CommonIterators;
  const ArrayNatureIteratorsWithTag = [ "es.object.to-string", ...ArrayNatureIterators ], CommonIteratorsWithTag = [ "es.object.to-string", ...CommonIterators ], TypedArrayDependencies = [ "es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice" ], TypedArrayStaticMethods = {
    from: "es.typed-array.from",
    of: "es.typed-array.of"
  }, PromiseDependencies = [ "es.promise", "es.object.to-string" ];
  exports.PromiseDependencies = PromiseDependencies;
  const PromiseDependenciesWithIterators = [ ...PromiseDependencies, ...CommonIterators ], SymbolDependencies = [ "es.symbol", "es.symbol.description", "es.object.to-string" ], MapDependencies = [ "es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update", ...CommonIteratorsWithTag ], SetDependencies = [ "es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union", ...CommonIteratorsWithTag ], WeakMapDependencies = [ "es.weak-map", "esnext.weak-map.delete-all", ...CommonIteratorsWithTag ], WeakSetDependencies = [ "es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all", ...CommonIteratorsWithTag ], URLSearchParamsDependencies = [ "web.url", ...CommonIteratorsWithTag ], BuiltIns = {
    AggregateError: [ "esnext.aggregate-error", ...CommonIterators ],
    ArrayBuffer: [ "es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string" ],
    DataView: [ "es.data-view", "es.array-buffer.slice", "es.object.to-string" ],
    Date: [ "es.date.to-string" ],
    Float32Array: [ "es.typed-array.float32-array", ...TypedArrayDependencies ],
    Float64Array: [ "es.typed-array.float64-array", ...TypedArrayDependencies ],
    Int8Array: [ "es.typed-array.int8-array", ...TypedArrayDependencies ],
    Int16Array: [ "es.typed-array.int16-array", ...TypedArrayDependencies ],
    Int32Array: [ "es.typed-array.int32-array", ...TypedArrayDependencies ],
    Uint8Array: [ "es.typed-array.uint8-array", ...TypedArrayDependencies ],
    Uint8ClampedArray: [ "es.typed-array.uint8-clamped-array", ...TypedArrayDependencies ],
    Uint16Array: [ "es.typed-array.uint16-array", ...TypedArrayDependencies ],
    Uint32Array: [ "es.typed-array.uint32-array", ...TypedArrayDependencies ],
    Map: MapDependencies,
    Number: [ "es.number.constructor" ],
    Observable: [ "esnext.observable", "esnext.symbol.observable", "es.object.to-string", ...CommonIteratorsWithTag ],
    Promise: PromiseDependencies,
    RegExp: [ "es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string" ],
    Set: SetDependencies,
    Symbol: SymbolDependencies,
    URL: [ "web.url", ...URLSearchParamsDependencies ],
    URLSearchParams: URLSearchParamsDependencies,
    WeakMap: WeakMapDependencies,
    WeakSet: WeakSetDependencies,
    clearImmediate: [ "web.immediate" ],
    compositeKey: [ "esnext.composite-key" ],
    compositeSymbol: [ "esnext.composite-symbol", ...SymbolDependencies ],
    fetch: PromiseDependencies,
    globalThis: [ "es.global-this", "esnext.global-this" ],
    parseFloat: [ "es.parse-float" ],
    parseInt: [ "es.parse-int" ],
    queueMicrotask: [ "web.queue-microtask" ],
    setTimeout: [ "web.timers" ],
    setInterval: [ "web.timers" ],
    setImmediate: [ "web.immediate" ]
  };
  exports.BuiltIns = BuiltIns;
  const InstanceProperties = {
    at: [ "esnext.string.at" ],
    anchor: [ "es.string.anchor" ],
    big: [ "es.string.big" ],
    bind: [ "es.function.bind" ],
    blink: [ "es.string.blink" ],
    bold: [ "es.string.bold" ],
    codePointAt: [ "es.string.code-point-at" ],
    codePoints: [ "esnext.string.code-points" ],
    concat: [ "es.array.concat" ],
    copyWithin: [ "es.array.copy-within" ],
    description: [ "es.symbol", "es.symbol.description" ],
    endsWith: [ "es.string.ends-with" ],
    entries: ArrayNatureIteratorsWithTag,
    every: [ "es.array.every" ],
    exec: [ "es.regexp.exec" ],
    fill: [ "es.array.fill" ],
    filter: [ "es.array.filter" ],
    finally: [ "es.promise.finally", ...PromiseDependencies ],
    find: [ "es.array.find" ],
    findIndex: [ "es.array.find-index" ],
    fixed: [ "es.string.fixed" ],
    flags: [ "es.regexp.flags" ],
    flat: [ "es.array.flat", "es.array.unscopables.flat" ],
    flatMap: [ "es.array.flat-map", "es.array.unscopables.flat-map" ],
    fontcolor: [ "es.string.fontcolor" ],
    fontsize: [ "es.string.fontsize" ],
    forEach: [ "es.array.for-each", "web.dom-collections.for-each" ],
    includes: [ "es.array.includes", "es.string.includes" ],
    indexOf: [ "es.array.index-of" ],
    italics: [ "es.string.italics" ],
    join: [ "es.array.join" ],
    keys: ArrayNatureIteratorsWithTag,
    lastIndex: [ "esnext.array.last-index" ],
    lastIndexOf: [ "es.array.last-index-of" ],
    lastItem: [ "esnext.array.last-item" ],
    link: [ "es.string.link" ],
    match: [ "es.string.match", "es.regexp.exec" ],
    matchAll: [ "es.string.match-all", "esnext.string.match-all" ],
    map: [ "es.array.map" ],
    name: [ "es.function.name" ],
    padEnd: [ "es.string.pad-end" ],
    padStart: [ "es.string.pad-start" ],
    reduce: [ "es.array.reduce" ],
    reduceRight: [ "es.array.reduce-right" ],
    repeat: [ "es.string.repeat" ],
    replace: [ "es.string.replace", "es.regexp.exec" ],
    replaceAll: [ "esnext.string.replace-all" ],
    reverse: [ "es.array.reverse" ],
    search: [ "es.string.search", "es.regexp.exec" ],
    slice: [ "es.array.slice" ],
    small: [ "es.string.small" ],
    some: [ "es.array.some" ],
    sort: [ "es.array.sort" ],
    splice: [ "es.array.splice" ],
    split: [ "es.string.split", "es.regexp.exec" ],
    startsWith: [ "es.string.starts-with" ],
    strike: [ "es.string.strike" ],
    sub: [ "es.string.sub" ],
    sup: [ "es.string.sup" ],
    toFixed: [ "es.number.to-fixed" ],
    toISOString: [ "es.date.to-iso-string" ],
    toJSON: [ "es.date.to-json", "web.url.to-json" ],
    toPrecision: [ "es.number.to-precision" ],
    toString: [ "es.object.to-string", "es.regexp.to-string", "es.date.to-string" ],
    trim: [ "es.string.trim" ],
    trimEnd: [ "es.string.trim-end" ],
    trimLeft: [ "es.string.trim-start" ],
    trimRight: [ "es.string.trim-end" ],
    trimStart: [ "es.string.trim-start" ],
    values: ArrayNatureIteratorsWithTag,
    __defineGetter__: [ "es.object.define-getter" ],
    __defineSetter__: [ "es.object.define-setter" ],
    __lookupGetter__: [ "es.object.lookup-getter" ],
    __lookupSetter__: [ "es.object.lookup-setter" ]
  };
  exports.InstanceProperties = InstanceProperties;
  const StaticProperties = {
    Array: {
      from: [ "es.array.from", "es.string.iterator" ],
      isArray: [ "es.array.is-array" ],
      of: [ "es.array.of" ]
    },
    Date: {
      now: "es.date.now"
    },
    Object: {
      assign: "es.object.assign",
      create: "es.object.create",
      defineProperty: "es.object.define-property",
      defineProperties: "es.object.define-properties",
      entries: "es.object.entries",
      freeze: "es.object.freeze",
      fromEntries: [ "es.object.from-entries", "es.array.iterator" ],
      getOwnPropertyDescriptor: "es.object.get-own-property-descriptor",
      getOwnPropertyDescriptors: "es.object.get-own-property-descriptors",
      getOwnPropertyNames: "es.object.get-own-property-names",
      getOwnPropertySymbols: "es.symbol",
      getPrototypeOf: "es.object.get-prototype-of",
      is: "es.object.is",
      isExtensible: "es.object.is-extensible",
      isFrozen: "es.object.is-frozen",
      isSealed: "es.object.is-sealed",
      keys: "es.object.keys",
      preventExtensions: "es.object.prevent-extensions",
      seal: "es.object.seal",
      setPrototypeOf: "es.object.set-prototype-of",
      values: "es.object.values"
    },
    Math: {
      DEG_PER_RAD: "esnext.math.deg-per-rad",
      RAD_PER_DEG: "esnext.math.rad-per-deg",
      acosh: "es.math.acosh",
      asinh: "es.math.asinh",
      atanh: "es.math.atanh",
      cbrt: "es.math.cbrt",
      clamp: "esnext.math.clamp",
      clz32: "es.math.clz32",
      cosh: "es.math.cosh",
      degrees: "esnext.math.degrees",
      expm1: "es.math.expm1",
      fround: "es.math.fround",
      fscale: "esnext.math.fscale",
      hypot: "es.math.hypot",
      iaddh: "esnext.math.iaddh",
      imul: "es.math.imul",
      imulh: "esnext.math.imulh",
      isubh: "esnext.math.isubh",
      log1p: "es.math.log1p",
      log10: "es.math.log10",
      log2: "es.math.log2",
      radians: "esnext.math.radians",
      scale: "esnext.math.scale",
      seededPRNG: "esnext.math.seeded-prng",
      sign: "es.math.sign",
      signbit: "esnext.math.signbit",
      sinh: "es.math.sinh",
      tanh: "es.math.tanh",
      trunc: "es.math.trunc",
      umulh: "esnext.math.umulh"
    },
    String: {
      fromCodePoint: "es.string.from-code-point",
      raw: "es.string.raw"
    },
    Number: {
      EPSILON: "es.number.epsilon",
      MIN_SAFE_INTEGER: "es.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es.number.max-safe-integer",
      fromString: "esnext.number.from-string",
      isFinite: "es.number.is-finite",
      isInteger: "es.number.is-integer",
      isSafeInteger: "es.number.is-safe-integer",
      isNaN: "es.number.is-nan",
      parseFloat: "es.number.parse-float",
      parseInt: "es.number.parse-int"
    },
    Map: {
      from: [ "esnext.map.from", ...MapDependencies ],
      groupBy: [ "esnext.map.group-by", ...MapDependencies ],
      keyBy: [ "esnext.map.key-by", ...MapDependencies ],
      of: [ "esnext.map.of", ...MapDependencies ]
    },
    Set: {
      from: [ "esnext.set.from", ...SetDependencies ],
      of: [ "esnext.set.of", ...SetDependencies ]
    },
    WeakMap: {
      from: [ "esnext.weak-map.from", ...WeakMapDependencies ],
      of: [ "esnext.weak-map.of", ...WeakMapDependencies ]
    },
    WeakSet: {
      from: [ "esnext.weak-set.from", ...WeakSetDependencies ],
      of: [ "esnext.weak-set.of", ...WeakSetDependencies ]
    },
    Promise: {
      all: PromiseDependenciesWithIterators,
      allSettled: [ "es.promise.all-settled", "esnext.promise.all-settled", ...PromiseDependenciesWithIterators ],
      any: [ "esnext.promise.any", "esnext.aggregate-error", ...PromiseDependenciesWithIterators ],
      race: PromiseDependenciesWithIterators,
      try: [ "esnext.promise.try", ...PromiseDependenciesWithIterators ]
    },
    Reflect: {
      apply: "es.reflect.apply",
      construct: "es.reflect.construct",
      defineMetadata: "esnext.reflect.define-metadata",
      defineProperty: "es.reflect.define-property",
      deleteMetadata: "esnext.reflect.delete-metadata",
      deleteProperty: "es.reflect.delete-property",
      get: "es.reflect.get",
      getMetadata: "esnext.reflect.get-metadata",
      getMetadataKeys: "esnext.reflect.get-metadata-keys",
      getOwnMetadata: "esnext.reflect.get-own-metadata",
      getOwnMetadataKeys: "esnext.reflect.get-own-metadata-keys",
      getOwnPropertyDescriptor: "es.reflect.get-own-property-descriptor",
      getPrototypeOf: "es.reflect.get-prototype-of",
      has: "es.reflect.has",
      hasMetadata: "esnext.reflect.has-metadata",
      hasOwnMetadata: "esnext.reflect.has-own-metadata",
      isExtensible: "es.reflect.is-extensible",
      metadata: "esnext.reflect.metadata",
      ownKeys: "es.reflect.own-keys",
      preventExtensions: "es.reflect.prevent-extensions",
      set: "es.reflect.set",
      setPrototypeOf: "es.reflect.set-prototype-of"
    },
    Symbol: {
      asyncIterator: [ "es.symbol.async-iterator" ],
      dispose: [ "esnext.symbol.dispose" ],
      hasInstance: [ "es.symbol.has-instance", "es.function.has-instance" ],
      isConcatSpreadable: [ "es.symbol.is-concat-spreadable", "es.array.concat" ],
      iterator: [ "es.symbol.iterator", ...CommonIteratorsWithTag ],
      match: [ "es.symbol.match", "es.string.match" ],
      observable: [ "esnext.symbol.observable" ],
      patternMatch: [ "esnext.symbol.pattern-match" ],
      replace: [ "es.symbol.replace", "es.string.replace" ],
      search: [ "es.symbol.search", "es.string.search" ],
      species: [ "es.symbol.species", "es.array.species" ],
      split: [ "es.symbol.split", "es.string.split" ],
      toPrimitive: [ "es.symbol.to-primitive", "es.date.to-primitive" ],
      toStringTag: [ "es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag" ],
      unscopables: [ "es.symbol.unscopables" ]
    },
    ArrayBuffer: {
      isView: [ "es.array-buffer.is-view" ]
    },
    Int8Array: TypedArrayStaticMethods,
    Uint8Array: TypedArrayStaticMethods,
    Uint8ClampedArray: TypedArrayStaticMethods,
    Int16Array: TypedArrayStaticMethods,
    Uint16Array: TypedArrayStaticMethods,
    Int32Array: TypedArrayStaticMethods,
    Uint32Array: TypedArrayStaticMethods,
    Float32Array: TypedArrayStaticMethods,
    Float64Array: TypedArrayStaticMethods
  };
  exports.StaticProperties = StaticProperties;
  const CommonInstanceDependencies = new Set([ "es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec" ]);
  exports.CommonInstanceDependencies = CommonInstanceDependencies;
  const PossibleGlobalObjects = new Set([ "global", "globalThis", "self", "window" ]);
  exports.PossibleGlobalObjects = PossibleGlobalObjects;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function() {
    return {
      name: "regenerator-usage",
      pre() {
        this.usesRegenerator = !1;
      },
      visitor: {
        Function(path) {
          const {node: node} = path;
          this.usesRegenerator || !node.generator && !node.async || (this.usesRegenerator = !0, 
          (0, _utils.createImport)(path, "regenerator-runtime"));
        }
      },
      post() {
        if (this.opts.debug && this.usesRegenerator) {
          let filename = this.file.opts.filename;
          "test" === process.env.BABEL_ENV && (filename = filename.replace(/\\/g, "/")), console.log(`\n[${filename}] Based on your code and targets, added regenerator-runtime.`);
        }
      }
    };
  };
  var _utils = __webpack_require__(18);
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(_, {include: include, exclude: exclude, polyfillTargets: polyfillTargets, regenerator: regenerator, debug: debug}) {
    const polyfills = (0, _helperCompilationTargets.filterItems)(_corejs2BuiltIns.default, include, exclude, polyfillTargets, (0, 
    _getPlatformSpecificDefault.default)(polyfillTargets));
    return {
      name: "corejs2-entry",
      visitor: {
        ImportDeclaration(path) {
          (0, _utils.isPolyfillSource)((0, _utils.getImportSource)(path)) && this.replaceBySeparateModulesImport(path);
        },
        Program(path) {
          path.get("body").forEach(bodyPath => {
            (0, _utils.isPolyfillSource)((0, _utils.getRequireSource)(bodyPath)) && this.replaceBySeparateModulesImport(bodyPath);
          });
        }
      },
      pre() {
        this.importPolyfillIncluded = !1, this.replaceBySeparateModulesImport = function(path) {
          this.importPolyfillIncluded = !0, regenerator && (0, _utils.createImport)(path, "regenerator-runtime");
          const modules = Array.from(polyfills).reverse();
          for (const module of modules) (0, _utils.createImport)(path, module);
          path.remove();
        };
      },
      post() {
        debug && (0, _debug.logEntryPolyfills)("@babel/polyfill", this.importPolyfillIncluded, polyfills, this.file.opts.filename, polyfillTargets, _corejs2BuiltIns.default);
      }
    };
  };
  var _corejs2BuiltIns = _interopRequireDefault(__webpack_require__(54)), _helperCompilationTargets = __webpack_require__(20), _getPlatformSpecificDefault = _interopRequireDefault(__webpack_require__(76)), _utils = __webpack_require__(18), _debug = __webpack_require__(24);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(_, {corejs: corejs, include: include, exclude: exclude, polyfillTargets: polyfillTargets, debug: debug}) {
    const polyfills = (0, _helperCompilationTargets.filterItems)(_data.default, include, exclude, polyfillTargets, null), available = new Set((0, 
    _getModulesListForTargetVersion.default)(corejs.version));
    function shouldReplace(source, modules) {
      return !!modules && (1 !== modules.length || !polyfills.has(modules[0]) || !available.has(modules[0]) || (0, 
      _utils.getModulePath)(modules[0]) !== source);
    }
    return {
      name: "corejs3-entry",
      visitor: {
        ImportDeclaration(path) {
          const source = (0, _utils.getImportSource)(path);
          if (source) if (isBabelPolyfillSource(source)) console.warn(BABEL_POLYFILL_DEPRECATION); else {
            const modules = isCoreJSSource(source);
            shouldReplace(source, modules) && this.replaceBySeparateModulesImport(path, modules);
          }
        },
        Program: {
          enter(path) {
            path.get("body").forEach(bodyPath => {
              const source = (0, _utils.getRequireSource)(bodyPath);
              if (source) if (isBabelPolyfillSource(source)) console.warn(BABEL_POLYFILL_DEPRECATION); else {
                const modules = isCoreJSSource(source);
                shouldReplace(source, modules) && this.replaceBySeparateModulesImport(bodyPath, modules);
              }
            });
          },
          exit(path) {
            const filtered = (0, _utils.intersection)(polyfills, this.polyfillsSet, available), reversed = Array.from(filtered).reverse();
            for (const module of reversed) this.injectedPolyfills.has(module) || (0, _utils.createImport)(path, module);
            filtered.forEach(module => this.injectedPolyfills.add(module));
          }
        }
      },
      pre() {
        this.injectedPolyfills = new Set, this.polyfillsSet = new Set, this.replaceBySeparateModulesImport = function(path, modules) {
          for (const module of modules) this.polyfillsSet.add(module);
          path.remove();
        };
      },
      post() {
        debug && (0, _debug.logEntryPolyfills)("core-js", this.injectedPolyfills.size > 0, this.injectedPolyfills, this.file.opts.filename, polyfillTargets, _data.default);
      }
    };
  };
  var _data = _interopRequireDefault(__webpack_require__(53)), _entries = _interopRequireDefault(__webpack_require__(493)), _getModulesListForTargetVersion = _interopRequireDefault(__webpack_require__(158)), _helperCompilationTargets = __webpack_require__(20), _utils = __webpack_require__(18), _debug = __webpack_require__(24);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function isBabelPolyfillSource(source) {
    return "@babel/polyfill" === source || "babel-polyfill" === source;
  }
  function isCoreJSSource(source) {
    return "string" == typeof source && (source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase()), 
    (0, _utils.has)(_entries.default, source) && _entries.default[source];
  }
  const BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
}, function(module) {
  module.exports = JSON.parse('{"core-js":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/es":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set"],"core-js/es/array":["es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.string.iterator"],"core-js/es/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/es/array-buffer/constructor":["es.array-buffer.constructor","es.object.to-string"],"core-js/es/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/es/array-buffer/slice":["es.array-buffer.slice"],"core-js/es/array/concat":["es.array.concat"],"core-js/es/array/copy-within":["es.array.copy-within"],"core-js/es/array/entries":["es.array.iterator"],"core-js/es/array/every":["es.array.every"],"core-js/es/array/fill":["es.array.fill"],"core-js/es/array/filter":["es.array.filter"],"core-js/es/array/find":["es.array.find"],"core-js/es/array/find-index":["es.array.find-index"],"core-js/es/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/es/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/es/array/for-each":["es.array.for-each"],"core-js/es/array/from":["es.array.from","es.string.iterator"],"core-js/es/array/includes":["es.array.includes"],"core-js/es/array/index-of":["es.array.index-of"],"core-js/es/array/is-array":["es.array.is-array"],"core-js/es/array/iterator":["es.array.iterator"],"core-js/es/array/join":["es.array.join"],"core-js/es/array/keys":["es.array.iterator"],"core-js/es/array/last-index-of":["es.array.last-index-of"],"core-js/es/array/map":["es.array.map"],"core-js/es/array/of":["es.array.of"],"core-js/es/array/reduce":["es.array.reduce"],"core-js/es/array/reduce-right":["es.array.reduce-right"],"core-js/es/array/reverse":["es.array.reverse"],"core-js/es/array/slice":["es.array.slice"],"core-js/es/array/some":["es.array.some"],"core-js/es/array/sort":["es.array.sort"],"core-js/es/array/splice":["es.array.splice"],"core-js/es/array/values":["es.array.iterator"],"core-js/es/array/virtual":["es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map"],"core-js/es/array/virtual/concat":["es.array.concat"],"core-js/es/array/virtual/copy-within":["es.array.copy-within"],"core-js/es/array/virtual/entries":["es.array.iterator"],"core-js/es/array/virtual/every":["es.array.every"],"core-js/es/array/virtual/fill":["es.array.fill"],"core-js/es/array/virtual/filter":["es.array.filter"],"core-js/es/array/virtual/find":["es.array.find"],"core-js/es/array/virtual/find-index":["es.array.find-index"],"core-js/es/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/es/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/es/array/virtual/for-each":["es.array.for-each"],"core-js/es/array/virtual/includes":["es.array.includes"],"core-js/es/array/virtual/index-of":["es.array.index-of"],"core-js/es/array/virtual/iterator":["es.array.iterator"],"core-js/es/array/virtual/join":["es.array.join"],"core-js/es/array/virtual/keys":["es.array.iterator"],"core-js/es/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/es/array/virtual/map":["es.array.map"],"core-js/es/array/virtual/reduce":["es.array.reduce"],"core-js/es/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/es/array/virtual/reverse":["es.array.reverse"],"core-js/es/array/virtual/slice":["es.array.slice"],"core-js/es/array/virtual/some":["es.array.some"],"core-js/es/array/virtual/sort":["es.array.sort"],"core-js/es/array/virtual/splice":["es.array.splice"],"core-js/es/array/virtual/values":["es.array.iterator"],"core-js/es/data-view":["es.data-view","es.object.to-string"],"core-js/es/date":["es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/es/date/now":["es.date.now"],"core-js/es/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/es/date/to-json":["es.date.to-json"],"core-js/es/date/to-primitive":["es.date.to-primitive"],"core-js/es/date/to-string":["es.date.to-string"],"core-js/es/function":["es.function.bind","es.function.has-instance","es.function.name"],"core-js/es/function/bind":["es.function.bind"],"core-js/es/function/has-instance":["es.function.has-instance"],"core-js/es/function/name":["es.function.name"],"core-js/es/function/virtual":["es.function.bind"],"core-js/es/function/virtual/bind":["es.function.bind"],"core-js/es/global-this":["es.global-this"],"core-js/es/instance/bind":["es.function.bind"],"core-js/es/instance/code-point-at":["es.string.code-point-at"],"core-js/es/instance/concat":["es.array.concat"],"core-js/es/instance/copy-within":["es.array.copy-within"],"core-js/es/instance/ends-with":["es.string.ends-with"],"core-js/es/instance/entries":["es.array.iterator"],"core-js/es/instance/every":["es.array.every"],"core-js/es/instance/fill":["es.array.fill"],"core-js/es/instance/filter":["es.array.filter"],"core-js/es/instance/find":["es.array.find"],"core-js/es/instance/find-index":["es.array.find-index"],"core-js/es/instance/flags":["es.regexp.flags"],"core-js/es/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/es/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/es/instance/for-each":["es.array.for-each"],"core-js/es/instance/includes":["es.array.includes","es.string.includes"],"core-js/es/instance/index-of":["es.array.index-of"],"core-js/es/instance/keys":["es.array.iterator"],"core-js/es/instance/last-index-of":["es.array.last-index-of"],"core-js/es/instance/map":["es.array.map"],"core-js/es/instance/match-all":["es.string.match-all"],"core-js/es/instance/pad-end":["es.string.pad-end"],"core-js/es/instance/pad-start":["es.string.pad-start"],"core-js/es/instance/reduce":["es.array.reduce"],"core-js/es/instance/reduce-right":["es.array.reduce-right"],"core-js/es/instance/repeat":["es.string.repeat"],"core-js/es/instance/reverse":["es.array.reverse"],"core-js/es/instance/slice":["es.array.slice"],"core-js/es/instance/some":["es.array.some"],"core-js/es/instance/sort":["es.array.sort"],"core-js/es/instance/splice":["es.array.splice"],"core-js/es/instance/starts-with":["es.string.starts-with"],"core-js/es/instance/trim":["es.string.trim"],"core-js/es/instance/trim-end":["es.string.trim-end"],"core-js/es/instance/trim-left":["es.string.trim-start"],"core-js/es/instance/trim-right":["es.string.trim-end"],"core-js/es/instance/trim-start":["es.string.trim-start"],"core-js/es/instance/values":["es.array.iterator"],"core-js/es/json":["es.json.stringify","es.json.to-string-tag"],"core-js/es/json/stringify":["es.json.stringify"],"core-js/es/json/to-string-tag":["es.json.to-string-tag"],"core-js/es/map":["es.map","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/es/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc"],"core-js/es/math/acosh":["es.math.acosh"],"core-js/es/math/asinh":["es.math.asinh"],"core-js/es/math/atanh":["es.math.atanh"],"core-js/es/math/cbrt":["es.math.cbrt"],"core-js/es/math/clz32":["es.math.clz32"],"core-js/es/math/cosh":["es.math.cosh"],"core-js/es/math/expm1":["es.math.expm1"],"core-js/es/math/fround":["es.math.fround"],"core-js/es/math/hypot":["es.math.hypot"],"core-js/es/math/imul":["es.math.imul"],"core-js/es/math/log10":["es.math.log10"],"core-js/es/math/log1p":["es.math.log1p"],"core-js/es/math/log2":["es.math.log2"],"core-js/es/math/sign":["es.math.sign"],"core-js/es/math/sinh":["es.math.sinh"],"core-js/es/math/tanh":["es.math.tanh"],"core-js/es/math/to-string-tag":["es.math.to-string-tag"],"core-js/es/math/trunc":["es.math.trunc"],"core-js/es/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision"],"core-js/es/number/constructor":["es.number.constructor"],"core-js/es/number/epsilon":["es.number.epsilon"],"core-js/es/number/is-finite":["es.number.is-finite"],"core-js/es/number/is-integer":["es.number.is-integer"],"core-js/es/number/is-nan":["es.number.is-nan"],"core-js/es/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/es/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/es/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/es/number/parse-float":["es.number.parse-float"],"core-js/es/number/parse-int":["es.number.parse-int"],"core-js/es/number/to-fixed":["es.number.to-fixed"],"core-js/es/number/to-precision":["es.number.to-precision"],"core-js/es/number/virtual":["es.number.to-fixed","es.number.to-precision"],"core-js/es/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/es/number/virtual/to-precision":["es.number.to-precision"],"core-js/es/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values"],"core-js/es/object/assign":["es.object.assign"],"core-js/es/object/create":["es.object.create"],"core-js/es/object/define-getter":["es.object.define-getter"],"core-js/es/object/define-properties":["es.object.define-properties"],"core-js/es/object/define-property":["es.object.define-property"],"core-js/es/object/define-setter":["es.object.define-setter"],"core-js/es/object/entries":["es.object.entries"],"core-js/es/object/freeze":["es.object.freeze"],"core-js/es/object/from-entries":["es.array.iterator","es.object.from-entries"],"core-js/es/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/es/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/es/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/es/object/get-own-property-symbols":["es.symbol"],"core-js/es/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/es/object/is":["es.object.is"],"core-js/es/object/is-extensible":["es.object.is-extensible"],"core-js/es/object/is-frozen":["es.object.is-frozen"],"core-js/es/object/is-sealed":["es.object.is-sealed"],"core-js/es/object/keys":["es.object.keys"],"core-js/es/object/lookup-getter":["es.object.lookup-setter"],"core-js/es/object/lookup-setter":["es.object.lookup-setter"],"core-js/es/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/es/object/seal":["es.object.seal"],"core-js/es/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/es/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/es/object/values":["es.object.values"],"core-js/es/parse-float":["es.parse-float"],"core-js/es/parse-int":["es.parse-int"],"core-js/es/promise":["es.object.to-string","es.promise","es.promise.all-settled","es.promise.finally","es.string.iterator","web.dom-collections.iterator"],"core-js/es/promise/all-settled":["es.promise","es.promise.all-settled"],"core-js/es/promise/finally":["es.promise","es.promise.finally"],"core-js/es/reflect":["es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of"],"core-js/es/reflect/apply":["es.reflect.apply"],"core-js/es/reflect/construct":["es.reflect.construct"],"core-js/es/reflect/define-property":["es.reflect.define-property"],"core-js/es/reflect/delete-property":["es.reflect.delete-property"],"core-js/es/reflect/get":["es.reflect.get"],"core-js/es/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/es/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/es/reflect/has":["es.reflect.has"],"core-js/es/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/es/reflect/own-keys":["es.reflect.own-keys"],"core-js/es/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/es/reflect/set":["es.reflect.set"],"core-js/es/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/es/regexp":["es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/es/regexp/constructor":["es.regexp.constructor"],"core-js/es/regexp/flags":["es.regexp.flags"],"core-js/es/regexp/match":["es.string.match"],"core-js/es/regexp/replace":["es.string.replace"],"core-js/es/regexp/search":["es.string.search"],"core-js/es/regexp/split":["es.string.split"],"core-js/es/regexp/sticky":["es.regexp.sticky"],"core-js/es/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/es/regexp/to-string":["es.regexp.to-string"],"core-js/es/set":["es.object.to-string","es.set","es.string.iterator","web.dom-collections.iterator"],"core-js/es/string":["es.regexp.exec","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/es/string/anchor":["es.string.anchor"],"core-js/es/string/big":["es.string.big"],"core-js/es/string/blink":["es.string.blink"],"core-js/es/string/bold":["es.string.bold"],"core-js/es/string/code-point-at":["es.string.code-point-at"],"core-js/es/string/ends-with":["es.string.ends-with"],"core-js/es/string/fixed":["es.string.fixed"],"core-js/es/string/fontcolor":["es.string.fontcolor"],"core-js/es/string/fontsize":["es.string.fontsize"],"core-js/es/string/from-code-point":["es.string.from-code-point"],"core-js/es/string/includes":["es.string.includes"],"core-js/es/string/italics":["es.string.italics"],"core-js/es/string/iterator":["es.string.iterator"],"core-js/es/string/link":["es.string.link"],"core-js/es/string/match":["es.regexp.exec","es.string.match"],"core-js/es/string/match-all":["es.string.match-all"],"core-js/es/string/pad-end":["es.string.pad-end"],"core-js/es/string/pad-start":["es.string.pad-start"],"core-js/es/string/raw":["es.string.raw"],"core-js/es/string/repeat":["es.string.repeat"],"core-js/es/string/replace":["es.regexp.exec","es.string.replace"],"core-js/es/string/search":["es.regexp.exec","es.string.search"],"core-js/es/string/small":["es.string.small"],"core-js/es/string/split":["es.regexp.exec","es.string.split"],"core-js/es/string/starts-with":["es.string.starts-with"],"core-js/es/string/strike":["es.string.strike"],"core-js/es/string/sub":["es.string.sub"],"core-js/es/string/sup":["es.string.sup"],"core-js/es/string/trim":["es.string.trim"],"core-js/es/string/trim-end":["es.string.trim-end"],"core-js/es/string/trim-left":["es.string.trim-start"],"core-js/es/string/trim-right":["es.string.trim-end"],"core-js/es/string/trim-start":["es.string.trim-start"],"core-js/es/string/virtual":["es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/es/string/virtual/anchor":["es.string.anchor"],"core-js/es/string/virtual/big":["es.string.big"],"core-js/es/string/virtual/blink":["es.string.blink"],"core-js/es/string/virtual/bold":["es.string.bold"],"core-js/es/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/es/string/virtual/ends-with":["es.string.ends-with"],"core-js/es/string/virtual/fixed":["es.string.fixed"],"core-js/es/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/es/string/virtual/fontsize":["es.string.fontsize"],"core-js/es/string/virtual/includes":["es.string.includes"],"core-js/es/string/virtual/italics":["es.string.italics"],"core-js/es/string/virtual/iterator":["es.string.iterator"],"core-js/es/string/virtual/link":["es.string.link"],"core-js/es/string/virtual/match-all":["es.string.match-all"],"core-js/es/string/virtual/pad-end":["es.string.pad-end"],"core-js/es/string/virtual/pad-start":["es.string.pad-start"],"core-js/es/string/virtual/repeat":["es.string.repeat"],"core-js/es/string/virtual/small":["es.string.small"],"core-js/es/string/virtual/starts-with":["es.string.starts-with"],"core-js/es/string/virtual/strike":["es.string.strike"],"core-js/es/string/virtual/sub":["es.string.sub"],"core-js/es/string/virtual/sup":["es.string.sup"],"core-js/es/string/virtual/trim":["es.string.trim"],"core-js/es/string/virtual/trim-end":["es.string.trim-end"],"core-js/es/string/virtual/trim-left":["es.string.trim-start"],"core-js/es/string/virtual/trim-right":["es.string.trim-end"],"core-js/es/string/virtual/trim-start":["es.string.trim-start"],"core-js/es/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/es/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/es/symbol/description":["es.symbol.description"],"core-js/es/symbol/for":["es.symbol"],"core-js/es/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/es/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/es/symbol/iterator":["es.symbol.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/es/symbol/key-for":["es.symbol"],"core-js/es/symbol/match":["es.symbol.match","es.string.match"],"core-js/es/symbol/match-all":["es.symbol.match-all","es.string.match-all"],"core-js/es/symbol/replace":["es.symbol.replace","es.string.replace"],"core-js/es/symbol/search":["es.symbol.search","es.string.search"],"core-js/es/symbol/species":["es.symbol.species"],"core-js/es/symbol/split":["es.symbol.split","es.string.split"],"core-js/es/symbol/to-primitive":["es.symbol.to-primitive"],"core-js/es/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/es/symbol/unscopables":["es.symbol.unscopables"],"core-js/es/typed-array":["es.object.to-string","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/es/typed-array/entries":["es.typed-array.iterator"],"core-js/es/typed-array/every":["es.typed-array.every"],"core-js/es/typed-array/fill":["es.typed-array.fill"],"core-js/es/typed-array/filter":["es.typed-array.filter"],"core-js/es/typed-array/find":["es.typed-array.find"],"core-js/es/typed-array/find-index":["es.typed-array.find-index"],"core-js/es/typed-array/float32-array":["es.object.to-string","es.typed-array.float32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/float64-array":["es.object.to-string","es.typed-array.float64-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/for-each":["es.typed-array.for-each"],"core-js/es/typed-array/from":["es.typed-array.from"],"core-js/es/typed-array/includes":["es.typed-array.includes"],"core-js/es/typed-array/index-of":["es.typed-array.index-of"],"core-js/es/typed-array/int16-array":["es.object.to-string","es.typed-array.int16-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/int32-array":["es.object.to-string","es.typed-array.int32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/int8-array":["es.object.to-string","es.typed-array.int8-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/iterator":["es.typed-array.iterator"],"core-js/es/typed-array/join":["es.typed-array.join"],"core-js/es/typed-array/keys":["es.typed-array.iterator"],"core-js/es/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/es/typed-array/map":["es.typed-array.map"],"core-js/es/typed-array/methods":["es.object.to-string","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/of":["es.typed-array.of"],"core-js/es/typed-array/reduce":["es.typed-array.reduce"],"core-js/es/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/es/typed-array/reverse":["es.typed-array.reverse"],"core-js/es/typed-array/set":["es.typed-array.set"],"core-js/es/typed-array/slice":["es.typed-array.slice"],"core-js/es/typed-array/some":["es.typed-array.some"],"core-js/es/typed-array/sort":["es.typed-array.sort"],"core-js/es/typed-array/subarray":["es.typed-array.subarray"],"core-js/es/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/es/typed-array/to-string":["es.typed-array.to-string"],"core-js/es/typed-array/uint16-array":["es.object.to-string","es.typed-array.uint16-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/uint32-array":["es.object.to-string","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/uint8-array":["es.object.to-string","es.typed-array.uint8-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/uint8-clamped-array":["es.object.to-string","es.typed-array.uint8-clamped-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/es/typed-array/values":["es.typed-array.iterator"],"core-js/es/weak-map":["es.object.to-string","es.weak-map","web.dom-collections.iterator"],"core-js/es/weak-set":["es.object.to-string","es.weak-set","web.dom-collections.iterator"],"core-js/features":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set","esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/features/aggregate-error":["es.string.iterator","esnext.aggregate-error","web.dom-collections.iterator"],"core-js/features/array":["es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.string.iterator","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item"],"core-js/features/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/features/array-buffer/constructor":["es.array-buffer.constructor","es.object.to-string"],"core-js/features/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/features/array-buffer/slice":["es.array-buffer.slice"],"core-js/features/array/concat":["es.array.concat"],"core-js/features/array/copy-within":["es.array.copy-within"],"core-js/features/array/entries":["es.array.iterator"],"core-js/features/array/every":["es.array.every"],"core-js/features/array/fill":["es.array.fill"],"core-js/features/array/filter":["es.array.filter"],"core-js/features/array/find":["es.array.find"],"core-js/features/array/find-index":["es.array.find-index"],"core-js/features/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/features/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/features/array/for-each":["es.array.for-each"],"core-js/features/array/from":["es.array.from","es.string.iterator"],"core-js/features/array/includes":["es.array.includes"],"core-js/features/array/index-of":["es.array.index-of"],"core-js/features/array/is-array":["es.array.is-array"],"core-js/features/array/is-template-object":["esnext.array.is-template-object"],"core-js/features/array/iterator":["es.array.iterator"],"core-js/features/array/join":["es.array.join"],"core-js/features/array/keys":["es.array.iterator"],"core-js/features/array/last-index":["esnext.array.last-index"],"core-js/features/array/last-index-of":["es.array.last-index-of"],"core-js/features/array/last-item":["esnext.array.last-item"],"core-js/features/array/map":["es.array.map"],"core-js/features/array/of":["es.array.of"],"core-js/features/array/reduce":["es.array.reduce"],"core-js/features/array/reduce-right":["es.array.reduce-right"],"core-js/features/array/reverse":["es.array.reverse"],"core-js/features/array/slice":["es.array.slice"],"core-js/features/array/some":["es.array.some"],"core-js/features/array/sort":["es.array.sort"],"core-js/features/array/splice":["es.array.splice"],"core-js/features/array/values":["es.array.iterator"],"core-js/features/array/virtual":["es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map"],"core-js/features/array/virtual/concat":["es.array.concat"],"core-js/features/array/virtual/copy-within":["es.array.copy-within"],"core-js/features/array/virtual/entries":["es.array.iterator"],"core-js/features/array/virtual/every":["es.array.every"],"core-js/features/array/virtual/fill":["es.array.fill"],"core-js/features/array/virtual/filter":["es.array.filter"],"core-js/features/array/virtual/find":["es.array.find"],"core-js/features/array/virtual/find-index":["es.array.find-index"],"core-js/features/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/features/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/features/array/virtual/for-each":["es.array.for-each"],"core-js/features/array/virtual/includes":["es.array.includes"],"core-js/features/array/virtual/index-of":["es.array.index-of"],"core-js/features/array/virtual/iterator":["es.array.iterator"],"core-js/features/array/virtual/join":["es.array.join"],"core-js/features/array/virtual/keys":["es.array.iterator"],"core-js/features/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/features/array/virtual/map":["es.array.map"],"core-js/features/array/virtual/reduce":["es.array.reduce"],"core-js/features/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/features/array/virtual/reverse":["es.array.reverse"],"core-js/features/array/virtual/slice":["es.array.slice"],"core-js/features/array/virtual/some":["es.array.some"],"core-js/features/array/virtual/sort":["es.array.sort"],"core-js/features/array/virtual/splice":["es.array.splice"],"core-js/features/array/virtual/values":["es.array.iterator"],"core-js/features/async-iterator":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","web.dom-collections.iterator"],"core-js/features/async-iterator/as-indexed-pairs":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","web.dom-collections.iterator"],"core-js/features/async-iterator/drop":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.drop","web.dom-collections.iterator"],"core-js/features/async-iterator/every":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.every","web.dom-collections.iterator"],"core-js/features/async-iterator/filter":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.filter","web.dom-collections.iterator"],"core-js/features/async-iterator/find":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.find","web.dom-collections.iterator"],"core-js/features/async-iterator/flat-map":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.flat-map","web.dom-collections.iterator"],"core-js/features/async-iterator/for-each":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.for-each","web.dom-collections.iterator"],"core-js/features/async-iterator/from":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.from","web.dom-collections.iterator"],"core-js/features/async-iterator/map":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.map","web.dom-collections.iterator"],"core-js/features/async-iterator/reduce":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.reduce","web.dom-collections.iterator"],"core-js/features/async-iterator/some":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.some","web.dom-collections.iterator"],"core-js/features/async-iterator/take":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.take","web.dom-collections.iterator"],"core-js/features/async-iterator/to-array":["es.object.to-string","es.promise","es.string.iterator","esnext.async-iterator.constructor","esnext.async-iterator.to-array","web.dom-collections.iterator"],"core-js/features/clear-immediate":["web.immediate"],"core-js/features/composite-key":["esnext.composite-key"],"core-js/features/composite-symbol":["es.symbol","esnext.composite-symbol"],"core-js/features/data-view":["es.data-view","es.object.to-string"],"core-js/features/date":["es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/features/date/now":["es.date.now"],"core-js/features/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/features/date/to-json":["es.date.to-json"],"core-js/features/date/to-primitive":["es.date.to-primitive"],"core-js/features/date/to-string":["es.date.to-string"],"core-js/features/dom-collections":["es.array.iterator","web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/features/dom-collections/for-each":["web.dom-collections.for-each"],"core-js/features/dom-collections/iterator":["web.dom-collections.iterator"],"core-js/features/function":["es.function.bind","es.function.has-instance","es.function.name"],"core-js/features/function/bind":["es.function.bind"],"core-js/features/function/has-instance":["es.function.has-instance"],"core-js/features/function/name":["es.function.name"],"core-js/features/function/virtual":["es.function.bind"],"core-js/features/function/virtual/bind":["es.function.bind"],"core-js/features/get-iterator":["es.string.iterator","web.dom-collections.iterator"],"core-js/features/get-iterator-method":["es.string.iterator","web.dom-collections.iterator"],"core-js/features/global-this":["es.global-this","esnext.global-this"],"core-js/features/instance/at":["esnext.string.at"],"core-js/features/instance/bind":["es.function.bind"],"core-js/features/instance/code-point-at":["es.string.code-point-at"],"core-js/features/instance/code-points":["esnext.string.code-points"],"core-js/features/instance/concat":["es.array.concat"],"core-js/features/instance/copy-within":["es.array.copy-within"],"core-js/features/instance/ends-with":["es.string.ends-with"],"core-js/features/instance/entries":["es.array.iterator","web.dom-collections.iterator"],"core-js/features/instance/every":["es.array.every"],"core-js/features/instance/fill":["es.array.fill"],"core-js/features/instance/filter":["es.array.filter"],"core-js/features/instance/find":["es.array.find"],"core-js/features/instance/find-index":["es.array.find-index"],"core-js/features/instance/flags":["es.regexp.flags"],"core-js/features/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/features/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/features/instance/for-each":["es.array.for-each","web.dom-collections.iterator"],"core-js/features/instance/includes":["es.array.includes","es.string.includes"],"core-js/features/instance/index-of":["es.array.index-of"],"core-js/features/instance/keys":["es.array.iterator","web.dom-collections.iterator"],"core-js/features/instance/last-index-of":["es.array.last-index-of"],"core-js/features/instance/map":["es.array.map"],"core-js/features/instance/match-all":["es.string.match-all","esnext.string.match-all"],"core-js/features/instance/pad-end":["es.string.pad-end"],"core-js/features/instance/pad-start":["es.string.pad-start"],"core-js/features/instance/reduce":["es.array.reduce"],"core-js/features/instance/reduce-right":["es.array.reduce-right"],"core-js/features/instance/repeat":["es.string.repeat"],"core-js/features/instance/replace-all":["esnext.string.replace-all"],"core-js/features/instance/reverse":["es.array.reverse"],"core-js/features/instance/slice":["es.array.slice"],"core-js/features/instance/some":["es.array.some"],"core-js/features/instance/sort":["es.array.sort"],"core-js/features/instance/splice":["es.array.splice"],"core-js/features/instance/starts-with":["es.string.starts-with"],"core-js/features/instance/trim":["es.string.trim"],"core-js/features/instance/trim-end":["es.string.trim-end"],"core-js/features/instance/trim-left":["es.string.trim-start"],"core-js/features/instance/trim-right":["es.string.trim-end"],"core-js/features/instance/trim-start":["es.string.trim-start"],"core-js/features/instance/values":["es.array.iterator","web.dom-collections.iterator"],"core-js/features/is-iterable":["es.string.iterator","web.dom-collections.iterator"],"core-js/features/iterator":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","web.dom-collections.iterator"],"core-js/features/iterator/as-indexed-pairs":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","web.dom-collections.iterator"],"core-js/features/iterator/drop":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.drop","web.dom-collections.iterator"],"core-js/features/iterator/every":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.every","web.dom-collections.iterator"],"core-js/features/iterator/filter":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.filter","web.dom-collections.iterator"],"core-js/features/iterator/find":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.find","web.dom-collections.iterator"],"core-js/features/iterator/flat-map":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.flat-map","web.dom-collections.iterator"],"core-js/features/iterator/for-each":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.for-each","web.dom-collections.iterator"],"core-js/features/iterator/from":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.from","web.dom-collections.iterator"],"core-js/features/iterator/map":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.map","web.dom-collections.iterator"],"core-js/features/iterator/reduce":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.reduce","web.dom-collections.iterator"],"core-js/features/iterator/some":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.some","web.dom-collections.iterator"],"core-js/features/iterator/take":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.take","web.dom-collections.iterator"],"core-js/features/iterator/to-array":["es.object.to-string","es.string.iterator","esnext.iterator.constructor","esnext.iterator.to-array","web.dom-collections.iterator"],"core-js/features/json":["es.json.stringify","es.json.to-string-tag"],"core-js/features/json/stringify":["es.json.stringify"],"core-js/features/json/to-string-tag":["es.json.to-string-tag"],"core-js/features/map":["es.map","es.object.to-string","es.string.iterator","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","web.dom-collections.iterator"],"core-js/features/map/delete-all":["es.map","esnext.map.delete-all"],"core-js/features/map/every":["es.map","esnext.map.every"],"core-js/features/map/filter":["es.map","esnext.map.filter"],"core-js/features/map/find":["es.map","esnext.map.find"],"core-js/features/map/find-key":["es.map","esnext.map.find-key"],"core-js/features/map/from":["es.map","es.string.iterator","esnext.map.from","web.dom-collections.iterator"],"core-js/features/map/group-by":["es.map","esnext.map.group-by"],"core-js/features/map/includes":["es.map","esnext.map.includes"],"core-js/features/map/key-by":["es.map","esnext.map.key-by"],"core-js/features/map/key-of":["es.map","esnext.map.key-of"],"core-js/features/map/map-keys":["es.map","esnext.map.map-keys"],"core-js/features/map/map-values":["es.map","esnext.map.map-values"],"core-js/features/map/merge":["es.map","esnext.map.merge"],"core-js/features/map/of":["es.map","es.string.iterator","esnext.map.of","web.dom-collections.iterator"],"core-js/features/map/reduce":["es.map","esnext.map.reduce"],"core-js/features/map/some":["es.map","esnext.map.some"],"core-js/features/map/update":["es.map","esnext.map.update"],"core-js/features/map/update-or-insert":["es.map","esnext.map.update-or-insert"],"core-js/features/map/upsert":["es.map","esnext.map.upsert"],"core-js/features/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh"],"core-js/features/math/acosh":["es.math.acosh"],"core-js/features/math/asinh":["es.math.asinh"],"core-js/features/math/atanh":["es.math.atanh"],"core-js/features/math/cbrt":["es.math.cbrt"],"core-js/features/math/clamp":["esnext.math.clamp"],"core-js/features/math/clz32":["es.math.clz32"],"core-js/features/math/cosh":["es.math.cosh"],"core-js/features/math/deg-per-rad":["esnext.math.deg-per-rad"],"core-js/features/math/degrees":["esnext.math.degrees"],"core-js/features/math/expm1":["es.math.expm1"],"core-js/features/math/fround":["es.math.fround"],"core-js/features/math/fscale":["esnext.math.fscale"],"core-js/features/math/hypot":["es.math.hypot"],"core-js/features/math/iaddh":["esnext.math.iaddh"],"core-js/features/math/imul":["es.math.imul"],"core-js/features/math/imulh":["esnext.math.imulh"],"core-js/features/math/isubh":["esnext.math.isubh"],"core-js/features/math/log10":["es.math.log10"],"core-js/features/math/log1p":["es.math.log1p"],"core-js/features/math/log2":["es.math.log2"],"core-js/features/math/rad-per-deg":["esnext.math.rad-per-deg"],"core-js/features/math/radians":["esnext.math.radians"],"core-js/features/math/scale":["esnext.math.scale"],"core-js/features/math/seeded-prng":["esnext.math.seeded-prng"],"core-js/features/math/sign":["es.math.sign"],"core-js/features/math/signbit":["esnext.math.signbit"],"core-js/features/math/sinh":["es.math.sinh"],"core-js/features/math/tanh":["es.math.tanh"],"core-js/features/math/to-string-tag":["es.math.to-string-tag"],"core-js/features/math/trunc":["es.math.trunc"],"core-js/features/math/umulh":["esnext.math.umulh"],"core-js/features/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","esnext.number.from-string"],"core-js/features/number/constructor":["es.number.constructor"],"core-js/features/number/epsilon":["es.number.epsilon"],"core-js/features/number/from-string":["esnext.number.from-string"],"core-js/features/number/is-finite":["es.number.is-finite"],"core-js/features/number/is-integer":["es.number.is-integer"],"core-js/features/number/is-nan":["es.number.is-nan"],"core-js/features/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/features/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/features/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/features/number/parse-float":["es.number.parse-float"],"core-js/features/number/parse-int":["es.number.parse-int"],"core-js/features/number/to-fixed":["es.number.to-fixed"],"core-js/features/number/to-precision":["es.number.to-precision"],"core-js/features/number/virtual":["es.number.to-fixed","es.number.to-precision"],"core-js/features/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/features/number/virtual/to-precision":["es.number.to-precision"],"core-js/features/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values"],"core-js/features/object/assign":["es.object.assign"],"core-js/features/object/create":["es.object.create"],"core-js/features/object/define-getter":["es.object.define-getter"],"core-js/features/object/define-properties":["es.object.define-properties"],"core-js/features/object/define-property":["es.object.define-property"],"core-js/features/object/define-setter":["es.object.define-setter"],"core-js/features/object/entries":["es.object.entries"],"core-js/features/object/freeze":["es.object.freeze"],"core-js/features/object/from-entries":["es.array.iterator","es.object.from-entries"],"core-js/features/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/features/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/features/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/features/object/get-own-property-symbols":["es.symbol"],"core-js/features/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/features/object/is":["es.object.is"],"core-js/features/object/is-extensible":["es.object.is-extensible"],"core-js/features/object/is-frozen":["es.object.is-frozen"],"core-js/features/object/is-sealed":["es.object.is-sealed"],"core-js/features/object/iterate-entries":["esnext.object.iterate-entries"],"core-js/features/object/iterate-keys":["esnext.object.iterate-keys"],"core-js/features/object/iterate-values":["esnext.object.iterate-values"],"core-js/features/object/keys":["es.object.keys"],"core-js/features/object/lookup-getter":["es.object.lookup-setter"],"core-js/features/object/lookup-setter":["es.object.lookup-setter"],"core-js/features/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/features/object/seal":["es.object.seal"],"core-js/features/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/features/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/features/object/values":["es.object.values"],"core-js/features/observable":["es.object.to-string","es.string.iterator","esnext.observable","esnext.symbol.observable","web.dom-collections.iterator"],"core-js/features/parse-float":["es.parse-float"],"core-js/features/parse-int":["es.parse-int"],"core-js/features/promise":["es.object.to-string","es.promise","es.promise.all-settled","es.promise.finally","es.string.iterator","esnext.aggregate-error","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","web.dom-collections.iterator"],"core-js/features/promise/all-settled":["es.promise","es.promise.all-settled","esnext.promise.all-settled"],"core-js/features/promise/any":["es.promise","esnext.aggregate-error","esnext.promise.any"],"core-js/features/promise/finally":["es.promise","es.promise.finally"],"core-js/features/promise/try":["es.promise","esnext.promise.try"],"core-js/features/queue-microtask":["web.queue-microtask"],"core-js/features/reflect":["es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata"],"core-js/features/reflect/apply":["es.reflect.apply"],"core-js/features/reflect/construct":["es.reflect.construct"],"core-js/features/reflect/define-metadata":["esnext.reflect.define-metadata"],"core-js/features/reflect/define-property":["es.reflect.define-property"],"core-js/features/reflect/delete-metadata":["esnext.reflect.delete-metadata"],"core-js/features/reflect/delete-property":["es.reflect.delete-property"],"core-js/features/reflect/get":["es.reflect.get"],"core-js/features/reflect/get-metadata":["esnext.reflect.get-metadata"],"core-js/features/reflect/get-metadata-keys":["esnext.reflect.get-metadata-keys"],"core-js/features/reflect/get-own-metadata":["esnext.reflect.get-own-metadata"],"core-js/features/reflect/get-own-metadata-keys":["esnext.reflect.get-own-metadata-keys"],"core-js/features/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/features/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/features/reflect/has":["es.reflect.has"],"core-js/features/reflect/has-metadata":["esnext.reflect.has-metadata"],"core-js/features/reflect/has-own-metadata":["esnext.reflect.has-own-metadata"],"core-js/features/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/features/reflect/metadata":["esnext.reflect.metadata"],"core-js/features/reflect/own-keys":["es.reflect.own-keys"],"core-js/features/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/features/reflect/set":["es.reflect.set"],"core-js/features/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/features/regexp":["es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/features/regexp/constructor":["es.regexp.constructor"],"core-js/features/regexp/flags":["es.regexp.flags"],"core-js/features/regexp/match":["es.string.match"],"core-js/features/regexp/replace":["es.string.replace"],"core-js/features/regexp/search":["es.string.search"],"core-js/features/regexp/split":["es.string.split"],"core-js/features/regexp/sticky":["es.regexp.sticky"],"core-js/features/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/features/regexp/to-string":["es.regexp.to-string"],"core-js/features/set":["es.object.to-string","es.set","es.string.iterator","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","web.dom-collections.iterator"],"core-js/features/set-immediate":["web.immediate"],"core-js/features/set-interval":["web.timers"],"core-js/features/set-timeout":["web.timers"],"core-js/features/set/add-all":["es.set","esnext.set.add-all"],"core-js/features/set/delete-all":["es.set","esnext.set.delete-all"],"core-js/features/set/difference":["es.set","es.string.iterator","esnext.set.difference","web.dom-collections.iterator"],"core-js/features/set/every":["es.set","esnext.set.every"],"core-js/features/set/filter":["es.set","esnext.set.filter"],"core-js/features/set/find":["es.set","esnext.set.find"],"core-js/features/set/from":["es.set","es.string.iterator","esnext.set.from","web.dom-collections.iterator"],"core-js/features/set/intersection":["es.set","esnext.set.intersection"],"core-js/features/set/is-disjoint-from":["es.set","esnext.set.is-disjoint-from"],"core-js/features/set/is-subset-of":["es.set","es.string.iterator","esnext.set.is-subset-of","web.dom-collections.iterator"],"core-js/features/set/is-superset-of":["es.set","esnext.set.is-superset-of"],"core-js/features/set/join":["es.set","esnext.set.join"],"core-js/features/set/map":["es.set","esnext.set.map"],"core-js/features/set/of":["es.set","es.string.iterator","esnext.set.of","web.dom-collections.iterator"],"core-js/features/set/reduce":["es.set","esnext.set.reduce"],"core-js/features/set/some":["es.set","esnext.set.some"],"core-js/features/set/symmetric-difference":["es.set","es.string.iterator","esnext.set.symmetric-difference","web.dom-collections.iterator"],"core-js/features/set/union":["es.set","es.string.iterator","esnext.set.union","web.dom-collections.iterator"],"core-js/features/string":["es.regexp.exec","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all"],"core-js/features/string/anchor":["es.string.anchor"],"core-js/features/string/at":["esnext.string.at"],"core-js/features/string/big":["es.string.big"],"core-js/features/string/blink":["es.string.blink"],"core-js/features/string/bold":["es.string.bold"],"core-js/features/string/code-point-at":["es.string.code-point-at"],"core-js/features/string/code-points":["esnext.string.code-points"],"core-js/features/string/ends-with":["es.string.ends-with"],"core-js/features/string/fixed":["es.string.fixed"],"core-js/features/string/fontcolor":["es.string.fontcolor"],"core-js/features/string/fontsize":["es.string.fontsize"],"core-js/features/string/from-code-point":["es.string.from-code-point"],"core-js/features/string/includes":["es.string.includes"],"core-js/features/string/italics":["es.string.italics"],"core-js/features/string/iterator":["es.string.iterator"],"core-js/features/string/link":["es.string.link"],"core-js/features/string/match":["es.regexp.exec","es.string.match"],"core-js/features/string/match-all":["es.string.match-all","esnext.string.match-all"],"core-js/features/string/pad-end":["es.string.pad-end"],"core-js/features/string/pad-start":["es.string.pad-start"],"core-js/features/string/raw":["es.string.raw"],"core-js/features/string/repeat":["es.string.repeat"],"core-js/features/string/replace":["es.regexp.exec","es.string.replace"],"core-js/features/string/replace-all":["esnext.string.replace-all"],"core-js/features/string/search":["es.regexp.exec","es.string.search"],"core-js/features/string/small":["es.string.small"],"core-js/features/string/split":["es.regexp.exec","es.string.split"],"core-js/features/string/starts-with":["es.string.starts-with"],"core-js/features/string/strike":["es.string.strike"],"core-js/features/string/sub":["es.string.sub"],"core-js/features/string/sup":["es.string.sup"],"core-js/features/string/trim":["es.string.trim"],"core-js/features/string/trim-end":["es.string.trim-end"],"core-js/features/string/trim-left":["es.string.trim-start"],"core-js/features/string/trim-right":["es.string.trim-end"],"core-js/features/string/trim-start":["es.string.trim-start"],"core-js/features/string/virtual":["es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all"],"core-js/features/string/virtual/anchor":["es.string.anchor"],"core-js/features/string/virtual/at":["esnext.string.at"],"core-js/features/string/virtual/big":["es.string.big"],"core-js/features/string/virtual/blink":["es.string.blink"],"core-js/features/string/virtual/bold":["es.string.bold"],"core-js/features/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/features/string/virtual/code-points":["esnext.string.code-points"],"core-js/features/string/virtual/ends-with":["es.string.ends-with"],"core-js/features/string/virtual/fixed":["es.string.fixed"],"core-js/features/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/features/string/virtual/fontsize":["es.string.fontsize"],"core-js/features/string/virtual/includes":["es.string.includes"],"core-js/features/string/virtual/italics":["es.string.italics"],"core-js/features/string/virtual/iterator":["es.string.iterator"],"core-js/features/string/virtual/link":["es.string.link"],"core-js/features/string/virtual/match-all":["es.string.match-all","esnext.string.match-all"],"core-js/features/string/virtual/pad-end":["es.string.pad-end"],"core-js/features/string/virtual/pad-start":["es.string.pad-start"],"core-js/features/string/virtual/repeat":["es.string.repeat"],"core-js/features/string/virtual/replace-all":["esnext.string.replace-all"],"core-js/features/string/virtual/small":["es.string.small"],"core-js/features/string/virtual/starts-with":["es.string.starts-with"],"core-js/features/string/virtual/strike":["es.string.strike"],"core-js/features/string/virtual/sub":["es.string.sub"],"core-js/features/string/virtual/sup":["es.string.sup"],"core-js/features/string/virtual/trim":["es.string.trim"],"core-js/features/string/virtual/trim-end":["es.string.trim-end"],"core-js/features/string/virtual/trim-left":["es.string.trim-start"],"core-js/features/string/virtual/trim-right":["es.string.trim-end"],"core-js/features/string/virtual/trim-start":["es.string.trim-start"],"core-js/features/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all"],"core-js/features/symbol/async-dispose":["esnext.symbol.async-dispose"],"core-js/features/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/features/symbol/description":["es.symbol.description"],"core-js/features/symbol/dispose":["esnext.symbol.dispose"],"core-js/features/symbol/for":["es.symbol"],"core-js/features/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/features/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/features/symbol/iterator":["es.symbol.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/features/symbol/key-for":["es.symbol"],"core-js/features/symbol/match":["es.symbol.match","es.string.match"],"core-js/features/symbol/match-all":["es.symbol.match-all","es.string.match-all"],"core-js/features/symbol/observable":["esnext.symbol.observable"],"core-js/features/symbol/pattern-match":["esnext.symbol.pattern-match"],"core-js/features/symbol/replace":["es.symbol.replace","es.string.replace"],"core-js/features/symbol/replace-all":["esnext.symbol.replace-all"],"core-js/features/symbol/search":["es.symbol.search","es.string.search"],"core-js/features/symbol/species":["es.symbol.species"],"core-js/features/symbol/split":["es.symbol.split","es.string.split"],"core-js/features/symbol/to-primitive":["es.symbol.to-primitive"],"core-js/features/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/features/symbol/unscopables":["es.symbol.unscopables"],"core-js/features/typed-array":["es.object.to-string","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/features/typed-array/entries":["es.typed-array.iterator"],"core-js/features/typed-array/every":["es.typed-array.every"],"core-js/features/typed-array/fill":["es.typed-array.fill"],"core-js/features/typed-array/filter":["es.typed-array.filter"],"core-js/features/typed-array/find":["es.typed-array.find"],"core-js/features/typed-array/find-index":["es.typed-array.find-index"],"core-js/features/typed-array/float32-array":["es.object.to-string","es.typed-array.float32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/float64-array":["es.object.to-string","es.typed-array.float64-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/for-each":["es.typed-array.for-each"],"core-js/features/typed-array/from":["es.typed-array.from"],"core-js/features/typed-array/includes":["es.typed-array.includes"],"core-js/features/typed-array/index-of":["es.typed-array.index-of"],"core-js/features/typed-array/int16-array":["es.object.to-string","es.typed-array.int16-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/int32-array":["es.object.to-string","es.typed-array.int32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/int8-array":["es.object.to-string","es.typed-array.int8-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/iterator":["es.typed-array.iterator"],"core-js/features/typed-array/join":["es.typed-array.join"],"core-js/features/typed-array/keys":["es.typed-array.iterator"],"core-js/features/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/features/typed-array/map":["es.typed-array.map"],"core-js/features/typed-array/of":["es.typed-array.of"],"core-js/features/typed-array/reduce":["es.typed-array.reduce"],"core-js/features/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/features/typed-array/reverse":["es.typed-array.reverse"],"core-js/features/typed-array/set":["es.typed-array.set"],"core-js/features/typed-array/slice":["es.typed-array.slice"],"core-js/features/typed-array/some":["es.typed-array.some"],"core-js/features/typed-array/sort":["es.typed-array.sort"],"core-js/features/typed-array/subarray":["es.typed-array.subarray"],"core-js/features/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/features/typed-array/to-string":["es.typed-array.to-string"],"core-js/features/typed-array/uint16-array":["es.object.to-string","es.typed-array.uint16-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/uint32-array":["es.object.to-string","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/uint8-array":["es.object.to-string","es.typed-array.uint8-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/uint8-clamped-array":["es.object.to-string","es.typed-array.uint8-clamped-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/features/typed-array/values":["es.typed-array.iterator"],"core-js/features/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/features/url-search-params":["web.url-search-params"],"core-js/features/url/to-json":["web.url.to-json"],"core-js/features/weak-map":["es.object.to-string","es.weak-map","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","web.dom-collections.iterator"],"core-js/features/weak-map/delete-all":["es.weak-map","esnext.weak-map.delete-all"],"core-js/features/weak-map/from":["es.string.iterator","es.weak-map","esnext.weak-map.from","web.dom-collections.iterator"],"core-js/features/weak-map/of":["es.string.iterator","es.weak-map","esnext.weak-map.of","web.dom-collections.iterator"],"core-js/features/weak-map/upsert":["es.weak-map","esnext.weak-map.upsert"],"core-js/features/weak-set":["es.object.to-string","es.weak-set","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.dom-collections.iterator"],"core-js/features/weak-set/add-all":["es.weak-set","esnext.weak-set.add-all"],"core-js/features/weak-set/delete-all":["es.weak-set","esnext.weak-set.delete-all"],"core-js/features/weak-set/from":["es.string.iterator","es.weak-set","esnext.weak-set.from","web.dom-collections.iterator"],"core-js/features/weak-set/of":["es.string.iterator","es.weak-set","esnext.weak-set.of","web.dom-collections.iterator"],"core-js/modules/es.array-buffer.constructor":["es.array-buffer.constructor"],"core-js/modules/es.array-buffer.is-view":["es.array-buffer.is-view"],"core-js/modules/es.array-buffer.slice":["es.array-buffer.slice"],"core-js/modules/es.array.concat":["es.array.concat"],"core-js/modules/es.array.copy-within":["es.array.copy-within"],"core-js/modules/es.array.every":["es.array.every"],"core-js/modules/es.array.fill":["es.array.fill"],"core-js/modules/es.array.filter":["es.array.filter"],"core-js/modules/es.array.find":["es.array.find"],"core-js/modules/es.array.find-index":["es.array.find-index"],"core-js/modules/es.array.flat":["es.array.flat"],"core-js/modules/es.array.flat-map":["es.array.flat-map"],"core-js/modules/es.array.for-each":["es.array.for-each"],"core-js/modules/es.array.from":["es.array.from"],"core-js/modules/es.array.includes":["es.array.includes"],"core-js/modules/es.array.index-of":["es.array.index-of"],"core-js/modules/es.array.is-array":["es.array.is-array"],"core-js/modules/es.array.iterator":["es.array.iterator"],"core-js/modules/es.array.join":["es.array.join"],"core-js/modules/es.array.last-index-of":["es.array.last-index-of"],"core-js/modules/es.array.map":["es.array.map"],"core-js/modules/es.array.of":["es.array.of"],"core-js/modules/es.array.reduce":["es.array.reduce"],"core-js/modules/es.array.reduce-right":["es.array.reduce-right"],"core-js/modules/es.array.reverse":["es.array.reverse"],"core-js/modules/es.array.slice":["es.array.slice"],"core-js/modules/es.array.some":["es.array.some"],"core-js/modules/es.array.sort":["es.array.sort"],"core-js/modules/es.array.species":["es.array.species"],"core-js/modules/es.array.splice":["es.array.splice"],"core-js/modules/es.array.unscopables.flat":["es.array.unscopables.flat"],"core-js/modules/es.array.unscopables.flat-map":["es.array.unscopables.flat-map"],"core-js/modules/es.data-view":["es.data-view"],"core-js/modules/es.date.now":["es.date.now"],"core-js/modules/es.date.to-iso-string":["es.date.to-iso-string"],"core-js/modules/es.date.to-json":["es.date.to-json"],"core-js/modules/es.date.to-primitive":["es.date.to-primitive"],"core-js/modules/es.date.to-string":["es.date.to-string"],"core-js/modules/es.function.bind":["es.function.bind"],"core-js/modules/es.function.has-instance":["es.function.has-instance"],"core-js/modules/es.function.name":["es.function.name"],"core-js/modules/es.global-this":["es.global-this"],"core-js/modules/es.json.stringify":["es.json.stringify"],"core-js/modules/es.json.to-string-tag":["es.json.to-string-tag"],"core-js/modules/es.map":["es.map"],"core-js/modules/es.math.acosh":["es.math.acosh"],"core-js/modules/es.math.asinh":["es.math.asinh"],"core-js/modules/es.math.atanh":["es.math.atanh"],"core-js/modules/es.math.cbrt":["es.math.cbrt"],"core-js/modules/es.math.clz32":["es.math.clz32"],"core-js/modules/es.math.cosh":["es.math.cosh"],"core-js/modules/es.math.expm1":["es.math.expm1"],"core-js/modules/es.math.fround":["es.math.fround"],"core-js/modules/es.math.hypot":["es.math.hypot"],"core-js/modules/es.math.imul":["es.math.imul"],"core-js/modules/es.math.log10":["es.math.log10"],"core-js/modules/es.math.log1p":["es.math.log1p"],"core-js/modules/es.math.log2":["es.math.log2"],"core-js/modules/es.math.sign":["es.math.sign"],"core-js/modules/es.math.sinh":["es.math.sinh"],"core-js/modules/es.math.tanh":["es.math.tanh"],"core-js/modules/es.math.to-string-tag":["es.math.to-string-tag"],"core-js/modules/es.math.trunc":["es.math.trunc"],"core-js/modules/es.number.constructor":["es.number.constructor"],"core-js/modules/es.number.epsilon":["es.number.epsilon"],"core-js/modules/es.number.is-finite":["es.number.is-finite"],"core-js/modules/es.number.is-integer":["es.number.is-integer"],"core-js/modules/es.number.is-nan":["es.number.is-nan"],"core-js/modules/es.number.is-safe-integer":["es.number.is-safe-integer"],"core-js/modules/es.number.max-safe-integer":["es.number.max-safe-integer"],"core-js/modules/es.number.min-safe-integer":["es.number.min-safe-integer"],"core-js/modules/es.number.parse-float":["es.number.parse-float"],"core-js/modules/es.number.parse-int":["es.number.parse-int"],"core-js/modules/es.number.to-fixed":["es.number.to-fixed"],"core-js/modules/es.number.to-precision":["es.number.to-precision"],"core-js/modules/es.object.assign":["es.object.assign"],"core-js/modules/es.object.create":["es.object.create"],"core-js/modules/es.object.define-getter":["es.object.define-getter"],"core-js/modules/es.object.define-properties":["es.object.define-properties"],"core-js/modules/es.object.define-property":["es.object.define-property"],"core-js/modules/es.object.define-setter":["es.object.define-setter"],"core-js/modules/es.object.entries":["es.object.entries"],"core-js/modules/es.object.freeze":["es.object.freeze"],"core-js/modules/es.object.from-entries":["es.object.from-entries"],"core-js/modules/es.object.get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/modules/es.object.get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/modules/es.object.get-own-property-names":["es.object.get-own-property-names"],"core-js/modules/es.object.get-prototype-of":["es.object.get-prototype-of"],"core-js/modules/es.object.is":["es.object.is"],"core-js/modules/es.object.is-extensible":["es.object.is-extensible"],"core-js/modules/es.object.is-frozen":["es.object.is-frozen"],"core-js/modules/es.object.is-sealed":["es.object.is-sealed"],"core-js/modules/es.object.keys":["es.object.keys"],"core-js/modules/es.object.lookup-getter":["es.object.lookup-getter"],"core-js/modules/es.object.lookup-setter":["es.object.lookup-setter"],"core-js/modules/es.object.prevent-extensions":["es.object.prevent-extensions"],"core-js/modules/es.object.seal":["es.object.seal"],"core-js/modules/es.object.set-prototype-of":["es.object.set-prototype-of"],"core-js/modules/es.object.to-string":["es.object.to-string"],"core-js/modules/es.object.values":["es.object.values"],"core-js/modules/es.parse-float":["es.parse-float"],"core-js/modules/es.parse-int":["es.parse-int"],"core-js/modules/es.promise":["es.promise"],"core-js/modules/es.promise.all-settled":["es.promise.all-settled"],"core-js/modules/es.promise.finally":["es.promise.finally"],"core-js/modules/es.reflect.apply":["es.reflect.apply"],"core-js/modules/es.reflect.construct":["es.reflect.construct"],"core-js/modules/es.reflect.define-property":["es.reflect.define-property"],"core-js/modules/es.reflect.delete-property":["es.reflect.delete-property"],"core-js/modules/es.reflect.get":["es.reflect.get"],"core-js/modules/es.reflect.get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/modules/es.reflect.get-prototype-of":["es.reflect.get-prototype-of"],"core-js/modules/es.reflect.has":["es.reflect.has"],"core-js/modules/es.reflect.is-extensible":["es.reflect.is-extensible"],"core-js/modules/es.reflect.own-keys":["es.reflect.own-keys"],"core-js/modules/es.reflect.prevent-extensions":["es.reflect.prevent-extensions"],"core-js/modules/es.reflect.set":["es.reflect.set"],"core-js/modules/es.reflect.set-prototype-of":["es.reflect.set-prototype-of"],"core-js/modules/es.regexp.constructor":["es.regexp.constructor"],"core-js/modules/es.regexp.exec":["es.regexp.exec"],"core-js/modules/es.regexp.flags":["es.regexp.flags"],"core-js/modules/es.regexp.sticky":["es.regexp.sticky"],"core-js/modules/es.regexp.test":["es.regexp.test"],"core-js/modules/es.regexp.to-string":["es.regexp.to-string"],"core-js/modules/es.set":["es.set"],"core-js/modules/es.string.anchor":["es.string.anchor"],"core-js/modules/es.string.big":["es.string.big"],"core-js/modules/es.string.blink":["es.string.blink"],"core-js/modules/es.string.bold":["es.string.bold"],"core-js/modules/es.string.code-point-at":["es.string.code-point-at"],"core-js/modules/es.string.ends-with":["es.string.ends-with"],"core-js/modules/es.string.fixed":["es.string.fixed"],"core-js/modules/es.string.fontcolor":["es.string.fontcolor"],"core-js/modules/es.string.fontsize":["es.string.fontsize"],"core-js/modules/es.string.from-code-point":["es.string.from-code-point"],"core-js/modules/es.string.includes":["es.string.includes"],"core-js/modules/es.string.italics":["es.string.italics"],"core-js/modules/es.string.iterator":["es.string.iterator"],"core-js/modules/es.string.link":["es.string.link"],"core-js/modules/es.string.match":["es.string.match"],"core-js/modules/es.string.match-all":["es.string.match-all"],"core-js/modules/es.string.pad-end":["es.string.pad-end"],"core-js/modules/es.string.pad-start":["es.string.pad-start"],"core-js/modules/es.string.raw":["es.string.raw"],"core-js/modules/es.string.repeat":["es.string.repeat"],"core-js/modules/es.string.replace":["es.string.replace"],"core-js/modules/es.string.search":["es.string.search"],"core-js/modules/es.string.small":["es.string.small"],"core-js/modules/es.string.split":["es.string.split"],"core-js/modules/es.string.starts-with":["es.string.starts-with"],"core-js/modules/es.string.strike":["es.string.strike"],"core-js/modules/es.string.sub":["es.string.sub"],"core-js/modules/es.string.sup":["es.string.sup"],"core-js/modules/es.string.trim":["es.string.trim"],"core-js/modules/es.string.trim-end":["es.string.trim-end"],"core-js/modules/es.string.trim-start":["es.string.trim-start"],"core-js/modules/es.symbol":["es.symbol"],"core-js/modules/es.symbol.async-iterator":["es.symbol.async-iterator"],"core-js/modules/es.symbol.description":["es.symbol.description"],"core-js/modules/es.symbol.has-instance":["es.symbol.has-instance"],"core-js/modules/es.symbol.is-concat-spreadable":["es.symbol.is-concat-spreadable"],"core-js/modules/es.symbol.iterator":["es.symbol.iterator"],"core-js/modules/es.symbol.match":["es.symbol.match"],"core-js/modules/es.symbol.match-all":["es.symbol.match-all"],"core-js/modules/es.symbol.replace":["es.symbol.replace"],"core-js/modules/es.symbol.search":["es.symbol.search"],"core-js/modules/es.symbol.species":["es.symbol.species"],"core-js/modules/es.symbol.split":["es.symbol.split"],"core-js/modules/es.symbol.to-primitive":["es.symbol.to-primitive"],"core-js/modules/es.symbol.to-string-tag":["es.symbol.to-string-tag"],"core-js/modules/es.symbol.unscopables":["es.symbol.unscopables"],"core-js/modules/es.typed-array.copy-within":["es.typed-array.copy-within"],"core-js/modules/es.typed-array.every":["es.typed-array.every"],"core-js/modules/es.typed-array.fill":["es.typed-array.fill"],"core-js/modules/es.typed-array.filter":["es.typed-array.filter"],"core-js/modules/es.typed-array.find":["es.typed-array.find"],"core-js/modules/es.typed-array.find-index":["es.typed-array.find-index"],"core-js/modules/es.typed-array.float32-array":["es.typed-array.float32-array"],"core-js/modules/es.typed-array.float64-array":["es.typed-array.float64-array"],"core-js/modules/es.typed-array.for-each":["es.typed-array.for-each"],"core-js/modules/es.typed-array.from":["es.typed-array.from"],"core-js/modules/es.typed-array.includes":["es.typed-array.includes"],"core-js/modules/es.typed-array.index-of":["es.typed-array.index-of"],"core-js/modules/es.typed-array.int16-array":["es.typed-array.int16-array"],"core-js/modules/es.typed-array.int32-array":["es.typed-array.int32-array"],"core-js/modules/es.typed-array.int8-array":["es.typed-array.int8-array"],"core-js/modules/es.typed-array.iterator":["es.typed-array.iterator"],"core-js/modules/es.typed-array.join":["es.typed-array.join"],"core-js/modules/es.typed-array.last-index-of":["es.typed-array.last-index-of"],"core-js/modules/es.typed-array.map":["es.typed-array.map"],"core-js/modules/es.typed-array.of":["es.typed-array.of"],"core-js/modules/es.typed-array.reduce":["es.typed-array.reduce"],"core-js/modules/es.typed-array.reduce-right":["es.typed-array.reduce-right"],"core-js/modules/es.typed-array.reverse":["es.typed-array.reverse"],"core-js/modules/es.typed-array.set":["es.typed-array.set"],"core-js/modules/es.typed-array.slice":["es.typed-array.slice"],"core-js/modules/es.typed-array.some":["es.typed-array.some"],"core-js/modules/es.typed-array.sort":["es.typed-array.sort"],"core-js/modules/es.typed-array.subarray":["es.typed-array.subarray"],"core-js/modules/es.typed-array.to-locale-string":["es.typed-array.to-locale-string"],"core-js/modules/es.typed-array.to-string":["es.typed-array.to-string"],"core-js/modules/es.typed-array.uint16-array":["es.typed-array.uint16-array"],"core-js/modules/es.typed-array.uint32-array":["es.typed-array.uint32-array"],"core-js/modules/es.typed-array.uint8-array":["es.typed-array.uint8-array"],"core-js/modules/es.typed-array.uint8-clamped-array":["es.typed-array.uint8-clamped-array"],"core-js/modules/es.weak-map":["es.weak-map"],"core-js/modules/es.weak-set":["es.weak-set"],"core-js/modules/esnext.aggregate-error":["esnext.aggregate-error"],"core-js/modules/esnext.array.is-template-object":["esnext.array.is-template-object"],"core-js/modules/esnext.array.last-index":["esnext.array.last-index"],"core-js/modules/esnext.array.last-item":["esnext.array.last-item"],"core-js/modules/esnext.async-iterator.as-indexed-pairs":["esnext.async-iterator.as-indexed-pairs"],"core-js/modules/esnext.async-iterator.constructor":["esnext.async-iterator.constructor"],"core-js/modules/esnext.async-iterator.drop":["esnext.async-iterator.drop"],"core-js/modules/esnext.async-iterator.every":["esnext.async-iterator.every"],"core-js/modules/esnext.async-iterator.filter":["esnext.async-iterator.filter"],"core-js/modules/esnext.async-iterator.find":["esnext.async-iterator.find"],"core-js/modules/esnext.async-iterator.flat-map":["esnext.async-iterator.flat-map"],"core-js/modules/esnext.async-iterator.for-each":["esnext.async-iterator.for-each"],"core-js/modules/esnext.async-iterator.from":["esnext.async-iterator.from"],"core-js/modules/esnext.async-iterator.map":["esnext.async-iterator.map"],"core-js/modules/esnext.async-iterator.reduce":["esnext.async-iterator.reduce"],"core-js/modules/esnext.async-iterator.some":["esnext.async-iterator.some"],"core-js/modules/esnext.async-iterator.take":["esnext.async-iterator.take"],"core-js/modules/esnext.async-iterator.to-array":["esnext.async-iterator.to-array"],"core-js/modules/esnext.composite-key":["esnext.composite-key"],"core-js/modules/esnext.composite-symbol":["esnext.composite-symbol"],"core-js/modules/esnext.global-this":["esnext.global-this"],"core-js/modules/esnext.iterator.as-indexed-pairs":["esnext.iterator.as-indexed-pairs"],"core-js/modules/esnext.iterator.constructor":["esnext.iterator.constructor"],"core-js/modules/esnext.iterator.drop":["esnext.iterator.drop"],"core-js/modules/esnext.iterator.every":["esnext.iterator.every"],"core-js/modules/esnext.iterator.filter":["esnext.iterator.filter"],"core-js/modules/esnext.iterator.find":["esnext.iterator.find"],"core-js/modules/esnext.iterator.flat-map":["esnext.iterator.flat-map"],"core-js/modules/esnext.iterator.for-each":["esnext.iterator.for-each"],"core-js/modules/esnext.iterator.from":["esnext.iterator.from"],"core-js/modules/esnext.iterator.map":["esnext.iterator.map"],"core-js/modules/esnext.iterator.reduce":["esnext.iterator.reduce"],"core-js/modules/esnext.iterator.some":["esnext.iterator.some"],"core-js/modules/esnext.iterator.take":["esnext.iterator.take"],"core-js/modules/esnext.iterator.to-array":["esnext.iterator.to-array"],"core-js/modules/esnext.map.delete-all":["esnext.map.delete-all"],"core-js/modules/esnext.map.every":["esnext.map.every"],"core-js/modules/esnext.map.filter":["esnext.map.filter"],"core-js/modules/esnext.map.find":["esnext.map.find"],"core-js/modules/esnext.map.find-key":["esnext.map.find-key"],"core-js/modules/esnext.map.from":["esnext.map.from"],"core-js/modules/esnext.map.group-by":["esnext.map.group-by"],"core-js/modules/esnext.map.includes":["esnext.map.includes"],"core-js/modules/esnext.map.key-by":["esnext.map.key-by"],"core-js/modules/esnext.map.key-of":["esnext.map.key-of"],"core-js/modules/esnext.map.map-keys":["esnext.map.map-keys"],"core-js/modules/esnext.map.map-values":["esnext.map.map-values"],"core-js/modules/esnext.map.merge":["esnext.map.merge"],"core-js/modules/esnext.map.of":["esnext.map.of"],"core-js/modules/esnext.map.reduce":["esnext.map.reduce"],"core-js/modules/esnext.map.some":["esnext.map.some"],"core-js/modules/esnext.map.update":["esnext.map.update"],"core-js/modules/esnext.map.update-or-insert":["esnext.map.update-or-insert"],"core-js/modules/esnext.map.upsert":["esnext.map.upsert"],"core-js/modules/esnext.math.clamp":["esnext.math.clamp"],"core-js/modules/esnext.math.deg-per-rad":["esnext.math.deg-per-rad"],"core-js/modules/esnext.math.degrees":["esnext.math.degrees"],"core-js/modules/esnext.math.fscale":["esnext.math.fscale"],"core-js/modules/esnext.math.iaddh":["esnext.math.iaddh"],"core-js/modules/esnext.math.imulh":["esnext.math.imulh"],"core-js/modules/esnext.math.isubh":["esnext.math.isubh"],"core-js/modules/esnext.math.rad-per-deg":["esnext.math.rad-per-deg"],"core-js/modules/esnext.math.radians":["esnext.math.radians"],"core-js/modules/esnext.math.scale":["esnext.math.scale"],"core-js/modules/esnext.math.seeded-prng":["esnext.math.seeded-prng"],"core-js/modules/esnext.math.signbit":["esnext.math.signbit"],"core-js/modules/esnext.math.umulh":["esnext.math.umulh"],"core-js/modules/esnext.number.from-string":["esnext.number.from-string"],"core-js/modules/esnext.object.iterate-entries":["esnext.object.iterate-entries"],"core-js/modules/esnext.object.iterate-keys":["esnext.object.iterate-keys"],"core-js/modules/esnext.object.iterate-values":["esnext.object.iterate-values"],"core-js/modules/esnext.observable":["esnext.observable"],"core-js/modules/esnext.promise.all-settled":["esnext.promise.all-settled"],"core-js/modules/esnext.promise.any":["esnext.promise.any"],"core-js/modules/esnext.promise.try":["esnext.promise.try"],"core-js/modules/esnext.reflect.define-metadata":["esnext.reflect.define-metadata"],"core-js/modules/esnext.reflect.delete-metadata":["esnext.reflect.delete-metadata"],"core-js/modules/esnext.reflect.get-metadata":["esnext.reflect.get-metadata"],"core-js/modules/esnext.reflect.get-metadata-keys":["esnext.reflect.get-metadata-keys"],"core-js/modules/esnext.reflect.get-own-metadata":["esnext.reflect.get-own-metadata"],"core-js/modules/esnext.reflect.get-own-metadata-keys":["esnext.reflect.get-own-metadata-keys"],"core-js/modules/esnext.reflect.has-metadata":["esnext.reflect.has-metadata"],"core-js/modules/esnext.reflect.has-own-metadata":["esnext.reflect.has-own-metadata"],"core-js/modules/esnext.reflect.metadata":["esnext.reflect.metadata"],"core-js/modules/esnext.set.add-all":["esnext.set.add-all"],"core-js/modules/esnext.set.delete-all":["esnext.set.delete-all"],"core-js/modules/esnext.set.difference":["esnext.set.difference"],"core-js/modules/esnext.set.every":["esnext.set.every"],"core-js/modules/esnext.set.filter":["esnext.set.filter"],"core-js/modules/esnext.set.find":["esnext.set.find"],"core-js/modules/esnext.set.from":["esnext.set.from"],"core-js/modules/esnext.set.intersection":["esnext.set.intersection"],"core-js/modules/esnext.set.is-disjoint-from":["esnext.set.is-disjoint-from"],"core-js/modules/esnext.set.is-subset-of":["esnext.set.is-subset-of"],"core-js/modules/esnext.set.is-superset-of":["esnext.set.is-superset-of"],"core-js/modules/esnext.set.join":["esnext.set.join"],"core-js/modules/esnext.set.map":["esnext.set.map"],"core-js/modules/esnext.set.of":["esnext.set.of"],"core-js/modules/esnext.set.reduce":["esnext.set.reduce"],"core-js/modules/esnext.set.some":["esnext.set.some"],"core-js/modules/esnext.set.symmetric-difference":["esnext.set.symmetric-difference"],"core-js/modules/esnext.set.union":["esnext.set.union"],"core-js/modules/esnext.string.at":["esnext.string.at"],"core-js/modules/esnext.string.code-points":["esnext.string.code-points"],"core-js/modules/esnext.string.match-all":["esnext.string.match-all"],"core-js/modules/esnext.string.replace-all":["esnext.string.replace-all"],"core-js/modules/esnext.symbol.async-dispose":["esnext.symbol.async-dispose"],"core-js/modules/esnext.symbol.dispose":["esnext.symbol.dispose"],"core-js/modules/esnext.symbol.observable":["esnext.symbol.observable"],"core-js/modules/esnext.symbol.pattern-match":["esnext.symbol.pattern-match"],"core-js/modules/esnext.symbol.replace-all":["esnext.symbol.replace-all"],"core-js/modules/esnext.weak-map.delete-all":["esnext.weak-map.delete-all"],"core-js/modules/esnext.weak-map.from":["esnext.weak-map.from"],"core-js/modules/esnext.weak-map.of":["esnext.weak-map.of"],"core-js/modules/esnext.weak-map.upsert":["esnext.weak-map.upsert"],"core-js/modules/esnext.weak-set.add-all":["esnext.weak-set.add-all"],"core-js/modules/esnext.weak-set.delete-all":["esnext.weak-set.delete-all"],"core-js/modules/esnext.weak-set.from":["esnext.weak-set.from"],"core-js/modules/esnext.weak-set.of":["esnext.weak-set.of"],"core-js/modules/web.dom-collections.for-each":["web.dom-collections.for-each"],"core-js/modules/web.dom-collections.iterator":["web.dom-collections.iterator"],"core-js/modules/web.immediate":["web.immediate"],"core-js/modules/web.queue-microtask":["web.queue-microtask"],"core-js/modules/web.timers":["web.timers"],"core-js/modules/web.url":["web.url"],"core-js/modules/web.url-search-params":["web.url-search-params"],"core-js/modules/web.url.to-json":["web.url.to-json"],"core-js/proposals":["esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/proposals/array-is-template-object":["esnext.array.is-template-object"],"core-js/proposals/array-last":["esnext.array.last-index","esnext.array.last-item"],"core-js/proposals/collection-methods":["esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.set.add-all","esnext.set.delete-all","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.join","esnext.set.map","esnext.set.reduce","esnext.set.some","esnext.weak-map.delete-all","esnext.weak-set.add-all","esnext.weak-set.delete-all"],"core-js/proposals/collection-of-from":["esnext.map.from","esnext.map.of","esnext.set.from","esnext.set.of","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-set.from","esnext.weak-set.of"],"core-js/proposals/efficient-64-bit-arithmetic":["esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.umulh"],"core-js/proposals/global-this":["esnext.global-this"],"core-js/proposals/iterator-helpers":["esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array"],"core-js/proposals/keys-composition":["esnext.composite-key","esnext.composite-symbol"],"core-js/proposals/map-update-or-insert":["esnext.map.update-or-insert","esnext.map.upsert","esnext.weak-map.upsert"],"core-js/proposals/map-upsert":["esnext.map.update-or-insert","esnext.map.upsert","esnext.weak-map.upsert"],"core-js/proposals/math-extensions":["esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale"],"core-js/proposals/math-signbit":["esnext.math.signbit"],"core-js/proposals/number-from-string":["esnext.number.from-string"],"core-js/proposals/object-iteration":["esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values"],"core-js/proposals/observable":["esnext.observable","esnext.symbol.observable"],"core-js/proposals/pattern-matching":["esnext.symbol.pattern-match"],"core-js/proposals/promise-all-settled":["esnext.promise.all-settled"],"core-js/proposals/promise-any":["esnext.aggregate-error","esnext.promise.any"],"core-js/proposals/promise-try":["esnext.promise.try"],"core-js/proposals/reflect-metadata":["esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata"],"core-js/proposals/seeded-random":["esnext.math.seeded-prng"],"core-js/proposals/set-methods":["esnext.set.difference","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.symmetric-difference","esnext.set.union"],"core-js/proposals/string-at":["esnext.string.at"],"core-js/proposals/string-code-points":["esnext.string.code-points"],"core-js/proposals/string-match-all":["esnext.string.match-all"],"core-js/proposals/string-replace-all":["esnext.string.replace-all","esnext.symbol.replace-all"],"core-js/proposals/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/proposals/using-statement":["esnext.symbol.async-dispose","esnext.symbol.dispose"],"core-js/stable":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.data-view","es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string","es.function.bind","es.function.has-instance","es.function.name","es.global-this","es.json.stringify","es.json.to-string-tag","es.map","es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc","es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values","es.parse-float","es.parse-int","es.promise","es.promise.all-settled","es.promise.finally","es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of","es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.set","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string","es.weak-map","es.weak-set","web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/stable/array":["es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.from","es.array.includes","es.array.index-of","es.array.is-array","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.of","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map","es.string.iterator"],"core-js/stable/array-buffer":["es.array-buffer.constructor","es.array-buffer.is-view","es.array-buffer.slice","es.object.to-string"],"core-js/stable/array-buffer/constructor":["es.array-buffer.constructor","es.object.to-string"],"core-js/stable/array-buffer/is-view":["es.array-buffer.is-view"],"core-js/stable/array-buffer/slice":["es.array-buffer.slice"],"core-js/stable/array/concat":["es.array.concat"],"core-js/stable/array/copy-within":["es.array.copy-within"],"core-js/stable/array/entries":["es.array.iterator"],"core-js/stable/array/every":["es.array.every"],"core-js/stable/array/fill":["es.array.fill"],"core-js/stable/array/filter":["es.array.filter"],"core-js/stable/array/find":["es.array.find"],"core-js/stable/array/find-index":["es.array.find-index"],"core-js/stable/array/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/stable/array/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/stable/array/for-each":["es.array.for-each"],"core-js/stable/array/from":["es.array.from","es.string.iterator"],"core-js/stable/array/includes":["es.array.includes"],"core-js/stable/array/index-of":["es.array.index-of"],"core-js/stable/array/is-array":["es.array.is-array"],"core-js/stable/array/iterator":["es.array.iterator"],"core-js/stable/array/join":["es.array.join"],"core-js/stable/array/keys":["es.array.iterator"],"core-js/stable/array/last-index-of":["es.array.last-index-of"],"core-js/stable/array/map":["es.array.map"],"core-js/stable/array/of":["es.array.of"],"core-js/stable/array/reduce":["es.array.reduce"],"core-js/stable/array/reduce-right":["es.array.reduce-right"],"core-js/stable/array/reverse":["es.array.reverse"],"core-js/stable/array/slice":["es.array.slice"],"core-js/stable/array/some":["es.array.some"],"core-js/stable/array/sort":["es.array.sort"],"core-js/stable/array/splice":["es.array.splice"],"core-js/stable/array/values":["es.array.iterator"],"core-js/stable/array/virtual":["es.array.concat","es.array.copy-within","es.array.every","es.array.fill","es.array.filter","es.array.find","es.array.find-index","es.array.flat","es.array.flat-map","es.array.for-each","es.array.includes","es.array.index-of","es.array.iterator","es.array.join","es.array.last-index-of","es.array.map","es.array.reduce","es.array.reduce-right","es.array.reverse","es.array.slice","es.array.some","es.array.sort","es.array.species","es.array.splice","es.array.unscopables.flat","es.array.unscopables.flat-map"],"core-js/stable/array/virtual/concat":["es.array.concat"],"core-js/stable/array/virtual/copy-within":["es.array.copy-within"],"core-js/stable/array/virtual/entries":["es.array.iterator"],"core-js/stable/array/virtual/every":["es.array.every"],"core-js/stable/array/virtual/fill":["es.array.fill"],"core-js/stable/array/virtual/filter":["es.array.filter"],"core-js/stable/array/virtual/find":["es.array.find"],"core-js/stable/array/virtual/find-index":["es.array.find-index"],"core-js/stable/array/virtual/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/stable/array/virtual/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/stable/array/virtual/for-each":["es.array.for-each"],"core-js/stable/array/virtual/includes":["es.array.includes"],"core-js/stable/array/virtual/index-of":["es.array.index-of"],"core-js/stable/array/virtual/iterator":["es.array.iterator"],"core-js/stable/array/virtual/join":["es.array.join"],"core-js/stable/array/virtual/keys":["es.array.iterator"],"core-js/stable/array/virtual/last-index-of":["es.array.last-index-of"],"core-js/stable/array/virtual/map":["es.array.map"],"core-js/stable/array/virtual/reduce":["es.array.reduce"],"core-js/stable/array/virtual/reduce-right":["es.array.reduce-right"],"core-js/stable/array/virtual/reverse":["es.array.reverse"],"core-js/stable/array/virtual/slice":["es.array.slice"],"core-js/stable/array/virtual/some":["es.array.some"],"core-js/stable/array/virtual/sort":["es.array.sort"],"core-js/stable/array/virtual/splice":["es.array.splice"],"core-js/stable/array/virtual/values":["es.array.iterator"],"core-js/stable/clear-immediate":["web.immediate"],"core-js/stable/data-view":["es.data-view","es.object.to-string"],"core-js/stable/date":["es.date.now","es.date.to-iso-string","es.date.to-json","es.date.to-primitive","es.date.to-string"],"core-js/stable/date/now":["es.date.now"],"core-js/stable/date/to-iso-string":["es.date.to-iso-string","es.date.to-json"],"core-js/stable/date/to-json":["es.date.to-json"],"core-js/stable/date/to-primitive":["es.date.to-primitive"],"core-js/stable/date/to-string":["es.date.to-string"],"core-js/stable/dom-collections":["es.array.iterator","web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/stable/dom-collections/for-each":["web.dom-collections.for-each"],"core-js/stable/dom-collections/iterator":["web.dom-collections.iterator"],"core-js/stable/function":["es.function.bind","es.function.has-instance","es.function.name"],"core-js/stable/function/bind":["es.function.bind"],"core-js/stable/function/has-instance":["es.function.has-instance"],"core-js/stable/function/name":["es.function.name"],"core-js/stable/function/virtual":["es.function.bind"],"core-js/stable/function/virtual/bind":["es.function.bind"],"core-js/stable/global-this":["es.global-this"],"core-js/stable/instance/bind":["es.function.bind"],"core-js/stable/instance/code-point-at":["es.string.code-point-at"],"core-js/stable/instance/concat":["es.array.concat"],"core-js/stable/instance/copy-within":["es.array.copy-within"],"core-js/stable/instance/ends-with":["es.string.ends-with"],"core-js/stable/instance/entries":["es.array.iterator","web.dom-collections.iterator"],"core-js/stable/instance/every":["es.array.every"],"core-js/stable/instance/fill":["es.array.fill"],"core-js/stable/instance/filter":["es.array.filter"],"core-js/stable/instance/find":["es.array.find"],"core-js/stable/instance/find-index":["es.array.find-index"],"core-js/stable/instance/flags":["es.regexp.flags"],"core-js/stable/instance/flat":["es.array.flat","es.array.unscopables.flat"],"core-js/stable/instance/flat-map":["es.array.flat-map","es.array.unscopables.flat-map"],"core-js/stable/instance/for-each":["es.array.for-each","web.dom-collections.iterator"],"core-js/stable/instance/includes":["es.array.includes","es.string.includes"],"core-js/stable/instance/index-of":["es.array.index-of"],"core-js/stable/instance/keys":["es.array.iterator","web.dom-collections.iterator"],"core-js/stable/instance/last-index-of":["es.array.last-index-of"],"core-js/stable/instance/map":["es.array.map"],"core-js/stable/instance/match-all":["es.string.match-all"],"core-js/stable/instance/pad-end":["es.string.pad-end"],"core-js/stable/instance/pad-start":["es.string.pad-start"],"core-js/stable/instance/reduce":["es.array.reduce"],"core-js/stable/instance/reduce-right":["es.array.reduce-right"],"core-js/stable/instance/repeat":["es.string.repeat"],"core-js/stable/instance/reverse":["es.array.reverse"],"core-js/stable/instance/slice":["es.array.slice"],"core-js/stable/instance/some":["es.array.some"],"core-js/stable/instance/sort":["es.array.sort"],"core-js/stable/instance/splice":["es.array.splice"],"core-js/stable/instance/starts-with":["es.string.starts-with"],"core-js/stable/instance/trim":["es.string.trim"],"core-js/stable/instance/trim-end":["es.string.trim-end"],"core-js/stable/instance/trim-left":["es.string.trim-start"],"core-js/stable/instance/trim-right":["es.string.trim-end"],"core-js/stable/instance/trim-start":["es.string.trim-start"],"core-js/stable/instance/values":["es.array.iterator","web.dom-collections.iterator"],"core-js/stable/json":["es.json.stringify","es.json.to-string-tag"],"core-js/stable/json/stringify":["es.json.stringify"],"core-js/stable/json/to-string-tag":["es.json.to-string-tag"],"core-js/stable/map":["es.map","es.object.to-string","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/math":["es.math.acosh","es.math.asinh","es.math.atanh","es.math.cbrt","es.math.clz32","es.math.cosh","es.math.expm1","es.math.fround","es.math.hypot","es.math.imul","es.math.log10","es.math.log1p","es.math.log2","es.math.sign","es.math.sinh","es.math.tanh","es.math.to-string-tag","es.math.trunc"],"core-js/stable/math/acosh":["es.math.acosh"],"core-js/stable/math/asinh":["es.math.asinh"],"core-js/stable/math/atanh":["es.math.atanh"],"core-js/stable/math/cbrt":["es.math.cbrt"],"core-js/stable/math/clz32":["es.math.clz32"],"core-js/stable/math/cosh":["es.math.cosh"],"core-js/stable/math/expm1":["es.math.expm1"],"core-js/stable/math/fround":["es.math.fround"],"core-js/stable/math/hypot":["es.math.hypot"],"core-js/stable/math/imul":["es.math.imul"],"core-js/stable/math/log10":["es.math.log10"],"core-js/stable/math/log1p":["es.math.log1p"],"core-js/stable/math/log2":["es.math.log2"],"core-js/stable/math/sign":["es.math.sign"],"core-js/stable/math/sinh":["es.math.sinh"],"core-js/stable/math/tanh":["es.math.tanh"],"core-js/stable/math/to-string-tag":["es.math.to-string-tag"],"core-js/stable/math/trunc":["es.math.trunc"],"core-js/stable/number":["es.number.constructor","es.number.epsilon","es.number.is-finite","es.number.is-integer","es.number.is-nan","es.number.is-safe-integer","es.number.max-safe-integer","es.number.min-safe-integer","es.number.parse-float","es.number.parse-int","es.number.to-fixed","es.number.to-precision"],"core-js/stable/number/constructor":["es.number.constructor"],"core-js/stable/number/epsilon":["es.number.epsilon"],"core-js/stable/number/is-finite":["es.number.is-finite"],"core-js/stable/number/is-integer":["es.number.is-integer"],"core-js/stable/number/is-nan":["es.number.is-nan"],"core-js/stable/number/is-safe-integer":["es.number.is-safe-integer"],"core-js/stable/number/max-safe-integer":["es.number.max-safe-integer"],"core-js/stable/number/min-safe-integer":["es.number.min-safe-integer"],"core-js/stable/number/parse-float":["es.number.parse-float"],"core-js/stable/number/parse-int":["es.number.parse-int"],"core-js/stable/number/to-fixed":["es.number.to-fixed"],"core-js/stable/number/to-precision":["es.number.to-precision"],"core-js/stable/number/virtual":["es.number.to-fixed","es.number.to-precision"],"core-js/stable/number/virtual/to-fixed":["es.number.to-fixed"],"core-js/stable/number/virtual/to-precision":["es.number.to-precision"],"core-js/stable/object":["es.symbol","es.json.to-string-tag","es.math.to-string-tag","es.object.assign","es.object.create","es.object.define-getter","es.object.define-properties","es.object.define-property","es.object.define-setter","es.object.entries","es.object.freeze","es.object.from-entries","es.object.get-own-property-descriptor","es.object.get-own-property-descriptors","es.object.get-own-property-names","es.object.get-prototype-of","es.object.is","es.object.is-extensible","es.object.is-frozen","es.object.is-sealed","es.object.keys","es.object.lookup-getter","es.object.lookup-setter","es.object.prevent-extensions","es.object.seal","es.object.set-prototype-of","es.object.to-string","es.object.values"],"core-js/stable/object/assign":["es.object.assign"],"core-js/stable/object/create":["es.object.create"],"core-js/stable/object/define-getter":["es.object.define-getter"],"core-js/stable/object/define-properties":["es.object.define-properties"],"core-js/stable/object/define-property":["es.object.define-property"],"core-js/stable/object/define-setter":["es.object.define-setter"],"core-js/stable/object/entries":["es.object.entries"],"core-js/stable/object/freeze":["es.object.freeze"],"core-js/stable/object/from-entries":["es.array.iterator","es.object.from-entries"],"core-js/stable/object/get-own-property-descriptor":["es.object.get-own-property-descriptor"],"core-js/stable/object/get-own-property-descriptors":["es.object.get-own-property-descriptors"],"core-js/stable/object/get-own-property-names":["es.object.get-own-property-names"],"core-js/stable/object/get-own-property-symbols":["es.symbol"],"core-js/stable/object/get-prototype-of":["es.object.get-prototype-of"],"core-js/stable/object/is":["es.object.is"],"core-js/stable/object/is-extensible":["es.object.is-extensible"],"core-js/stable/object/is-frozen":["es.object.is-frozen"],"core-js/stable/object/is-sealed":["es.object.is-sealed"],"core-js/stable/object/keys":["es.object.keys"],"core-js/stable/object/lookup-getter":["es.object.lookup-setter"],"core-js/stable/object/lookup-setter":["es.object.lookup-setter"],"core-js/stable/object/prevent-extensions":["es.object.prevent-extensions"],"core-js/stable/object/seal":["es.object.seal"],"core-js/stable/object/set-prototype-of":["es.object.set-prototype-of"],"core-js/stable/object/to-string":["es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/stable/object/values":["es.object.values"],"core-js/stable/parse-float":["es.parse-float"],"core-js/stable/parse-int":["es.parse-int"],"core-js/stable/promise":["es.object.to-string","es.promise","es.promise.all-settled","es.promise.finally","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/promise/all-settled":["es.promise","es.promise.all-settled"],"core-js/stable/promise/finally":["es.promise","es.promise.finally"],"core-js/stable/queue-microtask":["web.queue-microtask"],"core-js/stable/reflect":["es.reflect.apply","es.reflect.construct","es.reflect.define-property","es.reflect.delete-property","es.reflect.get","es.reflect.get-own-property-descriptor","es.reflect.get-prototype-of","es.reflect.has","es.reflect.is-extensible","es.reflect.own-keys","es.reflect.prevent-extensions","es.reflect.set","es.reflect.set-prototype-of"],"core-js/stable/reflect/apply":["es.reflect.apply"],"core-js/stable/reflect/construct":["es.reflect.construct"],"core-js/stable/reflect/define-property":["es.reflect.define-property"],"core-js/stable/reflect/delete-property":["es.reflect.delete-property"],"core-js/stable/reflect/get":["es.reflect.get"],"core-js/stable/reflect/get-own-property-descriptor":["es.reflect.get-own-property-descriptor"],"core-js/stable/reflect/get-prototype-of":["es.reflect.get-prototype-of"],"core-js/stable/reflect/has":["es.reflect.has"],"core-js/stable/reflect/is-extensible":["es.reflect.is-extensible"],"core-js/stable/reflect/own-keys":["es.reflect.own-keys"],"core-js/stable/reflect/prevent-extensions":["es.reflect.prevent-extensions"],"core-js/stable/reflect/set":["es.reflect.set"],"core-js/stable/reflect/set-prototype-of":["es.reflect.set-prototype-of"],"core-js/stable/regexp":["es.regexp.constructor","es.regexp.exec","es.regexp.flags","es.regexp.sticky","es.regexp.test","es.regexp.to-string","es.string.match","es.string.replace","es.string.search","es.string.split"],"core-js/stable/regexp/constructor":["es.regexp.constructor"],"core-js/stable/regexp/flags":["es.regexp.flags"],"core-js/stable/regexp/match":["es.string.match"],"core-js/stable/regexp/replace":["es.string.replace"],"core-js/stable/regexp/search":["es.string.search"],"core-js/stable/regexp/split":["es.string.split"],"core-js/stable/regexp/sticky":["es.regexp.sticky"],"core-js/stable/regexp/test":["es.regexp.exec","es.regexp.test"],"core-js/stable/regexp/to-string":["es.regexp.to-string"],"core-js/stable/set":["es.object.to-string","es.set","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/set-immediate":["web.immediate"],"core-js/stable/set-interval":["web.timers"],"core-js/stable/set-timeout":["web.timers"],"core-js/stable/string":["es.regexp.exec","es.string.code-point-at","es.string.ends-with","es.string.from-code-point","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.raw","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/stable/string/anchor":["es.string.anchor"],"core-js/stable/string/big":["es.string.big"],"core-js/stable/string/blink":["es.string.blink"],"core-js/stable/string/bold":["es.string.bold"],"core-js/stable/string/code-point-at":["es.string.code-point-at"],"core-js/stable/string/ends-with":["es.string.ends-with"],"core-js/stable/string/fixed":["es.string.fixed"],"core-js/stable/string/fontcolor":["es.string.fontcolor"],"core-js/stable/string/fontsize":["es.string.fontsize"],"core-js/stable/string/from-code-point":["es.string.from-code-point"],"core-js/stable/string/includes":["es.string.includes"],"core-js/stable/string/italics":["es.string.italics"],"core-js/stable/string/iterator":["es.string.iterator"],"core-js/stable/string/link":["es.string.link"],"core-js/stable/string/match":["es.regexp.exec","es.string.match"],"core-js/stable/string/match-all":["es.string.match-all"],"core-js/stable/string/pad-end":["es.string.pad-end"],"core-js/stable/string/pad-start":["es.string.pad-start"],"core-js/stable/string/raw":["es.string.raw"],"core-js/stable/string/repeat":["es.string.repeat"],"core-js/stable/string/replace":["es.regexp.exec","es.string.replace"],"core-js/stable/string/search":["es.regexp.exec","es.string.search"],"core-js/stable/string/small":["es.string.small"],"core-js/stable/string/split":["es.regexp.exec","es.string.split"],"core-js/stable/string/starts-with":["es.string.starts-with"],"core-js/stable/string/strike":["es.string.strike"],"core-js/stable/string/sub":["es.string.sub"],"core-js/stable/string/sup":["es.string.sup"],"core-js/stable/string/trim":["es.string.trim"],"core-js/stable/string/trim-end":["es.string.trim-end"],"core-js/stable/string/trim-left":["es.string.trim-start"],"core-js/stable/string/trim-right":["es.string.trim-end"],"core-js/stable/string/trim-start":["es.string.trim-start"],"core-js/stable/string/virtual":["es.string.code-point-at","es.string.ends-with","es.string.includes","es.string.iterator","es.string.match","es.string.match-all","es.string.pad-end","es.string.pad-start","es.string.repeat","es.string.replace","es.string.search","es.string.split","es.string.starts-with","es.string.trim","es.string.trim-end","es.string.trim-start","es.string.anchor","es.string.big","es.string.blink","es.string.bold","es.string.fixed","es.string.fontcolor","es.string.fontsize","es.string.italics","es.string.link","es.string.small","es.string.strike","es.string.sub","es.string.sup"],"core-js/stable/string/virtual/anchor":["es.string.anchor"],"core-js/stable/string/virtual/big":["es.string.big"],"core-js/stable/string/virtual/blink":["es.string.blink"],"core-js/stable/string/virtual/bold":["es.string.bold"],"core-js/stable/string/virtual/code-point-at":["es.string.code-point-at"],"core-js/stable/string/virtual/ends-with":["es.string.ends-with"],"core-js/stable/string/virtual/fixed":["es.string.fixed"],"core-js/stable/string/virtual/fontcolor":["es.string.fontcolor"],"core-js/stable/string/virtual/fontsize":["es.string.fontsize"],"core-js/stable/string/virtual/includes":["es.string.includes"],"core-js/stable/string/virtual/italics":["es.string.italics"],"core-js/stable/string/virtual/iterator":["es.string.iterator"],"core-js/stable/string/virtual/link":["es.string.link"],"core-js/stable/string/virtual/match-all":["es.string.match-all"],"core-js/stable/string/virtual/pad-end":["es.string.pad-end"],"core-js/stable/string/virtual/pad-start":["es.string.pad-start"],"core-js/stable/string/virtual/repeat":["es.string.repeat"],"core-js/stable/string/virtual/small":["es.string.small"],"core-js/stable/string/virtual/starts-with":["es.string.starts-with"],"core-js/stable/string/virtual/strike":["es.string.strike"],"core-js/stable/string/virtual/sub":["es.string.sub"],"core-js/stable/string/virtual/sup":["es.string.sup"],"core-js/stable/string/virtual/trim":["es.string.trim"],"core-js/stable/string/virtual/trim-end":["es.string.trim-end"],"core-js/stable/string/virtual/trim-left":["es.string.trim-start"],"core-js/stable/string/virtual/trim-right":["es.string.trim-end"],"core-js/stable/string/virtual/trim-start":["es.string.trim-start"],"core-js/stable/symbol":["es.symbol","es.symbol.description","es.symbol.async-iterator","es.symbol.has-instance","es.symbol.is-concat-spreadable","es.symbol.iterator","es.symbol.match","es.symbol.match-all","es.symbol.replace","es.symbol.search","es.symbol.species","es.symbol.split","es.symbol.to-primitive","es.symbol.to-string-tag","es.symbol.unscopables","es.array.concat","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/stable/symbol/async-iterator":["es.symbol.async-iterator"],"core-js/stable/symbol/description":["es.symbol.description"],"core-js/stable/symbol/for":["es.symbol"],"core-js/stable/symbol/has-instance":["es.symbol.has-instance","es.function.has-instance"],"core-js/stable/symbol/is-concat-spreadable":["es.symbol.is-concat-spreadable","es.array.concat"],"core-js/stable/symbol/iterator":["es.symbol.iterator","es.string.iterator","web.dom-collections.iterator"],"core-js/stable/symbol/key-for":["es.symbol"],"core-js/stable/symbol/match":["es.symbol.match","es.string.match"],"core-js/stable/symbol/match-all":["es.symbol.match-all","es.string.match-all"],"core-js/stable/symbol/replace":["es.symbol.replace","es.string.replace"],"core-js/stable/symbol/search":["es.symbol.search","es.string.search"],"core-js/stable/symbol/species":["es.symbol.species"],"core-js/stable/symbol/split":["es.symbol.split","es.string.split"],"core-js/stable/symbol/to-primitive":["es.symbol.to-primitive"],"core-js/stable/symbol/to-string-tag":["es.symbol.to-string-tag","es.json.to-string-tag","es.math.to-string-tag","es.object.to-string"],"core-js/stable/symbol/unscopables":["es.symbol.unscopables"],"core-js/stable/typed-array":["es.object.to-string","es.typed-array.float32-array","es.typed-array.float64-array","es.typed-array.int8-array","es.typed-array.int16-array","es.typed-array.int32-array","es.typed-array.uint8-array","es.typed-array.uint8-clamped-array","es.typed-array.uint16-array","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/copy-within":["es.typed-array.copy-within"],"core-js/stable/typed-array/entries":["es.typed-array.iterator"],"core-js/stable/typed-array/every":["es.typed-array.every"],"core-js/stable/typed-array/fill":["es.typed-array.fill"],"core-js/stable/typed-array/filter":["es.typed-array.filter"],"core-js/stable/typed-array/find":["es.typed-array.find"],"core-js/stable/typed-array/find-index":["es.typed-array.find-index"],"core-js/stable/typed-array/float32-array":["es.object.to-string","es.typed-array.float32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/float64-array":["es.object.to-string","es.typed-array.float64-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/for-each":["es.typed-array.for-each"],"core-js/stable/typed-array/from":["es.typed-array.from"],"core-js/stable/typed-array/includes":["es.typed-array.includes"],"core-js/stable/typed-array/index-of":["es.typed-array.index-of"],"core-js/stable/typed-array/int16-array":["es.object.to-string","es.typed-array.int16-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/int32-array":["es.object.to-string","es.typed-array.int32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/int8-array":["es.object.to-string","es.typed-array.int8-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/iterator":["es.typed-array.iterator"],"core-js/stable/typed-array/join":["es.typed-array.join"],"core-js/stable/typed-array/keys":["es.typed-array.iterator"],"core-js/stable/typed-array/last-index-of":["es.typed-array.last-index-of"],"core-js/stable/typed-array/map":["es.typed-array.map"],"core-js/stable/typed-array/of":["es.typed-array.of"],"core-js/stable/typed-array/reduce":["es.typed-array.reduce"],"core-js/stable/typed-array/reduce-right":["es.typed-array.reduce-right"],"core-js/stable/typed-array/reverse":["es.typed-array.reverse"],"core-js/stable/typed-array/set":["es.typed-array.set"],"core-js/stable/typed-array/slice":["es.typed-array.slice"],"core-js/stable/typed-array/some":["es.typed-array.some"],"core-js/stable/typed-array/sort":["es.typed-array.sort"],"core-js/stable/typed-array/subarray":["es.typed-array.subarray"],"core-js/stable/typed-array/to-locale-string":["es.typed-array.to-locale-string"],"core-js/stable/typed-array/to-string":["es.typed-array.to-string"],"core-js/stable/typed-array/uint16-array":["es.object.to-string","es.typed-array.uint16-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/uint32-array":["es.object.to-string","es.typed-array.uint32-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/uint8-array":["es.object.to-string","es.typed-array.uint8-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/uint8-clamped-array":["es.object.to-string","es.typed-array.uint8-clamped-array","es.typed-array.copy-within","es.typed-array.every","es.typed-array.fill","es.typed-array.filter","es.typed-array.find","es.typed-array.find-index","es.typed-array.for-each","es.typed-array.from","es.typed-array.includes","es.typed-array.index-of","es.typed-array.iterator","es.typed-array.join","es.typed-array.last-index-of","es.typed-array.map","es.typed-array.of","es.typed-array.reduce","es.typed-array.reduce-right","es.typed-array.reverse","es.typed-array.set","es.typed-array.slice","es.typed-array.some","es.typed-array.sort","es.typed-array.subarray","es.typed-array.to-locale-string","es.typed-array.to-string"],"core-js/stable/typed-array/values":["es.typed-array.iterator"],"core-js/stable/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/stable/url-search-params":["web.url-search-params"],"core-js/stable/url/to-json":["web.url.to-json"],"core-js/stable/weak-map":["es.object.to-string","es.weak-map","web.dom-collections.iterator"],"core-js/stable/weak-set":["es.object.to-string","es.weak-set","web.dom-collections.iterator"],"core-js/stage":["esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/stage/0":["esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/stage/1":["esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of"],"core-js/stage/2":["esnext.aggregate-error","esnext.array.is-template-object","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.update-or-insert","esnext.map.upsert","esnext.promise.all-settled","esnext.promise.any","esnext.set.difference","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.symmetric-difference","esnext.set.union","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.replace-all","esnext.weak-map.upsert"],"core-js/stage/3":["esnext.aggregate-error","esnext.global-this","esnext.promise.all-settled","esnext.promise.any","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.replace-all"],"core-js/stage/4":["esnext.global-this","esnext.promise.all-settled","esnext.string.match-all"],"core-js/stage/pre":["esnext.aggregate-error","esnext.array.is-template-object","esnext.array.last-index","esnext.array.last-item","esnext.async-iterator.constructor","esnext.async-iterator.as-indexed-pairs","esnext.async-iterator.drop","esnext.async-iterator.every","esnext.async-iterator.filter","esnext.async-iterator.find","esnext.async-iterator.flat-map","esnext.async-iterator.for-each","esnext.async-iterator.from","esnext.async-iterator.map","esnext.async-iterator.reduce","esnext.async-iterator.some","esnext.async-iterator.take","esnext.async-iterator.to-array","esnext.composite-key","esnext.composite-symbol","esnext.global-this","esnext.iterator.constructor","esnext.iterator.as-indexed-pairs","esnext.iterator.drop","esnext.iterator.every","esnext.iterator.filter","esnext.iterator.find","esnext.iterator.flat-map","esnext.iterator.for-each","esnext.iterator.from","esnext.iterator.map","esnext.iterator.reduce","esnext.iterator.some","esnext.iterator.take","esnext.iterator.to-array","esnext.map.delete-all","esnext.map.every","esnext.map.filter","esnext.map.find","esnext.map.find-key","esnext.map.from","esnext.map.group-by","esnext.map.includes","esnext.map.key-by","esnext.map.key-of","esnext.map.map-keys","esnext.map.map-values","esnext.map.merge","esnext.map.of","esnext.map.reduce","esnext.map.some","esnext.map.update","esnext.map.update-or-insert","esnext.map.upsert","esnext.math.clamp","esnext.math.deg-per-rad","esnext.math.degrees","esnext.math.fscale","esnext.math.iaddh","esnext.math.imulh","esnext.math.isubh","esnext.math.rad-per-deg","esnext.math.radians","esnext.math.scale","esnext.math.seeded-prng","esnext.math.signbit","esnext.math.umulh","esnext.number.from-string","esnext.object.iterate-entries","esnext.object.iterate-keys","esnext.object.iterate-values","esnext.observable","esnext.promise.all-settled","esnext.promise.any","esnext.promise.try","esnext.reflect.define-metadata","esnext.reflect.delete-metadata","esnext.reflect.get-metadata","esnext.reflect.get-metadata-keys","esnext.reflect.get-own-metadata","esnext.reflect.get-own-metadata-keys","esnext.reflect.has-metadata","esnext.reflect.has-own-metadata","esnext.reflect.metadata","esnext.set.add-all","esnext.set.delete-all","esnext.set.difference","esnext.set.every","esnext.set.filter","esnext.set.find","esnext.set.from","esnext.set.intersection","esnext.set.is-disjoint-from","esnext.set.is-subset-of","esnext.set.is-superset-of","esnext.set.join","esnext.set.map","esnext.set.of","esnext.set.reduce","esnext.set.some","esnext.set.symmetric-difference","esnext.set.union","esnext.string.at","esnext.string.code-points","esnext.string.match-all","esnext.string.replace-all","esnext.symbol.async-dispose","esnext.symbol.dispose","esnext.symbol.observable","esnext.symbol.pattern-match","esnext.symbol.replace-all","esnext.weak-map.delete-all","esnext.weak-map.from","esnext.weak-map.of","esnext.weak-map.upsert","esnext.weak-set.add-all","esnext.weak-set.delete-all","esnext.weak-set.from","esnext.weak-set.of","web.url","web.url.to-json","web.url-search-params"],"core-js/web":["web.dom-collections.for-each","web.dom-collections.iterator","web.immediate","web.queue-microtask","web.timers","web.url","web.url.to-json","web.url-search-params"],"core-js/web/dom-collections":["web.dom-collections.for-each","web.dom-collections.iterator"],"core-js/web/immediate":["web.immediate"],"core-js/web/queue-microtask":["web.queue-microtask"],"core-js/web/timers":["web.timers"],"core-js/web/url":["web.url","web.url.to-json","web.url-search-params"],"core-js/web/url-search-params":["web.url-search-params"]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function() {
    return {
      name: "regenerator-entry",
      visitor: {
        ImportDeclaration(path) {
          isRegeneratorSource((0, _utils.getImportSource)(path)) && (this.regeneratorImportExcluded = !0, 
          path.remove());
        },
        Program(path) {
          path.get("body").forEach(bodyPath => {
            isRegeneratorSource((0, _utils.getRequireSource)(bodyPath)) && (this.regeneratorImportExcluded = !0, 
            bodyPath.remove());
          });
        }
      },
      pre() {
        this.regeneratorImportExcluded = !1;
      },
      post() {
        if (this.opts.debug && this.regeneratorImportExcluded) {
          let filename = this.file.opts.filename;
          "test" === process.env.BABEL_ENV && (filename = filename.replace(/\\/g, "/")), console.log(`\n[${filename}] Based on your targets, regenerator-runtime import excluded.`);
        }
      }
    };
  };
  var _utils = __webpack_require__(18);
  function isRegeneratorSource(source) {
    return "regenerator-runtime/runtime" === source;
  }
} ]);