module.exports = function(modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: !1,
      exports: {}
    };
    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
    module.l = !0, module.exports;
  }
  return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
  __webpack_require__.d = function(exports, name, getter) {
    __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
      enumerable: !0,
      get: getter
    });
  }, __webpack_require__.r = function(exports) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(exports, "__esModule", {
      value: !0
    });
  }, __webpack_require__.t = function(value, mode) {
    if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
    if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
    var ns = Object.create(null);
    if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
      enumerable: !0,
      value: value
    }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function(key) {
      return value[key];
    }.bind(null, key));
    return ns;
  }, __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ? function() {
      return module.default;
    } : function() {
      return module;
    };
    return __webpack_require__.d(getter, "a", getter), getter;
  }, __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 182);
}([ function(module, exports) {
  module.exports = require("./webpack-sources");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const inspect = __webpack_require__(11).inspect.custom;
  class WebpackError extends Error {
    constructor(message) {
      super(message), this.details = void 0, this.missing = void 0, this.origin = void 0, 
      this.dependencies = void 0, this.module = void 0, Error.captureStackTrace(this, this.constructor);
    }
    [inspect]() {
      return this.stack + (this.details ? "\n" + this.details : "");
    }
  }
  module.exports = WebpackError;
}, function(module, exports, __webpack_require__) {
  const {ConcatSource: ConcatSource} = __webpack_require__(0), HotUpdateChunk = __webpack_require__(98), START_LOWERCASE_ALPHABET_CODE = "a".charCodeAt(0), START_UPPERCASE_ALPHABET_CODE = "A".charCodeAt(0), DELTA_A_TO_Z = "z".charCodeAt(0) - START_LOWERCASE_ALPHABET_CODE + 1, FUNCTION_CONTENT_REGEX = /^function\s?\(\)\s?\{\r?\n?|\r?\n?\}$/g, INDENT_MULTILINE_REGEX = /^\t/gm, LINE_SEPARATOR_REGEX = /\r?\n/g, IDENTIFIER_NAME_REPLACE_REGEX = /^([^a-zA-Z$_])/, IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX = /[^a-zA-Z0-9$]+/g, COMMENT_END_REGEX = /\*\//g, PATH_NAME_NORMALIZE_REPLACE_REGEX = /[^a-zA-Z0-9_!§$()=\-^°]+/g, MATCH_PADDED_HYPHENS_REPLACE_REGEX = /^-|-$/g, stringifyIdSortPredicate = (a, b) => {
    const aId = a.id + "", bId = b.id + "";
    return aId < bId ? -1 : aId > bId ? 1 : 0;
  };
  class Template {
    static getFunctionContent(fn) {
      return fn.toString().replace(FUNCTION_CONTENT_REGEX, "").replace(INDENT_MULTILINE_REGEX, "").replace(LINE_SEPARATOR_REGEX, "\n");
    }
    static toIdentifier(str) {
      return "string" != typeof str ? "" : str.replace(IDENTIFIER_NAME_REPLACE_REGEX, "_$1").replace(IDENTIFIER_ALPHA_NUMERIC_NAME_REPLACE_REGEX, "_");
    }
    static toComment(str) {
      return str ? `/*! ${str.replace(COMMENT_END_REGEX, "* /")} */` : "";
    }
    static toNormalComment(str) {
      return str ? `/* ${str.replace(COMMENT_END_REGEX, "* /")} */` : "";
    }
    static toPath(str) {
      return "string" != typeof str ? "" : str.replace(PATH_NAME_NORMALIZE_REPLACE_REGEX, "-").replace(MATCH_PADDED_HYPHENS_REPLACE_REGEX, "");
    }
    static numberToIdentifer(n) {
      return n < DELTA_A_TO_Z ? String.fromCharCode(START_LOWERCASE_ALPHABET_CODE + n) : n < 2 * DELTA_A_TO_Z ? String.fromCharCode(START_UPPERCASE_ALPHABET_CODE + n - DELTA_A_TO_Z) : Template.numberToIdentifer(n % (2 * DELTA_A_TO_Z)) + Template.numberToIdentifer(Math.floor(n / (2 * DELTA_A_TO_Z)));
    }
    static indent(s) {
      if (Array.isArray(s)) return s.map(Template.indent).join("\n");
      {
        const str = s.trimRight();
        if (!str) return "";
        return ("\n" === str[0] ? "" : "\t") + str.replace(/\n([^\n])/g, "\n\t$1");
      }
    }
    static prefix(s, prefix) {
      const str = Template.asString(s).trim();
      if (!str) return "";
      return ("\n" === str[0] ? "" : prefix) + str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
    }
    static asString(str) {
      return Array.isArray(str) ? str.join("\n") : str;
    }
    static getModulesArrayBounds(modules) {
      let maxId = -1 / 0, minId = 1 / 0;
      for (const module of modules) {
        if ("number" != typeof module.id) return !1;
        maxId < module.id && (maxId = module.id), minId > module.id && (minId = module.id);
      }
      minId < 16 + ("" + minId).length && (minId = 0);
      const objectOverhead = modules.map(module => (module.id + "").length + 2).reduce((a, b) => a + b, -1);
      return (0 === minId ? maxId : 16 + ("" + minId).length + maxId) < objectOverhead && [ minId, maxId ];
    }
    static renderChunkModules(chunk, filterFn, moduleTemplate, dependencyTemplates, prefix = "") {
      const source = new ConcatSource, modules = chunk.getModules().filter(filterFn);
      let removedModules;
      if (chunk instanceof HotUpdateChunk && (removedModules = chunk.removedModules), 
      0 === modules.length && (!removedModules || 0 === removedModules.length)) return source.add("[]"), 
      source;
      const allModules = modules.map(module => ({
        id: module.id,
        source: moduleTemplate.render(module, dependencyTemplates, {
          chunk: chunk
        })
      }));
      if (removedModules && removedModules.length > 0) for (const id of removedModules) allModules.push({
        id: id,
        source: "false"
      });
      const bounds = Template.getModulesArrayBounds(allModules);
      if (bounds) {
        const minId = bounds[0], maxId = bounds[1];
        0 !== minId && source.add(`Array(${minId}).concat(`), source.add("[\n");
        const modules = new Map;
        for (const module of allModules) modules.set(module.id, module);
        for (let idx = minId; idx <= maxId; idx++) {
          const module = modules.get(idx);
          idx !== minId && source.add(",\n"), source.add(`/* ${idx} */`), module && (source.add("\n"), 
          source.add(module.source));
        }
        source.add("\n" + prefix + "]"), 0 !== minId && source.add(")");
      } else source.add("{\n"), allModules.sort(stringifyIdSortPredicate).forEach((module, idx) => {
        0 !== idx && source.add(",\n"), source.add(`\n/***/ ${JSON.stringify(module.id)}:\n`), 
        source.add(module.source);
      }), source.add(`\n\n${prefix}}`);
      return source;
    }
  }
  module.exports = Template;
}, function(module, exports) {
  module.exports = require("path");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Dependency = __webpack_require__(19);
  module.exports = class extends Dependency {
    constructor(request) {
      super(), this.request = request, this.userRequest = request;
    }
    getResourceIdentifier() {
      return "module" + this.request;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class ConstDependency extends NullDependency {
    constructor(expression, range, requireWebpackRequire) {
      super(), this.expression = expression, this.range = range, this.requireWebpackRequire = requireWebpackRequire;
    }
    updateHash(hash) {
      hash.update(this.range + ""), hash.update(this.expression + "");
    }
  }
  ConstDependency.Template = class {
    apply(dep, source) {
      "number" != typeof dep.range ? source.replace(dep.range[0], dep.range[1] - 1, dep.expression) : source.insert(dep.range, dep.expression);
    }
  }, module.exports = ConstDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.__esModule = !0, exports.Tapable = __webpack_require__(90), exports.SyncHook = __webpack_require__(92), 
  exports.SyncBailHook = __webpack_require__(91), exports.SyncWaterfallHook = __webpack_require__(184), 
  exports.SyncLoopHook = __webpack_require__(185), exports.AsyncParallelHook = __webpack_require__(186), 
  exports.AsyncParallelBailHook = __webpack_require__(187), exports.AsyncSeriesHook = __webpack_require__(93), 
  exports.AsyncSeriesBailHook = __webpack_require__(94), exports.AsyncSeriesWaterfallHook = __webpack_require__(188), 
  exports.HookMap = __webpack_require__(189), exports.MultiHook = __webpack_require__(190);
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Dependency = __webpack_require__(19);
  class NullDependency extends Dependency {
    get type() {
      return "null";
    }
    updateHash() {}
  }
  NullDependency.Template = class {
    apply() {}
  }, module.exports = NullDependency;
}, function(module, exports) {
  module.exports = require("./schema-utils");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), BasicEvaluatedExpression = __webpack_require__(70), ConstDependency = __webpack_require__(5), UnsupportedFeatureWarning = __webpack_require__(74), ParserHelpers = exports;
  ParserHelpers.addParsedVariableToModule = (parser, name, expression) => {
    if (!parser.state.current.addVariable) return !1;
    var deps = [];
    return parser.parse(expression, {
      current: {
        addDependency: dep => {
          dep.userRequest = name, deps.push(dep);
        }
      },
      module: parser.state.module
    }), parser.state.current.addVariable(name, expression, deps), !0;
  }, ParserHelpers.requireFileAsExpression = (context, pathToModule) => {
    var moduleJsPath = path.relative(context, pathToModule);
    return /^[A-Z]:/i.test(moduleJsPath) || (moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/")), 
    "require(" + JSON.stringify(moduleJsPath) + ")";
  }, ParserHelpers.toConstantDependency = (parser, value) => function(expr) {
    var dep = new ConstDependency(value, expr.range, !1);
    return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
  }, ParserHelpers.toConstantDependencyWithWebpackRequire = (parser, value) => function(expr) {
    var dep = new ConstDependency(value, expr.range, !0);
    return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
  }, ParserHelpers.evaluateToString = value => function(expr) {
    return (new BasicEvaluatedExpression).setString(value).setRange(expr.range);
  }, ParserHelpers.evaluateToBoolean = value => function(expr) {
    return (new BasicEvaluatedExpression).setBoolean(value).setRange(expr.range);
  }, ParserHelpers.evaluateToIdentifier = (identifier, truthy) => function(expr) {
    let evex = (new BasicEvaluatedExpression).setIdentifier(identifier).setRange(expr.range);
    return !0 === truthy ? evex = evex.setTruthy() : !1 === truthy && (evex = evex.setFalsy()), 
    evex;
  }, ParserHelpers.expressionIsUnsupported = (parser, message) => function(expr) {
    var dep = new ConstDependency("(void 0)", expr.range, !1);
    if (dep.loc = expr.loc, parser.state.current.addDependency(dep), parser.state.module) return parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, message, expr.loc)), 
    !0;
  }, ParserHelpers.skipTraversal = function() {
    return !0;
  }, ParserHelpers.approve = function() {
    return !0;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    create(data, callback) {
      return callback();
    }
  };
}, function(module, exports) {
  module.exports = require("util");
}, function(module, exports, __webpack_require__) {
  !function(global, factory) {
    "use strict";
    !function(exports) {
      var nextTick, asyncNextTick, asyncSetImmediate, noop = function() {}, throwError = function() {
        throw new Error("Callback was already called.");
      }, obj = "object", func = "function", isArray = Array.isArray, nativeKeys = Object.keys, nativePush = Array.prototype.push, iteratorSymbol = typeof Symbol === func && Symbol.iterator;
      createImmediate();
      var each = function(arrayEach, baseEach, symbolEach) {
        return function(collection, iterator, callback) {
          var size, keys;
          callback = once(callback || noop);
          var completed = 0;
          function done(err, bool) {
            err ? (callback = once(callback))(err) : ++completed === size ? callback(null) : !1 === bool && (callback = once(callback))(null);
          }
          isArray(collection) ? (size = collection.length, arrayEach(collection, iterator, done)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, iterator, done)) && size === completed && callback(null) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, baseEach(collection, iterator, done, keys))), size || callback(null);
        };
      }((function(array, iterator, callback) {
        var index = -1, size = array.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(array[index], index, onlyOnce(callback)); else for (;++index < size; ) iterator(array[index], onlyOnce(callback));
      }), (function(object, iterator, callback, keys) {
        var key, index = -1, size = keys.length;
        if (3 === iterator.length) for (;++index < size; ) key = keys[index], iterator(object[key], key, onlyOnce(callback)); else for (;++index < size; ) iterator(object[keys[index]], onlyOnce(callback));
      }), (function(collection, iterator, callback) {
        var item, iter = collection[iteratorSymbol](), index = 0;
        if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(item.value, index++, onlyOnce(callback)); else for (;!1 === (item = iter.next()).done; ) index++, 
        iterator(item.value, onlyOnce(callback));
        return index;
      })), map = createMap(arrayEachIndex, baseEachIndex, symbolEachIndex, !0), mapValues = createMap(arrayEachIndex, (function(object, iterator, createCallback, keys) {
        var key, index = -1, size = keys.length;
        if (3 === iterator.length) for (;++index < size; ) key = keys[index], iterator(object[key], key, createCallback(key)); else for (;++index < size; ) key = keys[index], 
        iterator(object[key], createCallback(key));
      }), (function(collection, iterator, createCallback) {
        var item, index = 0, iter = collection[iteratorSymbol]();
        if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(item.value, index, createCallback(index++)); else for (;!1 === (item = iter.next()).done; ) iterator(item.value, createCallback(index++));
        return index;
      }), !1), filter = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, !0), filterSeries = createFilterSeries(!0), filterLimit = createFilterLimit(!0), reject = createFilter(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue, !1), rejectSeries = createFilterSeries(!1), rejectLimit = createFilterLimit(!1), detect = createDetect(arrayEachValue, baseEachValue, symbolEachValue, !0), detectSeries = createDetectSeries(!0), detectLimit = createDetectLimit(!0), every = function(arrayEach, baseEach, symbolEach) {
        var deny = createDetect(arrayEach, baseEach, symbolEach, !1);
        return function(collection, iterator, callback) {
          callback = callback || noop, deny(collection, iterator, (function(err, res) {
            if (err) return callback(err);
            callback(null, !res);
          }));
        };
      }(arrayEachValue, baseEachValue, symbolEachValue), everySeries = (denySeries = createDetectSeries(!1), 
      function(collection, iterator, callback) {
        callback = callback || noop, denySeries(collection, iterator, (function(err, res) {
          if (err) return callback(err);
          callback(null, !res);
        }));
      }), everyLimit = (denyLimit = createDetectLimit(!1), function(collection, limit, iterator, callback) {
        callback = callback || noop, denyLimit(collection, limit, iterator, (function(err, res) {
          if (err) return callback(err);
          callback(null, !res);
        }));
      }), pick = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, !0), pickSeries = createPickSeries(!0), pickLimit = createPickLimit(!0), omit = createPick(arrayEachIndexValue, baseEachKeyValue, symbolEachKeyValue, !1), omitSeries = createPickSeries(!1), omitLimit = createPickLimit(!1), transform = function(arrayEach, baseEach, symbolEach) {
        return function(collection, accumulator, iterator, callback) {
          var size, keys, result;
          3 === arguments.length && (callback = iterator, iterator = accumulator, accumulator = void 0), 
          callback = callback || noop;
          var completed = 0;
          function done(err, bool) {
            err ? (callback = once(callback))(err, isArray(result) ? createArray(result) : objectClone(result)) : ++completed === size ? callback(null, result) : !1 === bool && (callback = once(callback))(null, isArray(result) ? createArray(result) : objectClone(result));
          }
          isArray(collection) ? (size = collection.length, arrayEach(collection, result = void 0 !== accumulator ? accumulator : [], iterator, done)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, result = void 0 !== accumulator ? accumulator : {}, iterator, done)) && size === completed && callback(null, result) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, baseEach(collection, result = void 0 !== accumulator ? accumulator : {}, iterator, done, keys))), 
          size || callback(null, void 0 !== accumulator ? accumulator : result || {});
        };
      }((function(array, result, iterator, callback) {
        var index = -1, size = array.length;
        if (4 === iterator.length) for (;++index < size; ) iterator(result, array[index], index, onlyOnce(callback)); else for (;++index < size; ) iterator(result, array[index], onlyOnce(callback));
      }), (function(object, result, iterator, callback, keys) {
        var key, index = -1, size = keys.length;
        if (4 === iterator.length) for (;++index < size; ) key = keys[index], iterator(result, object[key], key, onlyOnce(callback)); else for (;++index < size; ) iterator(result, object[keys[index]], onlyOnce(callback));
      }), (function(collection, result, iterator, callback) {
        var item, index = 0, iter = collection[iteratorSymbol]();
        if (4 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(result, item.value, index++, onlyOnce(callback)); else for (;!1 === (item = iter.next()).done; ) index++, 
        iterator(result, item.value, onlyOnce(callback));
        return index;
      })), sortBy = function(arrayEach, baseEach, symbolEach) {
        return function(collection, iterator, callback) {
          var size, array, criteria;
          callback = callback || noop;
          var completed = 0;
          if (isArray(collection)) size = collection.length, array = Array(size), criteria = Array(size), 
          arrayEach(collection, iterator, createCallback); else if (collection) {
            if (iteratorSymbol && collection[iteratorSymbol]) array = [], criteria = [], (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, sortByCriteria(array, criteria)); else if (typeof collection === obj) {
              var keys = nativeKeys(collection);
              size = keys.length, array = Array(size), criteria = Array(size), baseEach(collection, iterator, createCallback, keys);
            }
          } else ;
          function createCallback(index, value) {
            var called = !1;
            return array[index] = value, function(err, criterion) {
              called && throwError(), called = !0, criteria[index] = criterion, err ? (callback = once(callback))(err) : ++completed === size && callback(null, sortByCriteria(array, criteria));
            };
          }
          size || callback(null, []);
        };
      }(arrayEachIndexValue, baseEachIndexValue, symbolEachIndexValue), concat = function(arrayEach, baseEach, symbolEach) {
        return function(collection, iterator, callback) {
          var size, result;
          callback = callback || noop;
          var completed = 0;
          if (isArray(collection)) size = collection.length, result = Array(size), arrayEach(collection, iterator, createCallback); else if (collection) {
            if (iteratorSymbol && collection[iteratorSymbol]) result = [], (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result); else if (typeof collection === obj) {
              var keys = nativeKeys(collection);
              size = keys.length, result = Array(size), baseEach(collection, iterator, createCallback, keys);
            }
          } else ;
          function createCallback(index) {
            return function(err, res) {
              if (null === index && throwError(), err) return index = null, callback = once(callback), 
              arrayEachSync(result, (function(array, index) {
                void 0 === array && (result[index] = noop);
              })), void callback(err, makeConcatResult(result));
              switch (arguments.length) {
               case 0:
               case 1:
                result[index] = noop;
                break;

               case 2:
                result[index] = res;
                break;

               default:
                result[index] = slice(arguments, 1);
              }
              index = null, ++completed === size && callback(null, makeConcatResult(result));
            };
          }
          size || callback(null, []);
        };
      }(arrayEachIndex, baseEachIndex, symbolEachIndex), groupBy = function(arrayEach, baseEach, symbolEach) {
        return function(collection, iterator, callback) {
          var size;
          callback = callback || noop;
          var completed = 0, result = {};
          if (isArray(collection)) size = collection.length, arrayEach(collection, iterator, createCallback); else if (collection) {
            if (iteratorSymbol && collection[iteratorSymbol]) (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result); else if (typeof collection === obj) {
              var keys = nativeKeys(collection);
              size = keys.length, baseEach(collection, iterator, createCallback, keys);
            }
          } else ;
          function createCallback(value) {
            var called = !1;
            return function(err, key) {
              if (called && throwError(), called = !0, err) (callback = once(callback))(err, objectClone(result)); else {
                var array = result[key];
                array ? array.push(value) : result[key] = [ value ], ++completed === size && callback(null, result);
              }
            };
          }
          size || callback(null, {});
        };
      }(arrayEachValue, baseEachValue, symbolEachValue), parallel = function(arrayEach, baseEach) {
        return function(tasks, callback) {
          var size, keys, result;
          callback = callback || noop;
          var completed = 0;
          function createCallback(key) {
            return function(err, res) {
              if (null === key && throwError(), err) return key = null, void (callback = once(callback))(err, result);
              result[key] = arguments.length <= 2 ? res : slice(arguments, 1), key = null, ++completed === size && callback(null, result);
            };
          }
          isArray(tasks) ? (size = tasks.length, result = Array(size), arrayEach(tasks, createCallback)) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), 
          size = keys.length, result = {}, baseEach(tasks, createCallback, keys)), size || callback(null, result);
        };
      }((function(array, createCallback) {
        var index = -1, size = array.length;
        for (;++index < size; ) array[index](createCallback(index));
      }), (function(object, createCallback, keys) {
        var key, index = -1, size = keys.length;
        for (;++index < size; ) key = keys[index], object[key](createCallback(key));
      })), applyEach = createApplyEach(map), applyEachSeries = createApplyEach(mapSeries), log = createLogger("log"), dir = createLogger("dir"), index = {
        VERSION: "2.6.2",
        each: each,
        eachSeries: eachSeries,
        eachLimit: eachLimit,
        forEach: each,
        forEachSeries: eachSeries,
        forEachLimit: eachLimit,
        eachOf: each,
        eachOfSeries: eachSeries,
        eachOfLimit: eachLimit,
        forEachOf: each,
        forEachOfSeries: eachSeries,
        forEachOfLimit: eachLimit,
        map: map,
        mapSeries: mapSeries,
        mapLimit: function(collection, limit, iterator, callback) {
          var size, index, key, keys, iter, item, result, iterate;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && iterator(collection[index], index, createCallback(index));
          } : function() {
            (index = started++) < size && iterator(collection[index], createCallback(index));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          result = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? iterator(item.value, started, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          } : function() {
            !1 === (item = iter.next()).done ? iterator(item.value, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (key = keys[index], iterator(collection[key], key, createCallback(index)));
          } : function() {
            (index = started++) < size && iterator(collection[keys[index]], createCallback(index));
          }));
          if (!size || isNaN(limit) || limit < 1) return callback(null, []);
          function createCallback(index) {
            return function(err, res) {
              if (null === index && throwError(), err) return index = null, iterate = noop, void (callback = once(callback))(err, createArray(result));
              result[index] = res, index = null, ++completed === size ? (iterate = throwError, 
              callback(null, result), callback = throwError) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          result = result || Array(size), timesSync(limit > size ? size : limit, iterate);
        },
        mapValues: mapValues,
        mapValuesSeries: function(collection, iterator, callback) {
          var size, key, keys, iter, item, iterate;
          callback = callback || noop;
          var sync = !1, result = {}, completed = 0;
          isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            key = completed, iterator(collection[completed], completed, done);
          } : function() {
            key = completed, iterator(collection[completed], done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            key = completed, (item = iter.next()).done ? callback(null, result) : iterator(item.value, completed, done);
          } : function() {
            key = completed, (item = iter.next()).done ? callback(null, result) : iterator(item.value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            key = keys[completed], iterator(collection[key], key, done);
          } : function() {
            key = keys[completed], iterator(collection[key], done);
          }));
          if (!size) return callback(null, result);
          function done(err, res) {
            if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, objectClone(result));
            result[key] = res, ++completed === size ? (iterate = throwError, callback(null, result), 
            callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        },
        mapValuesLimit: function(collection, limit, iterator, callback) {
          var size, index, key, keys, iter, item, iterate;
          callback = callback || noop;
          var sync = !1, result = {}, started = 0, completed = 0;
          isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && iterator(collection[index], index, createCallback(index));
          } : function() {
            (index = started++) < size && iterator(collection[index], createCallback(index));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? iterator(item.value, started, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          } : function() {
            !1 === (item = iter.next()).done ? iterator(item.value, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (key = keys[index], iterator(collection[key], key, createCallback(key)));
          } : function() {
            (index = started++) < size && (key = keys[index], iterator(collection[key], createCallback(key)));
          }));
          if (!size || isNaN(limit) || limit < 1) return callback(null, result);
          function createCallback(key) {
            return function(err, res) {
              if (null === key && throwError(), err) return key = null, iterate = noop, void (callback = once(callback))(err, objectClone(result));
              result[key] = res, key = null, ++completed === size ? callback(null, result) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          timesSync(limit > size ? size : limit, iterate);
        },
        filter: filter,
        filterSeries: filterSeries,
        filterLimit: filterLimit,
        select: filter,
        selectSeries: filterSeries,
        selectLimit: filterLimit,
        reject: reject,
        rejectSeries: rejectSeries,
        rejectLimit: rejectLimit,
        detect: detect,
        detectSeries: detectSeries,
        detectLimit: detectLimit,
        find: detect,
        findSeries: detectSeries,
        findLimit: detectLimit,
        pick: pick,
        pickSeries: pickSeries,
        pickLimit: pickLimit,
        omit: omit,
        omitSeries: omitSeries,
        omitLimit: omitLimit,
        reduce: reduce,
        inject: reduce,
        foldl: reduce,
        reduceRight: reduceRight,
        foldr: reduceRight,
        transform: transform,
        transformSeries: function(collection, accumulator, iterator, callback) {
          3 === arguments.length && (callback = iterator, iterator = accumulator, accumulator = void 0);
          var size, key, keys, iter, item, iterate, result;
          callback = onlyOnce(callback || noop);
          var sync = !1, completed = 0;
          isArray(collection) ? (size = collection.length, result = void 0 !== accumulator ? accumulator : [], 
          iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), result = void 0 !== accumulator ? accumulator : {}, 
          iterate = 4 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, result = void 0 !== accumulator ? accumulator : {}, iterate = 4 === iterator.length ? objectIteratorWithKey : objectIterator));
          if (!size) return callback(null, void 0 !== accumulator ? accumulator : result || {});
          function arrayIterator() {
            iterator(result, collection[completed], done);
          }
          function arrayIteratorWithIndex() {
            iterator(result, collection[completed], completed, done);
          }
          function symbolIterator() {
            (item = iter.next()).done ? callback(null, result) : iterator(result, item.value, done);
          }
          function symbolIteratorWithKey() {
            (item = iter.next()).done ? callback(null, result) : iterator(result, item.value, completed, done);
          }
          function objectIterator() {
            iterator(result, collection[keys[completed]], done);
          }
          function objectIteratorWithKey() {
            key = keys[completed], iterator(result, collection[key], key, done);
          }
          function done(err, bool) {
            err ? callback(err, result) : ++completed === size || !1 === bool ? (iterate = throwError, 
            callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        },
        transformLimit: function(collection, limit, accumulator, iterator, callback) {
          4 === arguments.length && (callback = iterator, iterator = accumulator, accumulator = void 0);
          var size, index, key, keys, iter, item, iterate, result;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          isArray(collection) ? (size = collection.length, result = void 0 !== accumulator ? accumulator : [], 
          iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), result = void 0 !== accumulator ? accumulator : {}, 
          iterate = 4 === iterator.length ? symbolIteratorWithKey : symbolIterator) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, result = void 0 !== accumulator ? accumulator : {}, iterate = 4 === iterator.length ? objectIteratorWithKey : objectIterator));
          if (!size || isNaN(limit) || limit < 1) return callback(null, void 0 !== accumulator ? accumulator : result || {});
          function arrayIterator() {
            (index = started++) < size && iterator(result, collection[index], onlyOnce(done));
          }
          function arrayIteratorWithIndex() {
            (index = started++) < size && iterator(result, collection[index], index, onlyOnce(done));
          }
          function symbolIterator() {
            !1 === (item = iter.next()).done ? (started++, iterator(result, item.value, onlyOnce(done))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          }
          function symbolIteratorWithKey() {
            !1 === (item = iter.next()).done ? iterator(result, item.value, started++, onlyOnce(done)) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          }
          function objectIterator() {
            (index = started++) < size && iterator(result, collection[keys[index]], onlyOnce(done));
          }
          function objectIteratorWithKey() {
            (index = started++) < size && (key = keys[index], iterator(result, collection[key], key, onlyOnce(done)));
          }
          function done(err, bool) {
            err || !1 === bool ? (iterate = noop, callback(err || null, isArray(result) ? createArray(result) : objectClone(result)), 
            callback = noop) : ++completed === size ? (iterator = noop, callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, 
            iterate()), sync = !1;
          }
          timesSync(limit > size ? size : limit, iterate);
        },
        sortBy: sortBy,
        sortBySeries: function(collection, iterator, callback) {
          var size, key, value, keys, iter, item, array, criteria, iterate;
          callback = onlyOnce(callback || noop);
          var sync = !1, completed = 0;
          isArray(collection) ? (size = collection.length, array = collection, criteria = Array(size), 
          iterate = 3 === iterator.length ? function() {
            value = collection[completed], iterator(value, completed, done);
          } : function() {
            value = collection[completed], iterator(value, done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          array = [], criteria = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            if ((item = iter.next()).done) return callback(null, sortByCriteria(array, criteria));
            value = item.value, array[completed] = value, iterator(value, completed, done);
          } : function() {
            if ((item = iter.next()).done) return callback(null, sortByCriteria(array, criteria));
            value = item.value, array[completed] = value, iterator(value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          array = Array(size), criteria = Array(size), iterate = 3 === iterator.length ? function() {
            key = keys[completed], value = collection[key], array[completed] = value, iterator(value, key, done);
          } : function() {
            value = collection[keys[completed]], array[completed] = value, iterator(value, done);
          }));
          if (!size) return callback(null, []);
          function done(err, criterion) {
            criteria[completed] = criterion, err ? callback(err) : ++completed === size ? (iterate = throwError, 
            callback(null, sortByCriteria(array, criteria))) : sync ? nextTick(iterate) : (sync = !0, 
            iterate()), sync = !1;
          }
          iterate();
        },
        sortByLimit: function(collection, limit, iterator, callback) {
          var size, index, key, value, array, keys, iter, item, criteria, iterate;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          isArray(collection) ? (size = collection.length, array = collection, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value, index)));
          } : function() {
            started < size && (value = collection[started], iterator(value, createCallback(value, started++)));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), array = [], criteria = [], iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? (value = item.value, array[started] = value, 
            iterator(value, started, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, sortByCriteria(array, criteria)));
          } : function() {
            !1 === (item = iter.next()).done ? (value = item.value, array[started] = value, 
            iterator(value, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, sortByCriteria(array, criteria)));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          array = Array(size), iterate = 3 === iterator.length ? function() {
            started < size && (key = keys[started], value = collection[key], array[started] = value, 
            iterator(value, key, createCallback(value, started++)));
          } : function() {
            started < size && (value = collection[keys[started]], array[started] = value, iterator(value, createCallback(value, started++)));
          }));
          if (!size || isNaN(limit) || limit < 1) return callback(null, []);
          function createCallback(value, index) {
            var called = !1;
            return function(err, criterion) {
              called && throwError(), called = !0, criteria[index] = criterion, err ? (iterate = noop, 
              callback(err), callback = noop) : ++completed === size ? callback(null, sortByCriteria(array, criteria)) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          criteria = criteria || Array(size), timesSync(limit > size ? size : limit, iterate);
        },
        some: some,
        someSeries: someSeries,
        someLimit: someLimit,
        any: some,
        anySeries: someSeries,
        anyLimit: someLimit,
        every: every,
        everySeries: everySeries,
        everyLimit: everyLimit,
        all: every,
        allSeries: everySeries,
        allLimit: everyLimit,
        concat: concat,
        concatSeries: function(collection, iterator, callback) {
          var size, key, keys, iter, item, iterate;
          callback = onlyOnce(callback || noop);
          var sync = !1, result = [], completed = 0;
          isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            iterator(collection[completed], completed, done);
          } : function() {
            iterator(collection[completed], done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            (item = iter.next()).done ? callback(null, result) : iterator(item.value, completed, done);
          } : function() {
            (item = iter.next()).done ? callback(null, result) : iterator(item.value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            key = keys[completed], iterator(collection[key], key, done);
          } : function() {
            iterator(collection[keys[completed]], done);
          }));
          if (!size) return callback(null, result);
          function done(err, array) {
            isArray(array) ? nativePush.apply(result, array) : arguments.length >= 2 && nativePush.apply(result, slice(arguments, 1)), 
            err ? callback(err, result) : ++completed === size ? (iterate = throwError, callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, 
            iterate()), sync = !1;
          }
          iterate();
        },
        concatLimit: function(collection, limit, iterator, callback) {
          var size, key, iter, item, iterate, result;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          if (isArray(collection)) size = collection.length, iterate = 3 === iterator.length ? function() {
            started < size && iterator(collection[started], started, createCallback(started++));
          } : function() {
            started < size && iterator(collection[started], createCallback(started++));
          }; else if (collection) {
            if (iteratorSymbol && collection[iteratorSymbol]) size = 1 / 0, result = [], iter = collection[iteratorSymbol](), 
            iterate = 3 === iterator.length ? function() {
              !1 === (item = iter.next()).done ? iterator(item.value, started, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
              callback(null, makeConcatResult(result)));
            } : function() {
              !1 === (item = iter.next()).done ? iterator(item.value, createCallback(started++)) : completed === started && iterator !== noop && (iterator = noop, 
              callback(null, makeConcatResult(result)));
            }; else if (typeof collection === obj) {
              var keys = nativeKeys(collection);
              size = keys.length, iterate = 3 === iterator.length ? function() {
                started < size && (key = keys[started], iterator(collection[key], key, createCallback(started++)));
              } : function() {
                started < size && iterator(collection[keys[started]], createCallback(started++));
              };
            }
          } else ;
          if (!size || isNaN(limit) || limit < 1) return callback(null, []);
          function createCallback(index) {
            return function(err, res) {
              if (null === index && throwError(), err) return index = null, iterate = noop, callback = once(callback), 
              arrayEachSync(result, (function(array, index) {
                void 0 === array && (result[index] = noop);
              })), void callback(err, makeConcatResult(result));
              switch (arguments.length) {
               case 0:
               case 1:
                result[index] = noop;
                break;

               case 2:
                result[index] = res;
                break;

               default:
                result[index] = slice(arguments, 1);
              }
              index = null, ++completed === size ? (iterate = throwError, callback(null, makeConcatResult(result)), 
              callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
            };
          }
          result = result || Array(size), timesSync(limit > size ? size : limit, iterate);
        },
        groupBy: groupBy,
        groupBySeries: function(collection, iterator, callback) {
          var size, key, value, keys, iter, item, iterate;
          callback = onlyOnce(callback || noop);
          var sync = !1, completed = 0, result = {};
          isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            value = collection[completed], iterator(value, completed, done);
          } : function() {
            value = collection[completed], iterator(value, done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, completed, done);
          } : function() {
            item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            key = keys[completed], value = collection[key], iterator(value, key, done);
          } : function() {
            value = collection[keys[completed]], iterator(value, done);
          }));
          if (!size) return callback(null, result);
          function done(err, key) {
            if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, objectClone(result));
            var array = result[key];
            array ? array.push(value) : result[key] = [ value ], ++completed === size ? (iterate = throwError, 
            callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        },
        groupByLimit: function(collection, limit, iterator, callback) {
          var size, index, key, value, keys, iter, item, iterate;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0, result = {};
          isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value)));
          } : function() {
            started < size && (value = collection[started++], iterator(value, createCallback(value)));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? (value = item.value, iterator(value, started++, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          } : function() {
            !1 === (item = iter.next()).done ? (started++, value = item.value, iterator(value, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            started < size && (key = keys[started++], value = collection[key], iterator(value, key, createCallback(value)));
          } : function() {
            started < size && (value = collection[keys[started++]], iterator(value, createCallback(value)));
          }));
          if (!size || isNaN(limit) || limit < 1) return callback(null, result);
          function createCallback(value) {
            var called = !1;
            return function(err, key) {
              if (called && throwError(), called = !0, err) return iterate = noop, void (callback = once(callback))(err, objectClone(result));
              var array = result[key];
              array ? array.push(value) : result[key] = [ value ], ++completed === size ? callback(null, result) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          timesSync(limit > size ? size : limit, iterate);
        },
        parallel: parallel,
        series: function(tasks, callback) {
          var size, key, keys, result, iterate;
          callback = callback || noop;
          var sync = !1, completed = 0;
          if (isArray(tasks)) size = tasks.length, result = Array(size), iterate = function() {
            key = completed, tasks[completed](done);
          }; else {
            if (!tasks || typeof tasks !== obj) return callback(null);
            keys = nativeKeys(tasks), size = keys.length, result = {}, iterate = function() {
              key = keys[completed], tasks[key](done);
            };
          }
          if (!size) return callback(null, result);
          function done(err, res) {
            if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, result);
            result[key] = arguments.length <= 2 ? res : slice(arguments, 1), ++completed === size ? (iterate = throwError, 
            callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        },
        parallelLimit: function(tasks, limit, callback) {
          var size, index, key, keys, result, iterate;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          isArray(tasks) ? (size = tasks.length, result = Array(size), iterate = function() {
            (index = started++) < size && tasks[index](createCallback(index));
          }) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), size = keys.length, 
          result = {}, iterate = function() {
            started < size && (key = keys[started++], tasks[key](createCallback(key)));
          });
          if (!size || isNaN(limit) || limit < 1) return callback(null, result);
          function createCallback(key) {
            return function(err, res) {
              if (null === key && throwError(), err) return key = null, iterate = noop, void (callback = once(callback))(err, result);
              result[key] = arguments.length <= 2 ? res : slice(arguments, 1), key = null, ++completed === size ? callback(null, result) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          timesSync(limit > size ? size : limit, iterate);
        },
        tryEach: function(tasks, callback) {
          var size, keys, iterate;
          callback = callback || noop;
          var completed = 0;
          isArray(tasks) ? (size = tasks.length, iterate = function() {
            tasks[completed](done);
          }) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), size = keys.length, 
          iterate = function() {
            tasks[keys[completed]](done);
          });
          if (!size) return callback(null);
          function done(err, res) {
            err ? ++completed === size ? callback(err) : (!0, iterate()) : callback(null, arguments.length <= 2 ? res : slice(arguments, 1)), 
            !1;
          }
          iterate();
        },
        waterfall: function(tasks, callback) {
          if (!checkWaterfallTasks(tasks, callback = callback || noop)) return;
          var func, args, done, sync, completed = 0, size = tasks.length;
          function iterate() {
            waterfallIterator(func, args, createCallback(func));
          }
          function createCallback(index) {
            return function(err, res) {
              return void 0 === index && (callback = noop, throwError()), index = void 0, err ? (done = callback, 
              callback = throwError, void done(err)) : ++completed === size ? (done = callback, 
              callback = throwError, void (arguments.length <= 2 ? done(err, res) : done.apply(null, createArray(arguments)))) : (sync ? (args = arguments, 
              func = tasks[completed] || throwError, nextTick(iterate)) : (sync = !0, waterfallIterator(tasks[completed] || throwError, arguments, createCallback(completed))), 
              void (sync = !1));
            };
          }
          waterfallIterator(tasks[0], [], createCallback(0));
        },
        angelFall: angelFall,
        angelfall: angelFall,
        whilst: function(test, iterator, callback) {
          callback = callback || noop;
          var sync = !1;
          test() ? iterate() : callback(null);
          function iterate() {
            sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
          }
          function next() {
            iterator(done);
          }
          function done(err, arg) {
            if (err) return callback(err);
            arguments.length <= 2 ? test(arg) ? iterate() : callback(null, arg) : (arg = slice(arguments, 1), 
            test.apply(null, arg) ? iterate() : callback.apply(null, [ null ].concat(arg)));
          }
        },
        doWhilst: function(iterator, test, callback) {
          callback = callback || noop;
          var sync = !1;
          function iterate() {
            sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
          }
          function next() {
            iterator(done);
          }
          function done(err, arg) {
            if (err) return callback(err);
            arguments.length <= 2 ? test(arg) ? iterate() : callback(null, arg) : (arg = slice(arguments, 1), 
            test.apply(null, arg) ? iterate() : callback.apply(null, [ null ].concat(arg)));
          }
          next();
        },
        until: function(test, iterator, callback) {
          callback = callback || noop;
          var sync = !1;
          test() ? callback(null) : iterate();
          function iterate() {
            sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
          }
          function next() {
            iterator(done);
          }
          function done(err, arg) {
            if (err) return callback(err);
            arguments.length <= 2 ? test(arg) ? callback(null, arg) : iterate() : (arg = slice(arguments, 1), 
            test.apply(null, arg) ? callback.apply(null, [ null ].concat(arg)) : iterate());
          }
        },
        doUntil: function(iterator, test, callback) {
          callback = callback || noop;
          var sync = !1;
          function iterate() {
            sync ? nextTick(next) : (sync = !0, iterator(done)), sync = !1;
          }
          function next() {
            iterator(done);
          }
          function done(err, arg) {
            if (err) return callback(err);
            arguments.length <= 2 ? test(arg) ? callback(null, arg) : iterate() : (arg = slice(arguments, 1), 
            test.apply(null, arg) ? callback.apply(null, [ null ].concat(arg)) : iterate());
          }
          next();
        },
        during: function(test, iterator, callback) {
          function _test() {
            test(iterate);
          }
          function iterate(err, truth) {
            if (err) return callback(err);
            truth ? iterator(done) : callback(null);
          }
          function done(err) {
            if (err) return callback(err);
            _test();
          }
          callback = callback || noop, _test();
        },
        doDuring: function(iterator, test, callback) {
          function iterate(err, truth) {
            if (err) return callback(err);
            truth ? iterator(done) : callback(null);
          }
          function done(err, res) {
            if (err) return callback(err);
            switch (arguments.length) {
             case 0:
             case 1:
              test(iterate);
              break;

             case 2:
              test(res, iterate);
              break;

             default:
              var args = slice(arguments, 1);
              args.push(iterate), test.apply(null, args);
            }
          }
          callback = callback || noop, iterate(null, !0);
        },
        forever: function(iterator, callback) {
          var sync = !1;
          function iterate() {
            iterator(next);
          }
          function next(err) {
            if (err) {
              if (callback) return callback(err);
              throw err;
            }
            sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        },
        compose: function() {
          return seq.apply(null, reverse(arguments));
        },
        seq: seq,
        applyEach: applyEach,
        applyEachSeries: applyEachSeries,
        queue: function(worker, concurrency) {
          return baseQueue(!0, worker, concurrency);
        },
        priorityQueue: function(worker, concurrency) {
          var q = baseQueue(!0, worker, concurrency);
          return q.push = function(tasks, priority, callback) {
            q.started = !0, priority = priority || 0;
            var _tasks = isArray(tasks) ? tasks : [ tasks ], taskSize = _tasks.length;
            if (void 0 === tasks || 0 === taskSize) return void (q.idle() && nextTick(q.drain));
            callback = typeof callback === func ? callback : noop;
            var nextNode = q._tasks.head;
            for (;nextNode && priority >= nextNode.priority; ) nextNode = nextNode.next;
            for (;taskSize--; ) {
              var item = {
                data: _tasks[taskSize],
                priority: priority,
                callback: callback
              };
              nextNode ? q._tasks.insertBefore(nextNode, item) : q._tasks.push(item), nextTick(q.process);
            }
          }, delete q.unshift, q;
        },
        cargo: function(worker, payload) {
          return baseQueue(!1, worker, 1, payload);
        },
        auto: auto,
        autoInject: function(tasks, concurrency, callback) {
          var newTasks = {};
          baseEachSync(tasks, (function(task, key) {
            var params, taskLength = task.length;
            if (isArray(task)) {
              if (0 === taskLength) throw new Error("autoInject task functions require explicit parameters.");
              if (params = createArray(task), taskLength = params.length - 1, task = params[taskLength], 
              0 === taskLength) return void (newTasks[key] = task);
            } else {
              if (1 === taskLength) return void (newTasks[key] = task);
              if (params = function(func) {
                return func = (func = (func = (func = func.toString().replace(STRIP_COMMENTS, "")).match(FN_ARGS)[2].replace(" ", "")) ? func.split(FN_ARG_SPLIT) : []).map((function(arg) {
                  return arg.replace(FN_ARG, "").trim();
                }));
              }(task), 0 === taskLength && 0 === params.length) throw new Error("autoInject task functions require explicit parameters.");
              taskLength = params.length - 1;
            }
            params[taskLength] = function(results, done) {
              switch (taskLength) {
               case 1:
                task(results[params[0]], done);
                break;

               case 2:
                task(results[params[0]], results[params[1]], done);
                break;

               case 3:
                task(results[params[0]], results[params[1]], results[params[2]], done);
                break;

               default:
                for (var i = -1; ++i < taskLength; ) params[i] = results[params[i]];
                params[i] = done, task.apply(null, params);
              }
            }, newTasks[key] = params;
          }), nativeKeys(tasks)), auto(newTasks, concurrency, callback);
        },
        retry: retry,
        retryable: function(opts, task) {
          task || (task = opts, opts = null);
          return function() {
            var taskFn, args = createArray(arguments), lastIndex = args.length - 1, callback = args[lastIndex];
            switch (task.length) {
             case 1:
              taskFn = task1;
              break;

             case 2:
              taskFn = task2;
              break;

             case 3:
              taskFn = task3;
              break;

             default:
              taskFn = task4;
            }
            opts ? retry(opts, taskFn, callback) : retry(taskFn, callback);
            function task1(done) {
              task(done);
            }
            function task2(done) {
              task(args[0], done);
            }
            function task3(done) {
              task(args[0], args[1], done);
            }
            function task4(callback) {
              args[lastIndex] = callback, task.apply(null, args);
            }
          };
        },
        iterator: function(tasks) {
          var size = 0, keys = [];
          isArray(tasks) ? size = tasks.length : (keys = nativeKeys(tasks), size = keys.length);
          return function makeCallback(index) {
            var fn = function() {
              if (size) {
                var key = keys[index] || index;
                tasks[key].apply(null, createArray(arguments));
              }
              return fn.next();
            };
            return fn.next = function() {
              return index < size - 1 ? makeCallback(index + 1) : null;
            }, fn;
          }(0);
        },
        times: function(n, iterator, callback) {
          if (callback = callback || noop, n = +n, isNaN(n) || n < 1) return callback(null, []);
          var result = Array(n);
          timesSync(n, (function(num) {
            iterator(num, function(index) {
              return function(err, res) {
                null === index && throwError(), result[index] = res, index = null, err ? (callback(err), 
                callback = noop) : 0 == --n && callback(null, result);
              };
            }(num));
          }));
        },
        timesSeries: function(n, iterator, callback) {
          if (callback = callback || noop, n = +n, isNaN(n) || n < 1) return callback(null, []);
          var result = Array(n), sync = !1, completed = 0;
          function iterate() {
            iterator(completed, done);
          }
          function done(err, res) {
            result[completed] = res, err ? (callback(err), callback = throwError) : ++completed >= n ? (callback(null, result), 
            callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        },
        timesLimit: function(n, limit, iterator, callback) {
          if (callback = callback || noop, n = +n, isNaN(n) || n < 1 || isNaN(limit) || limit < 1) return callback(null, []);
          var result = Array(n), sync = !1, started = 0, completed = 0;
          function iterate() {
            var index = started++;
            index < n && iterator(index, function(index) {
              return function(err, res) {
                null === index && throwError(), result[index] = res, index = null, err ? (callback(err), 
                callback = noop) : ++completed >= n ? (callback(null, result), callback = throwError) : sync ? nextTick(iterate) : (sync = !0, 
                iterate()), sync = !1;
              };
            }(index));
          }
          timesSync(limit > n ? n : limit, iterate);
        },
        race: function(tasks, callback) {
          var size, keys;
          callback = once(callback || noop);
          var index = -1;
          if (isArray(tasks)) for (size = tasks.length; ++index < size; ) tasks[index](callback); else {
            if (!tasks || typeof tasks !== obj) return callback(new TypeError("First argument to race must be a collection of functions"));
            for (keys = nativeKeys(tasks), size = keys.length; ++index < size; ) tasks[keys[index]](callback);
          }
          size || callback(null);
        },
        apply: function(func) {
          switch (arguments.length) {
           case 0:
           case 1:
            return func;

           case 2:
            return func.bind(null, arguments[1]);

           case 3:
            return func.bind(null, arguments[1], arguments[2]);

           case 4:
            return func.bind(null, arguments[1], arguments[2], arguments[3]);

           case 5:
            return func.bind(null, arguments[1], arguments[2], arguments[3], arguments[4]);

           default:
            var size = arguments.length, index = 0, args = Array(size);
            for (args[index] = null; ++index < size; ) args[index] = arguments[index];
            return func.bind.apply(func, args);
          }
        },
        nextTick: asyncNextTick,
        setImmediate: asyncSetImmediate,
        memoize: function(fn, hasher) {
          hasher = hasher || function(hash) {
            return hash;
          };
          var memo = {}, queues = {}, memoized = function() {
            var args = createArray(arguments), callback = args.pop(), key = hasher.apply(null, args);
            if (has(memo, key)) nextTick((function() {
              callback.apply(null, memo[key]);
            })); else {
              if (has(queues, key)) return queues[key].push(callback);
              queues[key] = [ callback ], args.push(done), fn.apply(null, args);
            }
            function done(err) {
              var args = createArray(arguments);
              err || (memo[key] = args);
              var q = queues[key];
              delete queues[key];
              for (var i = -1, size = q.length; ++i < size; ) q[i].apply(null, args);
            }
          };
          return memoized.memo = memo, memoized.unmemoized = fn, memoized;
        },
        unmemoize: function(fn) {
          return function() {
            return (fn.unmemoized || fn).apply(null, arguments);
          };
        },
        ensureAsync: function(fn) {
          return function() {
            var args = createArray(arguments), lastIndex = args.length - 1, callback = args[lastIndex], sync = !0;
            function done() {
              var innerArgs = createArray(arguments);
              sync ? nextTick((function() {
                callback.apply(null, innerArgs);
              })) : callback.apply(null, innerArgs);
            }
            args[lastIndex] = done, fn.apply(this, args), sync = !1;
          };
        },
        constant: function() {
          var args = [ null ].concat(createArray(arguments));
          return function(callback) {
            (callback = arguments[arguments.length - 1]).apply(this, args);
          };
        },
        asyncify: asyncify,
        wrapSync: asyncify,
        log: log,
        dir: dir,
        reflect: reflect,
        reflectAll: function(tasks) {
          var newTasks, keys;
          isArray(tasks) ? (newTasks = Array(tasks.length), arrayEachSync(tasks, iterate)) : tasks && typeof tasks === obj && (keys = nativeKeys(tasks), 
          newTasks = {}, baseEachSync(tasks, iterate, keys));
          return newTasks;
          function iterate(func, key) {
            newTasks[key] = reflect(func);
          }
        },
        timeout: function(func, millisec, info) {
          var callback, timer;
          return function() {
            timer = setTimeout(timeoutCallback, millisec);
            var args = createArray(arguments), lastIndex = args.length - 1;
            callback = args[lastIndex], args[lastIndex] = injectedCallback, simpleApply(func, args);
          };
          function timeoutCallback() {
            var name = func.name || "anonymous", err = new Error('Callback function "' + name + '" timed out.');
            err.code = "ETIMEDOUT", info && (err.info = info), timer = null, callback(err);
          }
          function injectedCallback() {
            null !== timer && (simpleApply(callback, createArray(arguments)), clearTimeout(timer));
          }
          function simpleApply(func, args) {
            switch (args.length) {
             case 0:
              func();
              break;

             case 1:
              func(args[0]);
              break;

             case 2:
              func(args[0], args[1]);
              break;

             default:
              func.apply(null, args);
            }
          }
        },
        createLogger: createLogger,
        safe: function() {
          return createImmediate(), exports;
        },
        fast: function() {
          return createImmediate(!1), exports;
        }
      };
      var denyLimit;
      var denySeries;
      function createImmediate(safeMode) {
        asyncSetImmediate = typeof setImmediate === func ? setImmediate : function(fn) {
          var args = slice(arguments, 1);
          setTimeout((function() {
            fn.apply(null, args);
          }));
        }, typeof process === obj && typeof process.nextTick === func ? (nextTick = /^v0.10/.test(process.version) ? asyncSetImmediate : process.nextTick, 
        asyncNextTick = /^v0/.test(process.version) ? asyncSetImmediate : process.nextTick) : asyncNextTick = nextTick = asyncSetImmediate, 
        !1 === safeMode && (nextTick = function(cb) {
          cb();
        });
      }
      function createArray(array) {
        for (var index = -1, size = array.length, result = Array(size); ++index < size; ) result[index] = array[index];
        return result;
      }
      function slice(array, start) {
        var index = -1, size = array.length - start;
        if (size <= 0) return [];
        for (var result = Array(size); ++index < size; ) result[index] = array[index + start];
        return result;
      }
      function objectClone(object) {
        for (var keys = nativeKeys(object), size = keys.length, index = -1, result = {}; ++index < size; ) {
          var key = keys[index];
          result[key] = object[key];
        }
        return result;
      }
      function compact(array) {
        for (var index = -1, size = array.length, result = []; ++index < size; ) {
          var value = array[index];
          value && (result[result.length] = value);
        }
        return result;
      }
      function reverse(array) {
        for (var index = -1, size = array.length, result = Array(size), resIndex = size; ++index < size; ) result[--resIndex] = array[index];
        return result;
      }
      function has(object, key) {
        return object.hasOwnProperty(key);
      }
      function notInclude(array, target) {
        for (var index = -1, size = array.length; ++index < size; ) if (array[index] === target) return !1;
        return !0;
      }
      function arrayEachSync(array, iterator) {
        for (var index = -1, size = array.length; ++index < size; ) iterator(array[index], index);
        return array;
      }
      function baseEachSync(object, iterator, keys) {
        for (var index = -1, size = keys.length; ++index < size; ) {
          var key = keys[index];
          iterator(object[key], key);
        }
        return object;
      }
      function timesSync(n, iterator) {
        for (var index = -1; ++index < n; ) iterator(index);
      }
      function sortByCriteria(array, criteria) {
        var i, l = array.length, indices = Array(l);
        for (i = 0; i < l; i++) indices[i] = i;
        !function quickSort(array, i, j, indices) {
          if (i === j) return;
          var k = i;
          for (;++k <= j && array[i] === array[k]; ) {
            var l = k - 1;
            if (indices[l] > indices[k]) {
              var index = indices[l];
              indices[l] = indices[k], indices[k] = index;
            }
          }
          if (k > j) return;
          var p = array[i] > array[k] ? i : k;
          k = function(array, i, j, mid, indices) {
            var l = i, r = j;
            for (;l <= r; ) {
              for (i = l; l < r && array[l] < mid; ) l++;
              for (;r >= i && array[r] >= mid; ) r--;
              if (l > r) break;
              swap(array, indices, l++, r--);
            }
            return l;
          }(array, i, j, array[p], indices), quickSort(array, i, k - 1, indices), quickSort(array, k, j, indices);
        }(criteria, 0, l - 1, indices);
        for (var result = Array(l), n = 0; n < l; n++) i = indices[n], result[n] = void 0 === i ? array[n] : array[i];
        return result;
      }
      function swap(array, indices, l, r) {
        var n = array[l];
        array[l] = array[r], array[r] = n;
        var i = indices[l];
        indices[l] = indices[r], indices[r] = i;
      }
      function makeConcatResult(array) {
        var result = [];
        return arrayEachSync(array, (function(value) {
          value !== noop && (isArray(value) ? nativePush.apply(result, value) : result.push(value));
        })), result;
      }
      function arrayEachIndex(array, iterator, createCallback) {
        var index = -1, size = array.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(array[index], index, createCallback(index)); else for (;++index < size; ) iterator(array[index], createCallback(index));
      }
      function baseEachIndex(object, iterator, createCallback, keys) {
        var key, index = -1, size = keys.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(object[key = keys[index]], key, createCallback(index)); else for (;++index < size; ) iterator(object[keys[index]], createCallback(index));
      }
      function symbolEachIndex(collection, iterator, createCallback) {
        var item, index = 0, iter = collection[iteratorSymbol]();
        if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(item.value, index, createCallback(index++)); else for (;!1 === (item = iter.next()).done; ) iterator(item.value, createCallback(index++));
        return index;
      }
      function arrayEachValue(array, iterator, createCallback) {
        var value, index = -1, size = array.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(value = array[index], index, createCallback(value)); else for (;++index < size; ) iterator(value = array[index], createCallback(value));
      }
      function baseEachValue(object, iterator, createCallback, keys) {
        var key, value, index = -1, size = keys.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(value = object[key = keys[index]], key, createCallback(value)); else for (;++index < size; ) iterator(value = object[keys[index]], createCallback(value));
      }
      function symbolEachValue(collection, iterator, createCallback) {
        var value, item, index = 0, iter = collection[iteratorSymbol]();
        if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, index++, createCallback(value)); else for (;!1 === (item = iter.next()).done; ) index++, 
        iterator(value = item.value, createCallback(value));
        return index;
      }
      function arrayEachIndexValue(array, iterator, createCallback) {
        var value, index = -1, size = array.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(value = array[index], index, createCallback(index, value)); else for (;++index < size; ) iterator(value = array[index], createCallback(index, value));
      }
      function baseEachIndexValue(object, iterator, createCallback, keys) {
        var key, value, index = -1, size = keys.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(value = object[key = keys[index]], key, createCallback(index, value)); else for (;++index < size; ) iterator(value = object[keys[index]], createCallback(index, value));
      }
      function symbolEachIndexValue(collection, iterator, createCallback) {
        var value, item, index = 0, iter = collection[iteratorSymbol]();
        if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, index, createCallback(index++, value)); else for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, createCallback(index++, value));
        return index;
      }
      function baseEachKeyValue(object, iterator, createCallback, keys) {
        var key, value, index = -1, size = keys.length;
        if (3 === iterator.length) for (;++index < size; ) iterator(value = object[key = keys[index]], key, createCallback(key, value)); else for (;++index < size; ) iterator(value = object[key = keys[index]], createCallback(key, value));
      }
      function symbolEachKeyValue(collection, iterator, createCallback) {
        var value, item, index = 0, iter = collection[iteratorSymbol]();
        if (3 === iterator.length) for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, index, createCallback(index++, value)); else for (;!1 === (item = iter.next()).done; ) iterator(value = item.value, createCallback(index++, value));
        return index;
      }
      function onlyOnce(func) {
        return function(err, res) {
          var fn = func;
          func = throwError, fn(err, res);
        };
      }
      function once(func) {
        return function(err, res) {
          var fn = func;
          func = noop, fn(err, res);
        };
      }
      function createMap(arrayEach, baseEach, symbolEach, useArray) {
        var init, clone;
        return useArray ? (init = Array, clone = createArray) : (init = function() {
          return {};
        }, clone = objectClone), function(collection, iterator, callback) {
          var size, keys, result;
          callback = callback || noop;
          var completed = 0;
          function createCallback(key) {
            return function(err, res) {
              if (null === key && throwError(), err) return key = null, void (callback = once(callback))(err, clone(result));
              result[key] = res, key = null, ++completed === size && callback(null, result);
            };
          }
          isArray(collection) ? (size = collection.length, result = init(size), arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (result = init(0), 
          (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result)) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, result = init(size), baseEach(collection, iterator, createCallback, keys))), 
          size || callback(null, init());
        };
      }
      function createFilter(arrayEach, baseEach, symbolEach, bool) {
        return function(collection, iterator, callback) {
          var size, keys, result;
          callback = callback || noop;
          var completed = 0;
          if (isArray(collection) ? (size = collection.length, result = Array(size), arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (result = [], 
          (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, compact(result))) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, result = Array(size), baseEach(collection, iterator, createCallback, keys))), 
          !size) return callback(null, []);
          function createCallback(index, value) {
            return function(err, res) {
              if (null === index && throwError(), err) return index = null, void (callback = once(callback))(err);
              !!res === bool && (result[index] = value), index = null, ++completed === size && callback(null, compact(result));
            };
          }
        };
      }
      function createFilterSeries(bool) {
        return function(collection, iterator, callback) {
          var size, key, value, keys, iter, item, iterate;
          callback = onlyOnce(callback || noop);
          var sync = !1, completed = 0, result = [];
          if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            value = collection[completed], iterator(value, completed, done);
          } : function() {
            value = collection[completed], iterator(value, done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, completed, done);
          } : function() {
            item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            key = keys[completed], value = collection[key], iterator(value, key, done);
          } : function() {
            key = keys[completed], value = collection[key], iterator(value, done);
          })), !size) return callback(null, []);
          function done(err, res) {
            err ? callback(err) : (!!res === bool && (result[result.length] = value), ++completed === size ? (iterate = throwError, 
            callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1);
          }
          iterate();
        };
      }
      function createFilterLimit(bool) {
        return function(collection, limit, iterator, callback) {
          var size, index, key, value, keys, iter, item, iterate, result;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value, index)));
          } : function() {
            (index = started++) < size && (value = collection[index], iterator(value, createCallback(value, index)));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          result = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? (value = item.value, iterator(value, started, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, compact(result)));
          } : function() {
            !1 === (item = iter.next()).done ? (value = item.value, iterator(value, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, compact(result)));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (key = keys[index], value = collection[key], iterator(value, key, createCallback(value, index)));
          } : function() {
            (index = started++) < size && (value = collection[keys[index]], iterator(value, createCallback(value, index)));
          })), !size || isNaN(limit) || limit < 1) return callback(null, []);
          function createCallback(value, index) {
            return function(err, res) {
              if (null === index && throwError(), err) return index = null, iterate = noop, void (callback = once(callback))(err);
              !!res === bool && (result[index] = value), index = null, ++completed === size ? (callback = onlyOnce(callback))(null, compact(result)) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          result = result || Array(size), timesSync(limit > size ? size : limit, iterate);
        };
      }
      function eachSeries(collection, iterator, callback) {
        var size, key, keys, iter, item, iterate;
        callback = onlyOnce(callback || noop);
        var sync = !1, completed = 0;
        if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
          iterator(collection[completed], completed, done);
        } : function() {
          iterator(collection[completed], done);
        }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
        iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
          (item = iter.next()).done ? callback(null) : iterator(item.value, completed, done);
        } : function() {
          (item = iter.next()).done ? callback(null) : iterator(item.value, done);
        }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
        iterate = 3 === iterator.length ? function() {
          key = keys[completed], iterator(collection[key], key, done);
        } : function() {
          iterator(collection[keys[completed]], done);
        })), !size) return callback(null);
        function done(err, bool) {
          err ? callback(err) : ++completed === size || !1 === bool ? (iterate = throwError, 
          callback(null)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
        }
        iterate();
      }
      function eachLimit(collection, limit, iterator, callback) {
        var size, index, key, keys, iter, item, iterate;
        callback = callback || noop;
        var sync = !1, started = 0, completed = 0;
        if (isArray(collection)) size = collection.length, iterate = 3 === iterator.length ? function() {
          (index = started++) < size && iterator(collection[index], index, done);
        } : function() {
          started < size && iterator(collection[started++], done);
        }; else if (collection) if (iteratorSymbol && collection[iteratorSymbol]) size = 1 / 0, 
        iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
          !1 === (item = iter.next()).done ? iterator(item.value, started++, done) : completed === started && iterator !== noop && (iterator = noop, 
          callback(null));
        } : function() {
          !1 === (item = iter.next()).done ? (started++, iterator(item.value, done)) : completed === started && iterator !== noop && (iterator = noop, 
          callback(null));
        }; else {
          if (typeof collection !== obj) return callback(null);
          keys = nativeKeys(collection), size = keys.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (key = keys[index], iterator(collection[key], key, done));
          } : function() {
            started < size && iterator(collection[keys[started++]], done);
          };
        } else ;
        if (!size || isNaN(limit) || limit < 1) return callback(null);
        function done(err, bool) {
          err || !1 === bool ? (iterate = noop, (callback = once(callback))(err)) : ++completed === size ? (iterator = noop, 
          iterate = throwError, (callback = onlyOnce(callback))(null)) : sync ? nextTick(iterate) : (sync = !0, 
          iterate()), sync = !1;
        }
        timesSync(limit > size ? size : limit, iterate);
      }
      function mapSeries(collection, iterator, callback) {
        var size, key, keys, iter, item, result, iterate;
        callback = callback || noop;
        var sync = !1, completed = 0;
        if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
          iterator(collection[completed], completed, done);
        } : function() {
          iterator(collection[completed], done);
        }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
        result = [], iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
          (item = iter.next()).done ? callback(null, result) : iterator(item.value, completed, done);
        } : function() {
          (item = iter.next()).done ? callback(null, result) : iterator(item.value, done);
        }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
        iterate = 3 === iterator.length ? function() {
          key = keys[completed], iterator(collection[key], key, done);
        } : function() {
          iterator(collection[keys[completed]], done);
        })), !size) return callback(null, []);
        function done(err, res) {
          if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err, createArray(result));
          result[completed] = res, ++completed === size ? (iterate = throwError, callback(null, result), 
          callback = throwError) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
        }
        result = result || Array(size), iterate();
      }
      function createDetect(arrayEach, baseEach, symbolEach, bool) {
        return function(collection, iterator, callback) {
          var size, keys;
          callback = callback || noop;
          var completed = 0;
          function createCallback(value) {
            var called = !1;
            return function(err, res) {
              called && throwError(), called = !0, err ? (callback = once(callback))(err) : !!res === bool ? (callback = once(callback))(null, value) : ++completed === size && callback(null);
            };
          }
          isArray(collection) ? (size = collection.length, arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, baseEach(collection, iterator, createCallback, keys))), size || callback(null);
        };
      }
      function createDetectSeries(bool) {
        return function(collection, iterator, callback) {
          var size, key, value, keys, iter, item, iterate;
          callback = onlyOnce(callback || noop);
          var sync = !1, completed = 0;
          if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            value = collection[completed], iterator(value, completed, done);
          } : function() {
            value = collection[completed], iterator(value, done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            item = iter.next(), value = item.value, item.done ? callback(null) : iterator(value, completed, done);
          } : function() {
            item = iter.next(), value = item.value, item.done ? callback(null) : iterator(value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            key = keys[completed], value = collection[key], iterator(value, key, done);
          } : function() {
            value = collection[keys[completed]], iterator(value, done);
          })), !size) return callback(null);
          function done(err, res) {
            err ? callback(err) : !!res === bool ? (iterate = throwError, callback(null, value)) : ++completed === size ? (iterate = throwError, 
            callback(null)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1;
          }
          iterate();
        };
      }
      function createDetectLimit(bool) {
        return function(collection, limit, iterator, callback) {
          var size, index, key, value, keys, iter, item, iterate;
          callback = callback || noop;
          var sync = !1, started = 0, completed = 0;
          if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value)));
          } : function() {
            (index = started++) < size && (value = collection[index], iterator(value, createCallback(value)));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? (value = item.value, iterator(value, started++, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null));
          } : function() {
            !1 === (item = iter.next()).done ? (started++, value = item.value, iterator(value, createCallback(value))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            started < size && (key = keys[started++], value = collection[key], iterator(value, key, createCallback(value)));
          } : function() {
            (index = started++) < size && (value = collection[keys[index]], iterator(value, createCallback(value)));
          })), !size || isNaN(limit) || limit < 1) return callback(null);
          function createCallback(value) {
            var called = !1;
            return function(err, res) {
              called && throwError(), called = !0, err ? (iterate = noop, (callback = once(callback))(err)) : !!res === bool ? (iterate = noop, 
              (callback = once(callback))(null, value)) : ++completed === size ? callback(null) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          timesSync(limit > size ? size : limit, iterate);
        };
      }
      function createPick(arrayEach, baseEach, symbolEach, bool) {
        return function(collection, iterator, callback) {
          var size, keys;
          callback = callback || noop;
          var completed = 0, result = {};
          if (isArray(collection) ? (size = collection.length, arrayEach(collection, iterator, createCallback)) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = symbolEach(collection, iterator, createCallback)) && size === completed && callback(null, result) : typeof collection === obj && (keys = nativeKeys(collection), 
          size = keys.length, baseEach(collection, iterator, createCallback, keys))), !size) return callback(null, {});
          function createCallback(key, value) {
            return function(err, res) {
              if (null === key && throwError(), err) return key = null, void (callback = once(callback))(err, objectClone(result));
              !!res === bool && (result[key] = value), key = null, ++completed === size && callback(null, result);
            };
          }
        };
      }
      function createPickSeries(bool) {
        return function(collection, iterator, callback) {
          var size, key, value, keys, iter, item, iterate;
          callback = onlyOnce(callback || noop);
          var sync = !1, result = {}, completed = 0;
          if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            key = completed, value = collection[completed], iterator(value, completed, done);
          } : function() {
            key = completed, value = collection[completed], iterator(value, done);
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            key = completed, item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, key, done);
          } : function() {
            key = completed, item = iter.next(), value = item.value, item.done ? callback(null, result) : iterator(value, done);
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            key = keys[completed], value = collection[key], iterator(value, key, done);
          } : function() {
            key = keys[completed], value = collection[key], iterator(value, done);
          })), !size) return callback(null, {});
          function done(err, res) {
            err ? callback(err, result) : (!!res === bool && (result[key] = value), ++completed === size ? (iterate = throwError, 
            callback(null, result)) : sync ? nextTick(iterate) : (sync = !0, iterate()), sync = !1);
          }
          iterate();
        };
      }
      function createPickLimit(bool) {
        return function(collection, limit, iterator, callback) {
          var size, index, key, value, keys, iter, item, iterate;
          callback = callback || noop;
          var sync = !1, result = {}, started = 0, completed = 0;
          if (isArray(collection) ? (size = collection.length, iterate = 3 === iterator.length ? function() {
            (index = started++) < size && (value = collection[index], iterator(value, index, createCallback(value, index)));
          } : function() {
            (index = started++) < size && (value = collection[index], iterator(value, createCallback(value, index)));
          }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
          iter = collection[iteratorSymbol](), iterate = 3 === iterator.length ? function() {
            !1 === (item = iter.next()).done ? (value = item.value, iterator(value, started, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          } : function() {
            !1 === (item = iter.next()).done ? (value = item.value, iterator(value, createCallback(value, started++))) : completed === started && iterator !== noop && (iterator = noop, 
            callback(null, result));
          }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
          iterate = 3 === iterator.length ? function() {
            started < size && (key = keys[started++], value = collection[key], iterator(value, key, createCallback(value, key)));
          } : function() {
            started < size && (key = keys[started++], value = collection[key], iterator(value, createCallback(value, key)));
          })), !size || isNaN(limit) || limit < 1) return callback(null, {});
          function createCallback(value, key) {
            return function(err, res) {
              if (null === key && throwError(), err) return key = null, iterate = noop, void (callback = once(callback))(err, objectClone(result));
              !!res === bool && (result[key] = value), key = null, ++completed === size ? (iterate = throwError, 
              (callback = onlyOnce(callback))(null, result)) : sync ? nextTick(iterate) : (sync = !0, 
              iterate()), sync = !1;
            };
          }
          timesSync(limit > size ? size : limit, iterate);
        };
      }
      function reduce(collection, result, iterator, callback) {
        var size, key, keys, iter, item, iterate;
        callback = onlyOnce(callback || noop);
        var sync = !1, completed = 0;
        if (isArray(collection) ? (size = collection.length, iterate = 4 === iterator.length ? function(result) {
          iterator(result, collection[completed], completed, done);
        } : function(result) {
          iterator(result, collection[completed], done);
        }) : collection && (iteratorSymbol && collection[iteratorSymbol] ? (size = 1 / 0, 
        iter = collection[iteratorSymbol](), iterate = 4 === iterator.length ? function(result) {
          (item = iter.next()).done ? callback(null, result) : iterator(result, item.value, completed, done);
        } : function(result) {
          (item = iter.next()).done ? callback(null, result) : iterator(result, item.value, done);
        }) : typeof collection === obj && (keys = nativeKeys(collection), size = keys.length, 
        iterate = 4 === iterator.length ? function(result) {
          key = keys[completed], iterator(result, collection[key], key, done);
        } : function(result) {
          iterator(result, collection[keys[completed]], done);
        })), !size) return callback(null, result);
        function done(err, result) {
          err ? callback(err, result) : ++completed === size ? (iterator = throwError, callback(null, result)) : sync ? nextTick((function() {
            iterate(result);
          })) : (sync = !0, iterate(result)), sync = !1;
        }
        iterate(result);
      }
      function reduceRight(collection, result, iterator, callback) {
        var resIndex, index, key, keys, iter, item, col, iterate;
        callback = onlyOnce(callback || noop);
        var sync = !1;
        if (isArray(collection)) resIndex = collection.length, iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator; else if (collection) if (iteratorSymbol && collection[iteratorSymbol]) {
          for (col = [], iter = collection[iteratorSymbol](), index = -1; !1 === (item = iter.next()).done; ) col[++index] = item.value;
          collection = col, resIndex = col.length, iterate = 4 === iterator.length ? arrayIteratorWithIndex : arrayIterator;
        } else typeof collection === obj && (keys = nativeKeys(collection), resIndex = keys.length, 
        iterate = 4 === iterator.length ? function(result) {
          key = keys[--resIndex], iterator(result, collection[key], key, done);
        } : function(result) {
          iterator(result, collection[keys[--resIndex]], done);
        }); else ;
        if (!resIndex) return callback(null, result);
        function arrayIterator(result) {
          iterator(result, collection[--resIndex], done);
        }
        function arrayIteratorWithIndex(result) {
          iterator(result, collection[--resIndex], resIndex, done);
        }
        function done(err, result) {
          err ? callback(err, result) : 0 === resIndex ? (iterate = throwError, callback(null, result)) : sync ? nextTick((function() {
            iterate(result);
          })) : (sync = !0, iterate(result)), sync = !1;
        }
        iterate(result);
      }
      function some(collection, iterator, callback) {
        callback = callback || noop, detect(collection, iterator, (function(err, res) {
          if (err) return callback(err);
          callback(null, !!res);
        }));
      }
      function someSeries(collection, iterator, callback) {
        callback = callback || noop, detectSeries(collection, iterator, (function(err, res) {
          if (err) return callback(err);
          callback(null, !!res);
        }));
      }
      function someLimit(collection, limit, iterator, callback) {
        callback = callback || noop, detectLimit(collection, limit, iterator, (function(err, res) {
          if (err) return callback(err);
          callback(null, !!res);
        }));
      }
      function checkWaterfallTasks(tasks, callback) {
        return isArray(tasks) ? 0 !== tasks.length || (callback(null), !1) : (callback(new Error("First argument to waterfall must be an array of functions")), 
        !1);
      }
      function waterfallIterator(func, args, next) {
        switch (args.length) {
         case 0:
         case 1:
          return func(next);

         case 2:
          return func(args[1], next);

         case 3:
          return func(args[1], args[2], next);

         case 4:
          return func(args[1], args[2], args[3], next);

         case 5:
          return func(args[1], args[2], args[3], args[4], next);

         case 6:
          return func(args[1], args[2], args[3], args[4], args[5], next);

         default:
          return (args = slice(args, 1)).push(next), func.apply(null, args);
        }
      }
      function angelFall(tasks, callback) {
        if (checkWaterfallTasks(tasks, callback = callback || noop)) {
          var completed = 0, sync = !1, size = tasks.length, func = tasks[completed], args = [], iterate = function() {
            switch (func.length) {
             case 0:
              try {
                next(null, func());
              } catch (e) {
                next(e);
              }
              return;

             case 1:
              return func(next);

             case 2:
              return func(args[1], next);

             case 3:
              return func(args[1], args[2], next);

             case 4:
              return func(args[1], args[2], args[3], next);

             case 5:
              return func(args[1], args[2], args[3], args[4], next);

             default:
              return (args = slice(args, 1))[func.length - 1] = next, func.apply(null, args);
            }
          };
          iterate();
        }
        function next(err, res) {
          if (err) return iterate = throwError, void (callback = onlyOnce(callback))(err);
          if (++completed === size) {
            iterate = throwError;
            var done = callback;
            return callback = throwError, void (2 === arguments.length ? done(err, res) : done.apply(null, createArray(arguments)));
          }
          func = tasks[completed], args = arguments, sync ? nextTick(iterate) : (sync = !0, 
          iterate()), sync = !1;
        }
      }
      function seq() {
        var fns = createArray(arguments);
        return function() {
          var self = this, args = createArray(arguments), callback = args[args.length - 1];
          function iterator(newargs, fn, callback) {
            newargs.push((function(err) {
              var nextargs = slice(arguments, 1);
              callback(err, nextargs);
            })), fn.apply(self, newargs);
          }
          function done(err, res) {
            (res = isArray(res) ? res : [ res ]).unshift(err), callback.apply(self, res);
          }
          typeof callback === func ? args.pop() : callback = noop, reduce(fns, args, iterator, done);
        };
      }
      function createApplyEach(func) {
        return function(fns) {
          var go = function() {
            var self = this, args = createArray(arguments), callback = args.pop() || noop;
            return func(fns, iterator, callback);
            function iterator(fn, done) {
              fn.apply(self, args.concat([ done ]));
            }
          };
          if (arguments.length > 1) {
            var args = slice(arguments, 1);
            return go.apply(this, args);
          }
          return go;
        };
      }
      function DLL() {
        this.head = null, this.tail = null, this.length = 0;
      }
      function baseQueue(isQueue, worker, concurrency, payload) {
        if (void 0 === concurrency) concurrency = 1; else if (isNaN(concurrency) || concurrency < 1) throw new Error("Concurrency must not be zero");
        var _callback, _unshift, workers = 0, workersList = [], q = {
          _tasks: new DLL,
          concurrency: concurrency,
          payload: payload,
          saturated: noop,
          unsaturated: noop,
          buffer: concurrency / 4,
          empty: noop,
          drain: noop,
          error: noop,
          started: !1,
          paused: !1,
          push: function(tasks, callback) {
            _insert(tasks, callback);
          },
          kill: function() {
            q.drain = noop, q._tasks.empty();
          },
          unshift: function(tasks, callback) {
            _insert(tasks, callback, !0);
          },
          remove: function(test) {
            q._tasks.remove(test);
          },
          process: isQueue ? function() {
            for (;!q.paused && workers < q.concurrency && q._tasks.length; ) {
              var task = q._tasks.shift();
              workers++, workersList.push(task), 0 === q._tasks.length && q.empty(), workers === q.concurrency && q.saturated();
              var done = _next(q, [ task ]);
              worker(task.data, done);
            }
          } : function() {
            for (;!q.paused && workers < q.concurrency && q._tasks.length; ) {
              for (var tasks = q._tasks.splice(q.payload || q._tasks.length), index = -1, size = tasks.length, data = Array(size); ++index < size; ) data[index] = tasks[index].data;
              workers++, nativePush.apply(workersList, tasks), 0 === q._tasks.length && q.empty(), 
              workers === q.concurrency && q.saturated();
              var done = _next(q, tasks);
              worker(data, done);
            }
          },
          length: function() {
            return q._tasks.length;
          },
          running: function() {
            return workers;
          },
          workersList: function() {
            return workersList;
          },
          idle: function() {
            return q.length() + workers === 0;
          },
          pause: function() {
            q.paused = !0;
          },
          resume: function() {
            if (!1 === q.paused) return;
            q.paused = !1, timesSync(q.concurrency < q._tasks.length ? q.concurrency : q._tasks.length, _resume);
          },
          _worker: worker
        };
        return q;
        function _exec(task) {
          var item = {
            data: task,
            callback: _callback
          };
          _unshift ? q._tasks.unshift(item) : q._tasks.push(item), nextTick(q.process);
        }
        function _insert(tasks, callback, unshift) {
          if (null == callback) callback = noop; else if ("function" != typeof callback) throw new Error("task callback must be a function");
          q.started = !0;
          var _tasks = isArray(tasks) ? tasks : [ tasks ];
          void 0 !== tasks && _tasks.length ? (_unshift = unshift, _callback = callback, arrayEachSync(_tasks, _exec), 
          _callback = void 0) : q.idle() && nextTick(q.drain);
        }
        function _next(q, tasks) {
          var called = !1;
          return function(err, res) {
            var task;
            called && throwError(), called = !0, workers--;
            for (var index = -1, size = workersList.length, taskIndex = -1, taskSize = tasks.length, useApply = arguments.length > 2, args = useApply && createArray(arguments); ++taskIndex < taskSize; ) {
              for (task = tasks[taskIndex]; ++index < size; ) workersList[index] === task && (0 === index ? workersList.shift() : workersList.splice(index, 1), 
              index = size, size--);
              index = -1, useApply ? task.callback.apply(task, args) : task.callback(err, res), 
              err && q.error(err, task.data);
            }
            workers <= q.concurrency - q.buffer && q.unsaturated(), q._tasks.length + workers === 0 && q.drain(), 
            q.process();
          };
        }
        function _resume() {
          nextTick(q.process);
        }
      }
      function auto(tasks, concurrency, callback) {
        typeof concurrency === func && (callback = concurrency, concurrency = null);
        var keys = nativeKeys(tasks), rest = keys.length, results = {};
        if (0 === rest) return callback(null, results);
        var runningTasks = 0, readyTasks = new DLL, listeners = Object.create(null);
        function proceedQueue() {
          if (0 === readyTasks.length && 0 === runningTasks) {
            if (0 !== rest) throw new Error("async.auto task has cyclic dependencies");
            return callback(null, results);
          }
          for (;readyTasks.length && runningTasks < concurrency && callback !== noop; ) {
            runningTasks++;
            var array = readyTasks.shift();
            0 === array[1] ? array[0](array[2]) : array[0](results, array[2]);
          }
        }
        function taskComplete(key) {
          arrayEachSync(listeners[key] || [], (function(task) {
            task();
          })), proceedQueue();
        }
        callback = onlyOnce(callback || noop), concurrency = concurrency || rest, baseEachSync(tasks, (function(task, key) {
          var _task, _taskSize;
          if (!isArray(task)) return _task = task, _taskSize = 0, void readyTasks.push([ _task, _taskSize, done ]);
          var dependencySize = task.length - 1;
          if (_task = task[dependencySize], _taskSize = dependencySize, 0 === dependencySize) return void readyTasks.push([ _task, _taskSize, done ]);
          var index = -1;
          for (;++index < dependencySize; ) {
            var dependencyName = task[index];
            if (notInclude(keys, dependencyName)) {
              var msg = "async.auto task `" + key + "` has non-existent dependency `" + dependencyName + "` in " + task.join(", ");
              throw new Error(msg);
            }
            var taskListeners = listeners[dependencyName];
            taskListeners || (taskListeners = listeners[dependencyName] = []), taskListeners.push(taskListener);
          }
          function done(err, arg) {
            if (null === key && throwError(), arg = arguments.length <= 2 ? arg : slice(arguments, 1), 
            err) {
              rest = 0, runningTasks = 0, readyTasks.length = 0;
              var safeResults = objectClone(results);
              safeResults[key] = arg, key = null;
              var _callback = callback;
              return callback = noop, void _callback(err, safeResults);
            }
            runningTasks--, rest--, results[key] = arg, taskComplete(key), key = null;
          }
          function taskListener() {
            0 == --dependencySize && readyTasks.push([ _task, _taskSize, done ]);
          }
        }), keys), proceedQueue();
      }
      exports.default = index, baseEachSync(index, (function(func, key) {
        exports[key] = func;
      }), nativeKeys(index)), DLL.prototype._removeLink = function(node) {
        var prev = node.prev, next = node.next;
        return prev ? prev.next = next : this.head = next, next ? next.prev = prev : this.tail = prev, 
        node.prev = null, node.next = null, this.length--, node;
      }, DLL.prototype.empty = DLL, DLL.prototype._setInitial = function(node) {
        this.length = 1, this.head = this.tail = node;
      }, DLL.prototype.insertBefore = function(node, newNode) {
        newNode.prev = node.prev, newNode.next = node, node.prev ? node.prev.next = newNode : this.head = newNode, 
        node.prev = newNode, this.length++;
      }, DLL.prototype.unshift = function(node) {
        this.head ? this.insertBefore(this.head, node) : this._setInitial(node);
      }, DLL.prototype.push = function(node) {
        var tail = this.tail;
        tail ? (node.prev = tail, node.next = tail.next, this.tail = node, tail.next = node, 
        this.length++) : this._setInitial(node);
      }, DLL.prototype.shift = function() {
        return this.head && this._removeLink(this.head);
      }, DLL.prototype.splice = function(end) {
        for (var task, tasks = []; end-- && (task = this.shift()); ) tasks.push(task);
        return tasks;
      }, DLL.prototype.remove = function(test) {
        for (var node = this.head; node; ) test(node) && this._removeLink(node), node = node.next;
        return this;
      };
      var FN_ARGS = /^(function)?\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /(=.+)?(\s*)$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
      function retry(opts, task, callback) {
        var times, intervalFunc, errorFilter, count = 0;
        if (arguments.length < 3 && typeof opts === func) callback = task || noop, task = opts, 
        opts = null, times = 5; else switch (callback = callback || noop, typeof opts) {
         case "object":
          typeof opts.errorFilter === func && (errorFilter = opts.errorFilter);
          var interval = opts.interval;
          switch (typeof interval) {
           case func:
            intervalFunc = interval;
            break;

           case "string":
           case "number":
            intervalFunc = (interval = +interval) ? function() {
              return interval;
            } : function() {
              return 0;
            };
          }
          times = +opts.times || 5;
          break;

         case "number":
          times = opts || 5;
          break;

         case "string":
          times = +opts || 5;
          break;

         default:
          throw new Error("Invalid arguments for async.retry");
        }
        if ("function" != typeof task) throw new Error("Invalid arguments for async.retry");
        function simpleIterator() {
          task(simpleCallback);
        }
        function simpleCallback(err, res) {
          if (++count === times || !err || errorFilter && !errorFilter(err)) {
            if (arguments.length <= 2) return callback(err, res);
            var args = createArray(arguments);
            return callback.apply(null, args);
          }
          simpleIterator();
        }
        function intervalIterator() {
          task(intervalCallback);
        }
        function intervalCallback(err, res) {
          if (++count === times || !err || errorFilter && !errorFilter(err)) {
            if (arguments.length <= 2) return callback(err, res);
            var args = createArray(arguments);
            return callback.apply(null, args);
          }
          setTimeout(intervalIterator, intervalFunc(count));
        }
        task(intervalFunc ? intervalCallback : simpleCallback);
      }
      function asyncify(fn) {
        return function() {
          var result, args = createArray(arguments), callback = args.pop();
          try {
            result = fn.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          result && typeof result.then === func ? result.then((function(value) {
            invokeCallback(callback, null, value);
          }), (function(err) {
            invokeCallback(callback, err && err.message ? err : new Error(err));
          })) : callback(null, result);
        };
      }
      function invokeCallback(callback, err, value) {
        try {
          callback(err, value);
        } catch (e) {
          nextTick(rethrow, e);
        }
      }
      function rethrow(error) {
        throw error;
      }
      function reflect(func) {
        return function() {
          var callback;
          switch (arguments.length) {
           case 1:
            return callback = arguments[0], func(done);

           case 2:
            return callback = arguments[1], func(arguments[0], done);

           default:
            var args = createArray(arguments), lastIndex = args.length - 1;
            callback = args[lastIndex], args[lastIndex] = done, func.apply(this, args);
          }
          function done(err, res) {
            if (err) return callback(null, {
              error: err
            });
            arguments.length > 2 && (res = slice(arguments, 1)), callback(null, {
              value: res
            });
          }
        };
      }
      function createLogger(name) {
        return function(fn) {
          var args = slice(arguments, 1);
          args.push(done), fn.apply(null, args);
        };
        function done(err) {
          if (typeof console === obj) {
            if (err) return void (console.error && console.error(err));
            if (console[name]) {
              var args = slice(arguments, 1);
              arrayEachSync(args, (function(arg) {
                console[name](arg);
              }));
            }
          }
        }
      }
    }(exports);
  }();
}, function(module, exports, __webpack_require__) {
  "use strict";
  class Hook {
    constructor(args) {
      Array.isArray(args) || (args = []), this._args = args, this.taps = [], this.interceptors = [], 
      this.call = this._call, this.promise = this._promise, this.callAsync = this._callAsync, 
      this._x = void 0;
    }
    compile(options) {
      throw new Error("Abstract: should be overriden");
    }
    _createCall(type) {
      return this.compile({
        taps: this.taps,
        interceptors: this.interceptors,
        args: this._args,
        type: type
      });
    }
    tap(options, fn) {
      if ("string" == typeof options && (options = {
        name: options
      }), "object" != typeof options || null === options) throw new Error("Invalid arguments to tap(options: Object, fn: function)");
      if ("string" != typeof (options = Object.assign({
        type: "sync",
        fn: fn
      }, options)).name || "" === options.name) throw new Error("Missing name for tap");
      options = this._runRegisterInterceptors(options), this._insert(options);
    }
    tapAsync(options, fn) {
      if ("string" == typeof options && (options = {
        name: options
      }), "object" != typeof options || null === options) throw new Error("Invalid arguments to tapAsync(options: Object, fn: function)");
      if ("string" != typeof (options = Object.assign({
        type: "async",
        fn: fn
      }, options)).name || "" === options.name) throw new Error("Missing name for tapAsync");
      options = this._runRegisterInterceptors(options), this._insert(options);
    }
    tapPromise(options, fn) {
      if ("string" == typeof options && (options = {
        name: options
      }), "object" != typeof options || null === options) throw new Error("Invalid arguments to tapPromise(options: Object, fn: function)");
      if ("string" != typeof (options = Object.assign({
        type: "promise",
        fn: fn
      }, options)).name || "" === options.name) throw new Error("Missing name for tapPromise");
      options = this._runRegisterInterceptors(options), this._insert(options);
    }
    _runRegisterInterceptors(options) {
      for (const interceptor of this.interceptors) if (interceptor.register) {
        const newOptions = interceptor.register(options);
        void 0 !== newOptions && (options = newOptions);
      }
      return options;
    }
    withOptions(options) {
      const mergeOptions = opt => Object.assign({}, options, "string" == typeof opt ? {
        name: opt
      } : opt);
      options = Object.assign({}, options, this._withOptions);
      const base = this._withOptionsBase || this, newHook = Object.create(base);
      return newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn), newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn), 
      newHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn), newHook._withOptions = options, 
      newHook._withOptionsBase = base, newHook;
    }
    isUsed() {
      return this.taps.length > 0 || this.interceptors.length > 0;
    }
    intercept(interceptor) {
      if (this._resetCompilation(), this.interceptors.push(Object.assign({}, interceptor)), 
      interceptor.register) for (let i = 0; i < this.taps.length; i++) this.taps[i] = interceptor.register(this.taps[i]);
    }
    _resetCompilation() {
      this.call = this._call, this.callAsync = this._callAsync, this.promise = this._promise;
    }
    _insert(item) {
      let before;
      this._resetCompilation(), "string" == typeof item.before ? before = new Set([ item.before ]) : Array.isArray(item.before) && (before = new Set(item.before));
      let stage = 0;
      "number" == typeof item.stage && (stage = item.stage);
      let i = this.taps.length;
      for (;i > 0; ) {
        i--;
        const x = this.taps[i];
        this.taps[i + 1] = x;
        const xStage = x.stage || 0;
        if (before) {
          if (before.has(x.name)) {
            before.delete(x.name);
            continue;
          }
          if (before.size > 0) continue;
        }
        if (!(xStage > stage)) {
          i++;
          break;
        }
      }
      this.taps[i] = item;
    }
  }
  function createCompileDelegate(name, type) {
    return function(...args) {
      return this[name] = this._createCall(type), this[name](...args);
    };
  }
  Object.defineProperties(Hook.prototype, {
    _call: {
      value: createCompileDelegate("call", "sync"),
      configurable: !0,
      writable: !0
    },
    _promise: {
      value: createCompileDelegate("promise", "promise"),
      configurable: !0,
      writable: !0
    },
    _callAsync: {
      value: createCompileDelegate("callAsync", "async"),
      configurable: !0,
      writable: !0
    }
  }), module.exports = Hook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), _makePathsRelative = (context, identifier) => identifier.split(/([|! ])/).map(str => {
    return !/^\/.*\/$/.test(maybeAbsolutePath = str) && /^(?:[a-z]:\\|\/)/i.test(maybeAbsolutePath) ? path.relative(context, str).replace(/\\/g, "/") : str;
    var maybeAbsolutePath;
  }).join("");
  exports.makePathsRelative = (context, identifier, cache) => {
    if (!cache) return _makePathsRelative(context, identifier);
    const relativePaths = cache.relativePaths || (cache.relativePaths = new Map);
    let cachedResult, contextCache = relativePaths.get(context);
    if (void 0 === contextCache ? relativePaths.set(context, contextCache = new Map) : cachedResult = contextCache.get(identifier), 
    void 0 !== cachedResult) return cachedResult;
    {
      const relativePath = _makePathsRelative(context, identifier);
      return contextCache.set(identifier, relativePath), relativePath;
    }
  }, exports.contextify = (context, request) => request.split("!").map(r => {
    const splitPath = r.split("?", 2);
    return /^[a-zA-Z]:\\/.test(splitPath[0]) && (splitPath[0] = path.win32.relative(context, splitPath[0]), 
    /^[a-zA-Z]:\\/.test(splitPath[0]) || (splitPath[0] = splitPath[0].replace(/\\/g, "/"))), 
    /^\//.test(splitPath[0]) && (splitPath[0] = path.posix.relative(context, splitPath[0])), 
    /^(\.\.\/|\/|[a-zA-Z]:\\)/.test(splitPath[0]) || (splitPath[0] = "./" + splitPath[0]), 
    splitPath.join("?");
  }).join("!");
  exports.absolutify = (context, request) => request.split("!").map(r => ((context, relativePath) => relativePath.startsWith("./") || relativePath.startsWith("../") ? path.join(context, relativePath) : relativePath)(context, r)).join("!");
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(module, importedNames, weak = !1, order = NaN) {
      this.module = module, this.importedNames = importedNames, this.weak = !!weak, this.order = order;
    }
    static sort(array) {
      const originalOrder = new WeakMap;
      let i = 0;
      for (const ref of array) originalOrder.set(ref, i++);
      return array.sort((a, b) => {
        const aOrder = a.order, bOrder = b.order;
        if (isNaN(aOrder)) {
          if (!isNaN(bOrder)) return 1;
        } else {
          if (isNaN(bOrder)) return -1;
          if (aOrder !== bOrder) return aOrder - bOrder;
        }
        return originalOrder.get(a) - originalOrder.get(b);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(config) {
      this.config = config, this.options = void 0, this._args = void 0;
    }
    create(options) {
      let fn;
      switch (this.init(options), this.options.type) {
       case "sync":
        fn = new Function(this.args(), '"use strict";\n' + this.header() + this.content({
          onError: err => `throw ${err};\n`,
          onResult: result => `return ${result};\n`,
          resultReturns: !0,
          onDone: () => "",
          rethrowIfPossible: !0
        }));
        break;

       case "async":
        fn = new Function(this.args({
          after: "_callback"
        }), '"use strict";\n' + this.header() + this.content({
          onError: err => `_callback(${err});\n`,
          onResult: result => `_callback(null, ${result});\n`,
          onDone: () => "_callback();\n"
        }));
        break;

       case "promise":
        let errorHelperUsed = !1;
        const content = this.content({
          onError: err => (errorHelperUsed = !0, `_error(${err});\n`),
          onResult: result => `_resolve(${result});\n`,
          onDone: () => "_resolve();\n"
        });
        let code = "";
        code += '"use strict";\n', code += "return new Promise((_resolve, _reject) => {\n", 
        errorHelperUsed && (code += "var _sync = true;\n", code += "function _error(_err) {\n", 
        code += "if(_sync)\n", code += "_resolve(Promise.resolve().then(() => { throw _err; }));\n", 
        code += "else\n", code += "_reject(_err);\n", code += "};\n"), code += this.header(), 
        code += content, errorHelperUsed && (code += "_sync = false;\n"), code += "});\n", 
        fn = new Function(this.args(), code);
      }
      return this.deinit(), fn;
    }
    setup(instance, options) {
      instance._x = options.taps.map(t => t.fn);
    }
    init(options) {
      this.options = options, this._args = options.args.slice();
    }
    deinit() {
      this.options = void 0, this._args = void 0;
    }
    header() {
      let code = "";
      this.needContext() ? code += "var _context = {};\n" : code += "var _context;\n", 
      code += "var _x = this._x;\n", this.options.interceptors.length > 0 && (code += "var _taps = this.taps;\n", 
      code += "var _interceptors = this.interceptors;\n");
      for (let i = 0; i < this.options.interceptors.length; i++) {
        const interceptor = this.options.interceptors[i];
        interceptor.call && (code += `${this.getInterceptor(i)}.call(${this.args({
          before: interceptor.context ? "_context" : void 0
        })});\n`);
      }
      return code;
    }
    needContext() {
      for (const tap of this.options.taps) if (tap.context) return !0;
      return !1;
    }
    callTap(tapIndex, {onError: onError, onResult: onResult, onDone: onDone, rethrowIfPossible: rethrowIfPossible}) {
      let code = "", hasTapCached = !1;
      for (let i = 0; i < this.options.interceptors.length; i++) {
        const interceptor = this.options.interceptors[i];
        interceptor.tap && (hasTapCached || (code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`, 
        hasTapCached = !0), code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});\n`);
      }
      code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
      const tap = this.options.taps[tapIndex];
      switch (tap.type) {
       case "sync":
        rethrowIfPossible || (code += `var _hasError${tapIndex} = false;\n`, code += "try {\n"), 
        code += onResult ? `var _result${tapIndex} = _fn${tapIndex}(${this.args({
          before: tap.context ? "_context" : void 0
        })});\n` : `_fn${tapIndex}(${this.args({
          before: tap.context ? "_context" : void 0
        })});\n`, rethrowIfPossible || (code += "} catch(_err) {\n", code += `_hasError${tapIndex} = true;\n`, 
        code += onError("_err"), code += "}\n", code += `if(!_hasError${tapIndex}) {\n`), 
        onResult && (code += onResult("_result" + tapIndex)), onDone && (code += onDone()), 
        rethrowIfPossible || (code += "}\n");
        break;

       case "async":
        let cbCode = "";
        cbCode += onResult ? `(_err${tapIndex}, _result${tapIndex}) => {\n` : `_err${tapIndex} => {\n`, 
        cbCode += `if(_err${tapIndex}) {\n`, cbCode += onError("_err" + tapIndex), cbCode += "} else {\n", 
        onResult && (cbCode += onResult("_result" + tapIndex)), onDone && (cbCode += onDone()), 
        cbCode += "}\n", cbCode += "}", code += `_fn${tapIndex}(${this.args({
          before: tap.context ? "_context" : void 0,
          after: cbCode
        })});\n`;
        break;

       case "promise":
        code += `var _hasResult${tapIndex} = false;\n`, code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
          before: tap.context ? "_context" : void 0
        })});\n`, code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`, code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`, 
        code += `_promise${tapIndex}.then(_result${tapIndex} => {\n`, code += `_hasResult${tapIndex} = true;\n`, 
        onResult && (code += onResult("_result" + tapIndex)), onDone && (code += onDone()), 
        code += `}, _err${tapIndex} => {\n`, code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`, 
        code += onError("_err" + tapIndex), code += "});\n";
      }
      return code;
    }
    callTapsSeries({onError: onError, onResult: onResult, resultReturns: resultReturns, onDone: onDone, doneReturns: doneReturns, rethrowIfPossible: rethrowIfPossible}) {
      if (0 === this.options.taps.length) return onDone();
      const firstAsync = this.options.taps.findIndex(t => "sync" !== t.type), somethingReturns = resultReturns || doneReturns || !1;
      let code = "", current = onDone;
      for (let j = this.options.taps.length - 1; j >= 0; j--) {
        const i = j;
        current !== onDone && "sync" !== this.options.taps[i].type && (code += `function _next${i}() {\n`, 
        code += current(), code += "}\n", current = () => `${somethingReturns ? "return " : ""}_next${i}();\n`);
        const done = current, doneBreak = skipDone => skipDone ? "" : onDone(), content = this.callTap(i, {
          onError: error => onError(i, error, done, doneBreak),
          onResult: onResult && (result => onResult(i, result, done, doneBreak)),
          onDone: !onResult && done,
          rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
        });
        current = () => content;
      }
      return code += current(), code;
    }
    callTapsLooping({onError: onError, onDone: onDone, rethrowIfPossible: rethrowIfPossible}) {
      if (0 === this.options.taps.length) return onDone();
      const syncOnly = this.options.taps.every(t => "sync" === t.type);
      let code = "";
      syncOnly || (code += "var _looper = () => {\n", code += "var _loopAsync = false;\n"), 
      code += "var _loop;\n", code += "do {\n", code += "_loop = false;\n";
      for (let i = 0; i < this.options.interceptors.length; i++) {
        const interceptor = this.options.interceptors[i];
        interceptor.loop && (code += `${this.getInterceptor(i)}.loop(${this.args({
          before: interceptor.context ? "_context" : void 0
        })});\n`);
      }
      return code += this.callTapsSeries({
        onError: onError,
        onResult: (i, result, next, doneBreak) => {
          let code = "";
          return code += `if(${result} !== undefined) {\n`, code += "_loop = true;\n", syncOnly || (code += "if(_loopAsync) _looper();\n"), 
          code += doneBreak(!0), code += "} else {\n", code += next(), code += "}\n", code;
        },
        onDone: onDone && (() => {
          let code = "";
          return code += "if(!_loop) {\n", code += onDone(), code += "}\n", code;
        }),
        rethrowIfPossible: rethrowIfPossible && syncOnly
      }), code += "} while(_loop);\n", syncOnly || (code += "_loopAsync = true;\n", code += "};\n", 
      code += "_looper();\n"), code;
    }
    callTapsParallel({onError: onError, onResult: onResult, onDone: onDone, rethrowIfPossible: rethrowIfPossible, onTap: onTap = ((i, run) => run())}) {
      if (this.options.taps.length <= 1) return this.callTapsSeries({
        onError: onError,
        onResult: onResult,
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
      let code = "";
      code += "do {\n", code += `var _counter = ${this.options.taps.length};\n`, onDone && (code += "var _done = () => {\n", 
      code += onDone(), code += "};\n");
      for (let i = 0; i < this.options.taps.length; i++) {
        const done = () => onDone ? "if(--_counter === 0) _done();\n" : "--_counter;", doneBreak = skipDone => skipDone || !onDone ? "_counter = 0;\n" : "_counter = 0;\n_done();\n";
        code += "if(_counter <= 0) break;\n", code += onTap(i, () => this.callTap(i, {
          onError: error => {
            let code = "";
            return code += "if(_counter > 0) {\n", code += onError(i, error, done, doneBreak), 
            code += "}\n", code;
          },
          onResult: onResult && (result => {
            let code = "";
            return code += "if(_counter > 0) {\n", code += onResult(i, result, done, doneBreak), 
            code += "}\n", code;
          }),
          onDone: !onResult && (() => done()),
          rethrowIfPossible: rethrowIfPossible
        }), done, doneBreak);
      }
      return code += "} while(false);\n", code;
    }
    args({before: before, after: after} = {}) {
      let allArgs = this._args;
      return before && (allArgs = [ before ].concat(allArgs)), after && (allArgs = allArgs.concat(after)), 
      0 === allArgs.length ? "" : allArgs.join(", ");
    }
    getTapFn(idx) {
      return `_x[${idx}]`;
    }
    getTap(idx) {
      return `_taps[${idx}]`;
    }
    getInterceptor(idx) {
      return `_interceptors[${idx}]`;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AbstractMethodError = __webpack_require__(204);
  class Hash {
    update(data, inputEncoding) {
      throw new AbstractMethodError;
    }
    digest(encoding) {
      throw new AbstractMethodError;
    }
  }
  exports.Hash = Hash;
  class BulkUpdateDecorator extends Hash {
    constructor(hash) {
      super(), this.hash = hash, this.buffer = "";
    }
    update(data, inputEncoding) {
      return void 0 !== inputEncoding || "string" != typeof data || data.length > 1e3 ? (this.buffer.length > 0 && (this.hash.update(this.buffer), 
      this.buffer = ""), this.hash.update(data, inputEncoding)) : (this.buffer += data, 
      this.buffer.length > 1e3 && (this.hash.update(this.buffer), this.buffer = "")), 
      this;
    }
    digest(encoding) {
      this.buffer.length > 0 && this.hash.update(this.buffer);
      var digestResult = this.hash.digest(encoding);
      return "string" == typeof digestResult ? digestResult : digestResult.toString();
    }
  }
  class DebugHash extends Hash {
    constructor() {
      super(), this.string = "";
    }
    update(data, inputEncoding) {
      return "string" != typeof data && (data = data.toString("utf-8")), this.string += data, 
      this;
    }
    digest(encoding) {
      return this.string.replace(/[^a-z0-9]+/gi, m => Buffer.from(m).toString("hex"));
    }
  }
  module.exports = algorithm => {
    if ("function" == typeof algorithm) return new BulkUpdateDecorator(new algorithm);
    switch (algorithm) {
     case "debug":
      return new DebugHash;

     default:
      return new BulkUpdateDecorator(__webpack_require__(99).createHash(algorithm));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), DependenciesBlock = __webpack_require__(101), ModuleReason = __webpack_require__(214), SortableSet = __webpack_require__(23), Template = __webpack_require__(2), EMPTY_RESOLVE_OPTIONS = {};
  let debugId = 1e3;
  const sortById = (a, b) => a.id - b.id, sortByDebugId = (a, b) => a.debugId - b.debugId;
  class Module extends DependenciesBlock {
    constructor(type, context = null) {
      super(), this.type = type, this.context = context, this.debugId = debugId++, this.hash = void 0, 
      this.renderedHash = void 0, this.resolveOptions = EMPTY_RESOLVE_OPTIONS, this.factoryMeta = {}, 
      this.warnings = [], this.errors = [], this.buildMeta = void 0, this.buildInfo = void 0, 
      this.reasons = [], this._chunks = new SortableSet(void 0, sortById), this.id = null, 
      this.index = null, this.index2 = null, this.depth = null, this.issuer = null, this.profile = void 0, 
      this.prefetched = !1, this.built = !1, this.used = null, this.usedExports = null, 
      this.optimizationBailout = [], this._rewriteChunkInReasons = void 0, this.useSourceMap = !1, 
      this._source = null;
    }
    get exportsArgument() {
      return this.buildInfo && this.buildInfo.exportsArgument || "exports";
    }
    get moduleArgument() {
      return this.buildInfo && this.buildInfo.moduleArgument || "module";
    }
    disconnect() {
      this.hash = void 0, this.renderedHash = void 0, this.reasons.length = 0, this._rewriteChunkInReasons = void 0, 
      this._chunks.clear(), this.id = null, this.index = null, this.index2 = null, this.depth = null, 
      this.issuer = null, this.profile = void 0, this.prefetched = !1, this.built = !1, 
      this.used = null, this.usedExports = null, this.optimizationBailout.length = 0, 
      super.disconnect();
    }
    unseal() {
      this.id = null, this.index = null, this.index2 = null, this.depth = null, this._chunks.clear(), 
      super.unseal();
    }
    setChunks(chunks) {
      this._chunks = new SortableSet(chunks, sortById);
    }
    addChunk(chunk) {
      return !this._chunks.has(chunk) && (this._chunks.add(chunk), !0);
    }
    removeChunk(chunk) {
      return !!this._chunks.delete(chunk) && (chunk.removeModule(this), !0);
    }
    isInChunk(chunk) {
      return this._chunks.has(chunk);
    }
    isEntryModule() {
      for (const chunk of this._chunks) if (chunk.entryModule === this) return !0;
      return !1;
    }
    get optional() {
      return this.reasons.length > 0 && this.reasons.every(r => r.dependency && r.dependency.optional);
    }
    getChunks() {
      return Array.from(this._chunks);
    }
    getNumberOfChunks() {
      return this._chunks.size;
    }
    get chunksIterable() {
      return this._chunks;
    }
    hasEqualsChunks(otherModule) {
      if (this._chunks.size !== otherModule._chunks.size) return !1;
      this._chunks.sortWith(sortByDebugId), otherModule._chunks.sortWith(sortByDebugId);
      const a = this._chunks[Symbol.iterator](), b = otherModule._chunks[Symbol.iterator]();
      for (;;) {
        const aItem = a.next(), bItem = b.next();
        if (aItem.done) return !0;
        if (aItem.value !== bItem.value) return !1;
      }
    }
    addReason(module, dependency, explanation) {
      this.reasons.push(new ModuleReason(module, dependency, explanation));
    }
    removeReason(module, dependency) {
      for (let i = 0; i < this.reasons.length; i++) {
        let r = this.reasons[i];
        if (r.module === module && r.dependency === dependency) return this.reasons.splice(i, 1), 
        !0;
      }
      return !1;
    }
    hasReasonForChunk(chunk) {
      if (this._rewriteChunkInReasons) {
        for (const operation of this._rewriteChunkInReasons) this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);
        this._rewriteChunkInReasons = void 0;
      }
      for (let i = 0; i < this.reasons.length; i++) if (this.reasons[i].hasChunk(chunk)) return !0;
      return !1;
    }
    hasReasons() {
      return this.reasons.length > 0;
    }
    rewriteChunkInReasons(oldChunk, newChunks) {
      void 0 === this._rewriteChunkInReasons && (this._rewriteChunkInReasons = []), this._rewriteChunkInReasons.push({
        oldChunk: oldChunk,
        newChunks: newChunks
      });
    }
    _doRewriteChunkInReasons(oldChunk, newChunks) {
      for (let i = 0; i < this.reasons.length; i++) this.reasons[i].rewriteChunks(oldChunk, newChunks);
    }
    isUsed(exportName) {
      if (!exportName) return !1 !== this.used;
      if (null === this.used || null === this.usedExports) return exportName;
      if (!this.used) return !1;
      if (!this.usedExports) return !1;
      if (!0 === this.usedExports) return exportName;
      let idx = this.usedExports.indexOf(exportName);
      if (idx < 0) return !1;
      if (this.isProvided(exportName)) {
        if ("namespace" === this.buildMeta.exportsType) return Template.numberToIdentifer(idx);
        if ("named" === this.buildMeta.exportsType && !this.usedExports.includes("default")) return Template.numberToIdentifer(idx);
      }
      return exportName;
    }
    isProvided(exportName) {
      return Array.isArray(this.buildMeta.providedExports) ? this.buildMeta.providedExports.includes(exportName) : null;
    }
    toString() {
      return `Module[${this.id || this.debugId}]`;
    }
    needRebuild(fileTimestamps, contextTimestamps) {
      return !0;
    }
    updateHash(hash) {
      hash.update("" + this.id), hash.update(JSON.stringify(this.usedExports)), super.updateHash(hash);
    }
    sortItems(sortChunks) {
      super.sortItems(), sortChunks && this._chunks.sort(), this.reasons.sort((a, b) => a.module === b.module ? 0 : a.module ? b.module ? sortById(a.module, b.module) : 1 : -1), 
      Array.isArray(this.usedExports) && this.usedExports.sort();
    }
    unbuild() {
      this.dependencies.length = 0, this.blocks.length = 0, this.variables.length = 0, 
      this.buildMeta = void 0, this.buildInfo = void 0, this.disconnect();
    }
    get arguments() {
      throw new Error("Module.arguments was removed, there is no replacement.");
    }
    set arguments(value) {
      throw new Error("Module.arguments was removed, there is no replacement.");
    }
  }
  Object.defineProperty(Module.prototype, "forEachChunk", {
    configurable: !1,
    value: util.deprecate((function(fn) {
      this._chunks.forEach(fn);
    }), "Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead")
  }), Object.defineProperty(Module.prototype, "mapChunks", {
    configurable: !1,
    value: util.deprecate((function(fn) {
      return Array.from(this._chunks, fn);
    }), "Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead")
  }), Object.defineProperty(Module.prototype, "entry", {
    configurable: !1,
    get() {
      throw new Error("Module.entry was removed. Use Chunk.entryModule");
    },
    set() {
      throw new Error("Module.entry was removed. Use Chunk.entryModule");
    }
  }), Object.defineProperty(Module.prototype, "meta", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.buildMeta;
    }), "Module.meta was renamed to Module.buildMeta"),
    set: util.deprecate((function(value) {
      this.buildMeta = value;
    }), "Module.meta was renamed to Module.buildMeta")
  }), Module.prototype.identifier = null, Module.prototype.readableIdentifier = null, 
  Module.prototype.build = null, Module.prototype.source = null, Module.prototype.size = null, 
  Module.prototype.nameForCondition = null, Module.prototype.chunkCondition = null, 
  Module.prototype.updateCacheModule = null, module.exports = Module;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), compareLocations = __webpack_require__(36), DependencyReference = __webpack_require__(15);
  class Dependency {
    constructor() {
      this.module = null, this.weak = !1, this.optional = !1, this.loc = void 0;
    }
    getResourceIdentifier() {
      return null;
    }
    getReference() {
      return this.module ? new DependencyReference(this.module, !0, this.weak) : null;
    }
    getExports() {
      return null;
    }
    getWarnings() {
      return null;
    }
    getErrors() {
      return null;
    }
    updateHash(hash) {
      hash.update((this.module && this.module.id) + "");
    }
    disconnect() {
      this.module = null;
    }
  }
  Dependency.compare = util.deprecate((a, b) => compareLocations(a.loc, b.loc), "Dependency.compare is deprecated and will be removed in the next major version"), 
  module.exports = Dependency;
}, function(module, exports) {
  module.exports = require("fs");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const createHash = __webpack_require__(17), ModuleFilenameHelpers = exports;
  ModuleFilenameHelpers.ALL_LOADERS_RESOURCE = "[all-loaders][resource]", ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\[all-?loaders\]\[resource\]/gi, 
  ModuleFilenameHelpers.LOADERS_RESOURCE = "[loaders][resource]", ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\[loaders\]\[resource\]/gi, 
  ModuleFilenameHelpers.RESOURCE = "[resource]", ModuleFilenameHelpers.REGEXP_RESOURCE = /\[resource\]/gi, 
  ModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = "[absolute-resource-path]", ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\[abs(olute)?-?resource-?path\]/gi, 
  ModuleFilenameHelpers.RESOURCE_PATH = "[resource-path]", ModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\[resource-?path\]/gi, 
  ModuleFilenameHelpers.ALL_LOADERS = "[all-loaders]", ModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\[all-?loaders\]/gi, 
  ModuleFilenameHelpers.LOADERS = "[loaders]", ModuleFilenameHelpers.REGEXP_LOADERS = /\[loaders\]/gi, 
  ModuleFilenameHelpers.QUERY = "[query]", ModuleFilenameHelpers.REGEXP_QUERY = /\[query\]/gi, 
  ModuleFilenameHelpers.ID = "[id]", ModuleFilenameHelpers.REGEXP_ID = /\[id\]/gi, 
  ModuleFilenameHelpers.HASH = "[hash]", ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi, 
  ModuleFilenameHelpers.NAMESPACE = "[namespace]", ModuleFilenameHelpers.REGEXP_NAMESPACE = /\[namespace\]/gi;
  const getBefore = (str, token) => {
    const idx = str.lastIndexOf(token);
    return idx < 0 ? "" : str.substr(0, idx);
  }, getHash = str => {
    const hash = createHash("md4");
    hash.update(str);
    return hash.digest("hex").substr(0, 4);
  }, asRegExp = test => ("string" == typeof test && (test = new RegExp("^" + test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"))), 
  test);
  ModuleFilenameHelpers.createFilename = (module, options, requestShortener) => {
    const opts = Object.assign({
      namespace: "",
      moduleFilenameTemplate: ""
    }, "object" == typeof options ? options : {
      moduleFilenameTemplate: options
    });
    let absoluteResourcePath, hash, identifier, moduleId, shortIdentifier;
    void 0 === module && (module = ""), "string" == typeof module ? (shortIdentifier = requestShortener.shorten(module), 
    identifier = shortIdentifier, moduleId = "", absoluteResourcePath = module.split("!").pop(), 
    hash = getHash(identifier)) : (shortIdentifier = module.readableIdentifier(requestShortener), 
    identifier = requestShortener.shorten(module.identifier()), moduleId = module.id, 
    absoluteResourcePath = module.identifier().split("!").pop(), hash = getHash(identifier));
    const resource = shortIdentifier.split("!").pop(), loaders = getBefore(shortIdentifier, "!"), allLoaders = getBefore(identifier, "!"), query = ((str, token) => {
      const idx = str.indexOf(token);
      return idx < 0 ? "" : str.substr(idx);
    })(resource, "?"), resourcePath = resource.substr(0, resource.length - query.length);
    return "function" == typeof opts.moduleFilenameTemplate ? opts.moduleFilenameTemplate({
      identifier: identifier,
      shortIdentifier: shortIdentifier,
      resource: resource,
      resourcePath: resourcePath,
      absoluteResourcePath: absoluteResourcePath,
      allLoaders: allLoaders,
      query: query,
      moduleId: moduleId,
      hash: hash,
      namespace: opts.namespace
    }) : opts.moduleFilenameTemplate.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier).replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier).replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource).replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath).replace(ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH, absoluteResourcePath).replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders).replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders).replace(ModuleFilenameHelpers.REGEXP_QUERY, query).replace(ModuleFilenameHelpers.REGEXP_ID, moduleId).replace(ModuleFilenameHelpers.REGEXP_HASH, hash).replace(ModuleFilenameHelpers.REGEXP_NAMESPACE, opts.namespace);
  }, ModuleFilenameHelpers.replaceDuplicates = (array, fn, comparator) => {
    const countMap = Object.create(null), posMap = Object.create(null);
    return array.forEach((item, idx) => {
      countMap[item] = countMap[item] || [], countMap[item].push(idx), posMap[item] = 0;
    }), comparator && Object.keys(countMap).forEach(item => {
      countMap[item].sort(comparator);
    }), array.map((item, i) => countMap[item].length > 1 ? comparator && countMap[item][0] === i ? item : fn(item, i, posMap[item]++) : item);
  }, ModuleFilenameHelpers.matchPart = (str, test) => !test || (test = asRegExp(test), 
  Array.isArray(test) ? test.map(asRegExp).some(regExp => regExp.test(str)) : test.test(str)), 
  ModuleFilenameHelpers.matchObject = (obj, str) => !(obj.test && !ModuleFilenameHelpers.matchPart(str, obj.test)) && (!(obj.include && !ModuleFilenameHelpers.matchPart(str, obj.include)) && (!obj.exclude || !ModuleFilenameHelpers.matchPart(str, obj.exclude)));
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), ModuleDependency = __webpack_require__(4), Template = __webpack_require__(2);
  class HarmonyImportDependency extends ModuleDependency {
    constructor(request, originModule, sourceOrder, parserScope) {
      super(request), this.redirectedModule = void 0, this.originModule = originModule, 
      this.sourceOrder = sourceOrder, this.parserScope = parserScope;
    }
    get _module() {
      return this.redirectedModule || this.module;
    }
    getReference() {
      return this._module ? new DependencyReference(this._module, !1, this.weak, this.sourceOrder) : null;
    }
    getImportVar() {
      let importVarMap = this.parserScope.importVarMap;
      importVarMap || (this.parserScope.importVarMap = importVarMap = new Map);
      let importVar = importVarMap.get(this._module);
      return importVar || (importVar = `${Template.toIdentifier("" + this.userRequest)}__WEBPACK_IMPORTED_MODULE_${importVarMap.size}__`, 
      importVarMap.set(this._module, importVar), importVar);
    }
    getImportStatement(update, runtime) {
      return runtime.importStatement({
        update: update,
        module: this._module,
        importVar: this.getImportVar(),
        request: this.request,
        originModule: this.originModule
      });
    }
    updateHash(hash) {
      super.updateHash(hash);
      const importedModule = this._module;
      hash.update((importedModule && (!importedModule.buildMeta || importedModule.buildMeta.exportsType)) + ""), 
      hash.update((importedModule && importedModule.id) + "");
    }
    disconnect() {
      super.disconnect(), this.redirectedModule = void 0;
    }
  }
  module.exports = HarmonyImportDependency;
  const importEmittedMap = new WeakMap;
  HarmonyImportDependency.Template = class {
    apply(dep, source, runtime) {}
    getHarmonyInitOrder(dep) {
      return dep.sourceOrder;
    }
    static isImportEmitted(dep, source) {
      let sourceInfo = importEmittedMap.get(source);
      if (!sourceInfo) return !1;
      const key = dep._module || dep.request;
      return key && sourceInfo.emittedImports.get(key);
    }
    harmonyInit(dep, source, runtime, dependencyTemplates) {
      let sourceInfo = importEmittedMap.get(source);
      sourceInfo || importEmittedMap.set(source, sourceInfo = {
        emittedImports: new Map
      });
      const key = dep._module || dep.request;
      if (key && sourceInfo.emittedImports.get(key)) return;
      sourceInfo.emittedImports.set(key, !0);
      const content = dep.getImportStatement(!1, runtime);
      source.insert(-1, content);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  class SortableSet extends Set {
    constructor(initialIterable, defaultSort) {
      super(initialIterable), this._sortFn = defaultSort, this._lastActiveSortFn = null, 
      this._cache = void 0, this._cacheOrderIndependent = void 0;
    }
    add(value) {
      return this._lastActiveSortFn = null, this._invalidateCache(), this._invalidateOrderedCache(), 
      super.add(value), this;
    }
    delete(value) {
      return this._invalidateCache(), this._invalidateOrderedCache(), super.delete(value);
    }
    clear() {
      return this._invalidateCache(), this._invalidateOrderedCache(), super.clear();
    }
    sortWith(sortFn) {
      if (this.size <= 1 || sortFn === this._lastActiveSortFn) return;
      const sortedArray = Array.from(this).sort(sortFn);
      super.clear();
      for (let i = 0; i < sortedArray.length; i += 1) super.add(sortedArray[i]);
      this._lastActiveSortFn = sortFn, this._invalidateCache();
    }
    sort() {
      this.sortWith(this._sortFn);
    }
    getFromCache(fn) {
      if (void 0 === this._cache) this._cache = new Map; else {
        const data = this._cache.get(fn);
        if (void 0 !== data) return data;
      }
      const newData = fn(this);
      return this._cache.set(fn, newData), newData;
    }
    getFromUnorderedCache(fn) {
      if (void 0 === this._cacheOrderIndependent) this._cacheOrderIndependent = new Map; else {
        const data = this._cacheOrderIndependent.get(fn);
        if (void 0 !== data) return data;
      }
      const newData = fn(this);
      return this._cacheOrderIndependent.set(fn, newData), newData;
    }
    _invalidateCache() {
      void 0 !== this._cache && this._cache.clear();
    }
    _invalidateOrderedCache() {
      void 0 !== this._cacheOrderIndependent && this._cacheOrderIndependent.clear();
    }
  }
  module.exports = SortableSet;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NodeMainTemplatePlugin = __webpack_require__(79), NodeChunkTemplatePlugin = __webpack_require__(82), NodeHotUpdateChunkTemplatePlugin = __webpack_require__(83);
  module.exports = class {
    constructor(options) {
      options = options || {}, this.asyncChunkLoading = options.asyncChunkLoading;
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("NodeTemplatePlugin", compilation => {
        new NodeMainTemplatePlugin(this.asyncChunkLoading).apply(compilation.mainTemplate), 
        (new NodeChunkTemplatePlugin).apply(compilation.chunkTemplate), (new NodeHotUpdateChunkTemplatePlugin).apply(compilation.hotUpdateChunkTemplate);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ExternalsPlugin = __webpack_require__(26), builtins = __webpack_require__(100).builtinModules || Object.keys(process.binding("natives"));
  module.exports = class {
    apply(compiler) {
      new ExternalsPlugin("commonjs", builtins).apply(compiler);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ExternalModuleFactoryPlugin = __webpack_require__(152);
  module.exports = class {
    constructor(type, externals) {
      this.type = type, this.externals = externals;
    }
    apply(compiler) {
      compiler.hooks.compile.tap("ExternalsPlugin", ({normalModuleFactory: normalModuleFactory}) => {
        new ExternalModuleFactoryPlugin(this.type, this.externals).apply(normalModuleFactory);
      });
    }
  };
}, function(module, exports) {
  exports.connectChunkGroupAndChunk = (chunkGroup, chunk) => {
    chunkGroup.pushChunk(chunk) && chunk.addGroup(chunkGroup);
  }, exports.connectChunkGroupParentAndChild = (parent, child) => {
    parent.addChild(child) && child.addParent(parent);
  }, exports.connectChunkAndModule = (chunk, module) => {
    module.addChunk(chunk) && chunk.addModule(module);
  }, exports.disconnectChunkAndModule = (chunk, module) => {
    chunk.removeModule(module), module.removeChunk(chunk);
  }, exports.connectDependenciesBlockAndChunkGroup = (depBlock, chunkGroup) => {
    chunkGroup.addBlock(depBlock) && (depBlock.chunkGroup = chunkGroup);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequestShortener = __webpack_require__(58), SizeFormatHelpers = __webpack_require__(38), formatLocation = __webpack_require__(202), identifierUtils = __webpack_require__(14), compareLocations = __webpack_require__(36), {LogType: LogType} = __webpack_require__(39), optionsOrFallback = (...args) => {
    let optionValues = [];
    return optionValues.push(...args), optionValues.find(optionValue => void 0 !== optionValue);
  }, compareId = (a, b) => typeof a != typeof b ? typeof a < typeof b ? -1 : 1 : a < b ? -1 : a > b ? 1 : 0;
  class Stats {
    constructor(compilation) {
      this.compilation = compilation, this.hash = compilation.hash, this.startTime = void 0, 
      this.endTime = void 0;
    }
    static filterWarnings(warnings, warningsFilter) {
      if (!warningsFilter) return warnings;
      const normalizedWarningsFilters = [].concat(warningsFilter).map(filter => {
        if ("string" == typeof filter) return warning => warning.includes(filter);
        if (filter instanceof RegExp) return warning => filter.test(warning);
        if ("function" == typeof filter) return filter;
        throw new Error(`Can only filter warnings with Strings or RegExps. (Given: ${filter})`);
      });
      return warnings.filter(warning => !normalizedWarningsFilters.some(check => check(warning)));
    }
    formatFilePath(filePath) {
      return filePath.includes("!") ? `${filePath.replace(/^(\s|\S)*!/, "")} (${filePath})` : "" + filePath;
    }
    hasWarnings() {
      return this.compilation.warnings.length > 0 || this.compilation.children.some(child => child.getStats().hasWarnings());
    }
    hasErrors() {
      return this.compilation.errors.length > 0 || this.compilation.children.some(child => child.getStats().hasErrors());
    }
    normalizeFieldKey(field) {
      return "!" === field[0] ? field.substr(1) : field;
    }
    sortOrderRegular(field) {
      return "!" !== field[0];
    }
    toJson(options, forToString) {
      "boolean" == typeof options || "string" == typeof options ? options = Stats.presetToOptions(options) : options || (options = {});
      const optionOrLocalFallback = (v, def) => void 0 !== v ? v : void 0 !== options.all ? options.all : def, testAgainstGivenOption = item => {
        if ("string" == typeof item) {
          const regExp = new RegExp(`[\\\\/]${item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&")}([\\\\/]|$|!|\\?)`);
          return ident => regExp.test(ident);
        }
        return item && "object" == typeof item && "function" == typeof item.test ? ident => item.test(ident) : "function" == typeof item ? item : "boolean" == typeof item ? () => item : void 0;
      }, compilation = this.compilation, context = optionsOrFallback(options.context, compilation.compiler.context), requestShortener = compilation.compiler.context === context ? compilation.requestShortener : new RequestShortener(context), showPerformance = optionOrLocalFallback(options.performance, !0), showHash = optionOrLocalFallback(options.hash, !0), showEnv = optionOrLocalFallback(options.env, !1), showVersion = optionOrLocalFallback(options.version, !0), showTimings = optionOrLocalFallback(options.timings, !0), showBuiltAt = optionOrLocalFallback(options.builtAt, !0), showAssets = optionOrLocalFallback(options.assets, !0), showEntrypoints = optionOrLocalFallback(options.entrypoints, !0), showChunkGroups = optionOrLocalFallback(options.chunkGroups, !forToString), showChunks = optionOrLocalFallback(options.chunks, !forToString), showChunkModules = optionOrLocalFallback(options.chunkModules, !0), showChunkOrigins = optionOrLocalFallback(options.chunkOrigins, !forToString), showModules = optionOrLocalFallback(options.modules, !0), showNestedModules = optionOrLocalFallback(options.nestedModules, !0), showModuleAssets = optionOrLocalFallback(options.moduleAssets, !forToString), showDepth = optionOrLocalFallback(options.depth, !forToString), showCachedModules = optionOrLocalFallback(options.cached, !0), showCachedAssets = optionOrLocalFallback(options.cachedAssets, !0), showReasons = optionOrLocalFallback(options.reasons, !forToString), showUsedExports = optionOrLocalFallback(options.usedExports, !forToString), showProvidedExports = optionOrLocalFallback(options.providedExports, !forToString), showOptimizationBailout = optionOrLocalFallback(options.optimizationBailout, !forToString), showChildren = optionOrLocalFallback(options.children, !0), showSource = optionOrLocalFallback(options.source, !forToString), showModuleTrace = optionOrLocalFallback(options.moduleTrace, !0), showErrors = optionOrLocalFallback(options.errors, !0), showErrorDetails = optionOrLocalFallback(options.errorDetails, !forToString), showWarnings = optionOrLocalFallback(options.warnings, !0), warningsFilter = optionsOrFallback(options.warningsFilter, null), showPublicPath = optionOrLocalFallback(options.publicPath, !forToString), showLogging = optionOrLocalFallback(options.logging, !forToString || "info"), showLoggingTrace = optionOrLocalFallback(options.loggingTrace, !forToString), loggingDebug = [].concat(optionsOrFallback(options.loggingDebug, [])).map(testAgainstGivenOption), excludeModules = [].concat(optionsOrFallback(options.excludeModules, options.exclude, [])).map(testAgainstGivenOption), excludeAssets = [].concat(optionsOrFallback(options.excludeAssets, [])).map(testAgainstGivenOption), maxModules = optionsOrFallback(options.maxModules, forToString ? 15 : 1 / 0), sortModules = optionsOrFallback(options.modulesSort, "id"), sortChunks = optionsOrFallback(options.chunksSort, "id"), sortAssets = optionsOrFallback(options.assetsSort, ""), showOutputPath = optionOrLocalFallback(options.outputPath, !forToString);
      showCachedModules || excludeModules.push((ident, module) => !module.built);
      const createModuleFilter = () => {
        let i = 0;
        return module => {
          if (excludeModules.length > 0) {
            const ident = requestShortener.shorten(module.resource);
            if (excludeModules.some(fn => fn(ident, module))) return !1;
          }
          const result = i < maxModules;
          return i++, result;
        };
      }, sortByField = (field, originalArray) => {
        const originalMap = originalArray.reduce((map, v, i) => (map.set(v, i), map), new Map);
        return (a, b) => {
          if (field) {
            const fieldKey = this.normalizeFieldKey(field), sortIsRegular = this.sortOrderRegular(field), cmp = ((fieldKey, a, b) => null === a[fieldKey] && null === b[fieldKey] ? 0 : null === a[fieldKey] ? 1 : null === b[fieldKey] ? -1 : a[fieldKey] === b[fieldKey] ? 0 : typeof a[fieldKey] != typeof b[fieldKey] ? typeof a[fieldKey] < typeof b[fieldKey] ? -1 : 1 : a[fieldKey] < b[fieldKey] ? -1 : 1)(fieldKey, sortIsRegular ? a : b, sortIsRegular ? b : a);
            if (cmp) return cmp;
          }
          return originalMap.get(a) - originalMap.get(b);
        };
      }, formatError = e => {
        let text = "";
        if ("string" == typeof e && (e = {
          message: e
        }), e.chunk && (text += `chunk ${e.chunk.name || e.chunk.id}${e.chunk.hasRuntime() ? " [entry]" : e.chunk.canBeInitial() ? " [initial]" : ""}\n`), 
        e.file && (text += e.file + "\n"), e.module && e.module.readableIdentifier && "function" == typeof e.module.readableIdentifier) {
          if (text += this.formatFilePath(e.module.readableIdentifier(requestShortener)), 
          "object" == typeof e.loc) {
            const locInfo = formatLocation(e.loc);
            locInfo && (text += " " + locInfo);
          }
          text += "\n";
        }
        if (text += e.message, showErrorDetails && e.details && (text += "\n" + e.details), 
        showErrorDetails && e.missing && (text += e.missing.map(item => `\n[${item}]`).join("")), 
        showModuleTrace && e.origin) {
          if (text += "\n @ " + this.formatFilePath(e.origin.readableIdentifier(requestShortener)), 
          "object" == typeof e.originLoc) {
            const locInfo = formatLocation(e.originLoc);
            locInfo && (text += " " + locInfo);
          }
          if (e.dependencies) for (const dep of e.dependencies) {
            if (!dep.loc) continue;
            if ("string" == typeof dep.loc) continue;
            const locInfo = formatLocation(dep.loc);
            locInfo && (text += " " + locInfo);
          }
          let current = e.origin;
          for (;current.issuer; ) current = current.issuer, text += "\n @ " + current.readableIdentifier(requestShortener);
        }
        return text;
      }, obj = {
        errors: compilation.errors.map(formatError),
        warnings: Stats.filterWarnings(compilation.warnings.map(formatError), warningsFilter)
      };
      if (Object.defineProperty(obj, "_showWarnings", {
        value: showWarnings,
        enumerable: !1
      }), Object.defineProperty(obj, "_showErrors", {
        value: showErrors,
        enumerable: !1
      }), showVersion && (obj.version = __webpack_require__(59).version), showHash && (obj.hash = this.hash), 
      showTimings && this.startTime && this.endTime && (obj.time = this.endTime - this.startTime), 
      showBuiltAt && this.endTime && (obj.builtAt = this.endTime), showEnv && options._env && (obj.env = options._env), 
      compilation.needAdditionalPass && (obj.needAdditionalPass = !0), showPublicPath && (obj.publicPath = this.compilation.mainTemplate.getPublicPath({
        hash: this.compilation.hash
      })), showOutputPath && (obj.outputPath = this.compilation.mainTemplate.outputOptions.path), 
      showAssets) {
        const assetsByFile = {}, compilationAssets = compilation.getAssets().sort((a, b) => a.name < b.name ? -1 : 1);
        obj.assetsByChunkName = {}, obj.assets = compilationAssets.map(({name: name, source: source, info: info}) => {
          const obj = {
            name: name,
            size: source.size(),
            chunks: [],
            chunkNames: [],
            info: info,
            emitted: source.emitted || compilation.emittedAssets.has(name)
          };
          return showPerformance && (obj.isOverSizeLimit = source.isOverSizeLimit), assetsByFile[name] = obj, 
          obj;
        }).filter(asset => {
          if (excludeAssets.length > 0) {
            const ident = asset.name;
            if (excludeAssets.some(fn => fn(ident, asset))) return !1;
          }
          return showCachedAssets || asset.emitted;
        }), obj.filteredAssets = compilationAssets.length - obj.assets.length;
        for (const chunk of compilation.chunks) for (const asset of chunk.files) if (assetsByFile[asset]) {
          for (const id of chunk.ids) assetsByFile[asset].chunks.push(id);
          chunk.name && (assetsByFile[asset].chunkNames.push(chunk.name), obj.assetsByChunkName[chunk.name] ? obj.assetsByChunkName[chunk.name] = [].concat(obj.assetsByChunkName[chunk.name]).concat([ asset ]) : obj.assetsByChunkName[chunk.name] = asset);
        }
        obj.assets.sort(sortByField(sortAssets, obj.assets));
      }
      const fnChunkGroup = groupMap => {
        const obj = {};
        for (const keyValuePair of groupMap) {
          const name = keyValuePair[0], cg = keyValuePair[1], children = cg.getChildrenByOrders();
          obj[name] = {
            chunks: cg.chunks.map(c => c.id),
            assets: cg.chunks.reduce((array, c) => array.concat(c.files || []), []),
            children: Object.keys(children).reduce((obj, key) => {
              const groups = children[key];
              return obj[key] = groups.map(group => ({
                name: group.name,
                chunks: group.chunks.map(c => c.id),
                assets: group.chunks.reduce((array, c) => array.concat(c.files || []), [])
              })), obj;
            }, Object.create(null)),
            childAssets: Object.keys(children).reduce((obj, key) => {
              const groups = children[key];
              return obj[key] = Array.from(groups.reduce((set, group) => {
                for (const chunk of group.chunks) for (const asset of chunk.files) set.add(asset);
                return set;
              }, new Set)), obj;
            }, Object.create(null))
          }, showPerformance && (obj[name].isOverSizeLimit = cg.isOverSizeLimit);
        }
        return obj;
      };
      showEntrypoints && (obj.entrypoints = fnChunkGroup(compilation.entrypoints)), showChunkGroups && (obj.namedChunkGroups = fnChunkGroup(compilation.namedChunkGroups));
      const fnModule = module => {
        const path = [];
        let current = module;
        for (;current.issuer; ) path.push(current = current.issuer);
        path.reverse();
        const obj = {
          id: module.id,
          identifier: module.identifier(),
          name: module.readableIdentifier(requestShortener),
          index: module.index,
          index2: module.index2,
          size: module.size(),
          cacheable: module.buildInfo.cacheable,
          built: !!module.built,
          optional: module.optional,
          prefetched: module.prefetched,
          chunks: Array.from(module.chunksIterable, chunk => chunk.id),
          issuer: module.issuer && module.issuer.identifier(),
          issuerId: module.issuer && module.issuer.id,
          issuerName: module.issuer && module.issuer.readableIdentifier(requestShortener),
          issuerPath: module.issuer && path.map(module => ({
            id: module.id,
            identifier: module.identifier(),
            name: module.readableIdentifier(requestShortener),
            profile: module.profile
          })),
          profile: module.profile,
          failed: !!module.error,
          errors: module.errors ? module.errors.length : 0,
          warnings: module.warnings ? module.warnings.length : 0
        };
        if (showModuleAssets && (obj.assets = Object.keys(module.buildInfo.assets || {})), 
        showReasons && (obj.reasons = module.reasons.sort((a, b) => {
          if (a.module && !b.module) return -1;
          if (!a.module && b.module) return 1;
          if (a.module && b.module) {
            const cmp = compareId(a.module.id, b.module.id);
            if (cmp) return cmp;
          }
          if (a.dependency && !b.dependency) return -1;
          if (!a.dependency && b.dependency) return 1;
          if (a.dependency && b.dependency) {
            const cmp = compareLocations(a.dependency.loc, b.dependency.loc);
            if (cmp) return cmp;
            if (a.dependency.type < b.dependency.type) return -1;
            if (a.dependency.type > b.dependency.type) return 1;
          }
          return 0;
        }).map(reason => {
          const obj = {
            moduleId: reason.module ? reason.module.id : null,
            moduleIdentifier: reason.module ? reason.module.identifier() : null,
            module: reason.module ? reason.module.readableIdentifier(requestShortener) : null,
            moduleName: reason.module ? reason.module.readableIdentifier(requestShortener) : null,
            type: reason.dependency ? reason.dependency.type : null,
            explanation: reason.explanation,
            userRequest: reason.dependency ? reason.dependency.userRequest : null
          };
          if (reason.dependency) {
            const locInfo = formatLocation(reason.dependency.loc);
            locInfo && (obj.loc = locInfo);
          }
          return obj;
        })), showUsedExports && (!0 === module.used ? obj.usedExports = module.usedExports : !1 === module.used && (obj.usedExports = !1)), 
        showProvidedExports && (obj.providedExports = Array.isArray(module.buildMeta.providedExports) ? module.buildMeta.providedExports : null), 
        showOptimizationBailout && (obj.optimizationBailout = module.optimizationBailout.map(item => "function" == typeof item ? item(requestShortener) : item)), 
        showDepth && (obj.depth = module.depth), showNestedModules && module.modules) {
          const modules = module.modules;
          obj.modules = modules.sort(sortByField("depth", modules)).filter(createModuleFilter()).map(fnModule), 
          obj.filteredModules = modules.length - obj.modules.length, obj.modules.sort(sortByField(sortModules, obj.modules));
        }
        return showSource && module._source && (obj.source = module._source.source()), obj;
      };
      if (showChunks && (obj.chunks = compilation.chunks.map(chunk => {
        const parents = new Set, children = new Set, siblings = new Set, childIdByOrder = chunk.getChildIdsByOrders();
        for (const chunkGroup of chunk.groupsIterable) {
          for (const parentGroup of chunkGroup.parentsIterable) for (const chunk of parentGroup.chunks) parents.add(chunk.id);
          for (const childGroup of chunkGroup.childrenIterable) for (const chunk of childGroup.chunks) children.add(chunk.id);
          for (const sibling of chunkGroup.chunks) sibling !== chunk && siblings.add(sibling.id);
        }
        const obj = {
          id: chunk.id,
          rendered: chunk.rendered,
          initial: chunk.canBeInitial(),
          entry: chunk.hasRuntime(),
          recorded: chunk.recorded,
          reason: chunk.chunkReason,
          size: chunk.modulesSize(),
          names: chunk.name ? [ chunk.name ] : [],
          files: chunk.files.slice(),
          hash: chunk.renderedHash,
          siblings: Array.from(siblings).sort(compareId),
          parents: Array.from(parents).sort(compareId),
          children: Array.from(children).sort(compareId),
          childrenByOrder: childIdByOrder
        };
        if (showChunkModules) {
          const modules = chunk.getModules();
          obj.modules = modules.slice().sort(sortByField("depth", modules)).filter(createModuleFilter()).map(fnModule), 
          obj.filteredModules = chunk.getNumberOfModules() - obj.modules.length, obj.modules.sort(sortByField(sortModules, obj.modules));
        }
        return showChunkOrigins && (obj.origins = Array.from(chunk.groupsIterable, g => g.origins).reduce((a, b) => a.concat(b), []).map(origin => ({
          moduleId: origin.module ? origin.module.id : void 0,
          module: origin.module ? origin.module.identifier() : "",
          moduleIdentifier: origin.module ? origin.module.identifier() : "",
          moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : "",
          loc: formatLocation(origin.loc),
          request: origin.request,
          reasons: origin.reasons || []
        })).sort((a, b) => {
          const cmp1 = compareId(a.moduleId, b.moduleId);
          if (cmp1) return cmp1;
          const cmp2 = compareId(a.loc, b.loc);
          if (cmp2) return cmp2;
          const cmp3 = compareId(a.request, b.request);
          return cmp3 || 0;
        })), obj;
      }), obj.chunks.sort(sortByField(sortChunks, obj.chunks))), showModules && (obj.modules = compilation.modules.slice().sort(sortByField("depth", compilation.modules)).filter(createModuleFilter()).map(fnModule), 
      obj.filteredModules = compilation.modules.length - obj.modules.length, obj.modules.sort(sortByField(sortModules, obj.modules))), 
      showLogging) {
        const util = __webpack_require__(11);
        let acceptedTypes;
        obj.logging = {};
        let collapsedGroups = !1;
        switch (showLogging) {
         case "none":
          acceptedTypes = new Set([]);
          break;

         case "error":
          acceptedTypes = new Set([ LogType.error ]);
          break;

         case "warn":
          acceptedTypes = new Set([ LogType.error, LogType.warn ]);
          break;

         case "info":
          acceptedTypes = new Set([ LogType.error, LogType.warn, LogType.info ]);
          break;

         case !0:
         case "log":
          acceptedTypes = new Set([ LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.clear ]);
          break;

         case "verbose":
          acceptedTypes = new Set([ LogType.error, LogType.warn, LogType.info, LogType.log, LogType.group, LogType.groupEnd, LogType.groupCollapsed, LogType.profile, LogType.profileEnd, LogType.time, LogType.status, LogType.clear ]), 
          collapsedGroups = !0;
        }
        for (const [origin, logEntries] of compilation.logging) {
          const debugMode = loggingDebug.some(fn => fn(origin));
          let collapseCounter = 0, processedLogEntries = logEntries;
          debugMode || (processedLogEntries = processedLogEntries.filter(entry => {
            if (!acceptedTypes.has(entry.type)) return !1;
            if (!collapsedGroups) switch (entry.type) {
             case LogType.groupCollapsed:
              return collapseCounter++, 1 === collapseCounter;

             case LogType.group:
              return collapseCounter > 0 && collapseCounter++, 0 === collapseCounter;

             case LogType.groupEnd:
              return !(collapseCounter > 0) || (collapseCounter--, !1);

             default:
              return 0 === collapseCounter;
            }
            return !0;
          })), processedLogEntries = processedLogEntries.map(entry => {
            let message = void 0;
            return entry.type === LogType.time ? message = `${entry.args[0]}: ${1e3 * entry.args[1] + entry.args[2] / 1e6}ms` : entry.args && entry.args.length > 0 && (message = util.format(entry.args[0], ...entry.args.slice(1))), 
            {
              type: (debugMode || collapsedGroups) && entry.type === LogType.groupCollapsed ? LogType.group : entry.type,
              message: message,
              trace: showLoggingTrace && entry.trace ? entry.trace : void 0
            };
          });
          let name = identifierUtils.makePathsRelative(context, origin, compilation.cache).replace(/\|/g, " ");
          if (name in obj.logging) {
            let i = 1;
            for (;`${name}#${i}` in obj.logging; ) i++;
            name = `${name}#${i}`;
          }
          obj.logging[name] = {
            entries: processedLogEntries,
            filteredEntries: logEntries.length - processedLogEntries.length,
            debug: debugMode
          };
        }
      }
      return showChildren && (obj.children = compilation.children.map((child, idx) => {
        const childOptions = Stats.getChildOptions(options, idx), obj = new Stats(child).toJson(childOptions, forToString);
        return delete obj.hash, delete obj.version, child.name && (obj.name = identifierUtils.makePathsRelative(context, child.name, compilation.cache)), 
        obj;
      })), obj;
    }
    toString(options) {
      "boolean" == typeof options || "string" == typeof options ? options = Stats.presetToOptions(options) : options || (options = {});
      const useColors = optionsOrFallback(options.colors, !1), obj = this.toJson(options, !0);
      return Stats.jsonToString(obj, useColors);
    }
    static jsonToString(obj, useColors) {
      const buf = [], defaultColors = {
        bold: "[1m",
        yellow: "[1m[33m",
        red: "[1m[31m",
        green: "[1m[32m",
        cyan: "[1m[36m",
        magenta: "[1m[35m"
      }, colors = Object.keys(defaultColors).reduce((obj, color) => (obj[color] = str => {
        useColors && buf.push(!0 === useColors || void 0 === useColors[color] ? defaultColors[color] : useColors[color]), 
        buf.push(str), useColors && buf.push("[39m[22m");
      }, obj), {
        normal: str => buf.push(str)
      }), coloredTime = time => {
        let times = [ 800, 400, 200, 100 ];
        obj.time && (times = [ obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16 ]), 
        time < times[3] ? colors.normal(time + "ms") : time < times[2] ? colors.bold(time + "ms") : time < times[1] ? colors.green(time + "ms") : time < times[0] ? colors.yellow(time + "ms") : colors.red(time + "ms");
      }, newline = () => buf.push("\n"), getText = (arr, row, col) => arr[row][col].value, getAssetColor = (asset, defaultColor) => asset.isOverSizeLimit ? colors.yellow : defaultColor;
      if (obj.hash && (colors.normal("Hash: "), colors.bold(obj.hash), newline()), obj.version && (colors.normal("Version: webpack "), 
      colors.bold(obj.version), newline()), "number" == typeof obj.time && (colors.normal("Time: "), 
      colors.bold(obj.time), colors.normal("ms"), newline()), "number" == typeof obj.builtAt) {
        const builtAtDate = new Date(obj.builtAt);
        let timeZone = void 0;
        try {
          builtAtDate.toLocaleTimeString();
        } catch (err) {
          timeZone = "UTC";
        }
        colors.normal("Built at: "), colors.normal(builtAtDate.toLocaleDateString(void 0, {
          day: "2-digit",
          month: "2-digit",
          year: "numeric",
          timeZone: timeZone
        })), colors.normal(" "), colors.bold(builtAtDate.toLocaleTimeString(void 0, {
          timeZone: timeZone
        })), newline();
      }
      if (obj.env && (colors.normal("Environment (--env): "), colors.bold(JSON.stringify(obj.env, null, 2)), 
      newline()), obj.publicPath && (colors.normal("PublicPath: "), colors.bold(obj.publicPath), 
      newline()), obj.assets && obj.assets.length > 0) {
        const t = [ [ {
          value: "Asset",
          color: colors.bold
        }, {
          value: "Size",
          color: colors.bold
        }, {
          value: "Chunks",
          color: colors.bold
        }, {
          value: "",
          color: colors.bold
        }, {
          value: "",
          color: colors.bold
        }, {
          value: "Chunk Names",
          color: colors.bold
        } ] ];
        for (const asset of obj.assets) t.push([ {
          value: asset.name,
          color: getAssetColor(asset, colors.green)
        }, {
          value: SizeFormatHelpers.formatSize(asset.size),
          color: getAssetColor(asset, colors.normal)
        }, {
          value: asset.chunks.join(", "),
          color: colors.bold
        }, {
          value: [ asset.emitted && "[emitted]", asset.info.immutable && "[immutable]", asset.info.development && "[dev]", asset.info.hotModuleReplacement && "[hmr]" ].filter(Boolean).join(" "),
          color: colors.green
        }, {
          value: asset.isOverSizeLimit ? "[big]" : "",
          color: getAssetColor(asset, colors.normal)
        }, {
          value: asset.chunkNames.join(", "),
          color: colors.normal
        } ]);
        ((array, align, splitter) => {
          const rows = array.length, cols = array[0].length, colSizes = new Array(cols);
          for (let col = 0; col < cols; col++) colSizes[col] = 0;
          for (let row = 0; row < rows; row++) for (let col = 0; col < cols; col++) {
            const value = "" + getText(array, row, col);
            value.length > colSizes[col] && (colSizes[col] = value.length);
          }
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const format = array[row][col].color, value = "" + getText(array, row, col);
              let l = value.length;
              for ("l" === align[col] && format(value); l < colSizes[col] && col !== cols - 1; l++) colors.normal(" ");
              "r" === align[col] && format(value), col + 1 < cols && 0 !== colSizes[col] && colors.normal(splitter || "  ");
            }
            newline();
          }
        })(t, "rrrlll");
      }
      obj.filteredAssets > 0 && (colors.normal(" "), obj.assets.length > 0 && colors.normal("+ "), 
      colors.normal(obj.filteredAssets), obj.assets.length > 0 && colors.normal(" hidden"), 
      colors.normal(1 !== obj.filteredAssets ? " assets" : " asset"), newline());
      const processChunkGroups = (namedGroups, prefix) => {
        for (const name of Object.keys(namedGroups)) {
          const cg = namedGroups[name];
          colors.normal(prefix + " "), colors.bold(name), cg.isOverSizeLimit && (colors.normal(" "), 
          colors.yellow("[big]")), colors.normal(" =");
          for (const asset of cg.assets) colors.normal(" "), colors.green(asset);
          for (const name of Object.keys(cg.childAssets)) {
            const assets = cg.childAssets[name];
            if (assets && assets.length > 0) {
              colors.normal(" "), colors.magenta(`(${name}:`);
              for (const asset of assets) colors.normal(" "), colors.green(asset);
              colors.magenta(")");
            }
          }
          newline();
        }
      };
      if (obj.entrypoints && processChunkGroups(obj.entrypoints, "Entrypoint"), obj.namedChunkGroups) {
        let outputChunkGroups = obj.namedChunkGroups;
        obj.entrypoints && (outputChunkGroups = Object.keys(outputChunkGroups).filter(name => !obj.entrypoints[name]).reduce((result, name) => (result[name] = obj.namedChunkGroups[name], 
        result), {})), processChunkGroups(outputChunkGroups, "Chunk Group");
      }
      const modulesByIdentifier = {};
      if (obj.modules) for (const module of obj.modules) modulesByIdentifier["$" + module.identifier] = module; else if (obj.chunks) for (const chunk of obj.chunks) if (chunk.modules) for (const module of chunk.modules) modulesByIdentifier["$" + module.identifier] = module;
      const processModuleAttributes = module => {
        if (colors.normal(" "), colors.normal(SizeFormatHelpers.formatSize(module.size)), 
        module.chunks) for (const chunk of module.chunks) colors.normal(" {"), colors.yellow(chunk), 
        colors.normal("}");
        "number" == typeof module.depth && colors.normal(` [depth ${module.depth}]`), !1 === module.cacheable && colors.red(" [not cacheable]"), 
        module.optional && colors.yellow(" [optional]"), module.built && colors.green(" [built]"), 
        module.assets && module.assets.length && colors.magenta(` [${module.assets.length} asset${1 === module.assets.length ? "" : "s"}]`), 
        module.prefetched && colors.magenta(" [prefetched]"), module.failed && colors.red(" [failed]"), 
        module.warnings && colors.yellow(` [${module.warnings} warning${1 === module.warnings ? "" : "s"}]`), 
        module.errors && colors.red(` [${module.errors} error${1 === module.errors ? "" : "s"}]`);
      }, processModuleContent = (module, prefix) => {
        if (Array.isArray(module.providedExports) && (colors.normal(prefix), 0 === module.providedExports.length ? colors.cyan("[no exports]") : colors.cyan(`[exports: ${module.providedExports.join(", ")}]`), 
        newline()), void 0 !== module.usedExports && !0 !== module.usedExports) {
          if (colors.normal(prefix), null === module.usedExports) colors.cyan("[used exports unknown]"); else if (!1 === module.usedExports) colors.cyan("[no exports used]"); else if (Array.isArray(module.usedExports) && 0 === module.usedExports.length) colors.cyan("[no exports used]"); else if (Array.isArray(module.usedExports)) {
            const providedExportsCount = Array.isArray(module.providedExports) ? module.providedExports.length : null;
            null !== providedExportsCount && providedExportsCount === module.usedExports.length ? colors.cyan("[all exports used]") : colors.cyan(`[only some exports used: ${module.usedExports.join(", ")}]`);
          }
          newline();
        }
        if (Array.isArray(module.optimizationBailout)) for (const item of module.optimizationBailout) colors.normal(prefix), 
        colors.yellow(item), newline();
        if (module.reasons) for (const reason of module.reasons) colors.normal(prefix), 
        reason.type && (colors.normal(reason.type), colors.normal(" ")), reason.userRequest && (colors.cyan(reason.userRequest), 
        colors.normal(" ")), null !== reason.moduleId && (colors.normal("["), colors.normal(reason.moduleId), 
        colors.normal("]")), reason.module && reason.module !== reason.moduleId && (colors.normal(" "), 
        colors.magenta(reason.module)), reason.loc && (colors.normal(" "), colors.normal(reason.loc)), 
        reason.explanation && (colors.normal(" "), colors.cyan(reason.explanation)), newline();
        if (module.profile) {
          colors.normal(prefix);
          let sum = 0;
          if (module.issuerPath) for (const m of module.issuerPath) {
            if (colors.normal("["), colors.normal(m.id), colors.normal("] "), m.profile) {
              const time = (m.profile.factory || 0) + (m.profile.building || 0);
              coloredTime(time), sum += time, colors.normal(" ");
            }
            colors.normal("-> ");
          }
          for (const key of Object.keys(module.profile)) {
            colors.normal(key + ":");
            const time = module.profile[key];
            coloredTime(time), colors.normal(" "), sum += time;
          }
          colors.normal("= "), coloredTime(sum), newline();
        }
        module.modules && processModulesList(module, prefix + "| ");
      }, processModulesList = (obj, prefix) => {
        if (obj.modules) {
          let maxModuleId = 0;
          for (const module of obj.modules) "number" == typeof module.id && maxModuleId < module.id && (maxModuleId = module.id);
          let contentPrefix = prefix + "    ";
          maxModuleId >= 10 && (contentPrefix += " "), maxModuleId >= 100 && (contentPrefix += " "), 
          maxModuleId >= 1e3 && (contentPrefix += " ");
          for (const module of obj.modules) {
            colors.normal(prefix);
            const name = module.name || module.identifier;
            "string" != typeof module.id && "number" != typeof module.id || ("number" == typeof module.id ? (module.id < 1e3 && maxModuleId >= 1e3 && colors.normal(" "), 
            module.id < 100 && maxModuleId >= 100 && colors.normal(" "), module.id < 10 && maxModuleId >= 10 && colors.normal(" ")) : (maxModuleId >= 1e3 && colors.normal(" "), 
            maxModuleId >= 100 && colors.normal(" "), maxModuleId >= 10 && colors.normal(" ")), 
            name !== module.id ? (colors.normal("["), colors.normal(module.id), colors.normal("]"), 
            colors.normal(" ")) : (colors.normal("["), colors.bold(module.id), colors.normal("]"))), 
            name !== module.id && colors.bold(name), processModuleAttributes(module), newline(), 
            processModuleContent(module, contentPrefix);
          }
          obj.filteredModules > 0 && (colors.normal(prefix), colors.normal("   "), obj.modules.length > 0 && colors.normal(" + "), 
          colors.normal(obj.filteredModules), obj.modules.length > 0 && colors.normal(" hidden"), 
          colors.normal(1 !== obj.filteredModules ? " modules" : " module"), newline());
        }
      };
      if (obj.chunks) for (const chunk of obj.chunks) {
        colors.normal("chunk "), chunk.id < 1e3 && colors.normal(" "), chunk.id < 100 && colors.normal(" "), 
        chunk.id < 10 && colors.normal(" "), colors.normal("{"), colors.yellow(chunk.id), 
        colors.normal("} "), colors.green(chunk.files.join(", ")), chunk.names && chunk.names.length > 0 && (colors.normal(" ("), 
        colors.normal(chunk.names.join(", ")), colors.normal(")")), colors.normal(" "), 
        colors.normal(SizeFormatHelpers.formatSize(chunk.size));
        for (const id of chunk.parents) colors.normal(" <{"), colors.yellow(id), colors.normal("}>");
        for (const id of chunk.siblings) colors.normal(" ={"), colors.yellow(id), colors.normal("}=");
        for (const id of chunk.children) colors.normal(" >{"), colors.yellow(id), colors.normal("}<");
        if (chunk.childrenByOrder) for (const name of Object.keys(chunk.childrenByOrder)) {
          const children = chunk.childrenByOrder[name];
          colors.normal(" "), colors.magenta(`(${name}:`);
          for (const id of children) colors.normal(" {"), colors.yellow(id), colors.normal("}");
          colors.magenta(")");
        }
        if (chunk.entry ? colors.yellow(" [entry]") : chunk.initial && colors.yellow(" [initial]"), 
        chunk.rendered && colors.green(" [rendered]"), chunk.recorded && colors.green(" [recorded]"), 
        chunk.reason && colors.yellow(" " + chunk.reason), newline(), chunk.origins) for (const origin of chunk.origins) {
          if (colors.normal("    > "), origin.reasons && origin.reasons.length && (colors.yellow(origin.reasons.join(" ")), 
          colors.normal(" ")), origin.request && (colors.normal(origin.request), colors.normal(" ")), 
          origin.module) {
            colors.normal("["), colors.normal(origin.moduleId), colors.normal("] ");
            const module = modulesByIdentifier["$" + origin.module];
            module && (colors.bold(module.name), colors.normal(" "));
          }
          origin.loc && colors.normal(origin.loc), newline();
        }
        processModulesList(chunk, " ");
      }
      if (processModulesList(obj, ""), obj.logging) for (const origin of Object.keys(obj.logging)) {
        const logData = obj.logging[origin];
        if (logData.entries.length > 0) {
          newline(), logData.debug && colors.red("DEBUG "), colors.bold("LOG from " + origin), 
          newline();
          let indent = "";
          for (const entry of logData.entries) {
            let color = colors.normal, prefix = "    ";
            switch (entry.type) {
             case LogType.clear:
              colors.normal(indent + "-------"), newline();
              continue;

             case LogType.error:
              color = colors.red, prefix = "<e> ";
              break;

             case LogType.warn:
              color = colors.yellow, prefix = "<w> ";
              break;

             case LogType.info:
              color = colors.green, prefix = "<i> ";
              break;

             case LogType.log:
              color = colors.bold;
              break;

             case LogType.trace:
             case LogType.debug:
              color = colors.normal;
              break;

             case LogType.status:
              color = colors.magenta, prefix = "<s> ";
              break;

             case LogType.profile:
              color = colors.magenta, prefix = "<p> ";
              break;

             case LogType.profileEnd:
              color = colors.magenta, prefix = "</p> ";
              break;

             case LogType.time:
              color = colors.magenta, prefix = "<t> ";
              break;

             case LogType.group:
              color = colors.cyan, prefix = "<-> ";
              break;

             case LogType.groupCollapsed:
              color = colors.cyan, prefix = "<+> ";
              break;

             case LogType.groupEnd:
              indent.length >= 2 && (indent = indent.slice(0, indent.length - 2));
              continue;
            }
            if (entry.message) for (const line of entry.message.split("\n")) colors.normal(`${indent}${prefix}`), 
            color(line), newline();
            if (entry.trace) for (const line of entry.trace) colors.normal(`${indent}| ${line}`), 
            newline();
            switch (entry.type) {
             case LogType.group:
              indent += "  ";
            }
          }
          logData.filteredEntries && (colors.normal(`+ ${logData.filteredEntries} hidden lines`), 
          newline());
        }
      }
      if (obj._showWarnings && obj.warnings) for (const warning of obj.warnings) newline(), 
      colors.yellow("WARNING in " + warning), newline();
      if (obj._showErrors && obj.errors) for (const error of obj.errors) newline(), colors.red("ERROR in " + error), 
      newline();
      if (obj.children) for (const child of obj.children) {
        const childString = Stats.jsonToString(child, useColors);
        childString && (child.name ? (colors.normal("Child "), colors.bold(child.name), 
        colors.normal(":")) : colors.normal("Child"), newline(), buf.push("    "), buf.push(childString.replace(/\n/g, "\n    ")), 
        newline());
      }
      for (obj.needAdditionalPass && colors.yellow("Compilation needs an additional pass and will compile again."); "\n" === buf[buf.length - 1]; ) buf.pop();
      return buf.join("");
    }
    static presetToOptions(name) {
      switch ("string" == typeof name && name.toLowerCase() || name || "none") {
       case "none":
        return {
          all: !1
        };

       case "verbose":
        return {
          entrypoints: !0,
          chunkGroups: !0,
          modules: !1,
          chunks: !0,
          chunkModules: !0,
          chunkOrigins: !0,
          depth: !0,
          env: !0,
          reasons: !0,
          usedExports: !0,
          providedExports: !0,
          optimizationBailout: !0,
          errorDetails: !0,
          publicPath: !0,
          logging: "verbose",
          exclude: !1,
          maxModules: 1 / 0
        };

       case "detailed":
        return {
          entrypoints: !0,
          chunkGroups: !0,
          chunks: !0,
          chunkModules: !1,
          chunkOrigins: !0,
          depth: !0,
          usedExports: !0,
          providedExports: !0,
          optimizationBailout: !0,
          errorDetails: !0,
          publicPath: !0,
          logging: !0,
          exclude: !1,
          maxModules: 1 / 0
        };

       case "minimal":
        return {
          all: !1,
          modules: !0,
          maxModules: 0,
          errors: !0,
          warnings: !0,
          logging: "warn"
        };

       case "errors-only":
        return {
          all: !1,
          errors: !0,
          moduleTrace: !0,
          logging: "error"
        };

       case "errors-warnings":
        return {
          all: !1,
          errors: !0,
          warnings: !0,
          logging: "warn"
        };

       default:
        return {};
      }
    }
    static getChildOptions(options, idx) {
      let innerOptions;
      if (Array.isArray(options.children) ? idx < options.children.length && (innerOptions = options.children[idx]) : "object" == typeof options.children && options.children && (innerOptions = options.children), 
      "boolean" != typeof innerOptions && "string" != typeof innerOptions || (innerOptions = Stats.presetToOptions(innerOptions)), 
      !innerOptions) return options;
      const childOptions = Object.assign({}, options);
      return delete childOptions.children, Object.assign(childOptions, innerOptions);
    }
  }
  module.exports = Stats;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const forEachBail = __webpack_require__(42);
  function cdUp(directory) {
    if ("/" === directory) return null;
    const i = directory.lastIndexOf("/"), j = directory.lastIndexOf("\\"), p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
    return p < 0 ? null : directory.substr(0, p || 1);
  }
  exports.loadDescriptionFile = function(resolver, directory, filenames, resolveContext, callback) {
    !function findDescriptionFile() {
      forEachBail(filenames, (filename, callback) => {
        const descriptionFilePath = resolver.join(directory, filename);
        function onJson(err, content) {
          if (err) return resolveContext.log ? resolveContext.log(descriptionFilePath + " (directory description file): " + err) : err.message = descriptionFilePath + " (directory description file): " + err, 
          callback(err);
          callback(null, {
            content: content,
            directory: directory,
            path: descriptionFilePath
          });
        }
        resolver.fileSystem.readJson ? resolver.fileSystem.readJson(descriptionFilePath, (err, content) => {
          if (err) return void 0 !== err.code ? callback() : onJson(err);
          onJson(null, content);
        }) : resolver.fileSystem.readFile(descriptionFilePath, (err, content) => {
          if (err) return callback();
          let json;
          try {
            json = JSON.parse(content);
          } catch (e) {
            onJson(e);
          }
          onJson(null, json);
        });
      }, (err, result) => err ? callback(err) : result ? callback(null, result) : (directory = cdUp(directory)) ? findDescriptionFile() : callback());
    }();
  }, exports.getField = function(content, field) {
    if (content) if (Array.isArray(field)) {
      let current = content;
      for (let j = 0; j < field.length; j++) {
        if (null === current || "object" != typeof current) {
          current = null;
          break;
        }
        current = current[field[j]];
      }
      if ("object" == typeof current) return current;
    } else if ("object" == typeof content[field]) return content[field];
  }, exports.cdUp = cdUp;
}, function(module, exports) {
  module.exports = require("assert");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  module.exports = class extends ModuleDependency {
    constructor(request) {
      super(request);
    }
    get type() {
      return "single entry";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Dependency = __webpack_require__(19), CriticalDependencyWarning = __webpack_require__(303), regExpToString = r => r ? r + "" : "";
  class ContextDependency extends Dependency {
    constructor(options) {
      super(), this.options = options, this.userRequest = this.options.request, this.critical = !1, 
      this.hadGlobalOrStickyRegExp = !1, (this.options.regExp.global || this.options.regExp.sticky) && (this.options.regExp = null, 
      this.hadGlobalOrStickyRegExp = !0);
    }
    getResourceIdentifier() {
      return `context${this.options.request} ${this.options.recursive} ${regExpToString(this.options.regExp)} ${regExpToString(this.options.include)} ${regExpToString(this.options.exclude)} ${this.options.mode} ${this.options.chunkName} ` + JSON.stringify(this.options.groupOptions);
    }
    getWarnings() {
      let warnings = super.getWarnings() || [];
      return this.critical && warnings.push(new CriticalDependencyWarning(this.critical)), 
      this.hadGlobalOrStickyRegExp && warnings.push(new CriticalDependencyWarning("Contexts can't use RegExps with the 'g' or 'y' flags.")), 
      warnings;
    }
  }
  Object.defineProperty(ContextDependency.prototype, "async", {
    configurable: !1,
    get() {
      throw new Error("ContextDependency.async was removed. Use ContextDependency.options.mode instead.");
    },
    set() {
      throw new Error("ContextDependency.async was removed. Pass options.mode to constructor instead");
    }
  }), module.exports = ContextDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const quotemeta = str => str.replace(/[-[\]\\/{}()*+?.^$|]/g, "\\$&"), splitContextFromPrefix = prefix => {
    const idx = prefix.lastIndexOf("/");
    let context = ".";
    return idx >= 0 && (context = prefix.substr(0, idx), prefix = "." + prefix.substr(idx)), 
    {
      context: context,
      prefix: prefix
    };
  }, splitQueryFromPostfix = postfix => {
    const idx = postfix.indexOf("?");
    let query = "";
    return idx >= 0 && (query = postfix.substr(idx), postfix = postfix.substr(0, idx)), 
    {
      postfix: postfix,
      query: query
    };
  };
  exports.create = (Dep, range, param, expr, options, contextOptions, parser = null) => {
    if (param.isTemplateString()) {
      let prefixRaw = param.quasis[0].string, postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : "";
      const valueRange = param.range, {context: context, prefix: prefix} = splitContextFromPrefix(prefixRaw), {postfix: postfix, query: query} = splitQueryFromPostfix(postfixRaw), innerQuasis = param.quasis.slice(1, param.quasis.length - 1), innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source).join(""), regExp = new RegExp(`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`), dep = new Dep(Object.assign({
        request: context + query,
        recursive: options.wrappedContextRecursive,
        regExp: regExp,
        mode: "sync"
      }, contextOptions), range, valueRange);
      dep.loc = expr.loc;
      const replaces = [];
      return param.parts.forEach((part, i) => {
        if (i % 2 == 0) {
          let range = part.range, value = part.string;
          if ("cooked" === param.templateStringKind && (value = JSON.stringify(value), value = value.slice(1, value.length - 1)), 
          0 === i) value = prefix, range = [ param.range[0], part.range[1] ], value = ("cooked" === param.templateStringKind ? "`" : "String.raw`") + value; else if (i === param.parts.length - 1) value = postfix, 
          range = [ part.range[0], param.range[1] ], value += "`"; else if (part.expression && "TemplateElement" === part.expression.type && part.expression.value.raw === value) return;
          replaces.push({
            range: range,
            value: value
          });
        } else parser && parser.walkExpression(part.expression);
      }), dep.replaces = replaces, dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression", 
      dep;
    }
    if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {
      let prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : "", postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : "";
      const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null, postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null, valueRange = param.range, {context: context, prefix: prefix} = splitContextFromPrefix(prefixRaw), {postfix: postfix, query: query} = splitQueryFromPostfix(postfixRaw), regExp = new RegExp(`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(postfix)}$`), dep = new Dep(Object.assign({
        request: context + query,
        recursive: options.wrappedContextRecursive,
        regExp: regExp,
        mode: "sync"
      }, contextOptions), range, valueRange);
      dep.loc = expr.loc;
      const replaces = [];
      if (prefixRange && replaces.push({
        range: prefixRange,
        value: JSON.stringify(prefix)
      }), postfixRange && replaces.push({
        range: postfixRange,
        value: JSON.stringify(postfix)
      }), dep.replaces = replaces, dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression", 
      parser && param.wrappedInnerExpressions) for (const part of param.wrappedInnerExpressions) part.expression && parser.walkExpression(part.expression);
      return dep;
    }
    {
      const dep = new Dep(Object.assign({
        request: options.exprContextRequest,
        recursive: options.exprContextRecursive,
        regExp: options.exprContextRegExp,
        mode: "sync"
      }, contextOptions), range, param.range);
      return dep.loc = expr.loc, dep.critical = options.exprContextCritical && "the request of a dependency is an expression", 
      parser && parser.walkExpression(param.expression), dep;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const HarmonyImportDependency = __webpack_require__(22);
  class HarmonyImportSideEffectDependency extends HarmonyImportDependency {
    constructor(request, originModule, sourceOrder, parserScope) {
      super(request, originModule, sourceOrder, parserScope);
    }
    getReference() {
      return this._module && this._module.factoryMeta.sideEffectFree ? null : super.getReference();
    }
    get type() {
      return "harmony side effect evaluation";
    }
  }
  HarmonyImportSideEffectDependency.Template = class extends HarmonyImportDependency.Template {
    getHarmonyInitOrder(dep) {
      return dep._module && dep._module.factoryMeta.sideEffectFree ? NaN : super.getHarmonyInitOrder(dep);
    }
  }, module.exports = HarmonyImportSideEffectDependency;
}, function(module, exports) {
  module.exports = require("../vendor/wasm-ast");
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = (a, b) => {
    if ("string" == typeof a) return "string" == typeof b ? a < b ? -1 : a > b ? 1 : 0 : "object" == typeof b ? 1 : 0;
    if ("object" == typeof a) {
      if ("string" == typeof b) return -1;
      if ("object" == typeof b) {
        if ("start" in a && "start" in b) {
          const ap = a.start, bp = b.start;
          if (ap.line < bp.line) return -1;
          if (ap.line > bp.line) return 1;
          if (ap.column < bp.column) return -1;
          if (ap.column > bp.column) return 1;
        }
        if ("name" in a && "name" in b) {
          if (a.name < b.name) return -1;
          if (a.name > b.name) return 1;
        }
        if ("index" in a && "index" in b) {
          if (a.index < b.index) return -1;
          if (a.index > b.index) return 1;
        }
        return 0;
      }
      return 0;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.intersect = sets => {
    if (0 === sets.length) return new Set;
    if (1 === sets.length) return new Set(sets[0]);
    let minSize = 1 / 0, minIndex = -1;
    for (let i = 0; i < sets.length; i++) {
      const size = sets[i].size;
      size < minSize && (minIndex = i, minSize = size);
    }
    const current = new Set(sets[minIndex]);
    for (let i = 0; i < sets.length; i++) {
      if (i === minIndex) continue;
      const set = sets[i];
      for (const item of current) set.has(item) || current.delete(item);
    }
    return current;
  }, exports.isSubset = (bigSet, smallSet) => {
    if (bigSet.size < smallSet.size) return !1;
    for (const item of smallSet) if (!bigSet.has(item)) return !1;
    return !0;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.formatSize = size => {
    if ("number" != typeof size || !0 === Number.isNaN(size)) return "unknown size";
    if (size <= 0) return "0 bytes";
    const index = Math.floor(Math.log(size) / Math.log(1024));
    return `${+(size / Math.pow(1024, index)).toPrecision(3)} ${[ "bytes", "KiB", "MiB", "GiB" ][index]}`;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const LogType = Object.freeze({
    error: "error",
    warn: "warn",
    info: "info",
    log: "log",
    debug: "debug",
    trace: "trace",
    group: "group",
    groupCollapsed: "groupCollapsed",
    groupEnd: "groupEnd",
    profile: "profile",
    profileEnd: "profileEnd",
    time: "time",
    clear: "clear",
    status: "status"
  });
  exports.LogType = LogType;
  const LOG_SYMBOL = Symbol("webpack logger raw log method"), TIMERS_SYMBOL = Symbol("webpack logger times");
  exports.Logger = class {
    constructor(log) {
      this[LOG_SYMBOL] = log;
    }
    error(...args) {
      this[LOG_SYMBOL](LogType.error, args);
    }
    warn(...args) {
      this[LOG_SYMBOL](LogType.warn, args);
    }
    info(...args) {
      this[LOG_SYMBOL](LogType.info, args);
    }
    log(...args) {
      this[LOG_SYMBOL](LogType.log, args);
    }
    debug(...args) {
      this[LOG_SYMBOL](LogType.debug, args);
    }
    assert(assertion, ...args) {
      assertion || this[LOG_SYMBOL](LogType.error, args);
    }
    trace() {
      this[LOG_SYMBOL](LogType.trace, [ "Trace" ]);
    }
    clear() {
      this[LOG_SYMBOL](LogType.clear);
    }
    status(...args) {
      this[LOG_SYMBOL](LogType.status, args);
    }
    group(...args) {
      this[LOG_SYMBOL](LogType.group, args);
    }
    groupCollapsed(...args) {
      this[LOG_SYMBOL](LogType.groupCollapsed, args);
    }
    groupEnd(...args) {
      this[LOG_SYMBOL](LogType.groupEnd, args);
    }
    profile(label) {
      this[LOG_SYMBOL](LogType.profile, [ label ]);
    }
    profileEnd(label) {
      this[LOG_SYMBOL](LogType.profileEnd, [ label ]);
    }
    time(label) {
      this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map, this[TIMERS_SYMBOL].set(label, process.hrtime());
    }
    timeLog(label) {
      const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) throw new Error(`No such label '${label}' for WebpackLogger.timeLog()`);
      const time = process.hrtime(prev);
      this[LOG_SYMBOL](LogType.time, [ label, ...time ]);
    }
    timeEnd(label) {
      const prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) throw new Error(`No such label '${label}' for WebpackLogger.timeEnd()`);
      const time = process.hrtime(prev);
      this[TIMERS_SYMBOL].delete(label), this[LOG_SYMBOL](LogType.time, [ label, ...time ]);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  exports.cutOffByFlag = (stack, flag) => {
    stack = stack.split("\n");
    for (let i = 0; i < stack.length; i++) stack[i].includes(flag) && (stack.length = i);
    return stack.join("\n");
  }, exports.cutOffLoaderExecution = stack => exports.cutOffByFlag(stack, "LOADER_EXECUTION"), 
  exports.cutOffWebpackOptions = stack => exports.cutOffByFlag(stack, "WEBPACK_OPTIONS"), 
  exports.cutOffMultilineMessage = (stack, message) => (stack = stack.split("\n"), 
  message = message.split("\n"), stack.reduce((acc, line, idx) => line.includes(message[idx]) ? acc : acc.concat(line), []).join("\n")), 
  exports.cutOffMessage = (stack, message) => {
    const nextLine = stack.indexOf("\n");
    if (-1 === nextLine) return stack === message ? "" : stack;
    return stack.substr(0, nextLine) === message ? stack.substr(nextLine + 1) : stack;
  }, exports.cleanUp = (stack, message) => (stack = exports.cutOffLoaderExecution(stack), 
  stack = exports.cutOffMessage(stack, message)), exports.cleanUpWebpackOptions = (stack, message) => (stack = exports.cutOffWebpackOptions(stack), 
  stack = exports.cutOffMultilineMessage(stack, message));
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependenciesBlock = __webpack_require__(101);
  module.exports = class extends DependenciesBlock {
    constructor(groupOptions, module, loc, request) {
      super(), "string" == typeof groupOptions ? groupOptions = {
        name: groupOptions
      } : groupOptions || (groupOptions = {
        name: void 0
      }), this.groupOptions = groupOptions, this.chunkGroup = void 0, this.module = module, 
      this.loc = loc, this.request = request, this.parent = void 0;
    }
    get chunkName() {
      return this.groupOptions.name;
    }
    set chunkName(value) {
      this.groupOptions.name = value;
    }
    get chunks() {
      throw new Error("Moved to AsyncDependenciesBlock.chunkGroup");
    }
    set chunks(value) {
      throw new Error("Moved to AsyncDependenciesBlock.chunkGroup");
    }
    updateHash(hash) {
      hash.update(JSON.stringify(this.groupOptions)), hash.update(this.chunkGroup && this.chunkGroup.chunks.map(chunk => null !== chunk.id ? chunk.id : "").join(",") || ""), 
      super.updateHash(hash);
    }
    disconnect() {
      this.chunkGroup = void 0, super.disconnect();
    }
    unseal() {
      this.chunkGroup = void 0, super.unseal();
    }
    sortItems() {
      super.sortItems();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(array, iterator, callback) {
    if (0 === array.length) return callback();
    let currentResult, currentPos = array.length, done = [];
    for (let i = 0; i < array.length; i++) {
      const itCb = createIteratorCallback(i);
      if (iterator(array[i], itCb), 0 === currentPos) break;
    }
    function createIteratorCallback(i) {
      return (...args) => {
        i >= currentPos || (done.push(i), args.length > 0 && (currentPos = i + 1, done = done.filter(item => item <= i), 
        currentResult = args), done.length === currentPos && (callback.apply(null, currentResult), 
        currentPos = 0));
      };
    }
  }, module.exports.withIndex = function(array, iterator, callback) {
    if (0 === array.length) return callback();
    let currentResult, currentPos = array.length, done = [];
    for (let i = 0; i < array.length; i++) {
      const itCb = createIteratorCallback(i);
      if (iterator(array[i], i, itCb), 0 === currentPos) break;
    }
    function createIteratorCallback(i) {
      return (...args) => {
        i >= currentPos || (done.push(i), args.length > 0 && (currentPos = i + 1, done = done.filter(item => item <= i), 
        currentResult = args), done.length === currentPos && (callback.apply(null, currentResult), 
        currentPos = 0));
      };
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), ModuleDependency = __webpack_require__(4);
  module.exports = class extends ModuleDependency {
    constructor(exportName, request, name, valueType) {
      super(request), this.exportName = exportName, this.name = name, this.valueType = valueType;
    }
    getReference() {
      return this.module ? new DependencyReference(this.module, [ this.name ], !1) : null;
    }
    get type() {
      return "wasm export import";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), ModuleDependency = __webpack_require__(4), UnsupportedWebAssemblyFeatureError = __webpack_require__(117);
  module.exports = class extends ModuleDependency {
    constructor(request, name, description, onlyDirectImport) {
      super(request), this.name = name, this.description = description, this.onlyDirectImport = onlyDirectImport;
    }
    getReference() {
      return this.module ? new DependencyReference(this.module, [ this.name ], !1) : null;
    }
    getErrors() {
      if (this.onlyDirectImport && this.module && !this.module.type.startsWith("webassembly")) return [ new UnsupportedWebAssemblyFeatureError(`Import "${this.name}" from "${this.request}" with ${this.onlyDirectImport} can only be used for direct wasm to wasm dependencies`) ];
    }
    get type() {
      return "wasm import";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const toErrorCode = err => `var e = new Error(${JSON.stringify(err)}); e.code = 'MODULE_NOT_FOUND';`;
  exports.module = request => `!(function webpackMissingModule() { ${exports.moduleCode(request)} }())`, 
  exports.promise = request => `Promise.reject(function webpackMissingModule() { ${toErrorCode(`Cannot find module '${request}'`)} return e; }())`, 
  exports.moduleCode = request => toErrorCode(`Cannot find module '${request}'`) + " throw e;";
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(dep, source, runtime) {
      if (!dep.range) return;
      const content = runtime.moduleId({
        module: dep.module,
        request: dep.request
      });
      source.replace(dep.range[0], dep.range[1] - 1, content);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class LocalModuleDependency extends NullDependency {
    constructor(localModule, range, callNew) {
      super(), localModule.flagUsed(), this.localModule = localModule, this.range = range, 
      this.callNew = callNew;
    }
  }
  LocalModuleDependency.Template = class {
    apply(dep, source) {
      if (!dep.range) return;
      const moduleInstance = dep.callNew ? `new (function () { return ${dep.localModule.variableName()}; })()` : dep.localModule.variableName();
      source.replace(dep.range[0], dep.range[1] - 1, moduleInstance);
    }
  }, module.exports = LocalModuleDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class HarmonyCompatibilityDependency extends NullDependency {
    constructor(originModule) {
      super(), this.originModule = originModule;
    }
    get type() {
      return "harmony export header";
    }
  }
  HarmonyCompatibilityDependency.Template = class {
    apply(dep, source, runtime) {
      const usedExports = dep.originModule.usedExports;
      if (!1 !== usedExports && !Array.isArray(usedExports)) {
        const content = runtime.defineEsModuleFlagStatement({
          exportsArgument: dep.originModule.exportsArgument
        });
        source.insert(-10, content);
      }
    }
  }, module.exports = HarmonyCompatibilityDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), HarmonyImportDependency = __webpack_require__(22), HarmonyLinkingError = __webpack_require__(135);
  class HarmonyImportSpecifierDependency extends HarmonyImportDependency {
    constructor(request, originModule, sourceOrder, parserScope, id, name, range, strictExportPresence) {
      super(request, originModule, sourceOrder, parserScope), this.id = null === id ? null : "" + id, 
      this.redirectedId = void 0, this.name = name, this.range = range, this.strictExportPresence = strictExportPresence, 
      this.namespaceObjectAsContext = !1, this.callArgs = void 0, this.call = void 0, 
      this.directImport = void 0, this.shorthand = void 0;
    }
    get type() {
      return "harmony import specifier";
    }
    get _id() {
      return this.redirectedId || this.id;
    }
    getReference() {
      return this._module ? new DependencyReference(this._module, !(this._id && !this.namespaceObjectAsContext) || [ this._id ], !1, this.sourceOrder) : null;
    }
    getWarnings() {
      return this.strictExportPresence || this.originModule.buildMeta.strictHarmonyModule ? [] : this._getErrors();
    }
    getErrors() {
      return this.strictExportPresence || this.originModule.buildMeta.strictHarmonyModule ? this._getErrors() : [];
    }
    _getErrors() {
      const importedModule = this._module;
      if (!importedModule) return;
      if (!importedModule.buildMeta || !importedModule.buildMeta.exportsType) return this.originModule.buildMeta.strictHarmonyModule && this._id && "default" !== this._id ? [ new HarmonyLinkingError(`Can't import the named export '${this._id}' from non EcmaScript module (only default export is available)`) ] : void 0;
      if (!this._id) return;
      if (!1 !== importedModule.isProvided(this._id)) return;
      const idIsNotNameMessage = this._id !== this.name ? ` (imported as '${this.name}')` : "", errorMessage = `"export '${this._id}'${idIsNotNameMessage} was not found in '${this.userRequest}'`;
      return [ new HarmonyLinkingError(errorMessage) ];
    }
    getNumberOfIdOccurrences() {
      return 0;
    }
    updateHash(hash) {
      super.updateHash(hash);
      const importedModule = this._module;
      hash.update((importedModule && this._id) + ""), hash.update((importedModule && this._id && importedModule.isUsed(this._id)) + ""), 
      hash.update((importedModule && (!importedModule.buildMeta || importedModule.buildMeta.exportsType)) + ""), 
      hash.update((importedModule && importedModule.used + JSON.stringify(importedModule.usedExports)) + "");
    }
    disconnect() {
      super.disconnect(), this.redirectedId = void 0;
    }
  }
  HarmonyImportSpecifierDependency.Template = class extends HarmonyImportDependency.Template {
    apply(dep, source, runtime) {
      super.apply(dep, source, runtime);
      const content = this.getContent(dep, runtime);
      source.replace(dep.range[0], dep.range[1] - 1, content);
    }
    getContent(dep, runtime) {
      const exportExpr = runtime.exportFromImport({
        module: dep._module,
        request: dep.request,
        exportName: dep._id,
        originModule: dep.originModule,
        asiSafe: dep.shorthand,
        isCall: dep.call,
        callContext: !dep.directImport,
        importVar: dep.getImportVar()
      });
      return dep.shorthand ? `${dep.name}: ${exportExpr}` : exportExpr;
    }
  }, module.exports = HarmonyImportSpecifierDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), HarmonyImportDependency = __webpack_require__(22), Template = __webpack_require__(2), HarmonyLinkingError = __webpack_require__(135), EMPTY_MAP = new Map;
  class ExportMode {
    constructor(type) {
      this.type = type, this.name = null, this.map = EMPTY_MAP, this.ignored = null, this.module = null, 
      this.userRequest = null;
    }
  }
  const EMPTY_STAR_MODE = new ExportMode("empty-star");
  class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
    constructor(request, originModule, sourceOrder, parserScope, id, name, activeExports, otherStarExports, strictExportPresence) {
      super(request, originModule, sourceOrder, parserScope), this.id = id, this.redirectedId = void 0, 
      this.name = name, this.activeExports = activeExports, this.otherStarExports = otherStarExports, 
      this.strictExportPresence = strictExportPresence;
    }
    get type() {
      return "harmony export imported specifier";
    }
    get _id() {
      return this.redirectedId || this.id;
    }
    getMode(ignoreUnused) {
      const name = this.name, id = this._id, used = this.originModule.isUsed(name), importedModule = this._module;
      if (!importedModule) {
        const mode = new ExportMode("missing");
        return mode.userRequest = this.userRequest, mode;
      }
      if (!ignoreUnused && (name ? !used : !1 === this.originModule.usedExports)) {
        const mode = new ExportMode("unused");
        return mode.name = name || "*", mode;
      }
      const strictHarmonyModule = this.originModule.buildMeta.strictHarmonyModule;
      if (name && "default" === id && importedModule.buildMeta) {
        if (!importedModule.buildMeta.exportsType) {
          const mode = new ExportMode(strictHarmonyModule ? "reexport-non-harmony-default-strict" : "reexport-non-harmony-default");
          return mode.name = name, mode.module = importedModule, mode;
        }
        if ("named" === importedModule.buildMeta.exportsType) {
          const mode = new ExportMode("reexport-named-default");
          return mode.name = name, mode.module = importedModule, mode;
        }
      }
      const isNotAHarmonyModule = importedModule.buildMeta && !importedModule.buildMeta.exportsType;
      if (name) {
        let mode;
        return id ? isNotAHarmonyModule && strictHarmonyModule ? (mode = new ExportMode("rexport-non-harmony-undefined"), 
        mode.name = name) : (mode = new ExportMode("safe-reexport"), mode.map = new Map([ [ name, id ] ])) : isNotAHarmonyModule && strictHarmonyModule ? (mode = new ExportMode("reexport-fake-namespace-object"), 
        mode.name = name) : (mode = new ExportMode("reexport-namespace-object"), mode.name = name), 
        mode.module = importedModule, mode;
      }
      const hasUsedExports = Array.isArray(this.originModule.usedExports), hasProvidedExports = Array.isArray(importedModule.buildMeta.providedExports), activeFromOtherStarExports = this._discoverActiveExportsFromOtherStartExports();
      if (hasUsedExports) {
        if (hasProvidedExports) {
          const map = new Map(this.originModule.usedExports.filter(id => "default" !== id && (!this.activeExports.has(id) && (!activeFromOtherStarExports.has(id) && !!importedModule.buildMeta.providedExports.includes(id)))).map(item => [ item, item ]));
          if (0 === map.size) return EMPTY_STAR_MODE;
          const mode = new ExportMode("safe-reexport");
          return mode.module = importedModule, mode.map = map, mode;
        }
        const map = new Map(this.originModule.usedExports.filter(id => "default" !== id && (!this.activeExports.has(id) && !activeFromOtherStarExports.has(id))).map(item => [ item, item ]));
        if (0 === map.size) return EMPTY_STAR_MODE;
        const mode = new ExportMode("checked-reexport");
        return mode.module = importedModule, mode.map = map, mode;
      }
      if (hasProvidedExports) {
        const map = new Map(importedModule.buildMeta.providedExports.filter(id => "default" !== id && (!this.activeExports.has(id) && !activeFromOtherStarExports.has(id))).map(item => [ item, item ]));
        if (0 === map.size) return EMPTY_STAR_MODE;
        const mode = new ExportMode("safe-reexport");
        return mode.module = importedModule, mode.map = map, mode;
      }
      const mode = new ExportMode("dynamic-reexport");
      return mode.module = importedModule, mode.ignored = new Set([ "default", ...this.activeExports, ...activeFromOtherStarExports ]), 
      mode;
    }
    getReference() {
      const mode = this.getMode(!1);
      switch (mode.type) {
       case "missing":
       case "unused":
       case "empty-star":
        return null;

       case "reexport-non-harmony-default":
       case "reexport-named-default":
        return new DependencyReference(mode.module, [ "default" ], !1, this.sourceOrder);

       case "reexport-namespace-object":
       case "reexport-non-harmony-default-strict":
       case "reexport-fake-namespace-object":
       case "rexport-non-harmony-undefined":
        return new DependencyReference(mode.module, !0, !1, this.sourceOrder);

       case "safe-reexport":
       case "checked-reexport":
        return new DependencyReference(mode.module, Array.from(mode.map.values()), !1, this.sourceOrder);

       case "dynamic-reexport":
        return new DependencyReference(mode.module, !0, !1, this.sourceOrder);

       default:
        throw new Error("Unknown mode " + mode.type);
      }
    }
    _discoverActiveExportsFromOtherStartExports() {
      if (!this.otherStarExports) return new Set;
      const result = new Set;
      for (const otherStarExport of this.otherStarExports) {
        const otherImportedModule = otherStarExport._module;
        if (otherImportedModule && Array.isArray(otherImportedModule.buildMeta.providedExports)) for (const exportName of otherImportedModule.buildMeta.providedExports) result.add(exportName);
      }
      return result;
    }
    getExports() {
      if (this.name) return {
        exports: [ this.name ],
        dependencies: void 0
      };
      const importedModule = this._module;
      if (!importedModule) return {
        exports: null,
        dependencies: void 0
      };
      if (Array.isArray(importedModule.buildMeta.providedExports)) {
        const activeFromOtherStarExports = this._discoverActiveExportsFromOtherStartExports();
        return {
          exports: importedModule.buildMeta.providedExports.filter(id => "default" !== id && !activeFromOtherStarExports.has(id) && !this.activeExports.has(id)),
          dependencies: [ importedModule ]
        };
      }
      return importedModule.buildMeta.providedExports ? {
        exports: !0,
        dependencies: void 0
      } : {
        exports: null,
        dependencies: [ importedModule ]
      };
    }
    getWarnings() {
      return this.strictExportPresence || this.originModule.buildMeta.strictHarmonyModule ? [] : this._getErrors();
    }
    getErrors() {
      return this.strictExportPresence || this.originModule.buildMeta.strictHarmonyModule ? this._getErrors() : [];
    }
    _getErrors() {
      const importedModule = this._module;
      if (!importedModule) return;
      if (!importedModule.buildMeta || !importedModule.buildMeta.exportsType) return this.originModule.buildMeta.strictHarmonyModule && this._id && "default" !== this._id ? [ new HarmonyLinkingError(`Can't reexport the named export '${this._id}' from non EcmaScript module (only default export is available)`) ] : void 0;
      if (!this._id) return;
      if (!1 !== importedModule.isProvided(this._id)) return;
      const idIsNotNameMessage = this._id !== this.name ? ` (reexported as '${this.name}')` : "", errorMessage = `"export '${this._id}'${idIsNotNameMessage} was not found in '${this.userRequest}'`;
      return [ new HarmonyLinkingError(errorMessage) ];
    }
    updateHash(hash) {
      super.updateHash(hash);
      const hashValue = this.getHashValue(this._module);
      hash.update(hashValue);
    }
    getHashValue(importedModule) {
      if (!importedModule) return "";
      const stringifiedUsedExport = JSON.stringify(importedModule.usedExports), stringifiedProvidedExport = JSON.stringify(importedModule.buildMeta.providedExports);
      return importedModule.used + stringifiedUsedExport + stringifiedProvidedExport;
    }
    disconnect() {
      super.disconnect(), this.redirectedId = void 0;
    }
  }
  module.exports = HarmonyExportImportedSpecifierDependency, HarmonyExportImportedSpecifierDependency.Template = class extends HarmonyImportDependency.Template {
    harmonyInit(dep, source, runtime, dependencyTemplates) {
      super.harmonyInit(dep, source, runtime, dependencyTemplates);
      const content = this.getContent(dep);
      source.insert(-1, content);
    }
    getHarmonyInitOrder(dep) {
      if (dep.name) {
        if (!dep.originModule.isUsed(dep.name)) return NaN;
      } else {
        const importedModule = dep._module, activeFromOtherStarExports = dep._discoverActiveExportsFromOtherStartExports();
        if (Array.isArray(dep.originModule.usedExports)) {
          if (dep.originModule.usedExports.every(id => "default" === id || (!!dep.activeExports.has(id) || (!1 === importedModule.isProvided(id) || !!activeFromOtherStarExports.has(id))))) return NaN;
        } else if (dep.originModule.usedExports && importedModule && Array.isArray(importedModule.buildMeta.providedExports)) {
          if (importedModule.buildMeta.providedExports.every(id => "default" === id || (!!dep.activeExports.has(id) || !!activeFromOtherStarExports.has(id)))) return NaN;
        }
      }
      return super.getHarmonyInitOrder(dep);
    }
    getContent(dep) {
      const mode = dep.getMode(!1), module = dep.originModule, importedModule = dep._module, importVar = dep.getImportVar();
      switch (mode.type) {
       case "missing":
        return `throw new Error(${JSON.stringify(`Cannot find module '${mode.userRequest}'`)});\n`;

       case "unused":
        return Template.toNormalComment("unused harmony reexport " + mode.name) + "\n";

       case "reexport-non-harmony-default":
        return "/* harmony reexport (default from non-harmony) */ " + this.getReexportStatement(module, module.isUsed(mode.name), importVar, null);

       case "reexport-named-default":
        return "/* harmony reexport (default from named exports) */ " + this.getReexportStatement(module, module.isUsed(mode.name), importVar, "");

       case "reexport-fake-namespace-object":
        return "/* harmony reexport (fake namespace object from non-harmony) */ " + this.getReexportFakeNamespaceObjectStatement(module, module.isUsed(mode.name), importVar);

       case "rexport-non-harmony-undefined":
        return "/* harmony reexport (non default export from non-harmony) */ " + this.getReexportStatement(module, module.isUsed(mode.name), "undefined", "");

       case "reexport-non-harmony-default-strict":
        return "/* harmony reexport (default from non-harmony) */ " + this.getReexportStatement(module, module.isUsed(mode.name), importVar, "");

       case "reexport-namespace-object":
        return "/* harmony reexport (module object) */ " + this.getReexportStatement(module, module.isUsed(mode.name), importVar, "");

       case "empty-star":
        return "/* empty/unused harmony star reexport */";

       case "safe-reexport":
        return Array.from(mode.map.entries()).map(item => "/* harmony reexport (safe) */ " + this.getReexportStatement(module, module.isUsed(item[0]), importVar, importedModule.isUsed(item[1])) + "\n").join("");

       case "checked-reexport":
        return Array.from(mode.map.entries()).map(item => "/* harmony reexport (checked) */ " + this.getConditionalReexportStatement(module, item[0], importVar, item[1]) + "\n").join("");

       case "dynamic-reexport":
        {
          const ignoredExports = mode.ignored;
          let content = "/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in " + importVar + ") ";
          ignoredExports.size > 0 ? content += "if(" + JSON.stringify(Array.from(ignoredExports)) + ".indexOf(__WEBPACK_IMPORT_KEY__) < 0) " : content += "if(__WEBPACK_IMPORT_KEY__ !== 'default') ";
          return content + `(function(key) { __webpack_require__.d(${dep.originModule.exportsArgument}, key, function() { return ${importVar}[key]; }) }(__WEBPACK_IMPORT_KEY__));\n`;
        }

       default:
        throw new Error("Unknown mode " + mode.type);
      }
    }
    getReexportStatement(module, key, name, valueKey) {
      const exportsName = module.exportsArgument, returnValue = this.getReturnValue(name, valueKey);
      return `__webpack_require__.d(${exportsName}, ${JSON.stringify(key)}, function() { return ${returnValue}; });\n`;
    }
    getReexportFakeNamespaceObjectStatement(module, key, name) {
      return `__webpack_require__.d(${module.exportsArgument}, ${JSON.stringify(key)}, function() { return __webpack_require__.t(${name}); });\n`;
    }
    getConditionalReexportStatement(module, key, name, valueKey) {
      if (!1 === valueKey) return "/* unused export */\n";
      const exportsName = module.exportsArgument, returnValue = this.getReturnValue(name, valueKey);
      return `if(__webpack_require__.o(${name}, ${JSON.stringify(valueKey)})) __webpack_require__.d(${exportsName}, ${JSON.stringify(key)}, function() { return ${returnValue}; });\n`;
    }
    getReturnValue(name, valueKey) {
      return null === valueKey ? name + "_default.a" : "" === valueKey ? name : !1 === valueKey ? "/* unused export */ undefined" : `${name}[${JSON.stringify(valueKey)}]`;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const JsonpMainTemplatePlugin = __webpack_require__(325), JsonpChunkTemplatePlugin = __webpack_require__(327), JsonpHotUpdateChunkTemplatePlugin = __webpack_require__(328);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("JsonpTemplatePlugin", compilation => {
        (new JsonpMainTemplatePlugin).apply(compilation.mainTemplate), (new JsonpChunkTemplatePlugin).apply(compilation.chunkTemplate), 
        (new JsonpHotUpdateChunkTemplatePlugin).apply(compilation.hotUpdateChunkTemplate);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WasmMainTemplatePlugin = __webpack_require__(149);
  module.exports = class {
    constructor(options) {
      this.options = options || {};
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("FetchCompileWasmTemplatePlugin", compilation => {
        const mainTemplate = compilation.mainTemplate;
        new WasmMainTemplatePlugin(Object.assign({
          generateLoadBinaryCode: path => `fetch(${mainTemplate.requireFn}.p + ${path})`,
          supportsStreaming: !0
        }, this.options)).apply(mainTemplate);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AliasPlugin = __webpack_require__(64), ParserHelpers = __webpack_require__(9), nodeLibsBrowser = __webpack_require__(329);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      if (!1 === options) return;
      const getPathToModule = (module, type) => {
        if (!0 === type || void 0 === type && nodeLibsBrowser[module]) {
          if (!nodeLibsBrowser[module]) throw new Error(`No browser version for node.js core module ${module} available`);
          return nodeLibsBrowser[module];
        }
        return "mock" === type ? __webpack_require__(3).resolve(__dirname, "../web_modules/mock/" + module) : "empty" === type ? __webpack_require__(3).resolve(__dirname, "../web_modules/mock/empty") : module;
      }, addExpression = (parser, name, module, type, suffix) => {
        suffix = suffix || "", parser.hooks.expression.for(name).tap("NodeSourcePlugin", () => {
          if (parser.state.module && parser.state.module.resource === getPathToModule(module, type)) return;
          const mockModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, getPathToModule(module, type));
          return ParserHelpers.addParsedVariableToModule(parser, name, mockModule + suffix);
        });
      };
      compiler.hooks.compilation.tap("NodeSourcePlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const handler = (parser, parserOptions) => {
          if (!1 === parserOptions.node) return;
          let localOptions = options;
          if (parserOptions.node && (localOptions = Object.assign({}, localOptions, parserOptions.node)), 
          localOptions.global && parser.hooks.expression.for("global").tap("NodeSourcePlugin", () => {
            const retrieveGlobalModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, __webpack_require__(3).resolve(__dirname, "../buildin/global"));
            return ParserHelpers.addParsedVariableToModule(parser, "global", retrieveGlobalModule);
          }), localOptions.process) {
            const processType = localOptions.process;
            addExpression(parser, "process", "process", processType);
          }
          if (localOptions.console) {
            const consoleType = localOptions.console;
            addExpression(parser, "console", "console", consoleType);
          }
          const bufferType = localOptions.Buffer;
          if (bufferType && addExpression(parser, "Buffer", "buffer", bufferType, ".Buffer"), 
          localOptions.setImmediate) {
            const setImmediateType = localOptions.setImmediate;
            addExpression(parser, "setImmediate", "timers", setImmediateType, ".setImmediate"), 
            addExpression(parser, "clearImmediate", "timers", setImmediateType, ".clearImmediate");
          }
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("NodeSourcePlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("NodeSourcePlugin", handler);
      }), compiler.hooks.afterResolvers.tap("NodeSourcePlugin", compiler => {
        for (const lib of Object.keys(nodeLibsBrowser)) !1 !== options[lib] && compiler.resolverFactory.hooks.resolver.for("normal").tap("NodeSourcePlugin", resolver => {
          new AliasPlugin("described-resolve", {
            name: lib,
            onlyModule: !0,
            alias: getPathToModule(lib, options[lib])
          }, "resolve").apply(resolver);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2), WasmMainTemplatePlugin = __webpack_require__(149);
  module.exports = class {
    constructor(options) {
      this.options = options || {};
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("ReadFileCompileWasmTemplatePlugin", compilation => {
        new WasmMainTemplatePlugin(Object.assign({
          generateLoadBinaryCode: path => Template.asString([ "new Promise(function (resolve, reject) {", Template.indent([ "var { readFile } = require('fs');", "var { join } = require('path');", "", "try {", Template.indent([ `readFile(join(__dirname, ${path}), function(err, buffer){`, Template.indent([ "if (err) return reject(err);", "", "// Fake fetch response", "resolve({", Template.indent([ "arrayBuffer() { return Promise.resolve(buffer); }" ]), "});" ]), "});" ]), "} catch (err) { reject(err); }" ]), "})" ]),
          supportsStreaming: !1
        }, this.options)).apply(compilation.mainTemplate);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  !function clone(exports) {
    "use strict";
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
    function deepCopy(obj) {
      var key, val, ret = {};
      for (key in obj) obj.hasOwnProperty(key) && (val = obj[key], ret[key] = "object" == typeof val && null !== val ? deepCopy(val) : val);
      return ret;
    }
    function Reference(parent, key) {
      this.parent = parent, this.key = key;
    }
    function Element(node, path, wrap, ref) {
      this.node = node, this.path = path, this.wrap = wrap, this.ref = ref;
    }
    function Controller() {}
    function isNode(node) {
      return null != node && ("object" == typeof node && "string" == typeof node.type);
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
    }
    function traverse(root, visitor) {
      return (new Controller).traverse(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      return target = function(array, func) {
        var diff, len, i, current;
        for (len = array.length, i = 0; len; ) func(array[current = i + (diff = len >>> 1)]) ? len = diff : (i = current + 1, 
        len -= diff + 1);
        return i;
      }(tokens, (function(token) {
        return token.range[0] > comment.range[0];
      })), comment.extendedRange = [ comment.range[0], comment.range[1] ], target !== tokens.length && (comment.extendedRange[1] = tokens[target].range[0]), 
      (target -= 1) >= 0 && (comment.extendedRange[0] = tokens[target].range[1]), comment;
    }
    return Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, VisitorKeys = {
      AssignmentExpression: [ "left", "right" ],
      AssignmentPattern: [ "left", "right" ],
      ArrayExpression: [ "elements" ],
      ArrayPattern: [ "elements" ],
      ArrowFunctionExpression: [ "params", "body" ],
      AwaitExpression: [ "argument" ],
      BlockStatement: [ "body" ],
      BinaryExpression: [ "left", "right" ],
      BreakStatement: [ "label" ],
      CallExpression: [ "callee", "arguments" ],
      CatchClause: [ "param", "body" ],
      ClassBody: [ "body" ],
      ClassDeclaration: [ "id", "superClass", "body" ],
      ClassExpression: [ "id", "superClass", "body" ],
      ComprehensionBlock: [ "left", "right" ],
      ComprehensionExpression: [ "blocks", "filter", "body" ],
      ConditionalExpression: [ "test", "consequent", "alternate" ],
      ContinueStatement: [ "label" ],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: [ "body", "test" ],
      EmptyStatement: [],
      ExportAllDeclaration: [ "source" ],
      ExportDefaultDeclaration: [ "declaration" ],
      ExportNamedDeclaration: [ "declaration", "specifiers", "source" ],
      ExportSpecifier: [ "exported", "local" ],
      ExpressionStatement: [ "expression" ],
      ForStatement: [ "init", "test", "update", "body" ],
      ForInStatement: [ "left", "right", "body" ],
      ForOfStatement: [ "left", "right", "body" ],
      FunctionDeclaration: [ "id", "params", "body" ],
      FunctionExpression: [ "id", "params", "body" ],
      GeneratorExpression: [ "blocks", "filter", "body" ],
      Identifier: [],
      IfStatement: [ "test", "consequent", "alternate" ],
      ImportExpression: [ "source" ],
      ImportDeclaration: [ "specifiers", "source" ],
      ImportDefaultSpecifier: [ "local" ],
      ImportNamespaceSpecifier: [ "local" ],
      ImportSpecifier: [ "imported", "local" ],
      Literal: [],
      LabeledStatement: [ "label", "body" ],
      LogicalExpression: [ "left", "right" ],
      MemberExpression: [ "object", "property" ],
      MetaProperty: [ "meta", "property" ],
      MethodDefinition: [ "key", "value" ],
      ModuleSpecifier: [],
      NewExpression: [ "callee", "arguments" ],
      ObjectExpression: [ "properties" ],
      ObjectPattern: [ "properties" ],
      Program: [ "body" ],
      Property: [ "key", "value" ],
      RestElement: [ "argument" ],
      ReturnStatement: [ "argument" ],
      SequenceExpression: [ "expressions" ],
      SpreadElement: [ "argument" ],
      Super: [],
      SwitchStatement: [ "discriminant", "cases" ],
      SwitchCase: [ "test", "consequent" ],
      TaggedTemplateExpression: [ "tag", "quasi" ],
      TemplateElement: [],
      TemplateLiteral: [ "quasis", "expressions" ],
      ThisExpression: [],
      ThrowStatement: [ "argument" ],
      TryStatement: [ "block", "handler", "finalizer" ],
      UnaryExpression: [ "argument" ],
      UpdateExpression: [ "argument" ],
      VariableDeclaration: [ "declarations" ],
      VariableDeclarator: [ "id", "init" ],
      WhileStatement: [ "test", "body" ],
      WithStatement: [ "object", "body" ],
      YieldExpression: [ "argument" ]
    }, VisitorOption = {
      Break: BREAK = {},
      Skip: SKIP = {},
      Remove: REMOVE = {}
    }, Reference.prototype.replace = function(node) {
      this.parent[this.key] = node;
    }, Reference.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), 
      !1);
    }, Controller.prototype.path = function() {
      var i, iz, j, jz, result;
      function addToPath(result, path) {
        if (Array.isArray(path)) for (j = 0, jz = path.length; j < jz; ++j) result.push(path[j]); else result.push(path);
      }
      if (!this.__current.path) return null;
      for (result = [], i = 2, iz = this.__leavelist.length; i < iz; ++i) addToPath(result, this.__leavelist[i].path);
      return addToPath(result, this.__current.path), result;
    }, Controller.prototype.type = function() {
      return this.current().type || this.__current.wrap;
    }, Controller.prototype.parents = function() {
      var i, iz, result;
      for (result = [], i = 1, iz = this.__leavelist.length; i < iz; ++i) result.push(this.__leavelist[i].node);
      return result;
    }, Controller.prototype.current = function() {
      return this.__current.node;
    }, Controller.prototype.__execute = function(callback, element) {
      var previous, result;
      return result = void 0, previous = this.__current, this.__current = element, this.__state = null, 
      callback && (result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node)), 
      this.__current = previous, result;
    }, Controller.prototype.notify = function(flag) {
      this.__state = flag;
    }, Controller.prototype.skip = function() {
      this.notify(SKIP);
    }, Controller.prototype.break = function() {
      this.notify(BREAK);
    }, Controller.prototype.remove = function() {
      this.notify(REMOVE);
    }, Controller.prototype.__initialize = function(root, visitor) {
      this.visitor = visitor, this.root = root, this.__worklist = [], this.__leavelist = [], 
      this.__current = null, this.__state = null, this.__fallback = null, "iteration" === visitor.fallback ? this.__fallback = Object.keys : "function" == typeof visitor.fallback && (this.__fallback = visitor.fallback), 
      this.__keys = VisitorKeys, visitor.keys && (this.__keys = Object.assign(Object.create(this.__keys), visitor.keys));
    }, Controller.prototype.traverse = function(root, visitor) {
      var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
      for (this.__initialize(root, visitor), sentinel = {}, worklist = this.__worklist, 
      leavelist = this.__leavelist, worklist.push(new Element(root, null, null, null)), 
      leavelist.push(new Element(null, null, null, null)); worklist.length; ) if ((element = worklist.pop()) !== sentinel) {
        if (element.node) {
          if (ret = this.__execute(visitor.enter, element), this.__state === BREAK || ret === BREAK) return;
          if (worklist.push(sentinel), leavelist.push(element), this.__state === SKIP || ret === SKIP) continue;
          if (nodeType = (node = element.node).type || element.wrap, !(candidates = this.__keys[nodeType])) {
            if (!this.__fallback) throw new Error("Unknown node type " + nodeType + ".");
            candidates = this.__fallback(node);
          }
          for (current = candidates.length; (current -= 1) >= 0; ) if (candidate = node[key = candidates[current]]) if (Array.isArray(candidate)) {
            for (current2 = candidate.length; (current2 -= 1) >= 0; ) if (candidate[current2]) {
              if (isProperty(nodeType, candidates[current])) element = new Element(candidate[current2], [ key, current2 ], "Property", null); else {
                if (!isNode(candidate[current2])) continue;
                element = new Element(candidate[current2], [ key, current2 ], null, null);
              }
              worklist.push(element);
            }
          } else isNode(candidate) && worklist.push(new Element(candidate, key, null, null));
        }
      } else if (element = leavelist.pop(), ret = this.__execute(visitor.leave, element), 
      this.__state === BREAK || ret === BREAK) return;
    }, Controller.prototype.replace = function(root, visitor) {
      var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
      function removeElem(element) {
        var i, key, nextElem, parent;
        if (element.ref.remove()) for (key = element.ref.key, parent = element.ref.parent, 
        i = worklist.length; i--; ) if ((nextElem = worklist[i]).ref && nextElem.ref.parent === parent) {
          if (nextElem.ref.key < key) break;
          --nextElem.ref.key;
        }
      }
      for (this.__initialize(root, visitor), sentinel = {}, worklist = this.__worklist, 
      leavelist = this.__leavelist, element = new Element(root, null, null, new Reference(outer = {
        root: root
      }, "root")), worklist.push(element), leavelist.push(element); worklist.length; ) if ((element = worklist.pop()) !== sentinel) {
        if (void 0 !== (target = this.__execute(visitor.enter, element)) && target !== BREAK && target !== SKIP && target !== REMOVE && (element.ref.replace(target), 
        element.node = target), this.__state !== REMOVE && target !== REMOVE || (removeElem(element), 
        element.node = null), this.__state === BREAK || target === BREAK) return outer.root;
        if ((node = element.node) && (worklist.push(sentinel), leavelist.push(element), 
        this.__state !== SKIP && target !== SKIP)) {
          if (nodeType = node.type || element.wrap, !(candidates = this.__keys[nodeType])) {
            if (!this.__fallback) throw new Error("Unknown node type " + nodeType + ".");
            candidates = this.__fallback(node);
          }
          for (current = candidates.length; (current -= 1) >= 0; ) if (candidate = node[key = candidates[current]]) if (Array.isArray(candidate)) {
            for (current2 = candidate.length; (current2 -= 1) >= 0; ) if (candidate[current2]) {
              if (isProperty(nodeType, candidates[current])) element = new Element(candidate[current2], [ key, current2 ], "Property", new Reference(candidate, current2)); else {
                if (!isNode(candidate[current2])) continue;
                element = new Element(candidate[current2], [ key, current2 ], null, new Reference(candidate, current2));
              }
              worklist.push(element);
            }
          } else isNode(candidate) && worklist.push(new Element(candidate, key, null, new Reference(node, key)));
        }
      } else if (element = leavelist.pop(), void 0 !== (target = this.__execute(visitor.leave, element)) && target !== BREAK && target !== SKIP && target !== REMOVE && element.ref.replace(target), 
      this.__state !== REMOVE && target !== REMOVE || removeElem(element), this.__state === BREAK || target === BREAK) return outer.root;
      return outer.root;
    }, exports.version = __webpack_require__(358).version, exports.Syntax = Syntax, 
    exports.traverse = traverse, exports.replace = function(root, visitor) {
      return (new Controller).replace(root, visitor);
    }, exports.attachComments = function(tree, providedComments, tokens) {
      var comment, len, i, cursor, comments = [];
      if (!tree.range) throw new Error("attachComments needs range information");
      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) (comment = deepCopy(providedComments[i])).extendedRange = [ 0, tree.range[0] ], 
          comments.push(comment);
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i = 0, len = providedComments.length; i < len; i += 1) comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      return cursor = 0, traverse(tree, {
        enter: function(node) {
          for (var comment; cursor < comments.length && !((comment = comments[cursor]).extendedRange[1] > node.range[0]); ) comment.extendedRange[1] === node.range[0] ? (node.leadingComments || (node.leadingComments = []), 
          node.leadingComments.push(comment), comments.splice(cursor, 1)) : cursor += 1;
          return cursor === comments.length ? VisitorOption.Break : comments[cursor].extendedRange[0] > node.range[1] ? VisitorOption.Skip : void 0;
        }
      }), cursor = 0, traverse(tree, {
        leave: function(node) {
          for (var comment; cursor < comments.length && (comment = comments[cursor], !(node.range[1] < comment.extendedRange[0])); ) node.range[1] === comment.extendedRange[0] ? (node.trailingComments || (node.trailingComments = []), 
          node.trailingComments.push(comment), comments.splice(cursor, 1)) : cursor += 1;
          return cursor === comments.length ? VisitorOption.Break : comments[cursor].extendedRange[0] > node.range[1] ? VisitorOption.Skip : void 0;
        }
      }), tree;
    }, exports.VisitorKeys = VisitorKeys, exports.VisitorOption = VisitorOption, exports.Controller = Controller, 
    exports.cloneEnvironment = function() {
      return clone({});
    }, exports;
  }(exports);
}, function(module, exports, __webpack_require__) {
  "use strict";
  class Variable {
    constructor(name, scope) {
      this.name = name, this.identifiers = [], this.references = [], this.defs = [], this.tainted = !1, 
      this.stack = !0, this.scope = scope;
    }
  }
  Variable.CatchClause = "CatchClause", Variable.Parameter = "Parameter", Variable.FunctionName = "FunctionName", 
  Variable.ClassName = "ClassName", Variable.Variable = "Variable", Variable.ImportBinding = "ImportBinding", 
  Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable", module.exports = Variable;
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(txt, reviver, context) {
    context = context || 20;
    try {
      return JSON.parse(txt, reviver);
    } catch (e) {
      if ("string" != typeof txt) {
        const errorMessage = "Cannot parse " + (Array.isArray(txt) && 0 === txt.length ? "an empty array" : String(txt));
        throw new TypeError(errorMessage);
      }
      const syntaxErr = e.message.match(/^Unexpected token.*position\s+(\d+)/i), errIdx = syntaxErr ? +syntaxErr[1] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;
      if (null != errIdx) {
        const start = errIdx <= context ? 0 : errIdx - context, end = errIdx + context >= txt.length ? txt.length : errIdx + context;
        e.message += ` while parsing near '${0 === start ? "" : "..."}${txt.slice(start, end)}${end === txt.length ? "" : "..."}'`;
      } else e.message += ` while parsing '${txt.slice(0, 2 * context)}'`;
      throw e;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), NORMALIZE_SLASH_DIRECTION_REGEXP = /\\/g, PATH_CHARS_REGEXP = /[-[\]{}()*+?.,\\^$|#\s]/g, SEPARATOR_REGEXP = /[/\\]$/, FRONT_OR_BACK_BANG_REGEXP = /^!|!$/g, INDEX_JS_REGEXP = /\/index.js(!|\?|\(query\))/g, MATCH_RESOURCE_REGEXP = /!=!/, normalizeBackSlashDirection = request => request.replace(NORMALIZE_SLASH_DIRECTION_REGEXP, "/"), createRegExpForPath = path => {
    const regexpTypePartial = path.replace(PATH_CHARS_REGEXP, "\\$&");
    return new RegExp("(^|!)" + regexpTypePartial, "g");
  };
  module.exports = class {
    constructor(directory) {
      directory = normalizeBackSlashDirection(directory), SEPARATOR_REGEXP.test(directory) && (directory = directory.substr(0, directory.length - 1)), 
      directory && (this.currentDirectoryRegExp = createRegExpForPath(directory));
      const dirname = path.dirname(directory), parentDirectory = SEPARATOR_REGEXP.test(dirname) ? dirname.substr(0, dirname.length - 1) : dirname;
      if (parentDirectory && parentDirectory !== directory && (this.parentDirectoryRegExp = createRegExpForPath(parentDirectory + "/")), 
      __dirname.length >= 2) {
        const buildins = normalizeBackSlashDirection(path.join(__dirname, "..")), buildinsAsModule = this.currentDirectoryRegExp && this.currentDirectoryRegExp.test(buildins);
        this.buildinsAsModule = buildinsAsModule, this.buildinsRegExp = createRegExpForPath(buildins);
      }
      this.cache = new Map;
    }
    shorten(request) {
      if (!request) return request;
      const cacheEntry = this.cache.get(request);
      if (void 0 !== cacheEntry) return cacheEntry;
      let result = normalizeBackSlashDirection(request);
      return this.buildinsAsModule && this.buildinsRegExp && (result = result.replace(this.buildinsRegExp, "!(webpack)")), 
      this.currentDirectoryRegExp && (result = result.replace(this.currentDirectoryRegExp, "!.")), 
      this.parentDirectoryRegExp && (result = result.replace(this.parentDirectoryRegExp, "!../")), 
      !this.buildinsAsModule && this.buildinsRegExp && (result = result.replace(this.buildinsRegExp, "!(webpack)")), 
      result = result.replace(INDEX_JS_REGEXP, "$1"), result = result.replace(FRONT_OR_BACK_BANG_REGEXP, ""), 
      result = result.replace(MATCH_RESOURCE_REGEXP, " = "), this.cache.set(request, result), 
      result;
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"name":"webpack","version":"4.46.0"}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NativeModule = __webpack_require__(100), {CachedSource: CachedSource, LineToLineMappedSource: LineToLineMappedSource, OriginalSource: OriginalSource, RawSource: RawSource, SourceMapSource: SourceMapSource} = __webpack_require__(0), {getContext: getContext, runLoaders: runLoaders} = __webpack_require__(209), WebpackError = __webpack_require__(1), Module = __webpack_require__(18), ModuleParseError = __webpack_require__(215), ModuleBuildError = __webpack_require__(216), ModuleError = __webpack_require__(217), ModuleWarning = __webpack_require__(218), createHash = __webpack_require__(17), contextify = __webpack_require__(14).contextify, asString = buf => Buffer.isBuffer(buf) ? buf.toString("utf-8") : buf;
  class NonErrorEmittedError extends WebpackError {
    constructor(error) {
      super(), this.name = "NonErrorEmittedError", this.message = "(Emitted value instead of an instance of Error) " + error, 
      Error.captureStackTrace(this, this.constructor);
    }
  }
  module.exports = class extends Module {
    constructor({type: type, request: request, userRequest: userRequest, rawRequest: rawRequest, loaders: loaders, resource: resource, matchResource: matchResource, parser: parser, generator: generator, resolveOptions: resolveOptions}) {
      super(type, getContext(resource)), this.request = request, this.userRequest = userRequest, 
      this.rawRequest = rawRequest, this.binary = type.startsWith("webassembly"), this.parser = parser, 
      this.generator = generator, this.resource = resource, this.matchResource = matchResource, 
      this.loaders = loaders, void 0 !== resolveOptions && (this.resolveOptions = resolveOptions), 
      this.error = null, this._source = null, this._sourceSize = null, this._buildHash = "", 
      this.buildTimestamp = void 0, this._cachedSources = new Map, this.useSourceMap = !1, 
      this.lineToLine = !1, this._lastSuccessfulBuildMeta = {};
    }
    identifier() {
      return this.request;
    }
    readableIdentifier(requestShortener) {
      return requestShortener.shorten(this.userRequest);
    }
    libIdent(options) {
      return contextify(options.context, this.userRequest);
    }
    nameForCondition() {
      const resource = this.matchResource || this.resource, idx = resource.indexOf("?");
      return idx >= 0 ? resource.substr(0, idx) : resource;
    }
    updateCacheModule(module) {
      this.type = module.type, this.request = module.request, this.userRequest = module.userRequest, 
      this.rawRequest = module.rawRequest, this.parser = module.parser, this.generator = module.generator, 
      this.resource = module.resource, this.matchResource = module.matchResource, this.loaders = module.loaders, 
      this.resolveOptions = module.resolveOptions;
    }
    createSourceForAsset(name, content, sourceMap) {
      return sourceMap ? "string" == typeof sourceMap ? new OriginalSource(content, sourceMap) : new SourceMapSource(content, name, sourceMap) : new RawSource(content);
    }
    createLoaderContext(resolver, options, compilation, fs) {
      const requestShortener = compilation.runtimeTemplate.requestShortener, getCurrentLoaderName = () => {
        const currentLoader = this.getCurrentLoader(loaderContext);
        return currentLoader ? requestShortener.shorten(currentLoader.loader) : "(not in loader scope)";
      }, loaderContext = {
        version: 2,
        emitWarning: warning => {
          warning instanceof Error || (warning = new NonErrorEmittedError(warning)), this.warnings.push(new ModuleWarning(this, warning, {
            from: getCurrentLoaderName()
          }));
        },
        emitError: error => {
          error instanceof Error || (error = new NonErrorEmittedError(error)), this.errors.push(new ModuleError(this, error, {
            from: getCurrentLoaderName()
          }));
        },
        getLogger: name => {
          const currentLoader = this.getCurrentLoader(loaderContext);
          return compilation.getLogger(() => [ currentLoader && currentLoader.loader, name, this.identifier() ].filter(Boolean).join("|"));
        },
        exec: (code, filename) => {
          const module = new NativeModule(filename, this);
          return module.paths = NativeModule._nodeModulePaths(this.context), module.filename = filename, 
          module._compile(code, filename), module.exports;
        },
        resolve(context, request, callback) {
          resolver.resolve({}, context, request, {}, callback);
        },
        getResolve(options) {
          const child = options ? resolver.withOptions(options) : resolver;
          return (context, request, callback) => {
            if (!callback) return new Promise((resolve, reject) => {
              child.resolve({}, context, request, {}, (err, result) => {
                err ? reject(err) : resolve(result);
              });
            });
            child.resolve({}, context, request, {}, callback);
          };
        },
        emitFile: (name, content, sourceMap, assetInfo) => {
          this.buildInfo.assets || (this.buildInfo.assets = Object.create(null), this.buildInfo.assetsInfo = new Map), 
          this.buildInfo.assets[name] = this.createSourceForAsset(name, content, sourceMap), 
          this.buildInfo.assetsInfo.set(name, assetInfo);
        },
        rootContext: options.context,
        webpack: !0,
        sourceMap: !!this.useSourceMap,
        mode: options.mode || "production",
        _module: this,
        _compilation: compilation,
        _compiler: compilation.compiler,
        fs: fs
      };
      return compilation.hooks.normalModuleLoader.call(loaderContext, this), options.loader && Object.assign(loaderContext, options.loader), 
      loaderContext;
    }
    getCurrentLoader(loaderContext, index = loaderContext.loaderIndex) {
      return this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index] ? this.loaders[index] : null;
    }
    createSource(source, resourceBuffer, sourceMap) {
      if (!this.identifier) return new RawSource(source);
      const identifier = this.identifier();
      return this.lineToLine && resourceBuffer ? new LineToLineMappedSource(source, identifier, asString(resourceBuffer)) : this.useSourceMap && sourceMap ? new SourceMapSource(source, identifier, sourceMap) : Buffer.isBuffer(source) ? new RawSource(source) : new OriginalSource(source, identifier);
    }
    doBuild(options, compilation, resolver, fs, callback) {
      const loaderContext = this.createLoaderContext(resolver, options, compilation, fs);
      runLoaders({
        resource: this.resource,
        loaders: this.loaders,
        context: loaderContext,
        readResource: fs.readFile.bind(fs)
      }, (err, result) => {
        if (result && (this.buildInfo.cacheable = result.cacheable, this.buildInfo.fileDependencies = new Set(result.fileDependencies), 
        this.buildInfo.contextDependencies = new Set(result.contextDependencies)), err) {
          err instanceof Error || (err = new NonErrorEmittedError(err));
          const currentLoader = this.getCurrentLoader(loaderContext), error = new ModuleBuildError(this, err, {
            from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)
          });
          return callback(error);
        }
        const resourceBuffer = result.resourceBuffer, source = result.result[0], sourceMap = result.result.length >= 1 ? result.result[1] : null, extraInfo = result.result.length >= 2 ? result.result[2] : null;
        if (!Buffer.isBuffer(source) && "string" != typeof source) {
          const currentLoader = this.getCurrentLoader(loaderContext, 0), err = new Error(`Final loader (${currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader) : "unknown"}) didn't return a Buffer or String`), error = new ModuleBuildError(this, err);
          return callback(error);
        }
        var str;
        return this._source = this.createSource(this.binary ? (str = source, Buffer.isBuffer(str) ? str : Buffer.from(str, "utf-8")) : asString(source), resourceBuffer, sourceMap), 
        this._sourceSize = null, this._ast = "object" == typeof extraInfo && null !== extraInfo && void 0 !== extraInfo.webpackAST ? extraInfo.webpackAST : null, 
        callback();
      });
    }
    markModuleAsErrored(error) {
      this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta), this.error = error, 
      this.errors.push(this.error), this._source = new RawSource("throw new Error(" + JSON.stringify(this.error.message) + ");"), 
      this._sourceSize = null, this._ast = null;
    }
    applyNoParseRule(rule, content) {
      return "string" == typeof rule ? 0 === content.indexOf(rule) : "function" == typeof rule ? rule(content) : rule.test(content);
    }
    shouldPreventParsing(noParseRule, request) {
      if (!noParseRule) return !1;
      if (!Array.isArray(noParseRule)) return this.applyNoParseRule(noParseRule, request);
      for (let i = 0; i < noParseRule.length; i++) {
        const rule = noParseRule[i];
        if (this.applyNoParseRule(rule, request)) return !0;
      }
      return !1;
    }
    _initBuildHash(compilation) {
      const hash = createHash(compilation.outputOptions.hashFunction);
      this._source && (hash.update("source"), this._source.updateHash(hash)), hash.update("meta"), 
      hash.update(JSON.stringify(this.buildMeta)), this._buildHash = hash.digest("hex");
    }
    build(options, compilation, resolver, fs, callback) {
      return this.buildTimestamp = Date.now(), this.built = !0, this._source = null, this._sourceSize = null, 
      this._ast = null, this._buildHash = "", this.error = null, this.errors.length = 0, 
      this.warnings.length = 0, this.buildMeta = {}, this.buildInfo = {
        cacheable: !1,
        fileDependencies: new Set,
        contextDependencies: new Set,
        assets: void 0,
        assetsInfo: void 0
      }, this.doBuild(options, compilation, resolver, fs, err => {
        if (this._cachedSources.clear(), err) return this.markModuleAsErrored(err), this._initBuildHash(compilation), 
        callback();
        const noParseRule = options.module && options.module.noParse;
        if (this.shouldPreventParsing(noParseRule, this.request)) return this._initBuildHash(compilation), 
        callback();
        const handleParseError = e => {
          const source = this._source.source(), loaders = this.loaders.map(item => contextify(options.context, item.loader)), error = new ModuleParseError(this, source, e, loaders);
          return this.markModuleAsErrored(error), this._initBuildHash(compilation), callback();
        }, handleParseResult = result => (this._lastSuccessfulBuildMeta = this.buildMeta, 
        this._initBuildHash(compilation), callback());
        try {
          const result = this.parser.parse(this._ast || this._source.source(), {
            current: this,
            module: this,
            compilation: compilation,
            options: options
          }, (err, result) => {
            err ? handleParseError(err) : handleParseResult();
          });
          void 0 !== result && handleParseResult();
        } catch (e) {
          handleParseError(e);
        }
      });
    }
    getHashDigest(dependencyTemplates) {
      let dtHash = dependencyTemplates.get("hash");
      return `${this.hash}-${dtHash}`;
    }
    source(dependencyTemplates, runtimeTemplate, type = "javascript") {
      const hashDigest = this.getHashDigest(dependencyTemplates), cacheEntry = this._cachedSources.get(type);
      if (void 0 !== cacheEntry && cacheEntry.hash === hashDigest) return cacheEntry.source;
      const source = this.generator.generate(this, dependencyTemplates, runtimeTemplate, type), cachedSource = new CachedSource(source);
      return this._cachedSources.set(type, {
        source: cachedSource,
        hash: hashDigest
      }), cachedSource;
    }
    originalSource() {
      return this._source;
    }
    needRebuild(fileTimestamps, contextTimestamps) {
      if (this.error) return !0;
      if (!this.buildInfo.cacheable) return !0;
      for (const file of this.buildInfo.fileDependencies) {
        const timestamp = fileTimestamps.get(file);
        if (!timestamp) return !0;
        if (timestamp >= this.buildTimestamp) return !0;
      }
      for (const file of this.buildInfo.contextDependencies) {
        const timestamp = contextTimestamps.get(file);
        if (!timestamp) return !0;
        if (timestamp >= this.buildTimestamp) return !0;
      }
      return !1;
    }
    size() {
      return null === this._sourceSize && (this._sourceSize = this._source ? this._source.size() : -1), 
      this._sourceSize;
    }
    updateHash(hash) {
      hash.update(this._buildHash), super.updateHash(hash);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const mergeCache = new WeakMap, cleverMerge = (first, second) => {
    const newObject = Object.assign({}, first);
    for (const key of Object.keys(second)) {
      if (!(key in newObject)) {
        newObject[key] = second[key];
        continue;
      }
      const secondValue = second[key];
      if (!Array.isArray(secondValue)) {
        newObject[key] = secondValue;
        continue;
      }
      const firstValue = newObject[key];
      if (Array.isArray(firstValue)) {
        const newArray = [];
        for (const item of secondValue) if ("..." === item) for (const item of firstValue) newArray.push(item); else newArray.push(item);
        newObject[key] = newArray;
      } else newObject[key] = secondValue;
    }
    return newObject;
  };
  exports.cachedCleverMerge = (first, second) => {
    let innerCache = mergeCache.get(first);
    void 0 === innerCache && (innerCache = new WeakMap, mergeCache.set(first, innerCache));
    const prevMerge = innerCache.get(second);
    if (void 0 !== prevMerge) return prevMerge;
    const newMerge = cleverMerge(first, second);
    return innerCache.set(second, newMerge), newMerge;
  }, exports.cleverMerge = cleverMerge;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  module.exports = class extends ModuleDependency {
    constructor(request, userRequest) {
      super(request), userRequest && (this.userRequest = userRequest);
    }
    get type() {
      return "context element";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(path) {
    var parts = path.split(/(\\+|\/+)/);
    if (1 === parts.length) return path;
    for (var result = [], absolutePathStart = 0, i = 0, sep = !1; i < parts.length; i += 1, 
    sep = !sep) {
      var part = parts[i];
      if (0 === i && /^([A-Z]:)?$/i.test(part)) result.push(part), absolutePathStart = 2; else if (sep) 1 === i && 0 === parts[0].length && "\\\\" === part ? result.push(part) : result.push(part[0]); else if (".." === part) switch (result.length) {
       case 0:
        result.push(part);
        break;

       case 2:
        "." !== result[0] ? (i += 1, sep = !sep, result.length = absolutePathStart) : (result.length = 0, 
        result.push(part));
        break;

       case 4:
        0 === absolutePathStart ? result.length -= 3 : (i += 1, sep = !sep, result.length = 2);
        break;

       default:
        result.length -= 3;
      } else if ("." === part) switch (result.length) {
       case 0:
        result.push(part);
        break;

       case 2:
        0 === absolutePathStart ? result.length -= 1 : (i += 1, sep = !sep);
        break;

       default:
        result.length -= 1;
      } else part && result.push(part);
    }
    return 1 === result.length && /^[A-Za-z]:$/.test(result[0]) ? result[0] + "\\" : result.join("");
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  function startsWith(string, searchString) {
    const stringLength = string.length, searchLength = searchString.length;
    if (searchLength > stringLength) return !1;
    let index = -1;
    for (;++index < searchLength; ) if (string.charCodeAt(index) !== searchString.charCodeAt(index)) return !1;
    return !0;
  }
  module.exports = class {
    constructor(source, options, target) {
      this.source = source, this.options = Array.isArray(options) ? options : [ options ], 
      this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("AliasPlugin", (request, resolveContext, callback) => {
        const innerRequest = request.request || request.path;
        if (!innerRequest) return callback();
        for (const item of this.options) if ((innerRequest === item.name || !item.onlyModule && startsWith(innerRequest, item.name + "/")) && innerRequest !== item.alias && !startsWith(innerRequest, item.alias + "/")) {
          const newRequestStr = item.alias + innerRequest.substr(item.name.length), obj = Object.assign({}, request, {
            request: newRequestStr
          });
          return resolver.doResolve(target, obj, "aliased with mapping '" + item.name + "': '" + item.alias + "' to '" + newRequestStr + "'", resolveContext, (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
        }
        return callback();
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const globToRegExp = __webpack_require__(240).globToRegExp;
  function parseType(type) {
    const items = type.split("+"), t = items.shift();
    return {
      type: "*" === t ? null : t,
      features: items
    };
  }
  function isTypeMatched(baseType, testedType) {
    return "string" == typeof baseType && (baseType = parseType(baseType)), "string" == typeof testedType && (testedType = parseType(testedType)), 
    (!testedType.type || testedType.type === baseType.type) && testedType.features.every(requiredFeature => baseType.features.indexOf(requiredFeature) >= 0);
  }
  function isResourceTypeSupported(context, type) {
    return context.supportedResourceTypes && context.supportedResourceTypes.some(supportedType => function(baseType, testedType) {
      if (baseType = baseType.split("/"), testedType = testedType.split("/"), baseType.length !== testedType.length) return !1;
      for (let i = 0; i < baseType.length; i++) if (!isTypeMatched(baseType[i], testedType[i])) return !1;
      return !0;
    }(supportedType, type));
  }
  function isEnvironment(context, env) {
    return context.environments && context.environments.every(environment => isTypeMatched(environment, env));
  }
  const globCache = {};
  function getGlobRegExp(glob) {
    return globCache[glob] || (globCache[glob] = globToRegExp(glob));
  }
  function matchGlob(glob, relativePath) {
    return getGlobRegExp(glob).exec(relativePath);
  }
  function isGlobMatched(glob, relativePath) {
    return !!matchGlob(glob, relativePath);
  }
  function isConditionMatched(context, condition) {
    return condition.split("|").some((function testFn(item) {
      item = item.trim();
      if (/^!/.test(item)) return !testFn(item.substr(1));
      if (!/^[a-z]+:/.test(item)) return item.indexOf("/") >= 0 ? isResourceTypeSupported(context, item) : isEnvironment(context, item);
      {
        const match = /^([a-z]+):\s*/.exec(item), value = item.substr(match[0].length);
        switch (match[1]) {
         case "referrer":
          return isGlobMatched(value, context.referrer);

         default:
          return !1;
        }
      }
    }));
  }
  function isKeyMatched(context, key) {
    for (;;) {
      const match = /^\[([^\]]+)\]\s*/.exec(key);
      if (!match) return key;
      key = key.substr(match[0].length);
      if (!isConditionMatched(context, match[1])) return !1;
    }
  }
  function getField(context, configuration, field) {
    let value;
    return Object.keys(configuration).forEach(key => {
      isKeyMatched(context, key) === field && (value = configuration[key]);
    }), value;
  }
  exports.parseType = parseType, exports.isTypeMatched = isTypeMatched, exports.isResourceTypeSupported = isResourceTypeSupported, 
  exports.isEnvironment = isEnvironment, exports.isGlobMatched = isGlobMatched, exports.isConditionMatched = isConditionMatched, 
  exports.isKeyMatched = isKeyMatched, exports.getField = getField, exports.getMain = function(context, configuration) {
    return getField(context, configuration, "main");
  }, exports.getExtensions = function(context, configuration) {
    return getField(context, configuration, "extensions");
  }, exports.matchModule = function(context, configuration, request) {
    const modulesField = getField(context, configuration, "modules");
    if (!modulesField) return request;
    let newRequest = request;
    const keys = Object.keys(modulesField);
    let match, index, iteration = 0;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i], pureKey = isKeyMatched(context, key);
      if (match = matchGlob(pureKey, newRequest), match) {
        const value = modulesField[key];
        if ("string" != typeof value) return value;
        if (/^\(.+\)$/.test(pureKey) ? newRequest = newRequest.replace(getGlobRegExp(pureKey), value) : (index = 1, 
        newRequest = value.replace(/(\/?\*)?\*/g, replaceMatcher)), i = -1, iteration++ > keys.length) throw new Error("Request '" + request + "' matches recursively");
      }
    }
    return newRequest;
    function replaceMatcher(find) {
      switch (find) {
       case "/**":
        {
          const m = match[index++];
          return m ? "/" + m : "";
        }

       case "**":
       case "*":
        return match[index++];
      }
    }
  }, exports.matchType = function(context, configuration, relativePath) {
    const typesField = getField(context, configuration, "types");
    if (!typesField) return;
    let type;
    return Object.keys(typesField).forEach(key => {
      if (isGlobMatched(isKeyMatched(context, key), relativePath)) {
        const value = typesField[key];
        if (!type && /\/\*$/.test(value)) throw new Error("value ('" + value + "') of key '" + key + "' contains '*', but there is no previous value defined");
        type = value.replace(/\/\*$/, "/" + type);
      }
    }), type;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NodeWatchFileSystem = __webpack_require__(67), NodeOutputFileSystem = __webpack_require__(68), NodeJsInputFileSystem = __webpack_require__(105), CachedInputFileSystem = __webpack_require__(108), createConsoleLogger = __webpack_require__(266), nodeConsole = __webpack_require__(69);
  module.exports = class {
    constructor(options) {
      this.options = options || {};
    }
    apply(compiler) {
      compiler.infrastructureLogger = createConsoleLogger(Object.assign({
        level: "info",
        debug: !1,
        console: nodeConsole
      }, this.options.infrastructureLogging)), compiler.inputFileSystem = new CachedInputFileSystem(new NodeJsInputFileSystem, 6e4);
      const inputFileSystem = compiler.inputFileSystem;
      compiler.outputFileSystem = new NodeOutputFileSystem, compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem), 
      compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", compiler => {
        compiler.inputFileSystem === inputFileSystem && inputFileSystem.purge();
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Watchpack = __webpack_require__(261), objectToMap = __webpack_require__(265);
  module.exports = class {
    constructor(inputFileSystem) {
      this.inputFileSystem = inputFileSystem, this.watcherOptions = {
        aggregateTimeout: 0
      }, this.watcher = new Watchpack(this.watcherOptions);
    }
    watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
      if (!Array.isArray(files)) throw new Error("Invalid arguments: 'files'");
      if (!Array.isArray(dirs)) throw new Error("Invalid arguments: 'dirs'");
      if (!Array.isArray(missing)) throw new Error("Invalid arguments: 'missing'");
      if ("function" != typeof callback) throw new Error("Invalid arguments: 'callback'");
      if ("number" != typeof startTime && startTime) throw new Error("Invalid arguments: 'startTime'");
      if ("object" != typeof options) throw new Error("Invalid arguments: 'options'");
      if ("function" != typeof callbackUndelayed && callbackUndelayed) throw new Error("Invalid arguments: 'callbackUndelayed'");
      const oldWatcher = this.watcher;
      this.watcher = new Watchpack(options), callbackUndelayed && this.watcher.once("change", callbackUndelayed);
      const cachedFiles = files, cachedDirs = dirs;
      return this.watcher.once("aggregated", (changes, removals) => {
        changes = changes.concat(removals), this.inputFileSystem && this.inputFileSystem.purge && this.inputFileSystem.purge(changes);
        const times = objectToMap(this.watcher.getTimes());
        files = new Set(files), dirs = new Set(dirs), missing = new Set(missing), removals = new Set(removals.filter(file => files.has(file))), 
        callback(null, changes.filter(file => files.has(file)).sort(), changes.filter(file => dirs.has(file)).sort(), changes.filter(file => missing.has(file)).sort(), times, times, removals);
      }), this.watcher.watch(cachedFiles.concat(missing), cachedDirs.concat(missing), startTime), 
      oldWatcher && oldWatcher.close(), {
        close: () => {
          this.watcher && (this.watcher.close(), this.watcher = null);
        },
        pause: () => {
          this.watcher && this.watcher.pause();
        },
        getFileTimestamps: () => this.watcher ? objectToMap(this.watcher.getTimes()) : new Map,
        getContextTimestamps: () => this.watcher ? objectToMap(this.watcher.getTimes()) : new Map
      };
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const fs = __webpack_require__(20), path = __webpack_require__(3), mkdirp = __webpack_require__(113);
  module.exports = class {
    constructor() {
      this.mkdirp = mkdirp, this.mkdir = fs.mkdir.bind(fs), this.rmdir = fs.rmdir.bind(fs), 
      this.unlink = fs.unlink.bind(fs), this.writeFile = fs.writeFile.bind(fs), this.join = path.join.bind(path);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const truncateArgs = __webpack_require__(267), util = __webpack_require__(11), tty = process.stderr.isTTY && "dumb" !== process.env.TERM;
  let currentStatusMessage = void 0, hasStatusMessage = !1, currentIndent = "", currentCollapsed = 0;
  const clearStatusMessage = () => {
    hasStatusMessage && (process.stderr.write("[2K\r"), hasStatusMessage = !1);
  }, writeStatusMessage = () => {
    if (!currentStatusMessage) return;
    const l = process.stderr.columns, coloredStr = `[1m${(l ? truncateArgs(currentStatusMessage, l - 1) : currentStatusMessage).join(" ")}[39m[22m`;
    process.stderr.write("[2K\r" + coloredStr), hasStatusMessage = !0;
  }, writeColored = (prefix, colorPrefix, colorSuffix) => (...args) => {
    if (currentCollapsed > 0) return;
    clearStatusMessage();
    const str = ((str, prefix, colorPrefix, colorSuffix) => "" === str ? str : (prefix = currentIndent + prefix, 
    tty ? prefix + colorPrefix + str.replace(/\n/g, colorSuffix + "\n" + prefix + colorPrefix) + colorSuffix : prefix + str.replace(/\n/g, "\n" + prefix)))(util.format(...args), prefix, colorPrefix, colorSuffix);
    process.stderr.write(str + "\n"), writeStatusMessage();
  }, writeGroupMessage = writeColored("<-> ", "[1m[36m", "[39m[22m"), writeGroupCollapsedMessage = writeColored("<+> ", "[1m[36m", "[39m[22m");
  module.exports = {
    log: writeColored("    ", "[1m", "[22m"),
    debug: writeColored("    ", "", ""),
    trace: writeColored("    ", "", ""),
    info: writeColored("<i> ", "[1m[32m", "[39m[22m"),
    warn: writeColored("<w> ", "[1m[33m", "[39m[22m"),
    error: writeColored("<e> ", "[1m[31m", "[39m[22m"),
    logTime: writeColored("<t> ", "[1m[35m", "[39m[22m"),
    group: (...args) => {
      writeGroupMessage(...args), currentCollapsed > 0 ? currentCollapsed++ : currentIndent += "  ";
    },
    groupCollapsed: (...args) => {
      writeGroupCollapsedMessage(...args), currentCollapsed++;
    },
    groupEnd: () => {
      currentCollapsed > 0 ? currentCollapsed-- : currentIndent.length >= 2 && (currentIndent = currentIndent.slice(0, currentIndent.length - 2));
    },
    profile: console.profile && (name => console.profile(name)),
    profileEnd: console.profileEnd && (name => console.profileEnd(name)),
    clear: tty && console.clear && (() => {
      clearStatusMessage(), console.clear(), writeStatusMessage();
    }),
    status: tty ? (name, ...args) => {
      args = args.filter(Boolean), void 0 === name && 0 === args.length ? (clearStatusMessage(), 
      currentStatusMessage = void 0) : "string" == typeof name && name.startsWith("[webpack.Progress] ") ? (currentStatusMessage = [ name.slice(19), ...args ], 
      writeStatusMessage()) : "[webpack.Progress]" === name ? (currentStatusMessage = [ ...args ], 
      writeStatusMessage()) : (currentStatusMessage = [ name, ...args ], writeStatusMessage());
    } : writeColored("<s> ", "", "")
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor() {
      this.type = 0, this.range = null, this.falsy = !1, this.truthy = !1, this.bool = null, 
      this.number = null, this.regExp = null, this.string = null, this.quasis = null, 
      this.parts = null, this.array = null, this.items = null, this.options = null, this.prefix = null, 
      this.postfix = null, this.wrappedInnerExpressions = null, this.expression = null;
    }
    isNull() {
      return 1 === this.type;
    }
    isString() {
      return 2 === this.type;
    }
    isNumber() {
      return 3 === this.type;
    }
    isBoolean() {
      return 4 === this.type;
    }
    isRegExp() {
      return 5 === this.type;
    }
    isConditional() {
      return 6 === this.type;
    }
    isArray() {
      return 7 === this.type;
    }
    isConstArray() {
      return 8 === this.type;
    }
    isIdentifier() {
      return 9 === this.type;
    }
    isWrapped() {
      return 10 === this.type;
    }
    isTemplateString() {
      return 11 === this.type;
    }
    isTruthy() {
      return this.truthy;
    }
    isFalsy() {
      return this.falsy;
    }
    asBool() {
      if (this.truthy) return !0;
      if (this.falsy) return !1;
      if (this.isBoolean()) return this.bool;
      if (this.isNull()) return !1;
      if (this.isString()) return "" !== this.string;
      if (this.isNumber()) return 0 !== this.number;
      if (this.isRegExp()) return !0;
      if (this.isArray()) return !0;
      if (this.isConstArray()) return !0;
      if (this.isWrapped()) return !!(this.prefix && this.prefix.asBool() || this.postfix && this.postfix.asBool()) || void 0;
      if (this.isTemplateString()) {
        const str = this.asString();
        if ("string" == typeof str) return "" !== str;
      }
    }
    asString() {
      if (this.isBoolean()) return "" + this.bool;
      if (this.isNull()) return "null";
      if (this.isString()) return this.string;
      if (this.isNumber()) return "" + this.number;
      if (this.isRegExp()) return "" + this.regExp;
      if (this.isArray()) {
        let array = [];
        for (const item of this.items) {
          const itemStr = item.asString();
          if (void 0 === itemStr) return;
          array.push(itemStr);
        }
        return "" + array;
      }
      if (this.isConstArray()) return "" + this.array;
      if (this.isTemplateString()) {
        let str = "";
        for (const part of this.parts) {
          const partStr = part.asString();
          if (void 0 === partStr) return;
          str += partStr;
        }
        return str;
      }
    }
    setString(string) {
      return this.type = 2, this.string = string, this;
    }
    setNull() {
      return this.type = 1, this;
    }
    setNumber(number) {
      return this.type = 3, this.number = number, this;
    }
    setBoolean(bool) {
      return this.type = 4, this.bool = bool, this;
    }
    setRegExp(regExp) {
      return this.type = 5, this.regExp = regExp, this;
    }
    setIdentifier(identifier) {
      return this.type = 9, this.identifier = identifier, this;
    }
    setWrapped(prefix, postfix, innerExpressions) {
      return this.type = 10, this.prefix = prefix, this.postfix = postfix, this.wrappedInnerExpressions = innerExpressions, 
      this;
    }
    setOptions(options) {
      return this.type = 6, this.options = options, this;
    }
    addOptions(options) {
      this.options || (this.type = 6, this.options = []);
      for (const item of options) this.options.push(item);
      return this;
    }
    setItems(items) {
      return this.type = 7, this.items = items, this;
    }
    setArray(array) {
      return this.type = 8, this.array = array, this;
    }
    setTemplateString(quasis, parts, kind) {
      return this.type = 11, this.quasis = quasis, this.parts = parts, this.templateStringKind = kind, 
      this;
    }
    setTruthy() {
      return this.falsy = !1, this.truthy = !0, this;
    }
    setFalsy() {
      return this.falsy = !0, this.truthy = !1, this;
    }
    setRange(range) {
      return this.range = range, this;
    }
    setExpression(expression) {
      return this.expression = expression, this;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  class Generator {
    static byType(map) {
      return new ByTypeGenerator(map);
    }
    generate(module, dependencyTemplates, runtimeTemplate, type) {
      throw new Error("Generator.generate: must be overridden");
    }
  }
  class ByTypeGenerator extends Generator {
    constructor(map) {
      super(), this.map = map;
    }
    generate(module, dependencyTemplates, runtimeTemplate, type) {
      const generator = this.map[type];
      if (!generator) throw new Error("Generator.byType: no generator specified for " + type);
      return generator.generate(module, dependencyTemplates, runtimeTemplate, type);
    }
  }
  module.exports = Generator;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), {ConcatSource: ConcatSource, RawSource: RawSource} = __webpack_require__(0), ModuleFilenameHelpers = __webpack_require__(21), SourceMapDevToolModuleOptionsPlugin = __webpack_require__(123), createHash = __webpack_require__(17), {absolutify: absolutify} = __webpack_require__(14), validateOptions = __webpack_require__(8), schema = __webpack_require__(286), assetsCache = new WeakMap;
  module.exports = class {
    constructor(options) {
      if (arguments.length > 1) throw new Error("SourceMapDevToolPlugin only takes one argument (pass an options object)");
      options || (options = {}), validateOptions(schema, options, "SourceMap DevTool Plugin"), 
      this.sourceMapFilename = options.filename, this.sourceMappingURLComment = !1 !== options.append && (options.append || "\n//# sourceMappingURL=[url]"), 
      this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]", 
      this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack://[namespace]/[resourcePath]?[hash]", 
      this.namespace = options.namespace || "", this.options = options;
    }
    apply(compiler) {
      const sourceMapFilename = this.sourceMapFilename, sourceMappingURLComment = this.sourceMappingURLComment, moduleFilenameTemplate = this.moduleFilenameTemplate, namespace = this.namespace, fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate, requestShortener = compiler.requestShortener, options = this.options;
      options.test = options.test || /\.(m?js|css)($|\?)/i;
      const matchObject = ModuleFilenameHelpers.matchObject.bind(void 0, options);
      compiler.hooks.compilation.tap("SourceMapDevToolPlugin", compilation => {
        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation), compilation.hooks.afterOptimizeChunkAssets.tap({
          name: "SourceMapDevToolPlugin",
          context: !0
        }, (context, chunks) => {
          const moduleToSourceNameMapping = new Map, reportProgress = context && context.reportProgress ? context.reportProgress : () => {}, files = [];
          for (const chunk of chunks) for (const file of chunk.files) matchObject(file) && files.push({
            file: file,
            chunk: chunk
          });
          reportProgress(0);
          const tasks = [];
          files.forEach(({file: file, chunk: chunk}, idx) => {
            const asset = compilation.getAsset(file).source, cache = assetsCache.get(asset);
            if (cache && cache.file === file) {
              for (const cachedFile in cache.assets) cachedFile === file ? compilation.updateAsset(cachedFile, cache.assets[cachedFile]) : compilation.emitAsset(cachedFile, cache.assets[cachedFile], {
                development: !0
              }), cachedFile !== file && chunk.files.push(cachedFile);
              return;
            }
            reportProgress(.5 * idx / files.length, file, "generate SourceMap");
            const task = ((file, asset, chunk, options, compilation) => {
              let source, sourceMap;
              if (asset.sourceAndMap) {
                const sourceAndMap = asset.sourceAndMap(options);
                sourceMap = sourceAndMap.map, source = sourceAndMap.source;
              } else sourceMap = asset.map(options), source = asset.source();
              if (!sourceMap || "string" != typeof source) return;
              const context = compilation.options.context, modules = sourceMap.sources.map(source => {
                source.startsWith("webpack://") && (source = absolutify(context, source.slice(10)));
                return compilation.findModule(source) || source;
              });
              return {
                chunk: chunk,
                file: file,
                asset: asset,
                source: source,
                sourceMap: sourceMap,
                modules: modules
              };
            })(file, asset, chunk, options, compilation);
            if (task) {
              const modules = task.modules;
              for (let idx = 0; idx < modules.length; idx++) {
                const module = modules[idx];
                moduleToSourceNameMapping.get(module) || moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {
                  moduleFilenameTemplate: moduleFilenameTemplate,
                  namespace: namespace
                }, requestShortener));
              }
              tasks.push(task);
            }
          }), reportProgress(.5, "resolve sources");
          const usedNamesSet = new Set(moduleToSourceNameMapping.values()), conflictDetectionSet = new Set, allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {
            const ai = "string" == typeof a ? a : a.identifier(), bi = "string" == typeof b ? b : b.identifier();
            return ai.length - bi.length;
          });
          for (let idx = 0; idx < allModules.length; idx++) {
            const module = allModules[idx];
            let sourceName = moduleToSourceNameMapping.get(module), hasName = conflictDetectionSet.has(sourceName);
            if (hasName) if (sourceName = ModuleFilenameHelpers.createFilename(module, {
              moduleFilenameTemplate: fallbackModuleFilenameTemplate,
              namespace: namespace
            }, requestShortener), hasName = usedNamesSet.has(sourceName), hasName) {
              for (;hasName; ) sourceName += "*", hasName = usedNamesSet.has(sourceName);
              moduleToSourceNameMapping.set(module, sourceName), usedNamesSet.add(sourceName);
            } else moduleToSourceNameMapping.set(module, sourceName), usedNamesSet.add(sourceName); else conflictDetectionSet.add(sourceName);
          }
          tasks.forEach((task, index) => {
            reportProgress(.5 + .5 * index / tasks.length, task.file, "attach SourceMap");
            const assets = Object.create(null), chunk = task.chunk, file = task.file, asset = task.asset, sourceMap = task.sourceMap, source = task.source, moduleFilenames = task.modules.map(m => moduleToSourceNameMapping.get(m));
            sourceMap.sources = moduleFilenames, options.noSources && (sourceMap.sourcesContent = void 0), 
            sourceMap.sourceRoot = options.sourceRoot || "", sourceMap.file = file, assetsCache.set(asset, {
              file: file,
              assets: assets
            });
            let currentSourceMappingURLComment = sourceMappingURLComment;
            !1 !== currentSourceMappingURLComment && /\.css($|\?)/i.test(file) && (currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\n\/\/(.*)$/, "\n/*$1*/"));
            const sourceMapString = JSON.stringify(sourceMap);
            if (sourceMapFilename) {
              let filename = file, query = "";
              const idx = filename.indexOf("?");
              idx >= 0 && (query = filename.substr(idx), filename = filename.substr(0, idx));
              const pathParams = {
                chunk: chunk,
                filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,
                query: query,
                basename: (name = filename, name.includes("/") ? name.substr(name.lastIndexOf("/") + 1) : name),
                contentHash: createHash("md4").update(sourceMapString).digest("hex")
              };
              let sourceMapFile = compilation.getPath(sourceMapFilename, pathParams);
              const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\/g, "/") : path.relative(path.dirname(file), sourceMapFile).replace(/\\/g, "/");
              if (!1 !== currentSourceMappingURLComment) {
                const asset = new ConcatSource(new RawSource(source), compilation.getPath(currentSourceMappingURLComment, Object.assign({
                  url: sourceMapUrl
                }, pathParams)));
                assets[file] = asset, compilation.updateAsset(file, asset);
              }
              const asset = new RawSource(sourceMapString);
              assets[sourceMapFile] = asset, compilation.emitAsset(sourceMapFile, asset, {
                development: !0
              }), chunk.files.push(sourceMapFile);
            } else {
              if (!1 === currentSourceMappingURLComment) throw new Error("SourceMapDevToolPlugin: append can't be false when no filename is provided");
              const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\[map\]/g, () => sourceMapString).replace(/\[url\]/g, () => "data:application/json;charset=utf-8;base64," + Buffer.from(sourceMapString, "utf-8").toString("base64")));
              assets[file] = asset, compilation.updateAsset(file, asset);
            }
            var name;
          }), reportProgress(1);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const SingleEntryDependency = __webpack_require__(31);
  class SingleEntryPlugin {
    constructor(context, entry, name) {
      this.context = context, this.entry = entry, this.name = name;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("SingleEntryPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
      }), compiler.hooks.make.tapAsync("SingleEntryPlugin", (compilation, callback) => {
        const {entry: entry, name: name, context: context} = this, dep = SingleEntryPlugin.createDependency(entry, name);
        compilation.addEntry(context, dep, name, callback);
      });
    }
    static createDependency(entry, name) {
      const dep = new SingleEntryDependency(entry);
      return dep.loc = {
        name: name
      }, dep;
    }
  }
  module.exports = SingleEntryPlugin;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(module, message, loc) {
      super(message), this.name = "UnsupportedFeatureWarning", this.module = module, this.loc = loc, 
      this.hideStack = !0, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(dep, source, runtime) {
      const moduleExports = runtime.moduleExports({
        module: dep.module,
        request: dep.request
      });
      if (dep.module) if (dep.valueRange) {
        if (Array.isArray(dep.replaces)) for (let i = 0; i < dep.replaces.length; i++) {
          const rep = dep.replaces[i];
          source.replace(rep.range[0], rep.range[1] - 1, rep.value);
        }
        source.replace(dep.valueRange[1], dep.range[1] - 1, ")"), source.replace(dep.range[0], dep.valueRange[0] - 1, `${moduleExports}(${"string" == typeof dep.prepend ? JSON.stringify(dep.prepend) : ""}`);
      } else source.replace(dep.range[0], dep.range[1] - 1, moduleExports); else source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const LocalModule = __webpack_require__(307), LocalModulesHelpers = exports;
  LocalModulesHelpers.addLocalModule = (state, name) => {
    state.localModules || (state.localModules = []);
    const m = new LocalModule(state.module, name, state.localModules.length);
    return state.localModules.push(m), m;
  }, LocalModulesHelpers.getLocalModule = (state, name, namedModule) => {
    if (!state.localModules) return null;
    namedModule && (name = ((parent, mod) => {
      if ("." !== mod.charAt(0)) return mod;
      var path = parent.split("/"), segs = mod.split("/");
      path.pop();
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        ".." === seg ? path.pop() : "." !== seg && path.push(seg);
      }
      return path.join("/");
    })(namedModule, name));
    for (let i = 0; i < state.localModules.length; i++) if (state.localModules[i].name === name) return state.localModules[i];
    return null;
  }, module.exports = LocalModulesHelpers;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class HarmonyExportExpressionDependency extends NullDependency {
    constructor(originModule, range, rangeStatement, prefix) {
      super(), this.originModule = originModule, this.range = range, this.rangeStatement = rangeStatement, 
      this.prefix = prefix;
    }
    get type() {
      return "harmony export expression";
    }
    getExports() {
      return {
        exports: [ "default" ],
        dependencies: void 0
      };
    }
  }
  HarmonyExportExpressionDependency.Template = class {
    apply(dep, source) {
      const used = dep.originModule.isUsed("default"), content = this.getContent(dep.originModule, used);
      if (dep.range) return source.replace(dep.rangeStatement[0], dep.range[0] - 1, content + "(" + dep.prefix), 
      void source.replace(dep.range[1], dep.rangeStatement[1] - 1, ");");
      source.replace(dep.rangeStatement[0], dep.rangeStatement[1] - 1, content);
    }
    getContent(module, used) {
      const exportsName = module.exportsArgument;
      return used ? `/* harmony default export */ ${exportsName}[${JSON.stringify(used)}] = ` : "/* unused harmony default export */ var _unused_webpack_default_export = ";
    }
  }, module.exports = HarmonyExportExpressionDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class HarmonyExportSpecifierDependency extends NullDependency {
    constructor(originModule, id, name) {
      super(), this.originModule = originModule, this.id = id, this.name = name;
    }
    get type() {
      return "harmony export specifier";
    }
    getExports() {
      return {
        exports: [ this.name ],
        dependencies: void 0
      };
    }
  }
  HarmonyExportSpecifierDependency.Template = class {
    apply(dep, source) {}
    getHarmonyInitOrder(dep) {
      return 0;
    }
    harmonyInit(dep, source, runtime) {
      const content = this.getContent(dep);
      source.insert(-1, content);
    }
    getContent(dep) {
      const used = dep.originModule.isUsed(dep.name);
      if (!used) return `/* unused harmony export ${dep.name || "namespace"} */\n`;
      return `/* harmony export (binding) */ __webpack_require__.d(${dep.originModule.exportsArgument}, ${JSON.stringify(used)}, function() { return ${dep.id}; });\n`;
    }
  }, module.exports = HarmonyExportSpecifierDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2);
  module.exports = class {
    constructor(asyncChunkLoading) {
      this.asyncChunkLoading = asyncChunkLoading;
    }
    apply(mainTemplate) {
      const needChunkOnDemandLoadingCode = chunk => {
        for (const chunkGroup of chunk.groupsIterable) if (chunkGroup.getNumberOfChildren() > 0) return !0;
        return !1;
      }, asyncChunkLoading = this.asyncChunkLoading;
      mainTemplate.hooks.localVars.tap("NodeMainTemplatePlugin", (source, chunk) => needChunkOnDemandLoadingCode(chunk) ? Template.asString([ source, "", "// object to store loaded chunks", '// "0" means "already loaded"', "var installedChunks = {", Template.indent(chunk.ids.map(id => JSON.stringify(id) + ": 0").join(",\n")), "};" ]) : source), 
      mainTemplate.hooks.requireExtensions.tap("NodeMainTemplatePlugin", (source, chunk) => needChunkOnDemandLoadingCode(chunk) ? Template.asString([ source, "", "// uncaught error handler for webpack runtime", mainTemplate.requireFn + ".oe = function(err) {", Template.indent([ "process.nextTick(function() {", Template.indent("throw err; // catch this error by using import().catch()"), "});" ]), "};" ]) : source), 
      mainTemplate.hooks.requireEnsure.tap("NodeMainTemplatePlugin", (source, chunk, hash) => {
        const chunkFilename = mainTemplate.outputOptions.chunkFilename, chunkMaps = chunk.getChunkMaps(), insertMoreModules = [ "var moreModules = chunk.modules, chunkIds = chunk.ids;", "for(var moduleId in moreModules) {", Template.indent(mainTemplate.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")), "}" ];
        if (asyncChunkLoading) return Template.asString([ source, "", "// ReadFile + VM.run chunk loading for javascript", "", "var installedChunkData = installedChunks[chunkId];", 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent([ '// array of [resolve, reject, promise] means "currently loading"', "if(installedChunkData) {", Template.indent([ "promises.push(installedChunkData[2]);" ]), "} else {", Template.indent([ "// load the chunk and return promise to it", "var promise = new Promise(function(resolve, reject) {", Template.indent([ "installedChunkData = installedChunks[chunkId] = [resolve, reject];", "var filename = require('path').join(__dirname, " + mainTemplate.getAssetPath(JSON.stringify("/" + chunkFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          chunk: {
            id: '" + chunkId + "',
            hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
            hashWithLength: length => {
              const shortChunkHashMap = {};
              for (const chunkId of Object.keys(chunkMaps.hash)) "string" == typeof chunkMaps.hash[chunkId] && (shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length));
              return `" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + "`;
            },
            contentHash: {
              javascript: `" + ${JSON.stringify(chunkMaps.contentHash.javascript)}[chunkId] + "`
            },
            contentHashWithLength: {
              javascript: length => {
                const shortContentHashMap = {}, contentHash = chunkMaps.contentHash.javascript;
                for (const chunkId of Object.keys(contentHash)) "string" == typeof contentHash[chunkId] && (shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length));
                return `" + ${JSON.stringify(shortContentHashMap)}[chunkId] + "`;
              }
            },
            name: `" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + "`
          },
          contentHashType: "javascript"
        }) + ");", "require('fs').readFile(filename, 'utf-8',  function(err, content) {", Template.indent([ "if(err) return reject(err);", "var chunk = {};", "require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)(chunk, require, require('path').dirname(filename), filename);" ].concat(insertMoreModules).concat([ "var callbacks = [];", "for(var i = 0; i < chunkIds.length; i++) {", Template.indent([ "if(installedChunks[chunkIds[i]])", Template.indent([ "callbacks = callbacks.concat(installedChunks[chunkIds[i]][0]);" ]), "installedChunks[chunkIds[i]] = 0;" ]), "}", "for(i = 0; i < callbacks.length; i++)", Template.indent("callbacks[i]();") ])), "});" ]), "});", "promises.push(installedChunkData[2] = promise);" ]), "}" ]), "}" ]);
        {
          const request = mainTemplate.getAssetPath(JSON.stringify("./" + chunkFilename), {
            hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
            hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
            chunk: {
              id: '" + chunkId + "',
              hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
              hashWithLength: length => {
                const shortChunkHashMap = {};
                for (const chunkId of Object.keys(chunkMaps.hash)) "string" == typeof chunkMaps.hash[chunkId] && (shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length));
                return `" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + "`;
              },
              contentHash: {
                javascript: `" + ${JSON.stringify(chunkMaps.contentHash.javascript)}[chunkId] + "`
              },
              contentHashWithLength: {
                javascript: length => {
                  const shortContentHashMap = {}, contentHash = chunkMaps.contentHash.javascript;
                  for (const chunkId of Object.keys(contentHash)) "string" == typeof contentHash[chunkId] && (shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length));
                  return `" + ${JSON.stringify(shortContentHashMap)}[chunkId] + "`;
                }
              },
              name: `" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + "`
            },
            contentHashType: "javascript"
          });
          return Template.asString([ source, "", "// require() chunk loading for javascript", "", '// "0" is the signal for "already loaded"', "if(installedChunks[chunkId] !== 0) {", Template.indent([ `var chunk = require(${request});` ].concat(insertMoreModules).concat([ "for(var i = 0; i < chunkIds.length; i++)", Template.indent("installedChunks[chunkIds[i]] = 0;") ])), "}" ]);
        }
      }), mainTemplate.hooks.hotBootstrap.tap("NodeMainTemplatePlugin", (source, chunk, hash) => {
        const hotUpdateChunkFilename = mainTemplate.outputOptions.hotUpdateChunkFilename, hotUpdateMainFilename = mainTemplate.outputOptions.hotUpdateMainFilename, chunkMaps = chunk.getChunkMaps(), currentHotUpdateChunkFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateChunkFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          chunk: {
            id: '" + chunkId + "',
            hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
            hashWithLength: length => {
              const shortChunkHashMap = {};
              for (const chunkId of Object.keys(chunkMaps.hash)) "string" == typeof chunkMaps.hash[chunkId] && (shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length));
              return `" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + "`;
            },
            name: `" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + "`
          }
        }), currentHotUpdateMainFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateMainFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
        });
        return Template.getFunctionContent(__webpack_require__(asyncChunkLoading ? 80 : 81)).replace(/\$require\$/g, mainTemplate.requireFn).replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename).replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename);
      }), mainTemplate.hooks.hash.tap("NodeMainTemplatePlugin", hash => {
        hash.update("node"), hash.update("4");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  module.exports = function() {};
}, function(module, exports, __webpack_require__) {
  module.exports = function() {};
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    apply(chunkTemplate) {
      chunkTemplate.hooks.render.tap("NodeChunkTemplatePlugin", (modules, chunk) => {
        const source = new ConcatSource;
        return source.add(`exports.ids = ${JSON.stringify(chunk.ids)};\nexports.modules = `), 
        source.add(modules), source.add(";"), source;
      }), chunkTemplate.hooks.hash.tap("NodeChunkTemplatePlugin", hash => {
        hash.update("node"), hash.update("3");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    apply(hotUpdateChunkTemplate) {
      hotUpdateChunkTemplate.hooks.render.tap("NodeHotUpdateChunkTemplatePlugin", (modulesSource, modules, removedModules, hash, id) => {
        const source = new ConcatSource;
        return source.add("exports.id = " + JSON.stringify(id) + ";\nexports.modules = "), 
        source.add(modulesSource), source.add(";"), source;
      }), hotUpdateChunkTemplate.hooks.hash.tap("NodeHotUpdateChunkTemplatePlugin", hash => {
        hash.update("NodeHotUpdateChunkTemplatePlugin"), hash.update("3"), hash.update(hotUpdateChunkTemplate.outputOptions.hotUpdateFunction + ""), 
        hash.update(hotUpdateChunkTemplate.outputOptions.library + "");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4), ModuleDependencyTemplateAsRequireId = __webpack_require__(144);
  class AMDRequireItemDependency extends ModuleDependency {
    constructor(request, range) {
      super(request), this.range = range;
    }
    get type() {
      return "amd require";
    }
  }
  AMDRequireItemDependency.Template = ModuleDependencyTemplateAsRequireId, module.exports = AMDRequireItemDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Dependency = __webpack_require__(19);
  class AMDRequireArrayDependency extends Dependency {
    constructor(depsArray, range) {
      super(), this.depsArray = depsArray, this.range = range;
    }
    get type() {
      return "amd require array";
    }
  }
  AMDRequireArrayDependency.Template = class {
    apply(dep, source, runtime) {
      const content = this.getContent(dep, runtime);
      source.replace(dep.range[0], dep.range[1] - 1, content);
    }
    getContent(dep, runtime) {
      return `[${dep.depsArray.map(dependency => this.contentForDependency(dependency, runtime)).join(", ")}]`;
    }
    contentForDependency(dep, runtime) {
      return "string" == typeof dep ? dep : dep.localModule ? dep.localModule.variableName() : runtime.moduleExports({
        module: dep.module,
        request: dep.request
      });
    }
  }, module.exports = AMDRequireArrayDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ContextDependency = __webpack_require__(32);
  class AMDRequireContextDependency extends ContextDependency {
    constructor(options, range, valueRange) {
      super(options), this.range = range, this.valueRange = valueRange;
    }
    get type() {
      return "amd require context";
    }
  }
  AMDRequireContextDependency.Template = __webpack_require__(75), module.exports = AMDRequireContextDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  class Reference {
    constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
      this.identifier = ident, this.from = scope, this.tainted = !1, this.resolved = null, 
      this.flag = flag, this.isWrite() && (this.writeExpr = writeExpr, this.partial = partial, 
      this.init = init), this.__maybeImplicitGlobal = maybeImplicitGlobal;
    }
    isStatic() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }
    isWrite() {
      return !!(this.flag & Reference.WRITE);
    }
    isRead() {
      return !!(this.flag & Reference.READ);
    }
    isReadOnly() {
      return this.flag === Reference.READ;
    }
    isWriteOnly() {
      return this.flag === Reference.WRITE;
    }
    isReadWrite() {
      return this.flag === Reference.RW;
    }
  }
  Reference.READ = 1, Reference.WRITE = 2, Reference.RW = 3, module.exports = Reference;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5), BasicEvaluatedExpression = __webpack_require__(70), ParserHelpers = __webpack_require__(9), NullFactory = __webpack_require__(10);
  class RuntimeValue {
    constructor(fn, fileDependencies) {
      this.fn = fn, this.fileDependencies = fileDependencies || [];
    }
    exec(parser) {
      if (!0 === this.fileDependencies) parser.state.module.buildInfo.cacheable = !1; else for (const fileDependency of this.fileDependencies) parser.state.module.buildInfo.fileDependencies.add(fileDependency);
      return this.fn({
        module: parser.state.module
      });
    }
  }
  const stringifyObj = (obj, parser) => "Object({" + Object.keys(obj).map(key => {
    const code = obj[key];
    return JSON.stringify(key) + ":" + toCode(code, parser);
  }).join(",") + "})", toCode = (code, parser) => null === code ? "null" : void 0 === code ? "undefined" : code instanceof RuntimeValue ? toCode(code.exec(parser), parser) : code instanceof RegExp && code.toString ? code.toString() : "function" == typeof code && code.toString ? "(" + code.toString() + ")" : "object" == typeof code ? stringifyObj(code, parser) : code + "";
  module.exports = class {
    constructor(definitions) {
      this.definitions = definitions;
    }
    static runtimeValue(fn, fileDependencies) {
      return new RuntimeValue(fn, fileDependencies);
    }
    apply(compiler) {
      const definitions = this.definitions;
      compiler.hooks.compilation.tap("DefinePlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const handler = parser => {
          const walkDefinitions = (definitions, prefix) => {
            Object.keys(definitions).forEach(key => {
              const code = definitions[key];
              if (code && "object" == typeof code && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) return walkDefinitions(code, prefix + key + "."), 
              void applyObjectDefine(prefix + key, code);
              applyDefineKey(prefix, key), applyDefine(prefix + key, code);
            });
          }, applyDefineKey = (prefix, key) => {
            const splittedKey = key.split(".");
            splittedKey.slice(1).forEach((_, i) => {
              const fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
              parser.hooks.canRename.for(fullKey).tap("DefinePlugin", ParserHelpers.approve);
            });
          }, applyDefine = (key, code) => {
            const isTypeof = /^typeof\s+/.test(key);
            isTypeof && (key = key.replace(/^typeof\s+/, ""));
            let recurse = !1, recurseTypeof = !1;
            isTypeof || (parser.hooks.canRename.for(key).tap("DefinePlugin", ParserHelpers.approve), 
            parser.hooks.evaluateIdentifier.for(key).tap("DefinePlugin", expr => {
              if (recurse) return;
              recurse = !0;
              const res = parser.evaluate(toCode(code, parser));
              return recurse = !1, res.setRange(expr.range), res;
            }), parser.hooks.expression.for(key).tap("DefinePlugin", expr => {
              const strCode = toCode(code, parser);
              return /__webpack_require__/.test(strCode) ? ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr) : ParserHelpers.toConstantDependency(parser, strCode)(expr);
            })), parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", expr => {
              if (recurseTypeof) return;
              recurseTypeof = !0;
              const typeofCode = isTypeof ? toCode(code, parser) : "typeof (" + toCode(code, parser) + ")", res = parser.evaluate(typeofCode);
              return recurseTypeof = !1, res.setRange(expr.range), res;
            }), parser.hooks.typeof.for(key).tap("DefinePlugin", expr => {
              const typeofCode = isTypeof ? toCode(code, parser) : "typeof (" + toCode(code, parser) + ")", res = parser.evaluate(typeofCode);
              if (res.isString()) return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);
            });
          }, applyObjectDefine = (key, obj) => {
            parser.hooks.canRename.for(key).tap("DefinePlugin", ParserHelpers.approve), parser.hooks.evaluateIdentifier.for(key).tap("DefinePlugin", expr => (new BasicEvaluatedExpression).setTruthy().setRange(expr.range)), 
            parser.hooks.evaluateTypeof.for(key).tap("DefinePlugin", expr => ParserHelpers.evaluateToString("object")(expr)), 
            parser.hooks.expression.for(key).tap("DefinePlugin", expr => {
              const strCode = stringifyObj(obj, parser);
              return /__webpack_require__/.test(strCode) ? ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr) : ParserHelpers.toConstantDependency(parser, strCode)(expr);
            }), parser.hooks.typeof.for(key).tap("DefinePlugin", expr => ParserHelpers.toConstantDependency(parser, JSON.stringify("object"))(expr));
          };
          walkDefinitions(definitions, "");
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("DefinePlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("DefinePlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("DefinePlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = {
    metaSchemaRef: function(ajv) {
      var defaultMeta = ajv._opts.defaultMeta;
      return "string" == typeof defaultMeta ? {
        $ref: defaultMeta
      } : ajv.getSchema("http://json-schema.org/draft-07/schema") ? {
        $ref: "http://json-schema.org/draft-07/schema"
      } : (console.warn("meta schema not defined"), {});
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), SyncBailHook = __webpack_require__(91);
  function Tapable() {
    this._pluginCompat = new SyncBailHook([ "options" ]), this._pluginCompat.tap({
      name: "Tapable camelCase",
      stage: 100
    }, options => {
      options.names.add(options.name.replace(/[- ]([a-z])/g, (str, ch) => ch.toUpperCase()));
    }), this._pluginCompat.tap({
      name: "Tapable this.hooks",
      stage: 200
    }, options => {
      let hook;
      for (const name of options.names) if (hook = this.hooks[name], void 0 !== hook) break;
      if (void 0 !== hook) {
        const tapOpt = {
          name: options.fn.name || "unnamed compat plugin",
          stage: options.stage || 0
        };
        return options.async ? hook.tapAsync(tapOpt, options.fn) : hook.tap(tapOpt, options.fn), 
        !0;
      }
    });
  }
  module.exports = Tapable, Tapable.addCompatLayer = function(instance) {
    Tapable.call(instance), instance.plugin = Tapable.prototype.plugin, instance.apply = Tapable.prototype.apply;
  }, Tapable.prototype.plugin = util.deprecate((function(name, fn) {
    if (Array.isArray(name)) return void name.forEach((function(name) {
      this.plugin(name, fn);
    }), this);
    if (!this._pluginCompat.call({
      name: name,
      fn: fn,
      names: new Set([ name ])
    })) throw new Error(`Plugin could not be registered at '${name}'. Hook was not found.\nBREAKING CHANGE: There need to exist a hook at 'this.hooks'. To create a compatibility layer for this hook, hook into 'this._pluginCompat'.`);
  }), "Tapable.plugin is deprecated. Use new API on `.hooks` instead"), Tapable.prototype.apply = util.deprecate((function() {
    for (var i = 0; i < arguments.length; i++) arguments[i].apply(this);
  }), "Tapable.apply is deprecated. Call apply on the plugin directly instead");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onResult: onResult, resultReturns: resultReturns, onDone: onDone, rethrowIfPossible: rethrowIfPossible}) {
      return this.callTapsSeries({
        onError: (i, err) => onError(err),
        onResult: (i, result, next) => `if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
        resultReturns: resultReturns,
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  };
  module.exports = class extends Hook {
    tapAsync() {
      throw new Error("tapAsync is not supported on a SyncBailHook");
    }
    tapPromise() {
      throw new Error("tapPromise is not supported on a SyncBailHook");
    }
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onDone: onDone, rethrowIfPossible: rethrowIfPossible}) {
      return this.callTapsSeries({
        onError: (i, err) => onError(err),
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  };
  module.exports = class extends Hook {
    tapAsync() {
      throw new Error("tapAsync is not supported on a SyncHook");
    }
    tapPromise() {
      throw new Error("tapPromise is not supported on a SyncHook");
    }
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onDone: onDone}) {
      return this.callTapsSeries({
        onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
        onDone: onDone
      });
    }
  };
  class AsyncSeriesHook extends Hook {
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  }
  Object.defineProperties(AsyncSeriesHook.prototype, {
    _call: {
      value: void 0,
      configurable: !0,
      writable: !0
    }
  }), module.exports = AsyncSeriesHook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onResult: onResult, resultReturns: resultReturns, onDone: onDone}) {
      return this.callTapsSeries({
        onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
        onResult: (i, result, next) => `if(${result} !== undefined) {\n${onResult(result)};\n} else {\n${next()}}\n`,
        resultReturns: resultReturns,
        onDone: onDone
      });
    }
  };
  class AsyncSeriesBailHook extends Hook {
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  }
  Object.defineProperties(AsyncSeriesBailHook.prototype, {
    _call: {
      value: void 0,
      configurable: !0,
      writable: !0
    }
  }), module.exports = AsyncSeriesBailHook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const SortableSet = __webpack_require__(23), compareLocations = __webpack_require__(36);
  let debugId = 5e3;
  const getArray = set => Array.from(set), sortById = (a, b) => a.id < b.id ? -1 : b.id < a.id ? 1 : 0, sortOrigin = (a, b) => {
    const aIdent = a.module ? a.module.identifier() : "", bIdent = b.module ? b.module.identifier() : "";
    return aIdent < bIdent ? -1 : aIdent > bIdent ? 1 : compareLocations(a.loc, b.loc);
  };
  module.exports = class {
    constructor(options) {
      "string" == typeof options ? options = {
        name: options
      } : options || (options = {
        name: void 0
      }), this.groupDebugId = debugId++, this.options = options, this._children = new SortableSet(void 0, sortById), 
      this._parents = new SortableSet(void 0, sortById), this._blocks = new SortableSet, 
      this.chunks = [], this.origins = [], this._moduleIndices = new Map, this._moduleIndices2 = new Map;
    }
    addOptions(options) {
      for (const key of Object.keys(options)) if (void 0 === this.options[key]) this.options[key] = options[key]; else if (this.options[key] !== options[key]) {
        if (!key.endsWith("Order")) throw new Error("ChunkGroup.addOptions: No option merge strategy for " + key);
        this.options[key] = Math.max(this.options[key], options[key]);
      }
    }
    get name() {
      return this.options.name;
    }
    set name(value) {
      this.options.name = value;
    }
    get debugId() {
      return Array.from(this.chunks, x => x.debugId).join("+");
    }
    get id() {
      return Array.from(this.chunks, x => x.id).join("+");
    }
    unshiftChunk(chunk) {
      const oldIdx = this.chunks.indexOf(chunk);
      if (oldIdx > 0) this.chunks.splice(oldIdx, 1), this.chunks.unshift(chunk); else if (oldIdx < 0) return this.chunks.unshift(chunk), 
      !0;
      return !1;
    }
    insertChunk(chunk, before) {
      const oldIdx = this.chunks.indexOf(chunk), idx = this.chunks.indexOf(before);
      if (idx < 0) throw new Error("before chunk not found");
      if (oldIdx >= 0 && oldIdx > idx) this.chunks.splice(oldIdx, 1), this.chunks.splice(idx, 0, chunk); else if (oldIdx < 0) return this.chunks.splice(idx, 0, chunk), 
      !0;
      return !1;
    }
    pushChunk(chunk) {
      return !(this.chunks.indexOf(chunk) >= 0) && (this.chunks.push(chunk), !0);
    }
    replaceChunk(oldChunk, newChunk) {
      const oldIdx = this.chunks.indexOf(oldChunk);
      if (oldIdx < 0) return !1;
      const newIdx = this.chunks.indexOf(newChunk);
      return newIdx < 0 ? (this.chunks[oldIdx] = newChunk, !0) : newIdx < oldIdx ? (this.chunks.splice(oldIdx, 1), 
      !0) : newIdx !== oldIdx ? (this.chunks[oldIdx] = newChunk, this.chunks.splice(newIdx, 1), 
      !0) : void 0;
    }
    removeChunk(chunk) {
      const idx = this.chunks.indexOf(chunk);
      return idx >= 0 && (this.chunks.splice(idx, 1), !0);
    }
    isInitial() {
      return !1;
    }
    addChild(chunk) {
      return !this._children.has(chunk) && (this._children.add(chunk), !0);
    }
    getChildren() {
      return this._children.getFromCache(getArray);
    }
    getNumberOfChildren() {
      return this._children.size;
    }
    get childrenIterable() {
      return this._children;
    }
    removeChild(chunk) {
      return !!this._children.has(chunk) && (this._children.delete(chunk), chunk.removeParent(this), 
      !0);
    }
    addParent(parentChunk) {
      return !this._parents.has(parentChunk) && (this._parents.add(parentChunk), !0);
    }
    getParents() {
      return this._parents.getFromCache(getArray);
    }
    setParents(newParents) {
      this._parents.clear();
      for (const p of newParents) this._parents.add(p);
    }
    getNumberOfParents() {
      return this._parents.size;
    }
    hasParent(parent) {
      return this._parents.has(parent);
    }
    get parentsIterable() {
      return this._parents;
    }
    removeParent(chunk) {
      return !!this._parents.delete(chunk) && (chunk.removeChunk(this), !0);
    }
    getBlocks() {
      return this._blocks.getFromCache(getArray);
    }
    getNumberOfBlocks() {
      return this._blocks.size;
    }
    hasBlock(block) {
      return this._blocks.has(block);
    }
    get blocksIterable() {
      return this._blocks;
    }
    addBlock(block) {
      return !this._blocks.has(block) && (this._blocks.add(block), !0);
    }
    addOrigin(module, loc, request) {
      this.origins.push({
        module: module,
        loc: loc,
        request: request
      });
    }
    containsModule(module) {
      for (const chunk of this.chunks) if (chunk.containsModule(module)) return !0;
      return !1;
    }
    getFiles() {
      const files = new Set;
      for (const chunk of this.chunks) for (const file of chunk.files) files.add(file);
      return Array.from(files);
    }
    remove(reason) {
      for (const parentChunkGroup of this._parents) {
        parentChunkGroup._children.delete(this);
        for (const chunkGroup of this._children) chunkGroup.addParent(parentChunkGroup), 
        parentChunkGroup.addChild(chunkGroup);
      }
      for (const chunkGroup of this._children) chunkGroup._parents.delete(this);
      for (const block of this._blocks) block.chunkGroup = null;
      for (const chunk of this.chunks) chunk.removeGroup(this);
    }
    sortItems() {
      this.origins.sort(sortOrigin), this._parents.sort(), this._children.sort();
    }
    compareTo(otherGroup) {
      if (this.chunks.length > otherGroup.chunks.length) return -1;
      if (this.chunks.length < otherGroup.chunks.length) return 1;
      const a = this.chunks[Symbol.iterator](), b = otherGroup.chunks[Symbol.iterator]();
      for (;;) {
        const aItem = a.next(), bItem = b.next();
        if (aItem.done) return 0;
        const cmp = aItem.value.compareTo(bItem.value);
        if (0 !== cmp) return cmp;
      }
    }
    getChildrenByOrders() {
      const lists = new Map;
      for (const childGroup of this._children) if ("object" == typeof childGroup.options) for (const key of Object.keys(childGroup.options)) if (key.endsWith("Order")) {
        const name = key.substr(0, key.length - "Order".length);
        let list = lists.get(name);
        void 0 === list && lists.set(name, list = []), list.push({
          order: childGroup.options[key],
          group: childGroup
        });
      }
      const result = Object.create(null);
      for (const [name, list] of lists) list.sort((a, b) => {
        const cmp = b.order - a.order;
        return 0 !== cmp ? cmp : a.group.compareTo ? a.group.compareTo(b.group) : 0;
      }), result[name] = list.map(i => i.group);
      return result;
    }
    setModuleIndex(module, index) {
      this._moduleIndices.set(module, index);
    }
    getModuleIndex(module) {
      return this._moduleIndices.get(module);
    }
    setModuleIndex2(module, index) {
      this._moduleIndices2.set(module, index);
    }
    getModuleIndex2(module) {
      return this._moduleIndices2.get(module);
    }
    checkConstraints() {
      const chunk = this;
      for (const child of chunk._children) if (!child._parents.has(chunk)) throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);
      for (const parentChunk of chunk._parents) if (!parentChunk._children.has(chunk)) throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), SortableSet = __webpack_require__(23), intersect = __webpack_require__(37).intersect, GraphHelpers = __webpack_require__(27), Entrypoint = __webpack_require__(97);
  let debugId = 1e3;
  const ERR_CHUNK_INITIAL = "Chunk.initial was removed. Use canBeInitial/isOnlyInitial()", sortModuleById = (a, b) => a.id < b.id ? -1 : b.id < a.id ? 1 : 0, sortChunkGroupById = (a, b) => a.id < b.id ? -1 : b.id < a.id ? 1 : 0, sortByIdentifier = (a, b) => a.identifier() > b.identifier() ? 1 : a.identifier() < b.identifier() ? -1 : 0, getModulesIdent = set => {
    set.sort();
    let str = "";
    for (const m of set) str += m.identifier() + "#";
    return str;
  }, getArray = set => Array.from(set), getModulesSize = set => {
    let size = 0;
    for (const module of set) size += module.size();
    return size;
  };
  class Chunk {
    constructor(name) {
      this.id = null, this.ids = null, this.debugId = debugId++, this.name = name, this.preventIntegration = !1, 
      this.entryModule = void 0, this._modules = new SortableSet(void 0, sortByIdentifier), 
      this.filenameTemplate = void 0, this._groups = new SortableSet(void 0, sortChunkGroupById), 
      this.files = [], this.rendered = !1, this.hash = void 0, this.contentHash = Object.create(null), 
      this.renderedHash = void 0, this.chunkReason = void 0, this.extraAsync = !1, this.removedModules = void 0;
    }
    get entry() {
      throw new Error("Chunk.entry was removed. Use hasRuntime()");
    }
    set entry(data) {
      throw new Error("Chunk.entry was removed. Use hasRuntime()");
    }
    get initial() {
      throw new Error(ERR_CHUNK_INITIAL);
    }
    set initial(data) {
      throw new Error(ERR_CHUNK_INITIAL);
    }
    hasRuntime() {
      for (const chunkGroup of this._groups) if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) return !0;
      return !1;
    }
    canBeInitial() {
      for (const chunkGroup of this._groups) if (chunkGroup.isInitial()) return !0;
      return !1;
    }
    isOnlyInitial() {
      if (this._groups.size <= 0) return !1;
      for (const chunkGroup of this._groups) if (!chunkGroup.isInitial()) return !1;
      return !0;
    }
    hasEntryModule() {
      return !!this.entryModule;
    }
    addModule(module) {
      return !this._modules.has(module) && (this._modules.add(module), !0);
    }
    removeModule(module) {
      return !!this._modules.delete(module) && (module.removeChunk(this), !0);
    }
    setModules(modules) {
      this._modules = new SortableSet(modules, sortByIdentifier);
    }
    getNumberOfModules() {
      return this._modules.size;
    }
    get modulesIterable() {
      return this._modules;
    }
    addGroup(chunkGroup) {
      return !this._groups.has(chunkGroup) && (this._groups.add(chunkGroup), !0);
    }
    removeGroup(chunkGroup) {
      return !!this._groups.has(chunkGroup) && (this._groups.delete(chunkGroup), !0);
    }
    isInGroup(chunkGroup) {
      return this._groups.has(chunkGroup);
    }
    getNumberOfGroups() {
      return this._groups.size;
    }
    get groupsIterable() {
      return this._groups;
    }
    compareTo(otherChunk) {
      if (this.name && !otherChunk.name) return -1;
      if (!this.name && otherChunk.name) return 1;
      if (this.name < otherChunk.name) return -1;
      if (this.name > otherChunk.name) return 1;
      if (this._modules.size > otherChunk._modules.size) return -1;
      if (this._modules.size < otherChunk._modules.size) return 1;
      this._modules.sort(), otherChunk._modules.sort();
      const a = this._modules[Symbol.iterator](), b = otherChunk._modules[Symbol.iterator]();
      for (;;) {
        const aItem = a.next();
        if (aItem.done) return 0;
        const bItem = b.next(), aModuleIdentifier = aItem.value.identifier(), bModuleIdentifier = bItem.value.identifier();
        if (aModuleIdentifier < bModuleIdentifier) return -1;
        if (aModuleIdentifier > bModuleIdentifier) return 1;
      }
    }
    containsModule(module) {
      return this._modules.has(module);
    }
    getModules() {
      return this._modules.getFromCache(getArray);
    }
    getModulesIdent() {
      return this._modules.getFromUnorderedCache(getModulesIdent);
    }
    remove(reason) {
      for (const module of Array.from(this._modules)) module.removeChunk(this);
      for (const chunkGroup of this._groups) chunkGroup.removeChunk(this);
    }
    moveModule(module, otherChunk) {
      GraphHelpers.disconnectChunkAndModule(this, module), GraphHelpers.connectChunkAndModule(otherChunk, module), 
      module.rewriteChunkInReasons(this, [ otherChunk ]);
    }
    integrate(otherChunk, reason) {
      if (!this.canBeIntegrated(otherChunk)) return !1;
      this.name && otherChunk.name ? this.hasEntryModule() === otherChunk.hasEntryModule() ? this.name.length !== otherChunk.name.length ? this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name : this.name = this.name < otherChunk.name ? this.name : otherChunk.name : otherChunk.hasEntryModule() && (this.name = otherChunk.name) : otherChunk.name && (this.name = otherChunk.name);
      for (const module of Array.from(otherChunk._modules)) otherChunk.moveModule(module, this);
      otherChunk._modules.clear(), otherChunk.entryModule && (this.entryModule = otherChunk.entryModule);
      for (const chunkGroup of otherChunk._groups) chunkGroup.replaceChunk(otherChunk, this), 
      this.addGroup(chunkGroup);
      return otherChunk._groups.clear(), !0;
    }
    split(newChunk) {
      for (const chunkGroup of this._groups) chunkGroup.insertChunk(newChunk, this), newChunk.addGroup(chunkGroup);
    }
    isEmpty() {
      return 0 === this._modules.size;
    }
    updateHash(hash) {
      hash.update(this.id + " "), hash.update(this.ids ? this.ids.join(",") : ""), hash.update((this.name || "") + " ");
      for (const m of this._modules) hash.update(m.hash);
    }
    canBeIntegrated(otherChunk) {
      if (this.preventIntegration || otherChunk.preventIntegration) return !1;
      const isAvailable = (a, b) => {
        const queue = new Set(b.groupsIterable);
        for (const chunkGroup of queue) if (!a.isInGroup(chunkGroup)) {
          if (chunkGroup.isInitial()) return !1;
          for (const parent of chunkGroup.parentsIterable) queue.add(parent);
        }
        return !0;
      }, selfHasRuntime = this.hasRuntime(), otherChunkHasRuntime = otherChunk.hasRuntime();
      return selfHasRuntime !== otherChunkHasRuntime ? selfHasRuntime ? isAvailable(this, otherChunk) : !!otherChunkHasRuntime && isAvailable(otherChunk, this) : !this.hasEntryModule() && !otherChunk.hasEntryModule();
    }
    addMultiplierAndOverhead(size, options) {
      const overhead = "number" == typeof options.chunkOverhead ? options.chunkOverhead : 1e4;
      return size * (this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1) + overhead;
    }
    modulesSize() {
      return this._modules.getFromUnorderedCache(getModulesSize);
    }
    size(options = {}) {
      return this.addMultiplierAndOverhead(this.modulesSize(), options);
    }
    integratedSize(otherChunk, options) {
      if (!this.canBeIntegrated(otherChunk)) return !1;
      let integratedModulesSize = this.modulesSize();
      for (const otherModule of otherChunk._modules) this._modules.has(otherModule) || (integratedModulesSize += otherModule.size());
      return this.addMultiplierAndOverhead(integratedModulesSize, options);
    }
    sortModules(sortByFn) {
      this._modules.sortWith(sortByFn || sortModuleById);
    }
    sortItems() {
      this.sortModules();
    }
    getAllAsyncChunks() {
      const queue = new Set, chunks = new Set, initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));
      for (const chunkGroup of this.groupsIterable) for (const child of chunkGroup.childrenIterable) queue.add(child);
      for (const chunkGroup of queue) {
        for (const chunk of chunkGroup.chunks) initialChunks.has(chunk) || chunks.add(chunk);
        for (const child of chunkGroup.childrenIterable) queue.add(child);
      }
      return chunks;
    }
    getChunkMaps(realHash) {
      const chunkHashMap = Object.create(null), chunkContentHashMap = Object.create(null), chunkNameMap = Object.create(null);
      for (const chunk of this.getAllAsyncChunks()) {
        chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;
        for (const key of Object.keys(chunk.contentHash)) chunkContentHashMap[key] || (chunkContentHashMap[key] = Object.create(null)), 
        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];
        chunk.name && (chunkNameMap[chunk.id] = chunk.name);
      }
      return {
        hash: chunkHashMap,
        contentHash: chunkContentHashMap,
        name: chunkNameMap
      };
    }
    getChildIdsByOrders() {
      const lists = new Map;
      for (const group of this.groupsIterable) if (group.chunks[group.chunks.length - 1] === this) for (const childGroup of group.childrenIterable) if ("object" == typeof childGroup.options) for (const key of Object.keys(childGroup.options)) if (key.endsWith("Order")) {
        const name = key.substr(0, key.length - "Order".length);
        let list = lists.get(name);
        void 0 === list && lists.set(name, list = []), list.push({
          order: childGroup.options[key],
          group: childGroup
        });
      }
      const result = Object.create(null);
      for (const [name, list] of lists) list.sort((a, b) => {
        const cmp = b.order - a.order;
        return 0 !== cmp ? cmp : a.group.compareTo ? a.group.compareTo(b.group) : 0;
      }), result[name] = Array.from(list.reduce((set, item) => {
        for (const chunk of item.group.chunks) set.add(chunk.id);
        return set;
      }, new Set));
      return result;
    }
    getChildIdsByOrdersMap(includeDirectChildren) {
      const chunkMaps = Object.create(null), addChildIdsByOrdersToMap = chunk => {
        const data = chunk.getChildIdsByOrders();
        for (const key of Object.keys(data)) {
          let chunkMap = chunkMaps[key];
          void 0 === chunkMap && (chunkMaps[key] = chunkMap = Object.create(null)), chunkMap[chunk.id] = data[key];
        }
      };
      if (includeDirectChildren) {
        const chunks = new Set;
        for (const chunkGroup of this.groupsIterable) for (const chunk of chunkGroup.chunks) chunks.add(chunk);
        for (const chunk of chunks) addChildIdsByOrdersToMap(chunk);
      }
      for (const chunk of this.getAllAsyncChunks()) addChildIdsByOrdersToMap(chunk);
      return chunkMaps;
    }
    getChunkModuleMaps(filterFn) {
      const chunkModuleIdMap = Object.create(null), chunkModuleHashMap = Object.create(null);
      for (const chunk of this.getAllAsyncChunks()) {
        let array;
        for (const module of chunk.modulesIterable) filterFn(module) && (void 0 === array && (array = [], 
        chunkModuleIdMap[chunk.id] = array), array.push(module.id), chunkModuleHashMap[module.id] = module.renderedHash);
        void 0 !== array && array.sort();
      }
      return {
        id: chunkModuleIdMap,
        hash: chunkModuleHashMap
      };
    }
    hasModuleInGraph(filterFn, filterChunkFn) {
      const queue = new Set(this.groupsIterable), chunksProcessed = new Set;
      for (const chunkGroup of queue) {
        for (const chunk of chunkGroup.chunks) if (!chunksProcessed.has(chunk) && (chunksProcessed.add(chunk), 
        !filterChunkFn || filterChunkFn(chunk))) for (const module of chunk.modulesIterable) if (filterFn(module)) return !0;
        for (const child of chunkGroup.childrenIterable) queue.add(child);
      }
      return !1;
    }
    toString() {
      return `Chunk[${Array.from(this._modules).join()}]`;
    }
  }
  Object.defineProperty(Chunk.prototype, "forEachModule", {
    configurable: !1,
    value: util.deprecate((function(fn) {
      this._modules.forEach(fn);
    }), "Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead")
  }), Object.defineProperty(Chunk.prototype, "mapModules", {
    configurable: !1,
    value: util.deprecate((function(fn) {
      return Array.from(this._modules, fn);
    }), "Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead")
  }), Object.defineProperty(Chunk.prototype, "chunks", {
    configurable: !1,
    get() {
      throw new Error("Chunk.chunks: Use ChunkGroup.getChildren() instead");
    },
    set() {
      throw new Error("Chunk.chunks: Use ChunkGroup.add/removeChild() instead");
    }
  }), Object.defineProperty(Chunk.prototype, "parents", {
    configurable: !1,
    get() {
      throw new Error("Chunk.parents: Use ChunkGroup.getParents() instead");
    },
    set() {
      throw new Error("Chunk.parents: Use ChunkGroup.add/removeParent() instead");
    }
  }), Object.defineProperty(Chunk.prototype, "blocks", {
    configurable: !1,
    get() {
      throw new Error("Chunk.blocks: Use ChunkGroup.getBlocks() instead");
    },
    set() {
      throw new Error("Chunk.blocks: Use ChunkGroup.add/removeBlock() instead");
    }
  }), Object.defineProperty(Chunk.prototype, "entrypoints", {
    configurable: !1,
    get() {
      throw new Error("Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead");
    },
    set() {
      throw new Error("Chunk.entrypoints: Use Chunks.addGroup instead");
    }
  }), module.exports = Chunk;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ChunkGroup = __webpack_require__(95);
  module.exports = class extends ChunkGroup {
    constructor(name) {
      super(name), this.runtimeChunk = void 0;
    }
    isInitial() {
      return !0;
    }
    setRuntimeChunk(chunk) {
      this.runtimeChunk = chunk;
    }
    getRuntimeChunk() {
      return this.runtimeChunk || this.chunks[0];
    }
    replaceChunk(oldChunk, newChunk) {
      return this.runtimeChunk === oldChunk && (this.runtimeChunk = newChunk), super.replaceChunk(oldChunk, newChunk);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Chunk = __webpack_require__(96);
  module.exports = class extends Chunk {
    constructor() {
      super(), this.removedModules = void 0;
    }
  };
}, function(module, exports) {
  module.exports = require("crypto");
}, function(module, exports) {
  module.exports = require("module");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependenciesBlockVariable = __webpack_require__(213);
  module.exports = class {
    constructor() {
      this.dependencies = [], this.blocks = [], this.variables = [];
    }
    addBlock(block) {
      this.blocks.push(block), block.parent = this;
    }
    addVariable(name, expression, dependencies) {
      for (let v of this.variables) if (v.name === name && v.expression === expression) return;
      this.variables.push(new DependenciesBlockVariable(name, expression, dependencies));
    }
    addDependency(dependency) {
      this.dependencies.push(dependency);
    }
    removeDependency(dependency) {
      const idx = this.dependencies.indexOf(dependency);
      idx >= 0 && this.dependencies.splice(idx, 1);
    }
    updateHash(hash) {
      for (const dep of this.dependencies) dep.updateHash(hash);
      for (const block of this.blocks) block.updateHash(hash);
      for (const variable of this.variables) variable.updateHash(hash);
    }
    disconnect() {
      for (const dep of this.dependencies) dep.disconnect();
      for (const block of this.blocks) block.disconnect();
      for (const variable of this.variables) variable.disconnect();
    }
    unseal() {
      for (const block of this.blocks) block.unseal();
    }
    hasDependencies(filter) {
      if (filter) {
        for (const dep of this.dependencies) if (filter(dep)) return !0;
      } else if (this.dependencies.length > 0) return !0;
      for (const block of this.blocks) if (block.hasDependencies(filter)) return !0;
      for (const variable of this.variables) if (variable.hasDependencies(filter)) return !0;
      return !1;
    }
    sortItems() {
      for (const block of this.blocks) block.sortItems();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const normalize = __webpack_require__(63), absoluteWinRegExp = /^[A-Z]:([\\\/]|$)/i, absoluteNixRegExp = /^\//i;
  module.exports = function(path, request) {
    return request ? absoluteWinRegExp.test(request) ? normalize(request.replace(/\//g, "\\")) : absoluteNixRegExp.test(request) ? normalize(request) : "/" == path ? normalize(path + request) : absoluteWinRegExp.test(path) ? normalize(path.replace(/\//g, "\\") + "\\" + request.replace(/\//g, "\\")) : (absoluteNixRegExp.test(path), 
    normalize(path + "/" + request)) : normalize(path);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(path) {
    const parts = path.split(/(.*?[\\/]+)/), paths = [ path ], seqments = [ parts[parts.length - 1] ];
    let part = parts[parts.length - 1];
    path = path.substr(0, path.length - part.length - 1);
    for (let i = parts.length - 2; i > 2; i -= 2) paths.push(path), part = parts[i], 
    path = path.substr(0, path.length - part.length) || "/", seqments.push(part.substr(0, part.length - 1));
    return part = parts[1], seqments.push(part), paths.push(part), {
      paths: paths,
      seqments: seqments
    };
  }, module.exports.basename = function(path) {
    const i = path.lastIndexOf("/"), j = path.lastIndexOf("\\"), p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
    if (p < 0) return null;
    return path.substr(p + 1);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(resolver, request) {
    if ("string" == typeof request.__innerRequest && request.__innerRequest_request === request.request && request.__innerRequest_relativePath === request.relativePath) return request.__innerRequest;
    let innerRequest;
    return request.request ? (innerRequest = request.request, /^\.\.?\//.test(innerRequest) && request.relativePath && (innerRequest = resolver.join(request.relativePath, innerRequest))) : innerRequest = request.relativePath, 
    request.__innerRequest_request = request.request, request.__innerRequest_relativePath = request.relativePath, 
    request.__innerRequest = innerRequest;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const fs = __webpack_require__(106);
  class NodeJsInputFileSystem {
    readdir(path, callback) {
      fs.readdir(path, (err, files) => {
        callback(err, files && files.map(file => file.normalize ? file.normalize("NFC") : file));
      });
    }
    readdirSync(path) {
      const files = fs.readdirSync(path);
      return files && files.map(file => file.normalize ? file.normalize("NFC") : file);
    }
  }
  const fsMethods = [ "stat", "statSync", "readFile", "readFileSync", "readlink", "readlinkSync" ];
  for (const key of fsMethods) Object.defineProperty(NodeJsInputFileSystem.prototype, key, {
    configurable: !0,
    writable: !0,
    value: fs[key].bind(fs)
  });
  module.exports = NodeJsInputFileSystem;
}, function(module, exports, __webpack_require__) {
  var gracefulQueue, previousSymbol, fs = __webpack_require__(20), polyfills = __webpack_require__(254), legacy = __webpack_require__(256), clone = __webpack_require__(257), util = __webpack_require__(11);
  function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue;
      }
    });
  }
  "function" == typeof Symbol && "function" == typeof Symbol.for ? (gracefulQueue = Symbol.for("graceful-fs.queue"), 
  previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", 
  previousSymbol = "___graceful-fs.previous");
  var retryTimer, debug = function() {};
  if (util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
    var m = util.format.apply(util, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: "), console.error(m);
  }), !fs[gracefulQueue]) {
    var queue = global[gracefulQueue] || [];
    publishQueue(fs, queue), fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, (function(err) {
          err || resetQueue(), "function" == typeof cb && cb.apply(this, arguments);
        }));
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs.close), fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", (function() {
      debug(fs[gracefulQueue]), __webpack_require__(30).equal(fs[gracefulQueue].length, 0);
    }));
  }
  function patch(fs) {
    polyfills(fs), fs.gracefulify = patch, fs.createReadStream = function(path, options) {
      return new fs.ReadStream(path, options);
    }, fs.createWriteStream = function(path, options) {
      return new fs.WriteStream(path, options);
    };
    var fs$readFile = fs.readFile;
    fs.readFile = function(path, options, cb) {
      "function" == typeof options && (cb = options, options = null);
      return function go$readFile(path, options, cb, startTime) {
        return fs$readFile(path, options, (function(err) {
          !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$readFile, [ path, options, cb ], err, startTime || Date.now(), Date.now() ]);
        }));
      }(path, options, cb);
    };
    var fs$writeFile = fs.writeFile;
    fs.writeFile = function(path, data, options, cb) {
      "function" == typeof options && (cb = options, options = null);
      return function go$writeFile(path, data, options, cb, startTime) {
        return fs$writeFile(path, data, options, (function(err) {
          !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$writeFile, [ path, data, options, cb ], err, startTime || Date.now(), Date.now() ]);
        }));
      }(path, data, options, cb);
    };
    var fs$appendFile = fs.appendFile;
    fs$appendFile && (fs.appendFile = function(path, data, options, cb) {
      "function" == typeof options && (cb = options, options = null);
      return function go$appendFile(path, data, options, cb, startTime) {
        return fs$appendFile(path, data, options, (function(err) {
          !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$appendFile, [ path, data, options, cb ], err, startTime || Date.now(), Date.now() ]);
        }));
      }(path, data, options, cb);
    });
    var fs$copyFile = fs.copyFile;
    fs$copyFile && (fs.copyFile = function(src, dest, flags, cb) {
      "function" == typeof flags && (cb = flags, flags = 0);
      return function go$copyFile(src, dest, flags, cb, startTime) {
        return fs$copyFile(src, dest, flags, (function(err) {
          !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$copyFile, [ src, dest, flags, cb ], err, startTime || Date.now(), Date.now() ]);
        }));
      }(src, dest, flags, cb);
    });
    var fs$readdir = fs.readdir;
    fs.readdir = function(path, options, cb) {
      "function" == typeof options && (cb = options, options = null);
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
      } : function(path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path, options, cb, startTime) {
        return function(err, files) {
          !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? (files && files.sort && files.sort(), 
          "function" == typeof cb && cb.call(this, err, files)) : enqueue([ go$readdir, [ path, options, cb ], err, startTime || Date.now(), Date.now() ]);
        };
      }
    };
    var noReaddirOptionVersions = /^v[0-5]\./;
    if ("v0.8" === process.version.substr(0, 4)) {
      var legStreams = legacy(fs);
      ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), 
    ReadStream.prototype.open = function() {
      var that = this;
      open(that.path, that.flags, that.mode, (function(err, fd) {
        err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, 
        that.emit("open", fd), that.read());
      }));
    });
    var fs$WriteStream = fs.WriteStream;
    fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), 
    WriteStream.prototype.open = function() {
      var that = this;
      open(that.path, that.flags, that.mode, (function(err, fd) {
        err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
      }));
    }), Object.defineProperty(fs, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(fs, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileWriteStream = WriteStream;
    function ReadStream(path, options) {
      return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function WriteStream(path, options) {
      return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    Object.defineProperty(fs, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var fs$open = fs.open;
    function open(path, flags, mode, cb) {
      return "function" == typeof mode && (cb = mode, mode = null), function go$open(path, flags, mode, cb, startTime) {
        return fs$open(path, flags, mode, (function(err, fd) {
          !err || "EMFILE" !== err.code && "ENFILE" !== err.code ? "function" == typeof cb && cb.apply(this, arguments) : enqueue([ go$open, [ path, flags, mode, cb ], err, startTime || Date.now(), Date.now() ]);
        }));
      }(path, flags, mode, cb);
    }
    return fs.open = open, fs;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]), fs[gracefulQueue].push(elem), retry();
  }
  function resetQueue() {
    for (var now = Date.now(), i = 0; i < fs[gracefulQueue].length; ++i) fs[gracefulQueue][i].length > 2 && (fs[gracefulQueue][i][3] = now, 
    fs[gracefulQueue][i][4] = now);
    retry();
  }
  function retry() {
    if (clearTimeout(retryTimer), retryTimer = void 0, 0 !== fs[gracefulQueue].length) {
      var elem = fs[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
      if (void 0 === startTime) debug("RETRY", fn.name, args), fn.apply(null, args); else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        "function" == typeof cb && cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1);
        sinceAttempt >= Math.min(1.2 * sinceStart, 100) ? (debug("RETRY", fn.name, args), 
        fn.apply(null, args.concat([ startTime ]))) : fs[gracefulQueue].push(elem);
      }
      void 0 === retryTimer && (retryTimer = setTimeout(retry, 0));
    }
  }
  global[gracefulQueue] || publishQueue(global, fs[gracefulQueue]), module.exports = patch(clone(fs)), 
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched && (module.exports = patch(fs), 
  fs.__patched = !0);
}, function(module, exports) {
  module.exports = require("stream");
}, function(module, exports, __webpack_require__) {
  "use strict";
  class Storage {
    constructor(duration) {
      if (this.duration = duration, this.running = new Map, this.data = new Map, this.levels = [], 
      duration > 0) {
        this.levels.push(new Set, new Set, new Set, new Set, new Set, new Set, new Set, new Set, new Set);
        for (let i = 8e3; i < duration; i += 500) this.levels.push(new Set);
      }
      this.count = 0, this.interval = null, this.needTickCheck = !1, this.nextTick = null, 
      this.passive = !0, this.tick = this.tick.bind(this);
    }
    ensureTick() {
      !this.interval && this.duration > 0 && !this.nextTick && (this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length)));
    }
    finished(name, err, result) {
      const callbacks = this.running.get(name);
      if (this.running.delete(name), this.duration > 0) {
        this.data.set(name, [ err, result ]);
        const levelData = this.levels[0];
        this.count -= levelData.size, levelData.add(name), this.count += levelData.size, 
        this.ensureTick();
      }
      for (let i = 0; i < callbacks.length; i++) callbacks[i](err, result);
    }
    finishedSync(name, err, result) {
      if (this.duration > 0) {
        this.data.set(name, [ err, result ]);
        const levelData = this.levels[0];
        this.count -= levelData.size, levelData.add(name), this.count += levelData.size, 
        this.ensureTick();
      }
    }
    provide(name, provider, callback) {
      if ("string" != typeof name) return void callback(new TypeError("path must be a string"));
      let running = this.running.get(name);
      if (running) running.push(callback); else {
        if (this.duration > 0) {
          this.checkTicks();
          const data = this.data.get(name);
          if (data) return process.nextTick(() => {
            callback.apply(null, data);
          });
        }
        this.running.set(name, running = [ callback ]), provider(name, (err, result) => {
          this.finished(name, err, result);
        });
      }
    }
    provideSync(name, provider) {
      if ("string" != typeof name) throw new TypeError("path must be a string");
      if (this.duration > 0) {
        this.checkTicks();
        const data = this.data.get(name);
        if (data) {
          if (data[0]) throw data[0];
          return data[1];
        }
      }
      let result;
      try {
        result = provider(name);
      } catch (e) {
        throw this.finishedSync(name, e), e;
      }
      return this.finishedSync(name, null, result), result;
    }
    tick() {
      const decay = this.levels.pop();
      for (let item of decay) this.data.delete(item);
      if (this.count -= decay.size, decay.clear(), this.levels.unshift(decay), 0 === this.count) return clearInterval(this.interval), 
      this.interval = null, this.nextTick = null, !0;
      if (this.nextTick) {
        this.nextTick += Math.floor(this.duration / this.levels.length);
        const time = (new Date).getTime();
        if (this.nextTick > time) return this.nextTick = null, this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length)), 
        !0;
      } else this.passive ? (clearInterval(this.interval), this.interval = null, this.nextTick = (new Date).getTime() + Math.floor(this.duration / this.levels.length)) : this.passive = !0;
    }
    checkTicks() {
      if (this.passive = !1, this.nextTick) for (;!this.tick(); ) ;
    }
    purge(what) {
      if (what) if ("string" == typeof what) for (let key of this.data.keys()) key.startsWith(what) && this.data.delete(key); else for (let i = what.length - 1; i >= 0; i--) this.purge(what[i]); else this.count = 0, 
      clearInterval(this.interval), this.nextTick = null, this.data.clear(), this.levels.forEach(level => {
        level.clear();
      });
    }
  }
  module.exports = class {
    constructor(fileSystem, duration) {
      this.fileSystem = fileSystem, this._statStorage = new Storage(duration), this._readdirStorage = new Storage(duration), 
      this._readFileStorage = new Storage(duration), this._readJsonStorage = new Storage(duration), 
      this._readlinkStorage = new Storage(duration), this._stat = this.fileSystem.stat ? this.fileSystem.stat.bind(this.fileSystem) : null, 
      this._stat || (this.stat = null), this._statSync = this.fileSystem.statSync ? this.fileSystem.statSync.bind(this.fileSystem) : null, 
      this._statSync || (this.statSync = null), this._readdir = this.fileSystem.readdir ? this.fileSystem.readdir.bind(this.fileSystem) : null, 
      this._readdir || (this.readdir = null), this._readdirSync = this.fileSystem.readdirSync ? this.fileSystem.readdirSync.bind(this.fileSystem) : null, 
      this._readdirSync || (this.readdirSync = null), this._readFile = this.fileSystem.readFile ? this.fileSystem.readFile.bind(this.fileSystem) : null, 
      this._readFile || (this.readFile = null), this._readFileSync = this.fileSystem.readFileSync ? this.fileSystem.readFileSync.bind(this.fileSystem) : null, 
      this._readFileSync || (this.readFileSync = null), this.fileSystem.readJson ? this._readJson = this.fileSystem.readJson.bind(this.fileSystem) : this.readFile ? this._readJson = (path, callback) => {
        this.readFile(path, (err, buffer) => {
          if (err) return callback(err);
          let data;
          try {
            data = JSON.parse(buffer.toString("utf-8"));
          } catch (e) {
            return callback(e);
          }
          callback(null, data);
        });
      } : this.readJson = null, this.fileSystem.readJsonSync ? this._readJsonSync = this.fileSystem.readJsonSync.bind(this.fileSystem) : this.readFileSync ? this._readJsonSync = path => {
        const buffer = this.readFileSync(path);
        return JSON.parse(buffer.toString("utf-8"));
      } : this.readJsonSync = null, this._readlink = this.fileSystem.readlink ? this.fileSystem.readlink.bind(this.fileSystem) : null, 
      this._readlink || (this.readlink = null), this._readlinkSync = this.fileSystem.readlinkSync ? this.fileSystem.readlinkSync.bind(this.fileSystem) : null, 
      this._readlinkSync || (this.readlinkSync = null);
    }
    stat(path, callback) {
      this._statStorage.provide(path, this._stat, callback);
    }
    readdir(path, callback) {
      this._readdirStorage.provide(path, this._readdir, callback);
    }
    readFile(path, callback) {
      this._readFileStorage.provide(path, this._readFile, callback);
    }
    readJson(path, callback) {
      this._readJsonStorage.provide(path, this._readJson, callback);
    }
    readlink(path, callback) {
      this._readlinkStorage.provide(path, this._readlink, callback);
    }
    statSync(path) {
      return this._statStorage.provideSync(path, this._statSync);
    }
    readdirSync(path) {
      return this._readdirStorage.provideSync(path, this._readdirSync);
    }
    readFileSync(path) {
      return this._readFileStorage.provideSync(path, this._readFileSync);
    }
    readJsonSync(path) {
      return this._readJsonStorage.provideSync(path, this._readJsonSync);
    }
    readlinkSync(path) {
      return this._readlinkStorage.provideSync(path, this._readlinkSync);
    }
    purge(what) {
      this._statStorage.purge(what), this._readdirStorage.purge(what), this._readFileStorage.purge(what), 
      this._readlinkStorage.purge(what), this._readJsonStorage.purge(what);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor() {
      super(), this.name = "ConcurrentCompilationError", this.message = "You ran Webpack twice. Each instance only supports a single concurrent compilation at a time.", 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var path = __webpack_require__(3);
  function WatcherManager() {
    this.directoryWatchers = {};
  }
  WatcherManager.prototype.getDirectoryWatcher = function(directory, options) {
    var DirectoryWatcher = __webpack_require__(262);
    options = options || {};
    var key = directory + " " + JSON.stringify(options);
    return this.directoryWatchers[key] || (this.directoryWatchers[key] = new DirectoryWatcher(directory, options), 
    this.directoryWatchers[key].on("closed", function() {
      delete this.directoryWatchers[key];
    }.bind(this))), this.directoryWatchers[key];
  }, WatcherManager.prototype.watchFile = function(p, options, startTime) {
    var directory = path.dirname(p);
    return this.getDirectoryWatcher(directory, options).watch(p, startTime);
  }, WatcherManager.prototype.watchDirectory = function(directory, options, startTime) {
    return this.getDirectoryWatcher(directory, options).watch(directory, startTime);
  }, module.exports = new WatcherManager;
}, function(module, exports) {
  module.exports = require("events");
}, function(module, exports) {
  module.exports = require("../vendor/chokidar");
}, function(module, exports, __webpack_require__) {
  var path = __webpack_require__(3), fs = __webpack_require__(20), _0777 = parseInt("0777", 8);
  function mkdirP(p, opts, f, made) {
    "function" == typeof opts ? (f = opts, opts = {}) : opts && "object" == typeof opts || (opts = {
      mode: opts
    });
    var mode = opts.mode, xfs = opts.fs || fs;
    void 0 === mode && (mode = _0777), made || (made = null);
    var cb = f || function() {};
    p = path.resolve(p), xfs.mkdir(p, mode, (function(er) {
      if (!er) return cb(null, made = made || p);
      switch (er.code) {
       case "ENOENT":
        if (path.dirname(p) === p) return cb(er);
        mkdirP(path.dirname(p), opts, (function(er, made) {
          er ? cb(er, made) : mkdirP(p, opts, cb, made);
        }));
        break;

       default:
        xfs.stat(p, (function(er2, stat) {
          er2 || !stat.isDirectory() ? cb(er, made) : cb(null, made);
        }));
      }
    }));
  }
  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP, mkdirP.sync = function sync(p, opts, made) {
    opts && "object" == typeof opts || (opts = {
      mode: opts
    });
    var mode = opts.mode, xfs = opts.fs || fs;
    void 0 === mode && (mode = _0777), made || (made = null), p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode), made = made || p;
    } catch (err0) {
      switch (err0.code) {
       case "ENOENT":
        made = sync(path.dirname(p), opts, made), sync(p, opts, made);
        break;

       default:
        var stat;
        try {
          stat = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat.isDirectory()) throw err0;
      }
    }
    return made;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const acorn = __webpack_require__(271), {Tapable: Tapable, SyncBailHook: SyncBailHook, HookMap: HookMap} = __webpack_require__(6), util = __webpack_require__(11), vm = __webpack_require__(115), BasicEvaluatedExpression = __webpack_require__(70), StackedSetMap = __webpack_require__(116), acornParser = acorn.Parser, joinRanges = (startRange, endRange) => endRange ? startRange ? [ startRange[0], endRange[1] ] : endRange : startRange, defaultParserOptions = {
    ranges: !0,
    locations: !0,
    ecmaVersion: 11,
    sourceType: "module",
    onComment: null
  }, webpackCommentRegExp = new RegExp(/(^|\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/), EMPTY_COMMENT_OPTIONS = {
    options: null,
    errors: null
  };
  class Parser extends Tapable {
    constructor(options, sourceType = "auto") {
      super(), this.hooks = {
        evaluateTypeof: new HookMap(() => new SyncBailHook([ "expression" ])),
        evaluate: new HookMap(() => new SyncBailHook([ "expression" ])),
        evaluateIdentifier: new HookMap(() => new SyncBailHook([ "expression" ])),
        evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([ "expression" ])),
        evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([ "expression", "param" ])),
        statement: new SyncBailHook([ "statement" ]),
        statementIf: new SyncBailHook([ "statement" ]),
        label: new HookMap(() => new SyncBailHook([ "statement" ])),
        import: new SyncBailHook([ "statement", "source" ]),
        importSpecifier: new SyncBailHook([ "statement", "source", "exportName", "identifierName" ]),
        export: new SyncBailHook([ "statement" ]),
        exportImport: new SyncBailHook([ "statement", "source" ]),
        exportDeclaration: new SyncBailHook([ "statement", "declaration" ]),
        exportExpression: new SyncBailHook([ "statement", "declaration" ]),
        exportSpecifier: new SyncBailHook([ "statement", "identifierName", "exportName", "index" ]),
        exportImportSpecifier: new SyncBailHook([ "statement", "source", "identifierName", "exportName", "index" ]),
        varDeclaration: new HookMap(() => new SyncBailHook([ "declaration" ])),
        varDeclarationLet: new HookMap(() => new SyncBailHook([ "declaration" ])),
        varDeclarationConst: new HookMap(() => new SyncBailHook([ "declaration" ])),
        varDeclarationVar: new HookMap(() => new SyncBailHook([ "declaration" ])),
        canRename: new HookMap(() => new SyncBailHook([ "initExpression" ])),
        rename: new HookMap(() => new SyncBailHook([ "initExpression" ])),
        assigned: new HookMap(() => new SyncBailHook([ "expression" ])),
        assign: new HookMap(() => new SyncBailHook([ "expression" ])),
        typeof: new HookMap(() => new SyncBailHook([ "expression" ])),
        importCall: new SyncBailHook([ "expression" ]),
        call: new HookMap(() => new SyncBailHook([ "expression" ])),
        callAnyMember: new HookMap(() => new SyncBailHook([ "expression" ])),
        new: new HookMap(() => new SyncBailHook([ "expression" ])),
        expression: new HookMap(() => new SyncBailHook([ "expression" ])),
        expressionAnyMember: new HookMap(() => new SyncBailHook([ "expression" ])),
        expressionConditionalOperator: new SyncBailHook([ "expression" ]),
        expressionLogicalOperator: new SyncBailHook([ "expression" ]),
        program: new SyncBailHook([ "ast", "comments" ])
      };
      const HOOK_MAP_COMPAT_CONFIG = {
        evaluateTypeof: /^evaluate typeof (.+)$/,
        evaluateIdentifier: /^evaluate Identifier (.+)$/,
        evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,
        evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,
        evaluate: /^evaluate (.+)$/,
        label: /^label (.+)$/,
        varDeclarationLet: /^var-let (.+)$/,
        varDeclarationConst: /^var-const (.+)$/,
        varDeclarationVar: /^var-var (.+)$/,
        varDeclaration: /^var (.+)$/,
        canRename: /^can-rename (.+)$/,
        rename: /^rename (.+)$/,
        typeof: /^typeof (.+)$/,
        assigned: /^assigned (.+)$/,
        assign: /^assign (.+)$/,
        callAnyMember: /^call (.+)\.\*$/,
        call: /^call (.+)$/,
        new: /^new (.+)$/,
        expressionConditionalOperator: /^expression \?:$/,
        expressionAnyMember: /^expression (.+)\.\*$/,
        expression: /^expression (.+)$/
      };
      this._pluginCompat.tap("Parser", options => {
        for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {
          const match = HOOK_MAP_COMPAT_CONFIG[name].exec(options.name);
          if (match) return match[1] ? this.hooks[name].tap(match[1], options.fn.name || "unnamed compat plugin", options.fn.bind(this)) : this.hooks[name].tap(options.fn.name || "unnamed compat plugin", options.fn.bind(this)), 
          !0;
        }
      }), this.options = options, this.sourceType = sourceType, this.scope = void 0, this.state = void 0, 
      this.comments = void 0, this.initializeEvaluating();
    }
    initializeEvaluating() {
      this.hooks.evaluate.for("Literal").tap("Parser", expr => {
        switch (typeof expr.value) {
         case "number":
          return (new BasicEvaluatedExpression).setNumber(expr.value).setRange(expr.range);

         case "string":
          return (new BasicEvaluatedExpression).setString(expr.value).setRange(expr.range);

         case "boolean":
          return (new BasicEvaluatedExpression).setBoolean(expr.value).setRange(expr.range);
        }
        return null === expr.value ? (new BasicEvaluatedExpression).setNull().setRange(expr.range) : expr.value instanceof RegExp ? (new BasicEvaluatedExpression).setRegExp(expr.value).setRange(expr.range) : void 0;
      }), this.hooks.evaluate.for("LogicalExpression").tap("Parser", expr => {
        let left, leftAsBool, right;
        if ("&&" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), leftAsBool = left && left.asBool(), 
          !1 === leftAsBool) return left.setRange(expr.range);
          if (!0 !== leftAsBool) return;
          return right = this.evaluateExpression(expr.right), right.setRange(expr.range);
        }
        if ("||" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), leftAsBool = left && left.asBool(), 
          !0 === leftAsBool) return left.setRange(expr.range);
          if (!1 !== leftAsBool) return;
          return right = this.evaluateExpression(expr.right), right.setRange(expr.range);
        }
      }), this.hooks.evaluate.for("BinaryExpression").tap("Parser", expr => {
        let left, right, res;
        if ("+" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (res = new BasicEvaluatedExpression, left.isString()) right.isString() ? res.setString(left.string + right.string) : right.isNumber() ? res.setString(left.string + right.number) : right.isWrapped() && right.prefix && right.prefix.isString() ? res.setWrapped((new BasicEvaluatedExpression).setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions) : right.isWrapped() ? res.setWrapped(left, right.postfix, right.wrappedInnerExpressions) : res.setWrapped(left, null, [ right ]); else if (left.isNumber()) if (right.isString()) res.setString(left.number + right.string); else {
            if (!right.isNumber()) return;
            res.setNumber(left.number + right.number);
          } else if (left.isWrapped()) left.postfix && left.postfix.isString() && right.isString() ? res.setWrapped(left.prefix, (new BasicEvaluatedExpression).setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions) : left.postfix && left.postfix.isString() && right.isNumber() ? res.setWrapped(left.prefix, (new BasicEvaluatedExpression).setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions) : right.isString() ? res.setWrapped(left.prefix, right, left.wrappedInnerExpressions) : right.isNumber() ? res.setWrapped(left.prefix, (new BasicEvaluatedExpression).setString(right.number + "").setRange(right.range), left.wrappedInnerExpressions) : right.isWrapped() ? res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [ left.postfix ] : []).concat(right.prefix ? [ right.prefix ] : []).concat(right.wrappedInnerExpressions)) : res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [ left.postfix, right ] : [ right ])); else if (right.isString()) res.setWrapped(null, right, [ left ]); else {
            if (!right.isWrapped()) return;
            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [ left, right.prefix ] : [ left ]).concat(right.wrappedInnerExpressions));
          }
          return res.setRange(expr.range), res;
        }
        if ("-" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          return res = new BasicEvaluatedExpression, res.setNumber(left.number - right.number), 
          res.setRange(expr.range), res;
        }
        if ("*" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          return res = new BasicEvaluatedExpression, res.setNumber(left.number * right.number), 
          res.setRange(expr.range), res;
        }
        if ("/" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          return res = new BasicEvaluatedExpression, res.setNumber(left.number / right.number), 
          res.setRange(expr.range), res;
        }
        if ("**" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (!left.isNumber() || !right.isNumber()) return;
          return res = new BasicEvaluatedExpression, res.setNumber(Math.pow(left.number, right.number)), 
          res.setRange(expr.range), res;
        }
        if ("==" === expr.operator || "===" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (res = new BasicEvaluatedExpression, res.setRange(expr.range), left.isString() && right.isString()) return res.setBoolean(left.string === right.string);
          if (left.isNumber() && right.isNumber()) return res.setBoolean(left.number === right.number);
          if (left.isBoolean() && right.isBoolean()) return res.setBoolean(left.bool === right.bool);
        } else if ("!=" === expr.operator || "!==" === expr.operator) {
          if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
          !left || !right) return;
          if (res = new BasicEvaluatedExpression, res.setRange(expr.range), left.isString() && right.isString()) return res.setBoolean(left.string !== right.string);
          if (left.isNumber() && right.isNumber()) return res.setBoolean(left.number !== right.number);
          if (left.isBoolean() && right.isBoolean()) return res.setBoolean(left.bool !== right.bool);
        } else {
          if ("&" === expr.operator) {
            if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
            !left || !right) return;
            if (!left.isNumber() || !right.isNumber()) return;
            return res = new BasicEvaluatedExpression, res.setNumber(left.number & right.number), 
            res.setRange(expr.range), res;
          }
          if ("|" === expr.operator) {
            if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
            !left || !right) return;
            if (!left.isNumber() || !right.isNumber()) return;
            return res = new BasicEvaluatedExpression, res.setNumber(left.number | right.number), 
            res.setRange(expr.range), res;
          }
          if ("^" === expr.operator) {
            if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
            !left || !right) return;
            if (!left.isNumber() || !right.isNumber()) return;
            return res = new BasicEvaluatedExpression, res.setNumber(left.number ^ right.number), 
            res.setRange(expr.range), res;
          }
          if (">>>" === expr.operator) {
            if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
            !left || !right) return;
            if (!left.isNumber() || !right.isNumber()) return;
            return res = new BasicEvaluatedExpression, res.setNumber(left.number >>> right.number), 
            res.setRange(expr.range), res;
          }
          if (">>" === expr.operator) {
            if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
            !left || !right) return;
            if (!left.isNumber() || !right.isNumber()) return;
            return res = new BasicEvaluatedExpression, res.setNumber(left.number >> right.number), 
            res.setRange(expr.range), res;
          }
          if ("<<" === expr.operator) {
            if (left = this.evaluateExpression(expr.left), right = this.evaluateExpression(expr.right), 
            !left || !right) return;
            if (!left.isNumber() || !right.isNumber()) return;
            return res = new BasicEvaluatedExpression, res.setNumber(left.number << right.number), 
            res.setRange(expr.range), res;
          }
        }
      }), this.hooks.evaluate.for("UnaryExpression").tap("Parser", expr => {
        if ("typeof" === expr.operator) {
          let res, name;
          if ("Identifier" === expr.argument.type && (name = this.scope.renames.get(expr.argument.name) || expr.argument.name, 
          !this.scope.definitions.has(name))) {
            const hook = this.hooks.evaluateTypeof.get(name);
            if (void 0 !== hook && (res = hook.call(expr), void 0 !== res)) return res;
          }
          if ("MemberExpression" === expr.argument.type) {
            const exprName = this.getNameForExpression(expr.argument);
            if (exprName && exprName.free) {
              const hook = this.hooks.evaluateTypeof.get(exprName.name);
              if (void 0 !== hook && (res = hook.call(expr), void 0 !== res)) return res;
            }
          }
          if ("FunctionExpression" === expr.argument.type) return (new BasicEvaluatedExpression).setString("function").setRange(expr.range);
          const arg = this.evaluateExpression(expr.argument);
          if (arg.isString() || arg.isWrapped()) return (new BasicEvaluatedExpression).setString("string").setRange(expr.range);
          if (arg.isNumber()) return (new BasicEvaluatedExpression).setString("number").setRange(expr.range);
          if (arg.isBoolean()) return (new BasicEvaluatedExpression).setString("boolean").setRange(expr.range);
          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) return (new BasicEvaluatedExpression).setString("object").setRange(expr.range);
        } else if ("!" === expr.operator) {
          const argument = this.evaluateExpression(expr.argument);
          if (!argument) return;
          if (argument.isBoolean()) return (new BasicEvaluatedExpression).setBoolean(!argument.bool).setRange(expr.range);
          if (argument.isTruthy()) return (new BasicEvaluatedExpression).setBoolean(!1).setRange(expr.range);
          if (argument.isFalsy()) return (new BasicEvaluatedExpression).setBoolean(!0).setRange(expr.range);
          if (argument.isString()) return (new BasicEvaluatedExpression).setBoolean(!argument.string).setRange(expr.range);
          if (argument.isNumber()) return (new BasicEvaluatedExpression).setBoolean(!argument.number).setRange(expr.range);
        } else if ("~" === expr.operator) {
          const argument = this.evaluateExpression(expr.argument);
          if (!argument) return;
          if (!argument.isNumber()) return;
          const res = new BasicEvaluatedExpression;
          return res.setNumber(~argument.number), res.setRange(expr.range), res;
        }
      }), this.hooks.evaluateTypeof.for("undefined").tap("Parser", expr => (new BasicEvaluatedExpression).setString("undefined").setRange(expr.range)), 
      this.hooks.evaluate.for("Identifier").tap("Parser", expr => {
        const name = this.scope.renames.get(expr.name) || expr.name;
        if (!this.scope.definitions.has(expr.name)) {
          const hook = this.hooks.evaluateIdentifier.get(name);
          if (void 0 !== hook) {
            const result = hook.call(expr);
            if (result) return result;
          }
          return (new BasicEvaluatedExpression).setIdentifier(name).setRange(expr.range);
        }
        {
          const hook = this.hooks.evaluateDefinedIdentifier.get(name);
          if (void 0 !== hook) return hook.call(expr);
        }
      }), this.hooks.evaluate.for("ThisExpression").tap("Parser", expr => {
        const name = this.scope.renames.get("this");
        if (name) {
          const hook = this.hooks.evaluateIdentifier.get(name);
          if (void 0 !== hook) {
            const result = hook.call(expr);
            if (result) return result;
          }
          return (new BasicEvaluatedExpression).setIdentifier(name).setRange(expr.range);
        }
      }), this.hooks.evaluate.for("MemberExpression").tap("Parser", expression => {
        let exprName = this.getNameForExpression(expression);
        if (exprName) {
          if (exprName.free) {
            const hook = this.hooks.evaluateIdentifier.get(exprName.name);
            if (void 0 !== hook) {
              const result = hook.call(expression);
              if (result) return result;
            }
            return (new BasicEvaluatedExpression).setIdentifier(exprName.name).setRange(expression.range);
          }
          {
            const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);
            if (void 0 !== hook) return hook.call(expression);
          }
        }
      }), this.hooks.evaluate.for("CallExpression").tap("Parser", expr => {
        if ("MemberExpression" !== expr.callee.type) return;
        if (expr.callee.property.type !== (expr.callee.computed ? "Literal" : "Identifier")) return;
        const param = this.evaluateExpression(expr.callee.object);
        if (!param) return;
        const property = expr.callee.property.name || expr.callee.property.value, hook = this.hooks.evaluateCallExpressionMember.get(property);
        return void 0 !== hook ? hook.call(expr, param) : void 0;
      }), this.hooks.evaluateCallExpressionMember.for("replace").tap("Parser", (expr, param) => {
        if (!param.isString()) return;
        if (2 !== expr.arguments.length) return;
        let arg1 = this.evaluateExpression(expr.arguments[0]), arg2 = this.evaluateExpression(expr.arguments[1]);
        return (arg1.isString() || arg1.isRegExp()) && (arg1 = arg1.regExp || arg1.string, 
        arg2.isString()) ? (arg2 = arg2.string, (new BasicEvaluatedExpression).setString(param.string.replace(arg1, arg2)).setRange(expr.range)) : void 0;
      }), [ "substr", "substring" ].forEach(fn => {
        this.hooks.evaluateCallExpressionMember.for(fn).tap("Parser", (expr, param) => {
          if (!param.isString()) return;
          let arg1, result, str = param.string;
          switch (expr.arguments.length) {
           case 1:
            if (arg1 = this.evaluateExpression(expr.arguments[0]), !arg1.isNumber()) return;
            result = str[fn](arg1.number);
            break;

           case 2:
            {
              arg1 = this.evaluateExpression(expr.arguments[0]);
              const arg2 = this.evaluateExpression(expr.arguments[1]);
              if (!arg1.isNumber()) return;
              if (!arg2.isNumber()) return;
              result = str[fn](arg1.number, arg2.number);
              break;
            }

           default:
            return;
          }
          return (new BasicEvaluatedExpression).setString(result).setRange(expr.range);
        });
      });
      const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
        const quasis = [], parts = [];
        for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
          const quasiExpr = templateLiteralExpr.quasis[i], quasi = quasiExpr.value[kind];
          if (i > 0) {
            const prevExpr = parts[parts.length - 1], expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]), exprAsString = expr.asString();
            if ("string" == typeof exprAsString) {
              prevExpr.setString(prevExpr.string + exprAsString + quasi), prevExpr.setRange([ prevExpr.range[0], quasiExpr.range[1] ]), 
              prevExpr.setExpression(void 0);
              continue;
            }
            parts.push(expr);
          }
          const part = (new BasicEvaluatedExpression).setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);
          quasis.push(part), parts.push(part);
        }
        return {
          quasis: quasis,
          parts: parts
        };
      };
      this.hooks.evaluate.for("TemplateLiteral").tap("Parser", node => {
        const {quasis: quasis, parts: parts} = getSimplifiedTemplateResult("cooked", node);
        return 1 === parts.length ? parts[0].setRange(node.range) : (new BasicEvaluatedExpression).setTemplateString(quasis, parts, "cooked").setRange(node.range);
      }), this.hooks.evaluate.for("TaggedTemplateExpression").tap("Parser", node => {
        if ("String.raw" !== this.evaluateExpression(node.tag).identifier) return;
        const {quasis: quasis, parts: parts} = getSimplifiedTemplateResult("raw", node.quasi);
        return 1 === parts.length ? parts[0].setRange(node.range) : (new BasicEvaluatedExpression).setTemplateString(quasis, parts, "raw").setRange(node.range);
      }), this.hooks.evaluateCallExpressionMember.for("concat").tap("Parser", (expr, param) => {
        if (!param.isString() && !param.isWrapped()) return;
        let stringSuffix = null, hasUnknownParams = !1;
        for (let i = expr.arguments.length - 1; i >= 0; i--) {
          const argExpr = this.evaluateExpression(expr.arguments[i]);
          if (!argExpr.isString() && !argExpr.isNumber()) {
            hasUnknownParams = !0;
            break;
          }
          const newString = (argExpr.isString() ? argExpr.string : "" + argExpr.number) + (stringSuffix ? stringSuffix.string : ""), newRange = [ argExpr.range[0], (stringSuffix || argExpr).range[1] ];
          stringSuffix = (new BasicEvaluatedExpression).setString(newString).setRange(newRange);
        }
        if (hasUnknownParams) {
          const prefix = param.isString() ? param : param.prefix;
          return (new BasicEvaluatedExpression).setWrapped(prefix, stringSuffix).setRange(expr.range);
        }
        if (param.isWrapped()) {
          const postfix = stringSuffix || param.postfix;
          return (new BasicEvaluatedExpression).setWrapped(param.prefix, postfix).setRange(expr.range);
        }
        {
          const newString = param.string + (stringSuffix ? stringSuffix.string : "");
          return (new BasicEvaluatedExpression).setString(newString).setRange(expr.range);
        }
      }), this.hooks.evaluateCallExpressionMember.for("split").tap("Parser", (expr, param) => {
        if (!param.isString()) return;
        if (1 !== expr.arguments.length) return;
        let result;
        const arg = this.evaluateExpression(expr.arguments[0]);
        if (arg.isString()) result = param.string.split(arg.string); else {
          if (!arg.isRegExp()) return;
          result = param.string.split(arg.regExp);
        }
        return (new BasicEvaluatedExpression).setArray(result).setRange(expr.range);
      }), this.hooks.evaluate.for("ConditionalExpression").tap("Parser", expr => {
        const conditionValue = this.evaluateExpression(expr.test).asBool();
        let res;
        if (void 0 === conditionValue) {
          const consequent = this.evaluateExpression(expr.consequent), alternate = this.evaluateExpression(expr.alternate);
          if (!consequent || !alternate) return;
          res = new BasicEvaluatedExpression, consequent.isConditional() ? res.setOptions(consequent.options) : res.setOptions([ consequent ]), 
          alternate.isConditional() ? res.addOptions(alternate.options) : res.addOptions([ alternate ]);
        } else res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);
        return res.setRange(expr.range), res;
      }), this.hooks.evaluate.for("ArrayExpression").tap("Parser", expr => {
        const items = expr.elements.map(element => null !== element && this.evaluateExpression(element));
        if (items.every(Boolean)) return (new BasicEvaluatedExpression).setItems(items).setRange(expr.range);
      });
    }
    getRenameIdentifier(expr) {
      const result = this.evaluateExpression(expr);
      if (result && result.isIdentifier()) return result.identifier;
    }
    walkClass(classy) {
      if (classy.superClass && this.walkExpression(classy.superClass), classy.body && "ClassBody" === classy.body.type) {
        const wasTopLevel = this.scope.topLevelScope;
        this.scope.topLevelScope = !1;
        for (const methodDefinition of classy.body.body) "MethodDefinition" === methodDefinition.type && this.walkMethodDefinition(methodDefinition);
        this.scope.topLevelScope = wasTopLevel;
      }
    }
    walkMethodDefinition(methodDefinition) {
      methodDefinition.computed && methodDefinition.key && this.walkExpression(methodDefinition.key), 
      methodDefinition.value && this.walkExpression(methodDefinition.value);
    }
    prewalkStatements(statements) {
      for (let index = 0, len = statements.length; index < len; index++) {
        const statement = statements[index];
        this.prewalkStatement(statement);
      }
    }
    blockPrewalkStatements(statements) {
      for (let index = 0, len = statements.length; index < len; index++) {
        const statement = statements[index];
        this.blockPrewalkStatement(statement);
      }
    }
    walkStatements(statements) {
      for (let index = 0, len = statements.length; index < len; index++) {
        const statement = statements[index];
        this.walkStatement(statement);
      }
    }
    prewalkStatement(statement) {
      switch (statement.type) {
       case "BlockStatement":
        this.prewalkBlockStatement(statement);
        break;

       case "DoWhileStatement":
        this.prewalkDoWhileStatement(statement);
        break;

       case "ExportAllDeclaration":
        this.prewalkExportAllDeclaration(statement);
        break;

       case "ExportDefaultDeclaration":
        this.prewalkExportDefaultDeclaration(statement);
        break;

       case "ExportNamedDeclaration":
        this.prewalkExportNamedDeclaration(statement);
        break;

       case "ForInStatement":
        this.prewalkForInStatement(statement);
        break;

       case "ForOfStatement":
        this.prewalkForOfStatement(statement);
        break;

       case "ForStatement":
        this.prewalkForStatement(statement);
        break;

       case "FunctionDeclaration":
        this.prewalkFunctionDeclaration(statement);
        break;

       case "IfStatement":
        this.prewalkIfStatement(statement);
        break;

       case "ImportDeclaration":
        this.prewalkImportDeclaration(statement);
        break;

       case "LabeledStatement":
        this.prewalkLabeledStatement(statement);
        break;

       case "SwitchStatement":
        this.prewalkSwitchStatement(statement);
        break;

       case "TryStatement":
        this.prewalkTryStatement(statement);
        break;

       case "VariableDeclaration":
        this.prewalkVariableDeclaration(statement);
        break;

       case "WhileStatement":
        this.prewalkWhileStatement(statement);
        break;

       case "WithStatement":
        this.prewalkWithStatement(statement);
      }
    }
    blockPrewalkStatement(statement) {
      switch (statement.type) {
       case "VariableDeclaration":
        this.blockPrewalkVariableDeclaration(statement);
        break;

       case "ExportDefaultDeclaration":
        this.blockPrewalkExportDefaultDeclaration(statement);
        break;

       case "ExportNamedDeclaration":
        this.blockPrewalkExportNamedDeclaration(statement);
        break;

       case "ClassDeclaration":
        this.blockPrewalkClassDeclaration(statement);
      }
    }
    walkStatement(statement) {
      if (void 0 === this.hooks.statement.call(statement)) switch (statement.type) {
       case "BlockStatement":
        this.walkBlockStatement(statement);
        break;

       case "ClassDeclaration":
        this.walkClassDeclaration(statement);
        break;

       case "DoWhileStatement":
        this.walkDoWhileStatement(statement);
        break;

       case "ExportDefaultDeclaration":
        this.walkExportDefaultDeclaration(statement);
        break;

       case "ExportNamedDeclaration":
        this.walkExportNamedDeclaration(statement);
        break;

       case "ExpressionStatement":
        this.walkExpressionStatement(statement);
        break;

       case "ForInStatement":
        this.walkForInStatement(statement);
        break;

       case "ForOfStatement":
        this.walkForOfStatement(statement);
        break;

       case "ForStatement":
        this.walkForStatement(statement);
        break;

       case "FunctionDeclaration":
        this.walkFunctionDeclaration(statement);
        break;

       case "IfStatement":
        this.walkIfStatement(statement);
        break;

       case "LabeledStatement":
        this.walkLabeledStatement(statement);
        break;

       case "ReturnStatement":
        this.walkReturnStatement(statement);
        break;

       case "SwitchStatement":
        this.walkSwitchStatement(statement);
        break;

       case "ThrowStatement":
        this.walkThrowStatement(statement);
        break;

       case "TryStatement":
        this.walkTryStatement(statement);
        break;

       case "VariableDeclaration":
        this.walkVariableDeclaration(statement);
        break;

       case "WhileStatement":
        this.walkWhileStatement(statement);
        break;

       case "WithStatement":
        this.walkWithStatement(statement);
      }
    }
    prewalkBlockStatement(statement) {
      this.prewalkStatements(statement.body);
    }
    walkBlockStatement(statement) {
      this.inBlockScope(() => {
        const body = statement.body;
        this.blockPrewalkStatements(body), this.walkStatements(body);
      });
    }
    walkExpressionStatement(statement) {
      this.walkExpression(statement.expression);
    }
    prewalkIfStatement(statement) {
      this.prewalkStatement(statement.consequent), statement.alternate && this.prewalkStatement(statement.alternate);
    }
    walkIfStatement(statement) {
      const result = this.hooks.statementIf.call(statement);
      void 0 === result ? (this.walkExpression(statement.test), this.walkStatement(statement.consequent), 
      statement.alternate && this.walkStatement(statement.alternate)) : result ? this.walkStatement(statement.consequent) : statement.alternate && this.walkStatement(statement.alternate);
    }
    prewalkLabeledStatement(statement) {
      this.prewalkStatement(statement.body);
    }
    walkLabeledStatement(statement) {
      const hook = this.hooks.label.get(statement.label.name);
      if (void 0 !== hook) {
        if (!0 === hook.call(statement)) return;
      }
      this.walkStatement(statement.body);
    }
    prewalkWithStatement(statement) {
      this.prewalkStatement(statement.body);
    }
    walkWithStatement(statement) {
      this.walkExpression(statement.object), this.walkStatement(statement.body);
    }
    prewalkSwitchStatement(statement) {
      this.prewalkSwitchCases(statement.cases);
    }
    walkSwitchStatement(statement) {
      this.walkExpression(statement.discriminant), this.walkSwitchCases(statement.cases);
    }
    walkTerminatingStatement(statement) {
      statement.argument && this.walkExpression(statement.argument);
    }
    walkReturnStatement(statement) {
      this.walkTerminatingStatement(statement);
    }
    walkThrowStatement(statement) {
      this.walkTerminatingStatement(statement);
    }
    prewalkTryStatement(statement) {
      this.prewalkStatement(statement.block);
    }
    walkTryStatement(statement) {
      this.scope.inTry ? this.walkStatement(statement.block) : (this.scope.inTry = !0, 
      this.walkStatement(statement.block), this.scope.inTry = !1), statement.handler && this.walkCatchClause(statement.handler), 
      statement.finalizer && this.walkStatement(statement.finalizer);
    }
    prewalkWhileStatement(statement) {
      this.prewalkStatement(statement.body);
    }
    walkWhileStatement(statement) {
      this.walkExpression(statement.test), this.walkStatement(statement.body);
    }
    prewalkDoWhileStatement(statement) {
      this.prewalkStatement(statement.body);
    }
    walkDoWhileStatement(statement) {
      this.walkStatement(statement.body), this.walkExpression(statement.test);
    }
    prewalkForStatement(statement) {
      statement.init && "VariableDeclaration" === statement.init.type && this.prewalkStatement(statement.init), 
      this.prewalkStatement(statement.body);
    }
    walkForStatement(statement) {
      this.inBlockScope(() => {
        statement.init && ("VariableDeclaration" === statement.init.type ? (this.blockPrewalkVariableDeclaration(statement.init), 
        this.walkStatement(statement.init)) : this.walkExpression(statement.init)), statement.test && this.walkExpression(statement.test), 
        statement.update && this.walkExpression(statement.update);
        const body = statement.body;
        "BlockStatement" === body.type ? (this.blockPrewalkStatements(body.body), this.walkStatements(body.body)) : this.walkStatement(body);
      });
    }
    prewalkForInStatement(statement) {
      "VariableDeclaration" === statement.left.type && this.prewalkVariableDeclaration(statement.left), 
      this.prewalkStatement(statement.body);
    }
    walkForInStatement(statement) {
      this.inBlockScope(() => {
        "VariableDeclaration" === statement.left.type ? (this.blockPrewalkVariableDeclaration(statement.left), 
        this.walkVariableDeclaration(statement.left)) : this.walkPattern(statement.left), 
        this.walkExpression(statement.right);
        const body = statement.body;
        "BlockStatement" === body.type ? (this.blockPrewalkStatements(body.body), this.walkStatements(body.body)) : this.walkStatement(body);
      });
    }
    prewalkForOfStatement(statement) {
      "VariableDeclaration" === statement.left.type && this.prewalkVariableDeclaration(statement.left), 
      this.prewalkStatement(statement.body);
    }
    walkForOfStatement(statement) {
      this.inBlockScope(() => {
        "VariableDeclaration" === statement.left.type ? (this.blockPrewalkVariableDeclaration(statement.left), 
        this.walkVariableDeclaration(statement.left)) : this.walkPattern(statement.left), 
        this.walkExpression(statement.right);
        const body = statement.body;
        "BlockStatement" === body.type ? (this.blockPrewalkStatements(body.body), this.walkStatements(body.body)) : this.walkStatement(body);
      });
    }
    prewalkFunctionDeclaration(statement) {
      statement.id && (this.scope.renames.set(statement.id.name, null), this.scope.definitions.add(statement.id.name));
    }
    walkFunctionDeclaration(statement) {
      const wasTopLevel = this.scope.topLevelScope;
      this.scope.topLevelScope = !1, this.inFunctionScope(!0, statement.params, () => {
        for (const param of statement.params) this.walkPattern(param);
        "BlockStatement" === statement.body.type ? (this.detectMode(statement.body.body), 
        this.prewalkStatement(statement.body), this.walkStatement(statement.body)) : this.walkExpression(statement.body);
      }), this.scope.topLevelScope = wasTopLevel;
    }
    prewalkImportDeclaration(statement) {
      const source = statement.source.value;
      this.hooks.import.call(statement, source);
      for (const specifier of statement.specifiers) {
        const name = specifier.local.name;
        switch (this.scope.renames.set(name, null), this.scope.definitions.add(name), specifier.type) {
         case "ImportDefaultSpecifier":
          this.hooks.importSpecifier.call(statement, source, "default", name);
          break;

         case "ImportSpecifier":
          this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);
          break;

         case "ImportNamespaceSpecifier":
          this.hooks.importSpecifier.call(statement, source, null, name);
        }
      }
    }
    enterDeclaration(declaration, onIdent) {
      switch (declaration.type) {
       case "VariableDeclaration":
        for (const declarator of declaration.declarations) switch (declarator.type) {
         case "VariableDeclarator":
          this.enterPattern(declarator.id, onIdent);
        }
        break;

       case "FunctionDeclaration":
       case "ClassDeclaration":
        this.enterPattern(declaration.id, onIdent);
      }
    }
    blockPrewalkExportNamedDeclaration(statement) {
      statement.declaration && this.blockPrewalkStatement(statement.declaration);
    }
    prewalkExportNamedDeclaration(statement) {
      let source;
      if (statement.source ? (source = statement.source.value, this.hooks.exportImport.call(statement, source)) : this.hooks.export.call(statement), 
      statement.declaration && !this.hooks.exportDeclaration.call(statement, statement.declaration)) {
        this.prewalkStatement(statement.declaration);
        let index = 0;
        this.enterDeclaration(statement.declaration, def => {
          this.hooks.exportSpecifier.call(statement, def, def, index++);
        });
      }
      if (statement.specifiers) for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {
        const specifier = statement.specifiers[specifierIndex];
        switch (specifier.type) {
         case "ExportSpecifier":
          {
            const name = specifier.exported.name;
            source ? this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex) : this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);
            break;
          }
        }
      }
    }
    walkExportNamedDeclaration(statement) {
      statement.declaration && this.walkStatement(statement.declaration);
    }
    blockPrewalkExportDefaultDeclaration(statement) {
      "ClassDeclaration" === statement.declaration.type && this.blockPrewalkClassDeclaration(statement.declaration);
    }
    prewalkExportDefaultDeclaration(statement) {
      this.prewalkStatement(statement.declaration), statement.declaration.id && "FunctionExpression" !== statement.declaration.type && "ClassExpression" !== statement.declaration.type && this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, "default");
    }
    walkExportDefaultDeclaration(statement) {
      this.hooks.export.call(statement), statement.declaration.id && "FunctionExpression" !== statement.declaration.type && "ClassExpression" !== statement.declaration.type ? this.hooks.exportDeclaration.call(statement, statement.declaration) || this.walkStatement(statement.declaration) : ("FunctionDeclaration" === statement.declaration.type ? this.walkFunctionDeclaration(statement.declaration) : "ClassDeclaration" === statement.declaration.type ? this.walkClassDeclaration(statement.declaration) : this.walkExpression(statement.declaration), 
      this.hooks.exportExpression.call(statement, statement.declaration) || this.hooks.exportSpecifier.call(statement, statement.declaration, "default"));
    }
    prewalkExportAllDeclaration(statement) {
      const source = statement.source.value;
      this.hooks.exportImport.call(statement, source), this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);
    }
    prewalkVariableDeclaration(statement) {
      "var" === statement.kind && this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);
    }
    blockPrewalkVariableDeclaration(statement) {
      if ("var" === statement.kind) return;
      const hookMap = "const" === statement.kind ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;
      this._prewalkVariableDeclaration(statement, hookMap);
    }
    _prewalkVariableDeclaration(statement, hookMap) {
      for (const declarator of statement.declarations) switch (declarator.type) {
       case "VariableDeclarator":
        this.enterPattern(declarator.id, (name, decl) => {
          let hook = hookMap.get(name);
          void 0 !== hook && hook.call(decl) || (hook = this.hooks.varDeclaration.get(name), 
          void 0 !== hook && hook.call(decl) || (this.scope.renames.set(name, null), this.scope.definitions.add(name)));
        });
      }
    }
    walkVariableDeclaration(statement) {
      for (const declarator of statement.declarations) switch (declarator.type) {
       case "VariableDeclarator":
        {
          const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);
          if (renameIdentifier && "Identifier" === declarator.id.type) {
            const hook = this.hooks.canRename.get(renameIdentifier);
            if (void 0 !== hook && hook.call(declarator.init)) {
              const hook = this.hooks.rename.get(renameIdentifier);
              void 0 !== hook && hook.call(declarator.init) || (this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier), 
              this.scope.definitions.delete(declarator.id.name));
              break;
            }
          }
          this.walkPattern(declarator.id), declarator.init && this.walkExpression(declarator.init);
          break;
        }
      }
    }
    blockPrewalkClassDeclaration(statement) {
      statement.id && (this.scope.renames.set(statement.id.name, null), this.scope.definitions.add(statement.id.name));
    }
    walkClassDeclaration(statement) {
      this.walkClass(statement);
    }
    prewalkSwitchCases(switchCases) {
      for (let index = 0, len = switchCases.length; index < len; index++) {
        const switchCase = switchCases[index];
        this.prewalkStatements(switchCase.consequent);
      }
    }
    walkSwitchCases(switchCases) {
      for (let index = 0, len = switchCases.length; index < len; index++) {
        const switchCase = switchCases[index];
        switchCase.test && this.walkExpression(switchCase.test), this.walkStatements(switchCase.consequent);
      }
    }
    walkCatchClause(catchClause) {
      this.inBlockScope(() => {
        null !== catchClause.param && (this.enterPattern(catchClause.param, ident => {
          this.scope.renames.set(ident, null), this.scope.definitions.add(ident);
        }), this.walkPattern(catchClause.param)), this.prewalkStatement(catchClause.body), 
        this.walkStatement(catchClause.body);
      });
    }
    walkPattern(pattern) {
      switch (pattern.type) {
       case "ArrayPattern":
        this.walkArrayPattern(pattern);
        break;

       case "AssignmentPattern":
        this.walkAssignmentPattern(pattern);
        break;

       case "MemberExpression":
        this.walkMemberExpression(pattern);
        break;

       case "ObjectPattern":
        this.walkObjectPattern(pattern);
        break;

       case "RestElement":
        this.walkRestElement(pattern);
      }
    }
    walkAssignmentPattern(pattern) {
      this.walkExpression(pattern.right), this.walkPattern(pattern.left);
    }
    walkObjectPattern(pattern) {
      for (let i = 0, len = pattern.properties.length; i < len; i++) {
        const prop = pattern.properties[i];
        prop && (prop.computed && this.walkExpression(prop.key), prop.value && this.walkPattern(prop.value));
      }
    }
    walkArrayPattern(pattern) {
      for (let i = 0, len = pattern.elements.length; i < len; i++) {
        const element = pattern.elements[i];
        element && this.walkPattern(element);
      }
    }
    walkRestElement(pattern) {
      this.walkPattern(pattern.argument);
    }
    walkExpressions(expressions) {
      for (const expression of expressions) expression && this.walkExpression(expression);
    }
    walkExpression(expression) {
      switch (expression.type) {
       case "ArrayExpression":
        this.walkArrayExpression(expression);
        break;

       case "ArrowFunctionExpression":
        this.walkArrowFunctionExpression(expression);
        break;

       case "AssignmentExpression":
        this.walkAssignmentExpression(expression);
        break;

       case "AwaitExpression":
        this.walkAwaitExpression(expression);
        break;

       case "BinaryExpression":
        this.walkBinaryExpression(expression);
        break;

       case "CallExpression":
        this.walkCallExpression(expression);
        break;

       case "ClassExpression":
        this.walkClassExpression(expression);
        break;

       case "ConditionalExpression":
        this.walkConditionalExpression(expression);
        break;

       case "FunctionExpression":
        this.walkFunctionExpression(expression);
        break;

       case "Identifier":
        this.walkIdentifier(expression);
        break;

       case "LogicalExpression":
        this.walkLogicalExpression(expression);
        break;

       case "MemberExpression":
        this.walkMemberExpression(expression);
        break;

       case "NewExpression":
        this.walkNewExpression(expression);
        break;

       case "ObjectExpression":
        this.walkObjectExpression(expression);
        break;

       case "SequenceExpression":
        this.walkSequenceExpression(expression);
        break;

       case "SpreadElement":
        this.walkSpreadElement(expression);
        break;

       case "TaggedTemplateExpression":
        this.walkTaggedTemplateExpression(expression);
        break;

       case "TemplateLiteral":
        this.walkTemplateLiteral(expression);
        break;

       case "ThisExpression":
        this.walkThisExpression(expression);
        break;

       case "UnaryExpression":
        this.walkUnaryExpression(expression);
        break;

       case "UpdateExpression":
        this.walkUpdateExpression(expression);
        break;

       case "YieldExpression":
        this.walkYieldExpression(expression);
      }
    }
    walkAwaitExpression(expression) {
      this.walkExpression(expression.argument);
    }
    walkArrayExpression(expression) {
      expression.elements && this.walkExpressions(expression.elements);
    }
    walkSpreadElement(expression) {
      expression.argument && this.walkExpression(expression.argument);
    }
    walkObjectExpression(expression) {
      for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {
        const prop = expression.properties[propIndex];
        "SpreadElement" !== prop.type ? (prop.computed && this.walkExpression(prop.key), 
        prop.shorthand && (this.scope.inShorthand = !0), this.walkExpression(prop.value), 
        prop.shorthand && (this.scope.inShorthand = !1)) : this.walkExpression(prop.argument);
      }
    }
    walkFunctionExpression(expression) {
      const wasTopLevel = this.scope.topLevelScope;
      this.scope.topLevelScope = !1;
      const scopeParams = expression.params;
      expression.id && scopeParams.push(expression.id.name), this.inFunctionScope(!0, scopeParams, () => {
        for (const param of expression.params) this.walkPattern(param);
        "BlockStatement" === expression.body.type ? (this.detectMode(expression.body.body), 
        this.prewalkStatement(expression.body), this.walkStatement(expression.body)) : this.walkExpression(expression.body);
      }), this.scope.topLevelScope = wasTopLevel;
    }
    walkArrowFunctionExpression(expression) {
      this.inFunctionScope(!1, expression.params, () => {
        for (const param of expression.params) this.walkPattern(param);
        "BlockStatement" === expression.body.type ? (this.detectMode(expression.body.body), 
        this.prewalkStatement(expression.body), this.walkStatement(expression.body)) : this.walkExpression(expression.body);
      });
    }
    walkSequenceExpression(expression) {
      expression.expressions && this.walkExpressions(expression.expressions);
    }
    walkUpdateExpression(expression) {
      this.walkExpression(expression.argument);
    }
    walkUnaryExpression(expression) {
      if ("typeof" === expression.operator) {
        const exprName = this.getNameForExpression(expression.argument);
        if (exprName && exprName.free) {
          const hook = this.hooks.typeof.get(exprName.name);
          if (void 0 !== hook) {
            if (!0 === hook.call(expression)) return;
          }
        }
      }
      this.walkExpression(expression.argument);
    }
    walkLeftRightExpression(expression) {
      this.walkExpression(expression.left), this.walkExpression(expression.right);
    }
    walkBinaryExpression(expression) {
      this.walkLeftRightExpression(expression);
    }
    walkLogicalExpression(expression) {
      const result = this.hooks.expressionLogicalOperator.call(expression);
      void 0 === result ? this.walkLeftRightExpression(expression) : result && this.walkExpression(expression.right);
    }
    walkAssignmentExpression(expression) {
      const renameIdentifier = this.getRenameIdentifier(expression.right);
      if ("Identifier" === expression.left.type && renameIdentifier) {
        const hook = this.hooks.canRename.get(renameIdentifier);
        if (void 0 !== hook && hook.call(expression.right)) {
          const hook = this.hooks.rename.get(renameIdentifier);
          return void (void 0 !== hook && hook.call(expression.right) || (this.scope.renames.set(expression.left.name, renameIdentifier), 
          this.scope.definitions.delete(expression.left.name)));
        }
      }
      if ("Identifier" !== expression.left.type) this.walkExpression(expression.right), 
      this.walkPattern(expression.left), this.enterPattern(expression.left, (name, decl) => {
        this.scope.renames.set(name, null);
      }); else {
        const assignedHook = this.hooks.assigned.get(expression.left.name);
        void 0 !== assignedHook && assignedHook.call(expression) || this.walkExpression(expression.right), 
        this.scope.renames.set(expression.left.name, null);
        const assignHook = this.hooks.assign.get(expression.left.name);
        void 0 !== assignHook && assignHook.call(expression) || this.walkExpression(expression.left);
      }
    }
    walkConditionalExpression(expression) {
      const result = this.hooks.expressionConditionalOperator.call(expression);
      void 0 === result ? (this.walkExpression(expression.test), this.walkExpression(expression.consequent), 
      expression.alternate && this.walkExpression(expression.alternate)) : result ? this.walkExpression(expression.consequent) : expression.alternate && this.walkExpression(expression.alternate);
    }
    walkNewExpression(expression) {
      const callee = this.evaluateExpression(expression.callee);
      if (callee.isIdentifier()) {
        const hook = this.hooks.new.get(callee.identifier);
        if (void 0 !== hook) {
          if (!0 === hook.call(expression)) return;
        }
      }
      this.walkExpression(expression.callee), expression.arguments && this.walkExpressions(expression.arguments);
    }
    walkYieldExpression(expression) {
      expression.argument && this.walkExpression(expression.argument);
    }
    walkTemplateLiteral(expression) {
      expression.expressions && this.walkExpressions(expression.expressions);
    }
    walkTaggedTemplateExpression(expression) {
      expression.tag && this.walkExpression(expression.tag), expression.quasi && expression.quasi.expressions && this.walkExpressions(expression.quasi.expressions);
    }
    walkClassExpression(expression) {
      this.walkClass(expression);
    }
    _walkIIFE(functionExpression, options, currentThis) {
      const renameArgOrThis = argOrThis => {
        const renameIdentifier = this.getRenameIdentifier(argOrThis);
        if (renameIdentifier) {
          const hook = this.hooks.canRename.get(renameIdentifier);
          if (void 0 !== hook && hook.call(argOrThis)) {
            const hook = this.hooks.rename.get(renameIdentifier);
            if (void 0 === hook || !hook.call(argOrThis)) return renameIdentifier;
          }
        }
        this.walkExpression(argOrThis);
      }, params = functionExpression.params, renameThis = currentThis ? renameArgOrThis(currentThis) : null, args = options.map(renameArgOrThis), wasTopLevel = this.scope.topLevelScope;
      this.scope.topLevelScope = !1;
      const scopeParams = params.filter((identifier, idx) => !args[idx]);
      functionExpression.id && scopeParams.push(functionExpression.id.name), this.inFunctionScope(!0, scopeParams, () => {
        renameThis && this.scope.renames.set("this", renameThis);
        for (let i = 0; i < args.length; i++) {
          const param = args[i];
          param && (params[i] && "Identifier" === params[i].type && this.scope.renames.set(params[i].name, param));
        }
        "BlockStatement" === functionExpression.body.type ? (this.detectMode(functionExpression.body.body), 
        this.prewalkStatement(functionExpression.body), this.walkStatement(functionExpression.body)) : this.walkExpression(functionExpression.body);
      }), this.scope.topLevelScope = wasTopLevel;
    }
    walkCallExpression(expression) {
      if ("MemberExpression" === expression.callee.type && "FunctionExpression" === expression.callee.object.type && !expression.callee.computed && ("call" === expression.callee.property.name || "bind" === expression.callee.property.name) && expression.arguments.length > 0) this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]); else if ("FunctionExpression" === expression.callee.type) this._walkIIFE(expression.callee, expression.arguments, null); else if ("Import" === expression.callee.type) {
        if (!0 === this.hooks.importCall.call(expression)) return;
        expression.arguments && this.walkExpressions(expression.arguments);
      } else {
        const callee = this.evaluateExpression(expression.callee);
        if (callee.isIdentifier()) {
          const callHook = this.hooks.call.get(callee.identifier);
          if (void 0 !== callHook) {
            if (!0 === callHook.call(expression)) return;
          }
          let identifier = callee.identifier.replace(/\.[^.]+$/, "");
          if (identifier !== callee.identifier) {
            const callAnyHook = this.hooks.callAnyMember.get(identifier);
            if (void 0 !== callAnyHook) {
              if (!0 === callAnyHook.call(expression)) return;
            }
          }
        }
        expression.callee && this.walkExpression(expression.callee), expression.arguments && this.walkExpressions(expression.arguments);
      }
    }
    walkMemberExpression(expression) {
      const exprName = this.getNameForExpression(expression);
      if (exprName && exprName.free) {
        const expressionHook = this.hooks.expression.get(exprName.name);
        if (void 0 !== expressionHook) {
          if (!0 === expressionHook.call(expression)) return;
        }
        const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);
        if (void 0 !== expressionAnyMemberHook) {
          if (!0 === expressionAnyMemberHook.call(expression)) return;
        }
      }
      this.walkExpression(expression.object), !0 === expression.computed && this.walkExpression(expression.property);
    }
    walkThisExpression(expression) {
      const expressionHook = this.hooks.expression.get("this");
      void 0 !== expressionHook && expressionHook.call(expression);
    }
    walkIdentifier(expression) {
      if (!this.scope.definitions.has(expression.name)) {
        const hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);
        if (void 0 !== hook) {
          if (!0 === hook.call(expression)) return;
        }
      }
    }
    inScope(params, fn) {
      const oldScope = this.scope;
      this.scope = {
        topLevelScope: oldScope.topLevelScope,
        inTry: !1,
        inShorthand: !1,
        isStrict: oldScope.isStrict,
        isAsmJs: oldScope.isAsmJs,
        definitions: oldScope.definitions.createChild(),
        renames: oldScope.renames.createChild()
      }, this.scope.renames.set("this", null), this.enterPatterns(params, ident => {
        this.scope.renames.set(ident, null), this.scope.definitions.add(ident);
      }), fn(), this.scope = oldScope;
    }
    inFunctionScope(hasThis, params, fn) {
      const oldScope = this.scope;
      this.scope = {
        topLevelScope: oldScope.topLevelScope,
        inTry: !1,
        inShorthand: !1,
        isStrict: oldScope.isStrict,
        isAsmJs: oldScope.isAsmJs,
        definitions: oldScope.definitions.createChild(),
        renames: oldScope.renames.createChild()
      }, hasThis && this.scope.renames.set("this", null), this.enterPatterns(params, ident => {
        this.scope.renames.set(ident, null), this.scope.definitions.add(ident);
      }), fn(), this.scope = oldScope;
    }
    inBlockScope(fn) {
      const oldScope = this.scope;
      this.scope = {
        topLevelScope: oldScope.topLevelScope,
        inTry: oldScope.inTry,
        inShorthand: !1,
        isStrict: oldScope.isStrict,
        isAsmJs: oldScope.isAsmJs,
        definitions: oldScope.definitions.createChild(),
        renames: oldScope.renames.createChild()
      }, fn(), this.scope = oldScope;
    }
    detectStrictMode(statements) {
      this.detectMode(statements);
    }
    detectMode(statements) {
      const isLiteral = statements.length >= 1 && "ExpressionStatement" === statements[0].type && "Literal" === statements[0].expression.type;
      isLiteral && "use strict" === statements[0].expression.value && (this.scope.isStrict = !0), 
      isLiteral && "use asm" === statements[0].expression.value && (this.scope.isAsmJs = !0);
    }
    enterPatterns(patterns, onIdent) {
      for (const pattern of patterns) "string" != typeof pattern ? this.enterPattern(pattern, onIdent) : pattern && onIdent(pattern);
    }
    enterPattern(pattern, onIdent) {
      if (pattern) switch (pattern.type) {
       case "ArrayPattern":
        this.enterArrayPattern(pattern, onIdent);
        break;

       case "AssignmentPattern":
        this.enterAssignmentPattern(pattern, onIdent);
        break;

       case "Identifier":
        this.enterIdentifier(pattern, onIdent);
        break;

       case "ObjectPattern":
        this.enterObjectPattern(pattern, onIdent);
        break;

       case "RestElement":
        this.enterRestElement(pattern, onIdent);
        break;

       case "Property":
        this.enterPattern(pattern.value, onIdent);
      }
    }
    enterIdentifier(pattern, onIdent) {
      onIdent(pattern.name, pattern);
    }
    enterObjectPattern(pattern, onIdent) {
      for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {
        const prop = pattern.properties[propIndex];
        this.enterPattern(prop, onIdent);
      }
    }
    enterArrayPattern(pattern, onIdent) {
      for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {
        const element = pattern.elements[elementIndex];
        this.enterPattern(element, onIdent);
      }
    }
    enterRestElement(pattern, onIdent) {
      this.enterPattern(pattern.argument, onIdent);
    }
    enterAssignmentPattern(pattern, onIdent) {
      this.enterPattern(pattern.left, onIdent);
    }
    evaluateExpression(expression) {
      try {
        const hook = this.hooks.evaluate.get(expression.type);
        if (void 0 !== hook) {
          const result = hook.call(expression);
          if (void 0 !== result) return result && result.setExpression(expression), result;
        }
      } catch (e) {
        console.warn(e);
      }
      return (new BasicEvaluatedExpression).setRange(expression.range).setExpression(expression);
    }
    parseString(expression) {
      switch (expression.type) {
       case "BinaryExpression":
        if ("+" === expression.operator) return this.parseString(expression.left) + this.parseString(expression.right);
        break;

       case "Literal":
        return expression.value + "";
      }
      throw new Error(expression.type + " is not supported as parameter for require");
    }
    parseCalculatedString(expression) {
      switch (expression.type) {
       case "BinaryExpression":
        if ("+" === expression.operator) {
          const left = this.parseCalculatedString(expression.left), right = this.parseCalculatedString(expression.right);
          return left.code ? {
            range: left.range,
            value: left.value,
            code: !0,
            conditional: !1
          } : right.code ? {
            range: [ left.range[0], right.range ? right.range[1] : left.range[1] ],
            value: left.value + right.value,
            code: !0,
            conditional: !1
          } : {
            range: [ left.range[0], right.range[1] ],
            value: left.value + right.value,
            code: !1,
            conditional: !1
          };
        }
        break;

       case "ConditionalExpression":
        {
          const consequent = this.parseCalculatedString(expression.consequent), alternate = this.parseCalculatedString(expression.alternate), items = [];
          if (consequent.conditional) items.push(...consequent.conditional); else {
            if (consequent.code) break;
            items.push(consequent);
          }
          if (alternate.conditional) items.push(...alternate.conditional); else {
            if (alternate.code) break;
            items.push(alternate);
          }
          return {
            range: void 0,
            value: "",
            code: !0,
            conditional: items
          };
        }

       case "Literal":
        return {
          range: expression.range,
          value: expression.value + "",
          code: !1,
          conditional: !1
        };
      }
      return {
        range: void 0,
        value: "",
        code: !0,
        conditional: !1
      };
    }
    parse(source, initialState) {
      let ast, comments;
      "object" == typeof source && null !== source ? (ast = source, comments = source.comments) : (comments = [], 
      ast = Parser.parse(source, {
        sourceType: this.sourceType,
        onComment: comments
      }));
      const oldScope = this.scope, oldState = this.state, oldComments = this.comments;
      this.scope = {
        topLevelScope: !0,
        inTry: !1,
        inShorthand: !1,
        isStrict: !1,
        isAsmJs: !1,
        definitions: new StackedSetMap,
        renames: new StackedSetMap
      };
      const state = this.state = initialState || {};
      return this.comments = comments, void 0 === this.hooks.program.call(ast, comments) && (this.detectMode(ast.body), 
      this.prewalkStatements(ast.body), this.blockPrewalkStatements(ast.body), this.walkStatements(ast.body)), 
      this.scope = oldScope, this.state = oldState, this.comments = oldComments, state;
    }
    evaluate(source) {
      const ast = Parser.parse("(" + source + ")", {
        sourceType: this.sourceType,
        locations: !1
      });
      if (1 !== ast.body.length || "ExpressionStatement" !== ast.body[0].type) throw new Error("evaluate: Source is not a expression");
      return this.evaluateExpression(ast.body[0].expression);
    }
    getComments(range) {
      return this.comments.filter(comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]);
    }
    parseCommentOptions(range) {
      const comments = this.getComments(range);
      if (0 === comments.length) return EMPTY_COMMENT_OPTIONS;
      let options = {}, errors = [];
      for (const comment of comments) {
        const {value: value} = comment;
        if (value && webpackCommentRegExp.test(value)) try {
          const val = vm.runInNewContext(`(function(){return {${value}};})()`);
          Object.assign(options, val);
        } catch (e) {
          e.comment = comment, errors.push(e);
        }
      }
      return {
        options: options,
        errors: errors
      };
    }
    getNameForExpression(expression) {
      let expr = expression;
      const exprName = [];
      for (;"MemberExpression" === expr.type && expr.property.type === (expr.computed ? "Literal" : "Identifier"); ) exprName.push(expr.computed ? expr.property.value : expr.property.name), 
      expr = expr.object;
      let free;
      if ("Identifier" === expr.type) free = !this.scope.definitions.has(expr.name), exprName.push(this.scope.renames.get(expr.name) || expr.name); else if ("ThisExpression" === expr.type && this.scope.renames.get("this")) free = !0, 
      exprName.push(this.scope.renames.get("this")); else {
        if ("ThisExpression" !== expr.type) return null;
        free = this.scope.topLevelScope, exprName.push("this");
      }
      let prefix = "";
      for (let i = exprName.length - 1; i >= 2; i--) prefix += exprName[i] + ".";
      exprName.length > 1 && (prefix += exprName[1]);
      return {
        name: prefix ? prefix + "." + exprName[0] : exprName[0],
        nameGeneral: prefix,
        free: free
      };
    }
    static parse(code, options) {
      const type = options ? options.sourceType : "module", parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);
      let ast, error;
      "auto" === type ? parserOptions.sourceType = "module" : "script" === parserOptions.sourceType && (parserOptions.allowReturnOutsideFunction = !0);
      let threw = !1;
      try {
        ast = acornParser.parse(code, parserOptions);
      } catch (e) {
        error = e, threw = !0;
      }
      if (threw && "auto" === type) {
        parserOptions.sourceType = "script", parserOptions.allowReturnOutsideFunction = !0, 
        Array.isArray(parserOptions.onComment) && (parserOptions.onComment.length = 0);
        try {
          ast = acornParser.parse(code, parserOptions), threw = !1;
        } catch (e) {
          threw = !0;
        }
      }
      if (threw) throw error;
      return ast;
    }
  }
  Object.defineProperty(Parser.prototype, "getCommentOptions", {
    configurable: !1,
    value: util.deprecate((function(range) {
      return this.parseCommentOptions(range).options;
    }), "Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead")
  }), module.exports = Parser;
}, function(module, exports) {
  module.exports = require("vm");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), TOMBSTONE = {}, UNDEFINED_MARKER = {};
  class StackedSetMap {
    constructor(parentStack) {
      this.stack = void 0 === parentStack ? [] : parentStack.slice(), this.map = new Map, 
      this.stack.push(this.map);
    }
    add(item) {
      this.map.set(item, !0);
    }
    set(item, value) {
      this.map.set(item, void 0 === value ? UNDEFINED_MARKER : value);
    }
    delete(item) {
      this.stack.length > 1 ? this.map.set(item, TOMBSTONE) : this.map.delete(item);
    }
    has(item) {
      const topValue = this.map.get(item);
      if (void 0 !== topValue) return topValue !== TOMBSTONE;
      if (this.stack.length > 1) {
        for (var i = this.stack.length - 2; i >= 0; i--) {
          const value = this.stack[i].get(item);
          if (void 0 !== value) return this.map.set(item, value), value !== TOMBSTONE;
        }
        this.map.set(item, TOMBSTONE);
      }
      return !1;
    }
    get(item) {
      const topValue = this.map.get(item);
      if (void 0 !== topValue) return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? void 0 : topValue;
      if (this.stack.length > 1) {
        for (var i = this.stack.length - 2; i >= 0; i--) {
          const value = this.stack[i].get(item);
          if (void 0 !== value) return this.map.set(item, value), value === TOMBSTONE || value === UNDEFINED_MARKER ? void 0 : value;
        }
        this.map.set(item, TOMBSTONE);
      }
    }
    _compress() {
      if (1 !== this.stack.length) {
        this.map = new Map;
        for (const data of this.stack) for (const pair of data) pair[1] === TOMBSTONE ? this.map.delete(pair[0]) : this.map.set(pair[0], pair[1]);
        this.stack = [ this.map ];
      }
    }
    asArray() {
      return this._compress(), Array.from(this.map.entries(), pair => pair[0]);
    }
    asSet() {
      return new Set(this.asArray());
    }
    asPairArray() {
      return this._compress(), Array.from(this.map.entries(), pair => pair[1] === UNDEFINED_MARKER ? [ pair[0], void 0 ] : pair);
    }
    asMap() {
      return new Map(this.asPairArray());
    }
    get size() {
      return this._compress(), this.map.size;
    }
    createChild() {
      return new StackedSetMap(this.stack);
    }
    get length() {
      throw new Error("This is no longer an Array");
    }
    set length(value) {
      throw new Error("This is no longer an Array");
    }
  }
  StackedSetMap.prototype.push = util.deprecate((function(item) {
    this.add(item);
  }), "This is no longer an Array: Use add instead."), module.exports = StackedSetMap;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(message) {
      super(message), this.name = "UnsupportedWebAssemblyFeatureError", this.hideStack = !0, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports) {
  module.exports = require("../vendor/wasm-parser");
}, function(module, __webpack_exports__, __webpack_require__) {
  "use strict";
  __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "moduleContextFromModuleAST", (function() {
    return moduleContextFromModuleAST;
  })), __webpack_require__.d(__webpack_exports__, "ModuleContext", (function() {
    return ModuleContext;
  }));
  var _webassemblyjs_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
      "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function moduleContextFromModuleAST(m) {
    var moduleContext = new ModuleContext;
    if ("Module" !== m.type) throw new Error('m.type === "Module" error: unknown');
    return m.fields.forEach((function(field) {
      switch (field.type) {
       case "Start":
        moduleContext.setStart(field.index);
        break;

       case "TypeInstruction":
        moduleContext.addType(field);
        break;

       case "Func":
        moduleContext.addFunction(field);
        break;

       case "Global":
        moduleContext.defineGlobal(field);
        break;

       case "ModuleImport":
        switch (field.descr.type) {
         case "GlobalType":
          moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);
          break;

         case "Memory":
          moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);
          break;

         case "FuncImportDescr":
          moduleContext.importFunction(field.descr);
          break;

         case "Table":
          break;

         default:
          throw new Error("Unsupported ModuleImport of type " + JSON.stringify(field.descr.type));
        }
        break;

       case "Memory":
        moduleContext.addMemory(field.limits.min, field.limits.max);
      }
    })), moduleContext;
  }
  var ModuleContext = function() {
    function ModuleContext() {
      !function(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }(this, ModuleContext), this.funcs = [], this.funcsOffsetByIdentifier = [], this.types = [], 
      this.globals = [], this.globalsOffsetByIdentifier = [], this.mems = [], this.locals = [], 
      this.labels = [], this.return = [], this.debugName = "unknown", this.start = null;
    }
    var Constructor, protoProps, staticProps;
    return Constructor = ModuleContext, (protoProps = [ {
      key: "setStart",
      value: function(index) {
        this.start = index.value;
      }
    }, {
      key: "getStart",
      value: function() {
        return this.start;
      }
    }, {
      key: "newContext",
      value: function(debugName, expectedResult) {
        this.locals = [], this.labels = [ expectedResult ], this.return = expectedResult, 
        this.debugName = debugName;
      }
    }, {
      key: "addFunction",
      value: function(func) {
        var _ref = func.signature || {}, _ref$params = _ref.params, args = void 0 === _ref$params ? [] : _ref$params, _ref$results = _ref.results, result = void 0 === _ref$results ? [] : _ref$results;
        args = args.map((function(arg) {
          return arg.valtype;
        })), this.funcs.push({
          args: args,
          result: result
        }), void 0 !== func.name && (this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1);
      }
    }, {
      key: "importFunction",
      value: function(funcimport) {
        if (Object(_webassemblyjs_ast__WEBPACK_IMPORTED_MODULE_0__.isSignature)(funcimport.signature)) {
          var _funcimport$signature = funcimport.signature, args = _funcimport$signature.params, result = _funcimport$signature.results;
          args = args.map((function(arg) {
            return arg.valtype;
          })), this.funcs.push({
            args: args,
            result: result
          });
        } else {
          if (!Object(_webassemblyjs_ast__WEBPACK_IMPORTED_MODULE_0__.isNumberLiteral)(funcimport.signature)) throw new Error("isNumberLiteral(funcimport.signature) error: unknown");
          var typeId = funcimport.signature.value;
          if (!this.hasType(typeId)) throw new Error("this.hasType(typeId) error: unknown");
          var signature = this.getType(typeId);
          this.funcs.push({
            args: signature.params.map((function(arg) {
              return arg.valtype;
            })),
            result: signature.results
          });
        }
        void 0 !== funcimport.id && (this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1);
      }
    }, {
      key: "hasFunction",
      value: function(index) {
        return void 0 !== this.getFunction(index);
      }
    }, {
      key: "getFunction",
      value: function(index) {
        if ("number" != typeof index) throw new Error("getFunction only supported for number index");
        return this.funcs[index];
      }
    }, {
      key: "getFunctionOffsetByIdentifier",
      value: function(name) {
        if ("string" != typeof name) throw new Error('typeof name === "string" error: unknown');
        return this.funcsOffsetByIdentifier[name];
      }
    }, {
      key: "addLabel",
      value: function(result) {
        this.labels.unshift(result);
      }
    }, {
      key: "hasLabel",
      value: function(index) {
        return this.labels.length > index && index >= 0;
      }
    }, {
      key: "getLabel",
      value: function(index) {
        return this.labels[index];
      }
    }, {
      key: "popLabel",
      value: function() {
        this.labels.shift();
      }
    }, {
      key: "hasLocal",
      value: function(index) {
        return void 0 !== this.getLocal(index);
      }
    }, {
      key: "getLocal",
      value: function(index) {
        return this.locals[index];
      }
    }, {
      key: "addLocal",
      value: function(type) {
        this.locals.push(type);
      }
    }, {
      key: "addType",
      value: function(type) {
        if ("Signature" !== type.functype.type) throw new Error('type.functype.type === "Signature" error: unknown');
        this.types.push(type.functype);
      }
    }, {
      key: "hasType",
      value: function(index) {
        return void 0 !== this.types[index];
      }
    }, {
      key: "getType",
      value: function(index) {
        return this.types[index];
      }
    }, {
      key: "hasGlobal",
      value: function(index) {
        return this.globals.length > index && index >= 0;
      }
    }, {
      key: "getGlobal",
      value: function(index) {
        return this.globals[index].type;
      }
    }, {
      key: "getGlobalOffsetByIdentifier",
      value: function(name) {
        if ("string" != typeof name) throw new Error('typeof name === "string" error: unknown');
        return this.globalsOffsetByIdentifier[name];
      }
    }, {
      key: "defineGlobal",
      value: function(global) {
        var type = global.globalType.valtype, mutability = global.globalType.mutability;
        this.globals.push({
          type: type,
          mutability: mutability
        }), void 0 !== global.name && (this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1);
      }
    }, {
      key: "importGlobal",
      value: function(type, mutability) {
        this.globals.push({
          type: type,
          mutability: mutability
        });
      }
    }, {
      key: "isMutableGlobal",
      value: function(index) {
        return "var" === this.globals[index].mutability;
      }
    }, {
      key: "isImmutableGlobal",
      value: function(index) {
        return "const" === this.globals[index].mutability;
      }
    }, {
      key: "hasMemory",
      value: function(index) {
        return this.mems.length > index && index >= 0;
      }
    }, {
      key: "addMemory",
      value: function(min, max) {
        this.mems.push({
          min: min,
          max: max
        });
      }
    }, {
      key: "getMemory",
      value: function(index) {
        return this.mems[index];
      }
    } ]) && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
    ModuleContext;
  }();
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2), WebAssemblyImportDependency = __webpack_require__(44);
  exports.getUsedDependencies = (module, mangle) => {
    const array = [];
    let importIndex = 0;
    for (const dep of module.dependencies) if (dep instanceof WebAssemblyImportDependency) {
      if ("GlobalType" === dep.description.type || null === dep.module) continue;
      const exportName = dep.name;
      mangle ? array.push({
        dependency: dep,
        name: Template.numberToIdentifer(importIndex++),
        module: "a"
      }) : array.push({
        dependency: dep,
        name: exportName,
        module: dep.request
      });
    }
    return array;
  }, exports.MANGLED_MODULE = "a";
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(target) {
      this.target = target;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("LoaderTargetPlugin", compilation => {
        compilation.hooks.normalModuleLoader.tap("LoaderTargetPlugin", loaderContext => {
          loaderContext.target = this.target;
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const EvalDevToolModuleTemplatePlugin = __webpack_require__(285);
  module.exports = class {
    constructor(options) {
      this.sourceUrlComment = options.sourceUrlComment, this.moduleFilenameTemplate = options.moduleFilenameTemplate, 
      this.namespace = options.namespace;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("EvalDevToolModulePlugin", compilation => {
        new EvalDevToolModuleTemplatePlugin({
          sourceUrlComment: this.sourceUrlComment,
          moduleFilenameTemplate: this.moduleFilenameTemplate,
          namespace: this.namespace
        }).apply(compilation.moduleTemplates.javascript);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleFilenameHelpers = __webpack_require__(21);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compilation) {
      const options = this.options;
      !1 !== options.module && compilation.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin", module => {
        module.useSourceMap = !0;
      }), !0 === options.lineToLine ? compilation.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin", module => {
        module.lineToLine = !0;
      }) : options.lineToLine && compilation.hooks.buildModule.tap("SourceMapDevToolModuleOptionsPlugin", module => {
        if (!module.resource) return;
        let resourcePath = module.resource;
        const idx = resourcePath.indexOf("?");
        idx >= 0 && (resourcePath = resourcePath.substr(0, idx)), module.lineToLine = ModuleFilenameHelpers.matchObject(options.lineToLine, resourcePath);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const EvalSourceMapDevToolModuleTemplatePlugin = __webpack_require__(287), SourceMapDevToolModuleOptionsPlugin = __webpack_require__(123);
  module.exports = class {
    constructor(options) {
      if (arguments.length > 1) throw new Error("EvalSourceMapDevToolPlugin only takes one argument (pass an options object)");
      "string" == typeof options && (options = {
        append: options
      }), options || (options = {}), this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("EvalSourceMapDevToolPlugin", compilation => {
        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation), new EvalSourceMapDevToolModuleTemplatePlugin(compilation, options).apply(compilation.moduleTemplates.javascript);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const MultiEntryDependency = __webpack_require__(126), SingleEntryDependency = __webpack_require__(31), MultiModuleFactory = __webpack_require__(127);
  class MultiEntryPlugin {
    constructor(context, entries, name) {
      this.context = context, this.entries = entries, this.name = name;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("MultiEntryPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const multiModuleFactory = new MultiModuleFactory;
        compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory), compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
      }), compiler.hooks.make.tapAsync("MultiEntryPlugin", (compilation, callback) => {
        const {context: context, entries: entries, name: name} = this, dep = MultiEntryPlugin.createDependency(entries, name);
        compilation.addEntry(context, dep, name, callback);
      });
    }
    static createDependency(entries, name) {
      return new MultiEntryDependency(entries.map((e, idx) => {
        const dep = new SingleEntryDependency(e);
        return dep.loc = {
          name: name,
          index: idx
        }, dep;
      }), name);
    }
  }
  module.exports = MultiEntryPlugin;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Dependency = __webpack_require__(19);
  module.exports = class extends Dependency {
    constructor(dependencies, name) {
      super(), this.dependencies = dependencies, this.name = name;
    }
    get type() {
      return "multi entry";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {Tapable: Tapable} = __webpack_require__(6), MultiModule = __webpack_require__(289);
  module.exports = class extends Tapable {
    constructor() {
      super(), this.hooks = {};
    }
    create(data, callback) {
      const dependency = data.dependencies[0];
      callback(null, new MultiModule(data.context, dependency.dependencies, dependency.name));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4), ModuleDependencyTemplateAsId = __webpack_require__(46);
  class CommonJsRequireDependency extends ModuleDependency {
    constructor(request, range) {
      super(request), this.range = range;
    }
    get type() {
      return "cjs require";
    }
  }
  CommonJsRequireDependency.Template = ModuleDependencyTemplateAsId, module.exports = CommonJsRequireDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ContextDependency = __webpack_require__(32), ContextDependencyTemplateAsRequireCall = __webpack_require__(75);
  class CommonJsRequireContextDependency extends ContextDependency {
    constructor(options, range, valueRange) {
      super(options), this.range = range, this.valueRange = valueRange;
    }
    get type() {
      return "cjs require context";
    }
  }
  CommonJsRequireContextDependency.Template = ContextDependencyTemplateAsRequireCall, 
  module.exports = CommonJsRequireContextDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4), ModuleDependencyAsId = __webpack_require__(46);
  class RequireResolveDependency extends ModuleDependency {
    constructor(request, range) {
      super(request), this.range = range;
    }
    get type() {
      return "require.resolve";
    }
  }
  RequireResolveDependency.Template = ModuleDependencyAsId, module.exports = RequireResolveDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ContextDependency = __webpack_require__(32), ContextDependencyTemplateAsId = __webpack_require__(304);
  class RequireResolveContextDependency extends ContextDependency {
    constructor(options, range, valueRange) {
      super(options), this.range = range, this.valueRange = valueRange;
    }
    get type() {
      return "amd require context";
    }
  }
  RequireResolveContextDependency.Template = ContextDependencyTemplateAsId, module.exports = RequireResolveContextDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class RequireResolveHeaderDependency extends NullDependency {
    constructor(range) {
      if (super(), !Array.isArray(range)) throw new Error("range must be valid");
      this.range = range;
    }
  }
  RequireResolveHeaderDependency.Template = class {
    apply(dep, source) {
      source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
    }
    applyAsTemplateArgument(name, dep, source) {
      source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
    }
  }, module.exports = RequireResolveHeaderDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class RequireHeaderDependency extends NullDependency {
    constructor(range) {
      if (super(), !Array.isArray(range)) throw new Error("range must be valid");
      this.range = range;
    }
  }
  RequireHeaderDependency.Template = class {
    apply(dep, source) {
      source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__");
    }
    applyAsTemplateArgument(name, dep, source) {
      source.replace(dep.range[0], dep.range[1] - 1, "require");
    }
  }, module.exports = RequireHeaderDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class HarmonyInitDependency extends NullDependency {
    constructor(originModule) {
      super(), this.originModule = originModule;
    }
    get type() {
      return "harmony init";
    }
  }
  module.exports = HarmonyInitDependency, HarmonyInitDependency.Template = class {
    apply(dep, source, runtime, dependencyTemplates) {
      const module = dep.originModule, list = [];
      for (const dependency of module.dependencies) {
        const template = dependencyTemplates.get(dependency.constructor);
        if (template && "function" == typeof template.harmonyInit && "function" == typeof template.getHarmonyInitOrder) {
          const order = template.getHarmonyInitOrder(dependency);
          isNaN(order) || list.push({
            order: order,
            listOrder: list.length,
            dependency: dependency,
            template: template
          });
        }
      }
      list.sort((a, b) => {
        const x = a.order - b.order;
        return x || a.listOrder - b.listOrder;
      });
      for (const item of list) item.template.harmonyInit(item.dependency, source, runtime, dependencyTemplates);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(message) {
      super(message), this.name = "HarmonyLinkingError", this.hideStack = !0, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class HarmonyExportHeaderDependency extends NullDependency {
    constructor(range, rangeStatement) {
      super(), this.range = range, this.rangeStatement = rangeStatement;
    }
    get type() {
      return "harmony export header";
    }
  }
  HarmonyExportHeaderDependency.Template = class {
    apply(dep, source) {
      const replaceUntil = dep.range ? dep.range[0] - 1 : dep.rangeStatement[1] - 1;
      source.replace(dep.rangeStatement[0], replaceUntil, "");
    }
  }, module.exports = HarmonyExportHeaderDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7), HarmonyImportDependency = __webpack_require__(22);
  class HarmonyAcceptDependency extends NullDependency {
    constructor(range, dependencies, hasCallback) {
      super(), this.range = range, this.dependencies = dependencies, this.hasCallback = hasCallback;
    }
    get type() {
      return "accepted harmony modules";
    }
  }
  HarmonyAcceptDependency.Template = class {
    apply(dep, source, runtime) {
      const content = dep.dependencies.filter(dependency => HarmonyImportDependency.Template.isImportEmitted(dependency, source)).map(dependency => dependency.getImportStatement(!0, runtime)).join("");
      if (dep.hasCallback) return source.insert(dep.range[0], `function(__WEBPACK_OUTDATED_DEPENDENCIES__) { ${content}(`), 
      void source.insert(dep.range[1], ")(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this)");
      source.insert(dep.range[1] - .5, `, function() { ${content} }`);
    }
  }, module.exports = HarmonyAcceptDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const HarmonyImportDependency = __webpack_require__(22);
  class HarmonyAcceptImportDependency extends HarmonyImportDependency {
    constructor(request, originModule, parserScope) {
      super(request, originModule, NaN, parserScope), this.weak = !0;
    }
    get type() {
      return "harmony accept";
    }
  }
  HarmonyAcceptImportDependency.Template = class extends HarmonyImportDependency.Template {
    apply(dep, source, runtime) {}
  }, module.exports = HarmonyAcceptImportDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  class ImportDependency extends ModuleDependency {
    constructor(request, originModule, block) {
      super(request), this.originModule = originModule, this.block = block;
    }
    get type() {
      return "import()";
    }
  }
  ImportDependency.Template = class {
    apply(dep, source, runtime) {
      const content = runtime.moduleNamespacePromise({
        block: dep.block,
        module: dep.module,
        request: dep.request,
        strict: dep.originModule.buildMeta.strictHarmonyModule,
        message: "import()"
      });
      source.replace(dep.block.range[0], dep.block.range[1] - 1, content);
    }
  }, module.exports = ImportDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  class ImportEagerDependency extends ModuleDependency {
    constructor(request, originModule, range) {
      super(request), this.originModule = originModule, this.range = range;
    }
    get type() {
      return "import() eager";
    }
  }
  ImportEagerDependency.Template = class {
    apply(dep, source, runtime) {
      const content = runtime.moduleNamespacePromise({
        module: dep.module,
        request: dep.request,
        strict: dep.originModule.buildMeta.strictHarmonyModule,
        message: "import() eager"
      });
      source.replace(dep.range[0], dep.range[1] - 1, content);
    }
  }, module.exports = ImportEagerDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  class ImportWeakDependency extends ModuleDependency {
    constructor(request, originModule, range) {
      super(request), this.originModule = originModule, this.range = range, this.weak = !0;
    }
    get type() {
      return "import() weak";
    }
  }
  ImportWeakDependency.Template = class {
    apply(dep, source, runtime) {
      const content = runtime.moduleNamespacePromise({
        module: dep.module,
        request: dep.request,
        strict: dep.originModule.buildMeta.strictHarmonyModule,
        message: "import() weak",
        weak: !0
      });
      source.replace(dep.range[0], dep.range[1] - 1, content);
    }
  }, module.exports = ImportWeakDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ContextDependency = __webpack_require__(32), ContextDependencyTemplateAsRequireCall = __webpack_require__(75);
  class ImportContextDependency extends ContextDependency {
    constructor(options, range, valueRange) {
      super(options), this.range = range, this.valueRange = valueRange;
    }
    get type() {
      return "import() context " + this.options.mode;
    }
  }
  ImportContextDependency.Template = ContextDependencyTemplateAsRequireCall, module.exports = ImportContextDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ContextDependency = __webpack_require__(32), ModuleDependencyTemplateAsRequireId = __webpack_require__(144);
  class RequireContextDependency extends ContextDependency {
    constructor(options, range) {
      super(options), this.range = range;
    }
    get type() {
      return "require.context";
    }
  }
  RequireContextDependency.Template = ModuleDependencyTemplateAsRequireId, module.exports = RequireContextDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(dep, source, runtime) {
      if (!dep.range) return;
      const content = runtime.moduleExports({
        module: dep.module,
        request: dep.request
      });
      source.replace(dep.range[0], dep.range[1] - 1, content);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4), NullDependency = __webpack_require__(7);
  class RequireEnsureItemDependency extends ModuleDependency {
    constructor(request) {
      super(request);
    }
    get type() {
      return "require.ensure item";
    }
  }
  RequireEnsureItemDependency.Template = NullDependency.Template, module.exports = RequireEnsureItemDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class RequireEnsureDependency extends NullDependency {
    constructor(block) {
      super(), this.block = block;
    }
    get type() {
      return "require.ensure";
    }
  }
  RequireEnsureDependency.Template = class {
    apply(dep, source, runtime) {
      const depBlock = dep.block, promise = runtime.blockPromise({
        block: depBlock,
        message: "require.ensure"
      }), errorCallbackExists = 4 === depBlock.expr.arguments.length || !depBlock.chunkName && 3 === depBlock.expr.arguments.length, startBlock = promise + ".then((", endBlock = `).bind(null, __webpack_require__)).catch(${runtime.onError()})`;
      source.replace(depBlock.expr.range[0], depBlock.expr.arguments[1].range[0] - 1, startBlock), 
      errorCallbackExists ? (source.replace(depBlock.expr.arguments[1].range[1], depBlock.expr.arguments[2].range[0] - 1, ").bind(null, __webpack_require__)).catch("), 
      source.replace(depBlock.expr.arguments[2].range[1], depBlock.expr.range[1] - 1, ")")) : source.replace(depBlock.expr.arguments[1].range[1], depBlock.expr.range[1] - 1, endBlock);
    }
  }, module.exports = RequireEnsureDependency;
}, function(module, exports) {
  module.exports = expr => "FunctionExpression" === expr.type || "ArrowFunctionExpression" === expr.type ? {
    fn: expr,
    expressions: [],
    needThis: !1
  } : "CallExpression" === expr.type && "MemberExpression" === expr.callee.type && "FunctionExpression" === expr.callee.object.type && "Identifier" === expr.callee.property.type && "bind" === expr.callee.property.name && 1 === expr.arguments.length ? {
    fn: expr.callee.object,
    expressions: [ expr.arguments[0] ],
    needThis: void 0
  } : "CallExpression" === expr.type && "FunctionExpression" === expr.callee.type && "BlockStatement" === expr.callee.body.type && 1 === expr.arguments.length && "ThisExpression" === expr.arguments[0].type && expr.callee.body.body && 1 === expr.callee.body.body.length && "ReturnStatement" === expr.callee.body.body[0].type && expr.callee.body.body[0].argument && "FunctionExpression" === expr.callee.body.body[0].argument.type ? {
    fn: expr.callee.body.body[0].argument,
    expressions: [],
    needThis: !0
  } : void 0;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), ModuleDependency = __webpack_require__(4), Template = __webpack_require__(2);
  class RequireIncludeDependency extends ModuleDependency {
    constructor(request, range) {
      super(request), this.range = range;
    }
    getReference() {
      return this.module ? new DependencyReference(this.module, [], !1) : null;
    }
    get type() {
      return "require.include";
    }
  }
  RequireIncludeDependency.Template = class {
    apply(dep, source, runtime) {
      const comment = runtime.outputOptions.pathinfo ? Template.toComment("require.include " + runtime.requestShortener.shorten(dep.request)) : "";
      source.replace(dep.range[0], dep.range[1] - 1, "undefined" + comment);
    }
  }, module.exports = RequireIncludeDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2), WebAssemblyUtils = __webpack_require__(120);
  module.exports = class {
    constructor({generateLoadBinaryCode: generateLoadBinaryCode, supportsStreaming: supportsStreaming, mangleImports: mangleImports}) {
      this.generateLoadBinaryCode = generateLoadBinaryCode, this.supportsStreaming = supportsStreaming, 
      this.mangleImports = mangleImports;
    }
    apply(mainTemplate) {
      mainTemplate.hooks.localVars.tap("WasmMainTemplatePlugin", (source, chunk) => {
        const wasmModules = (chunk => {
          const wasmModules = chunk.getAllAsyncChunks(), array = [];
          for (const chunk of wasmModules) for (const m of chunk.modulesIterable) m.type.startsWith("webassembly") && array.push(m);
          return array;
        })(chunk);
        if (0 === wasmModules.length) return source;
        const importObjects = wasmModules.map(module => ((module, mangle) => {
          const waitForInstances = new Map, properties = [], usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);
          for (const usedDep of usedWasmDependencies) {
            const dep = usedDep.dependency, importedModule = dep.module, exportName = dep.name, usedName = importedModule && importedModule.isUsed(exportName), description = dep.description, direct = dep.onlyDirectImport, module = usedDep.module, name = usedDep.name;
            if (direct) {
              const instanceVar = "m" + waitForInstances.size;
              waitForInstances.set(instanceVar, importedModule.id), properties.push({
                module: module,
                name: name,
                value: `${instanceVar}[${JSON.stringify(usedName)}]`
              });
            } else {
              const params = description.signature.params.map((param, k) => "p" + k + param.valtype), mod = `installedModules[${JSON.stringify(importedModule.id)}]`, func = `${mod}.exports[${JSON.stringify(usedName)}]`;
              properties.push({
                module: module,
                name: name,
                value: Template.asString([ (importedModule.type.startsWith("webassembly") ? `${mod} ? ${func} : ` : "") + `function(${params}) {`, Template.indent([ `return ${func}(${params});` ]), "}" ])
              });
            }
          }
          let importObject;
          if (mangle) importObject = [ "return {", Template.indent([ properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(",\n") ]), "};" ]; else {
            const propertiesByModule = new Map;
            for (const p of properties) {
              let list = propertiesByModule.get(p.module);
              void 0 === list && propertiesByModule.set(p.module, list = []), list.push(p);
            }
            importObject = [ "return {", Template.indent([ Array.from(propertiesByModule, ([module, list]) => Template.asString([ JSON.stringify(module) + ": {", Template.indent([ list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(",\n") ]), "}" ])).join(",\n") ]), "};" ];
          }
          if (1 === waitForInstances.size) {
            const moduleId = Array.from(waitForInstances.values())[0], promise = `installedWasmModules[${JSON.stringify(moduleId)}]`, variable = Array.from(waitForInstances.keys())[0];
            return Template.asString([ JSON.stringify(module.id) + ": function() {", Template.indent([ `return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), "});" ]), "}," ]);
          }
          if (waitForInstances.size > 0) {
            const promises = Array.from(waitForInstances.values(), id => `installedWasmModules[${JSON.stringify(id)}]`).join(", "), variables = Array.from(waitForInstances.keys(), (name, i) => `${name} = array[${i}]`).join(", ");
            return Template.asString([ JSON.stringify(module.id) + ": function() {", Template.indent([ `return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([ `var ${variables};`, ...importObject ]), "});" ]), "}," ]);
          }
          return Template.asString([ JSON.stringify(module.id) + ": function() {", Template.indent(importObject), "}," ]);
        })(module, this.mangleImports));
        return Template.asString([ source, "", "// object to store loaded and loading wasm modules", "var installedWasmModules = {};", "", "function promiseResolve() { return Promise.resolve(); }", "", "var wasmImportObjects = {", Template.indent(importObjects), "};" ]);
      }), mainTemplate.hooks.requireEnsure.tap("WasmMainTemplatePlugin", (source, chunk, hash) => {
        const webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename, chunkModuleMaps = chunk.getChunkModuleMaps(m => m.type.startsWith("webassembly"));
        if (0 === Object.keys(chunkModuleMaps.id).length) return source;
        const wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          module: {
            id: '" + wasmModuleId + "',
            hash: `" + ${JSON.stringify(chunkModuleMaps.hash)}[wasmModuleId] + "`,
            hashWithLength(length) {
              const shortChunkHashMap = Object.create(null);
              for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) "string" == typeof chunkModuleMaps.hash[wasmModuleId] && (shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length));
              return `" + ${JSON.stringify(shortChunkHashMap)}[wasmModuleId] + "`;
            }
          }
        }), createImportObject = content => this.mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content;
        return Template.asString([ source, "", "// Fetch + compile chunk loading for webassembly", "", `var wasmModules = ${JSON.stringify(chunkModuleMaps.id)}[chunkId] || [];`, "", "wasmModules.forEach(function(wasmModuleId) {", Template.indent([ "var installedWasmModuleData = installedWasmModules[wasmModuleId];", "", '// a Promise means "currently loading" or "already loaded".', "if(installedWasmModuleData)", Template.indent([ "promises.push(installedWasmModuleData);" ]), "else {", Template.indent([ "var importObject = wasmImportObjects[wasmModuleId]();", `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, "var promise;", this.supportsStreaming ? Template.asString([ "if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {", Template.indent([ "promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {", Template.indent([ `return WebAssembly.instantiate(items[0], ${createImportObject("items[1]")});` ]), "});" ]), "} else if(typeof WebAssembly.instantiateStreaming === 'function') {", Template.indent([ `promise = WebAssembly.instantiateStreaming(req, ${createImportObject("importObject")});` ]) ]) : Template.asString([ "if(importObject instanceof Promise) {", Template.indent([ "var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });", "promise = Promise.all([", Template.indent([ "bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),", "importObject" ]), "]).then(function(items) {", Template.indent([ `return WebAssembly.instantiate(items[0], ${createImportObject("items[1]")});` ]), "});" ]) ]), "} else {", Template.indent([ "var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });", "promise = bytesPromise.then(function(bytes) {", Template.indent([ `return WebAssembly.instantiate(bytes, ${createImportObject("importObject")});` ]), "});" ]), "}", "promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {", Template.indent([ `return ${mainTemplate.requireFn}.w[wasmModuleId] = (res.instance || res).exports;` ]), "}));" ]), "}" ]), "});" ]);
      }), mainTemplate.hooks.requireExtensions.tap("WasmMainTemplatePlugin", (source, chunk) => chunk.hasModuleInGraph(m => m.type.startsWith("webassembly")) ? Template.asString([ source, "", "// object with all WebAssembly.instance exports", mainTemplate.requireFn + ".w = {};" ]) : source), 
      mainTemplate.hooks.hash.tap("WasmMainTemplatePlugin", hash => {
        hash.update("WasmMainTemplatePlugin"), hash.update("2");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebWorkerMainTemplatePlugin = __webpack_require__(330), WebWorkerChunkTemplatePlugin = __webpack_require__(332), WebWorkerHotUpdateChunkTemplatePlugin = __webpack_require__(333);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("WebWorkerTemplatePlugin", compilation => {
        (new WebWorkerMainTemplatePlugin).apply(compilation.mainTemplate), (new WebWorkerChunkTemplatePlugin).apply(compilation.chunkTemplate), 
        (new WebWorkerHotUpdateChunkTemplatePlugin).apply(compilation.hotUpdateChunkTemplate);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  var map = {
    "./NodeChunkTemplatePlugin": 82,
    "./NodeChunkTemplatePlugin.js": 82,
    "./NodeEnvironmentPlugin": 66,
    "./NodeEnvironmentPlugin.js": 66,
    "./NodeHotUpdateChunkTemplatePlugin": 83,
    "./NodeHotUpdateChunkTemplatePlugin.js": 83,
    "./NodeMainTemplate.runtime": 81,
    "./NodeMainTemplate.runtime.js": 81,
    "./NodeMainTemplateAsync.runtime": 80,
    "./NodeMainTemplateAsync.runtime.js": 80,
    "./NodeMainTemplatePlugin": 79,
    "./NodeMainTemplatePlugin.js": 79,
    "./NodeOutputFileSystem": 68,
    "./NodeOutputFileSystem.js": 68,
    "./NodeSourcePlugin": 53,
    "./NodeSourcePlugin.js": 53,
    "./NodeTargetPlugin": 25,
    "./NodeTargetPlugin.js": 25,
    "./NodeTemplatePlugin": 24,
    "./NodeTemplatePlugin.js": 24,
    "./NodeWatchFileSystem": 67,
    "./NodeWatchFileSystem.js": 67,
    "./ReadFileCompileWasmTemplatePlugin": 54,
    "./ReadFileCompileWasmTemplatePlugin.js": 54,
    "./nodeConsole": 69,
    "./nodeConsole.js": 69
  };
  function webpackContext(req) {
    var id = webpackContextResolve(req);
    return __webpack_require__(id);
  }
  function webpackContextResolve(req) {
    if (!__webpack_require__.o(map, req)) {
      var e = new Error("Cannot find module '" + req + "'");
      throw e.code = "MODULE_NOT_FOUND", e;
    }
    return map[req];
  }
  webpackContext.keys = function() {
    return Object.keys(map);
  }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
  webpackContext.id = 151;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ExternalModule = __webpack_require__(334);
  module.exports = class {
    constructor(type, externals) {
      this.type = type, this.externals = externals;
    }
    apply(normalModuleFactory) {
      const globalType = this.type;
      normalModuleFactory.hooks.factory.tap("ExternalModuleFactoryPlugin", factory => (data, callback) => {
        const context = data.context, dependency = data.dependencies[0], handleExternal = (value, type, callback) => {
          if ("function" == typeof type && (callback = type, type = void 0), !1 === value) return factory(data, callback);
          if (!0 === value && (value = dependency.request), void 0 === type && /^[a-z0-9]+ /.test(value)) {
            const idx = value.indexOf(" ");
            type = value.substr(0, idx), value = value.substr(idx + 1);
          }
          return callback(null, new ExternalModule(value, type || globalType, dependency.request)), 
          !0;
        }, handleExternals = (externals, callback) => {
          if ("string" == typeof externals) {
            if (externals === dependency.request) return handleExternal(dependency.request, callback);
          } else {
            if (Array.isArray(externals)) {
              let i = 0;
              const next = () => {
                let asyncFlag;
                const handleExternalsAndCallback = (err, module) => err ? callback(err) : module ? void callback(null, module) : asyncFlag ? void (asyncFlag = !1) : next();
                do {
                  if (asyncFlag = !0, i >= externals.length) return callback();
                  handleExternals(externals[i++], handleExternalsAndCallback);
                } while (!asyncFlag);
                asyncFlag = !1;
              };
              return void next();
            }
            if (externals instanceof RegExp) {
              if (externals.test(dependency.request)) return handleExternal(dependency.request, callback);
            } else {
              if ("function" == typeof externals) return void externals.call(null, context, dependency.request, (err, value, type) => {
                if (err) return callback(err);
                void 0 !== value ? handleExternal(value, type, callback) : callback();
              });
              if ("object" == typeof externals && Object.prototype.hasOwnProperty.call(externals, dependency.request)) return handleExternal(externals[dependency.request], callback);
            }
          }
          callback();
        };
        handleExternals(this.externals, (err, module) => err ? callback(err) : module ? callback(null, module) : handleExternal(!1, callback));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const SetVarMainTemplatePlugin = __webpack_require__(154), accessorToObjectAccess = accessor => accessor.map(a => `[${JSON.stringify(a)}]`).join(""), accessorAccess = (base, accessor, umdProperty, joinWith = "; ") => {
    const normalizedAccessor = "object" != typeof accessor || Array.isArray(accessor) ? accessor : accessor[umdProperty], accessors = Array.isArray(normalizedAccessor) ? normalizedAccessor : [ normalizedAccessor ];
    return accessors.map((_, idx) => {
      const a = base ? base + accessorToObjectAccess(accessors.slice(0, idx + 1)) : accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
      return idx === accessors.length - 1 ? a : 0 === idx && void 0 === base ? `${a} = typeof ${a} === "object" ? ${a} : {}` : `${a} = ${a} || {}`;
    }).join(joinWith);
  };
  module.exports = class {
    constructor(name, target, umdNamedDefine, auxiliaryComment, exportProperty) {
      this.name = name, this.target = target, this.umdNamedDefine = umdNamedDefine, this.auxiliaryComment = auxiliaryComment, 
      this.exportProperty = exportProperty;
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("LibraryTemplatePlugin", compilation => {
        if (this.exportProperty) {
          new (__webpack_require__(335))(this.exportProperty).apply(compilation);
        }
        switch (this.target) {
         case "var":
          if (!this.name || "object" == typeof this.name && !Array.isArray(this.name)) throw new Error("library name must be set and not an UMD custom object for non-UMD target");
          new SetVarMainTemplatePlugin("var " + accessorAccess(void 0, this.name, "root"), !1).apply(compilation);
          break;

         case "assign":
          new SetVarMainTemplatePlugin(accessorAccess(void 0, this.name, "root"), !1).apply(compilation);
          break;

         case "this":
         case "self":
         case "window":
          this.name ? new SetVarMainTemplatePlugin(accessorAccess(this.target, this.name, "root"), !1).apply(compilation) : new SetVarMainTemplatePlugin(this.target, !0).apply(compilation);
          break;

         case "global":
          this.name ? new SetVarMainTemplatePlugin(accessorAccess(compilation.runtimeTemplate.outputOptions.globalObject, this.name, "root"), !1).apply(compilation) : new SetVarMainTemplatePlugin(compilation.runtimeTemplate.outputOptions.globalObject, !0).apply(compilation);
          break;

         case "commonjs":
          this.name ? new SetVarMainTemplatePlugin(accessorAccess("exports", this.name, "commonjs"), !1).apply(compilation) : new SetVarMainTemplatePlugin("exports", !0).apply(compilation);
          break;

         case "commonjs2":
         case "commonjs-module":
          new SetVarMainTemplatePlugin("module.exports", !1).apply(compilation);
          break;

         case "amd":
         case "amd-require":
          {
            const AmdMainTemplatePlugin = __webpack_require__(336);
            if (this.name && "string" != typeof this.name) throw new Error("library name must be a string for amd target");
            new AmdMainTemplatePlugin({
              name: this.name,
              requireAsWrapper: "amd-require" === this.target
            }).apply(compilation);
            break;
          }

         case "umd":
         case "umd2":
          new (__webpack_require__(155))(this.name, {
            optionalAmdExternalAsGlobal: "umd2" === this.target,
            namedDefine: this.umdNamedDefine,
            auxiliaryComment: this.auxiliaryComment
          }).apply(compilation);
          break;

         case "jsonp":
          {
            const JsonpExportMainTemplatePlugin = __webpack_require__(337);
            if ("string" != typeof this.name) throw new Error("library name must be a string for jsonp target");
            new JsonpExportMainTemplatePlugin(this.name).apply(compilation);
            break;
          }

         case "system":
          new (__webpack_require__(338))({
            name: this.name
          }).apply(compilation);
          break;

         default:
          throw new Error(this.target + " is not a valid Library target");
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    constructor(varExpression, copyObject) {
      this.varExpression = varExpression, this.copyObject = copyObject;
    }
    apply(compilation) {
      const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate} = compilation, onRenderWithEntry = (source, chunk, hash) => {
        const varExpression = mainTemplate.getAssetPath(this.varExpression, {
          hash: hash,
          chunk: chunk
        });
        if (this.copyObject) return new ConcatSource(`(function(e, a) { for(var i in a) e[i] = a[i]; }(${varExpression}, `, source, "))");
        return new ConcatSource(varExpression + " =\n", source);
      };
      for (const template of [ mainTemplate, chunkTemplate ]) template.hooks.renderWithEntry.tap("SetVarMainTemplatePlugin", onRenderWithEntry);
      mainTemplate.hooks.globalHashPaths.tap("SetVarMainTemplatePlugin", paths => (this.varExpression && paths.push(this.varExpression), 
      paths)), mainTemplate.hooks.hash.tap("SetVarMainTemplatePlugin", hash => {
        hash.update("set var"), hash.update("" + this.varExpression), hash.update("" + this.copyObject);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource, OriginalSource: OriginalSource} = __webpack_require__(0), Template = __webpack_require__(2), accessorToObjectAccess = accessor => accessor.map(a => `[${JSON.stringify(a)}]`).join("");
  module.exports = class {
    constructor(name, options) {
      "object" != typeof name || Array.isArray(name) ? (this.name = name, this.names = {
        commonjs: name,
        root: name,
        amd: name
      }) : (this.name = name.root || name.amd || name.commonjs, this.names = name), this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal, 
      this.namedDefine = options.namedDefine, this.auxiliaryComment = options.auxiliaryComment;
    }
    apply(compilation) {
      const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate, runtimeTemplate: runtimeTemplate} = compilation, onRenderWithEntry = (source, chunk, hash) => {
        let externals = chunk.getModules().filter(m => m.external && ("umd" === m.externalType || "umd2" === m.externalType));
        const optionalExternals = [];
        let requiredExternals = [];
        if (this.optionalAmdExternalAsGlobal) {
          for (const m of externals) m.optional ? optionalExternals.push(m) : requiredExternals.push(m);
          externals = requiredExternals.concat(optionalExternals);
        } else requiredExternals = externals;
        const replaceKeys = str => mainTemplate.getAssetPath(str, {
          hash: hash,
          chunk: chunk
        }), externalsDepsArray = modules => `[${replaceKeys(modules.map(m => JSON.stringify("object" == typeof m.request ? m.request.amd : m.request)).join(", "))}]`, externalsRootArray = modules => replaceKeys(modules.map(m => {
          let request = m.request;
          return "object" == typeof request && (request = request.root), "root" + accessorToObjectAccess([].concat(request));
        }).join(", ")), externalsRequireArray = type => replaceKeys(externals.map(m => {
          let expr, request = m.request;
          if ("object" == typeof request && (request = request[type]), void 0 === request) throw new Error("Missing external configuration for type:" + type);
          return expr = Array.isArray(request) ? `require(${JSON.stringify(request[0])})${accessorToObjectAccess(request.slice(1))}` : `require(${JSON.stringify(request)})`, 
          m.optional && (expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr}; } catch(e) {} }())`), 
          expr;
        }).join(", ")), externalsArguments = modules => modules.map(m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier("" + m.id)}__`).join(", "), libraryName = library => JSON.stringify(replaceKeys([].concat(library).pop()));
        let amdFactory;
        if (optionalExternals.length > 0) {
          amdFactory = `function webpackLoadOptionalExternalModuleAmd(${externalsArguments(requiredExternals)}) {\n\t\t\treturn factory(${requiredExternals.length > 0 ? externalsArguments(requiredExternals) + ", " + externalsRootArray(optionalExternals) : externalsRootArray(optionalExternals)});\n\t\t}`;
        } else amdFactory = "factory";
        const auxiliaryComment = this.auxiliaryComment, getAuxilaryComment = type => {
          if (auxiliaryComment) {
            if ("string" == typeof auxiliaryComment) return "\t//" + auxiliaryComment + "\n";
            if (auxiliaryComment[type]) return "\t//" + auxiliaryComment[type] + "\n";
          }
          return "";
        };
        return new ConcatSource(new OriginalSource("(function webpackUniversalModuleDefinition(root, factory) {\n" + getAuxilaryComment("commonjs2") + "\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(" + externalsRequireArray("commonjs2") + ");\n" + getAuxilaryComment("amd") + "\telse if(typeof define === 'function' && define.amd)\n" + (requiredExternals.length > 0 ? this.names.amd && !0 === this.namedDefine ? "\t\tdefine(" + libraryName(this.names.amd) + ", " + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" : "\t\tdefine(" + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" : this.names.amd && !0 === this.namedDefine ? "\t\tdefine(" + libraryName(this.names.amd) + ", [], " + amdFactory + ");\n" : "\t\tdefine([], " + amdFactory + ");\n") + (this.names.root || this.names.commonjs ? getAuxilaryComment("commonjs") + "\telse if(typeof exports === 'object')\n\t\texports[" + libraryName(this.names.commonjs || this.names.root) + "] = factory(" + externalsRequireArray("commonjs") + ");\n" + getAuxilaryComment("root") + "\telse\n\t\t" + replaceKeys(((base, accessor, joinWith = ", ") => {
          const accessors = Array.isArray(accessor) ? accessor : [ accessor ];
          return accessors.map((_, idx) => {
            const a = base ? base + accessorToObjectAccess(accessors.slice(0, idx + 1)) : accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
            return idx === accessors.length - 1 ? a : 0 === idx && void 0 === base ? `${a} = typeof ${a} === "object" ? ${a} : {}` : `${a} = ${a} || {}`;
          }).join(joinWith);
        })("root", this.names.root || this.names.commonjs)) + " = factory(" + externalsRootArray(externals) + ");\n" : "\telse {\n" + (externals.length > 0 ? "\t\tvar a = typeof exports === 'object' ? factory(" + externalsRequireArray("commonjs") + ") : factory(" + externalsRootArray(externals) + ");\n" : "\t\tvar a = factory();\n") + "\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n") + `})(${runtimeTemplate.outputOptions.globalObject}, function(${externalsArguments(externals)}) {\nreturn `, "webpack/universalModuleDefinition"), source, ";\n})");
      };
      for (const template of [ mainTemplate, chunkTemplate ]) template.hooks.renderWithEntry.tap("UmdMainTemplatePlugin", onRenderWithEntry);
      mainTemplate.hooks.globalHashPaths.tap("UmdMainTemplatePlugin", paths => (this.names.root && (paths = paths.concat(this.names.root)), 
      this.names.amd && (paths = paths.concat(this.names.amd)), this.names.commonjs && (paths = paths.concat(this.names.commonjs)), 
      paths)), mainTemplate.hooks.hash.tap("UmdMainTemplatePlugin", hash => {
        hash.update("umd"), hash.update("" + this.names.root), hash.update("" + this.names.amd), 
        hash.update("" + this.names.commonjs);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class AMDRequireDependency extends NullDependency {
    constructor(block) {
      super(), this.block = block;
    }
  }
  AMDRequireDependency.Template = class {
    apply(dep, source, runtime) {
      const depBlock = dep.block, promise = runtime.blockPromise({
        block: depBlock,
        message: "AMD require"
      });
      if (depBlock.arrayRange && !depBlock.functionRange) {
        const startBlock = promise + ".then(function() {", endBlock = `;}).catch(${runtime.onError()})`;
        return source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1, startBlock), 
        void source.replace(depBlock.arrayRange[1], depBlock.outerRange[1] - 1, endBlock);
      }
      if (depBlock.functionRange && !depBlock.arrayRange) {
        const startBlock = promise + ".then((", endBlock = `).bind(exports, __webpack_require__, exports, module)).catch(${runtime.onError()})`;
        return source.replace(depBlock.outerRange[0], depBlock.functionRange[0] - 1, startBlock), 
        void source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, endBlock);
      }
      if (depBlock.arrayRange && depBlock.functionRange && depBlock.errorCallbackRange) {
        const startBlock = promise + ".then(function() { ", errorRangeBlock = `}${depBlock.functionBindThis ? ".bind(this)" : ""}).catch(`, endBlock = (depBlock.errorCallbackBindThis ? ".bind(this)" : "") + ")";
        return source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1, startBlock), 
        source.insert(depBlock.arrayRange[0] + .9, "var __WEBPACK_AMD_REQUIRE_ARRAY__ = "), 
        source.replace(depBlock.arrayRange[1], depBlock.functionRange[0] - 1, "; ("), source.insert(depBlock.functionRange[1], ").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"), 
        source.replace(depBlock.functionRange[1], depBlock.errorCallbackRange[0] - 1, errorRangeBlock), 
        void source.replace(depBlock.errorCallbackRange[1], depBlock.outerRange[1] - 1, endBlock);
      }
      if (depBlock.arrayRange && depBlock.functionRange) {
        const startBlock = promise + ".then(function() { ", endBlock = `}${depBlock.functionBindThis ? ".bind(this)" : ""}).catch(${runtime.onError()})`;
        source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1, startBlock), 
        source.insert(depBlock.arrayRange[0] + .9, "var __WEBPACK_AMD_REQUIRE_ARRAY__ = "), 
        source.replace(depBlock.arrayRange[1], depBlock.functionRange[0] - 1, "; ("), source.insert(depBlock.functionRange[1], ").apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);"), 
        source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, endBlock);
      }
    }
  }, module.exports = AMDRequireDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  class AMDDefineDependency extends NullDependency {
    constructor(range, arrayRange, functionRange, objectRange, namedModule) {
      super(), this.range = range, this.arrayRange = arrayRange, this.functionRange = functionRange, 
      this.objectRange = objectRange, this.namedModule = namedModule, this.localModule = null;
    }
    get type() {
      return "amd define";
    }
  }
  AMDDefineDependency.Template = class {
    get definitions() {
      return {
        f: [ "var __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_RESULT__ = (#).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))" ],
        o: [ "", "!(module.exports = #)" ],
        of: [ "var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))" ],
        af: [ "var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = (#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))" ],
        ao: [ "", "!(#, module.exports = #)" ],
        aof: [ "var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))" ],
        lf: [ "var XXX, XXXmodule;", "!(XXXmodule = { id: YYY, exports: {}, loaded: false }, XXX = #.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule), XXXmodule.loaded = true, XXX === undefined && (XXX = XXXmodule.exports))" ],
        lo: [ "var XXX;", "!(XXX = #)" ],
        lof: [ "var XXX, XXXfactory, XXXmodule;", "!(XXXfactory = (#), (XXXmodule = { id: YYY, exports: {}, loaded: false }), XXX = (typeof XXXfactory === 'function' ? (XXXfactory.call(XXXmodule.exports, __webpack_require__, XXXmodule.exports, XXXmodule)) : XXXfactory), (XXXmodule.loaded = true), XXX === undefined && (XXX = XXXmodule.exports))" ],
        laf: [ "var __WEBPACK_AMD_DEFINE_ARRAY__, XXX;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = ((#).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))" ],
        lao: [ "var XXX;", "!(#, XXX = #)" ],
        laof: [ "var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, XXX;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#),\n\t\t\t\tXXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__))" ]
      };
    }
    apply(dependency, source) {
      const branch = this.branch(dependency), defAndText = this.definitions[branch], definitions = defAndText[0], text = defAndText[1];
      this.replace(dependency, source, definitions, text);
    }
    localModuleVar(dependency) {
      return dependency.localModule && dependency.localModule.used && dependency.localModule.variableName();
    }
    branch(dependency) {
      return (this.localModuleVar(dependency) ? "l" : "") + (dependency.arrayRange ? "a" : "") + (dependency.objectRange ? "o" : "") + (dependency.functionRange ? "f" : "");
    }
    replace(dependency, source, definition, text) {
      const localModuleVar = this.localModuleVar(dependency);
      localModuleVar && (text = text.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$")), 
      definition = definition.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"))), 
      dependency.namedModule && (text = text.replace(/YYY/g, JSON.stringify(dependency.namedModule)));
      const texts = text.split("#");
      definition && source.insert(0, definition);
      let current = dependency.range[0];
      if (dependency.arrayRange && (source.replace(current, dependency.arrayRange[0] - 1, texts.shift()), 
      current = dependency.arrayRange[1]), dependency.objectRange ? (source.replace(current, dependency.objectRange[0] - 1, texts.shift()), 
      current = dependency.objectRange[1]) : dependency.functionRange && (source.replace(current, dependency.functionRange[0] - 1, texts.shift()), 
      current = dependency.functionRange[1]), source.replace(current, dependency.range[1] - 1, texts.shift()), 
      texts.length > 0) throw new Error("Implementation error");
    }
  }, module.exports = AMDDefineDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7), webpackMissingModule = __webpack_require__(45).module;
  class UnsupportedDependency extends NullDependency {
    constructor(request, range) {
      super(), this.request = request, this.range = range;
    }
  }
  UnsupportedDependency.Template = class {
    apply(dep, source, runtime) {
      source.replace(dep.range[0], dep.range[1], webpackMissingModule(dep.request));
    }
  }, module.exports = UnsupportedDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(items) {
      this.set = new Set(items), this.iterator = this.set[Symbol.iterator]();
    }
    get length() {
      return this.set.size;
    }
    enqueue(item) {
      this.set.add(item);
    }
    dequeue() {
      const result = this.iterator.next();
      if (!result.done) return this.set.delete(result.value), result.value;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const mm = __webpack_require__(352), HarmonyExportImportedSpecifierDependency = __webpack_require__(50), HarmonyImportSideEffectDependency = __webpack_require__(34), HarmonyImportSpecifierDependency = __webpack_require__(49), getMappingFromInfo = (info, exportName) => {
    const staticMappings = info.static.get(exportName);
    if (void 0 !== staticMappings) return 1 === staticMappings.length ? staticMappings[0] : void 0;
    const dynamicMappings = Array.from(info.dynamic).filter(([_, ignored]) => !ignored.has(exportName));
    return 1 === dynamicMappings.length ? {
      module: dynamicMappings[0][0],
      exportName: exportName,
      checked: !0
    } : void 0;
  }, addStaticReexport = (info, exportName, module, innerExportName, checked) => {
    let mappings = info.static.get(exportName);
    if (void 0 !== mappings) {
      for (const mapping of mappings) if (mapping.module === module && mapping.exportName === innerExportName) return void (mapping.checked = mapping.checked && checked);
    } else mappings = [], info.static.set(exportName, mappings);
    mappings.push({
      module: module,
      exportName: innerExportName,
      checked: checked
    });
  }, addDynamicReexport = (info, module, ignored) => {
    const existingList = info.dynamic.get(module);
    if (void 0 !== existingList) for (const key of existingList) ignored.has(key) || existingList.delete(key); else info.dynamic.set(module, new Set(ignored));
  };
  class SideEffectsFlagPlugin {
    apply(compiler) {
      compiler.hooks.normalModuleFactory.tap("SideEffectsFlagPlugin", nmf => {
        nmf.hooks.module.tap("SideEffectsFlagPlugin", (module, data) => {
          const resolveData = data.resourceResolveData;
          if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {
            const sideEffects = resolveData.descriptionFileData.sideEffects;
            SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects) || (module.factoryMeta.sideEffectFree = !0);
          }
          return module;
        }), nmf.hooks.module.tap("SideEffectsFlagPlugin", (module, data) => {
          !1 === data.settings.sideEffects ? module.factoryMeta.sideEffectFree = !0 : !0 === data.settings.sideEffects && (module.factoryMeta.sideEffectFree = !1);
        });
      }), compiler.hooks.compilation.tap("SideEffectsFlagPlugin", compilation => {
        compilation.hooks.optimizeDependencies.tap("SideEffectsFlagPlugin", modules => {
          const reexportMaps = new Map;
          for (const module of modules) {
            const removeDependencies = [];
            for (const dep of module.dependencies) if (dep instanceof HarmonyImportSideEffectDependency) dep.module && dep.module.factoryMeta.sideEffectFree && removeDependencies.push(dep); else if (dep instanceof HarmonyExportImportedSpecifierDependency && module.factoryMeta.sideEffectFree) {
              const mode = dep.getMode(!0);
              if ("safe-reexport" === mode.type || "checked-reexport" === mode.type || "dynamic-reexport" === mode.type || "reexport-non-harmony-default" === mode.type || "reexport-non-harmony-default-strict" === mode.type || "reexport-named-default" === mode.type) {
                let info = reexportMaps.get(module);
                info || reexportMaps.set(module, info = {
                  static: new Map,
                  dynamic: new Map
                });
                const targetModule = dep._module;
                switch (mode.type) {
                 case "safe-reexport":
                  for (const [key, id] of mode.map) id && addStaticReexport(info, key, targetModule, id, !1);
                  break;

                 case "checked-reexport":
                  for (const [key, id] of mode.map) id && addStaticReexport(info, key, targetModule, id, !0);
                  break;

                 case "dynamic-reexport":
                  addDynamicReexport(info, targetModule, mode.ignored);
                  break;

                 case "reexport-non-harmony-default":
                 case "reexport-non-harmony-default-strict":
                 case "reexport-named-default":
                  addStaticReexport(info, mode.name, targetModule, "default", !1);
                }
              }
            }
          }
          for (const info of reexportMaps.values()) {
            const dynamicReexports = info.dynamic;
            info.dynamic = new Map;
            for (const reexport of dynamicReexports) {
              let [targetModule, ignored] = reexport;
              for (;;) {
                const innerInfo = reexportMaps.get(targetModule);
                if (!innerInfo) break;
                for (const [key, reexports] of innerInfo.static) if (!ignored.has(key)) for (const {module: module, exportName: exportName, checked: checked} of reexports) addStaticReexport(info, key, module, exportName, checked);
                if (1 !== innerInfo.dynamic.size) break;
                ignored = new Set(ignored);
                for (const [innerModule, innerIgnored] of innerInfo.dynamic) {
                  for (const key of innerIgnored) ignored.has(key) || (addStaticReexport(info, key, targetModule, key, !0), 
                  ignored.add(key));
                  targetModule = innerModule;
                }
              }
              addDynamicReexport(info, targetModule, ignored);
            }
          }
          for (const info of reexportMaps.values()) {
            const staticReexports = info.static;
            info.static = new Map;
            for (const [key, reexports] of staticReexports) for (let mapping of reexports) {
              for (;;) {
                const innerInfo = reexportMaps.get(mapping.module);
                if (!innerInfo) break;
                const newMapping = getMappingFromInfo(innerInfo, mapping.exportName);
                if (!newMapping) break;
                mapping = newMapping;
              }
              addStaticReexport(info, key, mapping.module, mapping.exportName, mapping.checked);
            }
          }
          for (const pair of reexportMaps) {
            const module = pair[0], info = pair[1];
            let newReasons = void 0;
            for (let i = 0; i < module.reasons.length; i++) {
              const reason = module.reasons[i], dep = reason.dependency;
              if ((dep instanceof HarmonyExportImportedSpecifierDependency || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) && dep._id) {
                const mapping = getMappingFromInfo(info, dep._id);
                if (mapping) {
                  dep.redirectedModule = mapping.module, dep.redirectedId = mapping.exportName, mapping.module.addReason(reason.module, dep, reason.explanation ? reason.explanation + " (skipped side-effect-free modules)" : "(skipped side-effect-free modules)"), 
                  void 0 === newReasons && (newReasons = 0 === i ? [] : module.reasons.slice(0, i));
                  continue;
                }
              }
              void 0 !== newReasons && newReasons.push(reason);
            }
            void 0 !== newReasons && (module.reasons = newReasons);
          }
        });
      });
    }
    static moduleHasSideEffects(moduleName, flagValue) {
      switch (typeof flagValue) {
       case "undefined":
        return !0;

       case "boolean":
        return flagValue;

       case "string":
        return "win32" === process.platform && (flagValue = flagValue.replace(/\\/g, "/")), 
        mm.isMatch(moduleName, flagValue, {
          matchBase: !0
        });

       case "object":
        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob));
      }
    }
  }
  module.exports = SideEffectsFlagPlugin;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const HarmonyImportDependency = __webpack_require__(22), ModuleHotAcceptDependency = __webpack_require__(162), ModuleHotDeclineDependency = __webpack_require__(163), ConcatenatedModule = __webpack_require__(355), HarmonyCompatibilityDependency = __webpack_require__(48), StackedSetMap = __webpack_require__(116), formatBailoutReason = msg => "ModuleConcatenation bailout: " + msg;
  class ConcatConfiguration {
    constructor(rootModule, cloneFrom) {
      this.rootModule = rootModule, cloneFrom ? (this.modules = cloneFrom.modules.createChild(5), 
      this.warnings = cloneFrom.warnings.createChild(5)) : (this.modules = new StackedSetMap, 
      this.modules.add(rootModule), this.warnings = new StackedSetMap);
    }
    add(module) {
      this.modules.add(module);
    }
    has(module) {
      return this.modules.has(module);
    }
    isEmpty() {
      return 1 === this.modules.size;
    }
    addWarning(module, problem) {
      this.warnings.set(module, problem);
    }
    getWarningsSorted() {
      return new Map(this.warnings.asPairArray().sort((a, b) => {
        const ai = a[0].identifier(), bi = b[0].identifier();
        return ai < bi ? -1 : ai > bi ? 1 : 0;
      }));
    }
    getModules() {
      return this.modules.asSet();
    }
    clone() {
      return new ConcatConfiguration(this.rootModule, this);
    }
    set(config) {
      this.rootModule = config.rootModule, this.modules = config.modules, this.warnings = config.warnings;
    }
  }
  module.exports = class {
    constructor(options) {
      "object" != typeof options && (options = {}), this.options = options;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("ModuleConcatenationPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const handler = (parser, parserOptions) => {
          parser.hooks.call.for("eval").tap("ModuleConcatenationPlugin", () => {
            parser.state.module.buildMeta.moduleConcatenationBailout = "eval()";
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("ModuleConcatenationPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ModuleConcatenationPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("ModuleConcatenationPlugin", handler);
        const bailoutReasonMap = new Map, setBailoutReason = (module, reason) => {
          bailoutReasonMap.set(module, reason), module.optimizationBailout.push("function" == typeof reason ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));
        }, getBailoutReason = (module, requestShortener) => {
          const reason = bailoutReasonMap.get(module);
          return "function" == typeof reason ? reason(requestShortener) : reason;
        };
        compilation.hooks.optimizeChunkModules.tap("ModuleConcatenationPlugin", (allChunks, modules) => {
          const relevantModules = [], possibleInners = new Set;
          for (const module of modules) {
            if (!module.buildMeta || "namespace" !== module.buildMeta.exportsType || !module.dependencies.some(d => d instanceof HarmonyCompatibilityDependency)) {
              setBailoutReason(module, "Module is not an ECMAScript module");
              continue;
            }
            if (module.buildMeta && module.buildMeta.moduleConcatenationBailout) {
              setBailoutReason(module, "Module uses " + module.buildMeta.moduleConcatenationBailout);
              continue;
            }
            if (!Array.isArray(module.buildMeta.providedExports)) {
              setBailoutReason(module, "Module exports are unknown");
              continue;
            }
            if (module.variables.length > 0) {
              setBailoutReason(module, `Module uses injected variables (${module.variables.map(v => v.name).join(", ")})`);
              continue;
            }
            if (module.dependencies.some(dep => dep instanceof ModuleHotAcceptDependency || dep instanceof ModuleHotDeclineDependency)) {
              setBailoutReason(module, "Module uses Hot Module Replacement");
              continue;
            }
            if (relevantModules.push(module), module.isEntryModule()) {
              setBailoutReason(module, "Module is an entry point");
              continue;
            }
            if (0 === module.getNumberOfChunks()) {
              setBailoutReason(module, "Module is not in any chunk");
              continue;
            }
            const nonHarmonyReasons = module.reasons.filter(reason => !(reason.dependency && reason.dependency instanceof HarmonyImportDependency));
            if (nonHarmonyReasons.length > 0) {
              const importingModules = new Set(nonHarmonyReasons.map(r => r.module).filter(Boolean)), importingExplanations = new Set(nonHarmonyReasons.map(r => r.explanation).filter(Boolean)), importingModuleTypes = new Map(Array.from(importingModules).map(m => [ m, new Set(nonHarmonyReasons.filter(r => r.module === m).map(r => r.dependency.type).sort()) ]));
              setBailoutReason(module, requestShortener => {
                const names = Array.from(importingModules).map(m => `${m.readableIdentifier(requestShortener)} (referenced with ${Array.from(importingModuleTypes.get(m)).join(", ")})`).sort(), explanations = Array.from(importingExplanations).sort();
                return names.length > 0 && 0 === explanations.length ? "Module is referenced from these modules with unsupported syntax: " + names.join(", ") : 0 === names.length && explanations.length > 0 ? "Module is referenced by: " + explanations.join(", ") : names.length > 0 && explanations.length > 0 ? `Module is referenced from these modules with unsupported syntax: ${names.join(", ")} and by: ${explanations.join(", ")}` : "Module is referenced in a unsupported way";
              });
            } else possibleInners.add(module);
          }
          relevantModules.sort((a, b) => a.depth - b.depth);
          const concatConfigurations = [], usedAsInner = new Set;
          for (const currentRoot of relevantModules) {
            if (usedAsInner.has(currentRoot)) continue;
            const currentConfiguration = new ConcatConfiguration(currentRoot), failureCache = new Map;
            for (const imp of this._getImports(compilation, currentRoot)) {
              const problem = this._tryToAdd(compilation, currentConfiguration, imp, possibleInners, failureCache);
              problem && (failureCache.set(imp, problem), currentConfiguration.addWarning(imp, problem));
            }
            if (!currentConfiguration.isEmpty()) {
              concatConfigurations.push(currentConfiguration);
              for (const module of currentConfiguration.getModules()) module !== currentConfiguration.rootModule && usedAsInner.add(module);
            }
          }
          concatConfigurations.sort((a, b) => b.modules.size - a.modules.size);
          const usedModules = new Set;
          for (const concatConfiguration of concatConfigurations) {
            if (usedModules.has(concatConfiguration.rootModule)) continue;
            const modules = concatConfiguration.getModules(), rootModule = concatConfiguration.rootModule, newModule = new ConcatenatedModule(rootModule, Array.from(modules), ConcatenatedModule.createConcatenationList(rootModule, modules, compilation));
            for (const warning of concatConfiguration.getWarningsSorted()) newModule.optimizationBailout.push(requestShortener => {
              const reason = getBailoutReason(warning[0], requestShortener), reasonWithPrefix = reason ? ` (<- ${reason})` : "";
              return warning[0] === warning[1] ? formatBailoutReason(`Cannot concat with ${warning[0].readableIdentifier(requestShortener)}${reasonWithPrefix}`) : formatBailoutReason(`Cannot concat with ${warning[0].readableIdentifier(requestShortener)} because of ${warning[1].readableIdentifier(requestShortener)}${reasonWithPrefix}`);
            });
            const chunks = concatConfiguration.rootModule.getChunks();
            for (const m of modules) {
              usedModules.add(m);
              for (const chunk of chunks) chunk.removeModule(m);
            }
            for (const chunk of chunks) chunk.addModule(newModule), newModule.addChunk(chunk);
            for (const chunk of allChunks) chunk.entryModule === concatConfiguration.rootModule && (chunk.entryModule = newModule);
            compilation.modules.push(newModule);
            for (const reason of newModule.reasons) reason.dependency.module === concatConfiguration.rootModule && (reason.dependency.module = newModule), 
            reason.dependency.redirectedModule === concatConfiguration.rootModule && (reason.dependency.redirectedModule = newModule);
            for (let i = 0; i < newModule.dependencies.length; i++) {
              let dep = newModule.dependencies[i];
              if (dep.module) {
                let reasons = dep.module.reasons;
                for (let j = 0; j < reasons.length; j++) {
                  let reason = reasons[j];
                  reason.dependency === dep && (reason.module = newModule);
                }
              }
            }
          }
          compilation.modules = compilation.modules.filter(m => !usedModules.has(m));
        });
      });
    }
    _getImports(compilation, module) {
      return new Set(module.dependencies.map(dep => dep instanceof HarmonyImportDependency ? compilation ? compilation.getDependencyReference(module, dep) : dep.getReference() : null).filter(ref => ref && ref.module && (Array.isArray(ref.importedNames) || Array.isArray(ref.module.buildMeta.providedExports))).map(ref => ref.module));
    }
    _tryToAdd(compilation, config, module, possibleModules, failureCache) {
      const cacheEntry = failureCache.get(module);
      if (cacheEntry) return cacheEntry;
      if (config.has(module)) return null;
      if (!possibleModules.has(module)) return failureCache.set(module, module), module;
      if (!config.rootModule.hasEqualsChunks(module)) return failureCache.set(module, module), 
      module;
      const testConfig = config.clone();
      testConfig.add(module);
      for (const reason of module.reasons) {
        if (reason.module.factoryMeta.sideEffectFree && !1 === reason.module.used) continue;
        const problem = this._tryToAdd(compilation, testConfig, reason.module, possibleModules, failureCache);
        if (problem) return failureCache.set(module, problem), problem;
      }
      config.set(testConfig);
      for (const imp of this._getImports(compilation, module)) {
        const problem = this._tryToAdd(compilation, config, imp, possibleModules, failureCache);
        problem && config.addWarning(imp, problem);
      }
      return null;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4), ModuleDependencyTemplateAsId = __webpack_require__(46);
  class ModuleHotAcceptDependency extends ModuleDependency {
    constructor(request, range) {
      super(request), this.range = range, this.weak = !0;
    }
    get type() {
      return "module.hot.accept";
    }
  }
  ModuleHotAcceptDependency.Template = ModuleDependencyTemplateAsId, module.exports = ModuleHotAcceptDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4), ModuleDependencyTemplateAsId = __webpack_require__(46);
  class ModuleHotDeclineDependency extends ModuleDependency {
    constructor(request, range) {
      super(request), this.range = range, this.weak = !0;
    }
    get type() {
      return "module.hot.decline";
    }
  }
  ModuleHotDeclineDependency.Template = ModuleDependencyTemplateAsId, module.exports = ModuleHotDeclineDependency;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Syntax = __webpack_require__(55).Syntax, Reference = __webpack_require__(87), Variable = __webpack_require__(56), Definition = __webpack_require__(165).Definition, assert = __webpack_require__(30);
  function shouldBeStatically(def) {
    return def.type === Variable.ClassName || def.type === Variable.Variable && "var" !== def.parent.kind;
  }
  class Scope {
    constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
      this.type = type, this.set = new Map, this.taints = new Map, this.dynamic = "global" === this.type || "with" === this.type, 
      this.block = block, this.through = [], this.variables = [], this.references = [], 
      this.variableScope = "global" === this.type || "function" === this.type || "module" === this.type ? this : upperScope.variableScope, 
      this.functionExpressionScope = !1, this.directCallToEvalScope = !1, this.thisFound = !1, 
      this.__left = [], this.upper = upperScope, this.isStrict = function(scope, block, isMethodDefinition, useDirective) {
        let body;
        if (scope.upper && scope.upper.isStrict) return !0;
        if (isMethodDefinition) return !0;
        if ("class" === scope.type || "module" === scope.type) return !0;
        if ("block" === scope.type || "switch" === scope.type) return !1;
        if ("function" === scope.type) {
          if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) return !1;
          if (body = block.type === Syntax.Program ? block : block.body, !body) return !1;
        } else {
          if ("global" !== scope.type) return !1;
          body = block;
        }
        if (useDirective) for (let i = 0, iz = body.body.length; i < iz; ++i) {
          const stmt = body.body[i];
          if (stmt.type !== Syntax.DirectiveStatement) break;
          if ('"use strict"' === stmt.raw || "'use strict'" === stmt.raw) return !0;
        } else for (let i = 0, iz = body.body.length; i < iz; ++i) {
          const stmt = body.body[i];
          if (stmt.type !== Syntax.ExpressionStatement) break;
          const expr = stmt.expression;
          if (expr.type !== Syntax.Literal || "string" != typeof expr.value) break;
          if (null !== expr.raw && void 0 !== expr.raw) {
            if ('"use strict"' === expr.raw || "'use strict'" === expr.raw) return !0;
          } else if ("use strict" === expr.value) return !0;
        }
        return !1;
      }(this, block, isMethodDefinition, scopeManager.__useDirective()), this.childScopes = [], 
      this.upper && this.upper.childScopes.push(this), this.__declaredVariables = scopeManager.__declaredVariables, 
      function(scopeManager, scope) {
        scopeManager.scopes.push(scope);
        const scopes = scopeManager.__nodeToScope.get(scope.block);
        scopes ? scopes.push(scope) : scopeManager.__nodeToScope.set(scope.block, [ scope ]);
      }(scopeManager, this);
    }
    __shouldStaticallyClose(scopeManager) {
      return !this.dynamic || scopeManager.__isOptimistic();
    }
    __shouldStaticallyCloseForGlobal(ref) {
      const name = ref.identifier.name;
      if (!this.set.has(name)) return !1;
      const defs = this.set.get(name).defs;
      return defs.length > 0 && defs.every(shouldBeStatically);
    }
    __staticCloseRef(ref) {
      this.__resolve(ref) || this.__delegateToUpperScope(ref);
    }
    __dynamicCloseRef(ref) {
      let current = this;
      do {
        current.through.push(ref), current = current.upper;
      } while (current);
    }
    __globalCloseRef(ref) {
      this.__shouldStaticallyCloseForGlobal(ref) ? this.__staticCloseRef(ref) : this.__dynamicCloseRef(ref);
    }
    __close(scopeManager) {
      let closeRef;
      closeRef = this.__shouldStaticallyClose(scopeManager) ? this.__staticCloseRef : "global" !== this.type ? this.__dynamicCloseRef : this.__globalCloseRef;
      for (let i = 0, iz = this.__left.length; i < iz; ++i) {
        const ref = this.__left[i];
        closeRef.call(this, ref);
      }
      return this.__left = null, this.upper;
    }
    __isValidResolution(ref, variable) {
      return !0;
    }
    __resolve(ref) {
      const name = ref.identifier.name;
      if (!this.set.has(name)) return !1;
      const variable = this.set.get(name);
      return !!this.__isValidResolution(ref, variable) && (variable.references.push(ref), 
      variable.stack = variable.stack && ref.from.variableScope === this.variableScope, 
      ref.tainted && (variable.tainted = !0, this.taints.set(variable.name, !0)), ref.resolved = variable, 
      !0);
    }
    __delegateToUpperScope(ref) {
      this.upper && this.upper.__left.push(ref), this.through.push(ref);
    }
    __addDeclaredVariablesOfNode(variable, node) {
      if (null == node) return;
      let variables = this.__declaredVariables.get(node);
      null == variables && (variables = [], this.__declaredVariables.set(node, variables)), 
      -1 === variables.indexOf(variable) && variables.push(variable);
    }
    __defineGeneric(name, set, variables, node, def) {
      let variable;
      variable = set.get(name), variable || (variable = new Variable(name, this), set.set(name, variable), 
      variables.push(variable)), def && (variable.defs.push(def), this.__addDeclaredVariablesOfNode(variable, def.node), 
      this.__addDeclaredVariablesOfNode(variable, def.parent)), node && variable.identifiers.push(node);
    }
    __define(node, def) {
      node && node.type === Syntax.Identifier && this.__defineGeneric(node.name, this.set, this.variables, node, def);
    }
    __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
      if (!node || node.type !== Syntax.Identifier) return;
      if ("super" === node.name) return;
      const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
      this.references.push(ref), this.__left.push(ref);
    }
    __detectEval() {
      let current = this;
      this.directCallToEvalScope = !0;
      do {
        current.dynamic = !0, current = current.upper;
      } while (current);
    }
    __detectThis() {
      this.thisFound = !0;
    }
    __isClosed() {
      return null === this.__left;
    }
    resolve(ident) {
      let ref, i, iz;
      for (assert(this.__isClosed(), "Scope should be closed."), assert(ident.type === Syntax.Identifier, "Target should be identifier."), 
      i = 0, iz = this.references.length; i < iz; ++i) if (ref = this.references[i], ref.identifier === ident) return ref;
      return null;
    }
    isStatic() {
      return !this.dynamic;
    }
    isArgumentsMaterialized() {
      return !0;
    }
    isThisMaterialized() {
      return !0;
    }
    isUsedName(name) {
      if (this.set.has(name)) return !0;
      for (let i = 0, iz = this.through.length; i < iz; ++i) if (this.through[i].identifier.name === name) return !0;
      return !1;
    }
  }
  module.exports = {
    Scope: Scope,
    GlobalScope: class extends Scope {
      constructor(scopeManager, block) {
        super(scopeManager, "global", null, block, !1), this.implicit = {
          set: new Map,
          variables: [],
          left: []
        };
      }
      __close(scopeManager) {
        const implicit = [];
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name) && implicit.push(ref.__maybeImplicitGlobal);
        }
        for (let i = 0, iz = implicit.length; i < iz; ++i) {
          const info = implicit[i];
          this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
        }
        return this.implicit.left = this.__left, super.__close(scopeManager);
      }
      __defineImplicit(node, def) {
        node && node.type === Syntax.Identifier && this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
      }
    },
    ModuleScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "module", upperScope, block, !1);
      }
    },
    FunctionExpressionNameScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "function-expression-name", upperScope, block, !1), this.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null)), 
        this.functionExpressionScope = !0;
      }
    },
    CatchScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "catch", upperScope, block, !1);
      }
    },
    WithScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "with", upperScope, block, !1);
      }
      __close(scopeManager) {
        if (this.__shouldStaticallyClose(scopeManager)) return super.__close(scopeManager);
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          ref.tainted = !0, this.__delegateToUpperScope(ref);
        }
        return this.__left = null, this.upper;
      }
    },
    BlockScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "block", upperScope, block, !1);
      }
    },
    SwitchScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "switch", upperScope, block, !1);
      }
    },
    FunctionScope: class extends Scope {
      constructor(scopeManager, upperScope, block, isMethodDefinition) {
        super(scopeManager, "function", upperScope, block, isMethodDefinition), this.block.type !== Syntax.ArrowFunctionExpression && this.__defineArguments();
      }
      isArgumentsMaterialized() {
        if (this.block.type === Syntax.ArrowFunctionExpression) return !1;
        if (!this.isStatic()) return !0;
        const variable = this.set.get("arguments");
        return assert(variable, "Always have arguments variable."), variable.tainted || 0 !== variable.references.length;
      }
      isThisMaterialized() {
        return !this.isStatic() || this.thisFound;
      }
      __defineArguments() {
        this.__defineGeneric("arguments", this.set, this.variables, null, null), this.taints.set("arguments", !0);
      }
      __isValidResolution(ref, variable) {
        if ("Program" === this.block.type) return !0;
        const bodyStart = this.block.body.range[0];
        return !(variable.scope === this && ref.identifier.range[0] < bodyStart && variable.defs.every(d => d.name.range[0] >= bodyStart));
      }
    },
    ForScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "for", upperScope, block, !1);
      }
    },
    ClassScope: class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "class", upperScope, block, !1);
      }
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Variable = __webpack_require__(56);
  class Definition {
    constructor(type, name, node, parent, index, kind) {
      this.type = type, this.name = name, this.node = node, this.parent = parent, this.index = index, 
      this.kind = kind;
    }
  }
  module.exports = {
    ParameterDefinition: class extends Definition {
      constructor(name, node, index, rest) {
        super(Variable.Parameter, name, node, null, index, null), this.rest = rest;
      }
    },
    Definition: Definition
  };
}, function(module, exports, __webpack_require__) {
  !function() {
    "use strict";
    var estraverse = __webpack_require__(55);
    function isNode(node) {
      return null != node && ("object" == typeof node && "string" == typeof node.type);
    }
    function Visitor(visitor, options) {
      options = options || {}, this.__visitor = visitor || this, this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys, 
      "iteration" === options.fallback ? this.__fallback = Object.keys : "function" == typeof options.fallback && (this.__fallback = options.fallback);
    }
    Visitor.prototype.visitChildren = function(node) {
      var type, children, i, iz, j, jz, child;
      if (null != node) {
        if (type = node.type || estraverse.Syntax.Property, !(children = this.__childVisitorKeys[type])) {
          if (!this.__fallback) throw new Error("Unknown node type " + type + ".");
          children = this.__fallback(node);
        }
        for (i = 0, iz = children.length; i < iz; ++i) if (child = node[children[i]]) if (Array.isArray(child)) for (j = 0, 
        jz = child.length; j < jz; ++j) child[j] && (!isNode(child[j]) && (nodeType = type, 
        key = children[i], nodeType !== estraverse.Syntax.ObjectExpression && nodeType !== estraverse.Syntax.ObjectPattern || "properties" !== key) || this.visit(child[j])); else isNode(child) && this.visit(child);
        var nodeType, key;
      }
    }, Visitor.prototype.visit = function(node) {
      var type;
      null != node && (type = node.type || estraverse.Syntax.Property, this.__visitor[type] ? this.__visitor[type].call(this, node) : this.visitChildren(node));
    }, exports.version = __webpack_require__(360).version, exports.Visitor = Visitor, 
    exports.visit = function(node, visitor, options) {
      new Visitor(visitor, options).visit(node);
    };
  }();
}, function(module, exports, __webpack_require__) {
  "use strict";
  const crypto = __webpack_require__(99), SortableSet = __webpack_require__(23), GraphHelpers = __webpack_require__(27), {isSubset: isSubset} = __webpack_require__(37), deterministicGrouping = __webpack_require__(363), MinMaxSizeWarning = __webpack_require__(364), contextify = __webpack_require__(14).contextify, deterministicGroupingForModules = deterministicGrouping, hashFilename = name => crypto.createHash("md4").update(name).digest("hex").slice(0, 8), sortByIdentifier = (a, b) => a.identifier() > b.identifier() ? 1 : a.identifier() < b.identifier() ? -1 : 0, getRequests = chunk => {
    let requests = 0;
    for (const chunkGroup of chunk.groupsIterable) requests = Math.max(requests, chunkGroup.chunks.length);
    return requests;
  }, getModulesSize = modules => {
    let sum = 0;
    for (const m of modules) sum += m.size();
    return sum;
  }, isOverlap = (a, b) => {
    for (const item of a) if (b.has(item)) return !0;
    return !1;
  }, compareEntries = (a, b) => {
    const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;
    if (diffPriority) return diffPriority;
    const diffCount = a.chunks.size - b.chunks.size;
    if (diffCount) return diffCount;
    const diffSizeReduce = a.size * (a.chunks.size - 1) - b.size * (b.chunks.size - 1);
    if (diffSizeReduce) return diffSizeReduce;
    const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;
    if (indexDiff) return indexDiff;
    const modulesA = a.modules, modulesB = b.modules, diff = modulesA.size - modulesB.size;
    if (diff) return diff;
    modulesA.sort(), modulesB.sort();
    const aI = modulesA[Symbol.iterator](), bI = modulesB[Symbol.iterator]();
    for (;;) {
      const aItem = aI.next(), bItem = bI.next();
      if (aItem.done) return 0;
      const aModuleIdentifier = aItem.value.identifier(), bModuleIdentifier = bItem.value.identifier();
      if (aModuleIdentifier > bModuleIdentifier) return -1;
      if (aModuleIdentifier < bModuleIdentifier) return 1;
    }
  }, compareNumbers = (a, b) => a - b, INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial(), ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial(), ALL_CHUNK_FILTER = chunk => !0;
  module.exports = class SplitChunksPlugin {
    constructor(options) {
      this.options = SplitChunksPlugin.normalizeOptions(options);
    }
    static normalizeOptions(options = {}) {
      return {
        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || "all"),
        minSize: options.minSize || 0,
        enforceSizeThreshold: options.enforceSizeThreshold || 0,
        maxSize: options.maxSize || 0,
        minChunks: options.minChunks || 1,
        maxAsyncRequests: options.maxAsyncRequests || 1,
        maxInitialRequests: options.maxInitialRequests || 1,
        hidePathInfo: options.hidePathInfo || !1,
        filename: options.filename || void 0,
        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({
          cacheGroups: options.cacheGroups,
          name: options.name,
          automaticNameDelimiter: options.automaticNameDelimiter,
          automaticNameMaxLength: options.automaticNameMaxLength
        }),
        automaticNameDelimiter: options.automaticNameDelimiter,
        automaticNameMaxLength: options.automaticNameMaxLength || 109,
        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)
      };
    }
    static normalizeName({name: name, automaticNameDelimiter: automaticNameDelimiter, automaticNamePrefix: automaticNamePrefix, automaticNameMaxLength: automaticNameMaxLength}) {
      if (!0 === name) {
        const cache = new WeakMap;
        return (module, chunks, cacheGroup) => {
          let cacheEntry = cache.get(chunks);
          if (void 0 === cacheEntry) cacheEntry = {}, cache.set(chunks, cacheEntry); else if (cacheGroup in cacheEntry) return cacheEntry[cacheGroup];
          const names = chunks.map(c => c.name);
          if (!names.every(Boolean)) return void (cacheEntry[cacheGroup] = void 0);
          names.sort();
          const prefix = "string" == typeof automaticNamePrefix ? automaticNamePrefix : cacheGroup;
          let name = (prefix ? prefix + automaticNameDelimiter : "") + names.join(automaticNameDelimiter);
          if (name.length > automaticNameMaxLength) {
            const hashedFilename = hashFilename(name), sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);
            name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;
          }
          return cacheEntry[cacheGroup] = name, name;
        };
      }
      if ("string" == typeof name) {
        return () => name;
      }
      if ("function" == typeof name) return name;
    }
    static normalizeChunksFilter(chunks) {
      return "initial" === chunks ? INITIAL_CHUNK_FILTER : "async" === chunks ? ASYNC_CHUNK_FILTER : "all" === chunks ? ALL_CHUNK_FILTER : "function" == typeof chunks ? chunks : void 0;
    }
    static normalizeFallbackCacheGroup({minSize: minSize, maxSize: maxSize, automaticNameDelimiter: automaticNameDelimiter}, {minSize: defaultMinSize, maxSize: defaultMaxSize, automaticNameDelimiter: defaultAutomaticNameDelimiter}) {
      return {
        minSize: "number" == typeof minSize ? minSize : defaultMinSize || 0,
        maxSize: "number" == typeof maxSize ? maxSize : defaultMaxSize || 0,
        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || "~"
      };
    }
    static normalizeCacheGroups({cacheGroups: cacheGroups, name: name, automaticNameDelimiter: automaticNameDelimiter, automaticNameMaxLength: automaticNameMaxLength}) {
      if ("function" == typeof cacheGroups) return 1 !== cacheGroups.length ? module => cacheGroups(module, module.getChunks()) : cacheGroups;
      if (cacheGroups && "object" == typeof cacheGroups) {
        return module => {
          let results;
          for (const key of Object.keys(cacheGroups)) {
            let option = cacheGroups[key];
            if (!1 !== option) if ((option instanceof RegExp || "string" == typeof option) && (option = {
              test: option
            }), "function" == typeof option) {
              let result = option(module);
              if (result) {
                void 0 === results && (results = []);
                for (const r of Array.isArray(result) ? result : [ result ]) {
                  const result = Object.assign({
                    key: key
                  }, r);
                  result.name && (result.getName = () => result.name), result.chunks && (result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks)), 
                  results.push(result);
                }
              }
            } else SplitChunksPlugin.checkTest(option.test, module) && (void 0 === results && (results = []), 
            results.push({
              key: key,
              priority: option.priority,
              getName: SplitChunksPlugin.normalizeName({
                name: option.name || name,
                automaticNameDelimiter: "string" == typeof option.automaticNameDelimiter ? option.automaticNameDelimiter : automaticNameDelimiter,
                automaticNamePrefix: option.automaticNamePrefix,
                automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength
              }) || (() => {}),
              chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),
              enforce: option.enforce,
              minSize: option.minSize,
              enforceSizeThreshold: option.enforceSizeThreshold,
              maxSize: option.maxSize,
              minChunks: option.minChunks,
              maxAsyncRequests: option.maxAsyncRequests,
              maxInitialRequests: option.maxInitialRequests,
              filename: option.filename,
              reuseExistingChunk: option.reuseExistingChunk
            }));
          }
          return results;
        };
      }
      return () => {};
    }
    static checkTest(test, module) {
      if (void 0 === test) return !0;
      if ("function" == typeof test) return 1 !== test.length ? test(module, module.getChunks()) : test(module);
      if ("boolean" == typeof test) return test;
      if ("string" == typeof test) {
        if (module.nameForCondition && module.nameForCondition().startsWith(test)) return !0;
        for (const chunk of module.chunksIterable) if (chunk.name && chunk.name.startsWith(test)) return !0;
        return !1;
      }
      if (test instanceof RegExp) {
        if (module.nameForCondition && test.test(module.nameForCondition())) return !0;
        for (const chunk of module.chunksIterable) if (chunk.name && test.test(chunk.name)) return !0;
        return !1;
      }
      return !1;
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("SplitChunksPlugin", compilation => {
        let alreadyOptimized = !1;
        compilation.hooks.unseal.tap("SplitChunksPlugin", () => {
          alreadyOptimized = !1;
        }), compilation.hooks.optimizeChunksAdvanced.tap("SplitChunksPlugin", chunks => {
          if (alreadyOptimized) return;
          alreadyOptimized = !0;
          const indexMap = new Map;
          let index = 1;
          for (const chunk of chunks) indexMap.set(chunk, index++);
          const getKey = chunks => Array.from(chunks, c => indexMap.get(c)).sort(compareNumbers).join(), chunkSetsInGraph = new Map;
          for (const module of compilation.modules) {
            const chunksKey = getKey(module.chunksIterable);
            chunkSetsInGraph.has(chunksKey) || chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));
          }
          const chunkSetsByCount = new Map;
          for (const chunksSet of chunkSetsInGraph.values()) {
            const count = chunksSet.size;
            let array = chunkSetsByCount.get(count);
            void 0 === array && (array = [], chunkSetsByCount.set(count, array)), array.push(chunksSet);
          }
          const combinationsCache = new Map, getCombinations = key => {
            const chunksSet = chunkSetsInGraph.get(key);
            var array = [ chunksSet ];
            if (chunksSet.size > 1) for (const [count, setArray] of chunkSetsByCount) if (count < chunksSet.size) for (const set of setArray) isSubset(chunksSet, set) && array.push(set);
            return array;
          }, selectedChunksCacheByChunksSet = new WeakMap, getSelectedChunks = (chunks, chunkFilter) => {
            let entry = selectedChunksCacheByChunksSet.get(chunks);
            void 0 === entry && (entry = new WeakMap, selectedChunksCacheByChunksSet.set(chunks, entry));
            let entry2 = entry.get(chunkFilter);
            if (void 0 === entry2) {
              const selectedChunks = [];
              for (const chunk of chunks) chunkFilter(chunk) && selectedChunks.push(chunk);
              entry2 = {
                chunks: selectedChunks,
                key: getKey(selectedChunks)
              }, entry.set(chunkFilter, entry2);
            }
            return entry2;
          }, chunksInfoMap = new Map, addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {
            if (selectedChunks.length < cacheGroup.minChunks) return;
            const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key), key = cacheGroup.key + (name ? " name:" + name : " chunks:" + selectedChunksKey);
            let info = chunksInfoMap.get(key);
            void 0 === info && chunksInfoMap.set(key, info = {
              modules: new SortableSet(void 0, sortByIdentifier),
              cacheGroup: cacheGroup,
              cacheGroupIndex: cacheGroupIndex,
              name: name,
              size: 0,
              chunks: new Set,
              reuseableChunks: new Set,
              chunksKeys: new Set
            });
            const oldSize = info.modules.size;
            info.modules.add(module), info.modules.size !== oldSize && (info.size += module.size());
            const oldChunksKeysSize = info.chunksKeys.size;
            if (info.chunksKeys.add(selectedChunksKey), oldChunksKeysSize !== info.chunksKeys.size) for (const chunk of selectedChunks) info.chunks.add(chunk);
          };
          for (const module of compilation.modules) {
            let cacheGroups = this.options.getCacheGroups(module);
            if (!Array.isArray(cacheGroups) || 0 === cacheGroups.length) continue;
            const chunksKey = getKey(module.chunksIterable);
            let combs = combinationsCache.get(chunksKey);
            void 0 === combs && (combs = getCombinations(chunksKey), combinationsCache.set(chunksKey, combs));
            let cacheGroupIndex = 0;
            for (const cacheGroupSource of cacheGroups) {
              const minSize = void 0 !== cacheGroupSource.minSize ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : this.options.minSize, enforceSizeThreshold = void 0 !== cacheGroupSource.enforceSizeThreshold ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : this.options.enforceSizeThreshold, cacheGroup = {
                key: cacheGroupSource.key,
                priority: cacheGroupSource.priority || 0,
                chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,
                minSize: minSize,
                minSizeForMaxSize: void 0 !== cacheGroupSource.minSize ? cacheGroupSource.minSize : this.options.minSize,
                enforceSizeThreshold: enforceSizeThreshold,
                maxSize: void 0 !== cacheGroupSource.maxSize ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : this.options.maxSize,
                minChunks: void 0 !== cacheGroupSource.minChunks ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,
                maxAsyncRequests: void 0 !== cacheGroupSource.maxAsyncRequests ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? 1 / 0 : this.options.maxAsyncRequests,
                maxInitialRequests: void 0 !== cacheGroupSource.maxInitialRequests ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? 1 / 0 : this.options.maxInitialRequests,
                getName: void 0 !== cacheGroupSource.getName ? cacheGroupSource.getName : this.options.getName,
                filename: void 0 !== cacheGroupSource.filename ? cacheGroupSource.filename : this.options.filename,
                automaticNameDelimiter: void 0 !== cacheGroupSource.automaticNameDelimiter ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,
                reuseExistingChunk: cacheGroupSource.reuseExistingChunk,
                _validateSize: minSize > 0,
                _conditionalEnforce: enforceSizeThreshold > 0
              };
              for (const chunkCombination of combs) {
                if (chunkCombination.size < cacheGroup.minChunks) continue;
                const {chunks: selectedChunks, key: selectedChunksKey} = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);
                addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);
              }
              cacheGroupIndex++;
            }
          }
          for (const pair of chunksInfoMap) {
            const info = pair[1];
            info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize && chunksInfoMap.delete(pair[0]);
          }
          const maxSizeQueueMap = new Map;
          for (;chunksInfoMap.size > 0; ) {
            let bestEntryKey, bestEntry;
            for (const pair of chunksInfoMap) {
              const key = pair[0], info = pair[1];
              (void 0 === bestEntry || compareEntries(bestEntry, info) < 0) && (bestEntry = info, 
              bestEntryKey = key);
            }
            const item = bestEntry;
            chunksInfoMap.delete(bestEntryKey);
            let newChunk, chunkName = item.name, isReused = !1;
            if (item.cacheGroup.reuseExistingChunk) outer: for (const chunk of item.chunks) if (chunk.getNumberOfModules() === item.modules.size && !chunk.hasEntryModule()) {
              for (const module of item.modules) if (!chunk.containsModule(module)) continue outer;
              newChunk && newChunk.name ? (chunk.name && chunk.name.length < newChunk.name.length || chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) && (newChunk = chunk) : newChunk = chunk, 
              chunkName = void 0, isReused = !0;
            }
            const selectedChunks = Array.from(item.chunks).filter(chunk => (!chunkName || chunk.name !== chunkName) && chunk !== newChunk), enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold;
            if (0 === selectedChunks.length) continue;
            const usedChunks = new Set(selectedChunks);
            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) for (const chunk of usedChunks) {
              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;
              isFinite(maxRequests) && getRequests(chunk) >= maxRequests && usedChunks.delete(chunk);
            }
            outer: for (const chunk of usedChunks) {
              for (const module of item.modules) if (chunk.containsModule(module)) continue outer;
              usedChunks.delete(chunk);
            }
            if (usedChunks.size < selectedChunks.length) {
              if (usedChunks.size >= item.cacheGroup.minChunks) {
                const chunksArr = Array.from(usedChunks);
                for (const module of item.modules) addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);
              }
            } else {
              isReused || (newChunk = compilation.addChunk(chunkName));
              for (const chunk of usedChunks) chunk.split(newChunk);
              if (newChunk.chunkReason = isReused ? "reused as split chunk" : "split chunk", item.cacheGroup.key && (newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`), 
              chunkName) {
                newChunk.chunkReason += ` (name: ${chunkName})`;
                const entrypoint = compilation.entrypoints.get(chunkName);
                entrypoint && (compilation.entrypoints.delete(chunkName), entrypoint.remove(), newChunk.entryModule = void 0);
              }
              if (item.cacheGroup.filename) {
                if (!newChunk.isOnlyInitial()) throw new Error(`SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. The runtime can only handle loading of chunks which match the chunkFilename schema. Using a custom filename would fail at runtime. (cache group: ${item.cacheGroup.key})`);
                newChunk.filenameTemplate = item.cacheGroup.filename;
              }
              if (isReused) for (const module of item.modules) for (const chunk of usedChunks) chunk.removeModule(module), 
              module.rewriteChunkInReasons(chunk, [ newChunk ]); else for (const module of item.modules) if ("function" != typeof module.chunkCondition || module.chunkCondition(newChunk)) {
                GraphHelpers.connectChunkAndModule(newChunk, module);
                for (const chunk of usedChunks) chunk.removeModule(module), module.rewriteChunkInReasons(chunk, [ newChunk ]);
              }
              if (item.cacheGroup.maxSize > 0) {
                const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);
                maxSizeQueueMap.set(newChunk, {
                  minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),
                  maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : 1 / 0, item.cacheGroup.maxSize),
                  automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,
                  keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [ item.cacheGroup.key ]
                });
              }
              for (const [key, info] of chunksInfoMap) if (isOverlap(info.chunks, usedChunks)) {
                const oldSize = info.modules.size;
                for (const module of item.modules) info.modules.delete(module);
                if (info.modules.size !== oldSize) {
                  if (0 === info.modules.size) {
                    chunksInfoMap.delete(key);
                    continue;
                  }
                  info.size = getModulesSize(info.modules), info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize && chunksInfoMap.delete(key), 
                  0 === info.modules.size && chunksInfoMap.delete(key);
                }
              }
            }
          }
          const incorrectMinMaxSizeSet = new Set;
          for (const chunk of compilation.chunks.slice()) {
            const {minSize: minSize, maxSize: maxSize, automaticNameDelimiter: automaticNameDelimiter, keys: keys} = maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;
            if (!maxSize) continue;
            if (minSize > maxSize) {
              const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;
              incorrectMinMaxSizeSet.has(warningKey) || (incorrectMinMaxSizeSet.add(warningKey), 
              compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize)));
            }
            const results = deterministicGroupingForModules({
              maxSize: Math.max(minSize, maxSize),
              minSize: minSize,
              items: chunk.modulesIterable,
              getKey(module) {
                const ident = contextify(compilation.options.context, module.identifier());
                return ((module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\?[^?!]*$/g, "")) + automaticNameDelimiter + hashFilename(ident)).replace(/[\\/?]/g, "_");
              },
              getSize: module => module.size()
            });
            results.sort((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0);
            for (let i = 0; i < results.length; i++) {
              const group = results[i], key = this.options.hidePathInfo ? hashFilename(group.key) : group.key;
              let newPart, name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;
              if (name && name.length > 100 && (name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name)), 
              i !== results.length - 1) {
                newPart = compilation.addChunk(name), chunk.split(newPart), newPart.chunkReason = chunk.chunkReason;
                for (const module of group.items) ("function" != typeof module.chunkCondition || module.chunkCondition(newPart)) && (GraphHelpers.connectChunkAndModule(newPart, module), 
                chunk.removeModule(module), module.rewriteChunkInReasons(chunk, [ newPart ]));
              } else newPart = chunk, chunk.name = name;
            }
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(options) {
      this.options = Object.assign({
        name: entrypoint => "runtime~" + entrypoint.name
      }, options);
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("RuntimeChunkPlugin", compilation => {
        compilation.hooks.optimizeChunksAdvanced.tap("RuntimeChunkPlugin", () => {
          for (const entrypoint of compilation.entrypoints.values()) {
            const chunk = entrypoint.getRuntimeChunk();
            let name = this.options.name;
            if ("function" == typeof name && (name = name(entrypoint)), chunk.getNumberOfModules() > 0 || !chunk.preventIntegration || chunk.name !== name) {
              const newChunk = compilation.addChunk(name);
              newChunk.preventIntegration = !0, entrypoint.unshiftChunk(newChunk), newChunk.addGroup(entrypoint), 
              entrypoint.setRuntimeChunk(newChunk);
            }
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(compiler) {
      compiler.hooks.shouldEmit.tap("NoEmitOnErrorsPlugin", compilation => {
        if (compilation.getStats().hasErrors()) return !1;
      }), compiler.hooks.compilation.tap("NoEmitOnErrorsPlugin", compilation => {
        compilation.hooks.shouldRecord.tap("NoEmitOnErrorsPlugin", () => {
          if (compilation.getStats().hasErrors()) return !1;
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const createHash = __webpack_require__(17), RequestShortener = __webpack_require__(58), getHash = str => {
    const hash = createHash("md4");
    hash.update(str);
    return hash.digest("hex").substr(0, 4);
  };
  module.exports = class {
    constructor(options) {
      this.options = options || {};
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("NamedModulesPlugin", compilation => {
        compilation.hooks.beforeModuleIds.tap("NamedModulesPlugin", modules => {
          const namedModules = new Map, context = this.options.context || compiler.options.context;
          for (const module of modules) if (null === module.id && module.libIdent && (module.id = module.libIdent({
            context: context
          })), null !== module.id) {
            const namedModule = namedModules.get(module.id);
            void 0 !== namedModule ? namedModule.push(module) : namedModules.set(module.id, [ module ]);
          }
          for (const namedModule of namedModules.values()) if (namedModule.length > 1) for (const module of namedModule) {
            const requestShortener = new RequestShortener(context);
            module.id = `${module.id}?${getHash(requestShortener.shorten(module.identifier()))}`;
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const createHash = __webpack_require__(17), validateOptions = __webpack_require__(8), schema = __webpack_require__(366);
  module.exports = class {
    constructor(options) {
      options || (options = {}), validateOptions(schema, options, "Hashed Module Ids Plugin"), 
      this.options = Object.assign({
        context: null,
        hashFunction: "md4",
        hashDigest: "base64",
        hashDigestLength: 4
      }, options);
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("HashedModuleIdsPlugin", compilation => {
        const usedIds = new Set;
        compilation.hooks.beforeModuleIds.tap("HashedModuleIdsPlugin", modules => {
          for (const module of modules) if (null === module.id && module.libIdent) {
            const id = module.libIdent({
              context: this.options.context || compiler.options.context
            }), hash = createHash(options.hashFunction);
            hash.update(id);
            const hashId = hash.digest(options.hashDigest);
            let len = options.hashDigestLength;
            for (;usedIds.has(hashId.substr(0, len)); ) len++;
            module.id = hashId.substr(0, len), usedIds.add(module.id);
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(367);
  module.exports = class {
    constructor(options = {}) {
      validateOptions(schema, options, "Occurrence Order Module Ids Plugin"), this.options = options;
    }
    apply(compiler) {
      const prioritiseInitial = this.options.prioritiseInitial;
      compiler.hooks.compilation.tap("OccurrenceOrderModuleIdsPlugin", compilation => {
        compilation.hooks.optimizeModuleOrder.tap("OccurrenceOrderModuleIdsPlugin", modules => {
          const occursInInitialChunksMap = new Map, occursInAllChunksMap = new Map, initialChunkChunkMap = new Map, entryCountMap = new Map;
          for (const m of modules) {
            let initial = 0, entry = 0;
            for (const c of m.chunksIterable) c.canBeInitial() && initial++, c.entryModule === m && entry++;
            initialChunkChunkMap.set(m, initial), entryCountMap.set(m, entry);
          }
          const countOccursInEntry = (sum, r) => {
            if (!r.module) return sum;
            const count = initialChunkChunkMap.get(r.module);
            return count ? sum + count : sum;
          }, countOccurs = (sum, r) => {
            if (!r.module) return sum;
            let factor = 1;
            return "function" == typeof r.dependency.getNumberOfIdOccurrences && (factor = r.dependency.getNumberOfIdOccurrences()), 
            0 === factor ? sum : sum + factor * r.module.getNumberOfChunks();
          };
          if (prioritiseInitial) for (const m of modules) {
            const result = m.reasons.reduce(countOccursInEntry, 0) + initialChunkChunkMap.get(m) + entryCountMap.get(m);
            occursInInitialChunksMap.set(m, result);
          }
          const originalOrder = new Map;
          let i = 0;
          for (const m of modules) {
            const result = m.reasons.reduce(countOccurs, 0) + m.getNumberOfChunks() + entryCountMap.get(m);
            occursInAllChunksMap.set(m, result), originalOrder.set(m, i++);
          }
          modules.sort((a, b) => {
            if (prioritiseInitial) {
              const aEntryOccurs = occursInInitialChunksMap.get(a), bEntryOccurs = occursInInitialChunksMap.get(b);
              if (aEntryOccurs > bEntryOccurs) return -1;
              if (aEntryOccurs < bEntryOccurs) return 1;
            }
            const aOccurs = occursInAllChunksMap.get(a), bOccurs = occursInAllChunksMap.get(b);
            if (aOccurs > bOccurs) return -1;
            if (aOccurs < bOccurs) return 1;
            return originalOrder.get(a) - originalOrder.get(b);
          });
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  class NamedChunksPlugin {
    static defaultNameResolver(chunk) {
      return chunk.name || null;
    }
    constructor(nameResolver) {
      this.nameResolver = nameResolver || NamedChunksPlugin.defaultNameResolver;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("NamedChunksPlugin", compilation => {
        compilation.hooks.beforeChunkIds.tap("NamedChunksPlugin", chunks => {
          for (const chunk of chunks) null === chunk.id && (chunk.id = this.nameResolver(chunk));
        });
      });
    }
  }
  module.exports = NamedChunksPlugin;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(369);
  module.exports = class {
    constructor(options = {}) {
      validateOptions(schema, options, "Occurrence Order Chunk Ids Plugin"), this.options = options;
    }
    apply(compiler) {
      const prioritiseInitial = this.options.prioritiseInitial;
      compiler.hooks.compilation.tap("OccurrenceOrderChunkIdsPlugin", compilation => {
        compilation.hooks.optimizeChunkOrder.tap("OccurrenceOrderChunkIdsPlugin", chunks => {
          const occursInInitialChunksMap = new Map, originalOrder = new Map;
          let i = 0;
          for (const c of chunks) {
            let occurs = 0;
            for (const chunkGroup of c.groupsIterable) for (const parent of chunkGroup.parentsIterable) parent.isInitial() && occurs++;
            occursInInitialChunksMap.set(c, occurs), originalOrder.set(c, i++);
          }
          chunks.sort((a, b) => {
            if (prioritiseInitial) {
              const aEntryOccurs = occursInInitialChunksMap.get(a), bEntryOccurs = occursInInitialChunksMap.get(b);
              if (aEntryOccurs > bEntryOccurs) return -1;
              if (aEntryOccurs < bEntryOccurs) return 1;
            }
            const aOccurs = a.getNumberOfGroups(), bOccurs = b.getNumberOfGroups();
            if (aOccurs > bOccurs) return -1;
            if (aOccurs < bOccurs) return 1;
            return originalOrder.get(a) - originalOrder.get(b);
          });
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const asyncLib = __webpack_require__(12);
  class CachePlugin {
    constructor(cache) {
      this.cache = cache || {}, this.FS_ACCURACY = 2e3;
    }
    apply(compiler) {
      if (Array.isArray(compiler.compilers)) compiler.compilers.forEach((c, idx) => {
        new CachePlugin(this.cache[idx] = this.cache[idx] || {}).apply(c);
      }); else {
        const registerCacheToCompiler = (compiler, cache) => {
          compiler.hooks.thisCompilation.tap("CachePlugin", compilation => {
            compilation.cache = cache, compilation.hooks.childCompiler.tap("CachePlugin", (childCompiler, compilerName, compilerIndex) => {
              let childCache;
              cache.children || (cache.children = {}), cache.children[compilerName] || (cache.children[compilerName] = []), 
              cache.children[compilerName][compilerIndex] ? childCache = cache.children[compilerName][compilerIndex] : cache.children[compilerName].push(childCache = {}), 
              registerCacheToCompiler(childCompiler, childCache);
            });
          });
        };
        registerCacheToCompiler(compiler, this.cache), compiler.hooks.watchRun.tap("CachePlugin", () => {
          this.watching = !0;
        }), compiler.hooks.run.tapAsync("CachePlugin", (compiler, callback) => {
          if (!compiler._lastCompilationFileDependencies) return callback();
          const fs = compiler.inputFileSystem, fileTs = compiler.fileTimestamps = new Map;
          asyncLib.forEach(compiler._lastCompilationFileDependencies, (file, callback) => {
            fs.stat(file, (err, stat) => {
              if (err) return "ENOENT" === err.code ? callback() : callback(err);
              stat.mtime && this.applyMtime(+stat.mtime), fileTs.set(file, +stat.mtime || 1 / 0), 
              callback();
            });
          }, err => {
            if (err) return callback(err);
            for (const [file, ts] of fileTs) fileTs.set(file, ts + this.FS_ACCURACY);
            callback();
          });
        }), compiler.hooks.afterCompile.tap("CachePlugin", compilation => {
          compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies, 
          compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
        });
      }
    }
    applyMtime(mtime) {
      this.FS_ACCURACY > 1 && mtime % 2 != 0 ? this.FS_ACCURACY = 1 : this.FS_ACCURACY > 10 && mtime % 20 != 0 ? this.FS_ACCURACY = 10 : this.FS_ACCURACY > 100 && mtime % 200 != 0 ? this.FS_ACCURACY = 100 : this.FS_ACCURACY > 1e3 && mtime % 2e3 != 0 && (this.FS_ACCURACY = 1e3);
    }
  }
  module.exports = CachePlugin;
}, function(module, exports) {
  module.exports = require("./terser-plugin");
}, function(module, exports, __webpack_require__) {
  "use strict";
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i, DATE_TIME_SEPARATOR = /t|\s/i, COMPARE_FORMATS = {
    date: compareDate,
    time: compareTime,
    "date-time": function(dt1, dt2) {
      if (!dt1 || !dt2) return;
      dt1 = dt1.split(DATE_TIME_SEPARATOR), dt2 = dt2.split(DATE_TIME_SEPARATOR);
      var res = compareDate(dt1[0], dt2[0]);
      if (void 0 === res) return;
      return res || compareTime(dt1[1], dt2[1]);
    }
  }, $dataMetaSchema = {
    type: "object",
    required: [ "$data" ],
    properties: {
      $data: {
        type: "string",
        anyOf: [ {
          format: "relative-json-pointer"
        }, {
          format: "json-pointer"
        } ]
      }
    },
    additionalProperties: !1
  };
  function compareDate(d1, d2) {
    if (d1 && d2) return d1 > d2 ? 1 : d1 < d2 ? -1 : d1 === d2 ? 0 : void 0;
  }
  function compareTime(t1, t2) {
    if (t1 && t2 && (t1 = t1.match(TIME), t2 = t2.match(TIME), t1 && t2)) return (t1 = t1[1] + t1[2] + t1[3] + (t1[4] || "")) > (t2 = t2[1] + t2[2] + t2[3] + (t2[4] || "")) ? 1 : t1 < t2 ? -1 : t1 === t2 ? 0 : void 0;
  }
  module.exports = function(minMax) {
    var keyword = "format" + minMax;
    return function defFunc(ajv) {
      return defFunc.definition = {
        type: "string",
        inline: __webpack_require__(393),
        statements: !0,
        errors: "full",
        dependencies: [ "format" ],
        metaSchema: {
          anyOf: [ {
            type: "string"
          }, $dataMetaSchema ]
        }
      }, ajv.addKeyword(keyword, defFunc.definition), ajv.addKeyword("formatExclusive" + minMax, {
        dependencies: [ "format" + minMax ],
        metaSchema: {
          anyOf: [ {
            type: "boolean"
          }, $dataMetaSchema ]
        }
      }), function(ajv) {
        var formats = ajv._formats;
        for (var name in COMPARE_FORMATS) {
          var format = formats[name];
          ("object" != typeof format || format instanceof RegExp || !format.validate) && (format = formats[name] = {
            validate: format
          }), format.compare || (format.compare = COMPARE_FORMATS[name]);
        }
      }(ajv), ajv;
    };
  };
}, function(module) {
  module.exports = JSON.parse('{"definitions":{"ArrayOfStringOrStringArrayValues":{"type":"array","items":{"description":"string or array of strings","anyOf":[{"type":"string","minLength":1},{"type":"array","items":{"description":"A non-empty string","type":"string","minLength":1}}]}},"ArrayOfStringValues":{"type":"array","items":{"description":"A non-empty string","type":"string","minLength":1}},"Entry":{"anyOf":[{"$ref":"#/definitions/EntryDynamic"},{"$ref":"#/definitions/EntryStatic"}]},"EntryDynamic":{"description":"A Function returning an entry object, an entry string, an entry array or a promise to these things.","instanceof":"Function","tsType":"(() => EntryStatic | Promise<EntryStatic>)"},"EntryItem":{"oneOf":[{"description":"An entry point without name. The string is resolved to a module which is loaded upon startup.","type":"string","minLength":1},{"description":"An entry point without name. All modules are loaded upon startup. The last one is exported.","anyOf":[{"$ref":"#/definitions/NonEmptyArrayOfUniqueStringValues"}]}]},"EntryObject":{"description":"Multiple entry bundles are created. The key is the chunk name. The value can be a string or an array.","type":"object","additionalProperties":{"description":"An entry point with name","oneOf":[{"description":"The string is resolved to a module which is loaded upon startup.","type":"string","minLength":1},{"description":"All modules are loaded upon startup. The last one is exported.","anyOf":[{"$ref":"#/definitions/NonEmptyArrayOfUniqueStringValues"}]}]},"minProperties":1},"EntryStatic":{"oneOf":[{"$ref":"#/definitions/EntryObject"},{"$ref":"#/definitions/EntryItem"}]},"ExternalItem":{"anyOf":[{"description":"An exact matched dependency becomes external. The same string is used as external dependency.","type":"string"},{"description":"If an dependency matches exactly a property of the object, the property value is used as dependency.","type":"object","additionalProperties":{"description":"The dependency used for the external","anyOf":[{"type":"string"},{"type":"object"},{"$ref":"#/definitions/ArrayOfStringValues"},{"type":"boolean"}]}},{"description":"Every matched dependency becomes external.","instanceof":"RegExp","tsType":"RegExp"}]},"Externals":{"anyOf":[{"description":"`function(context, request, callback(err, result))` The function is called on each dependency.","instanceof":"Function","tsType":"((context: string, request: string, callback: (err?: Error, result?: string) => void) => void)"},{"$ref":"#/definitions/ExternalItem"},{"type":"array","items":{"description":"External configuration","anyOf":[{"description":"`function(context, request, callback(err, result))` The function is called on each dependency.","instanceof":"Function","tsType":"((context: string, request: string, callback: (err?: Error, result?: string) => void) => void)"},{"$ref":"#/definitions/ExternalItem"}]}}]},"FilterItemTypes":{"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string"},{"instanceof":"Function","tsType":"((value: string) => boolean)"}]},"FilterTypes":{"anyOf":[{"$ref":"#/definitions/FilterItemTypes"},{"type":"array","items":{"description":"Rule to filter","anyOf":[{"$ref":"#/definitions/FilterItemTypes"}]}}]},"LibraryCustomUmdObject":{"type":"object","additionalProperties":false,"properties":{"amd":{"description":"Name of the exposed AMD library in the UMD","type":"string"},"commonjs":{"description":"Name of the exposed commonjs export in the UMD","type":"string"},"root":{"description":"Name of the property exposed globally by a UMD library","anyOf":[{"type":"string"},{"$ref":"#/definitions/ArrayOfStringValues"}]}}},"ModuleOptions":{"type":"object","additionalProperties":false,"properties":{"defaultRules":{"description":"An array of rules applied by default for modules.","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"exprContextCritical":{"description":"Enable warnings for full dynamic dependencies","type":"boolean"},"exprContextRecursive":{"description":"Enable recursive directory lookup for full dynamic dependencies","type":"boolean"},"exprContextRegExp":{"description":"Sets the default regular expression for full dynamic dependencies","anyOf":[{"type":"boolean"},{"instanceof":"RegExp","tsType":"RegExp"}]},"exprContextRequest":{"description":"Set the default request for full dynamic dependencies","type":"string"},"noParse":{"description":"Don\'t parse files matching. It\'s matched against the full resolved request.","anyOf":[{"type":"array","items":{"description":"A regular expression, when matched the module is not parsed","instanceof":"RegExp","tsType":"RegExp"},"minItems":1},{"instanceof":"RegExp","tsType":"RegExp"},{"instanceof":"Function","tsType":"Function"},{"type":"array","items":{"description":"An absolute path, when the module starts with this path it is not parsed","type":"string","absolutePath":true},"minItems":1},{"type":"string","absolutePath":true}]},"rules":{"description":"An array of rules applied for modules.","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"strictExportPresence":{"description":"Emit errors instead of warnings when imported names don\'t exist in imported module","type":"boolean"},"strictThisContextOnImports":{"description":"Handle the this context correctly according to the spec for namespace objects","type":"boolean"},"unknownContextCritical":{"description":"Enable warnings when using the require function in a not statically analyse-able way","type":"boolean"},"unknownContextRecursive":{"description":"Enable recursive directory lookup when using the require function in a not statically analyse-able way","type":"boolean"},"unknownContextRegExp":{"description":"Sets the regular expression when using the require function in a not statically analyse-able way","anyOf":[{"type":"boolean"},{"instanceof":"RegExp","tsType":"RegExp"}]},"unknownContextRequest":{"description":"Sets the request when using the require function in a not statically analyse-able way","type":"string"},"unsafeCache":{"description":"Cache the resolving of module requests","anyOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"}]},"wrappedContextCritical":{"description":"Enable warnings for partial dynamic dependencies","type":"boolean"},"wrappedContextRecursive":{"description":"Enable recursive directory lookup for partial dynamic dependencies","type":"boolean"},"wrappedContextRegExp":{"description":"Set the inner regular expression for partial dynamic dependencies","instanceof":"RegExp","tsType":"RegExp"}}},"NodeOptions":{"type":"object","additionalProperties":{"description":"Include a polyfill for the node.js module","enum":[false,true,"mock","empty"]},"properties":{"Buffer":{"description":"Include a polyfill for the \'Buffer\' variable","enum":[false,true,"mock"]},"__dirname":{"description":"Include a polyfill for the \'__dirname\' variable","enum":[false,true,"mock"]},"__filename":{"description":"Include a polyfill for the \'__filename\' variable","enum":[false,true,"mock"]},"console":{"description":"Include a polyfill for the \'console\' variable","enum":[false,true,"mock"]},"global":{"description":"Include a polyfill for the \'global\' variable","type":"boolean"},"process":{"description":"Include a polyfill for the \'process\' variable","enum":[false,true,"mock"]}}},"NonEmptyArrayOfUniqueStringValues":{"description":"A non-empty array of non-empty strings","type":"array","items":{"description":"A non-empty string","type":"string","minLength":1},"minItems":1,"uniqueItems":true},"OptimizationOptions":{"description":"Enables/Disables integrated optimizations","type":"object","additionalProperties":false,"properties":{"checkWasmTypes":{"description":"Check for incompatible wasm types when importing/exporting from/to ESM","type":"boolean"},"chunkIds":{"description":"Define the algorithm to choose chunk ids (named: readable ids for better debugging, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin)","enum":["natural","named","size","total-size",false]},"concatenateModules":{"description":"Concatenate modules when possible to generate less modules, more efficient code and enable more optimizations by the minimizer","type":"boolean"},"flagIncludedChunks":{"description":"Also flag chunks as loaded which contain a subset of the modules","type":"boolean"},"hashedModuleIds":{"description":"Use hashed module id instead module identifiers for better long term caching (deprecated, used moduleIds: hashed instead)","type":"boolean"},"mangleWasmImports":{"description":"Reduce size of WASM by changing imports to shorter strings.","type":"boolean"},"mergeDuplicateChunks":{"description":"Merge chunks which contain the same modules","type":"boolean"},"minimize":{"description":"Enable minimizing the output. Uses optimization.minimizer.","type":"boolean"},"minimizer":{"description":"Minimizer(s) to use for minimizing the output","type":"array","items":{"description":"Plugin of type object or instanceof Function","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"moduleIds":{"description":"Define the algorithm to choose module ids (natural: numeric ids in order of usage, named: readable ids for better debugging, hashed: short hashes as ids for better long term caching, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin)","enum":["natural","named","hashed","size","total-size",false]},"namedChunks":{"description":"Use readable chunk identifiers for better debugging (deprecated, used chunkIds: named instead)","type":"boolean"},"namedModules":{"description":"Use readable module identifiers for better debugging (deprecated, used moduleIds: named instead)","type":"boolean"},"noEmitOnErrors":{"description":"Avoid emitting assets when errors occur","type":"boolean"},"nodeEnv":{"description":"Set process.env.NODE_ENV to a specific value","anyOf":[{"enum":[false]},{"type":"string"}]},"occurrenceOrder":{"description":"Figure out a order of modules which results in the smallest initial bundle","type":"boolean"},"portableRecords":{"description":"Generate records with relative paths to be able to move the context folder","type":"boolean"},"providedExports":{"description":"Figure out which exports are provided by modules to generate more efficient code","type":"boolean"},"removeAvailableModules":{"description":"Removes modules from chunks when these modules are already included in all parents","type":"boolean"},"removeEmptyChunks":{"description":"Remove chunks which are empty","type":"boolean"},"runtimeChunk":{"description":"Create an additional chunk which contains only the webpack runtime and chunk hash maps","oneOf":[{"type":"boolean"},{"enum":["single","multiple"]},{"type":"object","additionalProperties":false,"properties":{"name":{"description":"The name or name factory for the runtime chunks","oneOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]}}}]},"sideEffects":{"description":"Skip over modules which are flagged to contain no side effects when exports are not used","type":"boolean"},"splitChunks":{"description":"Optimize duplication and caching by splitting chunks by shared modules and cache group","oneOf":[{"enum":[false]},{"$ref":"#/definitions/OptimizationSplitChunksOptions"}]},"usedExports":{"description":"Figure out which exports are used by modules to mangle export names, omit unused exports and generate more efficient code","type":"boolean"}}},"OptimizationSplitChunksOptions":{"type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks","type":"string","minLength":1},"automaticNameMaxLength":{"description":"Sets the max length for the name of a created chunk","type":"number","minimum":1},"cacheGroups":{"description":"Assign modules to a cache group (modules from different cache groups are tried to keep in separate chunks)","type":"object","additionalProperties":{"description":"Configuration for a cache group","anyOf":[{"enum":[false]},{"instanceof":"Function","tsType":"Function"},{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"},{"type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks","type":"string","minLength":1},"automaticNameMaxLength":{"description":"Sets the max length for the name of a created chunk","type":"number","minimum":1},"automaticNamePrefix":{"description":"Sets the name prefix for created chunks","type":"string"},"chunks":{"description":"Select chunks for determining cache group content (defaults to \\"initial\\", \\"initial\\" and \\"all\\" requires adding these chunks to the HTML)","oneOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"Function"}]},"enforce":{"description":"Ignore minimum size, minimum chunks and maximum requests and always create chunks for this cache group","type":"boolean"},"enforceSizeThreshold":{"description":"Size threshold at which splitting is enforced and other restrictions (maxAsyncRequests, maxInitialRequests) are ignored.","type":"number"},"filename":{"description":"Sets the template for the filename for created chunks (Only works for initial chunks)","type":"string","minLength":1},"maxAsyncRequests":{"description":"Maximum number of requests which are accepted for on-demand loading","type":"number","minimum":1},"maxInitialRequests":{"description":"Maximum number of initial chunks which are accepted for an entry point","type":"number","minimum":1},"maxSize":{"description":"Maximal size hint for the created chunks","type":"number","minimum":0},"minChunks":{"description":"Minimum number of times a module has to be duplicated until it\'s considered for splitting","type":"number","minimum":1},"minSize":{"description":"Minimal size for the created chunk","type":"number","minimum":0},"name":{"description":"Give chunks for this cache group a name (chunks with equal name are merged)","oneOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"},{"type":"string"}]},"priority":{"description":"Priority of this cache group","type":"number"},"reuseExistingChunk":{"description":"Try to reuse existing chunk (with name) when it has matching modules","type":"boolean"},"test":{"description":"Assign modules to a cache group","oneOf":[{"instanceof":"Function","tsType":"Function"},{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"}]}}}]},"not":{"description":"Using the cacheGroup shorthand syntax with a cache group named \'test\' is a potential config error\\nDid you intent to define a cache group with a test instead?\\ncacheGroups: {\\n  <name>: {\\n    test: ...\\n  }\\n}","type":"object","additionalProperties":true,"properties":{"test":{"description":"The test property is a cache group name, but using the test option of the cache group could be intended instead","anyOf":[{"instanceof":"Function","tsType":"Function"},{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"}]}},"required":["test"]}},"chunks":{"description":"Select chunks for determining shared modules (defaults to \\"async\\", \\"initial\\" and \\"all\\" requires adding these chunks to the HTML)","oneOf":[{"enum":["initial","async","all"]},{"instanceof":"Function","tsType":"Function"}]},"enforceSizeThreshold":{"description":"Size threshold at which splitting is enforced and other restrictions (maxAsyncRequests, maxInitialRequests) are ignored.","type":"number"},"fallbackCacheGroup":{"description":"Options for modules not selected by any other cache group","type":"object","additionalProperties":false,"properties":{"automaticNameDelimiter":{"description":"Sets the name delimiter for created chunks","type":"string","minLength":1},"maxSize":{"description":"Maximal size hint for the created chunks","type":"number","minimum":0},"minSize":{"description":"Minimal size for the created chunk","type":"number","minimum":0}}},"filename":{"description":"Sets the template for the filename for created chunks (Only works for initial chunks)","type":"string","minLength":1},"hidePathInfo":{"description":"Prevents exposing path info when creating names for parts splitted by maxSize","type":"boolean"},"maxAsyncRequests":{"description":"Maximum number of requests which are accepted for on-demand loading","type":"number","minimum":1},"maxInitialRequests":{"description":"Maximum number of initial chunks which are accepted for an entry point","type":"number","minimum":1},"maxSize":{"description":"Maximal size hint for the created chunks","type":"number","minimum":0},"minChunks":{"description":"Minimum number of times a module has to be duplicated until it\'s considered for splitting","type":"number","minimum":1},"minSize":{"description":"Minimal size for the created chunks","type":"number","minimum":0},"name":{"description":"Give chunks created a name (chunks with equal name are merged)","oneOf":[{"type":"boolean"},{"instanceof":"Function","tsType":"Function"},{"type":"string"}]}}},"OutputOptions":{"type":"object","additionalProperties":false,"properties":{"auxiliaryComment":{"description":"Add a comment in the UMD wrapper.","anyOf":[{"description":"Append the same comment above each import style.","type":"string"},{"description":"Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.","type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set comment for `amd` section in UMD","type":"string"},"commonjs":{"description":"Set comment for `commonjs` (exports) section in UMD","type":"string"},"commonjs2":{"description":"Set comment for `commonjs2` (module.exports) section in UMD","type":"string"},"root":{"description":"Set comment for `root` (global variable) section in UMD","type":"string"}}}]},"chunkCallbackName":{"description":"The callback function name used by webpack for loading of chunks in WebWorkers.","type":"string"},"chunkFilename":{"description":"The filename of non-entry chunks as relative path inside the `output.path` directory.","type":"string","absolutePath":false},"chunkLoadTimeout":{"description":"Number of milliseconds before chunk request expires","type":"number"},"crossOriginLoading":{"description":"This option enables cross-origin loading of chunks.","enum":[false,"anonymous","use-credentials"]},"devtoolFallbackModuleFilenameTemplate":{"description":"Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"devtoolLineToLine":{"description":"Enable line to line mapped mode for all/specified modules. Line to line mapped mode uses a simple SourceMap where each line of the generated source is mapped to the same line of the original source. It’s a performance optimization. Only use it if your performance need to be better and you are sure that input lines match which generated lines.","anyOf":[{"description":"`true` enables it for all modules (not recommended)","type":"boolean"},{"description":"An object similar to `module.loaders` enables it for specific files.","type":"object"}]},"devtoolModuleFilenameTemplate":{"description":"Filename template string of function for the sources array in a generated SourceMap.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"devtoolNamespace":{"description":"Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It\'s useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.","type":"string"},"filename":{"description":"Specifies the name of each output file on disk. You must **not** specify an absolute path here! The `output.path` option determines the location on disk the files are written to, filename is used solely for naming the individual files.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"Function"}]},"futureEmitAssets":{"description":"Use the future version of asset emitting logic, which allows freeing memory of assets after emitting. It could break plugins which assume that assets are still readable after emitting. Will be the new default in the next major version.","type":"boolean"},"globalObject":{"description":"An expression which is used to address the global object/scope in runtime code","type":"string","minLength":1},"hashDigest":{"description":"Digest type used for the hash","type":"string"},"hashDigestLength":{"description":"Number of chars which are used for the hash","type":"number","minimum":1},"hashFunction":{"description":"Algorithm used for generation the hash (see node.js crypto package)","anyOf":[{"type":"string","minLength":1},{"instanceof":"Function","tsType":"import(\'../lib/util/createHash\').HashConstructor"}]},"hashSalt":{"description":"Any string which is added to the hash to salt it","type":"string","minLength":1},"hotUpdateChunkFilename":{"description":"The filename of the Hot Update Chunks. They are inside the output.path directory.","type":"string","absolutePath":false},"hotUpdateFunction":{"description":"The JSONP function used by webpack for async loading of hot update chunks.","type":"string"},"hotUpdateMainFilename":{"description":"The filename of the Hot Update Main File. It is inside the `output.path` directory.","anyOf":[{"type":"string","absolutePath":false},{"instanceof":"Function","tsType":"Function"}]},"jsonpFunction":{"description":"The JSONP function used by webpack for async loading of chunks.","type":"string"},"jsonpScriptType":{"description":"This option enables loading async chunks via a custom script type, such as script type=\\"module\\"","enum":[false,"text/javascript","module"]},"library":{"description":"If set, export the bundle as library. `output.library` is the name.","anyOf":[{"type":"string"},{"type":"array","items":{"description":"A part of the library name","type":"string"}},{"$ref":"#/definitions/LibraryCustomUmdObject"}]},"libraryExport":{"description":"Specify which export should be exposed as library","anyOf":[{"type":"string"},{"$ref":"#/definitions/ArrayOfStringValues"}]},"libraryTarget":{"description":"Type of library","enum":["var","assign","this","window","self","global","commonjs","commonjs2","commonjs-module","amd","amd-require","umd","umd2","jsonp","system"]},"path":{"description":"The output directory as **absolute path** (required).","type":"string","absolutePath":true},"pathinfo":{"description":"Include comments with information about the modules.","type":"boolean"},"publicPath":{"description":"The `publicPath` specifies the public URL address of the output files when referenced in a browser.","anyOf":[{"type":"string"},{"instanceof":"Function","tsType":"Function"}]},"sourceMapFilename":{"description":"The filename of the SourceMaps for the JavaScript files. They are inside the `output.path` directory.","type":"string","absolutePath":false},"sourcePrefix":{"description":"Prefixes every line of the source in the bundle with this string.","type":"string"},"strictModuleExceptionHandling":{"description":"Handles exceptions in module loading correctly at a performance cost.","type":"boolean"},"umdNamedDefine":{"description":"If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.","type":"boolean"},"webassemblyModuleFilename":{"description":"The filename of WebAssembly modules as relative path inside the `output.path` directory.","type":"string","absolutePath":false}}},"PerformanceOptions":{"type":"object","additionalProperties":false,"properties":{"assetFilter":{"description":"Filter function to select assets that are checked","instanceof":"Function","tsType":"Function"},"hints":{"description":"Sets the format of the hints: warnings, errors or nothing at all","enum":[false,"warning","error"]},"maxAssetSize":{"description":"Filesize limit (in bytes) when exceeded, that webpack will provide performance hints","type":"number"},"maxEntrypointSize":{"description":"Total size of an entry point (in bytes)","type":"number"}}},"ResolveOptions":{"type":"object","additionalProperties":false,"properties":{"alias":{"description":"Redirect module requests","anyOf":[{"type":"object","additionalProperties":{"description":"New request","type":"string"}},{"type":"array","items":{"description":"Alias configuration","type":"object","additionalProperties":false,"properties":{"alias":{"description":"New request","type":"string"},"name":{"description":"Request to be redirected","type":"string"},"onlyModule":{"description":"Redirect only exact matching request","type":"boolean"}}}}]},"aliasFields":{"description":"Fields in the description file (package.json) which are used to redirect requests inside the module","anyOf":[{"$ref":"#/definitions/ArrayOfStringOrStringArrayValues"}]},"cachePredicate":{"description":"Predicate function to decide which requests should be cached","instanceof":"Function","tsType":"Function"},"cacheWithContext":{"description":"Include the context information in the cache identifier when caching","type":"boolean"},"concord":{"description":"Enable concord resolving extras","type":"boolean"},"descriptionFiles":{"description":"Filenames used to find a description file","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"enforceExtension":{"description":"Enforce using one of the extensions from the extensions option","type":"boolean"},"enforceModuleExtension":{"description":"Enforce using one of the module extensions from the moduleExtensions option","type":"boolean"},"extensions":{"description":"Extensions added to the request when trying to find the file","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"fileSystem":{"description":"Filesystem for the resolver"},"ignoreRootsErrors":{"description":"Enable to ignore fatal errors happening during resolving of \'resolve.roots\'. Usually such errors should not happen, but this option is provided for backward-compatibility.","type":"boolean"},"mainFields":{"description":"Field names from the description file (package.json) which are used to find the default entry point","anyOf":[{"$ref":"#/definitions/ArrayOfStringOrStringArrayValues"}]},"mainFiles":{"description":"Filenames used to find the default entry point if there is no description file or main field","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"moduleExtensions":{"description":"Extensions added to the module request when trying to find the module","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"modules":{"description":"Folder names or directory paths where to find modules","anyOf":[{"$ref":"#/definitions/ArrayOfStringValues"}]},"plugins":{"description":"Plugins for the resolver","type":"array","items":{"description":"Plugin of type object or instanceof Function","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"preferAbsolute":{"description":"Prefer to resolve server-relative URLs (starting with \'/\') as absolute paths before falling back to resolve in \'resolve.roots\'.","type":"boolean"},"resolver":{"description":"Custom resolver"},"roots":{"description":"A list of directories in which requests that are server-relative URLs (starting with \'/\') are resolved.","type":"array","items":{"description":"Directory in which requests that are server-relative URLs (starting with \'/\') are resolved.","type":"string"}},"symlinks":{"description":"Enable resolving symlinks to the original location","type":"boolean"},"unsafeCache":{"description":"Enable caching of successfully resolved requests","anyOf":[{"type":"boolean"},{"type":"object","additionalProperties":true}]},"useSyncFileSystemCalls":{"description":"Use synchronous filesystem calls for the resolver","type":"boolean"}}},"RuleSetCondition":{"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1},{"instanceof":"Function","tsType":"((value: string) => boolean)"},{"$ref":"#/definitions/RuleSetConditions"},{"type":"object","additionalProperties":false,"properties":{"and":{"description":"Logical AND","anyOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"include":{"description":"Exclude all modules matching not any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"not":{"description":"Logical NOT","anyOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"or":{"description":"Logical OR","anyOf":[{"$ref":"#/definitions/RuleSetConditions"}]},"test":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]}}}]},"RuleSetConditionAbsolute":{"anyOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","absolutePath":true},{"instanceof":"Function","tsType":"((value: string) => boolean)"},{"$ref":"#/definitions/RuleSetConditionsAbsolute"},{"type":"object","additionalProperties":false,"properties":{"and":{"description":"Logical AND","anyOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"include":{"description":"Exclude all modules matching not any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"not":{"description":"Logical NOT","anyOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"or":{"description":"Logical OR","anyOf":[{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"test":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]}}}]},"RuleSetConditionOrConditions":{"description":"One or multiple rule conditions","anyOf":[{"$ref":"#/definitions/RuleSetCondition"},{"$ref":"#/definitions/RuleSetConditions"}]},"RuleSetConditionOrConditionsAbsolute":{"description":"One or multiple rule conditions","anyOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"},{"$ref":"#/definitions/RuleSetConditionsAbsolute"}]},"RuleSetConditions":{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/RuleSetCondition"}]}},"RuleSetConditionsAbsolute":{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/RuleSetConditionAbsolute"}]}},"RuleSetLoader":{"type":"string","minLength":1},"RuleSetQuery":{"anyOf":[{"type":"object"},{"type":"string"}]},"RuleSetRule":{"type":"object","additionalProperties":false,"properties":{"compiler":{"description":"Match the child compiler name","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"enforce":{"description":"Enforce this rule as pre or post step","enum":["pre","post"]},"exclude":{"description":"Shortcut for resource.exclude","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"include":{"description":"Shortcut for resource.include","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"issuer":{"description":"Match the issuer of the module (The module pointing to this module)","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"loader":{"description":"Shortcut for use.loader","anyOf":[{"$ref":"#/definitions/RuleSetLoader"},{"$ref":"#/definitions/RuleSetUse"}]},"loaders":{"description":"Shortcut for use.loader","anyOf":[{"$ref":"#/definitions/RuleSetUse"}]},"oneOf":{"description":"Only execute the first matching rule in this array","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"options":{"description":"Shortcut for use.options","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]},"parser":{"description":"Options for parsing","type":"object","additionalProperties":true},"query":{"description":"Shortcut for use.query","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]},"realResource":{"description":"Match rules with custom resource name","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"resolve":{"description":"Options for the resolver","type":"object","anyOf":[{"$ref":"#/definitions/ResolveOptions"}]},"resource":{"description":"Match the resource path of the module","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"resourceQuery":{"description":"Match the resource query of the module","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditions"}]},"rules":{"description":"Match and execute these rules when this rule is matched","anyOf":[{"$ref":"#/definitions/RuleSetRules"}]},"sideEffects":{"description":"Flags a module as with or without side effects","type":"boolean"},"test":{"description":"Shortcut for resource.test","anyOf":[{"$ref":"#/definitions/RuleSetConditionOrConditionsAbsolute"}]},"type":{"description":"Module type to use for the module","enum":["javascript/auto","javascript/dynamic","javascript/esm","json","webassembly/experimental"]},"use":{"description":"Modifiers applied to the module when rule is matched","anyOf":[{"$ref":"#/definitions/RuleSetUse"}]}}},"RuleSetRules":{"type":"array","items":{"description":"A rule","anyOf":[{"$ref":"#/definitions/RuleSetRule"}]}},"RuleSetUse":{"anyOf":[{"$ref":"#/definitions/RuleSetUseItem"},{"instanceof":"Function","tsType":"Function"},{"type":"array","items":{"description":"An use item","anyOf":[{"$ref":"#/definitions/RuleSetUseItem"}]}}]},"RuleSetUseItem":{"anyOf":[{"$ref":"#/definitions/RuleSetLoader"},{"instanceof":"Function","tsType":"Function"},{"type":"object","additionalProperties":false,"properties":{"ident":{"description":"Unique loader identifier","type":"string"},"loader":{"description":"Loader name","anyOf":[{"$ref":"#/definitions/RuleSetLoader"}]},"options":{"description":"Loader options","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]},"query":{"description":"Loader query","anyOf":[{"$ref":"#/definitions/RuleSetQuery"}]}}}]},"StatsOptions":{"type":"object","additionalProperties":false,"properties":{"all":{"description":"fallback value for stats options when an option is not defined (has precedence over local webpack defaults)","type":"boolean"},"assets":{"description":"add assets information","type":"boolean"},"assetsSort":{"description":"sort the assets by that field","type":"string"},"builtAt":{"description":"add built at time information","type":"boolean"},"cached":{"description":"add also information about cached (not built) modules","type":"boolean"},"cachedAssets":{"description":"Show cached assets (setting this to `false` only shows emitted files)","type":"boolean"},"children":{"description":"add children information","type":"boolean"},"chunkGroups":{"description":"Display all chunk groups with the corresponding bundles","type":"boolean"},"chunkModules":{"description":"add built modules information to chunk information","type":"boolean"},"chunkOrigins":{"description":"add the origins of chunks and chunk merging info","type":"boolean"},"chunks":{"description":"add chunk information","type":"boolean"},"chunksSort":{"description":"sort the chunks by that field","type":"string"},"colors":{"description":"Enables/Disables colorful output","oneOf":[{"description":"`webpack --colors` equivalent","type":"boolean"},{"type":"object","additionalProperties":false,"properties":{"bold":{"description":"Custom color for bold text","type":"string"},"cyan":{"description":"Custom color for cyan text","type":"string"},"green":{"description":"Custom color for green text","type":"string"},"magenta":{"description":"Custom color for magenta text","type":"string"},"red":{"description":"Custom color for red text","type":"string"},"yellow":{"description":"Custom color for yellow text","type":"string"}}}]},"context":{"description":"context directory for request shortening","type":"string","absolutePath":true},"depth":{"description":"add module depth in module graph","type":"boolean"},"entrypoints":{"description":"Display the entry points with the corresponding bundles","type":"boolean"},"env":{"description":"add --env information","type":"boolean"},"errorDetails":{"description":"add details to errors (like resolving log)","type":"boolean"},"errors":{"description":"add errors","type":"boolean"},"exclude":{"description":"Please use excludeModules instead.","anyOf":[{"$ref":"#/definitions/FilterTypes"},{"type":"boolean"}]},"excludeAssets":{"description":"Suppress assets that match the specified filters. Filters can be Strings, RegExps or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"}]},"excludeModules":{"description":"Suppress modules that match the specified filters. Filters can be Strings, RegExps, Booleans or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"},{"type":"boolean"}]},"hash":{"description":"add the hash of the compilation","type":"boolean"},"logging":{"description":"add logging output","anyOf":[{"description":"enable/disable logging output (true: shows normal logging output, loglevel: log)","type":"boolean"},{"description":"specify log level of logging output","enum":["none","error","warn","info","log","verbose"]}]},"loggingDebug":{"description":"Include debug logging of specified loggers (i. e. for plugins or loaders). Filters can be Strings, RegExps or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"},{"description":"Enable/Disable debug logging for all loggers","type":"boolean"}]},"loggingTrace":{"description":"add stack traces to logging output","type":"boolean"},"maxModules":{"description":"Set the maximum number of modules to be shown","type":"number"},"moduleAssets":{"description":"add information about assets inside modules","type":"boolean"},"moduleTrace":{"description":"add dependencies and origin of warnings/errors","type":"boolean"},"modules":{"description":"add built modules information","type":"boolean"},"modulesSort":{"description":"sort the modules by that field","type":"string"},"nestedModules":{"description":"add information about modules nested in other modules (like with module concatenation)","type":"boolean"},"optimizationBailout":{"description":"show reasons why optimization bailed out for modules","type":"boolean"},"outputPath":{"description":"Add output path information","type":"boolean"},"performance":{"description":"add performance hint flags","type":"boolean"},"providedExports":{"description":"show exports provided by modules","type":"boolean"},"publicPath":{"description":"Add public path information","type":"boolean"},"reasons":{"description":"add information about the reasons why modules are included","type":"boolean"},"source":{"description":"add the source code of modules","type":"boolean"},"timings":{"description":"add timing information","type":"boolean"},"usedExports":{"description":"show exports used by modules","type":"boolean"},"version":{"description":"add webpack version information","type":"boolean"},"warnings":{"description":"add warnings","type":"boolean"},"warningsFilter":{"description":"Suppress warnings that match the specified filters. Filters can be Strings, RegExps or Functions","anyOf":[{"$ref":"#/definitions/FilterTypes"}]}}},"WebpackPluginFunction":{"description":"Function acting as plugin","instanceof":"Function","tsType":"(this: import(\'../lib/Compiler\'), compiler: import(\'../lib/Compiler\')) => void"},"WebpackPluginInstance":{"description":"Plugin instance","type":"object","additionalProperties":true,"properties":{"apply":{"description":"The run point of the plugin, required method.","instanceof":"Function","tsType":"(compiler: import(\'../lib/Compiler\')) => void"}},"required":["apply"]}},"type":"object","additionalProperties":false,"properties":{"amd":{"description":"Set the value of `require.amd` and `define.amd`. Or disable AMD support.","anyOf":[{"description":"You can pass `false` to disable AMD support.","enum":[false]},{"description":"You can pass an object to set the value of `require.amd` and `define.amd`.","type":"object"}]},"bail":{"description":"Report the first error as a hard error instead of tolerating it.","type":"boolean"},"cache":{"description":"Cache generated modules and chunks to improve performance for multiple incremental builds.","anyOf":[{"description":"You can pass `false` to disable it.","type":"boolean"},{"description":"You can pass an object to enable it and let webpack use the passed object as cache. This way you can share the cache object between multiple compiler calls.","type":"object"}]},"context":{"description":"The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.","type":"string","absolutePath":true},"dependencies":{"description":"References to other configurations to depend on.","type":"array","items":{"description":"References to another configuration to depend on.","type":"string"}},"devServer":{"description":"Options for the webpack-dev-server","type":"object"},"devtool":{"description":"A developer tool to enhance debugging.","anyOf":[{"type":"string"},{"enum":[false]}]},"entry":{"description":"The entry point(s) of the compilation.","anyOf":[{"$ref":"#/definitions/Entry"}]},"externals":{"description":"Specify dependencies that shouldn\'t be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.","anyOf":[{"$ref":"#/definitions/Externals"}]},"infrastructureLogging":{"description":"Options for infrastructure level logging","type":"object","additionalProperties":false,"properties":{"debug":{"description":"Enable debug logging for specific loggers","anyOf":[{"$ref":"#/definitions/FilterTypes"},{"description":"Enable/Disable debug logging for all loggers","type":"boolean"}]},"level":{"description":"Log level","enum":["none","error","warn","info","log","verbose"]}}},"loader":{"description":"Custom values available in the loader context.","type":"object"},"mode":{"description":"Enable production optimizations or development hints.","enum":["development","production","none"]},"module":{"description":"Options affecting the normal modules (`NormalModuleFactory`).","anyOf":[{"$ref":"#/definitions/ModuleOptions"}]},"name":{"description":"Name of the configuration. Used when loading multiple configurations.","type":"string"},"node":{"description":"Include polyfills or mocks for various node stuff.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/NodeOptions"}]},"optimization":{"description":"Enables/Disables integrated optimizations","anyOf":[{"$ref":"#/definitions/OptimizationOptions"}]},"output":{"description":"Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.","anyOf":[{"$ref":"#/definitions/OutputOptions"}]},"parallelism":{"description":"The number of parallel processed modules in the compilation.","type":"number","minimum":1},"performance":{"description":"Configuration for web performance recommendations.","anyOf":[{"enum":[false]},{"$ref":"#/definitions/PerformanceOptions"}]},"plugins":{"description":"Add additional plugins to the compiler.","type":"array","items":{"description":"Plugin of type object or instanceof Function","anyOf":[{"$ref":"#/definitions/WebpackPluginInstance"},{"$ref":"#/definitions/WebpackPluginFunction"}]}},"profile":{"description":"Capture timing information for each module.","type":"boolean"},"recordsInputPath":{"description":"Store compiler state to a json file.","type":"string","absolutePath":true},"recordsOutputPath":{"description":"Load compiler state from a json file.","type":"string","absolutePath":true},"recordsPath":{"description":"Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.","type":"string","absolutePath":true},"resolve":{"description":"Options for the resolver","anyOf":[{"$ref":"#/definitions/ResolveOptions"}]},"resolveLoader":{"description":"Options for the resolver when resolving loaders","anyOf":[{"$ref":"#/definitions/ResolveOptions"}]},"serve":{"description":"Options for webpack-serve","type":"object"},"stats":{"description":"Used by the webpack CLI program to pass stats options.","anyOf":[{"$ref":"#/definitions/StatsOptions"},{"type":"boolean"},{"enum":["none","errors-only","minimal","normal","detailed","verbose","errors-warnings"]}]},"target":{"description":"Environment to build for","anyOf":[{"enum":["web","webworker","node","async-node","node-webkit","electron-main","electron-renderer","electron-preload"]},{"instanceof":"Function","tsType":"((compiler: import(\'../lib/Compiler\')) => void)"}]},"watch":{"description":"Enter watch mode, which rebuilds on file change.","type":"boolean"},"watchOptions":{"description":"Options for the watcher","type":"object","additionalProperties":false,"properties":{"aggregateTimeout":{"description":"Delay the rebuilt after the first change. Value is a time in ms.","type":"number"},"ignored":{"description":"Ignore some files from watching"},"poll":{"description":"Enable polling mode for watching","anyOf":[{"description":"`true`: use polling.","type":"boolean"},{"description":"`number`: use polling with specified interval.","type":"number"}]},"stdin":{"description":"Stop watching when stdin stream has ended","type":"boolean"}}}}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  module.exports = class extends ModuleDependency {
    constructor(request) {
      super(request);
    }
    get type() {
      return "prefetch";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  module.exports = class extends ModuleDependency {
    constructor(request) {
      super(request);
    }
    get type() {
      return "delegated source";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DependencyReference = __webpack_require__(15), NullDependency = __webpack_require__(7);
  module.exports = class extends NullDependency {
    constructor(originModule, exports) {
      super(), this.originModule = originModule, this.exports = exports;
    }
    get type() {
      return "delegated exports";
    }
    getReference() {
      return new DependencyReference(this.originModule, !0, !1);
    }
    getExports() {
      return {
        exports: this.exports,
        dependencies: void 0
      };
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Compiler = __webpack_require__(183), MultiCompiler = __webpack_require__(258), NodeEnvironmentPlugin = __webpack_require__(66), WebpackOptionsApply = __webpack_require__(268), WebpackOptionsDefaulter = __webpack_require__(374), validateSchema = __webpack_require__(376), WebpackOptionsValidationError = __webpack_require__(402), webpackOptionsSchema = __webpack_require__(178), RemovedPluginError = __webpack_require__(403), version = __webpack_require__(59).version, webpack = (options, callback) => {
    const webpackOptionsValidationErrors = validateSchema(webpackOptionsSchema, options);
    if (webpackOptionsValidationErrors.length) throw new WebpackOptionsValidationError(webpackOptionsValidationErrors);
    let compiler;
    if (Array.isArray(options)) compiler = new MultiCompiler(Array.from(options).map(options => webpack(options))); else {
      if ("object" != typeof options) throw new Error("Invalid argument: options");
      if (options = (new WebpackOptionsDefaulter).process(options), compiler = new Compiler(options.context), 
      compiler.options = options, new NodeEnvironmentPlugin({
        infrastructureLogging: options.infrastructureLogging
      }).apply(compiler), options.plugins && Array.isArray(options.plugins)) for (const plugin of options.plugins) "function" == typeof plugin ? plugin.call(compiler, compiler) : plugin.apply(compiler);
      compiler.hooks.environment.call(), compiler.hooks.afterEnvironment.call(), compiler.options = (new WebpackOptionsApply).process(options, compiler);
    }
    if (callback) {
      if ("function" != typeof callback) throw new Error("Invalid argument: callback");
      if (!0 === options.watch || Array.isArray(options) && options.some(o => o.watch)) {
        const watchOptions = Array.isArray(options) ? options.map(o => o.watchOptions || {}) : options.watchOptions || {};
        return compiler.watch(watchOptions, callback);
      }
      compiler.run(callback);
    }
    return compiler;
  };
  (exports = module.exports = webpack).version = version, webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter, 
  webpack.WebpackOptionsApply = WebpackOptionsApply, webpack.Compiler = Compiler, 
  webpack.MultiCompiler = MultiCompiler, webpack.NodeEnvironmentPlugin = NodeEnvironmentPlugin, 
  webpack.validate = validateSchema.bind(this, webpackOptionsSchema), webpack.validateSchema = validateSchema, 
  webpack.WebpackOptionsValidationError = WebpackOptionsValidationError;
  const exportPlugins = (obj, mappings) => {
    for (const name of Object.keys(mappings)) Object.defineProperty(obj, name, {
      configurable: !1,
      enumerable: !0,
      get: mappings[name]
    });
  };
  exportPlugins(exports, {
    AutomaticPrefetchPlugin: () => __webpack_require__(404),
    BannerPlugin: () => __webpack_require__(405),
    CachePlugin: () => __webpack_require__(175),
    ContextExclusionPlugin: () => __webpack_require__(407),
    ContextReplacementPlugin: () => __webpack_require__(408),
    DefinePlugin: () => __webpack_require__(88),
    Dependency: () => __webpack_require__(19),
    DllPlugin: () => __webpack_require__(409),
    DllReferencePlugin: () => __webpack_require__(417),
    EnvironmentPlugin: () => __webpack_require__(421),
    EvalDevToolModulePlugin: () => __webpack_require__(122),
    EvalSourceMapDevToolPlugin: () => __webpack_require__(124),
    ExtendedAPIPlugin: () => __webpack_require__(423),
    ExternalsPlugin: () => __webpack_require__(26),
    HashedModuleIdsPlugin: () => __webpack_require__(171),
    HotModuleReplacementPlugin: () => __webpack_require__(424),
    IgnorePlugin: () => __webpack_require__(426),
    LibraryTemplatePlugin: () => __webpack_require__(153),
    LoaderOptionsPlugin: () => __webpack_require__(428),
    LoaderTargetPlugin: () => __webpack_require__(121),
    MemoryOutputFileSystem: () => __webpack_require__(430),
    Module: () => __webpack_require__(18),
    ModuleFilenameHelpers: () => __webpack_require__(21),
    NamedChunksPlugin: () => __webpack_require__(173),
    NamedModulesPlugin: () => __webpack_require__(170),
    NoEmitOnErrorsPlugin: () => __webpack_require__(169),
    NormalModuleReplacementPlugin: () => __webpack_require__(437),
    PrefetchPlugin: () => __webpack_require__(438),
    ProgressPlugin: () => __webpack_require__(439),
    ProvidePlugin: () => __webpack_require__(441),
    SetVarMainTemplatePlugin: () => __webpack_require__(154),
    SingleEntryPlugin: () => __webpack_require__(73),
    SourceMapDevToolPlugin: () => __webpack_require__(72),
    Stats: () => __webpack_require__(28),
    Template: () => __webpack_require__(2),
    UmdMainTemplatePlugin: () => __webpack_require__(155),
    TerserPlugin: () => __webpack_require__(176),
    I18nPlugin: () => __webpack_require__(442),
    CopyPlugin: () => __webpack_require__(446),
    ReplaceCodePlugin: () => __webpack_require__(447),
    WatchIgnorePlugin: () => __webpack_require__(448)
  }), exportPlugins(exports.dependencies = {}, {
    DependencyReference: () => __webpack_require__(15)
  }), exportPlugins(exports.optimize = {}, {
    AggressiveMergingPlugin: () => __webpack_require__(450),
    AggressiveSplittingPlugin: () => __webpack_require__(451),
    ChunkModuleIdRangePlugin: () => __webpack_require__(453),
    LimitChunkCountPlugin: () => __webpack_require__(454),
    MinChunkSizePlugin: () => __webpack_require__(457),
    ModuleConcatenationPlugin: () => __webpack_require__(161),
    OccurrenceOrderPlugin: () => __webpack_require__(459),
    OccurrenceModuleOrderPlugin: () => __webpack_require__(172),
    OccurrenceChunkOrderPlugin: () => __webpack_require__(174),
    RuntimeChunkPlugin: () => __webpack_require__(168),
    SideEffectsFlagPlugin: () => __webpack_require__(160),
    SplitChunksPlugin: () => __webpack_require__(167)
  }), exportPlugins(exports.web = {}, {
    FetchCompileWasmTemplatePlugin: () => __webpack_require__(52),
    JsonpTemplatePlugin: () => __webpack_require__(51)
  }), exportPlugins(exports.webworker = {}, {
    WebWorkerTemplatePlugin: () => __webpack_require__(150)
  }), exportPlugins(exports.node = {}, {
    NodeTemplatePlugin: () => __webpack_require__(24),
    ReadFileCompileWasmTemplatePlugin: () => __webpack_require__(54)
  }), exportPlugins(exports.debug = {}, {
    ProfilingPlugin: () => __webpack_require__(460)
  }), exportPlugins(exports.util = {}, {
    createHash: () => __webpack_require__(17)
  });
  const defineMissingPluginError = (namespace, pluginName, errorMessage) => {
    Object.defineProperty(namespace, pluginName, {
      configurable: !1,
      enumerable: !0,
      get() {
        throw new RemovedPluginError(errorMessage);
      }
    });
  };
  defineMissingPluginError(exports.optimize, "UglifyJsPlugin", "webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead."), 
  defineMissingPluginError(exports.optimize, "CommonsChunkPlugin", "webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead.");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const parseJson = __webpack_require__(57), asyncLib = __webpack_require__(12), path = __webpack_require__(3), {Source: Source} = __webpack_require__(0), util = __webpack_require__(11), {Tapable: Tapable, SyncHook: SyncHook, SyncBailHook: SyncBailHook, AsyncParallelHook: AsyncParallelHook, AsyncSeriesHook: AsyncSeriesHook} = __webpack_require__(6), Compilation = __webpack_require__(191), Stats = __webpack_require__(28), Watching = __webpack_require__(207), NormalModuleFactory = __webpack_require__(208), ContextModuleFactory = __webpack_require__(221), ResolverFactory = __webpack_require__(223), RequestShortener = __webpack_require__(58), {makePathsRelative: makePathsRelative} = __webpack_require__(14), ConcurrentCompilationError = __webpack_require__(109), {Logger: Logger} = __webpack_require__(39);
  class Compiler extends Tapable {
    constructor(context) {
      super(), this.hooks = {
        shouldEmit: new SyncBailHook([ "compilation" ]),
        done: new AsyncSeriesHook([ "stats" ]),
        additionalPass: new AsyncSeriesHook([]),
        beforeRun: new AsyncSeriesHook([ "compiler" ]),
        run: new AsyncSeriesHook([ "compiler" ]),
        emit: new AsyncSeriesHook([ "compilation" ]),
        assetEmitted: new AsyncSeriesHook([ "file", "content" ]),
        afterEmit: new AsyncSeriesHook([ "compilation" ]),
        thisCompilation: new SyncHook([ "compilation", "params" ]),
        compilation: new SyncHook([ "compilation", "params" ]),
        normalModuleFactory: new SyncHook([ "normalModuleFactory" ]),
        contextModuleFactory: new SyncHook([ "contextModulefactory" ]),
        beforeCompile: new AsyncSeriesHook([ "params" ]),
        compile: new SyncHook([ "params" ]),
        make: new AsyncParallelHook([ "compilation" ]),
        afterCompile: new AsyncSeriesHook([ "compilation" ]),
        watchRun: new AsyncSeriesHook([ "compiler" ]),
        failed: new SyncHook([ "error" ]),
        invalid: new SyncHook([ "filename", "changeTime" ]),
        watchClose: new SyncHook([]),
        infrastructureLog: new SyncBailHook([ "origin", "type", "args" ]),
        environment: new SyncHook([]),
        afterEnvironment: new SyncHook([]),
        afterPlugins: new SyncHook([ "compiler" ]),
        afterResolvers: new SyncHook([ "compiler" ]),
        entryOption: new SyncBailHook([ "context", "entry" ])
      }, this.hooks.infrastructurelog = this.hooks.infrastructureLog, this._pluginCompat.tap("Compiler", options => {
        switch (options.name) {
         case "additional-pass":
         case "before-run":
         case "run":
         case "emit":
         case "after-emit":
         case "before-compile":
         case "make":
         case "after-compile":
         case "watch-run":
          options.async = !0;
        }
      }), this.name = void 0, this.parentCompilation = void 0, this.outputPath = "", this.outputFileSystem = null, 
      this.inputFileSystem = null, this.recordsInputPath = null, this.recordsOutputPath = null, 
      this.records = {}, this.removedFiles = new Set, this.fileTimestamps = new Map, this.contextTimestamps = new Map, 
      this.resolverFactory = new ResolverFactory, this.infrastructureLogger = void 0, 
      this.resolvers = {
        normal: {
          plugins: util.deprecate((hook, fn) => {
            this.resolverFactory.plugin("resolver normal", resolver => {
              resolver.plugin(hook, fn);
            });
          }, 'webpack: Using compiler.resolvers.normal is deprecated.\nUse compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
          apply: util.deprecate((...args) => {
            this.resolverFactory.plugin("resolver normal", resolver => {
              resolver.apply(...args);
            });
          }, 'webpack: Using compiler.resolvers.normal is deprecated.\nUse compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
        },
        loader: {
          plugins: util.deprecate((hook, fn) => {
            this.resolverFactory.plugin("resolver loader", resolver => {
              resolver.plugin(hook, fn);
            });
          }, 'webpack: Using compiler.resolvers.loader is deprecated.\nUse compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
          apply: util.deprecate((...args) => {
            this.resolverFactory.plugin("resolver loader", resolver => {
              resolver.apply(...args);
            });
          }, 'webpack: Using compiler.resolvers.loader is deprecated.\nUse compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
        },
        context: {
          plugins: util.deprecate((hook, fn) => {
            this.resolverFactory.plugin("resolver context", resolver => {
              resolver.plugin(hook, fn);
            });
          }, 'webpack: Using compiler.resolvers.context is deprecated.\nUse compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
          apply: util.deprecate((...args) => {
            this.resolverFactory.plugin("resolver context", resolver => {
              resolver.apply(...args);
            });
          }, 'webpack: Using compiler.resolvers.context is deprecated.\nUse compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
        }
      }, this.options = {}, this.context = context, this.requestShortener = new RequestShortener(context), 
      this.running = !1, this.watchMode = !1, this._assetEmittingSourceCache = new WeakMap, 
      this._assetEmittingWrittenFiles = new Map;
    }
    getInfrastructureLogger(name) {
      if (!name) throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name");
      return new Logger((type, args) => {
        if ("function" == typeof name && !(name = name())) throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
        void 0 === this.hooks.infrastructureLog.call(name, type, args) && void 0 !== this.infrastructureLogger && this.infrastructureLogger(name, type, args);
      });
    }
    watch(watchOptions, handler) {
      return this.running ? handler(new ConcurrentCompilationError) : (this.running = !0, 
      this.watchMode = !0, this.fileTimestamps = new Map, this.contextTimestamps = new Map, 
      this.removedFiles = new Set, new Watching(this, watchOptions, handler));
    }
    run(callback) {
      if (this.running) return callback(new ConcurrentCompilationError);
      const finalCallback = (err, stats) => {
        if (this.running = !1, err && this.hooks.failed.call(err), void 0 !== callback) return callback(err, stats);
      }, startTime = Date.now();
      this.running = !0;
      const onCompiled = (err, compilation) => {
        if (err) return finalCallback(err);
        if (!1 === this.hooks.shouldEmit.call(compilation)) {
          const stats = new Stats(compilation);
          return stats.startTime = startTime, stats.endTime = Date.now(), void this.hooks.done.callAsync(stats, err => err ? finalCallback(err) : finalCallback(null, stats));
        }
        this.emitAssets(compilation, err => {
          if (err) return finalCallback(err);
          if (compilation.hooks.needAdditionalPass.call()) {
            compilation.needAdditionalPass = !0;
            const stats = new Stats(compilation);
            return stats.startTime = startTime, stats.endTime = Date.now(), void this.hooks.done.callAsync(stats, err => {
              if (err) return finalCallback(err);
              this.hooks.additionalPass.callAsync(err => {
                if (err) return finalCallback(err);
                this.compile(onCompiled);
              });
            });
          }
          this.emitRecords(err => {
            if (err) return finalCallback(err);
            const stats = new Stats(compilation);
            stats.startTime = startTime, stats.endTime = Date.now(), this.hooks.done.callAsync(stats, err => err ? finalCallback(err) : finalCallback(null, stats));
          });
        });
      };
      this.hooks.beforeRun.callAsync(this, err => {
        if (err) return finalCallback(err);
        this.hooks.run.callAsync(this, err => {
          if (err) return finalCallback(err);
          this.readRecords(err => {
            if (err) return finalCallback(err);
            this.compile(onCompiled);
          });
        });
      });
    }
    runAsChild(callback) {
      this.compile((err, compilation) => {
        if (err) return callback(err);
        this.parentCompilation.children.push(compilation);
        for (const {name: name, source: source, info: info} of compilation.getAssets()) this.parentCompilation.emitAsset(name, source, info);
        const entries = Array.from(compilation.entrypoints.values(), ep => ep.chunks).reduce((array, chunks) => array.concat(chunks), []);
        return callback(null, entries, compilation);
      });
    }
    purgeInputFileSystem() {
      this.inputFileSystem && this.inputFileSystem.purge && this.inputFileSystem.purge();
    }
    emitAssets(compilation, callback) {
      let outputPath;
      const emitFiles = err => {
        if (err) return callback(err);
        asyncLib.forEachLimit(compilation.getAssets(), 15, ({name: file, source: source}, callback) => {
          let targetFile = file;
          const queryStringIdx = targetFile.indexOf("?");
          queryStringIdx >= 0 && (targetFile = targetFile.substr(0, queryStringIdx));
          const writeOut = err => {
            if (err) return callback(err);
            const targetPath = this.outputFileSystem.join(outputPath, targetFile);
            if (this.options.output.futureEmitAssets) {
              const targetFileGeneration = this._assetEmittingWrittenFiles.get(targetPath);
              let content, cacheEntry = this._assetEmittingSourceCache.get(source);
              if (void 0 === cacheEntry && (cacheEntry = {
                sizeOnlySource: void 0,
                writtenTo: new Map
              }, this._assetEmittingSourceCache.set(source, cacheEntry)), void 0 !== targetFileGeneration) {
                if (cacheEntry.writtenTo.get(targetPath) === targetFileGeneration) return compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
                  size: cacheEntry.sizeOnlySource.size()
                }), callback();
              }
              if ("function" == typeof source.buffer) content = source.buffer(); else {
                const bufferOrString = source.source();
                content = Buffer.isBuffer(bufferOrString) ? bufferOrString : Buffer.from(bufferOrString, "utf8");
              }
              cacheEntry.sizeOnlySource = new SizeOnlySource(content.length), compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
                size: content.length
              }), this.outputFileSystem.writeFile(targetPath, content, err => {
                if (err) return callback(err);
                compilation.emittedAssets.add(file);
                const newGeneration = void 0 === targetFileGeneration ? 1 : targetFileGeneration + 1;
                cacheEntry.writtenTo.set(targetPath, newGeneration), this._assetEmittingWrittenFiles.set(targetPath, newGeneration), 
                this.hooks.assetEmitted.callAsync(file, content, callback);
              });
            } else {
              if (source.existsAt === targetPath) return source.emitted = !1, callback();
              let content = source.source();
              Buffer.isBuffer(content) || (content = Buffer.from(content, "utf8")), source.existsAt = targetPath, 
              source.emitted = !0, this.outputFileSystem.writeFile(targetPath, content, err => {
                if (err) return callback(err);
                this.hooks.assetEmitted.callAsync(file, content, callback);
              });
            }
          };
          if (targetFile.match(/\/|\\/)) {
            const dir = path.dirname(targetFile);
            this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut);
          } else writeOut();
        }, err => {
          if (err) return callback(err);
          this.hooks.afterEmit.callAsync(compilation, err => err ? callback(err) : callback());
        });
      };
      this.hooks.emit.callAsync(compilation, err => {
        if (err) return callback(err);
        outputPath = compilation.getPath(this.outputPath), this.outputFileSystem.mkdirp(outputPath, emitFiles);
      });
    }
    emitRecords(callback) {
      if (!this.recordsOutputPath) return callback();
      const idx1 = this.recordsOutputPath.lastIndexOf("/"), idx2 = this.recordsOutputPath.lastIndexOf("\\");
      let recordsOutputPathDirectory = null;
      idx1 > idx2 ? recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1) : idx1 < idx2 && (recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2));
      const writeFile = () => {
        this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, void 0, 2), callback);
      };
      if (!recordsOutputPathDirectory) return writeFile();
      this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {
        if (err) return callback(err);
        writeFile();
      });
    }
    readRecords(callback) {
      if (!this.recordsInputPath) return this.records = {}, callback();
      this.inputFileSystem.stat(this.recordsInputPath, err => {
        if (err) return callback();
        this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {
          if (err) return callback(err);
          try {
            this.records = parseJson(content.toString("utf-8"));
          } catch (e) {
            return e.message = "Cannot parse records: " + e.message, callback(e);
          }
          return callback();
        });
      });
    }
    createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {
      const childCompiler = new Compiler(this.context);
      if (Array.isArray(plugins)) for (const plugin of plugins) plugin.apply(childCompiler);
      for (const name in this.hooks) [ "make", "compile", "emit", "afterEmit", "invalid", "done", "thisCompilation" ].includes(name) || childCompiler.hooks[name] && (childCompiler.hooks[name].taps = this.hooks[name].taps.slice());
      childCompiler.name = compilerName, childCompiler.outputPath = this.outputPath, childCompiler.inputFileSystem = this.inputFileSystem, 
      childCompiler.outputFileSystem = null, childCompiler.resolverFactory = this.resolverFactory, 
      childCompiler.fileTimestamps = this.fileTimestamps, childCompiler.contextTimestamps = this.contextTimestamps;
      const relativeCompilerName = makePathsRelative(this.context, compilerName);
      this.records[relativeCompilerName] || (this.records[relativeCompilerName] = []), 
      this.records[relativeCompilerName][compilerIndex] ? childCompiler.records = this.records[relativeCompilerName][compilerIndex] : this.records[relativeCompilerName].push(childCompiler.records = {}), 
      childCompiler.options = Object.create(this.options), childCompiler.options.output = Object.create(childCompiler.options.output);
      for (const name in outputOptions) childCompiler.options.output[name] = outputOptions[name];
      return childCompiler.parentCompilation = compilation, compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex), 
      childCompiler;
    }
    isChild() {
      return !!this.parentCompilation;
    }
    createCompilation() {
      return new Compilation(this);
    }
    newCompilation(params) {
      const compilation = this.createCompilation();
      return compilation.fileTimestamps = this.fileTimestamps, compilation.contextTimestamps = this.contextTimestamps, 
      compilation.name = this.name, compilation.records = this.records, compilation.compilationDependencies = params.compilationDependencies, 
      this.hooks.thisCompilation.call(compilation, params), this.hooks.compilation.call(compilation, params), 
      compilation;
    }
    createNormalModuleFactory() {
      const normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});
      return this.hooks.normalModuleFactory.call(normalModuleFactory), normalModuleFactory;
    }
    createContextModuleFactory() {
      const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
      return this.hooks.contextModuleFactory.call(contextModuleFactory), contextModuleFactory;
    }
    newCompilationParams() {
      return {
        normalModuleFactory: this.createNormalModuleFactory(),
        contextModuleFactory: this.createContextModuleFactory(),
        compilationDependencies: new Set
      };
    }
    compile(callback) {
      const params = this.newCompilationParams();
      this.hooks.beforeCompile.callAsync(params, err => {
        if (err) return callback(err);
        this.hooks.compile.call(params);
        const compilation = this.newCompilation(params);
        this.hooks.make.callAsync(compilation, err => {
          if (err) return callback(err);
          compilation.finish(err => {
            if (err) return callback(err);
            compilation.seal(err => {
              if (err) return callback(err);
              this.hooks.afterCompile.callAsync(compilation, err => err ? callback(err) : callback(null, compilation));
            });
          });
        });
      });
    }
  }
  module.exports = Compiler;
  class SizeOnlySource extends Source {
    constructor(size) {
      super(), this._size = size;
    }
    _error() {
      return new Error("Content and Map of this Source is no longer available (only size() is supported)");
    }
    size() {
      return this._size;
    }
    source(options) {
      throw this._error();
    }
    node() {
      throw this._error();
    }
    listMap() {
      throw this._error();
    }
    map() {
      throw this._error();
    }
    listNode() {
      throw this._error();
    }
    updateHash() {
      throw this._error();
    }
  }
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onResult: onResult, resultReturns: resultReturns, rethrowIfPossible: rethrowIfPossible}) {
      return this.callTapsSeries({
        onError: (i, err) => onError(err),
        onResult: (i, result, next) => {
          let code = "";
          return code += `if(${result} !== undefined) {\n`, code += `${this._args[0]} = ${result};\n`, 
          code += "}\n", code += next(), code;
        },
        onDone: () => onResult(this._args[0]),
        doneReturns: resultReturns,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  };
  module.exports = class extends Hook {
    constructor(args) {
      if (super(args), args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    }
    tapAsync() {
      throw new Error("tapAsync is not supported on a SyncWaterfallHook");
    }
    tapPromise() {
      throw new Error("tapPromise is not supported on a SyncWaterfallHook");
    }
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onDone: onDone, rethrowIfPossible: rethrowIfPossible}) {
      return this.callTapsLooping({
        onError: (i, err) => onError(err),
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    }
  };
  module.exports = class extends Hook {
    tapAsync() {
      throw new Error("tapAsync is not supported on a SyncLoopHook");
    }
    tapPromise() {
      throw new Error("tapPromise is not supported on a SyncLoopHook");
    }
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onDone: onDone}) {
      return this.callTapsParallel({
        onError: (i, err, done, doneBreak) => onError(err) + doneBreak(!0),
        onDone: onDone
      });
    }
  };
  class AsyncParallelHook extends Hook {
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  }
  Object.defineProperties(AsyncParallelHook.prototype, {
    _call: {
      value: void 0,
      configurable: !0,
      writable: !0
    }
  }), module.exports = AsyncParallelHook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onResult: onResult, onDone: onDone}) {
      let code = "";
      return code += `var _results = new Array(${this.options.taps.length});\n`, code += "var _checkDone = () => {\n", 
      code += "for(var i = 0; i < _results.length; i++) {\n", code += "var item = _results[i];\n", 
      code += "if(item === undefined) return false;\n", code += "if(item.result !== undefined) {\n", 
      code += onResult("item.result"), code += "return true;\n", code += "}\n", code += "if(item.error) {\n", 
      code += onError("item.error"), code += "return true;\n", code += "}\n", code += "}\n", 
      code += "return false;\n", code += "}\n", code += this.callTapsParallel({
        onError: (i, err, done, doneBreak) => {
          let code = "";
          return code += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`, 
          code += doneBreak(!0), code += "} else {\n", code += done(), code += "}\n", code;
        },
        onResult: (i, result, done, doneBreak) => {
          let code = "";
          return code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`, 
          code += doneBreak(!0), code += "} else {\n", code += done(), code += "}\n", code;
        },
        onTap: (i, run, done, doneBreak) => {
          let code = "";
          return i > 0 && (code += `if(${i} >= _results.length) {\n`, code += done(), code += "} else {\n"), 
          code += run(), i > 0 && (code += "}\n"), code;
        },
        onDone: onDone
      }), code;
    }
  };
  class AsyncParallelBailHook extends Hook {
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  }
  Object.defineProperties(AsyncParallelBailHook.prototype, {
    _call: {
      value: void 0,
      configurable: !0,
      writable: !0
    }
  }), module.exports = AsyncParallelBailHook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Hook = __webpack_require__(13), HookCodeFactory = __webpack_require__(16);
  const factory = new class extends HookCodeFactory {
    content({onError: onError, onResult: onResult, onDone: onDone}) {
      return this.callTapsSeries({
        onError: (i, err, next, doneBreak) => onError(err) + doneBreak(!0),
        onResult: (i, result, next) => {
          let code = "";
          return code += `if(${result} !== undefined) {\n`, code += `${this._args[0]} = ${result};\n`, 
          code += "}\n", code += next(), code;
        },
        onDone: () => onResult(this._args[0])
      });
    }
  };
  class AsyncSeriesWaterfallHook extends Hook {
    constructor(args) {
      if (super(args), args.length < 1) throw new Error("Waterfall hooks must have at least one argument");
    }
    compile(options) {
      return factory.setup(this, options), factory.create(options);
    }
  }
  Object.defineProperties(AsyncSeriesWaterfallHook.prototype, {
    _call: {
      value: void 0,
      configurable: !0,
      writable: !0
    }
  }), module.exports = AsyncSeriesWaterfallHook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(factory) {
      this._map = new Map, this._factory = factory, this._interceptors = [];
    }
    get(key) {
      return this._map.get(key);
    }
    for(key) {
      const hook = this.get(key);
      if (void 0 !== hook) return hook;
      let newHook = this._factory(key);
      const interceptors = this._interceptors;
      for (let i = 0; i < interceptors.length; i++) newHook = interceptors[i].factory(key, newHook);
      return this._map.set(key, newHook), newHook;
    }
    intercept(interceptor) {
      this._interceptors.push(Object.assign({
        factory: (key, hook) => hook
      }, interceptor));
    }
    tap(key, options, fn) {
      return this.for(key).tap(options, fn);
    }
    tapAsync(key, options, fn) {
      return this.for(key).tapAsync(options, fn);
    }
    tapPromise(key, options, fn) {
      return this.for(key).tapPromise(options, fn);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  __webpack_require__(13);
  class MultiHook {
    constructor(hooks) {
      this.hooks = hooks;
    }
    tap(options, fn) {
      for (const hook of this.hooks) hook.tap(options, fn);
    }
    tapAsync(options, fn) {
      for (const hook of this.hooks) hook.tapAsync(options, fn);
    }
    tapPromise(options, fn) {
      for (const hook of this.hooks) hook.tapPromise(options, fn);
    }
    isUsed() {
      for (const hook of this.hooks) if (hook.isUsed()) return !0;
      return !1;
    }
    intercept(interceptor) {
      for (const hook of this.hooks) hook.intercept(interceptor);
    }
    withOptions(options) {
      return new MultiHook(this.hooks.map(h => h.withOptions(options)));
    }
  }
  module.exports = MultiHook;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const asyncLib = __webpack_require__(12), util = __webpack_require__(11), {CachedSource: CachedSource} = __webpack_require__(0), {Tapable: Tapable, SyncHook: SyncHook, SyncBailHook: SyncBailHook, SyncWaterfallHook: SyncWaterfallHook, AsyncSeriesHook: AsyncSeriesHook} = __webpack_require__(6), EntryModuleNotFoundError = __webpack_require__(192), ModuleNotFoundError = __webpack_require__(193), ModuleDependencyWarning = __webpack_require__(194), ModuleDependencyError = __webpack_require__(195), ChunkGroup = __webpack_require__(95), Chunk = __webpack_require__(96), Entrypoint = __webpack_require__(97), MainTemplate = __webpack_require__(196), ChunkTemplate = __webpack_require__(197), HotUpdateChunkTemplate = __webpack_require__(198), ModuleTemplate = __webpack_require__(199), RuntimeTemplate = __webpack_require__(200), ChunkRenderError = __webpack_require__(201), Stats = __webpack_require__(28), Semaphore = __webpack_require__(203), createHash = __webpack_require__(17), SortableSet = __webpack_require__(23), GraphHelpers = __webpack_require__(27), ModuleDependency = __webpack_require__(4), compareLocations = __webpack_require__(36), {Logger: Logger, LogType: LogType} = __webpack_require__(39), ErrorHelpers = __webpack_require__(40), buildChunkGraph = __webpack_require__(205), WebpackError = __webpack_require__(1), byId = (a, b) => typeof a.id != typeof b.id ? typeof a.id < typeof b.id ? -1 : 1 : a.id < b.id ? -1 : a.id > b.id ? 1 : 0, byIdOrIdentifier = (a, b) => {
    if (typeof a.id != typeof b.id) return typeof a.id < typeof b.id ? -1 : 1;
    if (a.id < b.id) return -1;
    if (a.id > b.id) return 1;
    const identA = a.identifier(), identB = b.identifier();
    return identA < identB ? -1 : identA > identB ? 1 : 0;
  }, byIndexOrIdentifier = (a, b) => {
    if (a.index < b.index) return -1;
    if (a.index > b.index) return 1;
    const identA = a.identifier(), identB = b.identifier();
    return identA < identB ? -1 : identA > identB ? 1 : 0;
  }, byNameOrHash = (a, b) => a.name < b.name ? -1 : a.name > b.name ? 1 : a.fullHash < b.fullHash ? -1 : a.fullHash > b.fullHash ? 1 : 0, iterationBlockVariable = (variables, fn) => {
    for (let indexVariable = 0; indexVariable < variables.length; indexVariable++) {
      const varDep = variables[indexVariable].dependencies;
      for (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) fn(varDep[indexVDep]);
    }
  }, iterationOfArrayCallback = (arr, fn) => {
    for (let index = 0; index < arr.length; index++) fn(arr[index]);
  }, addAllToSet = (set, otherSet) => {
    for (const item of otherSet) set.add(item);
  };
  class Compilation extends Tapable {
    constructor(compiler) {
      super(), this.hooks = {
        buildModule: new SyncHook([ "module" ]),
        rebuildModule: new SyncHook([ "module" ]),
        failedModule: new SyncHook([ "module", "error" ]),
        succeedModule: new SyncHook([ "module" ]),
        addEntry: new SyncHook([ "entry", "name" ]),
        failedEntry: new SyncHook([ "entry", "name", "error" ]),
        succeedEntry: new SyncHook([ "entry", "name", "module" ]),
        dependencyReference: new SyncWaterfallHook([ "dependencyReference", "dependency", "module" ]),
        finishModules: new AsyncSeriesHook([ "modules" ]),
        finishRebuildingModule: new SyncHook([ "module" ]),
        unseal: new SyncHook([]),
        seal: new SyncHook([]),
        beforeChunks: new SyncHook([]),
        afterChunks: new SyncHook([ "chunks" ]),
        optimizeDependenciesBasic: new SyncBailHook([ "modules" ]),
        optimizeDependencies: new SyncBailHook([ "modules" ]),
        optimizeDependenciesAdvanced: new SyncBailHook([ "modules" ]),
        afterOptimizeDependencies: new SyncHook([ "modules" ]),
        optimize: new SyncHook([]),
        optimizeModulesBasic: new SyncBailHook([ "modules" ]),
        optimizeModules: new SyncBailHook([ "modules" ]),
        optimizeModulesAdvanced: new SyncBailHook([ "modules" ]),
        afterOptimizeModules: new SyncHook([ "modules" ]),
        optimizeChunksBasic: new SyncBailHook([ "chunks", "chunkGroups" ]),
        optimizeChunks: new SyncBailHook([ "chunks", "chunkGroups" ]),
        optimizeChunksAdvanced: new SyncBailHook([ "chunks", "chunkGroups" ]),
        afterOptimizeChunks: new SyncHook([ "chunks", "chunkGroups" ]),
        optimizeTree: new AsyncSeriesHook([ "chunks", "modules" ]),
        afterOptimizeTree: new SyncHook([ "chunks", "modules" ]),
        optimizeChunkModulesBasic: new SyncBailHook([ "chunks", "modules" ]),
        optimizeChunkModules: new SyncBailHook([ "chunks", "modules" ]),
        optimizeChunkModulesAdvanced: new SyncBailHook([ "chunks", "modules" ]),
        afterOptimizeChunkModules: new SyncHook([ "chunks", "modules" ]),
        shouldRecord: new SyncBailHook([]),
        reviveModules: new SyncHook([ "modules", "records" ]),
        optimizeModuleOrder: new SyncHook([ "modules" ]),
        advancedOptimizeModuleOrder: new SyncHook([ "modules" ]),
        beforeModuleIds: new SyncHook([ "modules" ]),
        moduleIds: new SyncHook([ "modules" ]),
        optimizeModuleIds: new SyncHook([ "modules" ]),
        afterOptimizeModuleIds: new SyncHook([ "modules" ]),
        reviveChunks: new SyncHook([ "chunks", "records" ]),
        optimizeChunkOrder: new SyncHook([ "chunks" ]),
        beforeChunkIds: new SyncHook([ "chunks" ]),
        optimizeChunkIds: new SyncHook([ "chunks" ]),
        afterOptimizeChunkIds: new SyncHook([ "chunks" ]),
        recordModules: new SyncHook([ "modules", "records" ]),
        recordChunks: new SyncHook([ "chunks", "records" ]),
        beforeHash: new SyncHook([]),
        contentHash: new SyncHook([ "chunk" ]),
        afterHash: new SyncHook([]),
        recordHash: new SyncHook([ "records" ]),
        record: new SyncHook([ "compilation", "records" ]),
        beforeModuleAssets: new SyncHook([]),
        shouldGenerateChunkAssets: new SyncBailHook([]),
        beforeChunkAssets: new SyncHook([]),
        additionalChunkAssets: new SyncHook([ "chunks" ]),
        additionalAssets: new AsyncSeriesHook([]),
        optimizeChunkAssets: new AsyncSeriesHook([ "chunks" ]),
        afterOptimizeChunkAssets: new SyncHook([ "chunks" ]),
        optimizeAssets: new AsyncSeriesHook([ "assets" ]),
        afterOptimizeAssets: new SyncHook([ "assets" ]),
        needAdditionalSeal: new SyncBailHook([]),
        afterSeal: new AsyncSeriesHook([]),
        chunkHash: new SyncHook([ "chunk", "chunkHash" ]),
        moduleAsset: new SyncHook([ "module", "filename" ]),
        chunkAsset: new SyncHook([ "chunk", "filename" ]),
        assetPath: new SyncWaterfallHook([ "filename", "data" ]),
        needAdditionalPass: new SyncBailHook([]),
        childCompiler: new SyncHook([ "childCompiler", "compilerName", "compilerIndex" ]),
        log: new SyncBailHook([ "origin", "logEntry" ]),
        normalModuleLoader: new SyncHook([ "loaderContext", "module" ]),
        optimizeExtractedChunksBasic: new SyncBailHook([ "chunks" ]),
        optimizeExtractedChunks: new SyncBailHook([ "chunks" ]),
        optimizeExtractedChunksAdvanced: new SyncBailHook([ "chunks" ]),
        afterOptimizeExtractedChunks: new SyncHook([ "chunks" ])
      }, this._pluginCompat.tap("Compilation", options => {
        switch (options.name) {
         case "optimize-tree":
         case "additional-assets":
         case "optimize-chunk-assets":
         case "optimize-assets":
         case "after-seal":
          options.async = !0;
        }
      }), this.name = void 0, this.compiler = compiler, this.resolverFactory = compiler.resolverFactory, 
      this.inputFileSystem = compiler.inputFileSystem, this.requestShortener = compiler.requestShortener;
      const options = compiler.options;
      this.options = options, this.outputOptions = options && options.output, this.bail = options && options.bail, 
      this.profile = options && options.profile, this.performance = options && options.performance, 
      this.mainTemplate = new MainTemplate(this.outputOptions), this.chunkTemplate = new ChunkTemplate(this.outputOptions), 
      this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions), this.runtimeTemplate = new RuntimeTemplate(this.outputOptions, this.requestShortener), 
      this.moduleTemplates = {
        javascript: new ModuleTemplate(this.runtimeTemplate, "javascript"),
        webassembly: new ModuleTemplate(this.runtimeTemplate, "webassembly")
      }, this.semaphore = new Semaphore(options.parallelism || 100), this.entries = [], 
      this._preparedEntrypoints = [], this.entrypoints = new Map, this.chunks = [], this.chunkGroups = [], 
      this.namedChunkGroups = new Map, this.namedChunks = new Map, this.modules = [], 
      this._modules = new Map, this.cache = null, this.records = null, this.additionalChunkAssets = [], 
      this.assets = {}, this.assetsInfo = new Map, this.errors = [], this.warnings = [], 
      this.children = [], this.logging = new Map, this.dependencyFactories = new Map, 
      this.dependencyTemplates = new Map, this.dependencyTemplates.set("hash", ""), this.childrenCounters = {}, 
      this.usedChunkIds = null, this.usedModuleIds = null, this.fileTimestamps = void 0, 
      this.contextTimestamps = void 0, this.compilationDependencies = void 0, this._buildingModules = new Map, 
      this._rebuildingModules = new Map, this.emittedAssets = new Set;
    }
    getStats() {
      return new Stats(this);
    }
    getLogger(name) {
      if (!name) throw new TypeError("Compilation.getLogger(name) called without a name");
      let logEntries;
      return new Logger((type, args) => {
        if ("function" == typeof name && !(name = name())) throw new TypeError("Compilation.getLogger(name) called with a function not returning a name");
        let trace;
        switch (type) {
         case LogType.warn:
         case LogType.error:
         case LogType.trace:
          trace = ErrorHelpers.cutOffLoaderExecution(new Error("Trace").stack).split("\n").slice(3);
        }
        const logEntry = {
          time: Date.now(),
          type: type,
          args: args,
          trace: trace
        };
        void 0 === this.hooks.log.call(name, logEntry) && (logEntry.type === LogType.profileEnd && "function" == typeof console.profileEnd && console.profileEnd(`[${name}] ${logEntry.args[0]}`), 
        void 0 === logEntries && (logEntries = this.logging.get(name), void 0 === logEntries && (logEntries = [], 
        this.logging.set(name, logEntries))), logEntries.push(logEntry), logEntry.type === LogType.profile && "function" == typeof console.profile && console.profile(`[${name}] ${logEntry.args[0]}`));
      });
    }
    addModule(module, cacheGroup) {
      const identifier = module.identifier(), alreadyAddedModule = this._modules.get(identifier);
      if (alreadyAddedModule) return {
        module: alreadyAddedModule,
        issuer: !1,
        build: !1,
        dependencies: !1
      };
      const cacheName = (cacheGroup || "m") + identifier;
      if (this.cache && this.cache[cacheName]) {
        const cacheModule = this.cache[cacheName];
        "function" == typeof cacheModule.updateCacheModule && cacheModule.updateCacheModule(module);
        let rebuild = !0;
        if (this.fileTimestamps && this.contextTimestamps && (rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps)), 
        !rebuild) {
          cacheModule.disconnect(), this._modules.set(identifier, cacheModule), this.modules.push(cacheModule);
          for (const err of cacheModule.errors) this.errors.push(err);
          for (const err of cacheModule.warnings) this.warnings.push(err);
          return {
            module: cacheModule,
            issuer: !0,
            build: !1,
            dependencies: !0
          };
        }
        cacheModule.unbuild(), module = cacheModule;
      }
      return this._modules.set(identifier, module), this.cache && (this.cache[cacheName] = module), 
      this.modules.push(module), {
        module: module,
        issuer: !0,
        build: !0,
        dependencies: !0
      };
    }
    getModule(module) {
      const identifier = module.identifier();
      return this._modules.get(identifier);
    }
    findModule(identifier) {
      return this._modules.get(identifier);
    }
    waitForBuildingFinished(module, callback) {
      let callbackList = this._buildingModules.get(module);
      callbackList ? callbackList.push(() => callback()) : process.nextTick(callback);
    }
    buildModule(module, optional, origin, dependencies, thisCallback) {
      let callbackList = this._buildingModules.get(module);
      if (callbackList) return void callbackList.push(thisCallback);
      this._buildingModules.set(module, callbackList = [ thisCallback ]);
      const callback = err => {
        this._buildingModules.delete(module);
        for (const cb of callbackList) cb(err);
      };
      this.hooks.buildModule.call(module), module.build(this.options, this, this.resolverFactory.get("normal", module.resolveOptions), this.inputFileSystem, error => {
        const errors = module.errors;
        for (let indexError = 0; indexError < errors.length; indexError++) {
          const err = errors[indexError];
          err.origin = origin, err.dependencies = dependencies, optional ? this.warnings.push(err) : this.errors.push(err);
        }
        const warnings = module.warnings;
        for (let indexWarning = 0; indexWarning < warnings.length; indexWarning++) {
          const war = warnings[indexWarning];
          war.origin = origin, war.dependencies = dependencies, this.warnings.push(war);
        }
        const originalMap = module.dependencies.reduce((map, v, i) => (map.set(v, i), map), new Map);
        return module.dependencies.sort((a, b) => {
          const cmp = compareLocations(a.loc, b.loc);
          return cmp || originalMap.get(a) - originalMap.get(b);
        }), error ? (this.hooks.failedModule.call(module, error), callback(error)) : (this.hooks.succeedModule.call(module), 
        callback());
      });
    }
    processModuleDependencies(module, callback) {
      const dependencies = new Map, addDependency = dep => {
        const resourceIdent = dep.getResourceIdentifier();
        if (resourceIdent) {
          const factory = this.dependencyFactories.get(dep.constructor);
          if (void 0 === factory) throw new Error("No module factory available for dependency type: " + dep.constructor.name);
          let innerMap = dependencies.get(factory);
          void 0 === innerMap && dependencies.set(factory, innerMap = new Map);
          let list = innerMap.get(resourceIdent);
          void 0 === list && innerMap.set(resourceIdent, list = []), list.push(dep);
        }
      }, addDependenciesBlock = block => {
        block.dependencies && iterationOfArrayCallback(block.dependencies, addDependency), 
        block.blocks && iterationOfArrayCallback(block.blocks, addDependenciesBlock), block.variables && iterationBlockVariable(block.variables, addDependency);
      };
      try {
        addDependenciesBlock(module);
      } catch (e) {
        callback(e);
      }
      const sortedDependencies = [];
      for (const pair1 of dependencies) for (const pair2 of pair1[1]) sortedDependencies.push({
        factory: pair1[0],
        dependencies: pair2[1]
      });
      this.addModuleDependencies(module, sortedDependencies, this.bail, null, !0, callback);
    }
    addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {
      const start = this.profile && Date.now(), currentProfile = this.profile && {};
      asyncLib.forEach(dependencies, (item, callback) => {
        const dependencies = item.dependencies, errorAndCallback = err => {
          err.origin = module, err.dependencies = dependencies, this.errors.push(err), bail ? callback(err) : callback();
        }, warningAndCallback = err => {
          err.origin = module, this.warnings.push(err), callback();
        }, semaphore = this.semaphore;
        semaphore.acquire(() => {
          item.factory.create({
            contextInfo: {
              issuer: module.nameForCondition && module.nameForCondition(),
              compiler: this.compiler.name
            },
            resolveOptions: module.resolveOptions,
            context: module.context,
            dependencies: dependencies
          }, (err, dependentModule) => {
            let afterFactory;
            const isOptional = () => dependencies.every(d => d.optional), errorOrWarningAndCallback = err => isOptional() ? warningAndCallback(err) : errorAndCallback(err);
            if (err) return semaphore.release(), errorOrWarningAndCallback(new ModuleNotFoundError(module, err));
            if (!dependentModule) return semaphore.release(), process.nextTick(callback);
            currentProfile && (afterFactory = Date.now(), currentProfile.factory = afterFactory - start);
            const addModuleResult = this.addModule(dependentModule, cacheGroup);
            dependentModule = addModuleResult.module, (depend => {
              for (let index = 0; index < depend.length; index++) {
                const dep = depend[index];
                dep.module = dependentModule, dependentModule.addReason(module, dep);
              }
            })(dependencies);
            const afterBuild = () => {
              if (!recursive || !addModuleResult.dependencies) return callback();
              this.processModuleDependencies(dependentModule, callback);
            };
            if (addModuleResult.issuer) currentProfile && (dependentModule.profile = currentProfile), 
            dependentModule.issuer = module; else if (this.profile && module.profile) {
              const time = Date.now() - start;
              (!module.profile.dependencies || time > module.profile.dependencies) && (module.profile.dependencies = time);
            }
            addModuleResult.build ? this.buildModule(dependentModule, isOptional(), module, dependencies, err => {
              if (err) return semaphore.release(), errorOrWarningAndCallback(err);
              if (currentProfile) {
                const afterBuilding = Date.now();
                currentProfile.building = afterBuilding - afterFactory;
              }
              semaphore.release(), afterBuild();
            }) : (semaphore.release(), this.waitForBuildingFinished(dependentModule, afterBuild));
          });
        });
      }, err => err ? (err.stack = err.stack, callback(err)) : process.nextTick(callback));
    }
    _addModuleChain(context, dependency, onModule, callback) {
      const start = this.profile && Date.now(), currentProfile = this.profile && {}, errorAndCallback = this.bail ? err => {
        callback(err);
      } : err => {
        err.dependencies = [ dependency ], this.errors.push(err), callback();
      };
      if ("object" != typeof dependency || null === dependency || !dependency.constructor) throw new Error("Parameter 'dependency' must be a Dependency");
      const Dep = dependency.constructor, moduleFactory = this.dependencyFactories.get(Dep);
      if (!moduleFactory) throw new Error("No dependency factory available for this dependency type: " + dependency.constructor.name);
      this.semaphore.acquire(() => {
        moduleFactory.create({
          contextInfo: {
            issuer: "",
            compiler: this.compiler.name
          },
          context: context,
          dependencies: [ dependency ]
        }, (err, module) => {
          if (err) return this.semaphore.release(), errorAndCallback(new EntryModuleNotFoundError(err));
          let afterFactory;
          currentProfile && (afterFactory = Date.now(), currentProfile.factory = afterFactory - start);
          const addModuleResult = this.addModule(module);
          module = addModuleResult.module, onModule(module), dependency.module = module, module.addReason(null, dependency);
          const afterBuild = () => {
            if (!addModuleResult.dependencies) return callback(null, module);
            this.processModuleDependencies(module, err => {
              if (err) return callback(err);
              callback(null, module);
            });
          };
          addModuleResult.issuer && currentProfile && (module.profile = currentProfile), addModuleResult.build ? this.buildModule(module, !1, null, null, err => {
            if (err) return this.semaphore.release(), errorAndCallback(err);
            if (currentProfile) {
              const afterBuilding = Date.now();
              currentProfile.building = afterBuilding - afterFactory;
            }
            this.semaphore.release(), afterBuild();
          }) : (this.semaphore.release(), this.waitForBuildingFinished(module, afterBuild));
        });
      });
    }
    addEntry(context, entry, name, callback) {
      this.hooks.addEntry.call(entry, name);
      const slot = {
        name: name,
        request: null,
        module: null
      };
      entry instanceof ModuleDependency && (slot.request = entry.request);
      const idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);
      idx >= 0 ? this._preparedEntrypoints[idx] = slot : this._preparedEntrypoints.push(slot), 
      this._addModuleChain(context, entry, module => {
        this.entries.push(module);
      }, (err, module) => {
        if (err) return this.hooks.failedEntry.call(entry, name, err), callback(err);
        if (module) slot.module = module; else {
          const idx = this._preparedEntrypoints.indexOf(slot);
          idx >= 0 && this._preparedEntrypoints.splice(idx, 1);
        }
        return this.hooks.succeedEntry.call(entry, name, module), callback(null, module);
      });
    }
    prefetch(context, dependency, callback) {
      this._addModuleChain(context, dependency, module => {
        module.prefetched = !0;
      }, callback);
    }
    rebuildModule(module, thisCallback) {
      let callbackList = this._rebuildingModules.get(module);
      if (callbackList) return void callbackList.push(thisCallback);
      this._rebuildingModules.set(module, callbackList = [ thisCallback ]);
      const callback = err => {
        this._rebuildingModules.delete(module);
        for (const cb of callbackList) cb(err);
      };
      this.hooks.rebuildModule.call(module);
      const oldDependencies = module.dependencies.slice(), oldVariables = module.variables.slice(), oldBlocks = module.blocks.slice();
      module.unbuild(), this.buildModule(module, !1, module, null, err => {
        if (err) return this.hooks.finishRebuildingModule.call(module), callback(err);
        this.processModuleDependencies(module, err => {
          if (err) return callback(err);
          this.removeReasonsOfDependencyBlock(module, {
            dependencies: oldDependencies,
            variables: oldVariables,
            blocks: oldBlocks
          }), this.hooks.finishRebuildingModule.call(module), callback();
        });
      });
    }
    finish(callback) {
      const modules = this.modules;
      this.hooks.finishModules.callAsync(modules, err => {
        if (err) return callback(err);
        for (let index = 0; index < modules.length; index++) {
          const module = modules[index];
          this.reportDependencyErrorsAndWarnings(module, [ module ]);
        }
        callback();
      });
    }
    unseal() {
      this.hooks.unseal.call(), this.chunks.length = 0, this.chunkGroups.length = 0, this.namedChunks.clear(), 
      this.namedChunkGroups.clear(), this.additionalChunkAssets.length = 0, this.assets = {}, 
      this.assetsInfo.clear();
      for (const module of this.modules) module.unseal();
    }
    seal(callback) {
      for (this.hooks.seal.call(); this.hooks.optimizeDependenciesBasic.call(this.modules) || this.hooks.optimizeDependencies.call(this.modules) || this.hooks.optimizeDependenciesAdvanced.call(this.modules); ) ;
      this.hooks.afterOptimizeDependencies.call(this.modules), this.hooks.beforeChunks.call();
      for (const preparedEntrypoint of this._preparedEntrypoints) {
        const module = preparedEntrypoint.module, name = preparedEntrypoint.name, chunk = this.addChunk(name), entrypoint = new Entrypoint(name);
        entrypoint.setRuntimeChunk(chunk), entrypoint.addOrigin(null, name, preparedEntrypoint.request), 
        this.namedChunkGroups.set(name, entrypoint), this.entrypoints.set(name, entrypoint), 
        this.chunkGroups.push(entrypoint), GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk), 
        GraphHelpers.connectChunkAndModule(chunk, module), chunk.entryModule = module, chunk.name = name, 
        this.assignDepth(module);
      }
      for (buildChunkGraph(this, this.chunkGroups.slice()), this.sortModules(this.modules), 
      this.hooks.afterChunks.call(this.chunks), this.hooks.optimize.call(); this.hooks.optimizeModulesBasic.call(this.modules) || this.hooks.optimizeModules.call(this.modules) || this.hooks.optimizeModulesAdvanced.call(this.modules); ) ;
      for (this.hooks.afterOptimizeModules.call(this.modules); this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups); ) ;
      this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups), this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {
        if (err) return callback(err);
        for (this.hooks.afterOptimizeTree.call(this.chunks, this.modules); this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) || this.hooks.optimizeChunkModules.call(this.chunks, this.modules) || this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules); ) ;
        this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);
        const shouldRecord = !1 !== this.hooks.shouldRecord.call();
        this.hooks.reviveModules.call(this.modules, this.records), this.hooks.optimizeModuleOrder.call(this.modules), 
        this.hooks.advancedOptimizeModuleOrder.call(this.modules), this.hooks.beforeModuleIds.call(this.modules), 
        this.hooks.moduleIds.call(this.modules), this.applyModuleIds(), this.hooks.optimizeModuleIds.call(this.modules), 
        this.hooks.afterOptimizeModuleIds.call(this.modules), this.sortItemsWithModuleIds(), 
        this.hooks.reviveChunks.call(this.chunks, this.records), this.hooks.optimizeChunkOrder.call(this.chunks), 
        this.hooks.beforeChunkIds.call(this.chunks), this.applyChunkIds(), this.hooks.optimizeChunkIds.call(this.chunks), 
        this.hooks.afterOptimizeChunkIds.call(this.chunks), this.sortItemsWithChunkIds(), 
        shouldRecord && (this.hooks.recordModules.call(this.modules, this.records), this.hooks.recordChunks.call(this.chunks, this.records)), 
        this.hooks.beforeHash.call(), this.createHash(), this.hooks.afterHash.call(), shouldRecord && this.hooks.recordHash.call(this.records), 
        this.hooks.beforeModuleAssets.call(), this.createModuleAssets(), !1 !== this.hooks.shouldGenerateChunkAssets.call() && (this.hooks.beforeChunkAssets.call(), 
        this.createChunkAssets()), this.hooks.additionalChunkAssets.call(this.chunks), this.summarizeDependencies(), 
        shouldRecord && this.hooks.record.call(this, this.records), this.hooks.additionalAssets.callAsync(err => {
          if (err) return callback(err);
          this.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {
            if (err) return callback(err);
            this.hooks.afterOptimizeChunkAssets.call(this.chunks), this.hooks.optimizeAssets.callAsync(this.assets, err => err ? callback(err) : (this.hooks.afterOptimizeAssets.call(this.assets), 
            this.hooks.needAdditionalSeal.call() ? (this.unseal(), this.seal(callback)) : this.hooks.afterSeal.callAsync(callback)));
          });
        });
      });
    }
    sortModules(modules) {
      modules.sort(byIndexOrIdentifier);
    }
    reportDependencyErrorsAndWarnings(module, blocks) {
      for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
        const block = blocks[indexBlock], dependencies = block.dependencies;
        for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {
          const d = dependencies[indexDep], warnings = d.getWarnings();
          if (warnings) for (let indexWar = 0; indexWar < warnings.length; indexWar++) {
            const w = warnings[indexWar], warning = new ModuleDependencyWarning(module, w, d.loc);
            this.warnings.push(warning);
          }
          const errors = d.getErrors();
          if (errors) for (let indexErr = 0; indexErr < errors.length; indexErr++) {
            const e = errors[indexErr], error = new ModuleDependencyError(module, e, d.loc);
            this.errors.push(error);
          }
        }
        this.reportDependencyErrorsAndWarnings(module, block.blocks);
      }
    }
    addChunkInGroup(groupOptions, module, loc, request) {
      "string" == typeof groupOptions && (groupOptions = {
        name: groupOptions
      });
      const name = groupOptions.name;
      if (name) {
        const chunkGroup = this.namedChunkGroups.get(name);
        if (void 0 !== chunkGroup) return chunkGroup.addOptions(groupOptions), module && chunkGroup.addOrigin(module, loc, request), 
        chunkGroup;
      }
      const chunkGroup = new ChunkGroup(groupOptions);
      module && chunkGroup.addOrigin(module, loc, request);
      const chunk = this.addChunk(name);
      return GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk), this.chunkGroups.push(chunkGroup), 
      name && this.namedChunkGroups.set(name, chunkGroup), chunkGroup;
    }
    addChunk(name) {
      if (name) {
        const chunk = this.namedChunks.get(name);
        if (void 0 !== chunk) return chunk;
      }
      const chunk = new Chunk(name);
      return this.chunks.push(chunk), name && this.namedChunks.set(name, chunk), chunk;
    }
    assignDepth(module) {
      const queue = new Set([ module ]);
      let depth;
      module.depth = 0;
      const assignDepthToDependency = dependency => {
        dependency.module && (module => {
          const d = module.depth;
          "number" == typeof d && d <= depth || (queue.add(module), module.depth = depth);
        })(dependency.module);
      }, assignDepthToDependencyBlock = block => {
        block.variables && iterationBlockVariable(block.variables, assignDepthToDependency), 
        block.dependencies && iterationOfArrayCallback(block.dependencies, assignDepthToDependency), 
        block.blocks && iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);
      };
      for (module of queue) queue.delete(module), depth = module.depth, depth++, assignDepthToDependencyBlock(module);
    }
    getDependencyReference(module, dependency) {
      if ("function" != typeof dependency.getReference) return null;
      const ref = dependency.getReference();
      return ref ? this.hooks.dependencyReference.call(ref, dependency, module) : null;
    }
    removeReasonsOfDependencyBlock(module, block) {
      const iteratorDependency = d => {
        if (d.module && d.module.removeReason(module, d)) for (const chunk of d.module.chunksIterable) this.patchChunksAfterReasonRemoval(d.module, chunk);
      };
      block.blocks && iterationOfArrayCallback(block.blocks, block => this.removeReasonsOfDependencyBlock(module, block)), 
      block.dependencies && iterationOfArrayCallback(block.dependencies, iteratorDependency), 
      block.variables && iterationBlockVariable(block.variables, iteratorDependency);
    }
    patchChunksAfterReasonRemoval(module, chunk) {
      module.hasReasons() || this.removeReasonsOfDependencyBlock(module, module), module.hasReasonForChunk(chunk) || module.removeChunk(chunk) && this.removeChunkFromDependencies(module, chunk);
    }
    removeChunkFromDependencies(block, chunk) {
      const iteratorDependency = d => {
        d.module && this.patchChunksAfterReasonRemoval(d.module, chunk);
      }, blocks = block.blocks;
      for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {
        const asyncBlock = blocks[indexBlock], chunks = asyncBlock.chunkGroup.chunks;
        for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
          const iteratedChunk = chunks[indexChunk];
          asyncBlock.chunkGroup.removeChunk(iteratedChunk), asyncBlock.chunkGroup.removeParent(iteratedChunk), 
          this.removeChunkFromDependencies(block, iteratedChunk);
        }
      }
      block.dependencies && iterationOfArrayCallback(block.dependencies, iteratorDependency), 
      block.variables && iterationBlockVariable(block.variables, iteratorDependency);
    }
    applyModuleIds() {
      const unusedIds = [];
      let nextFreeModuleId = 0;
      const usedIds = new Set;
      if (this.usedModuleIds) for (const id of this.usedModuleIds) usedIds.add(id);
      const modules1 = this.modules;
      for (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {
        const module1 = modules1[indexModule1];
        null !== module1.id && usedIds.add(module1.id);
      }
      if (usedIds.size > 0) {
        let usedIdMax = -1;
        for (const usedIdKey of usedIds) "number" == typeof usedIdKey && (usedIdMax = Math.max(usedIdMax, usedIdKey));
        let lengthFreeModules = nextFreeModuleId = usedIdMax + 1;
        for (;lengthFreeModules--; ) usedIds.has(lengthFreeModules) || unusedIds.push(lengthFreeModules);
      }
      const modules2 = this.modules;
      for (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {
        const module2 = modules2[indexModule2];
        null === module2.id && (unusedIds.length > 0 ? module2.id = unusedIds.pop() : module2.id = nextFreeModuleId++);
      }
    }
    applyChunkIds() {
      const usedIds = new Set;
      if (this.usedChunkIds) for (const id of this.usedChunkIds) "number" == typeof id && usedIds.add(id);
      const chunks = this.chunks;
      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        const usedIdValue = chunks[indexChunk].id;
        "number" == typeof usedIdValue && usedIds.add(usedIdValue);
      }
      let nextFreeChunkId = -1;
      for (const id of usedIds) nextFreeChunkId = Math.max(nextFreeChunkId, id);
      nextFreeChunkId++;
      const unusedIds = [];
      if (nextFreeChunkId > 0) {
        let index = nextFreeChunkId;
        for (;index--; ) usedIds.has(index) || unusedIds.push(index);
      }
      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        const chunk = chunks[indexChunk];
        null === chunk.id && (unusedIds.length > 0 ? chunk.id = unusedIds.pop() : chunk.id = nextFreeChunkId++), 
        chunk.ids || (chunk.ids = [ chunk.id ]);
      }
    }
    sortItemsWithModuleIds() {
      this.modules.sort(byIdOrIdentifier);
      const modules = this.modules;
      for (let indexModule = 0; indexModule < modules.length; indexModule++) modules[indexModule].sortItems(!1);
      const chunks = this.chunks;
      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) chunks[indexChunk].sortItems();
      chunks.sort((a, b) => a.compareTo(b));
    }
    sortItemsWithChunkIds() {
      for (const chunkGroup of this.chunkGroups) chunkGroup.sortItems();
      this.chunks.sort(byId);
      for (let indexModule = 0; indexModule < this.modules.length; indexModule++) this.modules[indexModule].sortItems(!0);
      const chunks = this.chunks;
      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) chunks[indexChunk].sortItems();
      const byMessage = (a, b) => {
        const ma = "" + a.message, mb = "" + b.message;
        return ma < mb ? -1 : mb < ma ? 1 : 0;
      };
      this.errors.sort(byMessage), this.warnings.sort(byMessage), this.children.sort(byNameOrHash);
    }
    summarizeDependencies() {
      this.fileDependencies = new SortableSet(this.compilationDependencies), this.contextDependencies = new SortableSet, 
      this.missingDependencies = new SortableSet;
      for (let indexChildren = 0; indexChildren < this.children.length; indexChildren++) {
        const child = this.children[indexChildren];
        addAllToSet(this.fileDependencies, child.fileDependencies), addAllToSet(this.contextDependencies, child.contextDependencies), 
        addAllToSet(this.missingDependencies, child.missingDependencies);
      }
      for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {
        const module = this.modules[indexModule];
        module.buildInfo.fileDependencies && addAllToSet(this.fileDependencies, module.buildInfo.fileDependencies), 
        module.buildInfo.contextDependencies && addAllToSet(this.contextDependencies, module.buildInfo.contextDependencies);
      }
      for (const error of this.errors) "object" == typeof error.missing && error.missing && error.missing[Symbol.iterator] && addAllToSet(this.missingDependencies, error.missing);
      this.fileDependencies.sort(), this.contextDependencies.sort(), this.missingDependencies.sort();
    }
    createHash() {
      const outputOptions = this.outputOptions, hashFunction = outputOptions.hashFunction, hashDigest = outputOptions.hashDigest, hashDigestLength = outputOptions.hashDigestLength, hash = createHash(hashFunction);
      outputOptions.hashSalt && hash.update(outputOptions.hashSalt), this.mainTemplate.updateHash(hash), 
      this.chunkTemplate.updateHash(hash);
      for (const key of Object.keys(this.moduleTemplates).sort()) this.moduleTemplates[key].updateHash(hash);
      for (const child of this.children) hash.update(child.hash);
      for (const warning of this.warnings) hash.update("" + warning.message);
      for (const error of this.errors) hash.update("" + error.message);
      const modules = this.modules;
      for (let i = 0; i < modules.length; i++) {
        const module = modules[i], moduleHash = createHash(hashFunction);
        module.updateHash(moduleHash), module.hash = moduleHash.digest(hashDigest), module.renderedHash = module.hash.substr(0, hashDigestLength);
      }
      const chunks = this.chunks.slice();
      chunks.sort((a, b) => {
        const aEntry = a.hasRuntime(), bEntry = b.hasRuntime();
        return aEntry && !bEntry ? 1 : !aEntry && bEntry ? -1 : byId(a, b);
      });
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i], chunkHash = createHash(hashFunction);
        try {
          outputOptions.hashSalt && chunkHash.update(outputOptions.hashSalt), chunk.updateHash(chunkHash);
          (chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate).updateHashForChunk(chunkHash, chunk, this.moduleTemplates.javascript, this.dependencyTemplates), 
          this.hooks.chunkHash.call(chunk, chunkHash), chunk.hash = chunkHash.digest(hashDigest), 
          hash.update(chunk.hash), chunk.renderedHash = chunk.hash.substr(0, hashDigestLength), 
          this.hooks.contentHash.call(chunk);
        } catch (err) {
          this.errors.push(new ChunkRenderError(chunk, "", err));
        }
      }
      this.fullHash = hash.digest(hashDigest), this.hash = this.fullHash.substr(0, hashDigestLength);
    }
    modifyHash(update) {
      const outputOptions = this.outputOptions, hashFunction = outputOptions.hashFunction, hashDigest = outputOptions.hashDigest, hashDigestLength = outputOptions.hashDigestLength, hash = createHash(hashFunction);
      hash.update(this.fullHash), hash.update(update), this.fullHash = hash.digest(hashDigest), 
      this.hash = this.fullHash.substr(0, hashDigestLength);
    }
    emitAsset(file, source, assetInfo = {}) {
      if (this.assets[file]) {
        if (!((a, b) => {
          if (a === b) return !0;
          let aSource = a.source(), bSource = b.source();
          return aSource === bSource || ("string" != typeof aSource || "string" != typeof bSource) && (Buffer.isBuffer(aSource) || (aSource = Buffer.from(aSource, "utf-8")), 
          Buffer.isBuffer(bSource) || (bSource = Buffer.from(bSource, "utf-8")), aSource.equals(bSource));
        })(this.assets[file], source)) return this.warnings.push(new WebpackError("Conflict: Multiple assets emit different content to the same filename " + file)), 
        this.assets[file] = source, void this.assetsInfo.set(file, assetInfo);
        const oldInfo = this.assetsInfo.get(file);
        this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));
      } else this.assets[file] = source, this.assetsInfo.set(file, assetInfo);
    }
    updateAsset(file, newSourceOrFunction, assetInfoUpdateOrFunction) {
      if (!this.assets[file]) throw new Error("Called Compilation.updateAsset for not existing filename " + file);
      if (this.assets[file] = "function" == typeof newSourceOrFunction ? newSourceOrFunction(this.assets[file]) : newSourceOrFunction, 
      void 0 !== assetInfoUpdateOrFunction) {
        const oldInfo = this.assetsInfo.get(file);
        "function" == typeof assetInfoUpdateOrFunction ? this.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {})) : this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfoUpdateOrFunction));
      }
    }
    getAssets() {
      const array = [];
      for (const assetName of Object.keys(this.assets)) Object.prototype.hasOwnProperty.call(this.assets, assetName) && array.push({
        name: assetName,
        source: this.assets[assetName],
        info: this.assetsInfo.get(assetName) || {}
      });
      return array;
    }
    getAsset(name) {
      if (Object.prototype.hasOwnProperty.call(this.assets, name)) return {
        name: name,
        source: this.assets[name],
        info: this.assetsInfo.get(name) || {}
      };
    }
    createModuleAssets() {
      for (let i = 0; i < this.modules.length; i++) {
        const module = this.modules[i];
        if (module.buildInfo.assets) {
          const assetsInfo = module.buildInfo.assetsInfo;
          for (const assetName of Object.keys(module.buildInfo.assets)) {
            const fileName = this.getPath(assetName);
            this.emitAsset(fileName, module.buildInfo.assets[assetName], assetsInfo ? assetsInfo.get(assetName) : void 0), 
            this.hooks.moduleAsset.call(module, fileName);
          }
        }
      }
    }
    createChunkAssets() {
      const outputOptions = this.outputOptions, cachedSourceMap = new Map, alreadyWrittenFiles = new Map;
      for (let i = 0; i < this.chunks.length; i++) {
        const chunk = this.chunks[i];
        let source, file, filenameTemplate;
        chunk.files = [];
        try {
          const manifest = (chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate).getRenderManifest({
            chunk: chunk,
            hash: this.hash,
            fullHash: this.fullHash,
            outputOptions: outputOptions,
            moduleTemplates: this.moduleTemplates,
            dependencyTemplates: this.dependencyTemplates
          });
          for (const fileManifest of manifest) {
            const cacheName = fileManifest.identifier, usedHash = fileManifest.hash;
            filenameTemplate = fileManifest.filenameTemplate;
            const pathAndInfo = this.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);
            file = pathAndInfo.path;
            const assetInfo = pathAndInfo.info, alreadyWritten = alreadyWrittenFiles.get(file);
            if (void 0 !== alreadyWritten) {
              if (alreadyWritten.hash === usedHash) {
                this.cache && (this.cache[cacheName] = {
                  hash: usedHash,
                  source: alreadyWritten.source
                }), chunk.files.push(file), this.hooks.chunkAsset.call(chunk, file);
                continue;
              }
              throw new Error("Conflict: Multiple chunks emit assets to the same filename " + file + ` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`);
            }
            if (this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) source = this.cache[cacheName].source; else {
              if (source = fileManifest.render(), !(source instanceof CachedSource)) {
                const cacheEntry = cachedSourceMap.get(source);
                if (cacheEntry) source = cacheEntry; else {
                  const cachedSource = new CachedSource(source);
                  cachedSourceMap.set(source, cachedSource), source = cachedSource;
                }
              }
              this.cache && (this.cache[cacheName] = {
                hash: usedHash,
                source: source
              });
            }
            this.emitAsset(file, source, assetInfo), chunk.files.push(file), this.hooks.chunkAsset.call(chunk, file), 
            alreadyWrittenFiles.set(file, {
              hash: usedHash,
              source: source,
              chunk: chunk
            });
          }
        } catch (err) {
          this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));
        }
      }
    }
    getPath(filename, data) {
      return (data = data || {}).hash = data.hash || this.hash, this.mainTemplate.getAssetPath(filename, data);
    }
    getPathWithInfo(filename, data) {
      return (data = data || {}).hash = data.hash || this.hash, this.mainTemplate.getAssetPathWithInfo(filename, data);
    }
    createChildCompiler(name, outputOptions, plugins) {
      const idx = this.childrenCounters[name] || 0;
      return this.childrenCounters[name] = idx + 1, this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);
    }
    checkConstraints() {
      const usedIds = new Set, modules = this.modules;
      for (let indexModule = 0; indexModule < modules.length; indexModule++) {
        const moduleId = modules[indexModule].id;
        if (null !== moduleId) {
          if (usedIds.has(moduleId)) throw new Error("checkConstraints: duplicate module id " + moduleId);
          usedIds.add(moduleId);
        }
      }
      const chunks = this.chunks;
      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {
        const chunk = chunks[indexChunk];
        if (chunks.indexOf(chunk) !== indexChunk) throw new Error("checkConstraints: duplicate chunk in compilation " + chunk.debugId);
      }
      for (const chunkGroup of this.chunkGroups) chunkGroup.checkConstraints();
    }
  }
  Compilation.prototype.applyPlugins = util.deprecate((function(name, ...args) {
    this.hooks[name.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())].call(...args);
  }), "Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead"), 
  Object.defineProperty(Compilation.prototype, "moduleTemplate", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.moduleTemplates.javascript;
    }), "Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead"),
    set: util.deprecate((function(value) {
      this.moduleTemplates.javascript = value;
    }), "Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.")
  }), module.exports = Compilation;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(err) {
      super("Entry module not found: " + err), this.name = "EntryModuleNotFoundError", 
      this.details = err.details, this.error = err, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(module, err) {
      super("Module not found: " + err), this.name = "ModuleNotFoundError", this.details = err.details, 
      this.missing = err.missing, this.module = module, this.error = err, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(module, err, loc) {
      super(err.message), this.name = "ModuleDependencyWarning", this.details = err.stack.split("\n").slice(1).join("\n"), 
      this.module = module, this.loc = loc, this.error = err, this.origin = module.issuer, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(module, err, loc) {
      super(err.message), this.name = "ModuleDependencyError", this.details = err.stack.split("\n").slice(1).join("\n"), 
      this.module = module, this.loc = loc, this.error = err, this.origin = module.issuer, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource, OriginalSource: OriginalSource, PrefixSource: PrefixSource, RawSource: RawSource} = __webpack_require__(0), {Tapable: Tapable, SyncWaterfallHook: SyncWaterfallHook, SyncHook: SyncHook, SyncBailHook: SyncBailHook} = __webpack_require__(6), Template = __webpack_require__(2);
  module.exports = class extends Tapable {
    constructor(outputOptions) {
      super(), this.outputOptions = outputOptions || {}, this.hooks = {
        renderManifest: new SyncWaterfallHook([ "result", "options" ]),
        modules: new SyncWaterfallHook([ "modules", "chunk", "hash", "moduleTemplate", "dependencyTemplates" ]),
        moduleObj: new SyncWaterfallHook([ "source", "chunk", "hash", "moduleIdExpression" ]),
        requireEnsure: new SyncWaterfallHook([ "source", "chunk", "hash", "chunkIdExpression" ]),
        bootstrap: new SyncWaterfallHook([ "source", "chunk", "hash", "moduleTemplate", "dependencyTemplates" ]),
        localVars: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        require: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        requireExtensions: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        beforeStartup: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        startup: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        afterStartup: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        render: new SyncWaterfallHook([ "source", "chunk", "hash", "moduleTemplate", "dependencyTemplates" ]),
        renderWithEntry: new SyncWaterfallHook([ "source", "chunk", "hash" ]),
        moduleRequire: new SyncWaterfallHook([ "source", "chunk", "hash", "moduleIdExpression" ]),
        addModule: new SyncWaterfallHook([ "source", "chunk", "hash", "moduleIdExpression", "moduleExpression" ]),
        currentHash: new SyncWaterfallHook([ "source", "requestedLength" ]),
        assetPath: new SyncWaterfallHook([ "path", "options", "assetInfo" ]),
        hash: new SyncHook([ "hash" ]),
        hashForChunk: new SyncHook([ "hash", "chunk" ]),
        globalHashPaths: new SyncWaterfallHook([ "paths" ]),
        globalHash: new SyncBailHook([ "chunk", "paths" ]),
        hotBootstrap: new SyncWaterfallHook([ "source", "chunk", "hash" ])
      }, this.hooks.startup.tap("MainTemplate", (source, chunk, hash) => {
        const buf = [];
        return chunk.entryModule && (buf.push("// Load entry module and return exports"), 
        buf.push(`return ${this.renderRequireFunctionForModule(hash, chunk, JSON.stringify(chunk.entryModule.id))}(${this.requireFn}.s = ${JSON.stringify(chunk.entryModule.id)});`)), 
        Template.asString(buf);
      }), this.hooks.render.tap("MainTemplate", (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => {
        const source = new ConcatSource;
        return source.add("/******/ (function(modules) { // webpackBootstrap\n"), source.add(new PrefixSource("/******/", bootstrapSource)), 
        source.add("/******/ })\n"), source.add("/************************************************************************/\n"), 
        source.add("/******/ ("), source.add(this.hooks.modules.call(new RawSource(""), chunk, hash, moduleTemplate, dependencyTemplates)), 
        source.add(")"), source;
      }), this.hooks.localVars.tap("MainTemplate", (source, chunk, hash) => Template.asString([ source, "// The module cache", "var installedModules = {};" ])), 
      this.hooks.require.tap("MainTemplate", (source, chunk, hash) => Template.asString([ source, "// Check if module is in cache", "if(installedModules[moduleId]) {", Template.indent("return installedModules[moduleId].exports;"), "}", "// Create a new module (and put it into the cache)", "var module = installedModules[moduleId] = {", Template.indent(this.hooks.moduleObj.call("", chunk, hash, "moduleId")), "};", "", Template.asString(outputOptions.strictModuleExceptionHandling ? [ "// Execute the module function", "var threw = true;", "try {", Template.indent([ `modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(hash, chunk, "moduleId")});`, "threw = false;" ]), "} finally {", Template.indent([ "if(threw) delete installedModules[moduleId];" ]), "}" ] : [ "// Execute the module function", `modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(hash, chunk, "moduleId")});` ]), "", "// Flag the module as loaded", "module.l = true;", "", "// Return the exports of the module", "return module.exports;" ])), 
      this.hooks.moduleObj.tap("MainTemplate", (source, chunk, hash, varModuleId) => Template.asString([ "i: moduleId,", "l: false,", "exports: {}" ])), 
      this.hooks.requireExtensions.tap("MainTemplate", (source, chunk, hash) => {
        const buf = [], chunkMaps = chunk.getChunkMaps();
        Object.keys(chunkMaps.hash).length ? (buf.push("// This file contains only the entry chunk."), 
        buf.push("// The chunk loading function for additional chunks"), buf.push(this.requireFn + ".e = function requireEnsure(chunkId) {"), 
        buf.push(Template.indent("var promises = [];")), buf.push(Template.indent(this.hooks.requireEnsure.call("", chunk, hash, "chunkId"))), 
        buf.push(Template.indent("return Promise.all(promises);")), buf.push("};")) : chunk.hasModuleInGraph(m => m.blocks.some(b => b.chunkGroup && b.chunkGroup.chunks.length > 0)) && (buf.push("// The chunk loading function for additional chunks"), 
        buf.push("// Since all referenced chunks are already included"), buf.push("// in this file, this function is empty here."), 
        buf.push(this.requireFn + ".e = function requireEnsure() {"), buf.push(Template.indent("return Promise.resolve();")), 
        buf.push("};")), buf.push(""), buf.push("// expose the modules object (__webpack_modules__)"), 
        buf.push(this.requireFn + ".m = modules;"), buf.push(""), buf.push("// expose the module cache"), 
        buf.push(this.requireFn + ".c = installedModules;"), buf.push(""), buf.push("// define getter function for harmony exports"), 
        buf.push(this.requireFn + ".d = function(exports, name, getter) {"), buf.push(Template.indent([ `if(!${this.requireFn}.o(exports, name)) {`, Template.indent([ "Object.defineProperty(exports, name, { enumerable: true, get: getter });" ]), "}" ])), 
        buf.push("};"), buf.push(""), buf.push("// define __esModule on exports"), buf.push(this.requireFn + ".r = function(exports) {"), 
        buf.push(Template.indent([ "if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {", Template.indent([ "Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });" ]), "}", "Object.defineProperty(exports, '__esModule', { value: true });" ])), 
        buf.push("};"), buf.push(""), buf.push("// create a fake namespace object"), buf.push("// mode & 1: value is a module id, require it"), 
        buf.push("// mode & 2: merge all properties of value into the ns"), buf.push("// mode & 4: return value when already ns object"), 
        buf.push("// mode & 8|1: behave like require"), buf.push(this.requireFn + ".t = function(value, mode) {"), 
        buf.push(Template.indent([ `if(mode & 1) value = ${this.requireFn}(value);`, "if(mode & 8) return value;", "if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;", "var ns = Object.create(null);", this.requireFn + ".r(ns);", "Object.defineProperty(ns, 'default', { enumerable: true, value: value });", "if(mode & 2 && typeof value != 'string') for(var key in value) " + this.requireFn + ".d(ns, key, function(key) { return value[key]; }.bind(null, key));", "return ns;" ])), 
        buf.push("};"), buf.push(""), buf.push("// getDefaultExport function for compatibility with non-harmony modules"), 
        buf.push(this.requireFn + ".n = function(module) {"), buf.push(Template.indent([ "var getter = module && module.__esModule ?", Template.indent([ "function getDefault() { return module['default']; } :", "function getModuleExports() { return module; };" ]), this.requireFn + ".d(getter, 'a', getter);", "return getter;" ])), 
        buf.push("};"), buf.push(""), buf.push("// Object.prototype.hasOwnProperty.call"), 
        buf.push(this.requireFn + ".o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };");
        const publicPath = this.getPublicPath({
          hash: hash
        });
        return buf.push(""), buf.push("// __webpack_public_path__"), buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`), 
        Template.asString(buf);
      }), this.requireFn = "__webpack_require__";
    }
    getRenderManifest(options) {
      const result = [];
      return this.hooks.renderManifest.call(result, options), result;
    }
    renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {
      const buf = [];
      buf.push(this.hooks.bootstrap.call("", chunk, hash, moduleTemplate, dependencyTemplates)), 
      buf.push(this.hooks.localVars.call("", chunk, hash)), buf.push(""), buf.push("// The require function"), 
      buf.push(`function ${this.requireFn}(moduleId) {`), buf.push(Template.indent(this.hooks.require.call("", chunk, hash))), 
      buf.push("}"), buf.push(""), buf.push(Template.asString(this.hooks.requireExtensions.call("", chunk, hash))), 
      buf.push(""), buf.push(Template.asString(this.hooks.beforeStartup.call("", chunk, hash)));
      const afterStartupCode = Template.asString(this.hooks.afterStartup.call("", chunk, hash));
      return afterStartupCode && buf.push("var startupResult = (function() {"), buf.push(Template.asString(this.hooks.startup.call("", chunk, hash))), 
      afterStartupCode && (buf.push("})();"), buf.push(afterStartupCode), buf.push("return startupResult;")), 
      buf;
    }
    render(hash, chunk, moduleTemplate, dependencyTemplates) {
      const buf = this.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);
      let source = this.hooks.render.call(new OriginalSource(Template.prefix(buf, " \t") + "\n", "webpack/bootstrap"), chunk, hash, moduleTemplate, dependencyTemplates);
      if (chunk.hasEntryModule() && (source = this.hooks.renderWithEntry.call(source, chunk, hash)), 
      !source) throw new Error("Compiler error: MainTemplate plugin 'render' should return something");
      return chunk.rendered = !0, new ConcatSource(source, ";");
    }
    renderRequireFunctionForModule(hash, chunk, varModuleId) {
      return this.hooks.moduleRequire.call(this.requireFn, chunk, hash, varModuleId);
    }
    renderAddModule(hash, chunk, varModuleId, varModule) {
      return this.hooks.addModule.call(`modules[${varModuleId}] = ${varModule};`, chunk, hash, varModuleId, varModule);
    }
    renderCurrentHashCode(hash, length) {
      return length = length || 1 / 0, this.hooks.currentHash.call(JSON.stringify(hash.substr(0, length)), length);
    }
    getPublicPath(options) {
      return this.hooks.assetPath.call(this.outputOptions.publicPath || "", options);
    }
    getAssetPath(path, options) {
      return this.hooks.assetPath.call(path, options);
    }
    getAssetPathWithInfo(path, options) {
      const assetInfo = {};
      return {
        path: this.hooks.assetPath.call(path, options, assetInfo),
        info: assetInfo
      };
    }
    updateHash(hash) {
      hash.update("maintemplate"), hash.update("3"), this.hooks.hash.call(hash);
    }
    updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
      this.updateHash(hash), this.hooks.hashForChunk.call(hash, chunk);
      for (const line of this.renderBootstrap("0000", chunk, moduleTemplate, dependencyTemplates)) hash.update(line);
    }
    useChunkHash(chunk) {
      const paths = this.hooks.globalHashPaths.call([]);
      return !this.hooks.globalHash.call(chunk, paths);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {Tapable: Tapable, SyncWaterfallHook: SyncWaterfallHook, SyncHook: SyncHook} = __webpack_require__(6);
  module.exports = class extends Tapable {
    constructor(outputOptions) {
      super(), this.outputOptions = outputOptions || {}, this.hooks = {
        renderManifest: new SyncWaterfallHook([ "result", "options" ]),
        modules: new SyncWaterfallHook([ "source", "chunk", "moduleTemplate", "dependencyTemplates" ]),
        render: new SyncWaterfallHook([ "source", "chunk", "moduleTemplate", "dependencyTemplates" ]),
        renderWithEntry: new SyncWaterfallHook([ "source", "chunk" ]),
        hash: new SyncHook([ "hash" ]),
        hashForChunk: new SyncHook([ "hash", "chunk" ])
      };
    }
    getRenderManifest(options) {
      const result = [];
      return this.hooks.renderManifest.call(result, options), result;
    }
    updateHash(hash) {
      hash.update("ChunkTemplate"), hash.update("2"), this.hooks.hash.call(hash);
    }
    updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {
      this.updateHash(hash), this.hooks.hashForChunk.call(hash, chunk);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2), HotUpdateChunk = __webpack_require__(98), {Tapable: Tapable, SyncWaterfallHook: SyncWaterfallHook, SyncHook: SyncHook} = __webpack_require__(6);
  module.exports = class extends Tapable {
    constructor(outputOptions) {
      super(), this.outputOptions = outputOptions || {}, this.hooks = {
        modules: new SyncWaterfallHook([ "source", "modules", "removedModules", "moduleTemplate", "dependencyTemplates" ]),
        render: new SyncWaterfallHook([ "source", "modules", "removedModules", "hash", "id", "moduleTemplate", "dependencyTemplates" ]),
        hash: new SyncHook([ "hash" ])
      };
    }
    render(id, modules, removedModules, hash, moduleTemplate, dependencyTemplates) {
      const hotUpdateChunk = new HotUpdateChunk;
      hotUpdateChunk.id = id, hotUpdateChunk.setModules(modules), hotUpdateChunk.removedModules = removedModules;
      const modulesSource = Template.renderChunkModules(hotUpdateChunk, m => "function" == typeof m.source, moduleTemplate, dependencyTemplates), core = this.hooks.modules.call(modulesSource, modules, removedModules, moduleTemplate, dependencyTemplates);
      return this.hooks.render.call(core, modules, removedModules, hash, id, moduleTemplate, dependencyTemplates);
    }
    updateHash(hash) {
      hash.update("HotUpdateChunkTemplate"), hash.update("1"), this.hooks.hash.call(hash);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {Tapable: Tapable, SyncWaterfallHook: SyncWaterfallHook, SyncHook: SyncHook} = __webpack_require__(6);
  module.exports = class extends Tapable {
    constructor(runtimeTemplate, type) {
      super(), this.runtimeTemplate = runtimeTemplate, this.type = type, this.hooks = {
        content: new SyncWaterfallHook([ "source", "module", "options", "dependencyTemplates" ]),
        module: new SyncWaterfallHook([ "source", "module", "options", "dependencyTemplates" ]),
        render: new SyncWaterfallHook([ "source", "module", "options", "dependencyTemplates" ]),
        package: new SyncWaterfallHook([ "source", "module", "options", "dependencyTemplates" ]),
        hash: new SyncHook([ "hash" ])
      };
    }
    render(module, dependencyTemplates, options) {
      try {
        const moduleSource = module.source(dependencyTemplates, this.runtimeTemplate, this.type), moduleSourcePostContent = this.hooks.content.call(moduleSource, module, options, dependencyTemplates), moduleSourcePostModule = this.hooks.module.call(moduleSourcePostContent, module, options, dependencyTemplates), moduleSourcePostRender = this.hooks.render.call(moduleSourcePostModule, module, options, dependencyTemplates);
        return this.hooks.package.call(moduleSourcePostRender, module, options, dependencyTemplates);
      } catch (e) {
        throw e.message = `${module.identifier()}\n${e.message}`, e;
      }
    }
    updateHash(hash) {
      hash.update("1"), this.hooks.hash.call(hash);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2);
  module.exports = class {
    constructor(outputOptions, requestShortener) {
      this.outputOptions = outputOptions || {}, this.requestShortener = requestShortener;
    }
    comment({request: request, chunkName: chunkName, chunkReason: chunkReason, message: message, exportName: exportName}) {
      let content;
      return content = this.outputOptions.pathinfo ? [ message, request, chunkName, chunkReason ].filter(Boolean).map(item => this.requestShortener.shorten(item)).join(" | ") : [ message, chunkName, chunkReason ].filter(Boolean).map(item => this.requestShortener.shorten(item)).join(" | "), 
      content ? this.outputOptions.pathinfo ? Template.toComment(content) + " " : Template.toNormalComment(content) + " " : "";
    }
    throwMissingModuleErrorFunction({request: request}) {
      const err = `Cannot find module '${request}'`;
      return `function webpackMissingModule() { var e = new Error(${JSON.stringify(err)}); e.code = 'MODULE_NOT_FOUND'; throw e; }`;
    }
    missingModule({request: request}) {
      return `!(${this.throwMissingModuleErrorFunction({
        request: request
      })}())`;
    }
    missingModuleStatement({request: request}) {
      return this.missingModule({
        request: request
      }) + ";\n";
    }
    missingModulePromise({request: request}) {
      return `Promise.resolve().then(${this.throwMissingModuleErrorFunction({
        request: request
      })})`;
    }
    moduleId({module: module, request: request}) {
      if (!module) return this.missingModule({
        request: request
      });
      if (null === module.id) throw new Error(`RuntimeTemplate.moduleId(): Module ${module.identifier()} has no id. This should not happen.`);
      return `${this.comment({
        request: request
      })}${JSON.stringify(module.id)}`;
    }
    moduleRaw({module: module, request: request}) {
      return module ? `__webpack_require__(${this.moduleId({
        module: module,
        request: request
      })})` : this.missingModule({
        request: request
      });
    }
    moduleExports({module: module, request: request}) {
      return this.moduleRaw({
        module: module,
        request: request
      });
    }
    moduleNamespace({module: module, request: request, strict: strict}) {
      if (!module) return this.missingModule({
        request: request
      });
      const moduleId = this.moduleId({
        module: module,
        request: request
      }), exportsType = module.buildMeta && module.buildMeta.exportsType;
      if ("namespace" === exportsType) {
        return this.moduleRaw({
          module: module,
          request: request
        });
      }
      return "named" === exportsType ? `__webpack_require__.t(${moduleId}, 3)` : strict ? `__webpack_require__.t(${moduleId}, 1)` : `__webpack_require__.t(${moduleId}, 7)`;
    }
    moduleNamespacePromise({block: block, module: module, request: request, message: message, strict: strict, weak: weak}) {
      if (!module) return this.missingModulePromise({
        request: request
      });
      if (null === module.id) throw new Error(`RuntimeTemplate.moduleNamespacePromise(): Module ${module.identifier()} has no id. This should not happen.`);
      const promise = this.blockPromise({
        block: block,
        message: message
      });
      let getModuleFunction, idExpr = JSON.stringify(module.id);
      const comment = this.comment({
        request: request
      });
      let header = "";
      weak && (idExpr.length > 8 && (header += `var id = ${idExpr}; `, idExpr = "id"), 
      header += `if(!__webpack_require__.m[${idExpr}]) { var e = new Error("Module '" + ${idExpr} + "' is not available (weak dependency)"); e.code = 'MODULE_NOT_FOUND'; throw e; } `);
      const moduleId = this.moduleId({
        module: module,
        request: request
      }), exportsType = module.buildMeta && module.buildMeta.exportsType;
      if ("namespace" === exportsType) if (header) {
        getModuleFunction = `function() { ${header}return ${this.moduleRaw({
          module: module,
          request: request
        })}; }`;
      } else getModuleFunction = `__webpack_require__.bind(null, ${comment}${idExpr})`; else getModuleFunction = "named" === exportsType ? header ? `function() { ${header}return __webpack_require__.t(${moduleId}, 3); }` : `__webpack_require__.t.bind(null, ${comment}${idExpr}, 3)` : strict ? header ? `function() { ${header}return __webpack_require__.t(${moduleId}, 1); }` : `__webpack_require__.t.bind(null, ${comment}${idExpr}, 1)` : header ? `function() { ${header}return __webpack_require__.t(${moduleId}, 7); }` : `__webpack_require__.t.bind(null, ${comment}${idExpr}, 7)`;
      return `${promise || "Promise.resolve()"}.then(${getModuleFunction})`;
    }
    importStatement({update: update, module: module, request: request, importVar: importVar, originModule: originModule}) {
      if (!module) return this.missingModuleStatement({
        request: request
      });
      const moduleId = this.moduleId({
        module: module,
        request: request
      }), optDeclaration = update ? "" : "var ", exportsType = module.buildMeta && module.buildMeta.exportsType;
      let content = `/* harmony import */ ${optDeclaration}${importVar} = __webpack_require__(${moduleId});\n`;
      return exportsType || originModule.buildMeta.strictHarmonyModule || (content += `/* harmony import */ ${optDeclaration}${importVar}_default = /*#__PURE__*/__webpack_require__.n(${importVar});\n`), 
      "named" === exportsType && (Array.isArray(module.buildMeta.providedExports) ? content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId}, 1);\n` : content += `${optDeclaration}${importVar}_namespace = /*#__PURE__*/__webpack_require__.t(${moduleId});\n`), 
      content;
    }
    exportFromImport({module: module, request: request, exportName: exportName, originModule: originModule, asiSafe: asiSafe, isCall: isCall, callContext: callContext, importVar: importVar}) {
      if (!module) return this.missingModule({
        request: request
      });
      const exportsType = module.buildMeta && module.buildMeta.exportsType;
      if (!exportsType) {
        if ("default" === exportName) return originModule.buildMeta.strictHarmonyModule ? importVar : isCall ? importVar + "_default()" : asiSafe ? `(${importVar}_default())` : importVar + "_default.a";
        if (originModule.buildMeta.strictHarmonyModule) return exportName ? "/* non-default import from non-esm module */undefined" : `/*#__PURE__*/__webpack_require__.t(${importVar})`;
      }
      if ("named" === exportsType) {
        if ("default" === exportName) return importVar;
        if (!exportName) return importVar + "_namespace";
      }
      if (exportName) {
        const used = module.isUsed(exportName);
        if (!used) {
          return Template.toNormalComment("unused export " + exportName) + " undefined";
        }
        const access = `${importVar}[${used !== exportName ? Template.toNormalComment(exportName) + " " : ""}${JSON.stringify(used)}]`;
        if (isCall) {
          if (!1 === callContext && asiSafe) return `(0,${access})`;
          if (!1 === callContext) return `Object(${access})`;
        }
        return access;
      }
      return importVar;
    }
    blockPromise({block: block, message: message}) {
      if (!block || !block.chunkGroup || 0 === block.chunkGroup.chunks.length) {
        return `Promise.resolve(${this.comment({
          message: message
        }).trim()})`;
      }
      const chunks = block.chunkGroup.chunks.filter(chunk => !chunk.hasRuntime() && null !== chunk.id), comment = this.comment({
        message: message,
        chunkName: block.chunkName,
        chunkReason: block.chunkReason
      });
      if (1 === chunks.length) {
        return `__webpack_require__.e(${comment}${JSON.stringify(chunks[0].id)})`;
      }
      if (chunks.length > 0) {
        const requireChunkId = chunk => `__webpack_require__.e(${JSON.stringify(chunk.id)})`;
        return `Promise.all(${comment.trim()}[${chunks.map(requireChunkId).join(", ")}])`;
      }
      return `Promise.resolve(${comment.trim()})`;
    }
    onError() {
      return "__webpack_require__.oe";
    }
    defineEsModuleFlagStatement({exportsArgument: exportsArgument}) {
      return `__webpack_require__.r(${exportsArgument});\n`;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(chunk, file, error) {
      super(), this.name = "ChunkRenderError", this.error = error, this.message = error.message, 
      this.details = error.stack, this.file = file, this.chunk = chunk, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const formatPosition = pos => null === pos ? "" : "string" == typeof pos ? pos : "number" == typeof pos ? "" + pos : "object" == typeof pos ? "line" in pos && "column" in pos ? `${pos.line}:${pos.column}` : "line" in pos ? pos.line + ":?" : "index" in pos ? "+" + pos.index : "" : "";
  module.exports = loc => null === loc ? "" : "string" == typeof loc ? loc : "number" == typeof loc ? "" + loc : "object" == typeof loc ? "start" in loc && loc.start && "end" in loc && loc.end ? "object" == typeof loc.start && "number" == typeof loc.start.line && "object" == typeof loc.end && "number" == typeof loc.end.line && "number" == typeof loc.end.column && loc.start.line === loc.end.line ? `${formatPosition(loc.start)}-${loc.end.column}` : `${formatPosition(loc.start)}-${formatPosition(loc.end)}` : "start" in loc && loc.start ? formatPosition(loc.start) : "name" in loc && "index" in loc ? `${loc.name}[${loc.index}]` : "name" in loc ? loc.name : formatPosition(loc) : "";
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(available) {
      this.available = available, this.waiters = [], this._continue = this._continue.bind(this);
    }
    acquire(callback) {
      this.available > 0 ? (this.available--, callback()) : this.waiters.push(callback);
    }
    release() {
      this.available++, this.waiters.length > 0 && process.nextTick(this._continue);
    }
    _continue() {
      if (this.available > 0 && this.waiters.length > 0) {
        this.available--;
        this.waiters.pop()();
      }
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), CURRENT_METHOD_REGEXP = /at ([a-zA-Z0-9_.]*)/;
  function createMessage(method) {
    return `Abstract method${method ? " " + method : ""}. Must be overridden.`;
  }
  function Message() {
    this.stack = void 0, Error.captureStackTrace(this);
    const match = this.stack.split("\n")[3].match(CURRENT_METHOD_REGEXP);
    this.message = match && match[1] ? createMessage(match[1]) : createMessage();
  }
  module.exports = class extends WebpackError {
    constructor() {
      super((new Message).message), this.name = "AbstractMethodError";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AsyncDependencyToInitialChunkError = __webpack_require__(206), GraphHelpers = __webpack_require__(27), bySetSize = (a, b) => b.size - a.size, visitModules = (compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {
    const logger = compilation.getLogger("webpack.buildChunkGraph.visitModules"), {namedChunkGroups: namedChunkGroups} = compilation;
    logger.time("prepare");
    const blockInfoMap = (compilation => {
      const blockInfoMap = new Map, iteratorDependency = d => {
        const ref = compilation.getDependencyReference(currentModule, d);
        if (!ref) return;
        const refModule = ref.module;
        refModule && (ref.weak || blockInfoModules.add(refModule));
      }, iteratorBlockPrepare = b => {
        blockInfoBlocks.push(b), blockQueue.push(b);
      };
      let currentModule, block, blockQueue, blockInfoModules, blockInfoBlocks;
      for (const module of compilation.modules) for (blockQueue = [ module ], currentModule = module; blockQueue.length > 0; ) {
        if (block = blockQueue.pop(), blockInfoModules = new Set, blockInfoBlocks = [], 
        block.variables) for (const variable of block.variables) for (const dep of variable.dependencies) iteratorDependency(dep);
        if (block.dependencies) for (const dep of block.dependencies) iteratorDependency(dep);
        if (block.blocks) for (const b of block.blocks) iteratorBlockPrepare(b);
        const blockInfo = {
          modules: blockInfoModules,
          blocks: blockInfoBlocks
        };
        blockInfoMap.set(block, blockInfo);
      }
      return blockInfoMap;
    })(compilation), chunkGroupCounters = new Map;
    for (const chunkGroup of inputChunkGroups) chunkGroupCounters.set(chunkGroup, {
      index: 0,
      index2: 0
    });
    let nextFreeModuleIndex = 0, nextFreeModuleIndex2 = 0;
    const blockChunkGroups = new Map;
    let queue = inputChunkGroups.reduce((queue, chunkGroup) => {
      for (const chunk of chunkGroup.chunks) {
        const module = chunk.entryModule;
        queue.push({
          action: 1,
          block: module,
          module: module,
          chunk: chunk,
          chunkGroup: chunkGroup
        });
      }
      return chunkGroupInfoMap.set(chunkGroup, {
        chunkGroup: chunkGroup,
        minAvailableModules: new Set,
        minAvailableModulesOwned: !0,
        availableModulesToBeMerged: [],
        skippedItems: [],
        resultingAvailableModules: void 0,
        children: void 0
      }), queue;
    }, []).reverse();
    const queueConnect = new Map, outdatedChunkGroupInfo = new Set;
    let module, chunk, chunkGroup, chunkGroupInfo, block, minAvailableModules, skippedItems, queueDelayed = [];
    logger.timeEnd("prepare");
    const iteratorBlock = b => {
      let c = blockChunkGroups.get(b);
      void 0 === c ? (c = namedChunkGroups.get(b.chunkName), c && c.isInitial() ? (compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)), 
      c = chunkGroup) : (c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request), 
      chunkGroupCounters.set(c, {
        index: 0,
        index2: 0
      }), blockChunkGroups.set(b, c), allCreatedChunkGroups.add(c)), blockConnections.set(b, [])) : (c.addOptions && c.addOptions(b.groupOptions), 
      c.addOrigin(module, b.loc, b.request)), blockConnections.get(b).push({
        originChunkGroupInfo: chunkGroupInfo,
        chunkGroup: c
      });
      let connectList = queueConnect.get(chunkGroup);
      void 0 === connectList && (connectList = new Set, queueConnect.set(chunkGroup, connectList)), 
      connectList.add(c), queueDelayed.push({
        action: 2,
        block: b,
        module: module,
        chunk: c.chunks[0],
        chunkGroup: c
      });
    };
    for (;queue.length; ) {
      for (logger.time("visiting"); queue.length; ) {
        const queueItem = queue.pop();
        switch (module = queueItem.module, block = queueItem.block, chunk = queueItem.chunk, 
        chunkGroup !== queueItem.chunkGroup && (chunkGroup = queueItem.chunkGroup, chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup), 
        minAvailableModules = chunkGroupInfo.minAvailableModules, skippedItems = chunkGroupInfo.skippedItems), 
        queueItem.action) {
         case 0:
          if (minAvailableModules.has(module)) {
            skippedItems.push(queueItem);
            break;
          }
          if (!chunk.addModule(module)) break;
          module.addChunk(chunk);

         case 1:
          if (void 0 !== chunkGroup) {
            void 0 === chunkGroup.getModuleIndex(module) && chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);
          }
          null === module.index && (module.index = nextFreeModuleIndex++), queue.push({
            action: 3,
            block: block,
            module: module,
            chunk: chunk,
            chunkGroup: chunkGroup
          });

         case 2:
          {
            const blockInfo = blockInfoMap.get(block), skipBuffer = [], queueBuffer = [];
            for (const refModule of blockInfo.modules) chunk.containsModule(refModule) || (minAvailableModules.has(refModule) ? skipBuffer.push({
              action: 0,
              block: refModule,
              module: refModule,
              chunk: chunk,
              chunkGroup: chunkGroup
            }) : queueBuffer.push({
              action: 0,
              block: refModule,
              module: refModule,
              chunk: chunk,
              chunkGroup: chunkGroup
            }));
            for (let i = skipBuffer.length - 1; i >= 0; i--) skippedItems.push(skipBuffer[i]);
            for (let i = queueBuffer.length - 1; i >= 0; i--) queue.push(queueBuffer[i]);
            for (const block of blockInfo.blocks) iteratorBlock(block);
            blockInfo.blocks.length > 0 && module !== block && blocksWithNestedBlocks.add(block);
            break;
          }

         case 3:
          if (void 0 !== chunkGroup) {
            void 0 === chunkGroup.getModuleIndex2(module) && chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);
          }
          null === module.index2 && (module.index2 = nextFreeModuleIndex2++);
        }
      }
      for (logger.timeEnd("visiting"); queueConnect.size > 0; ) {
        logger.time("calculating available modules");
        for (const [chunkGroup, targets] of queueConnect) {
          const info = chunkGroupInfoMap.get(chunkGroup);
          let minAvailableModules = info.minAvailableModules;
          const resultingAvailableModules = new Set(minAvailableModules);
          for (const chunk of chunkGroup.chunks) for (const m of chunk.modulesIterable) resultingAvailableModules.add(m);
          if (info.resultingAvailableModules = resultingAvailableModules, void 0 === info.children) info.children = targets; else for (const target of targets) info.children.add(target);
          for (const target of targets) {
            let chunkGroupInfo = chunkGroupInfoMap.get(target);
            void 0 === chunkGroupInfo && (chunkGroupInfo = {
              chunkGroup: target,
              minAvailableModules: void 0,
              minAvailableModulesOwned: void 0,
              availableModulesToBeMerged: [],
              skippedItems: [],
              resultingAvailableModules: void 0,
              children: void 0
            }, chunkGroupInfoMap.set(target, chunkGroupInfo)), chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules), 
            outdatedChunkGroupInfo.add(chunkGroupInfo);
          }
        }
        if (queueConnect.clear(), logger.timeEnd("calculating available modules"), outdatedChunkGroupInfo.size > 0) {
          logger.time("merging available modules");
          for (const info of outdatedChunkGroupInfo) {
            const availableModulesToBeMerged = info.availableModulesToBeMerged;
            let cachedMinAvailableModules = info.minAvailableModules;
            availableModulesToBeMerged.length > 1 && availableModulesToBeMerged.sort(bySetSize);
            let changed = !1;
            for (const availableModules of availableModulesToBeMerged) if (void 0 === cachedMinAvailableModules) cachedMinAvailableModules = availableModules, 
            info.minAvailableModules = cachedMinAvailableModules, info.minAvailableModulesOwned = !1, 
            changed = !0; else if (info.minAvailableModulesOwned) for (const m of cachedMinAvailableModules) availableModules.has(m) || (cachedMinAvailableModules.delete(m), 
            changed = !0); else for (const m of cachedMinAvailableModules) if (!availableModules.has(m)) {
              const newSet = new Set, iterator = cachedMinAvailableModules[Symbol.iterator]();
              let it;
              for (;!(it = iterator.next()).done; ) {
                const module = it.value;
                if (module === m) break;
                newSet.add(module);
              }
              for (;!(it = iterator.next()).done; ) {
                const module = it.value;
                availableModules.has(module) && newSet.add(module);
              }
              cachedMinAvailableModules = newSet, info.minAvailableModulesOwned = !0, info.minAvailableModules = newSet, 
              chunkGroup === info.chunkGroup && (minAvailableModules = cachedMinAvailableModules), 
              changed = !0;
              break;
            }
            if (availableModulesToBeMerged.length = 0, changed) {
              for (const queueItem of info.skippedItems) queue.push(queueItem);
              if (info.skippedItems.length = 0, void 0 !== info.children) {
                const chunkGroup = info.chunkGroup;
                for (const c of info.children) {
                  let connectList = queueConnect.get(chunkGroup);
                  void 0 === connectList && (connectList = new Set, queueConnect.set(chunkGroup, connectList)), 
                  connectList.add(c);
                }
              }
            }
          }
          outdatedChunkGroupInfo.clear(), logger.timeEnd("merging available modules");
        }
      }
      if (0 === queue.length) {
        const tempQueue = queue;
        queue = queueDelayed.reverse(), queueDelayed = tempQueue;
      }
    }
  };
  module.exports = (compilation, inputChunkGroups) => {
    const blockConnections = new Map, allCreatedChunkGroups = new Set, chunkGroupInfoMap = new Map, blocksWithNestedBlocks = new Set;
    visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups), 
    ((blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {
      const areModulesAvailable = (chunkGroup, availableModules) => {
        for (const chunk of chunkGroup.chunks) for (const module of chunk.modulesIterable) if (!availableModules.has(module)) return !1;
        return !0;
      };
      for (const [block, connections] of blockConnections) if (blocksWithNestedBlocks.has(block) || !connections.every(({chunkGroup: chunkGroup, originChunkGroupInfo: originChunkGroupInfo}) => areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules))) for (let i = 0; i < connections.length; i++) {
        const {chunkGroup: chunkGroup, originChunkGroupInfo: originChunkGroupInfo} = connections[i];
        GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup), GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);
      }
    })(blocksWithNestedBlocks, blockConnections), ((compilation, allCreatedChunkGroups) => {
      for (const chunkGroup of allCreatedChunkGroups) if (0 === chunkGroup.getNumberOfParents()) {
        for (const chunk of chunkGroup.chunks) {
          const idx = compilation.chunks.indexOf(chunk);
          idx >= 0 && compilation.chunks.splice(idx, 1), chunk.remove("unconnected");
        }
        chunkGroup.remove("unconnected");
      }
    })(compilation, allCreatedChunkGroups);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(chunkName, module, loc) {
      super(`It's not allowed to load an initial chunk on demand. The chunk name "${chunkName}" is already used by an entrypoint.`), 
      this.name = "AsyncDependencyToInitialChunkError", this.module = module, this.loc = loc, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Stats = __webpack_require__(28);
  module.exports = class {
    constructor(compiler, watchOptions, handler) {
      this.startTime = null, this.invalid = !1, this.handler = handler, this.callbacks = [], 
      this.closed = !1, this.suspended = !1, this.watchOptions = "number" == typeof watchOptions ? {
        aggregateTimeout: watchOptions
      } : watchOptions && "object" == typeof watchOptions ? Object.assign({}, watchOptions) : {}, 
      this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200, 
      this.compiler = compiler, this.running = !0, this.compiler.readRecords(err => {
        if (err) return this._done(err);
        this._go();
      });
    }
    _go() {
      this.startTime = Date.now(), this.running = !0, this.invalid = !1, this.compiler.hooks.watchRun.callAsync(this.compiler, err => {
        if (err) return this._done(err);
        const onCompiled = (err, compilation) => err ? this._done(err) : this.invalid ? this._done() : !1 === this.compiler.hooks.shouldEmit.call(compilation) ? this._done(null, compilation) : void this.compiler.emitAssets(compilation, err => err ? this._done(err) : this.invalid ? this._done() : void this.compiler.emitRecords(err => {
          if (err) return this._done(err);
          if (compilation.hooks.needAdditionalPass.call()) {
            compilation.needAdditionalPass = !0;
            const stats = new Stats(compilation);
            return stats.startTime = this.startTime, stats.endTime = Date.now(), void this.compiler.hooks.done.callAsync(stats, err => {
              if (err) return this._done(err);
              this.compiler.hooks.additionalPass.callAsync(err => {
                if (err) return this._done(err);
                this.compiler.compile(onCompiled);
              });
            });
          }
          return this._done(null, compilation);
        }));
        this.compiler.compile(onCompiled);
      });
    }
    _getStats(compilation) {
      const stats = new Stats(compilation);
      return stats.startTime = this.startTime, stats.endTime = Date.now(), stats;
    }
    _done(err, compilation) {
      if (this.running = !1, this.invalid) return this._go();
      const stats = compilation ? this._getStats(compilation) : null;
      if (err) return this.compiler.hooks.failed.call(err), void this.handler(err, stats);
      this.compiler.hooks.done.callAsync(stats, () => {
        this.handler(null, stats), this.closed || this.watch(Array.from(compilation.fileDependencies), Array.from(compilation.contextDependencies), Array.from(compilation.missingDependencies));
        for (const cb of this.callbacks) cb();
        this.callbacks.length = 0;
      });
    }
    watch(files, dirs, missing) {
      this.pausedWatcher = null, this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, (err, filesModified, contextModified, missingModified, fileTimestamps, contextTimestamps, removedFiles) => {
        if (this.pausedWatcher = this.watcher, this.watcher = null, err) return this.handler(err);
        this.compiler.fileTimestamps = fileTimestamps, this.compiler.contextTimestamps = contextTimestamps, 
        this.compiler.removedFiles = removedFiles, this.suspended || this._invalidate();
      }, (fileName, changeTime) => {
        this.compiler.hooks.invalid.call(fileName, changeTime);
      });
    }
    invalidate(callback) {
      return callback && this.callbacks.push(callback), this.watcher && (this.compiler.fileTimestamps = this.watcher.getFileTimestamps(), 
      this.compiler.contextTimestamps = this.watcher.getContextTimestamps()), this._invalidate();
    }
    _invalidate() {
      if (this.watcher && (this.pausedWatcher = this.watcher, this.watcher.pause(), this.watcher = null), 
      this.running) return this.invalid = !0, !1;
      this._go();
    }
    suspend() {
      this.suspended = !0, this.invalid = !1;
    }
    resume() {
      this.suspended && (this.suspended = !1, this._invalidate());
    }
    close(callback) {
      const finalCallback = () => {
        this.compiler.hooks.watchClose.call(), this.compiler.running = !1, this.compiler.watchMode = !1, 
        void 0 !== callback && callback();
      };
      this.closed = !0, this.watcher && (this.watcher.close(), this.watcher = null), this.pausedWatcher && (this.pausedWatcher.close(), 
      this.pausedWatcher = null), this.running ? (this.invalid = !0, this._done = finalCallback) : finalCallback();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), asyncLib = __webpack_require__(12), {Tapable: Tapable, AsyncSeriesWaterfallHook: AsyncSeriesWaterfallHook, SyncWaterfallHook: SyncWaterfallHook, SyncBailHook: SyncBailHook, SyncHook: SyncHook, HookMap: HookMap} = __webpack_require__(6), NormalModule = __webpack_require__(60), RawModule = __webpack_require__(219), RuleSet = __webpack_require__(220), {cachedCleverMerge: cachedCleverMerge} = __webpack_require__(61), EMPTY_RESOLVE_OPTIONS = {}, MATCH_RESOURCE_REGEX = /^([^!]+)!=!/, loaderToIdent = data => {
    if (!data.options) return data.loader;
    if ("string" == typeof data.options) return data.loader + "?" + data.options;
    if ("object" != typeof data.options) throw new Error("loader options must be string or object");
    return data.ident ? data.loader + "??" + data.ident : data.loader + "?" + JSON.stringify(data.options);
  }, identToLoaderRequest = resultString => {
    const idx = resultString.indexOf("?");
    if (idx >= 0) {
      return {
        loader: resultString.substr(0, idx),
        options: resultString.substr(idx + 1)
      };
    }
    return {
      loader: resultString,
      options: void 0
    };
  }, dependencyCache = new WeakMap;
  module.exports = class extends Tapable {
    constructor(context, resolverFactory, options) {
      super(), this.hooks = {
        resolver: new SyncWaterfallHook([ "resolver" ]),
        factory: new SyncWaterfallHook([ "factory" ]),
        beforeResolve: new AsyncSeriesWaterfallHook([ "data" ]),
        afterResolve: new AsyncSeriesWaterfallHook([ "data" ]),
        createModule: new SyncBailHook([ "data" ]),
        module: new SyncWaterfallHook([ "module", "data" ]),
        createParser: new HookMap(() => new SyncBailHook([ "parserOptions" ])),
        parser: new HookMap(() => new SyncHook([ "parser", "parserOptions" ])),
        createGenerator: new HookMap(() => new SyncBailHook([ "generatorOptions" ])),
        generator: new HookMap(() => new SyncHook([ "generator", "generatorOptions" ]))
      }, this._pluginCompat.tap("NormalModuleFactory", options => {
        switch (options.name) {
         case "before-resolve":
         case "after-resolve":
          options.async = !0;
          break;

         case "parser":
          return this.hooks.parser.for("javascript/auto").tap(options.fn.name || "unnamed compat plugin", options.fn), 
          !0;
        }
        let match;
        return match = /^parser (.+)$/.exec(options.name), match ? (this.hooks.parser.for(match[1]).tap(options.fn.name || "unnamed compat plugin", options.fn.bind(this)), 
        !0) : (match = /^create-parser (.+)$/.exec(options.name), match ? (this.hooks.createParser.for(match[1]).tap(options.fn.name || "unnamed compat plugin", options.fn.bind(this)), 
        !0) : void 0);
      }), this.resolverFactory = resolverFactory, this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules)), 
      this.cachePredicate = "function" == typeof options.unsafeCache ? options.unsafeCache : Boolean.bind(null, options.unsafeCache), 
      this.context = context || "", this.parserCache = Object.create(null), this.generatorCache = Object.create(null), 
      this.hooks.factory.tap("NormalModuleFactory", () => (result, callback) => {
        let resolver = this.hooks.resolver.call(null);
        if (!resolver) return callback();
        resolver(result, (err, data) => err ? callback(err) : data ? "function" == typeof data.source ? callback(null, data) : void this.hooks.afterResolve.callAsync(data, (err, result) => {
          if (err) return callback(err);
          if (!result) return callback();
          let createdModule = this.hooks.createModule.call(result);
          if (!createdModule) {
            if (!result.request) return callback(new Error("Empty dependency (no request)"));
            createdModule = new NormalModule(result);
          }
          return createdModule = this.hooks.module.call(createdModule, result), callback(null, createdModule);
        }) : callback());
      }), this.hooks.resolver.tap("NormalModuleFactory", () => (data, callback) => {
        const contextInfo = data.contextInfo, context = data.context, request = data.request, loaderResolver = this.getResolver("loader"), normalResolver = this.getResolver("normal", data.resolveOptions);
        let matchResource = void 0, requestWithoutMatchResource = request;
        const matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);
        matchResourceMatch && (matchResource = matchResourceMatch[1], /^\.\.?\//.test(matchResource) && (matchResource = path.join(context, matchResource)), 
        requestWithoutMatchResource = request.substr(matchResourceMatch[0].length));
        const noPreAutoLoaders = requestWithoutMatchResource.startsWith("-!"), noAutoLoaders = noPreAutoLoaders || requestWithoutMatchResource.startsWith("!"), noPrePostAutoLoaders = requestWithoutMatchResource.startsWith("!!");
        let elements = requestWithoutMatchResource.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!"), resource = elements.pop();
        elements = elements.map(identToLoaderRequest), asyncLib.parallel([ callback => this.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback), callback => {
          if ("" === resource || "?" === resource[0]) return callback(null, {
            resource: resource
          });
          normalResolver.resolve(contextInfo, context, resource, {}, (err, resource, resourceResolveData) => {
            if (err) return callback(err);
            callback(null, {
              resourceResolveData: resourceResolveData,
              resource: resource
            });
          });
        } ], (err, results) => {
          if (err) return callback(err);
          let loaders = results[0];
          const resourceResolveData = results[1].resourceResolveData;
          resource = results[1].resource;
          try {
            for (const item of loaders) if ("string" == typeof item.options && "?" === item.options[0]) {
              const ident = item.options.substr(1);
              item.options = this.ruleSet.findOptionsByIdent(ident), item.ident = ident;
            }
          } catch (e) {
            return callback(e);
          }
          if (!1 === resource) return callback(null, new RawModule("/* (ignored) */", `ignored ${context} ${request}`, request + " (ignored)"));
          const userRequest = (void 0 !== matchResource ? matchResource + "!=!" : "") + loaders.map(loaderToIdent).concat([ resource ]).join("!");
          let resourcePath = void 0 !== matchResource ? matchResource : resource, resourceQuery = "";
          const queryIndex = resourcePath.indexOf("?");
          queryIndex >= 0 && (resourceQuery = resourcePath.substr(queryIndex), resourcePath = resourcePath.substr(0, queryIndex));
          const result = this.ruleSet.exec({
            resource: resourcePath,
            realResource: void 0 !== matchResource ? resource.replace(/\?.*/, "") : resourcePath,
            resourceQuery: resourceQuery,
            issuer: contextInfo.issuer,
            compiler: contextInfo.compiler
          }), settings = {}, useLoadersPost = [], useLoaders = [], useLoadersPre = [];
          for (const r of result) "use" === r.type ? "post" !== r.enforce || noPrePostAutoLoaders ? "pre" !== r.enforce || noPreAutoLoaders || noPrePostAutoLoaders ? r.enforce || noAutoLoaders || noPrePostAutoLoaders || useLoaders.push(r.value) : useLoadersPre.push(r.value) : useLoadersPost.push(r.value) : "object" == typeof r.value && null !== r.value && "object" == typeof settings[r.type] && null !== settings[r.type] ? settings[r.type] = cachedCleverMerge(settings[r.type], r.value) : settings[r.type] = r.value;
          asyncLib.parallel([ this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPost, loaderResolver), this.resolveRequestArray.bind(this, contextInfo, this.context, useLoaders, loaderResolver), this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPre, loaderResolver) ], (err, results) => {
            if (err) return callback(err);
            loaders = void 0 === matchResource ? results[0].concat(loaders, results[1], results[2]) : results[0].concat(results[1], loaders, results[2]), 
            process.nextTick(() => {
              const type = settings.type, resolveOptions = settings.resolve;
              callback(null, {
                context: context,
                request: loaders.map(loaderToIdent).concat([ resource ]).join("!"),
                dependencies: data.dependencies,
                userRequest: userRequest,
                rawRequest: request,
                loaders: loaders,
                resource: resource,
                matchResource: matchResource,
                resourceResolveData: resourceResolveData,
                settings: settings,
                type: type,
                parser: this.getParser(type, settings.parser),
                generator: this.getGenerator(type, settings.generator),
                resolveOptions: resolveOptions
              });
            });
          });
        });
      });
    }
    create(data, callback) {
      const dependencies = data.dependencies, cacheEntry = dependencyCache.get(dependencies[0]);
      if (cacheEntry) return callback(null, cacheEntry);
      const context = data.context || this.context, resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS, request = dependencies[0].request, contextInfo = data.contextInfo || {};
      this.hooks.beforeResolve.callAsync({
        contextInfo: contextInfo,
        resolveOptions: resolveOptions,
        context: context,
        request: request,
        dependencies: dependencies
      }, (err, result) => {
        if (err) return callback(err);
        if (!result) return callback();
        const factory = this.hooks.factory.call(null);
        if (!factory) return callback();
        factory(result, (err, module) => {
          if (err) return callback(err);
          if (module && this.cachePredicate(module)) for (const d of dependencies) dependencyCache.set(d, module);
          callback(null, module);
        });
      });
    }
    resolveRequestArray(contextInfo, context, array, resolver, callback) {
      if (0 === array.length) return callback(null, []);
      asyncLib.map(array, (item, callback) => {
        resolver.resolve(contextInfo, context, item.loader, {}, (err, result) => {
          if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) return resolver.resolve(contextInfo, context, item.loader + "-loader", {}, err2 => {
            err2 || (err.message = err.message + "\nBREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" + `                 You need to specify '${item.loader}-loader' instead of '${item.loader}',\n                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed`), 
            callback(err);
          });
          if (err) return callback(err);
          const optionsOnly = item.options ? {
            options: item.options
          } : void 0;
          return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));
        });
      }, callback);
    }
    getParser(type, parserOptions) {
      let ident = type;
      return parserOptions && (ident = parserOptions.ident ? `${type}|${parserOptions.ident}` : JSON.stringify([ type, parserOptions ])), 
      ident in this.parserCache ? this.parserCache[ident] : this.parserCache[ident] = this.createParser(type, parserOptions);
    }
    createParser(type, parserOptions = {}) {
      const parser = this.hooks.createParser.for(type).call(parserOptions);
      if (!parser) throw new Error("No parser registered for " + type);
      return this.hooks.parser.for(type).call(parser, parserOptions), parser;
    }
    getGenerator(type, generatorOptions) {
      let ident = type;
      return generatorOptions && (ident = generatorOptions.ident ? `${type}|${generatorOptions.ident}` : JSON.stringify([ type, generatorOptions ])), 
      ident in this.generatorCache ? this.generatorCache[ident] : this.generatorCache[ident] = this.createGenerator(type, generatorOptions);
    }
    createGenerator(type, generatorOptions = {}) {
      const generator = this.hooks.createGenerator.for(type).call(generatorOptions);
      if (!generator) throw new Error("No generator registered for " + type);
      return this.hooks.generator.for(type).call(generator, generatorOptions), generator;
    }
    getResolver(type, resolveOptions) {
      return this.resolverFactory.get(type, resolveOptions || EMPTY_RESOLVE_OPTIONS);
    }
  };
}, function(module, exports, __webpack_require__) {
  var fs = __webpack_require__(20), readFile = fs.readFile.bind(fs), loadLoader = __webpack_require__(210);
  function splitQuery(req) {
    var i = req.indexOf("?");
    return i < 0 ? [ req, "" ] : [ req.substr(0, i), req.substr(i) ];
  }
  function dirname(path) {
    if ("/" === path) return "/";
    var i = path.lastIndexOf("/"), j = path.lastIndexOf("\\"), i2 = path.indexOf("/"), j2 = path.indexOf("\\"), idx = i > j ? i : j;
    return idx < 0 ? path : idx === (i > j ? i2 : j2) ? path.substr(0, idx + 1) : path.substr(0, idx);
  }
  function createLoaderObject(loader) {
    var obj = {
      path: null,
      query: null,
      options: null,
      ident: null,
      normal: null,
      pitch: null,
      raw: null,
      data: null,
      pitchExecuted: !1,
      normalExecuted: !1
    };
    return Object.defineProperty(obj, "request", {
      enumerable: !0,
      get: function() {
        return obj.path + obj.query;
      },
      set: function(value) {
        if ("string" == typeof value) {
          var splittedRequest = splitQuery(value);
          obj.path = splittedRequest[0], obj.query = splittedRequest[1], obj.options = void 0, 
          obj.ident = void 0;
        } else {
          if (!value.loader) throw new Error("request should be a string or object with loader and object (" + JSON.stringify(value) + ")");
          obj.path = value.loader, obj.options = value.options, obj.ident = value.ident, null === obj.options || void 0 === obj.options ? obj.query = "" : "string" == typeof obj.options ? obj.query = "?" + obj.options : obj.ident ? obj.query = "??" + obj.ident : "object" == typeof obj.options && obj.options.ident ? obj.query = "??" + obj.options.ident : obj.query = "?" + JSON.stringify(obj.options);
        }
      }
    }), obj.request = loader, Object.preventExtensions && Object.preventExtensions(obj), 
    obj;
  }
  function runSyncOrAsync(fn, context, args, callback) {
    var isSync = !0, isDone = !1, isError = !1, reportedError = !1;
    context.async = function() {
      if (isDone) {
        if (reportedError) return;
        throw new Error("async(): The callback was already called.");
      }
      return isSync = !1, innerCallback;
    };
    var innerCallback = context.callback = function() {
      if (isDone) {
        if (reportedError) return;
        throw new Error("callback(): The callback was already called.");
      }
      isDone = !0, isSync = !1;
      try {
        callback.apply(null, arguments);
      } catch (e) {
        throw isError = !0, e;
      }
    };
    try {
      var result = fn.apply(context, args);
      if (isSync) return isDone = !0, void 0 === result ? callback() : result && "object" == typeof result && "function" == typeof result.then ? result.then((function(r) {
        callback(null, r);
      }), callback) : callback(null, result);
    } catch (e) {
      if (isError) throw e;
      if (isDone) return void ("object" == typeof e && e.stack ? console.error(e.stack) : console.error(e));
      isDone = !0, reportedError = !0, callback(e);
    }
  }
  function iteratePitchingLoaders(options, loaderContext, callback) {
    if (loaderContext.loaderIndex >= loaderContext.loaders.length) return function(options, loaderContext, callback) {
      loaderContext.loaderIndex = loaderContext.loaders.length - 1;
      var resourcePath = loaderContext.resourcePath;
      resourcePath ? (loaderContext.addDependency(resourcePath), options.readResource(resourcePath, (function(err, buffer) {
        if (err) return callback(err);
        options.resourceBuffer = buffer, iterateNormalLoaders(options, loaderContext, [ buffer ], callback);
      }))) : iterateNormalLoaders(options, loaderContext, [ null ], callback);
    }(options, loaderContext, callback);
    var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
    if (currentLoaderObject.pitchExecuted) return loaderContext.loaderIndex++, iteratePitchingLoaders(options, loaderContext, callback);
    loadLoader(currentLoaderObject, (function(err) {
      if (err) return loaderContext.cacheable(!1), callback(err);
      var fn = currentLoaderObject.pitch;
      if (currentLoaderObject.pitchExecuted = !0, !fn) return iteratePitchingLoaders(options, loaderContext, callback);
      runSyncOrAsync(fn, loaderContext, [ loaderContext.remainingRequest, loaderContext.previousRequest, currentLoaderObject.data = {} ], (function(err) {
        if (err) return callback(err);
        var args = Array.prototype.slice.call(arguments, 1);
        args.length > 0 ? (loaderContext.loaderIndex--, iterateNormalLoaders(options, loaderContext, args, callback)) : iteratePitchingLoaders(options, loaderContext, callback);
      }));
    }));
  }
  function iterateNormalLoaders(options, loaderContext, args, callback) {
    if (loaderContext.loaderIndex < 0) return callback(null, args);
    var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];
    if (currentLoaderObject.normalExecuted) return loaderContext.loaderIndex--, iterateNormalLoaders(options, loaderContext, args, callback);
    var fn = currentLoaderObject.normal;
    if (currentLoaderObject.normalExecuted = !0, !fn) return iterateNormalLoaders(options, loaderContext, args, callback);
    !function(args, raw) {
      var buf, str;
      !raw && Buffer.isBuffer(args[0]) ? args[0] = (buf = args[0], 65279 === (str = buf.toString("utf-8")).charCodeAt(0) ? str.substr(1) : str) : raw && "string" == typeof args[0] && (args[0] = new Buffer(args[0], "utf-8"));
    }(args, currentLoaderObject.raw), runSyncOrAsync(fn, loaderContext, args, (function(err) {
      if (err) return callback(err);
      var args = Array.prototype.slice.call(arguments, 1);
      iterateNormalLoaders(options, loaderContext, args, callback);
    }));
  }
  exports.getContext = function(resource) {
    return dirname(splitQuery(resource)[0]);
  }, exports.runLoaders = function(options, callback) {
    var resource = options.resource || "", loaders = options.loaders || [], loaderContext = options.context || {}, readResource = options.readResource || readFile, splittedResource = resource && splitQuery(resource), resourcePath = splittedResource ? splittedResource[0] : void 0, resourceQuery = splittedResource ? splittedResource[1] : void 0, contextDirectory = resourcePath ? dirname(resourcePath) : null, requestCacheable = !0, fileDependencies = [], contextDependencies = [];
    loaders = loaders.map(createLoaderObject), loaderContext.context = contextDirectory, 
    loaderContext.loaderIndex = 0, loaderContext.loaders = loaders, loaderContext.resourcePath = resourcePath, 
    loaderContext.resourceQuery = resourceQuery, loaderContext.async = null, loaderContext.callback = null, 
    loaderContext.cacheable = function(flag) {
      !1 === flag && (requestCacheable = !1);
    }, loaderContext.dependency = loaderContext.addDependency = function(file) {
      fileDependencies.push(file);
    }, loaderContext.addContextDependency = function(context) {
      contextDependencies.push(context);
    }, loaderContext.getDependencies = function() {
      return fileDependencies.slice();
    }, loaderContext.getContextDependencies = function() {
      return contextDependencies.slice();
    }, loaderContext.clearDependencies = function() {
      fileDependencies.length = 0, contextDependencies.length = 0, requestCacheable = !0;
    }, Object.defineProperty(loaderContext, "resource", {
      enumerable: !0,
      get: function() {
        if (void 0 !== loaderContext.resourcePath) return loaderContext.resourcePath + loaderContext.resourceQuery;
      },
      set: function(value) {
        var splittedResource = value && splitQuery(value);
        loaderContext.resourcePath = splittedResource ? splittedResource[0] : void 0, loaderContext.resourceQuery = splittedResource ? splittedResource[1] : void 0;
      }
    }), Object.defineProperty(loaderContext, "request", {
      enumerable: !0,
      get: function() {
        return loaderContext.loaders.map((function(o) {
          return o.request;
        })).concat(loaderContext.resource || "").join("!");
      }
    }), Object.defineProperty(loaderContext, "remainingRequest", {
      enumerable: !0,
      get: function() {
        return loaderContext.loaderIndex >= loaderContext.loaders.length - 1 && !loaderContext.resource ? "" : loaderContext.loaders.slice(loaderContext.loaderIndex + 1).map((function(o) {
          return o.request;
        })).concat(loaderContext.resource || "").join("!");
      }
    }), Object.defineProperty(loaderContext, "currentRequest", {
      enumerable: !0,
      get: function() {
        return loaderContext.loaders.slice(loaderContext.loaderIndex).map((function(o) {
          return o.request;
        })).concat(loaderContext.resource || "").join("!");
      }
    }), Object.defineProperty(loaderContext, "previousRequest", {
      enumerable: !0,
      get: function() {
        return loaderContext.loaders.slice(0, loaderContext.loaderIndex).map((function(o) {
          return o.request;
        })).join("!");
      }
    }), Object.defineProperty(loaderContext, "query", {
      enumerable: !0,
      get: function() {
        var entry = loaderContext.loaders[loaderContext.loaderIndex];
        return entry.options && "object" == typeof entry.options ? entry.options : entry.query;
      }
    }), Object.defineProperty(loaderContext, "data", {
      enumerable: !0,
      get: function() {
        return loaderContext.loaders[loaderContext.loaderIndex].data;
      }
    }), Object.preventExtensions && Object.preventExtensions(loaderContext);
    var processOptions = {
      resourceBuffer: null,
      readResource: readResource
    };
    iteratePitchingLoaders(processOptions, loaderContext, (function(err, result) {
      if (err) return callback(err, {
        cacheable: requestCacheable,
        fileDependencies: fileDependencies,
        contextDependencies: contextDependencies
      });
      callback(null, {
        result: result,
        resourceBuffer: processOptions.resourceBuffer,
        cacheable: requestCacheable,
        fileDependencies: fileDependencies,
        contextDependencies: contextDependencies
      });
    }));
  };
}, function(module, exports, __webpack_require__) {
  var LoaderLoadingError = __webpack_require__(211);
  module.exports = function loadLoader(loader, callback) {
    try {
      var module = __webpack_require__(212)(loader.path);
    } catch (e) {
      if (e instanceof Error && "EMFILE" === e.code) {
        var retry = loadLoader.bind(null, loader, callback);
        return "function" == typeof setImmediate ? setImmediate(retry) : process.nextTick(retry);
      }
      return callback(e);
    }
    return "function" != typeof module && "object" != typeof module ? callback(new LoaderLoadingError("Module '" + loader.path + "' is not a loader (export function or es6 module)")) : (loader.normal = "function" == typeof module ? module : module.default, 
    loader.pitch = module.pitch, loader.raw = module.raw, "function" != typeof loader.normal && "function" != typeof loader.pitch ? callback(new LoaderLoadingError("Module '" + loader.path + "' is not a loader (must have normal or pitch function)")) : void callback());
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  class LoadingLoaderError extends Error {
    constructor(message) {
      super(message), this.name = "LoaderRunnerError", Error.captureStackTrace(this, this.constructor);
    }
  }
  module.exports = LoadingLoaderError;
}, function(module, exports) {
  module.exports = require;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {RawSource: RawSource, ReplaceSource: ReplaceSource} = __webpack_require__(0);
  module.exports = class {
    constructor(name, expression, dependencies) {
      this.name = name, this.expression = expression, this.dependencies = dependencies || [];
    }
    updateHash(hash) {
      hash.update(this.name), hash.update(this.expression);
      for (const d of this.dependencies) d.updateHash(hash);
    }
    expressionSource(dependencyTemplates, runtimeTemplate) {
      const source = new ReplaceSource(new RawSource(this.expression));
      for (const dep of this.dependencies) {
        const template = dependencyTemplates.get(dep.constructor);
        if (!template) throw new Error("No template for dependency: " + dep.constructor.name);
        template.apply(dep, source, runtimeTemplate, dependencyTemplates);
      }
      return source;
    }
    disconnect() {
      for (const d of this.dependencies) d.disconnect();
    }
    hasDependencies(filter) {
      return filter ? this.dependencies.some(filter) : this.dependencies.length > 0;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(module, dependency, explanation) {
      this.module = module, this.dependency = dependency, this.explanation = explanation, 
      this._chunks = null;
    }
    hasChunk(chunk) {
      if (this._chunks) {
        if (this._chunks.has(chunk)) return !0;
      } else if (this.module && this.module._chunks.has(chunk)) return !0;
      return !1;
    }
    rewriteChunks(oldChunk, newChunks) {
      if (!this._chunks) if (this.module) {
        if (!this.module._chunks.has(oldChunk)) return;
        this._chunks = new Set(this.module._chunks);
      } else this._chunks = new Set;
      if (this._chunks.has(oldChunk)) {
        this._chunks.delete(oldChunk);
        for (let i = 0; i < newChunks.length; i++) this._chunks.add(newChunks[i]);
      }
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(module, source, err, loaders) {
      let message = "Module parse failed: " + err.message, loc = void 0;
      if (loaders.length >= 1 ? (message += "\nFile was processed with these loaders:" + loaders.map(loader => "\n * " + loader).join(""), 
      message += "\nYou may need an additional loader to handle the result of these loaders.") : message += "\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders", 
      err.loc && "object" == typeof err.loc && "number" == typeof err.loc.line) {
        var lineNumber = err.loc.line;
        if (/[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(source)) message += "\n(Source code omitted for this binary file)"; else {
          const sourceLines = source.split(/\r?\n/), start = Math.max(0, lineNumber - 3), linesBefore = sourceLines.slice(start, lineNumber - 1), theLine = sourceLines[lineNumber - 1], linesAfter = sourceLines.slice(lineNumber, lineNumber + 2);
          message += linesBefore.map(l => "\n| " + l).join("") + "\n> " + theLine + linesAfter.map(l => "\n| " + l).join("");
        }
        loc = err.loc;
      } else message += "\n" + err.stack;
      super(message), this.name = "ModuleParseError", this.module = module, this.loc = loc, 
      this.error = err, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), {cutOffLoaderExecution: cutOffLoaderExecution} = __webpack_require__(40);
  module.exports = class extends WebpackError {
    constructor(module, err, {from: from = null} = {}) {
      let message = "Module build failed", details = void 0;
      if (message += from ? ` (from ${from}):\n` : ": ", null !== err && "object" == typeof err) if ("string" == typeof err.stack && err.stack) {
        const stack = cutOffLoaderExecution(err.stack);
        err.hideStack ? (details = stack, "string" == typeof err.message && err.message ? message += err.message : message += err) : message += stack;
      } else "string" == typeof err.message && err.message ? message += err.message : message += err; else message = err;
      super(message), this.name = "ModuleBuildError", this.details = details, this.module = module, 
      this.error = err, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), {cleanUp: cleanUp} = __webpack_require__(40);
  module.exports = class extends WebpackError {
    constructor(module, err, {from: from = null} = {}) {
      let message = "Module Error";
      message += from ? ` (from ${from}):\n` : ": ", err && "object" == typeof err && err.message ? message += err.message : err && (message += err), 
      super(message), this.name = "ModuleError", this.module = module, this.error = err, 
      this.details = err && "object" == typeof err && err.stack ? cleanUp(err.stack, this.message) : void 0, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), {cleanUp: cleanUp} = __webpack_require__(40);
  module.exports = class extends WebpackError {
    constructor(module, warning, {from: from = null} = {}) {
      let message = "Module Warning";
      message += from ? ` (from ${from}):\n` : ": ", warning && "object" == typeof warning && warning.message ? message += warning.message : warning && (message += warning), 
      super(message), this.name = "ModuleWarning", this.module = module, this.warning = warning, 
      this.details = warning && "object" == typeof warning && warning.stack ? cleanUp(warning.stack, this.message) : void 0, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Module = __webpack_require__(18), {OriginalSource: OriginalSource, RawSource: RawSource} = __webpack_require__(0);
  module.exports = class extends Module {
    constructor(source, identifier, readableIdentifier) {
      super("javascript/dynamic", null), this.sourceStr = source, this.identifierStr = identifier || this.sourceStr, 
      this.readableIdentifierStr = readableIdentifier || this.identifierStr, this.built = !1;
    }
    identifier() {
      return this.identifierStr;
    }
    size() {
      return this.sourceStr.length;
    }
    readableIdentifier(requestShortener) {
      return requestShortener.shorten(this.readableIdentifierStr);
    }
    needRebuild() {
      return !1;
    }
    build(options, compilations, resolver, fs, callback) {
      this.built = !0, this.buildMeta = {}, this.buildInfo = {
        cacheable: !0
      }, callback();
    }
    source() {
      return this.useSourceMap ? new OriginalSource(this.sourceStr, this.identifier()) : new RawSource(this.sourceStr);
    }
    updateHash(hash) {
      hash.update(this.sourceStr), super.updateHash(hash);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const andMatcher = items => str => {
    for (let i = 0; i < items.length; i++) if (!items[i](str)) return !1;
    return !0;
  };
  module.exports = class RuleSet {
    constructor(rules) {
      this.references = Object.create(null), this.rules = RuleSet.normalizeRules(rules, this.references, "ref-");
    }
    static normalizeRules(rules, refs, ident) {
      return Array.isArray(rules) ? rules.map((rule, idx) => RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`)) : rules ? [ RuleSet.normalizeRule(rules, refs, ident) ] : [];
    }
    static normalizeRule(rule, refs, ident) {
      if ("string" == typeof rule) return {
        use: [ {
          loader: rule
        } ]
      };
      if (!rule) throw new Error("Unexcepted null when object was expected as rule");
      if ("object" != typeof rule) throw new Error("Unexcepted " + typeof rule + " when object was expected as rule (" + rule + ")");
      const newRule = {};
      let useSource, resourceSource, condition;
      const checkUseSource = newSource => {
        if (useSource && useSource !== newSource) throw new Error(RuleSet.buildErrorMessage(rule, new Error("Rule can only have one result source (provided " + newSource + " and " + useSource + ")")));
        useSource = newSource;
      }, checkResourceSource = newSource => {
        if (resourceSource && resourceSource !== newSource) throw new Error(RuleSet.buildErrorMessage(rule, new Error("Rule can only have one resource source (provided " + newSource + " and " + resourceSource + ")")));
        resourceSource = newSource;
      };
      if (rule.test || rule.include || rule.exclude) {
        checkResourceSource("test + include + exclude"), condition = {
          test: rule.test,
          include: rule.include,
          exclude: rule.exclude
        };
        try {
          newRule.resource = RuleSet.normalizeCondition(condition);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(condition, error));
        }
      }
      if (rule.resource) {
        checkResourceSource("resource");
        try {
          newRule.resource = RuleSet.normalizeCondition(rule.resource);
        } catch (error) {
          throw new Error(RuleSet.buildErrorMessage(rule.resource, error));
        }
      }
      if (rule.realResource) try {
        newRule.realResource = RuleSet.normalizeCondition(rule.realResource);
      } catch (error) {
        throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));
      }
      if (rule.resourceQuery) try {
        newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);
      } catch (error) {
        throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));
      }
      if (rule.compiler) try {
        newRule.compiler = RuleSet.normalizeCondition(rule.compiler);
      } catch (error) {
        throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));
      }
      if (rule.issuer) try {
        newRule.issuer = RuleSet.normalizeCondition(rule.issuer);
      } catch (error) {
        throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));
      }
      if (rule.loader && rule.loaders) throw new Error(RuleSet.buildErrorMessage(rule, new Error("Provided loader and loaders for rule (use only one of them)")));
      const loader = rule.loaders || rule.loader;
      if ("string" != typeof loader || rule.options || rule.query) if ("string" == typeof loader && (rule.options || rule.query)) checkUseSource("loader + options/query"), 
      newRule.use = RuleSet.normalizeUse({
        loader: loader,
        options: rule.options,
        query: rule.query
      }, ident); else {
        if (loader && (rule.options || rule.query)) throw new Error(RuleSet.buildErrorMessage(rule, new Error("options/query cannot be used with loaders (use options for each array item)")));
        if (loader) checkUseSource("loaders"), newRule.use = RuleSet.normalizeUse(loader, ident); else if (rule.options || rule.query) throw new Error(RuleSet.buildErrorMessage(rule, new Error("options/query provided without loader (use loader + options)")));
      } else checkUseSource("loader"), newRule.use = RuleSet.normalizeUse(loader.split("!"), ident);
      rule.use && (checkUseSource("use"), newRule.use = RuleSet.normalizeUse(rule.use, ident)), 
      rule.rules && (newRule.rules = RuleSet.normalizeRules(rule.rules, refs, ident + "-rules")), 
      rule.oneOf && (newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, ident + "-oneOf"));
      const keys = Object.keys(rule).filter(key => ![ "resource", "resourceQuery", "compiler", "test", "include", "exclude", "issuer", "loader", "options", "query", "loaders", "use", "rules", "oneOf" ].includes(key));
      for (const key of keys) newRule[key] = rule[key];
      if (Array.isArray(newRule.use)) for (const item of newRule.use) item.ident && (refs[item.ident] = item.options);
      return newRule;
    }
    static buildErrorMessage(condition, error) {
      const conditionAsText = JSON.stringify(condition, (key, value) => void 0 === value ? "undefined" : value, 2);
      return error.message + " in " + conditionAsText;
    }
    static normalizeUse(use, ident) {
      return "function" == typeof use ? data => RuleSet.normalizeUse(use(data), ident) : Array.isArray(use) ? use.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`)).reduce((arr, items) => arr.concat(items), []) : [ RuleSet.normalizeUseItem(use, ident) ];
    }
    static normalizeUseItemString(useItemString) {
      const idx = useItemString.indexOf("?");
      return idx >= 0 ? {
        loader: useItemString.substr(0, idx),
        options: useItemString.substr(idx + 1)
      } : {
        loader: useItemString,
        options: void 0
      };
    }
    static normalizeUseItem(item, ident) {
      if ("string" == typeof item) return RuleSet.normalizeUseItemString(item);
      const newItem = {};
      if (item.options && item.query) throw new Error("Provided options and query in use");
      if (!item.loader) throw new Error("No loader specified");
      newItem.options = item.options || item.query, "object" == typeof newItem.options && newItem.options && (newItem.options.ident ? newItem.ident = newItem.options.ident : newItem.ident = ident);
      const keys = Object.keys(item).filter((function(key) {
        return ![ "options", "query" ].includes(key);
      }));
      for (const key of keys) newItem[key] = item[key];
      return newItem;
    }
    static normalizeCondition(condition) {
      if (!condition) throw new Error("Expected condition but got falsy value");
      if ("string" == typeof condition) return str => 0 === str.indexOf(condition);
      if ("function" == typeof condition) return condition;
      if (condition instanceof RegExp) return condition.test.bind(condition);
      if (Array.isArray(condition)) {
        return (items => str => {
          for (let i = 0; i < items.length; i++) if (items[i](str)) return !0;
          return !1;
        })(condition.map(c => RuleSet.normalizeCondition(c)));
      }
      if ("object" != typeof condition) throw Error("Unexcepted " + typeof condition + " when condition was expected (" + condition + ")");
      const matchers = [];
      if (Object.keys(condition).forEach(key => {
        const value = condition[key];
        switch (key) {
         case "or":
         case "include":
         case "test":
          value && matchers.push(RuleSet.normalizeCondition(value));
          break;

         case "and":
          if (value) {
            const items = value.map(c => RuleSet.normalizeCondition(c));
            matchers.push(andMatcher(items));
          }
          break;

         case "not":
         case "exclude":
          if (value) {
            const matcher = RuleSet.normalizeCondition(value);
            matchers.push((matcher => str => !matcher(str))(matcher));
          }
          break;

         default:
          throw new Error("Unexcepted property " + key + " in condition");
        }
      }), 0 === matchers.length) throw new Error("Excepted condition but got " + condition);
      return 1 === matchers.length ? matchers[0] : andMatcher(matchers);
    }
    exec(data) {
      const result = [];
      return this._run(data, {
        rules: this.rules
      }, result), result;
    }
    _run(data, rule, result) {
      if (rule.resource && !data.resource) return !1;
      if (rule.realResource && !data.realResource) return !1;
      if (rule.resourceQuery && !data.resourceQuery) return !1;
      if (rule.compiler && !data.compiler) return !1;
      if (rule.issuer && !data.issuer) return !1;
      if (rule.resource && !rule.resource(data.resource)) return !1;
      if (rule.realResource && !rule.realResource(data.realResource)) return !1;
      if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return !1;
      if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) return !1;
      if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) return !1;
      const keys = Object.keys(rule).filter(key => ![ "resource", "realResource", "resourceQuery", "compiler", "issuer", "rules", "oneOf", "use", "enforce" ].includes(key));
      for (const key of keys) result.push({
        type: key,
        value: rule[key]
      });
      if (rule.use) {
        const process = use => {
          "function" == typeof use ? process(use(data)) : Array.isArray(use) ? use.forEach(process) : result.push({
            type: "use",
            value: use,
            enforce: rule.enforce
          });
        };
        process(rule.use);
      }
      if (rule.rules) for (let i = 0; i < rule.rules.length; i++) this._run(data, rule.rules[i], result);
      if (rule.oneOf) for (let i = 0; i < rule.oneOf.length && !this._run(data, rule.oneOf[i], result); i++) ;
      return !0;
    }
    findOptionsByIdent(ident) {
      const options = this.references[ident];
      if (!options) throw new Error("Can't find options with ident '" + ident + "'");
      return options;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const asyncLib = __webpack_require__(12), path = __webpack_require__(3), {Tapable: Tapable, AsyncSeriesWaterfallHook: AsyncSeriesWaterfallHook, SyncWaterfallHook: SyncWaterfallHook} = __webpack_require__(6), ContextModule = __webpack_require__(222), ContextElementDependency = __webpack_require__(62), EMPTY_RESOLVE_OPTIONS = {};
  module.exports = class extends Tapable {
    constructor(resolverFactory) {
      super(), this.hooks = {
        beforeResolve: new AsyncSeriesWaterfallHook([ "data" ]),
        afterResolve: new AsyncSeriesWaterfallHook([ "data" ]),
        contextModuleFiles: new SyncWaterfallHook([ "files" ]),
        alternatives: new AsyncSeriesWaterfallHook([ "modules" ])
      }, this._pluginCompat.tap("ContextModuleFactory", options => {
        switch (options.name) {
         case "before-resolve":
         case "after-resolve":
         case "alternatives":
          options.async = !0;
        }
      }), this.resolverFactory = resolverFactory;
    }
    create(data, callback) {
      const context = data.context, dependencies = data.dependencies, resolveOptions = data.resolveOptions, dependency = dependencies[0];
      this.hooks.beforeResolve.callAsync(Object.assign({
        context: context,
        dependencies: dependencies,
        resolveOptions: resolveOptions
      }, dependency.options), (err, beforeResolveResult) => {
        if (err) return callback(err);
        if (!beforeResolveResult) return callback();
        const context = beforeResolveResult.context, request = beforeResolveResult.request, resolveOptions = beforeResolveResult.resolveOptions;
        let loaders, resource, loadersPrefix = "";
        const idx = request.lastIndexOf("!");
        if (idx >= 0) {
          let i, loadersRequest = request.substr(0, idx + 1);
          for (i = 0; i < loadersRequest.length && "!" === loadersRequest[i]; i++) loadersPrefix += "!";
          loadersRequest = loadersRequest.substr(i).replace(/!+$/, "").replace(/!!+/g, "!"), 
          loaders = "" === loadersRequest ? [] : loadersRequest.split("!"), resource = request.substr(idx + 1);
        } else loaders = [], resource = request;
        const contextResolver = this.resolverFactory.get("context", resolveOptions || EMPTY_RESOLVE_OPTIONS), loaderResolver = this.resolverFactory.get("loader", EMPTY_RESOLVE_OPTIONS);
        asyncLib.parallel([ callback => {
          contextResolver.resolve({}, context, resource, {}, (err, result) => {
            if (err) return callback(err);
            callback(null, result);
          });
        }, callback => {
          asyncLib.map(loaders, (loader, callback) => {
            loaderResolver.resolve({}, context, loader, {}, (err, result) => {
              if (err) return callback(err);
              callback(null, result);
            });
          }, callback);
        } ], (err, result) => {
          if (err) return callback(err);
          this.hooks.afterResolve.callAsync(Object.assign({
            addon: loadersPrefix + result[1].join("!") + (result[1].length > 0 ? "!" : ""),
            resource: result[0],
            resolveDependencies: this.resolveDependencies.bind(this)
          }, beforeResolveResult), (err, result) => err ? callback(err) : result ? callback(null, new ContextModule(result.resolveDependencies, result)) : callback());
        });
      });
    }
    resolveDependencies(fs, options, callback) {
      const cmf = this;
      let resource = options.resource, resourceQuery = options.resourceQuery, recursive = options.recursive, regExp = options.regExp, include = options.include, exclude = options.exclude;
      if (!regExp || !resource) return callback(null, []);
      const addDirectory = (directory, callback) => {
        fs.readdir(directory, (err, files) => err ? callback(err) : (files = cmf.hooks.contextModuleFiles.call(files)) && 0 !== files.length ? void asyncLib.map(files.filter(p => 0 !== p.indexOf(".")), (segment, callback) => {
          const subResource = path.join(directory, segment);
          exclude && subResource.match(exclude) ? callback() : fs.stat(subResource, (err, stat) => {
            if (err) return "ENOENT" === err.code ? callback() : callback(err);
            if (stat.isDirectory()) {
              if (!recursive) return callback();
              addDirectory.call(this, subResource, callback);
            } else if (!stat.isFile() || include && !subResource.match(include)) callback(); else {
              const obj = {
                context: resource,
                request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
              };
              this.hooks.alternatives.callAsync([ obj ], (err, alternatives) => {
                if (err) return callback(err);
                alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {
                  const dep = new ContextElementDependency(obj.request + resourceQuery, obj.request);
                  return dep.optional = !0, dep;
                }), callback(null, alternatives);
              });
            }
          });
        }, (err, result) => err ? callback(err) : result ? void callback(null, result.filter(Boolean).reduce((a, i) => a.concat(i), [])) : callback(null, [])) : callback(null, []));
      };
      addDirectory(resource, callback);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), {OriginalSource: OriginalSource, RawSource: RawSource} = __webpack_require__(0), Module = __webpack_require__(18), AsyncDependenciesBlock = __webpack_require__(41), Template = __webpack_require__(2), contextify = __webpack_require__(14).contextify;
  class ContextModule extends Module {
    constructor(resolveDependencies, options) {
      let resource, resourceQuery;
      const queryIdx = options.resource.indexOf("?");
      if (queryIdx >= 0 ? (resource = options.resource.substr(0, queryIdx), resourceQuery = options.resource.substr(queryIdx)) : (resource = options.resource, 
      resourceQuery = ""), super("javascript/dynamic", resource), this.resolveDependencies = resolveDependencies, 
      this.options = Object.assign({}, options, {
        resource: resource,
        resourceQuery: resourceQuery
      }), void 0 !== options.resolveOptions && (this.resolveOptions = options.resolveOptions), 
      this._contextDependencies = new Set([ this.context ]), "string" != typeof options.mode) throw new Error("options.mode is a required option");
      this._identifier = this._createIdentifier();
    }
    updateCacheModule(module) {
      this.resolveDependencies = module.resolveDependencies, this.options = module.options, 
      this.resolveOptions = module.resolveOptions;
    }
    prettyRegExp(regexString) {
      return regexString.substring(1, regexString.length - 1);
    }
    _createIdentifier() {
      let identifier = this.context;
      return this.options.resourceQuery && (identifier += " " + this.options.resourceQuery), 
      this.options.mode && (identifier += " " + this.options.mode), this.options.recursive || (identifier += " nonrecursive"), 
      this.options.addon && (identifier += " " + this.options.addon), this.options.regExp && (identifier += " " + this.options.regExp), 
      this.options.include && (identifier += " include: " + this.options.include), this.options.exclude && (identifier += " exclude: " + this.options.exclude), 
      this.options.groupOptions && (identifier += " groupOptions: " + JSON.stringify(this.options.groupOptions)), 
      "strict" === this.options.namespaceObject ? identifier += " strict namespace object" : this.options.namespaceObject && (identifier += " namespace object"), 
      identifier;
    }
    identifier() {
      return this._identifier;
    }
    readableIdentifier(requestShortener) {
      let identifier = requestShortener.shorten(this.context);
      if (this.options.resourceQuery && (identifier += " " + this.options.resourceQuery), 
      this.options.mode && (identifier += " " + this.options.mode), this.options.recursive || (identifier += " nonrecursive"), 
      this.options.addon && (identifier += " " + requestShortener.shorten(this.options.addon)), 
      this.options.regExp && (identifier += " " + this.prettyRegExp(this.options.regExp + "")), 
      this.options.include && (identifier += " include: " + this.prettyRegExp(this.options.include + "")), 
      this.options.exclude && (identifier += " exclude: " + this.prettyRegExp(this.options.exclude + "")), 
      this.options.groupOptions) {
        const groupOptions = this.options.groupOptions;
        for (const key of Object.keys(groupOptions)) identifier += ` ${key}: ${groupOptions[key]}`;
      }
      return "strict" === this.options.namespaceObject ? identifier += " strict namespace object" : this.options.namespaceObject && (identifier += " namespace object"), 
      identifier;
    }
    libIdent(options) {
      let identifier = contextify(options.context, this.context);
      return this.options.mode && (identifier += " " + this.options.mode), this.options.recursive && (identifier += " recursive"), 
      this.options.addon && (identifier += " " + contextify(options.context, this.options.addon)), 
      this.options.regExp && (identifier += " " + this.prettyRegExp(this.options.regExp + "")), 
      this.options.include && (identifier += " include: " + this.prettyRegExp(this.options.include + "")), 
      this.options.exclude && (identifier += " exclude: " + this.prettyRegExp(this.options.exclude + "")), 
      identifier;
    }
    needRebuild(fileTimestamps, contextTimestamps) {
      const ts = contextTimestamps.get(this.context);
      return !ts || ts >= this.buildInfo.builtTime;
    }
    build(options, compilation, resolver, fs, callback) {
      this.built = !0, this.buildMeta = {}, this.buildInfo = {
        builtTime: Date.now(),
        contextDependencies: this._contextDependencies
      }, this.resolveDependencies(fs, this.options, (err, dependencies) => {
        if (err) return callback(err);
        if (dependencies) {
          for (const dep of dependencies) dep.loc = {
            name: dep.userRequest
          }, dep.request = this.options.addon + dep.request;
          if ("sync" === this.options.mode || "eager" === this.options.mode) this.dependencies = dependencies; else if ("lazy-once" === this.options.mode) {
            if (dependencies.length > 0) {
              const block = new AsyncDependenciesBlock(Object.assign({}, this.options.groupOptions, {
                name: this.options.chunkName
              }), this);
              for (const dep of dependencies) block.addDependency(dep);
              this.addBlock(block);
            }
          } else if ("weak" === this.options.mode || "async-weak" === this.options.mode) {
            for (const dep of dependencies) dep.weak = !0;
            this.dependencies = dependencies;
          } else {
            if ("lazy" !== this.options.mode) return void callback(new Error(`Unsupported mode "${this.options.mode}" in context`));
            {
              let index = 0;
              for (const dep of dependencies) {
                let chunkName = this.options.chunkName;
                chunkName && (/\[(index|request)\]/.test(chunkName) || (chunkName += "[index]"), 
                chunkName = chunkName.replace(/\[index\]/g, index++), chunkName = chunkName.replace(/\[request\]/g, Template.toPath(dep.userRequest)));
                const block = new AsyncDependenciesBlock(Object.assign({}, this.options.groupOptions, {
                  name: chunkName
                }), dep.module, dep.loc, dep.userRequest);
                block.addDependency(dep), this.addBlock(block);
              }
            }
          }
          callback();
        } else callback();
      });
    }
    getUserRequestMap(dependencies) {
      return dependencies.filter(dependency => dependency.module).sort((a, b) => a.userRequest === b.userRequest ? 0 : a.userRequest < b.userRequest ? -1 : 1).reduce((map, dep) => (map[dep.userRequest] = dep.module.id, 
      map), Object.create(null));
    }
    getFakeMap(dependencies) {
      if (!this.options.namespaceObject) return 9;
      let hasNonHarmony = !1, hasNamespace = !1, hasNamed = !1;
      const fakeMap = dependencies.filter(dependency => dependency.module).sort((a, b) => b.module.id - a.module.id).reduce((map, dep) => {
        const exportsType = dep.module.buildMeta && dep.module.buildMeta.exportsType, id = dep.module.id;
        return exportsType ? "namespace" === exportsType ? (map[id] = 9, hasNamespace = !0) : "named" === exportsType && (map[id] = 3, 
        hasNamed = !0) : (map[id] = "strict" === this.options.namespaceObject ? 1 : 7, hasNonHarmony = !0), 
        map;
      }, Object.create(null));
      return hasNamespace || !hasNonHarmony || hasNamed ? !hasNamespace || hasNonHarmony || hasNamed ? hasNamespace || hasNonHarmony || !hasNamed ? hasNamespace || hasNonHarmony || hasNamed ? fakeMap : 9 : 3 : 9 : "strict" === this.options.namespaceObject ? 1 : 7;
    }
    getFakeMapInitStatement(fakeMap) {
      return "object" == typeof fakeMap ? `var fakeMap = ${JSON.stringify(fakeMap, null, "\t")};` : "";
    }
    getReturn(type) {
      return 9 === type ? "__webpack_require__(id)" : `__webpack_require__.t(id, ${type})`;
    }
    getReturnModuleObjectSource(fakeMap, fakeMapDataExpression = "fakeMap[id]") {
      return "number" == typeof fakeMap ? `return ${this.getReturn(fakeMap)};` : `return __webpack_require__.t(id, ${fakeMapDataExpression})`;
    }
    getSyncSource(dependencies, id) {
      const map = this.getUserRequestMap(dependencies), fakeMap = this.getFakeMap(dependencies), returnModuleObject = this.getReturnModuleObjectSource(fakeMap);
      return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\t${returnModuleObject}\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = ${JSON.stringify(id)};`;
    }
    getWeakSyncSource(dependencies, id) {
      const map = this.getUserRequestMap(dependencies), fakeMap = this.getFakeMap(dependencies), returnModuleObject = this.getReturnModuleObjectSource(fakeMap);
      return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\tif(!__webpack_require__.m[id]) {\n\t\tvar e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t${returnModuleObject}\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nwebpackContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackContext;`;
    }
    getAsyncWeakSource(dependencies, id) {
      const map = this.getUserRequestMap(dependencies), fakeMap = this.getFakeMap(dependencies), returnModuleObject = this.getReturnModuleObjectSource(fakeMap);
      return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(function(id) {\n\t\tif(!__webpack_require__.m[id]) {\n\t\t\tvar e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\t${returnModuleObject}\n\t});\n}\nfunction webpackAsyncContextResolve(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tif(!__webpack_require__.o(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
    }
    getEagerSource(dependencies, id) {
      const map = this.getUserRequestMap(dependencies), fakeMap = this.getFakeMap(dependencies), thenFunction = 9 !== fakeMap ? `function(id) {\n\t\t${this.getReturnModuleObjectSource(fakeMap)}\n\t}` : "__webpack_require__";
      return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${thenFunction});\n}\nfunction webpackAsyncContextResolve(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tif(!__webpack_require__.o(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
    }
    getLazyOnceSource(block, dependencies, id, runtimeTemplate) {
      const promise = runtimeTemplate.blockPromise({
        block: block,
        message: "lazy-once context"
      }), map = this.getUserRequestMap(dependencies), fakeMap = this.getFakeMap(dependencies), thenFunction = 9 !== fakeMap ? `function(id) {\n\t\t${this.getReturnModuleObjectSource(fakeMap)};\n\t}` : "__webpack_require__";
      return `var map = ${JSON.stringify(map, null, "\t")};\n${this.getFakeMapInitStatement(fakeMap)}\n\nfunction webpackAsyncContext(req) {\n\treturn webpackAsyncContextResolve(req).then(${thenFunction});\n}\nfunction webpackAsyncContextResolve(req) {\n\treturn ${promise}.then(function() {\n\t\tif(!__webpack_require__.o(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\t\treturn map[req];\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
    }
    getLazySource(blocks, id) {
      let hasMultipleOrNoChunks = !1, hasNoChunk = !0;
      const fakeMap = this.getFakeMap(blocks.map(b => b.dependencies[0])), hasFakeMap = "object" == typeof fakeMap, map = blocks.filter(block => block.dependencies[0].module).map(block => {
        const chunks = block.chunkGroup ? block.chunkGroup.chunks : [];
        return chunks.length > 0 && (hasNoChunk = !1), 1 !== chunks.length && (hasMultipleOrNoChunks = !0), 
        {
          dependency: block.dependencies[0],
          block: block,
          userRequest: block.dependencies[0].userRequest,
          chunks: chunks
        };
      }).sort((a, b) => a.userRequest === b.userRequest ? 0 : a.userRequest < b.userRequest ? -1 : 1).reduce((map, item) => {
        const chunks = item.chunks;
        if (hasNoChunk && !hasFakeMap) map[item.userRequest] = item.dependency.module.id; else {
          const arrayStart = [ item.dependency.module.id ];
          "object" == typeof fakeMap && arrayStart.push(fakeMap[item.dependency.module.id]), 
          map[item.userRequest] = arrayStart.concat(chunks.map(chunk => chunk.id));
        }
        return map;
      }, Object.create(null)), shortMode = hasNoChunk && !hasFakeMap, chunksStartPosition = hasFakeMap ? 2 : 1, requestPrefix = hasNoChunk ? "Promise.resolve()" : hasMultipleOrNoChunks ? `Promise.all(ids.slice(${chunksStartPosition}).map(__webpack_require__.e))` : `__webpack_require__.e(ids[${chunksStartPosition}])`, returnModuleObject = this.getReturnModuleObjectSource(fakeMap, shortMode ? "invalid" : "ids[1]"), webpackAsyncContext = "Promise.resolve()" === requestPrefix ? `\nfunction webpackAsyncContext(req) {\n\treturn Promise.resolve().then(function() {\n\t\tif(!__webpack_require__.o(map, req)) {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\n\t\t${shortMode ? "var id = map[req];" : "var ids = map[req], id = ids[0];"}\n\t\t${returnModuleObject}\n\t});\n}` : `function webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn ${requestPrefix}.then(function() {\n\t\t${returnModuleObject}\n\t});\n}`;
      return `var map = ${JSON.stringify(map, null, "\t")};\n${webpackAsyncContext}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = ${JSON.stringify(id)};\nmodule.exports = webpackAsyncContext;`;
    }
    getSourceForEmptyContext(id) {
      return `function webpackEmptyContext(req) {\n\tvar e = new Error("Cannot find module '" + req + "'");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = ${JSON.stringify(id)};`;
    }
    getSourceForEmptyAsyncContext(id) {
      return `function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error("Cannot find module '" + req + "'");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = ${JSON.stringify(id)};`;
    }
    getSourceString(asyncMode, runtimeTemplate) {
      if ("lazy" === asyncMode) return this.blocks && this.blocks.length > 0 ? this.getLazySource(this.blocks, this.id) : this.getSourceForEmptyAsyncContext(this.id);
      if ("eager" === asyncMode) return this.dependencies && this.dependencies.length > 0 ? this.getEagerSource(this.dependencies, this.id) : this.getSourceForEmptyAsyncContext(this.id);
      if ("lazy-once" === asyncMode) {
        const block = this.blocks[0];
        return block ? this.getLazyOnceSource(block, block.dependencies, this.id, runtimeTemplate) : this.getSourceForEmptyAsyncContext(this.id);
      }
      return "async-weak" === asyncMode ? this.dependencies && this.dependencies.length > 0 ? this.getAsyncWeakSource(this.dependencies, this.id) : this.getSourceForEmptyAsyncContext(this.id) : "weak" === asyncMode && this.dependencies && this.dependencies.length > 0 ? this.getWeakSyncSource(this.dependencies, this.id) : this.dependencies && this.dependencies.length > 0 ? this.getSyncSource(this.dependencies, this.id) : this.getSourceForEmptyContext(this.id);
    }
    getSource(sourceString) {
      return this.useSourceMap ? new OriginalSource(sourceString, this.identifier()) : new RawSource(sourceString);
    }
    source(dependencyTemplates, runtimeTemplate) {
      return this.getSource(this.getSourceString(this.options.mode, runtimeTemplate));
    }
    size() {
      return this.dependencies.reduce((size, dependency) => size + 5 + dependency.userRequest.length, 160);
    }
  }
  Object.defineProperty(ContextModule.prototype, "recursive", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.options.recursive;
    }), "ContextModule.recursive has been moved to ContextModule.options.recursive"),
    set: util.deprecate((function(value) {
      this.options.recursive = value;
    }), "ContextModule.recursive has been moved to ContextModule.options.recursive")
  }), Object.defineProperty(ContextModule.prototype, "regExp", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.options.regExp;
    }), "ContextModule.regExp has been moved to ContextModule.options.regExp"),
    set: util.deprecate((function(value) {
      this.options.regExp = value;
    }), "ContextModule.regExp has been moved to ContextModule.options.regExp")
  }), Object.defineProperty(ContextModule.prototype, "addon", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.options.addon;
    }), "ContextModule.addon has been moved to ContextModule.options.addon"),
    set: util.deprecate((function(value) {
      this.options.addon = value;
    }), "ContextModule.addon has been moved to ContextModule.options.addon")
  }), Object.defineProperty(ContextModule.prototype, "async", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.options.mode;
    }), "ContextModule.async has been moved to ContextModule.options.mode"),
    set: util.deprecate((function(value) {
      this.options.mode = value;
    }), "ContextModule.async has been moved to ContextModule.options.mode")
  }), Object.defineProperty(ContextModule.prototype, "chunkName", {
    configurable: !1,
    get: util.deprecate((function() {
      return this.options.chunkName;
    }), "ContextModule.chunkName has been moved to ContextModule.options.chunkName"),
    set: util.deprecate((function(value) {
      this.options.chunkName = value;
    }), "ContextModule.chunkName has been moved to ContextModule.options.chunkName")
  }), module.exports = ContextModule;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {Tapable: Tapable, HookMap: HookMap, SyncHook: SyncHook, SyncWaterfallHook: SyncWaterfallHook} = __webpack_require__(6), Factory = __webpack_require__(224).ResolverFactory, {cachedCleverMerge: cachedCleverMerge} = __webpack_require__(61), EMTPY_RESOLVE_OPTIONS = {};
  module.exports = class extends Tapable {
    constructor() {
      super(), this.hooks = {
        resolveOptions: new HookMap(() => new SyncWaterfallHook([ "resolveOptions" ])),
        resolver: new HookMap(() => new SyncHook([ "resolver", "resolveOptions" ]))
      }, this._pluginCompat.tap("ResolverFactory", options => {
        let match;
        return match = /^resolve-options (.+)$/.exec(options.name), match ? (this.hooks.resolveOptions.for(match[1]).tap(options.fn.name || "unnamed compat plugin", options.fn), 
        !0) : (match = /^resolver (.+)$/.exec(options.name), match ? (this.hooks.resolver.for(match[1]).tap(options.fn.name || "unnamed compat plugin", options.fn), 
        !0) : void 0);
      }), this.cache2 = new Map;
    }
    get(type, resolveOptions) {
      resolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;
      const ident = `${type}|${JSON.stringify(resolveOptions)}`, resolver = this.cache2.get(ident);
      if (resolver) return resolver;
      const newResolver = this._create(type, resolveOptions);
      return this.cache2.set(ident, newResolver), newResolver;
    }
    _create(type, resolveOptions) {
      const originalResolveOptions = Object.assign({}, resolveOptions);
      resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);
      const resolver = Factory.createResolver(resolveOptions);
      if (!resolver) throw new Error("No resolver created");
      const childCache = new Map;
      return resolver.withOptions = options => {
        const cacheEntry = childCache.get(options);
        if (void 0 !== cacheEntry) return cacheEntry;
        const mergedOptions = cachedCleverMerge(originalResolveOptions, options), resolver = this.get(type, mergedOptions);
        return childCache.set(options, resolver), resolver;
      }, this.hooks.resolver.for(type).call(resolver, resolveOptions), resolver;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ResolverFactory = __webpack_require__(225), NodeJsInputFileSystem = __webpack_require__(105), CachedInputFileSystem = __webpack_require__(108), nodeFileSystem = new CachedInputFileSystem(new NodeJsInputFileSystem, 4e3), nodeContext = {
    environments: [ "node+es3+es5+process+native" ]
  }, asyncResolver = ResolverFactory.createResolver({
    extensions: [ ".js", ".json", ".node" ],
    fileSystem: nodeFileSystem
  });
  module.exports = function(context, path, request, resolveContext, callback) {
    "string" == typeof context && (callback = resolveContext, resolveContext = request, 
    request = path, path = context, context = nodeContext), "function" != typeof callback && (callback = resolveContext), 
    asyncResolver.resolve(context, path, request, resolveContext, callback);
  };
  const syncResolver = ResolverFactory.createResolver({
    extensions: [ ".js", ".json", ".node" ],
    useSyncFileSystemCalls: !0,
    fileSystem: nodeFileSystem
  });
  module.exports.sync = function(context, path, request) {
    return "string" == typeof context && (request = path, path = context, context = nodeContext), 
    syncResolver.resolveSync(context, path, request);
  };
  const asyncContextResolver = ResolverFactory.createResolver({
    extensions: [ ".js", ".json", ".node" ],
    resolveToContext: !0,
    fileSystem: nodeFileSystem
  });
  module.exports.context = function(context, path, request, resolveContext, callback) {
    "string" == typeof context && (callback = resolveContext, resolveContext = request, 
    request = path, path = context, context = nodeContext), "function" != typeof callback && (callback = resolveContext), 
    asyncContextResolver.resolve(context, path, request, resolveContext, callback);
  };
  const syncContextResolver = ResolverFactory.createResolver({
    extensions: [ ".js", ".json", ".node" ],
    resolveToContext: !0,
    useSyncFileSystemCalls: !0,
    fileSystem: nodeFileSystem
  });
  module.exports.context.sync = function(context, path, request) {
    return "string" == typeof context && (request = path, path = context, context = nodeContext), 
    syncContextResolver.resolveSync(context, path, request);
  };
  const asyncLoaderResolver = ResolverFactory.createResolver({
    extensions: [ ".js", ".json", ".node" ],
    moduleExtensions: [ "-loader" ],
    mainFields: [ "loader", "main" ],
    fileSystem: nodeFileSystem
  });
  module.exports.loader = function(context, path, request, resolveContext, callback) {
    "string" == typeof context && (callback = resolveContext, resolveContext = request, 
    request = path, path = context, context = nodeContext), "function" != typeof callback && (callback = resolveContext), 
    asyncLoaderResolver.resolve(context, path, request, resolveContext, callback);
  };
  const syncLoaderResolver = ResolverFactory.createResolver({
    extensions: [ ".js", ".json", ".node" ],
    moduleExtensions: [ "-loader" ],
    mainFields: [ "loader", "main" ],
    useSyncFileSystemCalls: !0,
    fileSystem: nodeFileSystem
  });
  module.exports.loader.sync = function(context, path, request) {
    return "string" == typeof context && (request = path, path = context, context = nodeContext), 
    syncLoaderResolver.resolveSync(context, path, request);
  }, module.exports.create = function(options) {
    options = Object.assign({
      fileSystem: nodeFileSystem
    }, options);
    const resolver = ResolverFactory.createResolver(options);
    return function(context, path, request, resolveContext, callback) {
      "string" == typeof context && (callback = resolveContext, resolveContext = request, 
      request = path, path = context, context = nodeContext), "function" != typeof callback && (callback = resolveContext), 
      resolver.resolve(context, path, request, resolveContext, callback);
    };
  }, module.exports.create.sync = function(options) {
    options = Object.assign({
      useSyncFileSystemCalls: !0,
      fileSystem: nodeFileSystem
    }, options);
    const resolver = ResolverFactory.createResolver(options);
    return function(context, path, request) {
      return "string" == typeof context && (request = path, path = context, context = nodeContext), 
      resolver.resolveSync(context, path, request);
    };
  }, module.exports.ResolverFactory = ResolverFactory, module.exports.NodeJsInputFileSystem = NodeJsInputFileSystem, 
  module.exports.CachedInputFileSystem = CachedInputFileSystem;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Resolver = __webpack_require__(226), SyncAsyncFileSystemDecorator = __webpack_require__(228), ParsePlugin = __webpack_require__(229), DescriptionFilePlugin = __webpack_require__(230), NextPlugin = __webpack_require__(231), TryNextPlugin = __webpack_require__(232), ModuleKindPlugin = __webpack_require__(233), FileKindPlugin = __webpack_require__(234), JoinRequestPlugin = __webpack_require__(235), ModulesInHierachicDirectoriesPlugin = __webpack_require__(236), ModulesInRootPlugin = __webpack_require__(237), AliasPlugin = __webpack_require__(64), AliasFieldPlugin = __webpack_require__(238), ConcordExtensionsPlugin = __webpack_require__(239), ConcordMainPlugin = __webpack_require__(241), ConcordModulesPlugin = __webpack_require__(242), DirectoryExistsPlugin = __webpack_require__(243), FileExistsPlugin = __webpack_require__(244), SymlinkPlugin = __webpack_require__(245), MainFieldPlugin = __webpack_require__(246), UseFilePlugin = __webpack_require__(247), AppendPlugin = __webpack_require__(248), RootPlugin = __webpack_require__(249), RestrictionsPlugin = __webpack_require__(250), ResultPlugin = __webpack_require__(251), ModuleAppendPlugin = __webpack_require__(252), UnsafeCachePlugin = __webpack_require__(253);
  exports.createResolver = function(options) {
    let modules = options.modules || [ "node_modules" ];
    const descriptionFiles = options.descriptionFiles || [ "package.json" ], plugins = options.plugins && options.plugins.slice() || [];
    let mainFields = options.mainFields || [ "main" ];
    const aliasFields = options.aliasFields || [], mainFiles = options.mainFiles || [ "index" ];
    let extensions = options.extensions || [ ".js", ".json", ".node" ];
    const enforceExtension = options.enforceExtension || !1;
    let moduleExtensions = options.moduleExtensions || [];
    const enforceModuleExtension = options.enforceModuleExtension || !1;
    let alias = options.alias || [];
    const symlinks = void 0 === options.symlinks || options.symlinks, resolveToContext = options.resolveToContext || !1, roots = options.roots || [], ignoreRootsErrors = options.ignoreRootsErrors || !1, preferAbsolute = options.preferAbsolute || !1, restrictions = options.restrictions || [];
    let unsafeCache = options.unsafeCache || !1;
    const cacheWithContext = void 0 === options.cacheWithContext || options.cacheWithContext, enableConcord = options.concord || !1, cachePredicate = options.cachePredicate || function() {
      return !0;
    }, fileSystem = options.fileSystem, useSyncFileSystemCalls = options.useSyncFileSystemCalls;
    let resolver = options.resolver;
    var array, filter;
    return resolver || (resolver = new Resolver(useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(fileSystem) : fileSystem)), 
    extensions = [].concat(extensions), moduleExtensions = [].concat(moduleExtensions), 
    array = [].concat(modules), filter = item => !/^[A-Z]:|^\//.test(item), modules = array.reduce((array, item) => {
      if (filter(item)) {
        const lastElement = array[array.length - 1];
        return Array.isArray(lastElement) ? lastElement.push(item) : array.push([ item ]), 
        array;
      }
      return array.push(item), array;
    }, []), mainFields = mainFields.map(item => (("string" == typeof item || Array.isArray(item)) && (item = {
      name: item,
      forceRelative: !0
    }), item)), "object" != typeof alias || Array.isArray(alias) || (alias = Object.keys(alias).map(key => {
      let onlyModule = !1, obj = alias[key];
      return /\$$/.test(key) && (onlyModule = !0, key = key.substr(0, key.length - 1)), 
      "string" == typeof obj && (obj = {
        alias: obj
      }), obj = Object.assign({
        name: key,
        onlyModule: onlyModule
      }, obj), obj;
    })), unsafeCache && "object" != typeof unsafeCache && (unsafeCache = {}), resolver.ensureHook("resolve"), 
    resolver.ensureHook("parsedResolve"), resolver.ensureHook("describedResolve"), resolver.ensureHook("rawModule"), 
    resolver.ensureHook("module"), resolver.ensureHook("relative"), resolver.ensureHook("describedRelative"), 
    resolver.ensureHook("directory"), resolver.ensureHook("existingDirectory"), resolver.ensureHook("undescribedRawFile"), 
    resolver.ensureHook("rawFile"), resolver.ensureHook("file"), resolver.ensureHook("existingFile"), 
    resolver.ensureHook("resolved"), unsafeCache ? (plugins.push(new UnsafeCachePlugin("resolve", cachePredicate, unsafeCache, cacheWithContext, "new-resolve")), 
    plugins.push(new ParsePlugin("new-resolve", "parsed-resolve"))) : plugins.push(new ParsePlugin("resolve", "parsed-resolve")), 
    plugins.push(new DescriptionFilePlugin("parsed-resolve", descriptionFiles, "described-resolve")), 
    plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve")), alias.length > 0 && plugins.push(new AliasPlugin("described-resolve", alias, "resolve")), 
    enableConcord && plugins.push(new ConcordModulesPlugin("described-resolve", {}, "resolve")), 
    aliasFields.forEach(item => {
      plugins.push(new AliasFieldPlugin("described-resolve", item, "resolve"));
    }), plugins.push(new ModuleKindPlugin("after-described-resolve", "raw-module")), 
    preferAbsolute && plugins.push(new JoinRequestPlugin("after-described-resolve", "relative")), 
    roots.forEach(root => {
      plugins.push(new RootPlugin("after-described-resolve", root, "relative", ignoreRootsErrors));
    }), preferAbsolute || plugins.push(new JoinRequestPlugin("after-described-resolve", "relative")), 
    moduleExtensions.forEach(item => {
      plugins.push(new ModuleAppendPlugin("raw-module", item, "module"));
    }), enforceModuleExtension || plugins.push(new TryNextPlugin("raw-module", null, "module")), 
    modules.forEach(item => {
      Array.isArray(item) ? plugins.push(new ModulesInHierachicDirectoriesPlugin("module", item, "resolve")) : plugins.push(new ModulesInRootPlugin("module", item, "resolve"));
    }), plugins.push(new DescriptionFilePlugin("relative", descriptionFiles, "described-relative")), 
    plugins.push(new NextPlugin("after-relative", "described-relative")), plugins.push(new FileKindPlugin("described-relative", "raw-file")), 
    plugins.push(new TryNextPlugin("described-relative", "as directory", "directory")), 
    plugins.push(new DirectoryExistsPlugin("directory", "existing-directory")), resolveToContext ? plugins.push(new NextPlugin("existing-directory", "resolved")) : (enableConcord && plugins.push(new ConcordMainPlugin("existing-directory", {}, "resolve")), 
    mainFields.forEach(item => {
      plugins.push(new MainFieldPlugin("existing-directory", item, "resolve"));
    }), mainFiles.forEach(item => {
      plugins.push(new UseFilePlugin("existing-directory", item, "undescribed-raw-file"));
    }), plugins.push(new DescriptionFilePlugin("undescribed-raw-file", descriptionFiles, "raw-file")), 
    plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file")), enforceExtension || plugins.push(new TryNextPlugin("raw-file", "no extension", "file")), 
    enableConcord && plugins.push(new ConcordExtensionsPlugin("raw-file", {}, "file")), 
    extensions.forEach(item => {
      plugins.push(new AppendPlugin("raw-file", item, "file"));
    }), alias.length > 0 && plugins.push(new AliasPlugin("file", alias, "resolve")), 
    enableConcord && plugins.push(new ConcordModulesPlugin("file", {}, "resolve")), 
    aliasFields.forEach(item => {
      plugins.push(new AliasFieldPlugin("file", item, "resolve"));
    }), symlinks && plugins.push(new SymlinkPlugin("file", "relative")), plugins.push(new FileExistsPlugin("file", "existing-file")), 
    plugins.push(new NextPlugin("existing-file", "resolved"))), restrictions.length > 0 && plugins.push(new RestrictionsPlugin(resolver.hooks.resolved, restrictions)), 
    plugins.push(new ResultPlugin(resolver.hooks.resolved)), plugins.forEach(plugin => {
      plugin.apply(resolver);
    }), resolver;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const util = __webpack_require__(11), Tapable = __webpack_require__(90), SyncHook = __webpack_require__(92), AsyncSeriesBailHook = __webpack_require__(94), AsyncSeriesHook = __webpack_require__(93), createInnerContext = __webpack_require__(227), REGEXP_NOT_MODULE = /^\.$|^\.[\\/]|^\.\.$|^\.\.[\\/]|^\/|^[A-Z]:[\\/]/i, REGEXP_DIRECTORY = /[\\/]$/i, memoryFsJoin = __webpack_require__(102), memoizedJoin = new Map, memoryFsNormalize = __webpack_require__(63);
  function withName(name, hook) {
    return hook.name = name, hook;
  }
  function toCamelCase(str) {
    return str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());
  }
  const deprecatedPushToMissing = util.deprecate((set, item) => {
    set.add(item);
  }, "Resolver: 'missing' is now a Set. Use add instead of push."), deprecatedResolveContextInCallback = util.deprecate(x => x, "Resolver: The callback argument was splitted into resolveContext and callback."), deprecatedHookAsString = util.deprecate(x => x, "Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.");
  module.exports = class extends Tapable {
    constructor(fileSystem) {
      super(), this.fileSystem = fileSystem, this.hooks = {
        resolveStep: withName("resolveStep", new SyncHook([ "hook", "request" ])),
        noResolve: withName("noResolve", new SyncHook([ "request", "error" ])),
        resolve: withName("resolve", new AsyncSeriesBailHook([ "request", "resolveContext" ])),
        result: new AsyncSeriesHook([ "result", "resolveContext" ])
      }, this._pluginCompat.tap("Resolver: before/after", options => {
        /^before-/.test(options.name) ? (options.name = options.name.substr(7), options.stage = -10) : /^after-/.test(options.name) && (options.name = options.name.substr(6), 
        options.stage = 10);
      }), this._pluginCompat.tap("Resolver: step hooks", options => {
        const name = options.name;
        if (!/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name)) {
          options.async = !0, this.ensureHook(name);
          const fn = options.fn;
          options.fn = (request, resolverContext, callback) => {
            const innerCallback = (err, result) => err ? callback(err) : void 0 !== result ? callback(null, result) : void callback();
            for (const key in resolverContext) innerCallback[key] = resolverContext[key];
            fn.call(this, request, innerCallback);
          };
        }
      });
    }
    ensureHook(name) {
      if ("string" != typeof name) return name;
      if (name = toCamelCase(name), /^before/.test(name)) return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({
        stage: -10
      });
      if (/^after/.test(name)) return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({
        stage: 10
      });
      const hook = this.hooks[name];
      return hook || (this.hooks[name] = withName(name, new AsyncSeriesBailHook([ "request", "resolveContext" ])));
    }
    getHook(name) {
      if ("string" != typeof name) return name;
      if (name = toCamelCase(name), /^before/.test(name)) return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({
        stage: -10
      });
      if (/^after/.test(name)) return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({
        stage: 10
      });
      const hook = this.hooks[name];
      if (!hook) throw new Error(`Hook ${name} doesn't exist`);
      return hook;
    }
    resolveSync(context, path, request) {
      let err, result, sync = !1;
      if (this.resolve(context, path, request, {}, (e, r) => {
        err = e, result = r, sync = !0;
      }), !sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
      if (err) throw err;
      return result;
    }
    resolve(context, path, request, resolveContext, callback) {
      "function" != typeof callback && (callback = deprecatedResolveContextInCallback(resolveContext));
      const obj = {
        context: context,
        path: path,
        request: request
      }, message = "resolve '" + request + "' in '" + path + "'";
      return this.doResolve(this.hooks.resolve, obj, message, {
        missing: resolveContext.missing,
        stack: resolveContext.stack
      }, (err, result) => {
        if (!err && result) return callback(null, !1 !== result.path && result.path + (result.query || ""), result);
        const localMissing = new Set;
        localMissing.push = item => deprecatedPushToMissing(localMissing, item);
        const log = [];
        return this.doResolve(this.hooks.resolve, obj, message, {
          log: msg => {
            resolveContext.log && resolveContext.log(msg), log.push(msg);
          },
          missing: localMissing,
          stack: resolveContext.stack
        }, (err, result) => {
          if (err) return callback(err);
          const error = new Error("Can't " + message);
          return error.details = log.join("\n"), error.missing = Array.from(localMissing), 
          this.hooks.noResolve.call(obj, error), callback(error);
        });
      });
    }
    doResolve(hook, request, message, resolveContext, callback) {
      if ("function" != typeof callback && (callback = deprecatedResolveContextInCallback(resolveContext)), 
      "string" == typeof hook) {
        const name = toCamelCase(hook);
        if (!(hook = deprecatedHookAsString(this.hooks[name]))) throw new Error(`Hook "${name}" doesn't exist`);
      }
      if ("function" != typeof callback) throw new Error("callback is not a function " + Array.from(arguments));
      if (!resolveContext) throw new Error("resolveContext is not an object " + Array.from(arguments));
      const stackLine = hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
      let newStack;
      if (resolveContext.stack) {
        if (newStack = new Set(resolveContext.stack), resolveContext.stack.has(stackLine)) {
          const recursionError = new Error("Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  "));
          return recursionError.recursion = !0, resolveContext.log && resolveContext.log("abort resolving because of recursion"), 
          callback(recursionError);
        }
        newStack.add(stackLine);
      } else newStack = new Set([ stackLine ]);
      if (this.hooks.resolveStep.call(hook, request), hook.isUsed()) {
        const innerContext = createInnerContext({
          log: resolveContext.log,
          missing: resolveContext.missing,
          stack: newStack
        }, message);
        return hook.callAsync(request, innerContext, (err, result) => err ? callback(err) : result ? callback(null, result) : void callback());
      }
      callback();
    }
    parse(identifier) {
      if ("" === identifier) return null;
      const part = {
        request: "",
        query: "",
        module: !1,
        directory: !1,
        file: !1
      }, idxQuery = identifier.indexOf("?");
      return 0 === idxQuery ? part.query = identifier : idxQuery > 0 ? (part.request = identifier.slice(0, idxQuery), 
      part.query = identifier.slice(idxQuery)) : part.request = identifier, part.request && (part.module = this.isModule(part.request), 
      part.directory = this.isDirectory(part.request), part.directory && (part.request = part.request.substr(0, part.request.length - 1))), 
      part;
    }
    isModule(path) {
      return !REGEXP_NOT_MODULE.test(path);
    }
    isDirectory(path) {
      return REGEXP_DIRECTORY.test(path);
    }
    join(path, request) {
      let cacheEntry, pathCache = memoizedJoin.get(path);
      if (void 0 === pathCache) memoizedJoin.set(path, pathCache = new Map); else if (cacheEntry = pathCache.get(request), 
      void 0 !== cacheEntry) return cacheEntry;
      return cacheEntry = memoryFsJoin(path, request), pathCache.set(request, cacheEntry), 
      cacheEntry;
    }
    normalize(path) {
      return memoryFsNormalize(path);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(options, message, messageOptional) {
    let messageReported = !1;
    return {
      log: (() => {
        if (!options.log) return;
        if (!message) return options.log;
        return msg => {
          messageReported || (options.log(message), messageReported = !0), options.log("  " + msg);
        };
      })(),
      stack: options.stack,
      missing: options.missing
    };
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(fs) {
    this.fs = fs, fs.statSync && (this.stat = function(arg, callback) {
      let result;
      try {
        result = fs.statSync(arg);
      } catch (e) {
        return callback(e);
      }
      callback(null, result);
    }), fs.readdirSync && (this.readdir = function(arg, callback) {
      let result;
      try {
        result = fs.readdirSync(arg);
      } catch (e) {
        return callback(e);
      }
      callback(null, result);
    }), fs.readFileSync && (this.readFile = function(arg, callback) {
      let result;
      try {
        result = fs.readFileSync(arg);
      } catch (e) {
        return callback(e);
      }
      callback(null, result);
    }), fs.readlinkSync && (this.readlink = function(arg, callback) {
      let result;
      try {
        result = fs.readlinkSync(arg);
      } catch (e) {
        return callback(e);
      }
      callback(null, result);
    }), fs.readJsonSync && (this.readJson = function(arg, callback) {
      let result;
      try {
        result = fs.readJsonSync(arg);
      } catch (e) {
        return callback(e);
      }
      callback(null, result);
    });
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ParsePlugin", (request, resolveContext, callback) => {
        const parsed = resolver.parse(request.request), obj = Object.assign({}, request, parsed);
        request.query && !parsed.query && (obj.query = request.query), parsed && resolveContext.log && (parsed.module && resolveContext.log("Parsed request is a module"), 
        parsed.directory && resolveContext.log("Parsed request is a directory")), resolver.doResolve(target, obj, null, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DescriptionFileUtils = __webpack_require__(29);
  module.exports = class {
    constructor(source, filenames, target) {
      this.source = source, this.filenames = [].concat(filenames), this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("DescriptionFilePlugin", (request, resolveContext, callback) => {
        const directory = request.path;
        DescriptionFileUtils.loadDescriptionFile(resolver, directory, this.filenames, resolveContext, (err, result) => {
          if (err) return callback(err);
          if (!result) return resolveContext.missing && this.filenames.forEach(filename => {
            resolveContext.missing.add(resolver.join(directory, filename));
          }), resolveContext.log && resolveContext.log("No description file found"), callback();
          const relativePath = "." + request.path.substr(result.directory.length).replace(/\\/g, "/"), obj = Object.assign({}, request, {
            descriptionFilePath: result.path,
            descriptionFileData: result.content,
            descriptionFileRoot: result.directory,
            relativePath: relativePath
          });
          resolver.doResolve(target, obj, "using description file: " + result.path + " (relative path: " + relativePath + ")", resolveContext, (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("NextPlugin", (request, resolveContext, callback) => {
        resolver.doResolve(target, request, null, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, message, target) {
      this.source = source, this.message = message, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("TryNextPlugin", (request, resolveContext, callback) => {
        resolver.doResolve(target, request, this.message, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ModuleKindPlugin", (request, resolveContext, callback) => {
        if (!request.module) return callback();
        const obj = Object.assign({}, request);
        delete obj.module, resolver.doResolve(target, obj, "resolve as module", resolveContext, (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("FileKindPlugin", (request, resolveContext, callback) => {
        if (request.directory) return callback();
        const obj = Object.assign({}, request);
        delete obj.directory, resolver.doResolve(target, obj, null, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("JoinRequestPlugin", (request, resolveContext, callback) => {
        const obj = Object.assign({}, request, {
          path: resolver.join(request.path, request.request),
          relativePath: request.relativePath && resolver.join(request.relativePath, request.request),
          request: void 0
        });
        resolver.doResolve(target, obj, null, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const forEachBail = __webpack_require__(42), getPaths = __webpack_require__(103);
  module.exports = class {
    constructor(source, directories, target) {
      this.source = source, this.directories = [].concat(directories), this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ModulesInHierachicDirectoriesPlugin", (request, resolveContext, callback) => {
        const fs = resolver.fileSystem, addrs = getPaths(request.path).paths.map(p => this.directories.map(d => resolver.join(p, d))).reduce((array, p) => (array.push.apply(array, p), 
        array), []);
        forEachBail(addrs, (addr, callback) => {
          fs.stat(addr, (err, stat) => {
            if (!err && stat && stat.isDirectory()) {
              const obj = Object.assign({}, request, {
                path: addr,
                request: "./" + request.request
              }), message = "looking for modules in " + addr;
              return resolver.doResolve(target, obj, message, resolveContext, callback);
            }
            return resolveContext.log && resolveContext.log(addr + " doesn't exist or is not a directory"), 
            resolveContext.missing && resolveContext.missing.add(addr), callback();
          });
        }, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, path, target) {
      this.source = source, this.path = path, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ModulesInRootPlugin", (request, resolveContext, callback) => {
        const obj = Object.assign({}, request, {
          path: this.path,
          request: "./" + request.request
        });
        resolver.doResolve(target, obj, "looking for modules in " + this.path, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DescriptionFileUtils = __webpack_require__(29), getInnerRequest = __webpack_require__(104);
  module.exports = class {
    constructor(source, field, target) {
      this.source = source, this.field = field, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("AliasFieldPlugin", (request, resolveContext, callback) => {
        if (!request.descriptionFileData) return callback();
        const innerRequest = getInnerRequest(resolver, request);
        if (!innerRequest) return callback();
        const fieldData = DescriptionFileUtils.getField(request.descriptionFileData, this.field);
        if ("object" != typeof fieldData) return resolveContext.log && resolveContext.log("Field '" + this.field + "' doesn't contain a valid alias configuration"), 
        callback();
        const data1 = fieldData[innerRequest], data2 = fieldData[innerRequest.replace(/^\.\//, "")], data = void 0 !== data1 ? data1 : data2;
        if (data === innerRequest) return callback();
        if (void 0 === data) return callback();
        if (!1 === data) {
          const ignoreObj = Object.assign({}, request, {
            path: !1
          });
          return callback(null, ignoreObj);
        }
        const obj = Object.assign({}, request, {
          path: request.descriptionFileRoot,
          request: data
        });
        resolver.doResolve(target, obj, "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + data + "'", resolveContext, (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const concord = __webpack_require__(65), DescriptionFileUtils = __webpack_require__(29), forEachBail = __webpack_require__(42);
  module.exports = class {
    constructor(source, options, target) {
      this.source = source, this.options = options, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ConcordExtensionsPlugin", (request, resolveContext, callback) => {
        const concordField = DescriptionFileUtils.getField(request.descriptionFileData, "concord");
        if (!concordField) return callback();
        const extensions = concord.getExtensions(request.context, concordField);
        if (!extensions) return callback();
        forEachBail(extensions, (appending, callback) => {
          const obj = Object.assign({}, request, {
            path: request.path + appending,
            relativePath: request.relativePath && request.relativePath + appending
          });
          resolver.doResolve(target, obj, "concord extension: " + appending, resolveContext, callback);
        }, (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const SIMPLE_TOKENS = {
    "@(": "one",
    "?(": "zero-one",
    "+(": "one-many",
    "*(": "zero-many",
    "|": "segment-sep",
    "/**/": "any-path-segments",
    "**": "any-path",
    "*": "any-path-segment",
    "?": "any-char",
    "{": "or",
    "/": "path-sep",
    ",": "comma",
    ")": "closing-segment",
    "}": "closing-or"
  };
  exports.globToRegExp = function(glob) {
    if (/^\(.+\)$/.test(glob)) return new RegExp(glob.substr(1, glob.length - 2));
    const tokens = function(glob) {
      return glob.split(/([@?+*]\(|\/\*\*\/|\*\*|[?*]|\[[!^]?(?:[^\]\\]|\\.)+\]|\{|,|\/|[|)}])/g).map(item => {
        if (!item) return null;
        const t = SIMPLE_TOKENS[item];
        return t ? {
          type: t
        } : "[" === item[0] ? "^" === item[1] || "!" === item[1] ? {
          type: "inverted-char-set",
          value: item.substr(2, item.length - 3)
        } : {
          type: "char-set",
          value: item.substr(1, item.length - 2)
        } : {
          type: "string",
          value: item
        };
      }).filter(Boolean).concat({
        type: "end"
      });
    }(glob), process = function() {
      const inOr = [], process = function() {
        const inSeqment = [], process = function(token, initial) {
          switch (token.type) {
           case "path-sep":
            return "[\\\\/]+";

           case "any-path-segments":
            return "[\\\\/]+(?:(.+)[\\\\/]+)?";

           case "any-path":
            return "(.*)";

           case "any-path-segment":
            return initial ? "\\.[\\\\/]+(?:.*[\\\\/]+)?([^\\\\/]+)" : "([^\\\\/]*)";

           case "any-char":
            return "[^\\\\/]";

           case "inverted-char-set":
            return "[^" + token.value + "]";

           case "char-set":
            return "[" + token.value + "]";

           case "string":
            return token.value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

           case "end":
            return "";

           default:
            throw new Error("Unsupported token '" + token.type + "'");
          }
        };
        return function(token, initial) {
          switch (token.type) {
           case "one":
           case "one-many":
           case "zero-many":
           case "zero-one":
            return inSeqment.push(token.type), "(";

           case "segment-sep":
            return inSeqment.length ? "|" : process({
              type: "string",
              value: "|"
            }, initial);

           case "closing-segment":
            {
              const segment = inSeqment.pop();
              switch (segment) {
               case "one":
                return ")";

               case "one-many":
                return ")+";

               case "zero-many":
                return ")*";

               case "zero-one":
                return ")?";
              }
              throw new Error("Unexcepted segment " + segment);
            }

           case "end":
            if (inSeqment.length > 0) throw new Error("Unmatched segment, missing ')'");
            return process(token, initial);

           default:
            return process(token, initial);
          }
        };
      }();
      let initial = !0;
      return function(token) {
        switch (token.type) {
         case "or":
          return inOr.push(initial), "(";

         case "comma":
          return inOr.length ? (initial = inOr[inOr.length - 1], "|") : process({
            type: "string",
            value: ","
          }, initial);

         case "closing-or":
          if (0 === inOr.length) throw new Error("Unmatched '}'");
          return inOr.pop(), ")";

         case "end":
          if (inOr.length) throw new Error("Unmatched '{'");
          return process(token, initial);

         default:
          {
            const result = process(token, initial);
            return initial = !1, result;
          }
        }
      };
    }(), regExpStr = tokens.map(process).join("");
    return new RegExp("^" + regExpStr + "$");
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), concord = __webpack_require__(65), DescriptionFileUtils = __webpack_require__(29);
  module.exports = class {
    constructor(source, options, target) {
      this.source = source, this.options = options, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ConcordMainPlugin", (request, resolveContext, callback) => {
        if (request.path !== request.descriptionFileRoot) return callback();
        const concordField = DescriptionFileUtils.getField(request.descriptionFileData, "concord");
        if (!concordField) return callback();
        const mainModule = concord.getMain(request.context, concordField);
        if (!mainModule) return callback();
        const obj = Object.assign({}, request, {
          request: mainModule
        }), filename = path.basename(request.descriptionFilePath);
        return resolver.doResolve(target, obj, "use " + mainModule + " from " + filename, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const concord = __webpack_require__(65), DescriptionFileUtils = __webpack_require__(29), getInnerRequest = __webpack_require__(104);
  module.exports = class {
    constructor(source, options, target) {
      this.source = source, this.options = options, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ConcordModulesPlugin", (request, resolveContext, callback) => {
        const innerRequest = getInnerRequest(resolver, request);
        if (!innerRequest) return callback();
        const concordField = DescriptionFileUtils.getField(request.descriptionFileData, "concord");
        if (!concordField) return callback();
        const data = concord.matchModule(request.context, concordField, innerRequest);
        if (data === innerRequest) return callback();
        if (void 0 === data) return callback();
        if (!1 === data) {
          const ignoreObj = Object.assign({}, request, {
            path: !1
          });
          return callback(null, ignoreObj);
        }
        const obj = Object.assign({}, request, {
          path: request.descriptionFileRoot,
          request: data
        });
        resolver.doResolve(target, obj, "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + data + "'", resolveContext, (err, result) => err ? callback(err) : void 0 === result ? callback(null, null) : void callback(null, result));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("DirectoryExistsPlugin", (request, resolveContext, callback) => {
        const fs = resolver.fileSystem, directory = request.path;
        fs.stat(directory, (err, stat) => err || !stat ? (resolveContext.missing && resolveContext.missing.add(directory), 
        resolveContext.log && resolveContext.log(directory + " doesn't exist"), callback()) : stat.isDirectory() ? void resolver.doResolve(target, request, "existing directory", resolveContext, callback) : (resolveContext.missing && resolveContext.missing.add(directory), 
        resolveContext.log && resolveContext.log(directory + " is not a directory"), callback()));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target), fs = resolver.fileSystem;
      resolver.getHook(this.source).tapAsync("FileExistsPlugin", (request, resolveContext, callback) => {
        const file = request.path;
        fs.stat(file, (err, stat) => err || !stat ? (resolveContext.missing && resolveContext.missing.add(file), 
        resolveContext.log && resolveContext.log(file + " doesn't exist"), callback()) : stat.isFile() ? void resolver.doResolve(target, request, "existing file: " + file, resolveContext, callback) : (resolveContext.missing && resolveContext.missing.add(file), 
        resolveContext.log && resolveContext.log(file + " is not a file"), callback()));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const getPaths = __webpack_require__(103), forEachBail = __webpack_require__(42);
  module.exports = class {
    constructor(source, target) {
      this.source = source, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target), fs = resolver.fileSystem;
      resolver.getHook(this.source).tapAsync("SymlinkPlugin", (request, resolveContext, callback) => {
        const pathsResult = getPaths(request.path), pathSeqments = pathsResult.seqments, paths = pathsResult.paths;
        let containsSymlink = !1;
        forEachBail.withIndex(paths, (path, idx, callback) => {
          fs.readlink(path, (err, result) => {
            if (!err && result && (pathSeqments[idx] = result, containsSymlink = !0, /^(\/|[a-zA-Z]:($|\\))/.test(result))) return callback(null, idx);
            callback();
          });
        }, (err, idx) => {
          if (!containsSymlink) return callback();
          const result = ("number" == typeof idx ? pathSeqments.slice(0, idx + 1) : pathSeqments.slice()).reverse().reduce((a, b) => resolver.join(a, b)), obj = Object.assign({}, request, {
            path: result
          });
          resolver.doResolve(target, obj, "resolved symlink to " + result, resolveContext, callback);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3);
  module.exports = class {
    constructor(source, options, target) {
      this.source = source, this.options = options, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("MainFieldPlugin", (request, resolveContext, callback) => {
        if (request.path !== request.descriptionFileRoot) return callback();
        if (request.alreadyTriedMainField === request.descriptionFilePath) return callback();
        const content = request.descriptionFileData, filename = path.basename(request.descriptionFilePath);
        let mainModule;
        const field = this.options.name;
        if (Array.isArray(field)) {
          let current = content;
          for (let j = 0; j < field.length; j++) {
            if (null === current || "object" != typeof current) {
              current = null;
              break;
            }
            current = current[field[j]];
          }
          "string" == typeof current && (mainModule = current);
        } else "string" == typeof content[field] && (mainModule = content[field]);
        if (!mainModule) return callback();
        this.options.forceRelative && !/^\.\.?\//.test(mainModule) && (mainModule = "./" + mainModule);
        const obj = Object.assign({}, request, {
          request: mainModule,
          alreadyTriedMainField: request.descriptionFilePath
        });
        return resolver.doResolve(target, obj, "use " + mainModule + " from " + this.options.name + " in " + filename, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, filename, target) {
      this.source = source, this.filename = filename, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("UseFilePlugin", (request, resolveContext, callback) => {
        const filePath = resolver.join(request.path, this.filename), obj = Object.assign({}, request, {
          path: filePath,
          relativePath: request.relativePath && resolver.join(request.relativePath, this.filename)
        });
        resolver.doResolve(target, obj, "using path: " + filePath, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, appending, target) {
      this.source = source, this.appending = appending, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("AppendPlugin", (request, resolveContext, callback) => {
        const obj = Object.assign({}, request, {
          path: request.path + this.appending,
          relativePath: request.relativePath && request.relativePath + this.appending
        });
        resolver.doResolve(target, obj, this.appending, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, root, target, ignoreErrors) {
      this.root = root, this.source = source, this.target = target, this._ignoreErrors = ignoreErrors;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("RootPlugin", (request, resolveContext, callback) => {
        const req = request.request;
        if (!req) return callback();
        if (!req.startsWith("/")) return callback();
        const path = resolver.join(this.root, req.slice(1)), obj = Object.assign(request, {
          path: path,
          relativePath: request.relativePath && path
        });
        resolver.doResolve(target, obj, "root path " + this.root, resolveContext, this._ignoreErrors ? (err, result) => err ? (resolveContext.log && resolveContext.log("Ignored fatal error while resolving root path:\n" + err), 
        callback()) : result ? callback(null, result) : void callback() : callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const slashCode = "/".charCodeAt(0), backslashCode = "\\".charCodeAt(0), isInside = (path, parent) => {
    if (!path.startsWith(parent)) return !1;
    if (path.length === parent.length) return !0;
    const charCode = path.charCodeAt(parent.length);
    return charCode === slashCode || charCode === backslashCode;
  };
  module.exports = class {
    constructor(source, restrictions) {
      this.source = source, this.restrictions = restrictions;
    }
    apply(resolver) {
      resolver.getHook(this.source).tapAsync("RestrictionsPlugin", (request, resolveContext, callback) => {
        if ("string" == typeof request.path) {
          const path = request.path;
          for (let i = 0; i < this.restrictions.length; i++) {
            const rule = this.restrictions[i];
            if ("string" == typeof rule) {
              if (!isInside(path, rule)) return resolveContext.log && resolveContext.log(`${path} is not inside of the restriction ${rule}`), 
              callback(null, null);
            } else if (!rule.test(path)) return resolveContext.log && resolveContext.log(`${path} doesn't match the restriction ${rule}`), 
            callback(null, null);
          }
        }
        callback();
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source) {
      this.source = source;
    }
    apply(resolver) {
      this.source.tapAsync("ResultPlugin", (request, resolverContext, callback) => {
        const obj = Object.assign({}, request);
        resolverContext.log && resolverContext.log("reporting result " + obj.path), resolver.hooks.result.callAsync(obj, resolverContext, err => {
          if (err) return callback(err);
          callback(null, obj);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, appending, target) {
      this.source = source, this.appending = appending, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("ModuleAppendPlugin", (request, resolveContext, callback) => {
        const i = request.request.indexOf("/"), j = request.request.indexOf("\\"), p = i < 0 ? j : j < 0 || i < j ? i : j;
        let moduleName, remainingRequest;
        if (p < 0 ? (moduleName = request.request, remainingRequest = "") : (moduleName = request.request.substr(0, p), 
        remainingRequest = request.request.substr(p)), "." === moduleName || ".." === moduleName) return callback();
        const moduleFinalName = moduleName + this.appending, obj = Object.assign({}, request, {
          request: moduleFinalName + remainingRequest
        });
        resolver.doResolve(target, obj, "module variation " + moduleFinalName, resolveContext, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(source, filterPredicate, cache, withContext, target) {
      this.source = source, this.filterPredicate = filterPredicate, this.withContext = withContext, 
      this.cache = cache || {}, this.target = target;
    }
    apply(resolver) {
      const target = resolver.ensureHook(this.target);
      resolver.getHook(this.source).tapAsync("UnsafeCachePlugin", (request, resolveContext, callback) => {
        if (!this.filterPredicate(request)) return callback();
        const cacheId = function(request, withContext) {
          return JSON.stringify({
            context: withContext ? request.context : "",
            path: request.path,
            query: request.query,
            request: request.request
          });
        }(request, this.withContext), cacheEntry = this.cache[cacheId];
        if (cacheEntry) return callback(null, cacheEntry);
        resolver.doResolve(target, request, null, resolveContext, (err, result) => err ? callback(err) : result ? callback(null, this.cache[cacheId] = result) : void callback());
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  var constants = __webpack_require__(255), origCwd = process.cwd, cwd = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return cwd || (cwd = origCwd.call(process)), cwd;
  };
  try {
    process.cwd();
  } catch (er) {}
  if ("function" == typeof process.chdir) {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir);
  }
  module.exports = function(fs) {
    constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && function(fs) {
      fs.lchmod = function(path, mode, callback) {
        fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, (function(err, fd) {
          err ? callback && callback(err) : fs.fchmod(fd, mode, (function(err) {
            fs.close(fd, (function(err2) {
              callback && callback(err || err2);
            }));
          }));
        }));
      }, fs.lchmodSync = function(path, mode) {
        var ret, fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0;
        try {
          ret = fs.fchmodSync(fd, mode), threw = !1;
        } finally {
          if (threw) try {
            fs.closeSync(fd);
          } catch (er) {} else fs.closeSync(fd);
        }
        return ret;
      };
    }(fs);
    fs.lutimes || function(fs) {
      constants.hasOwnProperty("O_SYMLINK") && fs.futimes ? (fs.lutimes = function(path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, (function(er, fd) {
          er ? cb && cb(er) : fs.futimes(fd, at, mt, (function(er) {
            fs.close(fd, (function(er2) {
              cb && cb(er || er2);
            }));
          }));
        }));
      }, fs.lutimesSync = function(path, at, mt) {
        var ret, fd = fs.openSync(path, constants.O_SYMLINK), threw = !0;
        try {
          ret = fs.futimesSync(fd, at, mt), threw = !1;
        } finally {
          if (threw) try {
            fs.closeSync(fd);
          } catch (er) {} else fs.closeSync(fd);
        }
        return ret;
      }) : fs.futimes && (fs.lutimes = function(_a, _b, _c, cb) {
        cb && process.nextTick(cb);
      }, fs.lutimesSync = function() {});
    }(fs);
    fs.chown = chownFix(fs.chown), fs.fchown = chownFix(fs.fchown), fs.lchown = chownFix(fs.lchown), 
    fs.chmod = chmodFix(fs.chmod), fs.fchmod = chmodFix(fs.fchmod), fs.lchmod = chmodFix(fs.lchmod), 
    fs.chownSync = chownFixSync(fs.chownSync), fs.fchownSync = chownFixSync(fs.fchownSync), 
    fs.lchownSync = chownFixSync(fs.lchownSync), fs.chmodSync = chmodFixSync(fs.chmodSync), 
    fs.fchmodSync = chmodFixSync(fs.fchmodSync), fs.lchmodSync = chmodFixSync(fs.lchmodSync), 
    fs.stat = statFix(fs.stat), fs.fstat = statFix(fs.fstat), fs.lstat = statFix(fs.lstat), 
    fs.statSync = statFixSync(fs.statSync), fs.fstatSync = statFixSync(fs.fstatSync), 
    fs.lstatSync = statFixSync(fs.lstatSync), fs.chmod && !fs.lchmod && (fs.lchmod = function(path, mode, cb) {
      cb && process.nextTick(cb);
    }, fs.lchmodSync = function() {});
    fs.chown && !fs.lchown && (fs.lchown = function(path, uid, gid, cb) {
      cb && process.nextTick(cb);
    }, fs.lchownSync = function() {});
    "win32" === platform && (fs.rename = "function" != typeof fs.rename ? fs.rename : function(fs$rename) {
      function rename(from, to, cb) {
        var start = Date.now(), backoff = 0;
        fs$rename(from, to, (function CB(er) {
          if (er && ("EACCES" === er.code || "EPERM" === er.code) && Date.now() - start < 6e4) return setTimeout((function() {
            fs.stat(to, (function(stater, st) {
              stater && "ENOENT" === stater.code ? fs$rename(from, to, CB) : cb(er);
            }));
          }), backoff), void (backoff < 100 && (backoff += 10));
          cb && cb(er);
        }));
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
    }(fs.rename));
    function chmodFix(orig) {
      return orig ? function(target, mode, cb) {
        return orig.call(fs, target, mode, (function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        }));
      } : orig;
    }
    function chmodFixSync(orig) {
      return orig ? function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      } : orig;
    }
    function chownFix(orig) {
      return orig ? function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, (function(er) {
          chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
        }));
      } : orig;
    }
    function chownFixSync(orig) {
      return orig ? function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      } : orig;
    }
    function statFix(orig) {
      return orig ? function(target, options, cb) {
        function callback(er, stats) {
          stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), 
          cb && cb.apply(this, arguments);
        }
        return "function" == typeof options && (cb = options, options = null), options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      } : orig;
    }
    function statFixSync(orig) {
      return orig ? function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), 
        stats;
      } : orig;
    }
    function chownErOk(er) {
      return !er || ("ENOSYS" === er.code || !(process.getuid && 0 === process.getuid() || "EINVAL" !== er.code && "EPERM" !== er.code));
    }
    fs.read = "function" != typeof fs.read ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && "function" == typeof callback_) {
          var eagCounter = 0;
          callback = function(er, _, __) {
            if (er && "EAGAIN" === er.code && eagCounter < 10) return eagCounter++, fs$read.call(fs, fd, buffer, offset, length, position, callback);
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
    }(fs.read), fs.readSync = "function" != typeof fs.readSync ? fs.readSync : (fs$readSync = fs.readSync, 
    function(fd, buffer, offset, length, position) {
      for (var eagCounter = 0; ;) try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position);
      } catch (er) {
        if ("EAGAIN" === er.code && eagCounter < 10) {
          eagCounter++;
          continue;
        }
        throw er;
      }
    });
    var fs$readSync;
  };
}, function(module, exports) {
  module.exports = require("constants");
}, function(module, exports, __webpack_require__) {
  var Stream = __webpack_require__(107).Stream;
  module.exports = function(fs) {
    return {
      ReadStream: function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", 
        this.mode = 438, this.bufferSize = 65536, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        this.encoding && this.setEncoding(this.encoding);
        if (void 0 !== this.start) {
          if ("number" != typeof this.start) throw TypeError("start must be a Number");
          if (void 0 === this.end) this.end = 1 / 0; else if ("number" != typeof this.end) throw TypeError("end must be a Number");
          if (this.start > this.end) throw new Error("start must be <= end");
          this.pos = this.start;
        }
        if (null !== this.fd) return void process.nextTick((function() {
          self._read();
        }));
        fs.open(this.path, this.flags, this.mode, (function(err, fd) {
          if (err) return self.emit("error", err), void (self.readable = !1);
          self.fd = fd, self.emit("open", fd), self._read();
        }));
      },
      WriteStream: function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this), this.path = path, this.fd = null, this.writable = !0, this.flags = "w", 
        this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (void 0 !== this.start) {
          if ("number" != typeof this.start) throw TypeError("start must be a Number");
          if (this.start < 0) throw new Error("start must be >= zero");
          this.pos = this.start;
        }
        this.busy = !1, this._queue = [], null === this.fd && (this._open = fs.open, this._queue.push([ this._open, this.path, this.flags, this.mode, void 0 ]), 
        this.flush());
      }
    };
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(obj) {
    if (null === obj || "object" != typeof obj) return obj;
    if (obj instanceof Object) var copy = {
      __proto__: getPrototypeOf(obj)
    }; else copy = Object.create(null);
    return Object.getOwnPropertyNames(obj).forEach((function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    })), copy;
  };
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {Tapable: Tapable, SyncHook: SyncHook, MultiHook: MultiHook} = __webpack_require__(6), asyncLib = __webpack_require__(12), MultiWatching = __webpack_require__(259), MultiStats = __webpack_require__(260), ConcurrentCompilationError = __webpack_require__(109);
  module.exports = class extends Tapable {
    constructor(compilers) {
      super(), this.hooks = {
        done: new SyncHook([ "stats" ]),
        invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),
        run: new MultiHook(compilers.map(c => c.hooks.run)),
        watchClose: new SyncHook([]),
        watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),
        infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))
      }, Array.isArray(compilers) || (compilers = Object.keys(compilers).map(name => (compilers[name].name = name, 
      compilers[name]))), this.compilers = compilers;
      let doneCompilers = 0, compilerStats = [], index = 0;
      for (const compiler of this.compilers) {
        let compilerDone = !1;
        const compilerIndex = index++;
        compiler.hooks.done.tap("MultiCompiler", stats => {
          compilerDone || (compilerDone = !0, doneCompilers++), compilerStats[compilerIndex] = stats, 
          doneCompilers === this.compilers.length && this.hooks.done.call(new MultiStats(compilerStats));
        }), compiler.hooks.invalid.tap("MultiCompiler", () => {
          compilerDone && (compilerDone = !1, doneCompilers--);
        });
      }
      this.running = !1;
    }
    get outputPath() {
      let commonPath = this.compilers[0].outputPath;
      for (const compiler of this.compilers) for (;0 !== compiler.outputPath.indexOf(commonPath) && /[/\\]/.test(commonPath); ) commonPath = commonPath.replace(/[/\\][^/\\]*$/, "");
      return commonPath || "/" !== this.compilers[0].outputPath[0] ? commonPath : "/";
    }
    get inputFileSystem() {
      throw new Error("Cannot read inputFileSystem of a MultiCompiler");
    }
    get outputFileSystem() {
      throw new Error("Cannot read outputFileSystem of a MultiCompiler");
    }
    set inputFileSystem(value) {
      for (const compiler of this.compilers) compiler.inputFileSystem = value;
    }
    set outputFileSystem(value) {
      for (const compiler of this.compilers) compiler.outputFileSystem = value;
    }
    getInfrastructureLogger(name) {
      return this.compilers[0].getInfrastructureLogger(name);
    }
    validateDependencies(callback) {
      const edges = new Set, missing = [], targetFound = compiler => {
        for (const edge of edges) if (edge.target === compiler) return !0;
        return !1;
      }, sortEdges = (e1, e2) => e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);
      for (const source of this.compilers) if (source.dependencies) for (const dep of source.dependencies) {
        const target = this.compilers.find(c => c.name === dep);
        target ? edges.add({
          source: source,
          target: target
        }) : missing.push(dep);
      }
      const errors = missing.map(m => `Compiler dependency \`${m}\` not found.`), stack = this.compilers.filter(c => !targetFound(c));
      for (;stack.length > 0; ) {
        const current = stack.pop();
        for (const edge of edges) if (edge.source === current) {
          edges.delete(edge);
          const target = edge.target;
          targetFound(target) || stack.push(target);
        }
      }
      if (edges.size > 0) {
        const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);
        lines.unshift("Circular dependency found in compiler dependencies."), errors.unshift(lines.join("\n"));
      }
      if (errors.length > 0) {
        const message = errors.join("\n");
        return callback(new Error(message)), !1;
      }
      return !0;
    }
    runWithDependencies(compilers, fn, callback) {
      const fulfilledNames = new Set;
      let remainingCompilers = compilers;
      const isDependencyFulfilled = d => fulfilledNames.has(d), runCompilers = callback => {
        if (0 === remainingCompilers.length) return callback();
        asyncLib.map((() => {
          let readyCompilers = [], list = remainingCompilers;
          remainingCompilers = [];
          for (const c of list) {
            !c.dependencies || c.dependencies.every(isDependencyFulfilled) ? readyCompilers.push(c) : remainingCompilers.push(c);
          }
          return readyCompilers;
        })(), (compiler, callback) => {
          fn(compiler, err => {
            if (err) return callback(err);
            fulfilledNames.add(compiler.name), runCompilers(callback);
          });
        }, callback);
      };
      runCompilers(callback);
    }
    watch(watchOptions, handler) {
      if (this.running) return handler(new ConcurrentCompilationError);
      let watchings = [], allStats = this.compilers.map(() => null), compilerStatus = this.compilers.map(() => !1);
      return this.validateDependencies(handler) && (this.running = !0, this.runWithDependencies(this.compilers, (compiler, callback) => {
        const compilerIdx = this.compilers.indexOf(compiler);
        let firstRun = !0, watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, (err, stats) => {
          if (err && handler(err), stats && (allStats[compilerIdx] = stats, compilerStatus[compilerIdx] = "new", 
          compilerStatus.every(Boolean))) {
            const freshStats = allStats.filter((s, idx) => "new" === compilerStatus[idx]);
            compilerStatus.fill(!0);
            const multiStats = new MultiStats(freshStats);
            handler(null, multiStats);
          }
          firstRun && !err && (firstRun = !1, callback());
        });
        watchings.push(watching);
      }, () => {})), new MultiWatching(watchings, this);
    }
    run(callback) {
      if (this.running) return callback(new ConcurrentCompilationError);
      const finalCallback = (err, stats) => {
        if (this.running = !1, void 0 !== callback) return callback(err, stats);
      }, allStats = this.compilers.map(() => null);
      this.validateDependencies(callback) && (this.running = !0, this.runWithDependencies(this.compilers, (compiler, callback) => {
        const compilerIdx = this.compilers.indexOf(compiler);
        compiler.run((err, stats) => {
          if (err) return callback(err);
          allStats[compilerIdx] = stats, callback();
        });
      }, err => {
        if (err) return finalCallback(err);
        finalCallback(null, new MultiStats(allStats));
      }));
    }
    purgeInputFileSystem() {
      for (const compiler of this.compilers) compiler.inputFileSystem && compiler.inputFileSystem.purge && compiler.inputFileSystem.purge();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const asyncLib = __webpack_require__(12);
  module.exports = class {
    constructor(watchings, compiler) {
      this.watchings = watchings, this.compiler = compiler;
    }
    invalidate() {
      for (const watching of this.watchings) watching.invalidate();
    }
    suspend() {
      for (const watching of this.watchings) watching.suspend();
    }
    resume() {
      for (const watching of this.watchings) watching.resume();
    }
    close(callback) {
      asyncLib.forEach(this.watchings, (watching, finishedCallback) => {
        watching.close(finishedCallback);
      }, err => {
        this.compiler.hooks.watchClose.call(), "function" == typeof callback && (this.compiler.running = !1, 
        callback(err));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Stats = __webpack_require__(28);
  module.exports = class {
    constructor(stats) {
      this.stats = stats, this.hash = stats.map(stat => stat.hash).join("");
    }
    hasErrors() {
      return this.stats.map(stat => stat.hasErrors()).reduce((a, b) => a || b, !1);
    }
    hasWarnings() {
      return this.stats.map(stat => stat.hasWarnings()).reduce((a, b) => a || b, !1);
    }
    toJson(options, forToString) {
      "boolean" == typeof options || "string" == typeof options ? options = Stats.presetToOptions(options) : options || (options = {});
      const jsons = this.stats.map((stat, idx) => {
        const childOptions = Stats.getChildOptions(options, idx), obj = stat.toJson(childOptions, forToString);
        return obj.name = stat.compilation && stat.compilation.name, obj;
      }), showVersion = void 0 === options.version ? jsons.every(j => j.version) : !1 !== options.version, showHash = void 0 === options.hash ? jsons.every(j => j.hash) : !1 !== options.hash;
      if (showVersion) for (const j of jsons) delete j.version;
      const obj = {
        errors: jsons.reduce((arr, j) => arr.concat(j.errors.map(msg => `(${j.name}) ${msg}`)), []),
        warnings: jsons.reduce((arr, j) => arr.concat(j.warnings.map(msg => `(${j.name}) ${msg}`)), [])
      };
      return showVersion && (obj.version = __webpack_require__(59).version), showHash && (obj.hash = this.hash), 
      !1 !== options.children && (obj.children = jsons), obj;
    }
    toString(options) {
      "boolean" == typeof options || "string" == typeof options ? options = Stats.presetToOptions(options) : options || (options = {});
      const useColors = (optionValue = options.colors, fallbackValue = !1, void 0 !== optionValue ? optionValue : fallbackValue);
      var optionValue, fallbackValue;
      const obj = this.toJson(options, !0);
      return Stats.jsonToString(obj, useColors);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var watcherManager = __webpack_require__(110), EventEmitter = __webpack_require__(111).EventEmitter;
  function Watchpack(options) {
    EventEmitter.call(this), options || (options = {}), options.aggregateTimeout || (options.aggregateTimeout = 200), 
    this.options = options, this.watcherOptions = {
      ignored: options.ignored,
      poll: options.poll
    }, this.fileWatchers = [], this.dirWatchers = [], this.mtimes = Object.create(null), 
    this.paused = !1, this.aggregatedChanges = [], this.aggregatedRemovals = [], this.aggregateTimeout = 0, 
    this._onTimeout = this._onTimeout.bind(this);
  }
  module.exports = Watchpack, Watchpack.prototype = Object.create(EventEmitter.prototype), 
  Watchpack.prototype.watch = function(files, directories, startTime) {
    this.paused = !1;
    var oldFileWatchers = this.fileWatchers, oldDirWatchers = this.dirWatchers;
    this.fileWatchers = files.map((function(file) {
      return this._fileWatcher(file, watcherManager.watchFile(file, this.watcherOptions, startTime));
    }), this), this.dirWatchers = directories.map((function(dir) {
      return this._dirWatcher(dir, watcherManager.watchDirectory(dir, this.watcherOptions, startTime));
    }), this), oldFileWatchers.forEach((function(w) {
      w.close();
    }), this), oldDirWatchers.forEach((function(w) {
      w.close();
    }), this);
  }, Watchpack.prototype.close = function() {
    this.paused = !0, this.aggregateTimeout && clearTimeout(this.aggregateTimeout), 
    this.fileWatchers.forEach((function(w) {
      w.close();
    }), this), this.dirWatchers.forEach((function(w) {
      w.close();
    }), this), this.fileWatchers.length = 0, this.dirWatchers.length = 0;
  }, Watchpack.prototype.pause = function() {
    this.paused = !0, this.aggregateTimeout && clearTimeout(this.aggregateTimeout);
  }, Watchpack.prototype.getTimes = function() {
    var directoryWatchers = [];
    !function addWatchersToArray(watchers, array) {
      watchers.forEach((function(w) {
        array.indexOf(w.directoryWatcher) < 0 && (array.push(w.directoryWatcher), addWatchersToArray(Object.keys(w.directoryWatcher.directories).reduce((function(a, dir) {
          return !0 !== w.directoryWatcher.directories[dir] && a.push(w.directoryWatcher.directories[dir]), 
          a;
        }), []), array));
      }));
    }(this.fileWatchers.concat(this.dirWatchers), directoryWatchers);
    var obj = Object.create(null);
    return directoryWatchers.forEach((function(w) {
      var times = w.getTimes();
      Object.keys(times).forEach((function(file) {
        obj[file] = times[file];
      }));
    })), obj;
  }, Watchpack.prototype._fileWatcher = function(file, watcher) {
    return watcher.on("change", function(mtime, type) {
      this._onChange(file, mtime, file, type);
    }.bind(this)), watcher.on("remove", function(type) {
      this._onRemove(file, file, type);
    }.bind(this)), watcher;
  }, Watchpack.prototype._dirWatcher = function(item, watcher) {
    return watcher.on("change", function(file, mtime, type) {
      this._onChange(item, mtime, file, type);
    }.bind(this)), watcher;
  }, Watchpack.prototype._onChange = function(item, mtime, file) {
    file = file || item, this.mtimes[file] = mtime, this.paused || (this.emit("change", file, mtime), 
    this.aggregateTimeout && clearTimeout(this.aggregateTimeout), this.aggregatedChanges.indexOf(item) < 0 && this.aggregatedChanges.push(item), 
    this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout));
  }, Watchpack.prototype._onRemove = function(item, file) {
    file = file || item, delete this.mtimes[item], this.paused || (this.emit("remove", item), 
    this.aggregateTimeout && clearTimeout(this.aggregateTimeout), this.aggregatedRemovals.indexOf(item) < 0 && this.aggregatedRemovals.push(item), 
    this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout));
  }, Watchpack.prototype._onTimeout = function() {
    this.aggregateTimeout = 0;
    var changes = this.aggregatedChanges, removals = this.aggregatedRemovals;
    this.aggregatedChanges = [], this.aggregatedRemovals = [], this.emit("aggregated", changes, removals);
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var EventEmitter = __webpack_require__(111).EventEmitter, async = __webpack_require__(12), chokidar = __webpack_require__(263), fs = __webpack_require__(106), path = __webpack_require__(3), watcherManager = __webpack_require__(110), FS_ACCURACY = 1e3;
  function withoutCase(str) {
    return str.toLowerCase();
  }
  function Watcher(directoryWatcher, filePath, startTime) {
    EventEmitter.call(this), this.directoryWatcher = directoryWatcher, this.path = filePath, 
    this.startTime = startTime && +startTime, this.data = 0;
  }
  function DirectoryWatcher(directoryPath, options) {
    EventEmitter.call(this), this.options = options, this.path = directoryPath, this.files = Object.create(null), 
    this.directories = Object.create(null);
    var interval = "number" == typeof options.poll ? options.poll : void 0;
    this.watcher = chokidar.watch(directoryPath, {
      ignoreInitial: !0,
      persistent: !0,
      followSymlinks: !1,
      depth: 0,
      atomic: !1,
      alwaysStat: !0,
      ignorePermissionErrors: !0,
      ignored: options.ignored,
      usePolling: !!options.poll || void 0,
      interval: interval,
      binaryInterval: interval,
      disableGlobbing: !0
    }), this.watcher.on("add", this.onFileAdded.bind(this)), this.watcher.on("addDir", this.onDirectoryAdded.bind(this)), 
    this.watcher.on("change", this.onChange.bind(this)), this.watcher.on("unlink", this.onFileUnlinked.bind(this)), 
    this.watcher.on("unlinkDir", this.onDirectoryUnlinked.bind(this)), this.watcher.on("error", this.onWatcherError.bind(this)), 
    this.initialScan = !0, this.nestedWatching = !1, this.initialScanRemoved = [], this.doInitialScan(), 
    this.watchers = Object.create(null), this.parentWatcher = null, this.refs = 0;
  }
  Watcher.prototype = Object.create(EventEmitter.prototype), Watcher.prototype.constructor = Watcher, 
  Watcher.prototype.checkStartTime = function(mtime, initial) {
    return "number" != typeof this.startTime ? !initial : this.startTime <= mtime;
  }, Watcher.prototype.close = function() {
    this.emit("closed");
  }, module.exports = DirectoryWatcher, DirectoryWatcher.prototype = Object.create(EventEmitter.prototype), 
  DirectoryWatcher.prototype.constructor = DirectoryWatcher, DirectoryWatcher.prototype.setFileTime = function(filePath, mtime, initial, type) {
    var now = Date.now(), old = this.files[filePath];
    this.files[filePath] = [ initial ? Math.min(now, mtime) : now, mtime ], mtime && (mtime += FS_ACCURACY), 
    old ? !initial && mtime ? this.watchers[withoutCase(filePath)] && this.watchers[withoutCase(filePath)].forEach((function(w) {
      w.emit("change", mtime, type);
    })) : initial || mtime || this.watchers[withoutCase(filePath)] && this.watchers[withoutCase(filePath)].forEach((function(w) {
      w.emit("remove", type);
    })) : mtime && this.watchers[withoutCase(filePath)] && this.watchers[withoutCase(filePath)].forEach((function(w) {
      initial && !w.checkStartTime(mtime, initial) || w.emit("change", mtime, initial ? "initial" : type);
    })), this.watchers[withoutCase(this.path)] && this.watchers[withoutCase(this.path)].forEach((function(w) {
      initial && !w.checkStartTime(mtime, initial) || w.emit("change", filePath, mtime, initial ? "initial" : type);
    }));
  }, DirectoryWatcher.prototype.setDirectory = function(directoryPath, exist, initial, type) {
    directoryPath === this.path ? !initial && this.watchers[withoutCase(this.path)] && this.watchers[withoutCase(this.path)].forEach((function(w) {
      w.emit("change", directoryPath, w.data, initial ? "initial" : type);
    })) : this.directories[directoryPath] ? exist || (this.nestedWatching && this.directories[directoryPath].close(), 
    delete this.directories[directoryPath], !initial && this.watchers[withoutCase(this.path)] && this.watchers[withoutCase(this.path)].forEach((function(w) {
      w.emit("change", directoryPath, w.data, initial ? "initial" : type);
    })), this.watchers[withoutCase(directoryPath) + "#directory"] && this.watchers[withoutCase(directoryPath) + "#directory"].forEach((function(w) {
      w.emit("change", directoryPath, w.data, initial ? "initial" : type);
    }))) : exist && (this.nestedWatching ? this.createNestedWatcher(directoryPath) : this.directories[directoryPath] = !0, 
    !initial && this.watchers[withoutCase(this.path)] && this.watchers[withoutCase(this.path)].forEach((function(w) {
      w.emit("change", directoryPath, w.data, initial ? "initial" : type);
    })), this.watchers[withoutCase(directoryPath) + "#directory"] && this.watchers[withoutCase(directoryPath) + "#directory"].forEach((function(w) {
      w.emit("change", w.data, initial ? "initial" : type);
    })));
  }, DirectoryWatcher.prototype.createNestedWatcher = function(directoryPath) {
    this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1), 
    this.directories[directoryPath].on("change", function(filePath, mtime, type) {
      this.watchers[withoutCase(this.path)] && this.watchers[withoutCase(this.path)].forEach((function(w) {
        w.checkStartTime(mtime, !1) && w.emit("change", filePath, mtime, type);
      }));
    }.bind(this));
  }, DirectoryWatcher.prototype.setNestedWatching = function(flag) {
    this.nestedWatching !== !!flag && (this.nestedWatching = !!flag, this.nestedWatching ? Object.keys(this.directories).forEach((function(directory) {
      this.createNestedWatcher(directory);
    }), this) : Object.keys(this.directories).forEach((function(directory) {
      this.directories[directory].close(), this.directories[directory] = !0;
    }), this));
  }, DirectoryWatcher.prototype.watch = function(filePath, startTime) {
    this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [], 
    this.refs++;
    var data, watcher = new Watcher(this, filePath, startTime);
    return watcher.on("closed", function() {
      var idx = this.watchers[withoutCase(filePath)].indexOf(watcher);
      this.watchers[withoutCase(filePath)].splice(idx, 1), 0 === this.watchers[withoutCase(filePath)].length && (delete this.watchers[withoutCase(filePath)], 
      this.path === filePath && this.setNestedWatching(!1)), --this.refs <= 0 && this.close();
    }.bind(this)), this.watchers[withoutCase(filePath)].push(watcher), filePath === this.path ? (this.setNestedWatching(!0), 
    data = !1, Object.keys(this.files).forEach((function(file) {
      var d = this.files[file];
      data = data ? [ Math.max(data[0], d[0]), Math.max(data[1], d[1]) ] : d;
    }), this)) : data = this.files[filePath], process.nextTick(function() {
      data ? (data[0] === data[1] ? data[0] + FS_ACCURACY : data[0]) >= startTime && watcher.emit("change", data[1]) : this.initialScan && this.initialScanRemoved.indexOf(filePath) >= 0 && watcher.emit("remove");
    }.bind(this)), watcher;
  }, DirectoryWatcher.prototype.onFileAdded = function(filePath, stat) {
    0 === filePath.indexOf(this.path) && (/[\\\/]/.test(filePath.substr(this.path.length + 1)) || this.setFileTime(filePath, +stat.mtime || +stat.ctime || 1, !1, "add"));
  }, DirectoryWatcher.prototype.onDirectoryAdded = function(directoryPath) {
    0 === directoryPath.indexOf(this.path) && (/[\\\/]/.test(directoryPath.substr(this.path.length + 1)) || this.setDirectory(directoryPath, !0, !1, "add"));
  }, DirectoryWatcher.prototype.onChange = function(filePath, stat) {
    if (0 === filePath.indexOf(this.path) && !/[\\\/]/.test(filePath.substr(this.path.length + 1))) {
      var mtime = +stat.mtime || +stat.ctime || 1;
      !function(mtime) {
        if (!mtime) return;
        FS_ACCURACY > 1 && mtime % 1 != 0 ? FS_ACCURACY = 1 : FS_ACCURACY > 10 && mtime % 10 != 0 ? FS_ACCURACY = 10 : FS_ACCURACY > 100 && mtime % 100 != 0 && (FS_ACCURACY = 100);
      }(mtime), this.setFileTime(filePath, mtime, !1, "change");
    }
  }, DirectoryWatcher.prototype.onFileUnlinked = function(filePath) {
    0 === filePath.indexOf(this.path) && (/[\\\/]/.test(filePath.substr(this.path.length + 1)) || (this.setFileTime(filePath, null, !1, "unlink"), 
    this.initialScan && this.initialScanRemoved.push(filePath)));
  }, DirectoryWatcher.prototype.onDirectoryUnlinked = function(directoryPath) {
    0 === directoryPath.indexOf(this.path) && (/[\\\/]/.test(directoryPath.substr(this.path.length + 1)) || (this.setDirectory(directoryPath, !1, !1, "unlink"), 
    this.initialScan && this.initialScanRemoved.push(directoryPath)));
  }, DirectoryWatcher.prototype.onWatcherError = function(err) {
    console.warn("Error from chokidar (" + this.path + "): " + err);
  }, DirectoryWatcher.prototype.doInitialScan = function() {
    fs.readdir(this.path, function(err, items) {
      if (err) return this.parentWatcher = watcherManager.watchFile(this.path + "#directory", this.options, 1), 
      this.parentWatcher.on("change", function(mtime, type) {
        this.watchers[withoutCase(this.path)] && this.watchers[withoutCase(this.path)].forEach((function(w) {
          w.emit("change", this.path, mtime, type);
        }), this);
      }.bind(this)), void (this.initialScan = !1);
      async.forEach(items, function(item, callback) {
        var itemPath = path.join(this.path, item);
        fs.stat(itemPath, function(err2, stat) {
          this.initialScan && (err2 || (stat.isFile() ? this.files[itemPath] || this.setFileTime(itemPath, +stat.mtime || +stat.ctime || 1, !0) : stat.isDirectory() && (this.directories[itemPath] || this.setDirectory(itemPath, !0, !0))), 
          callback());
        }.bind(this));
      }.bind(this), function() {
        this.initialScan = !1, this.initialScanRemoved = null;
      }.bind(this));
    }.bind(this));
  }, DirectoryWatcher.prototype.getTimes = function() {
    var obj = Object.create(null), selfTime = 0;
    return Object.keys(this.files).forEach((function(file) {
      var time, data = this.files[file];
      time = data[1] ? Math.max(data[0], data[1] + FS_ACCURACY) : data[0], obj[file] = time, 
      time > selfTime && (selfTime = time);
    }), this), this.nestedWatching && (Object.keys(this.directories).forEach((function(dir) {
      var times = this.directories[dir].directoryWatcher.getTimes();
      Object.keys(times).forEach((function(file) {
        var time = times[file];
        obj[file] = time, time > selfTime && (selfTime = time);
      }));
    }), this), obj[this.path] = selfTime), obj;
  }, DirectoryWatcher.prototype.close = function() {
    this.initialScan = !1;
    var p = this.watcher.close();
    p && p.catch && p.catch(this.onWatcherError.bind(this)), this.nestedWatching && Object.keys(this.directories).forEach((function(dir) {
      this.directories[dir].close();
    }), this), this.parentWatcher && this.parentWatcher.close(), this.emit("closed");
  };
}, function(module, exports, __webpack_require__) {
  var v3Err, v2Err;
  try {
    return void (module.exports = __webpack_require__(112));
  } catch (e) {
    v3Err = e;
  }
  try {
    return void (module.exports = __webpack_require__(264));
  } catch (e) {
    v2Err = e;
  }
  throw new Error("No version of chokidar is available. Tried chokidar@2 and chokidar@3.\nYou could try to manually install any chokidar version.\nchokidar@3: " + v3Err + "\nchokidar@2: " + v2Err + "\n");
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(112);
}, function(module, exports) {
  module.exports = function(obj) {
    return new Map(Object.keys(obj).map(key => [ key, obj[key] ]));
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {LogType: LogType} = __webpack_require__(39), filterToFunction = item => {
    if ("string" == typeof item) {
      const regExp = new RegExp(`[\\\\/]${item.replace(/[-[\]{}()*+?.\\^$|]/g, "\\$&")}([\\\\/]|$|!|\\?)`);
      return ident => regExp.test(ident);
    }
    return item && "object" == typeof item && "function" == typeof item.test ? ident => item.test(ident) : "function" == typeof item ? item : "boolean" == typeof item ? () => item : void 0;
  }, LogLevel = {
    none: 6,
    false: 6,
    error: 5,
    warn: 4,
    info: 3,
    log: 2,
    true: 2,
    verbose: 1
  };
  module.exports = ({level: level = "info", debug: debug = !1, console: console}) => {
    const debugFilters = "boolean" == typeof debug ? [ () => debug ] : [].concat(debug).map(filterToFunction), loglevel = LogLevel["" + level] || 0;
    return (name, type, args) => {
      const labeledArgs = () => Array.isArray(args) ? args.length > 0 && "string" == typeof args[0] ? [ `[${name}] ${args[0]}`, ...args.slice(1) ] : [ `[${name}]`, ...args ] : [], debug = debugFilters.some(f => f(name));
      switch (type) {
       case LogType.debug:
        if (!debug) return;
        "function" == typeof console.debug ? console.debug(...labeledArgs()) : console.log(...labeledArgs());
        break;

       case LogType.log:
        if (!debug && loglevel > LogLevel.log) return;
        console.log(...labeledArgs());
        break;

       case LogType.info:
        if (!debug && loglevel > LogLevel.info) return;
        console.info(...labeledArgs());
        break;

       case LogType.warn:
        if (!debug && loglevel > LogLevel.warn) return;
        console.warn(...labeledArgs());
        break;

       case LogType.error:
        if (!debug && loglevel > LogLevel.error) return;
        console.error(...labeledArgs());
        break;

       case LogType.trace:
        if (!debug) return;
        console.trace();
        break;

       case LogType.groupCollapsed:
        if (!debug && loglevel > LogLevel.log) return;
        if (!debug && loglevel > LogLevel.verbose) {
          "function" == typeof console.groupCollapsed ? console.groupCollapsed(...labeledArgs()) : console.log(...labeledArgs());
          break;
        }

       case LogType.group:
        if (!debug && loglevel > LogLevel.log) return;
        "function" == typeof console.group ? console.group(...labeledArgs()) : console.log(...labeledArgs());
        break;

       case LogType.groupEnd:
        if (!debug && loglevel > LogLevel.log) return;
        "function" == typeof console.groupEnd && console.groupEnd();
        break;

       case LogType.time:
        {
          if (!debug && loglevel > LogLevel.log) return;
          const ms = 1e3 * args[1] + args[2] / 1e6, msg = `[${name}] ${args[0]}: ${ms}ms`;
          "function" == typeof console.logTime ? console.logTime(msg) : console.log(msg);
          break;
        }

       case LogType.profile:
        "function" == typeof console.profile && console.profile(...labeledArgs());
        break;

       case LogType.profileEnd:
        "function" == typeof console.profileEnd && console.profileEnd(...labeledArgs());
        break;

       case LogType.clear:
        if (!debug && loglevel > LogLevel.log) return;
        "function" == typeof console.clear && console.clear();
        break;

       case LogType.status:
        if (!debug && loglevel > LogLevel.info) return;
        "function" == typeof console.status ? 0 === args.length ? console.status() : console.status(...labeledArgs()) : 0 !== args.length && console.info(...labeledArgs());
        break;

       default:
        throw new Error("Unexpected LogType " + type);
      }
    };
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const truncateArgs = (args, maxLength) => {
    const lengths = args.map(a => ("" + a).length), availableLength = maxLength - lengths.length + 1;
    if (availableLength > 0 && 1 === args.length) return availableLength >= args[0].length ? args : availableLength > 3 ? [ "..." + args[0].slice(3 - availableLength) ] : [ args[0].slice(-availableLength) ];
    if (availableLength < lengths.reduce((s, i) => s + Math.min(i, 6), 0)) return args.length > 1 ? truncateArgs(args.slice(0, args.length - 1), maxLength) : [];
    let currentLength = lengths.reduce((a, b) => a + b, 0);
    if (currentLength <= availableLength) return args;
    for (;currentLength > availableLength; ) {
      const maxLength = Math.max(...lengths), shorterItems = lengths.filter(l => l !== maxLength), nextToMaxLength = shorterItems.length > 0 ? Math.max(...shorterItems) : 0, maxReduce = maxLength - nextToMaxLength;
      let maxItems = lengths.length - shorterItems.length, overrun = currentLength - availableLength;
      for (let i = 0; i < lengths.length; i++) if (lengths[i] === maxLength) {
        const reduce = Math.min(Math.floor(overrun / maxItems), maxReduce);
        lengths[i] -= reduce, currentLength -= reduce, overrun -= reduce, maxItems--;
      }
    }
    return args.map((a, i) => {
      const str = "" + a, length = lengths[i];
      return str.length === length ? str : length > 5 ? "..." + str.slice(3 - length) : length > 0 ? str.slice(-length) : "";
    });
  };
  module.exports = truncateArgs;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const OptionsApply = __webpack_require__(269), JavascriptModulesPlugin = __webpack_require__(270), JsonModulesPlugin = __webpack_require__(273), WebAssemblyModulesPlugin = __webpack_require__(277), LoaderTargetPlugin = __webpack_require__(121), FunctionModulePlugin = __webpack_require__(283), EvalDevToolModulePlugin = __webpack_require__(122), SourceMapDevToolPlugin = __webpack_require__(72), EvalSourceMapDevToolPlugin = __webpack_require__(124), EntryOptionPlugin = __webpack_require__(288), RecordIdsPlugin = __webpack_require__(291), APIPlugin = __webpack_require__(292), ConstPlugin = __webpack_require__(293), CommonJsStuffPlugin = __webpack_require__(294), CompatibilityPlugin = __webpack_require__(295), TemplatedPathPlugin = __webpack_require__(296), WarnCaseSensitiveModulesPlugin = __webpack_require__(297), UseStrictPlugin = __webpack_require__(299), LoaderPlugin = __webpack_require__(300), CommonJsPlugin = __webpack_require__(302), HarmonyModulesPlugin = __webpack_require__(308), SystemPlugin = __webpack_require__(313), ImportPlugin = __webpack_require__(314), RequireContextPlugin = __webpack_require__(318), RequireEnsurePlugin = __webpack_require__(320), RequireIncludePlugin = __webpack_require__(323), {cachedCleverMerge: cachedCleverMerge} = __webpack_require__(61);
  module.exports = class extends OptionsApply {
    constructor() {
      super();
    }
    process(options, compiler) {
      let ExternalsPlugin, noSources, legacy, modern, comment;
      if (compiler.outputPath = options.output.path, compiler.recordsInputPath = options.recordsInputPath || options.recordsPath, 
      compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath, compiler.name = options.name, 
      compiler.dependencies = options.dependencies, "string" == typeof options.target) {
        let JsonpTemplatePlugin, FetchCompileWasmTemplatePlugin, ReadFileCompileWasmTemplatePlugin, NodeSourcePlugin, NodeTargetPlugin, NodeTemplatePlugin;
        switch (options.target) {
         case "web":
          JsonpTemplatePlugin = __webpack_require__(51), FetchCompileWasmTemplatePlugin = __webpack_require__(52), 
          NodeSourcePlugin = __webpack_require__(53), (new JsonpTemplatePlugin).apply(compiler), 
          new FetchCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler), (new FunctionModulePlugin).apply(compiler), new NodeSourcePlugin(options.node).apply(compiler), 
          new LoaderTargetPlugin(options.target).apply(compiler);
          break;

         case "webworker":
          {
            let WebWorkerTemplatePlugin = __webpack_require__(150);
            FetchCompileWasmTemplatePlugin = __webpack_require__(52), NodeSourcePlugin = __webpack_require__(53), 
            (new WebWorkerTemplatePlugin).apply(compiler), new FetchCompileWasmTemplatePlugin({
              mangleImports: options.optimization.mangleWasmImports
            }).apply(compiler), (new FunctionModulePlugin).apply(compiler), new NodeSourcePlugin(options.node).apply(compiler), 
            new LoaderTargetPlugin(options.target).apply(compiler);
            break;
          }

         case "node":
         case "async-node":
          NodeTemplatePlugin = __webpack_require__(24), ReadFileCompileWasmTemplatePlugin = __webpack_require__(54), 
          NodeTargetPlugin = __webpack_require__(25), new NodeTemplatePlugin({
            asyncChunkLoading: "async-node" === options.target
          }).apply(compiler), new ReadFileCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler), (new FunctionModulePlugin).apply(compiler), (new NodeTargetPlugin).apply(compiler), 
          new LoaderTargetPlugin("node").apply(compiler);
          break;

         case "node-webkit":
          JsonpTemplatePlugin = __webpack_require__(51), NodeTargetPlugin = __webpack_require__(25), 
          ExternalsPlugin = __webpack_require__(26), (new JsonpTemplatePlugin).apply(compiler), 
          (new FunctionModulePlugin).apply(compiler), (new NodeTargetPlugin).apply(compiler), 
          new ExternalsPlugin("commonjs", "nw.gui").apply(compiler), new LoaderTargetPlugin(options.target).apply(compiler);
          break;

         case "electron-main":
          NodeTemplatePlugin = __webpack_require__(24), NodeTargetPlugin = __webpack_require__(25), 
          ExternalsPlugin = __webpack_require__(26), new NodeTemplatePlugin({
            asyncChunkLoading: !0
          }).apply(compiler), (new FunctionModulePlugin).apply(compiler), (new NodeTargetPlugin).apply(compiler), 
          new ExternalsPlugin("commonjs", [ "app", "auto-updater", "browser-window", "clipboard", "content-tracing", "crash-reporter", "dialog", "electron", "global-shortcut", "ipc", "ipc-main", "menu", "menu-item", "native-image", "original-fs", "power-monitor", "power-save-blocker", "protocol", "screen", "session", "shell", "tray", "web-contents" ]).apply(compiler), 
          new LoaderTargetPlugin(options.target).apply(compiler);
          break;

         case "electron-renderer":
         case "electron-preload":
          FetchCompileWasmTemplatePlugin = __webpack_require__(52), NodeTargetPlugin = __webpack_require__(25), 
          ExternalsPlugin = __webpack_require__(26), "electron-renderer" === options.target ? (JsonpTemplatePlugin = __webpack_require__(51), 
          (new JsonpTemplatePlugin).apply(compiler)) : "electron-preload" === options.target && (NodeTemplatePlugin = __webpack_require__(24), 
          new NodeTemplatePlugin({
            asyncChunkLoading: !0
          }).apply(compiler)), new FetchCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler), (new FunctionModulePlugin).apply(compiler), (new NodeTargetPlugin).apply(compiler), 
          new ExternalsPlugin("commonjs", [ "clipboard", "crash-reporter", "desktop-capturer", "electron", "ipc", "ipc-renderer", "native-image", "original-fs", "remote", "screen", "shell", "web-frame" ]).apply(compiler), 
          new LoaderTargetPlugin(options.target).apply(compiler);
          break;

         default:
          throw new Error("Unsupported target '" + options.target + "'.");
        }
      } else {
        if (!1 === options.target) throw new Error("Unsupported target '" + options.target + "'.");
        options.target(compiler);
      }
      if (options.output.library || "var" !== options.output.libraryTarget) {
        new (__webpack_require__(153))(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine, options.output.auxiliaryComment || "", options.output.libraryExport).apply(compiler);
      }
      if (options.externals && (ExternalsPlugin = __webpack_require__(26), new ExternalsPlugin(options.output.libraryTarget, options.externals).apply(compiler)), 
      options.devtool && (options.devtool.includes("sourcemap") || options.devtool.includes("source-map"))) {
        const hidden = options.devtool.includes("hidden"), inline = options.devtool.includes("inline"), evalWrapped = options.devtool.includes("eval"), cheap = options.devtool.includes("cheap"), moduleMaps = options.devtool.includes("module");
        noSources = options.devtool.includes("nosources"), legacy = options.devtool.includes("@"), 
        modern = options.devtool.includes("#"), comment = legacy && modern ? "\n/*\n//@ sourceMappingURL=[url]\n//# sourceMappingURL=[url]\n*/" : legacy ? "\n/*\n//@ sourceMappingURL=[url]\n*/" : modern ? "\n//# sourceMappingURL=[url]" : null;
        new (evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin)({
          filename: inline ? null : options.output.sourceMapFilename,
          moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
          fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
          append: !hidden && comment,
          module: !!moduleMaps || !cheap,
          columns: !cheap,
          lineToLine: options.output.devtoolLineToLine,
          noSources: noSources,
          namespace: options.output.devtoolNamespace
        }).apply(compiler);
      } else options.devtool && options.devtool.includes("eval") && (legacy = options.devtool.includes("@"), 
      modern = options.devtool.includes("#"), comment = legacy && modern ? "\n//@ sourceURL=[url]\n//# sourceURL=[url]" : legacy ? "\n//@ sourceURL=[url]" : modern ? "\n//# sourceURL=[url]" : null, 
      new EvalDevToolModulePlugin({
        sourceUrlComment: comment,
        moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
        namespace: options.output.devtoolNamespace
      }).apply(compiler));
      if ((new JavascriptModulesPlugin).apply(compiler), (new JsonModulesPlugin).apply(compiler), 
      new WebAssemblyModulesPlugin({
        mangleImports: options.optimization.mangleWasmImports
      }).apply(compiler), (new EntryOptionPlugin).apply(compiler), compiler.hooks.entryOption.call(options.context, options.entry), 
      (new CompatibilityPlugin).apply(compiler), new HarmonyModulesPlugin(options.module).apply(compiler), 
      !1 !== options.amd) {
        const AMDPlugin = __webpack_require__(339), RequireJsStuffPlugin = __webpack_require__(343);
        new AMDPlugin(options.module, options.amd || {}).apply(compiler), (new RequireJsStuffPlugin).apply(compiler);
      }
      if (new CommonJsPlugin(options.module).apply(compiler), (new LoaderPlugin).apply(compiler), 
      !1 !== options.node) {
        new (__webpack_require__(344))(options.node).apply(compiler);
      }
      if ((new CommonJsStuffPlugin).apply(compiler), (new APIPlugin).apply(compiler), 
      (new ConstPlugin).apply(compiler), (new UseStrictPlugin).apply(compiler), (new RequireIncludePlugin).apply(compiler), 
      (new RequireEnsurePlugin).apply(compiler), new RequireContextPlugin(options.resolve.modules, options.resolve.extensions, options.resolve.mainFiles).apply(compiler), 
      new ImportPlugin(options.module).apply(compiler), new SystemPlugin(options.module).apply(compiler), 
      "string" != typeof options.mode) {
        (new (__webpack_require__(345))).apply(compiler);
      }
      if ((new (__webpack_require__(347))).apply(compiler), options.optimization.removeAvailableModules) {
        (new (__webpack_require__(348))).apply(compiler);
      }
      if (options.optimization.removeEmptyChunks) {
        (new (__webpack_require__(349))).apply(compiler);
      }
      if (options.optimization.mergeDuplicateChunks) {
        (new (__webpack_require__(350))).apply(compiler);
      }
      if (options.optimization.flagIncludedChunks) {
        (new (__webpack_require__(351))).apply(compiler);
      }
      if (options.optimization.sideEffects) {
        (new (__webpack_require__(160))).apply(compiler);
      }
      if (options.optimization.providedExports) {
        (new (__webpack_require__(353))).apply(compiler);
      }
      if (options.optimization.usedExports) {
        (new (__webpack_require__(354))).apply(compiler);
      }
      if (options.optimization.concatenateModules) {
        (new (__webpack_require__(161))).apply(compiler);
      }
      if (options.optimization.splitChunks) {
        new (__webpack_require__(167))(options.optimization.splitChunks).apply(compiler);
      }
      if (options.optimization.runtimeChunk) {
        new (__webpack_require__(168))(options.optimization.runtimeChunk).apply(compiler);
      }
      if (options.optimization.noEmitOnErrors) {
        (new (__webpack_require__(169))).apply(compiler);
      }
      if (options.optimization.checkWasmTypes) {
        (new (__webpack_require__(365))).apply(compiler);
      }
      let moduleIds = options.optimization.moduleIds;
      if (void 0 === moduleIds && (options.optimization.occurrenceOrder && (moduleIds = "size"), 
      options.optimization.namedModules && (moduleIds = "named"), options.optimization.hashedModuleIds && (moduleIds = "hashed"), 
      void 0 === moduleIds && (moduleIds = "natural")), moduleIds) {
        const NamedModulesPlugin = __webpack_require__(170), HashedModuleIdsPlugin = __webpack_require__(171), OccurrenceModuleOrderPlugin = __webpack_require__(172);
        switch (moduleIds) {
         case "natural":
          break;

         case "named":
          (new NamedModulesPlugin).apply(compiler);
          break;

         case "hashed":
          (new HashedModuleIdsPlugin).apply(compiler);
          break;

         case "size":
          new OccurrenceModuleOrderPlugin({
            prioritiseInitial: !0
          }).apply(compiler);
          break;

         case "total-size":
          new OccurrenceModuleOrderPlugin({
            prioritiseInitial: !1
          }).apply(compiler);
          break;

         default:
          throw new Error(`webpack bug: moduleIds: ${moduleIds} is not implemented`);
        }
      }
      let chunkIds = options.optimization.chunkIds;
      if (void 0 === chunkIds && (options.optimization.occurrenceOrder && (chunkIds = "total-size"), 
      options.optimization.namedChunks && (chunkIds = "named"), void 0 === chunkIds && (chunkIds = "natural")), 
      chunkIds) {
        const NaturalChunkOrderPlugin = __webpack_require__(368), NamedChunksPlugin = __webpack_require__(173), OccurrenceChunkOrderPlugin = __webpack_require__(174);
        switch (chunkIds) {
         case "natural":
          (new NaturalChunkOrderPlugin).apply(compiler);
          break;

         case "named":
          new OccurrenceChunkOrderPlugin({
            prioritiseInitial: !1
          }).apply(compiler), (new NamedChunksPlugin).apply(compiler);
          break;

         case "size":
          new OccurrenceChunkOrderPlugin({
            prioritiseInitial: !0
          }).apply(compiler);
          break;

         case "total-size":
          new OccurrenceChunkOrderPlugin({
            prioritiseInitial: !1
          }).apply(compiler);
          break;

         default:
          throw new Error(`webpack bug: chunkIds: ${chunkIds} is not implemented`);
        }
      }
      if (options.optimization.nodeEnv) {
        new (__webpack_require__(88))({
          "process.env.NODE_ENV": JSON.stringify(options.optimization.nodeEnv)
        }).apply(compiler);
      }
      if (options.optimization.minimize) for (const minimizer of options.optimization.minimizer) "function" == typeof minimizer ? minimizer.call(compiler, compiler) : minimizer.apply(compiler);
      if (options.performance) {
        new (__webpack_require__(370))(options.performance).apply(compiler);
      }
      if ((new TemplatedPathPlugin).apply(compiler), new RecordIdsPlugin({
        portableIds: options.optimization.portableRecords
      }).apply(compiler), (new WarnCaseSensitiveModulesPlugin).apply(compiler), options.cache) {
        new (__webpack_require__(175))("object" == typeof options.cache ? options.cache : null).apply(compiler);
      }
      if (compiler.hooks.afterPlugins.call(compiler), !compiler.inputFileSystem) throw new Error("No input filesystem provided");
      return compiler.resolverFactory.hooks.resolveOptions.for("normal").tap("WebpackOptionsApply", resolveOptions => Object.assign({
        fileSystem: compiler.inputFileSystem
      }, cachedCleverMerge(options.resolve, resolveOptions))), compiler.resolverFactory.hooks.resolveOptions.for("context").tap("WebpackOptionsApply", resolveOptions => Object.assign({
        fileSystem: compiler.inputFileSystem,
        resolveToContext: !0
      }, cachedCleverMerge(options.resolve, resolveOptions))), compiler.resolverFactory.hooks.resolveOptions.for("loader").tap("WebpackOptionsApply", resolveOptions => Object.assign({
        fileSystem: compiler.inputFileSystem
      }, cachedCleverMerge(options.resolveLoader, resolveOptions))), compiler.hooks.afterResolvers.call(compiler), 
      options;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    process(options, compiler) {}
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Parser = __webpack_require__(114), Template = __webpack_require__(2), {ConcatSource: ConcatSource} = __webpack_require__(0), JavascriptGenerator = __webpack_require__(272), createHash = __webpack_require__(17);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("JavascriptModulesPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        normalModuleFactory.hooks.createParser.for("javascript/auto").tap("JavascriptModulesPlugin", options => new Parser(options, "auto")), 
        normalModuleFactory.hooks.createParser.for("javascript/dynamic").tap("JavascriptModulesPlugin", options => new Parser(options, "script")), 
        normalModuleFactory.hooks.createParser.for("javascript/esm").tap("JavascriptModulesPlugin", options => new Parser(options, "module")), 
        normalModuleFactory.hooks.createGenerator.for("javascript/auto").tap("JavascriptModulesPlugin", () => new JavascriptGenerator), 
        normalModuleFactory.hooks.createGenerator.for("javascript/dynamic").tap("JavascriptModulesPlugin", () => new JavascriptGenerator), 
        normalModuleFactory.hooks.createGenerator.for("javascript/esm").tap("JavascriptModulesPlugin", () => new JavascriptGenerator), 
        compilation.mainTemplate.hooks.renderManifest.tap("JavascriptModulesPlugin", (result, options) => {
          const chunk = options.chunk, hash = options.hash, fullHash = options.fullHash, outputOptions = options.outputOptions, moduleTemplates = options.moduleTemplates, dependencyTemplates = options.dependencyTemplates, filenameTemplate = chunk.filenameTemplate || outputOptions.filename, useChunkHash = compilation.mainTemplate.useChunkHash(chunk);
          return result.push({
            render: () => compilation.mainTemplate.render(hash, chunk, moduleTemplates.javascript, dependencyTemplates),
            filenameTemplate: filenameTemplate,
            pathOptions: {
              noChunkHash: !useChunkHash,
              contentHashType: "javascript",
              chunk: chunk
            },
            identifier: "chunk" + chunk.id,
            hash: useChunkHash ? chunk.hash : fullHash
          }), result;
        }), compilation.mainTemplate.hooks.modules.tap("JavascriptModulesPlugin", (source, chunk, hash, moduleTemplate, dependencyTemplates) => Template.renderChunkModules(chunk, m => "function" == typeof m.source, moduleTemplate, dependencyTemplates, "/******/ ")), 
        compilation.chunkTemplate.hooks.renderManifest.tap("JavascriptModulesPlugin", (result, options) => {
          const chunk = options.chunk, outputOptions = options.outputOptions, moduleTemplates = options.moduleTemplates, dependencyTemplates = options.dependencyTemplates, filenameTemplate = chunk.filenameTemplate || outputOptions.chunkFilename;
          return result.push({
            render: () => this.renderJavascript(compilation.chunkTemplate, chunk, moduleTemplates.javascript, dependencyTemplates),
            filenameTemplate: filenameTemplate,
            pathOptions: {
              chunk: chunk,
              contentHashType: "javascript"
            },
            identifier: "chunk" + chunk.id,
            hash: chunk.hash
          }), result;
        }), compilation.hooks.contentHash.tap("JavascriptModulesPlugin", chunk => {
          const outputOptions = compilation.outputOptions, {hashSalt: hashSalt, hashDigest: hashDigest, hashDigestLength: hashDigestLength, hashFunction: hashFunction} = outputOptions, hash = createHash(hashFunction);
          hashSalt && hash.update(hashSalt);
          const template = chunk.hasRuntime() ? compilation.mainTemplate : compilation.chunkTemplate;
          hash.update(chunk.id + " "), hash.update(chunk.ids ? chunk.ids.join(",") : ""), 
          template.updateHashForChunk(hash, chunk, compilation.moduleTemplates.javascript, compilation.dependencyTemplates);
          for (const m of chunk.modulesIterable) "function" == typeof m.source && hash.update(m.hash);
          const digest = hash.digest(hashDigest);
          chunk.contentHash.javascript = digest.substr(0, hashDigestLength);
        });
      });
    }
    renderJavascript(chunkTemplate, chunk, moduleTemplate, dependencyTemplates) {
      const moduleSources = Template.renderChunkModules(chunk, m => "function" == typeof m.source, moduleTemplate, dependencyTemplates), core = chunkTemplate.hooks.modules.call(moduleSources, chunk, moduleTemplate, dependencyTemplates);
      let source = chunkTemplate.hooks.render.call(core, chunk, moduleTemplate, dependencyTemplates);
      return chunk.hasEntryModule() && (source = chunkTemplate.hooks.renderWithEntry.call(source, chunk)), 
      chunk.rendered = !0, new ConcatSource(source, ";");
    }
  };
}, function(__webpack_module__, __webpack_exports__, __webpack_require__) {
  "use strict";
  __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "Node", (function() {
    return Node;
  })), __webpack_require__.d(__webpack_exports__, "Parser", (function() {
    return Parser;
  })), __webpack_require__.d(__webpack_exports__, "Position", (function() {
    return Position;
  })), __webpack_require__.d(__webpack_exports__, "SourceLocation", (function() {
    return SourceLocation;
  })), __webpack_require__.d(__webpack_exports__, "TokContext", (function() {
    return TokContext;
  })), __webpack_require__.d(__webpack_exports__, "Token", (function() {
    return Token;
  })), __webpack_require__.d(__webpack_exports__, "TokenType", (function() {
    return TokenType;
  })), __webpack_require__.d(__webpack_exports__, "defaultOptions", (function() {
    return defaultOptions;
  })), __webpack_require__.d(__webpack_exports__, "getLineInfo", (function() {
    return getLineInfo;
  })), __webpack_require__.d(__webpack_exports__, "isIdentifierChar", (function() {
    return isIdentifierChar;
  })), __webpack_require__.d(__webpack_exports__, "isIdentifierStart", (function() {
    return isIdentifierStart;
  })), __webpack_require__.d(__webpack_exports__, "isNewLine", (function() {
    return isNewLine;
  })), __webpack_require__.d(__webpack_exports__, "keywordTypes", (function() {
    return keywords$1;
  })), __webpack_require__.d(__webpack_exports__, "lineBreak", (function() {
    return lineBreak;
  })), __webpack_require__.d(__webpack_exports__, "lineBreakG", (function() {
    return lineBreakG;
  })), __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", (function() {
    return nonASCIIwhitespace;
  })), __webpack_require__.d(__webpack_exports__, "parse", (function() {
    return parse;
  })), __webpack_require__.d(__webpack_exports__, "parseExpressionAt", (function() {
    return parseExpressionAt;
  })), __webpack_require__.d(__webpack_exports__, "tokContexts", (function() {
    return types$1;
  })), __webpack_require__.d(__webpack_exports__, "tokTypes", (function() {
    return types;
  })), __webpack_require__.d(__webpack_exports__, "tokenizer", (function() {
    return tokenizer;
  })), __webpack_require__.d(__webpack_exports__, "version", (function() {
    return version;
  }));
  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  }, ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", keywords = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  }, keywordRelationalOperator = /^in(stanceof)?$/, nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-Ᶎꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭧꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [ 0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541 ], astralIdentifierCodes = [ 509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239 ];
  function isInAstralSet(code, set) {
    for (var pos = 65536, i = 0; i < set.length; i += 2) {
      if ((pos += set[i]) > code) return !1;
      if ((pos += set[i + 1]) >= code) return !0;
    }
  }
  function isIdentifierStart(code, astral) {
    return code < 65 ? 36 === code : code < 91 || (code < 97 ? 95 === code : code < 123 || (code <= 65535 ? code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code)) : !1 !== astral && isInAstralSet(code, astralIdentifierStartCodes)));
  }
  function isIdentifierChar(code, astral) {
    return code < 48 ? 36 === code : code < 58 || !(code < 65) && (code < 91 || (code < 97 ? 95 === code : code < 123 || (code <= 65535 ? code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code)) : !1 !== astral && (isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)))));
  }
  var TokenType = function(label, conf) {
    void 0 === conf && (conf = {}), this.label = label, this.keyword = conf.keyword, 
    this.beforeExpr = !!conf.beforeExpr, this.startsExpr = !!conf.startsExpr, this.isLoop = !!conf.isLoop, 
    this.isAssign = !!conf.isAssign, this.prefix = !!conf.prefix, this.postfix = !!conf.postfix, 
    this.binop = conf.binop || null, this.updateContext = null;
  };
  function binop(name, prec) {
    return new TokenType(name, {
      beforeExpr: !0,
      binop: prec
    });
  }
  var beforeExpr = {
    beforeExpr: !0
  }, startsExpr = {
    startsExpr: !0
  }, keywords$1 = {};
  function kw(name, options) {
    return void 0 === options && (options = {}), options.keyword = name, keywords$1[name] = new TokenType(name, options);
  }
  var types = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    eq: new TokenType("=", {
      beforeExpr: !0,
      isAssign: !0
    }),
    assign: new TokenType("_=", {
      beforeExpr: !0,
      isAssign: !0
    }),
    incDec: new TokenType("++/--", {
      prefix: !0,
      postfix: !0,
      startsExpr: !0
    }),
    prefix: new TokenType("!/~", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: !0,
      binop: 9,
      prefix: !0,
      startsExpr: !0
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
      beforeExpr: !0
    }),
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
      isLoop: !0,
      beforeExpr: !0
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
      isLoop: !0
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
      isLoop: !0
    }),
    _with: kw("with"),
    _new: kw("new", {
      beforeExpr: !0,
      startsExpr: !0
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
      beforeExpr: !0,
      binop: 7
    }),
    _instanceof: kw("instanceof", {
      beforeExpr: !0,
      binop: 7
    }),
    _typeof: kw("typeof", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _void: kw("void", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    }),
    _delete: kw("delete", {
      beforeExpr: !0,
      prefix: !0,
      startsExpr: !0
    })
  }, lineBreak = /\r\n?|\n|\u2028|\u2029/, lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code, ecma2019String) {
    return 10 === code || 13 === code || !ecma2019String && (8232 === code || 8233 === code);
  }
  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ref = Object.prototype, hasOwnProperty = ref.hasOwnProperty, toString = ref.toString;
  function has(obj, propName) {
    return hasOwnProperty.call(obj, propName);
  }
  var isArray = Array.isArray || function(obj) {
    return "[object Array]" === toString.call(obj);
  };
  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
  }
  var Position = function(line, col) {
    this.line = line, this.column = col;
  };
  Position.prototype.offset = function(n) {
    return new Position(this.line, this.column + n);
  };
  var SourceLocation = function(p, start, end) {
    this.start = start, this.end = end, null !== p.sourceFile && (this.source = p.sourceFile);
  };
  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0; ;) {
      lineBreakG.lastIndex = cur;
      var match = lineBreakG.exec(input);
      if (!(match && match.index < offset)) return new Position(line, offset - cur);
      ++line, cur = match.index + match[0].length;
    }
  }
  var defaultOptions = {
    ecmaVersion: 9,
    sourceType: "script",
    onInsertedSemicolon: null,
    onTrailingComma: null,
    allowReserved: null,
    allowReturnOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowAwaitOutsideFunction: !1,
    allowHashBang: !1,
    locations: !1,
    onToken: null,
    onComment: null,
    ranges: !1,
    program: null,
    sourceFile: null,
    directSourceFile: null,
    preserveParens: !1
  };
  function getOptions(opts) {
    var options = {};
    for (var opt in defaultOptions) options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
    if (options.ecmaVersion >= 2015 && (options.ecmaVersion -= 2009), null == options.allowReserved && (options.allowReserved = options.ecmaVersion < 5), 
    isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function(token) {
        return tokens.push(token);
      };
    }
    return isArray(options.onComment) && (options.onComment = function(options, array) {
      return function(block, text, start, end, startLoc, endLoc) {
        var comment = {
          type: block ? "Block" : "Line",
          value: text,
          start: start,
          end: end
        };
        options.locations && (comment.loc = new SourceLocation(this, startLoc, endLoc)), 
        options.ranges && (comment.range = [ start, end ]), array.push(comment);
      };
    }(options, options.onComment)), options;
  }
  function functionFlags(async, generator) {
    return 2 | (async ? 4 : 0) | (generator ? 8 : 0);
  }
  var Parser = function(options, input, startPos) {
    this.options = options = getOptions(options), this.sourceFile = options.sourceFile, 
    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : "module" === options.sourceType ? "5module" : 5]);
    var reserved = "";
    if (!0 !== options.allowReserved) {
      for (var v = options.ecmaVersion; !(reserved = reservedWords[v]); v--) ;
      "module" === options.sourceType && (reserved += " await");
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict), this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind), 
    this.input = String(input), this.containsEsc = !1, startPos ? (this.pos = startPos, 
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length) : (this.pos = this.lineStart = 0, 
    this.curLine = 1), this.type = types.eof, this.value = null, this.start = this.end = this.pos, 
    this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, 
    this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), 
    this.exprAllowed = !0, this.inModule = "module" === options.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), 
    this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, 
    this.labels = [], this.undefinedExports = {}, 0 === this.pos && options.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), 
    this.scopeStack = [], this.enterScope(1), this.regexpState = null;
  }, prototypeAccessors = {
    inFunction: {
      configurable: !0
    },
    inGenerator: {
      configurable: !0
    },
    inAsync: {
      configurable: !0
    },
    allowSuper: {
      configurable: !0
    },
    allowDirectSuper: {
      configurable: !0
    },
    treatFunctionsAsVar: {
      configurable: !0
    }
  };
  Parser.prototype.parse = function() {
    var node = this.options.program || this.startNode();
    return this.nextToken(), this.parseTopLevel(node);
  }, prototypeAccessors.inFunction.get = function() {
    return (2 & this.currentVarScope().flags) > 0;
  }, prototypeAccessors.inGenerator.get = function() {
    return (8 & this.currentVarScope().flags) > 0;
  }, prototypeAccessors.inAsync.get = function() {
    return (4 & this.currentVarScope().flags) > 0;
  }, prototypeAccessors.allowSuper.get = function() {
    return (64 & this.currentThisScope().flags) > 0;
  }, prototypeAccessors.allowDirectSuper.get = function() {
    return (128 & this.currentThisScope().flags) > 0;
  }, prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }, Parser.prototype.inNonArrowFunction = function() {
    return (2 & this.currentThisScope().flags) > 0;
  }, Parser.extend = function() {
    for (var plugins = [], len = arguments.length; len--; ) plugins[len] = arguments[len];
    for (var cls = this, i = 0; i < plugins.length; i++) cls = plugins[i](cls);
    return cls;
  }, Parser.parse = function(input, options) {
    return new this(options, input).parse();
  }, Parser.parseExpressionAt = function(input, pos, options) {
    var parser = new this(options, input, pos);
    return parser.nextToken(), parser.parseExpression();
  }, Parser.tokenizer = function(input, options) {
    return new this(options, input);
  }, Object.defineProperties(Parser.prototype, prototypeAccessors);
  var pp = Parser.prototype, literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  function DestructuringErrors() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  }
  pp.strictDirective = function(start) {
    for (;;) {
      skipWhiteSpace.lastIndex = start, start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) return !1;
      if ("use strict" === (match[1] || match[2])) return !0;
      start += match[0].length, skipWhiteSpace.lastIndex = start, start += skipWhiteSpace.exec(this.input)[0].length, 
      ";" === this.input[start] && start++;
    }
  }, pp.eat = function(type) {
    return this.type === type && (this.next(), !0);
  }, pp.isContextual = function(name) {
    return this.type === types.name && this.value === name && !this.containsEsc;
  }, pp.eatContextual = function(name) {
    return !!this.isContextual(name) && (this.next(), !0);
  }, pp.expectContextual = function(name) {
    this.eatContextual(name) || this.unexpected();
  }, pp.canInsertSemicolon = function() {
    return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }, pp.insertSemicolon = function() {
    if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), 
    !0;
  }, pp.semicolon = function() {
    this.eat(types.semi) || this.insertSemicolon() || this.unexpected();
  }, pp.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), 
    notNext || this.next(), !0;
  }, pp.expect = function(type) {
    this.eat(type) || this.unexpected();
  }, pp.unexpected = function(pos) {
    this.raise(null != pos ? pos : this.start, "Unexpected token");
  }, pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (refDestructuringErrors) {
      refDestructuringErrors.trailingComma > -1 && this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      parens > -1 && this.raiseRecoverable(parens, "Parenthesized pattern");
    }
  }, pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) return !1;
    var shorthandAssign = refDestructuringErrors.shorthandAssign, doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
    shorthandAssign >= 0 && this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"), 
    doubleProto >= 0 && this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }, pp.checkYieldAwaitInDefaultParams = function() {
    this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), 
    this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
  }, pp.isSimpleAssignTarget = function(expr) {
    return "ParenthesizedExpression" === expr.type ? this.isSimpleAssignTarget(expr.expression) : "Identifier" === expr.type || "MemberExpression" === expr.type;
  };
  var pp$1 = Parser.prototype;
  pp$1.parseTopLevel = function(node) {
    var exports = {};
    for (node.body || (node.body = []); this.type !== types.eof; ) {
      var stmt = this.parseStatement(null, !0, exports);
      node.body.push(stmt);
    }
    if (this.inModule) for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
    return this.adaptDirectivePrologue(node.body), this.next(), node.sourceType = this.options.sourceType, 
    this.finishNode(node, "Program");
  };
  var loopLabel = {
    kind: "loop"
  }, switchLabel = {
    kind: "switch"
  };
  pp$1.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (91 === nextCh) return !0;
    if (context) return !1;
    if (123 === nextCh) return !0;
    if (isIdentifierStart(nextCh, !0)) {
      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), !0); ) ++pos;
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) return !0;
    }
    return !1;
  }, pp$1.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length;
    return !(lineBreak.test(this.input.slice(this.pos, next)) || "function" !== this.input.slice(next, next + 8) || next + 8 !== this.input.length && isIdentifierChar(this.input.charAt(next + 8)));
  }, pp$1.parseStatement = function(context, topLevel, exports) {
    var kind, starttype = this.type, node = this.startNode();
    switch (this.isLet(context) && (starttype = types._var, kind = "let"), starttype) {
     case types._break:
     case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);

     case types._debugger:
      return this.parseDebuggerStatement(node);

     case types._do:
      return this.parseDoStatement(node);

     case types._for:
      return this.parseForStatement(node);

     case types._function:
      return context && (this.strict || "if" !== context && "label" !== context) && this.options.ecmaVersion >= 6 && this.unexpected(), 
      this.parseFunctionStatement(node, !1, !context);

     case types._class:
      return context && this.unexpected(), this.parseClass(node, !0);

     case types._if:
      return this.parseIfStatement(node);

     case types._return:
      return this.parseReturnStatement(node);

     case types._switch:
      return this.parseSwitchStatement(node);

     case types._throw:
      return this.parseThrowStatement(node);

     case types._try:
      return this.parseTryStatement(node);

     case types._const:
     case types._var:
      return kind = kind || this.value, context && "var" !== kind && this.unexpected(), 
      this.parseVarStatement(node, kind);

     case types._while:
      return this.parseWhileStatement(node);

     case types._with:
      return this.parseWithStatement(node);

     case types.braceL:
      return this.parseBlock(!0, node);

     case types.semi:
      return this.parseEmptyStatement(node);

     case types._export:
     case types._import:
      if (this.options.ecmaVersion > 10 && starttype === types._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input), next = this.pos + skip[0].length;
        if (40 === this.input.charCodeAt(next)) return this.parseExpressionStatement(node, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (topLevel || this.raise(this.start, "'import' and 'export' may only appear at the top level"), 
      this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), 
      starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);

     default:
      if (this.isAsyncFunction()) return context && this.unexpected(), this.next(), this.parseFunctionStatement(node, !0, !context);
      var maybeName = this.value, expr = this.parseExpression();
      return starttype === types.name && "Identifier" === expr.type && this.eat(types.colon) ? this.parseLabeledStatement(node, maybeName, expr, context) : this.parseExpressionStatement(node, expr);
    }
  }, pp$1.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = "break" === keyword;
    this.next(), this.eat(types.semi) || this.insertSemicolon() ? node.label = null : this.type !== types.name ? this.unexpected() : (node.label = this.parseIdent(), 
    this.semicolon());
    for (var i = 0; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (null == node.label || lab.name === node.label.name) {
        if (null != lab.kind && (isBreak || "loop" === lab.kind)) break;
        if (node.label && isBreak) break;
      }
    }
    return i === this.labels.length && this.raise(node.start, "Unsyntactic " + keyword), 
    this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
  }, pp$1.parseDebuggerStatement = function(node) {
    return this.next(), this.semicolon(), this.finishNode(node, "DebuggerStatement");
  }, pp$1.parseDoStatement = function(node) {
    return this.next(), this.labels.push(loopLabel), node.body = this.parseStatement("do"), 
    this.labels.pop(), this.expect(types._while), node.test = this.parseParenExpression(), 
    this.options.ecmaVersion >= 6 ? this.eat(types.semi) : this.semicolon(), this.finishNode(node, "DoWhileStatement");
  }, pp$1.parseForStatement = function(node) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
    if (this.labels.push(loopLabel), this.enterScope(0), this.expect(types.parenL), 
    this.type === types.semi) return awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, null);
    var isLet = this.isLet();
    if (this.type === types._var || this.type === types._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      return this.next(), this.parseVar(init$1, !0, kind), this.finishNode(init$1, "VariableDeclaration"), 
      (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === init$1.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === types._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), 
      this.parseForIn(node, init$1)) : (awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init$1));
    }
    var refDestructuringErrors = new DestructuringErrors, init = this.parseExpression(!0, refDestructuringErrors);
    return this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === types._in ? awaitAt > -1 && this.unexpected(awaitAt) : node.await = awaitAt > -1), 
    this.toAssignable(init, !1, refDestructuringErrors), this.checkLVal(init), this.parseForIn(node, init)) : (this.checkExpressionErrors(refDestructuringErrors, !0), 
    awaitAt > -1 && this.unexpected(awaitAt), this.parseFor(node, init));
  }, pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    return this.next(), this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), !1, isAsync);
  }, pp$1.parseIfStatement = function(node) {
    return this.next(), node.test = this.parseParenExpression(), node.consequent = this.parseStatement("if"), 
    node.alternate = this.eat(types._else) ? this.parseStatement("if") : null, this.finishNode(node, "IfStatement");
  }, pp$1.parseReturnStatement = function(node) {
    return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), 
    this.next(), this.eat(types.semi) || this.insertSemicolon() ? node.argument = null : (node.argument = this.parseExpression(), 
    this.semicolon()), this.finishNode(node, "ReturnStatement");
  }, pp$1.parseSwitchStatement = function(node) {
    var cur;
    this.next(), node.discriminant = this.parseParenExpression(), node.cases = [], this.expect(types.braceL), 
    this.labels.push(switchLabel), this.enterScope(0);
    for (var sawDefault = !1; this.type !== types.braceR; ) if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      cur && this.finishNode(cur, "SwitchCase"), node.cases.push(cur = this.startNode()), 
      cur.consequent = [], this.next(), isCase ? cur.test = this.parseExpression() : (sawDefault && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), 
      sawDefault = !0, cur.test = null), this.expect(types.colon);
    } else cur || this.unexpected(), cur.consequent.push(this.parseStatement(null));
    return this.exitScope(), cur && this.finishNode(cur, "SwitchCase"), this.next(), 
    this.labels.pop(), this.finishNode(node, "SwitchStatement");
  }, pp$1.parseThrowStatement = function(node) {
    return this.next(), lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), 
    node.argument = this.parseExpression(), this.semicolon(), this.finishNode(node, "ThrowStatement");
  };
  var empty = [];
  pp$1.parseTryStatement = function(node) {
    if (this.next(), node.block = this.parseBlock(), node.handler = null, this.type === types._catch) {
      var clause = this.startNode();
      if (this.next(), this.eat(types.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = "Identifier" === clause.param.type;
        this.enterScope(simple ? 32 : 0), this.checkLVal(clause.param, simple ? 4 : 2), 
        this.expect(types.parenR);
      } else this.options.ecmaVersion < 10 && this.unexpected(), clause.param = null, 
      this.enterScope(0);
      clause.body = this.parseBlock(!1), this.exitScope(), node.handler = this.finishNode(clause, "CatchClause");
    }
    return node.finalizer = this.eat(types._finally) ? this.parseBlock() : null, node.handler || node.finalizer || this.raise(node.start, "Missing catch or finally clause"), 
    this.finishNode(node, "TryStatement");
  }, pp$1.parseVarStatement = function(node, kind) {
    return this.next(), this.parseVar(node, !1, kind), this.semicolon(), this.finishNode(node, "VariableDeclaration");
  }, pp$1.parseWhileStatement = function(node) {
    return this.next(), node.test = this.parseParenExpression(), this.labels.push(loopLabel), 
    node.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(node, "WhileStatement");
  }, pp$1.parseWithStatement = function(node) {
    return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), 
    node.object = this.parseParenExpression(), node.body = this.parseStatement("with"), 
    this.finishNode(node, "WithStatement");
  }, pp$1.parseEmptyStatement = function(node) {
    return this.next(), this.finishNode(node, "EmptyStatement");
  }, pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
      list[i$1].name === maybeName && this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
    for (var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null, i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart !== node.start) break;
      label$1.statementStart = this.start, label$1.kind = kind;
    }
    return this.labels.push({
      name: maybeName,
      kind: kind,
      statementStart: this.start
    }), node.body = this.parseStatement(context ? -1 === context.indexOf("label") ? context + "label" : context : "label"), 
    this.labels.pop(), node.label = expr, this.finishNode(node, "LabeledStatement");
  }, pp$1.parseExpressionStatement = function(node, expr) {
    return node.expression = expr, this.semicolon(), this.finishNode(node, "ExpressionStatement");
  }, pp$1.parseBlock = function(createNewLexicalScope, node) {
    for (void 0 === createNewLexicalScope && (createNewLexicalScope = !0), void 0 === node && (node = this.startNode()), 
    node.body = [], this.expect(types.braceL), createNewLexicalScope && this.enterScope(0); !this.eat(types.braceR); ) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    return createNewLexicalScope && this.exitScope(), this.finishNode(node, "BlockStatement");
  }, pp$1.parseFor = function(node, init) {
    return node.init = init, this.expect(types.semi), node.test = this.type === types.semi ? null : this.parseExpression(), 
    this.expect(types.semi), node.update = this.type === types.parenR ? null : this.parseExpression(), 
    this.expect(types.parenR), node.body = this.parseStatement("for"), this.exitScope(), 
    this.labels.pop(), this.finishNode(node, "ForStatement");
  }, pp$1.parseForIn = function(node, init) {
    var isForIn = this.type === types._in;
    return this.next(), "VariableDeclaration" === init.type && null != init.declarations[0].init && (!isForIn || this.options.ecmaVersion < 8 || this.strict || "var" !== init.kind || "Identifier" !== init.declarations[0].id.type) ? this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : "AssignmentPattern" === init.type && this.raise(init.start, "Invalid left-hand side in for-loop"), 
    node.left = init, node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign(), 
    this.expect(types.parenR), node.body = this.parseStatement("for"), this.exitScope(), 
    this.labels.pop(), this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
  }, pp$1.parseVar = function(node, isFor, kind) {
    for (node.declarations = [], node.kind = kind; ;) {
      var decl = this.startNode();
      if (this.parseVarId(decl, kind), this.eat(types.eq) ? decl.init = this.parseMaybeAssign(isFor) : "const" !== kind || this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? "Identifier" === decl.id.type || isFor && (this.type === types._in || this.isContextual("of")) ? decl.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), 
      node.declarations.push(this.finishNode(decl, "VariableDeclarator")), !this.eat(types.comma)) break;
    }
    return node;
  }, pp$1.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom(), this.checkLVal(decl.id, "var" === kind ? 1 : 2, !1);
  };
  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2;
  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
    this.initFunction(node), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) && (this.type === types.star && statement & FUNC_HANGING_STATEMENT && this.unexpected(), 
    node.generator = this.eat(types.star)), this.options.ecmaVersion >= 8 && (node.async = !!isAsync), 
    statement & FUNC_STATEMENT && (node.id = 4 & statement && this.type !== types.name ? null : this.parseIdent(), 
    !node.id || statement & FUNC_HANGING_STATEMENT || this.checkLVal(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(node.async, node.generator)), 
    statement & FUNC_STATEMENT || (node.id = this.type === types.name ? this.parseIdent() : null), 
    this.parseFunctionParams(node), this.parseFunctionBody(node, allowExpressionBody, !1), 
    this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
    this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
  }, pp$1.parseFunctionParams = function(node) {
    this.expect(types.parenL), node.params = this.parseBindingList(types.parenR, !1, this.options.ecmaVersion >= 8), 
    this.checkYieldAwaitInDefaultParams();
  }, pp$1.parseClass = function(node, isStatement) {
    this.next();
    var oldStrict = this.strict;
    this.strict = !0, this.parseClassId(node, isStatement), this.parseClassSuper(node);
    var classBody = this.startNode(), hadConstructor = !1;
    for (classBody.body = [], this.expect(types.braceL); !this.eat(types.braceR); ) {
      var element = this.parseClassElement(null !== node.superClass);
      element && (classBody.body.push(element), "MethodDefinition" === element.type && "constructor" === element.kind && (hadConstructor && this.raise(element.start, "Duplicate constructor in the same class"), 
      hadConstructor = !0));
    }
    return node.body = this.finishNode(classBody, "ClassBody"), this.strict = oldStrict, 
    this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
  }, pp$1.parseClassElement = function(constructorAllowsSuper) {
    var this$1 = this;
    if (this.eat(types.semi)) return null;
    var method = this.startNode(), tryContextual = function(k, noLineBreak) {
      void 0 === noLineBreak && (noLineBreak = !1);
      var start = this$1.start, startLoc = this$1.startLoc;
      return !!this$1.eatContextual(k) && (!(this$1.type === types.parenL || noLineBreak && this$1.canInsertSemicolon()) || (method.key && this$1.unexpected(), 
      method.computed = !1, method.key = this$1.startNodeAt(start, startLoc), method.key.name = k, 
      this$1.finishNode(method.key, "Identifier"), !1));
    };
    method.kind = "method", method.static = tryContextual("static");
    var isGenerator = this.eat(types.star), isAsync = !1;
    isGenerator || (this.options.ecmaVersion >= 8 && tryContextual("async", !0) ? (isAsync = !0, 
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star)) : tryContextual("get") ? method.kind = "get" : tryContextual("set") && (method.kind = "set")), 
    method.key || this.parsePropertyName(method);
    var key = method.key, allowsDirectSuper = !1;
    return method.computed || method.static || !("Identifier" === key.type && "constructor" === key.name || "Literal" === key.type && "constructor" === key.value) ? method.static && "Identifier" === key.type && "prototype" === key.name && this.raise(key.start, "Classes may not have a static property named prototype") : ("method" !== method.kind && this.raise(key.start, "Constructor can't have get/set modifier"), 
    isGenerator && this.raise(key.start, "Constructor can't be a generator"), isAsync && this.raise(key.start, "Constructor can't be an async method"), 
    method.kind = "constructor", allowsDirectSuper = constructorAllowsSuper), this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper), 
    "get" === method.kind && 0 !== method.value.params.length && this.raiseRecoverable(method.value.start, "getter should have no params"), 
    "set" === method.kind && 1 !== method.value.params.length && this.raiseRecoverable(method.value.start, "setter should have exactly one param"), 
    "set" === method.kind && "RestElement" === method.value.params[0].type && this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"), 
    method;
  }, pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    return method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper), 
    this.finishNode(method, "MethodDefinition");
  }, pp$1.parseClassId = function(node, isStatement) {
    this.type === types.name ? (node.id = this.parseIdent(), isStatement && this.checkLVal(node.id, 2, !1)) : (!0 === isStatement && this.unexpected(), 
    node.id = null);
  }, pp$1.parseClassSuper = function(node) {
    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
  }, pp$1.parseExport = function(node, exports) {
    if (this.next(), this.eat(types.star)) return this.expectContextual("from"), this.type !== types.string && this.unexpected(), 
    node.source = this.parseExprAtom(), this.semicolon(), this.finishNode(node, "ExportAllDeclaration");
    if (this.eat(types._default)) {
      var isAsync;
      if (this.checkExport(exports, "default", this.lastTokStart), this.type === types._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next(), isAsync && this.next(), node.declaration = this.parseFunction(fNode, 4 | FUNC_STATEMENT, !1, isAsync);
      } else if (this.type === types._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else node.declaration = this.parseMaybeAssign(), this.semicolon();
      return this.finishNode(node, "ExportDefaultDeclaration");
    }
    if (this.shouldParseExportStatement()) node.declaration = this.parseStatement(null), 
    "VariableDeclaration" === node.declaration.type ? this.checkVariableExport(exports, node.declaration.declarations) : this.checkExport(exports, node.declaration.id.name, node.declaration.id.start), 
    node.specifiers = [], node.source = null; else {
      if (node.declaration = null, node.specifiers = this.parseExportSpecifiers(exports), 
      this.eatContextual("from")) this.type !== types.string && this.unexpected(), node.source = this.parseExprAtom(); else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];
          this.checkUnreserved(spec.local), this.checkLocalExport(spec.local);
        }
        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration");
  }, pp$1.checkExport = function(exports, name, pos) {
    exports && (has(exports, name) && this.raiseRecoverable(pos, "Duplicate export '" + name + "'"), 
    exports[name] = !0);
  }, pp$1.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if ("Identifier" === type) this.checkExport(exports, pat.name, pat.start); else if ("ObjectPattern" === type) for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports, prop);
    } else if ("ArrayPattern" === type) for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      elt && this.checkPatternExport(exports, elt);
    } else "Property" === type ? this.checkPatternExport(exports, pat.value) : "AssignmentPattern" === type ? this.checkPatternExport(exports, pat.left) : "RestElement" === type ? this.checkPatternExport(exports, pat.argument) : "ParenthesizedExpression" === type && this.checkPatternExport(exports, pat.expression);
  }, pp$1.checkVariableExport = function(exports, decls) {
    if (exports) for (var i = 0, list = decls; i < list.length; i += 1) {
      var decl = list[i];
      this.checkPatternExport(exports, decl.id);
    }
  }, pp$1.shouldParseExportStatement = function() {
    return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
  }, pp$1.parseExportSpecifiers = function(exports) {
    var nodes = [], first = !0;
    for (this.expect(types.braceL); !this.eat(types.braceR); ) {
      if (first) first = !1; else if (this.expect(types.comma), this.afterTrailingComma(types.braceR)) break;
      var node = this.startNode();
      node.local = this.parseIdent(!0), node.exported = this.eatContextual("as") ? this.parseIdent(!0) : node.local, 
      this.checkExport(exports, node.exported.name, node.exported.start), nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes;
  }, pp$1.parseImport = function(node) {
    return this.next(), this.type === types.string ? (node.specifiers = empty, node.source = this.parseExprAtom()) : (node.specifiers = this.parseImportSpecifiers(), 
    this.expectContextual("from"), node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected()), 
    this.semicolon(), this.finishNode(node, "ImportDeclaration");
  }, pp$1.parseImportSpecifiers = function() {
    var nodes = [], first = !0;
    if (this.type === types.name) {
      var node = this.startNode();
      if (node.local = this.parseIdent(), this.checkLVal(node.local, 2), nodes.push(this.finishNode(node, "ImportDefaultSpecifier")), 
      !this.eat(types.comma)) return nodes;
    }
    if (this.type === types.star) {
      var node$1 = this.startNode();
      return this.next(), this.expectContextual("as"), node$1.local = this.parseIdent(), 
      this.checkLVal(node$1.local, 2), nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier")), 
      nodes;
    }
    for (this.expect(types.braceL); !this.eat(types.braceR); ) {
      if (first) first = !1; else if (this.expect(types.comma), this.afterTrailingComma(types.braceR)) break;
      var node$2 = this.startNode();
      node$2.imported = this.parseIdent(!0), this.eatContextual("as") ? node$2.local = this.parseIdent() : (this.checkUnreserved(node$2.imported), 
      node$2.local = node$2.imported), this.checkLVal(node$2.local, 2), nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes;
  }, pp$1.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }, pp$1.isDirectiveCandidate = function(statement) {
    return "ExpressionStatement" === statement.type && "Literal" === statement.expression.type && "string" == typeof statement.expression.value && ('"' === this.input[statement.start] || "'" === this.input[statement.start]);
  };
  var pp$2 = Parser.prototype;
  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
     case "Identifier":
      this.inAsync && "await" === node.name && this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
      break;

     case "ObjectPattern":
     case "ArrayPattern":
     case "RestElement":
      break;

     case "ObjectExpression":
      node.type = "ObjectPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, !0);
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.toAssignable(prop, isBinding), "RestElement" !== prop.type || "ArrayPattern" !== prop.argument.type && "ObjectPattern" !== prop.argument.type || this.raise(prop.argument.start, "Unexpected token");
      }
      break;

     case "Property":
      "init" !== node.kind && this.raise(node.key.start, "Object pattern can't contain getter or setter"), 
      this.toAssignable(node.value, isBinding);
      break;

     case "ArrayExpression":
      node.type = "ArrayPattern", refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, !0), 
      this.toAssignableList(node.elements, isBinding);
      break;

     case "SpreadElement":
      node.type = "RestElement", this.toAssignable(node.argument, isBinding), "AssignmentPattern" === node.argument.type && this.raise(node.argument.start, "Rest elements cannot have a default value");
      break;

     case "AssignmentExpression":
      "=" !== node.operator && this.raise(node.left.end, "Only '=' operator can be used for specifying default value."), 
      node.type = "AssignmentPattern", delete node.operator, this.toAssignable(node.left, isBinding);

     case "AssignmentPattern":
      break;

     case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break;

     case "MemberExpression":
      if (!isBinding) break;

     default:
      this.raise(node.start, "Assigning to rvalue");
    } else refDestructuringErrors && this.checkPatternErrors(refDestructuringErrors, !0);
    return node;
  }, pp$2.toAssignableList = function(exprList, isBinding) {
    for (var end = exprList.length, i = 0; i < end; i++) {
      var elt = exprList[i];
      elt && this.toAssignable(elt, isBinding);
    }
    if (end) {
      var last = exprList[end - 1];
      6 === this.options.ecmaVersion && isBinding && last && "RestElement" === last.type && "Identifier" !== last.argument.type && this.unexpected(last.argument.start);
    }
    return exprList;
  }, pp$2.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    return this.next(), node.argument = this.parseMaybeAssign(!1, refDestructuringErrors), 
    this.finishNode(node, "SpreadElement");
  }, pp$2.parseRestBinding = function() {
    var node = this.startNode();
    return this.next(), 6 === this.options.ecmaVersion && this.type !== types.name && this.unexpected(), 
    node.argument = this.parseBindingAtom(), this.finishNode(node, "RestElement");
  }, pp$2.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) switch (this.type) {
     case types.bracketL:
      var node = this.startNode();
      return this.next(), node.elements = this.parseBindingList(types.bracketR, !0, !0), 
      this.finishNode(node, "ArrayPattern");

     case types.braceL:
      return this.parseObj(!0);
    }
    return this.parseIdent();
  }, pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    for (var elts = [], first = !0; !this.eat(close); ) if (first ? first = !1 : this.expect(types.comma), 
    allowEmpty && this.type === types.comma) elts.push(null); else {
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
      if (this.type === types.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest), elts.push(rest), this.type === types.comma && this.raise(this.start, "Comma is not permitted after the rest element"), 
        this.expect(close);
        break;
      }
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem), elts.push(elem);
    }
    return elts;
  }, pp$2.parseBindingListItem = function(param) {
    return param;
  }, pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
    if (left = left || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(types.eq)) return left;
    var node = this.startNodeAt(startPos, startLoc);
    return node.left = left, node.right = this.parseMaybeAssign(), this.finishNode(node, "AssignmentPattern");
  }, pp$2.checkLVal = function(expr, bindingType, checkClashes) {
    switch (void 0 === bindingType && (bindingType = 0), expr.type) {
     case "Identifier":
      2 === bindingType && "let" === expr.name && this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"), 
      this.strict && this.reservedWordsStrictBind.test(expr.name) && this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"), 
      checkClashes && (has(checkClashes, expr.name) && this.raiseRecoverable(expr.start, "Argument name clash"), 
      checkClashes[expr.name] = !0), 0 !== bindingType && 5 !== bindingType && this.declareName(expr.name, bindingType, expr.start);
      break;

     case "MemberExpression":
      bindingType && this.raiseRecoverable(expr.start, "Binding member expression");
      break;

     case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLVal(prop, bindingType, checkClashes);
      }
      break;

     case "Property":
      this.checkLVal(expr.value, bindingType, checkClashes);
      break;

     case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        elem && this.checkLVal(elem, bindingType, checkClashes);
      }
      break;

     case "AssignmentPattern":
      this.checkLVal(expr.left, bindingType, checkClashes);
      break;

     case "RestElement":
      this.checkLVal(expr.argument, bindingType, checkClashes);
      break;

     case "ParenthesizedExpression":
      this.checkLVal(expr.expression, bindingType, checkClashes);
      break;

     default:
      this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  var pp$3 = Parser.prototype;
  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === prop.type || this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))) {
      var name, key = prop.key;
      switch (key.type) {
       case "Identifier":
        name = key.name;
        break;

       case "Literal":
        name = String(key.value);
        break;

       default:
        return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) "__proto__" === name && "init" === kind && (propHash.proto && (refDestructuringErrors && refDestructuringErrors.doubleProto < 0 ? refDestructuringErrors.doubleProto = key.start : this.raiseRecoverable(key.start, "Redefinition of __proto__ property")), 
      propHash.proto = !0); else {
        var other = propHash[name = "$" + name];
        if (other) ("init" === kind ? this.strict && other.init || other.get || other.set : other.init || other[kind]) && this.raiseRecoverable(key.start, "Redefinition of property"); else other = propHash[name] = {
          init: !1,
          get: !1,
          set: !1
        };
        other[kind] = !0;
      }
    }
  }, pp$3.parseExpression = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
    if (this.type === types.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      for (node.expressions = [ expr ]; this.eat(types.comma); ) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
      return this.finishNode(node, "SequenceExpression");
    }
    return expr;
  }, pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) return this.parseYield(noIn);
      this.exprAllowed = !1;
    }
    var ownDestructuringErrors = !1, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
    refDestructuringErrors ? (oldParenAssign = refDestructuringErrors.parenthesizedAssign, 
    oldTrailingComma = refDestructuringErrors.trailingComma, oldShorthandAssign = refDestructuringErrors.shorthandAssign, 
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1) : (refDestructuringErrors = new DestructuringErrors, 
    ownDestructuringErrors = !0);
    var startPos = this.start, startLoc = this.startLoc;
    this.type !== types.parenL && this.type !== types.name || (this.potentialArrowAt = this.start);
    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
    if (afterLeftParse && (left = afterLeftParse.call(this, left, startPos, startLoc)), 
    this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      return node.operator = this.value, node.left = this.type === types.eq ? this.toAssignable(left, !1, refDestructuringErrors) : left, 
      ownDestructuringErrors || DestructuringErrors.call(refDestructuringErrors), refDestructuringErrors.shorthandAssign = -1, 
      this.checkLVal(left), this.next(), node.right = this.parseMaybeAssign(noIn), this.finishNode(node, "AssignmentExpression");
    }
    return ownDestructuringErrors && this.checkExpressionErrors(refDestructuringErrors, !0), 
    oldParenAssign > -1 && (refDestructuringErrors.parenthesizedAssign = oldParenAssign), 
    oldTrailingComma > -1 && (refDestructuringErrors.trailingComma = oldTrailingComma), 
    oldShorthandAssign > -1 && (refDestructuringErrors.shorthandAssign = oldShorthandAssign), 
    left;
  }, pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprOps(noIn, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    if (this.eat(types.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      return node.test = expr, node.consequent = this.parseMaybeAssign(), this.expect(types.colon), 
      node.alternate = this.parseMaybeAssign(noIn), this.finishNode(node, "ConditionalExpression");
    }
    return expr;
  }, pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc, expr = this.parseMaybeUnary(refDestructuringErrors, !1);
    return this.checkExpressionErrors(refDestructuringErrors) || expr.start === startPos && "ArrowFunctionExpression" === expr.type ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }, pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
    var prec = this.type.binop;
    if (null != prec && (!noIn || this.type !== types._in) && prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND, op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc, right = this.parseExprOp(this.parseMaybeUnary(null, !1), startPos, startLoc, prec, noIn), node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
    return left;
  }, pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    var node = this.startNodeAt(startPos, startLoc);
    return node.left = left, node.operator = op, node.right = right, this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
  }, pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
    var expr, startPos = this.start, startLoc = this.startLoc;
    if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) expr = this.parseAwait(), 
    sawUnary = !0; else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types.incDec;
      node.operator = this.value, node.prefix = !0, this.next(), node.argument = this.parseMaybeUnary(null, !0), 
      this.checkExpressionErrors(refDestructuringErrors, !0), update ? this.checkLVal(node.argument) : this.strict && "delete" === node.operator && "Identifier" === node.argument.type ? this.raiseRecoverable(node.start, "Deleting local variable in strict mode") : sawUnary = !0, 
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else {
      if (expr = this.parseExprSubscripts(refDestructuringErrors), this.checkExpressionErrors(refDestructuringErrors)) return expr;
      for (;this.type.postfix && !this.canInsertSemicolon(); ) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value, node$1.prefix = !1, node$1.argument = expr, this.checkLVal(expr), 
        this.next(), expr = this.finishNode(node$1, "UpdateExpression");
      }
    }
    return !sawUnary && this.eat(types.starstar) ? this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, !1), "**", !1) : expr;
  }, pp$3.parseExprSubscripts = function(refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc, expr = this.parseExprAtom(refDestructuringErrors), skipArrowSubscripts = "ArrowFunctionExpression" === expr.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd);
    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
    var result = this.parseSubscripts(expr, startPos, startLoc);
    return refDestructuringErrors && "MemberExpression" === result.type && (refDestructuringErrors.parenthesizedAssign >= result.start && (refDestructuringErrors.parenthesizedAssign = -1), 
    refDestructuringErrors.parenthesizedBind >= result.start && (refDestructuringErrors.parenthesizedBind = -1)), 
    result;
  }, pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
    for (var maybeAsyncArrow = this.options.ecmaVersion >= 8 && "Identifier" === base.type && "async" === base.name && this.lastTokEnd === base.end && !this.canInsertSemicolon() && "async" === this.input.slice(base.start, base.end); ;) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
      if (element === base || "ArrowFunctionExpression" === element.type) return element;
      base = element;
    }
  }, pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
    var computed = this.eat(types.bracketL);
    if (computed || this.eat(types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base, node.property = computed ? this.parseExpression() : this.parseIdent("never" !== this.options.allowReserved), 
      node.computed = !!computed, computed && this.expect(types.bracketR), base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && "Import" !== base.type, !1, refDestructuringErrors);
      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) return this.checkPatternErrors(refDestructuringErrors, !1), 
      this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), 
      this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
      this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, !0);
      this.checkExpressionErrors(refDestructuringErrors, !0), this.yieldPos = oldYieldPos || this.yieldPos, 
      this.awaitPos = oldAwaitPos || this.awaitPos, this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      if (node$1.callee = base, node$1.arguments = exprList, "Import" === node$1.callee.type) {
        1 !== node$1.arguments.length && this.raise(node$1.start, "import() requires exactly one argument");
        var importArg = node$1.arguments[0];
        importArg && "SpreadElement" === importArg.type && this.raise(importArg.start, "... is not allowed in import()");
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types.backQuote) {
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base, node$2.quasi = this.parseTemplate({
        isTagged: !0
      }), base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
  }, pp$3.parseExprAtom = function(refDestructuringErrors) {
    this.type === types.slash && this.readRegexp();
    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
     case types._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), 
      node = this.startNode(), this.next(), this.type !== types.parenL || this.allowDirectSuper || this.raise(node.start, "super() call outside constructor of a subclass"), 
      this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL && this.unexpected(), 
      this.finishNode(node, "Super");

     case types._this:
      return node = this.startNode(), this.next(), this.finishNode(node, "ThisExpression");

     case types.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc, id = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !containsEsc && "async" === id.name && !this.canInsertSemicolon() && this.eat(types._function)) return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, !1, !0);
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [ id ], !1);
        if (this.options.ecmaVersion >= 8 && "async" === id.name && this.type === types.name && !containsEsc) return id = this.parseIdent(!1), 
        !this.canInsertSemicolon() && this.eat(types.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [ id ], !0);
      }
      return id;

     case types.regexp:
      var value = this.value;
      return (node = this.parseLiteral(value.value)).regex = {
        pattern: value.pattern,
        flags: value.flags
      }, node;

     case types.num:
     case types.string:
      return this.parseLiteral(this.value);

     case types._null:
     case types._true:
     case types._false:
      return (node = this.startNode()).value = this.type === types._null ? null : this.type === types._true, 
      node.raw = this.type.keyword, this.next(), this.finishNode(node, "Literal");

     case types.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
      return refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr) && (refDestructuringErrors.parenthesizedAssign = start), 
      refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = start)), 
      expr;

     case types.bracketL:
      return node = this.startNode(), this.next(), node.elements = this.parseExprList(types.bracketR, !0, !0, refDestructuringErrors), 
      this.finishNode(node, "ArrayExpression");

     case types.braceL:
      return this.parseObj(!1, refDestructuringErrors);

     case types._function:
      return node = this.startNode(), this.next(), this.parseFunction(node, 0);

     case types._class:
      return this.parseClass(this.startNode(), !1);

     case types._new:
      return this.parseNew();

     case types.backQuote:
      return this.parseTemplate();

     case types._import:
      return this.options.ecmaVersion > 10 ? this.parseDynamicImport() : this.unexpected();

     default:
      this.unexpected();
    }
  }, pp$3.parseDynamicImport = function() {
    var node = this.startNode();
    return this.next(), this.type !== types.parenL && this.unexpected(), this.finishNode(node, "Import");
  }, pp$3.parseLiteral = function(value) {
    var node = this.startNode();
    return node.value = value, node.raw = this.input.slice(this.start, this.end), 110 === node.raw.charCodeAt(node.raw.length - 1) && (node.bigint = node.raw.slice(0, -1)), 
    this.next(), this.finishNode(node, "Literal");
  }, pp$3.parseParenExpression = function() {
    this.expect(types.parenL);
    var val = this.parseExpression();
    return this.expect(types.parenR), val;
  }, pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
    var val, startPos = this.start, startLoc = this.startLoc, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var spreadStart, innerStartPos = this.start, innerStartLoc = this.startLoc, exprList = [], first = !0, lastIsComma = !1, refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos;
      for (this.yieldPos = 0, this.awaitPos = 0; this.type !== types.parenR; ) {
        if (first ? first = !1 : this.expect(types.comma), allowTrailingComma && this.afterTrailingComma(types.parenR, !0)) {
          lastIsComma = !0;
          break;
        }
        if (this.type === types.ellipsis) {
          spreadStart = this.start, exprList.push(this.parseParenItem(this.parseRestBinding())), 
          this.type === types.comma && this.raise(this.start, "Comma is not permitted after the rest element");
          break;
        }
        exprList.push(this.parseMaybeAssign(!1, refDestructuringErrors, this.parseParenItem));
      }
      var innerEndPos = this.start, innerEndLoc = this.startLoc;
      if (this.expect(types.parenR), canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) return this.checkPatternErrors(refDestructuringErrors, !1), 
      this.checkYieldAwaitInDefaultParams(), this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, 
      this.parseParenArrowList(startPos, startLoc, exprList);
      exprList.length && !lastIsComma || this.unexpected(this.lastTokStart), spreadStart && this.unexpected(spreadStart), 
      this.checkExpressionErrors(refDestructuringErrors, !0), this.yieldPos = oldYieldPos || this.yieldPos, 
      this.awaitPos = oldAwaitPos || this.awaitPos, exprList.length > 1 ? ((val = this.startNodeAt(innerStartPos, innerStartLoc)).expressions = exprList, 
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)) : val = exprList[0];
    } else val = this.parseParenExpression();
    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      return par.expression = val, this.finishNode(par, "ParenthesizedExpression");
    }
    return val;
  }, pp$3.parseParenItem = function(item) {
    return item;
  }, pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
  };
  var empty$1 = [];
  pp$3.parseNew = function() {
    var node = this.startNode(), meta = this.parseIdent(!0);
    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      return node.property = this.parseIdent(!0), ("target" !== node.property.name || containsEsc) && this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"), 
      this.inNonArrowFunction() || this.raiseRecoverable(node.start, "new.target can only be used in functions"), 
      this.finishNode(node, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc;
    return node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, !0), 
    this.options.ecmaVersion > 10 && "Import" === node.callee.type && this.raise(node.callee.start, "Cannot use new with import(...)"), 
    this.eat(types.parenL) ? node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && "Import" !== node.callee.type, !1) : node.arguments = empty$1, 
    this.finishNode(node, "NewExpression");
  }, pp$3.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged, elem = this.startNode();
    return this.type === types.invalidTemplate ? (isTagged || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), 
    elem.value = {
      raw: this.value,
      cooked: null
    }) : elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    }, this.next(), elem.tail = this.type === types.backQuote, this.finishNode(elem, "TemplateElement");
  }, pp$3.parseTemplate = function(ref) {
    void 0 === ref && (ref = {});
    var isTagged = ref.isTagged;
    void 0 === isTagged && (isTagged = !1);
    var node = this.startNode();
    this.next(), node.expressions = [];
    var curElt = this.parseTemplateElement({
      isTagged: isTagged
    });
    for (node.quasis = [ curElt ]; !curElt.tail; ) this.type === types.eof && this.raise(this.pos, "Unterminated template literal"), 
    this.expect(types.dollarBraceL), node.expressions.push(this.parseExpression()), 
    this.expect(types.braceR), node.quasis.push(curElt = this.parseTemplateElement({
      isTagged: isTagged
    }));
    return this.next(), this.finishNode(node, "TemplateLiteral");
  }, pp$3.isAsyncProp = function(prop) {
    return !prop.computed && "Identifier" === prop.key.type && "async" === prop.key.name && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }, pp$3.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = !0, propHash = {};
    for (node.properties = [], this.next(); !this.eat(types.braceR); ) {
      if (first) first = !1; else if (this.expect(types.comma), this.afterTrailingComma(types.braceR)) break;
      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      isPattern || this.checkPropClash(prop, propHash, refDestructuringErrors), node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
  }, pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
    var isGenerator, isAsync, startPos, startLoc, prop = this.startNode();
    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) return isPattern ? (prop.argument = this.parseIdent(!1), 
    this.type === types.comma && this.raise(this.start, "Comma is not permitted after the rest element"), 
    this.finishNode(prop, "RestElement")) : (this.type === types.parenL && refDestructuringErrors && (refDestructuringErrors.parenthesizedAssign < 0 && (refDestructuringErrors.parenthesizedAssign = this.start), 
    refDestructuringErrors.parenthesizedBind < 0 && (refDestructuringErrors.parenthesizedBind = this.start)), 
    prop.argument = this.parseMaybeAssign(!1, refDestructuringErrors), this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start), 
    this.finishNode(prop, "SpreadElement"));
    this.options.ecmaVersion >= 6 && (prop.method = !1, prop.shorthand = !1, (isPattern || refDestructuringErrors) && (startPos = this.start, 
    startLoc = this.startLoc), isPattern || (isGenerator = this.eat(types.star)));
    var containsEsc = this.containsEsc;
    return this.parsePropertyName(prop), !isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop) ? (isAsync = !0, 
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star), this.parsePropertyName(prop, refDestructuringErrors)) : isAsync = !1, 
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc), 
    this.finishNode(prop, "Property");
  }, pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types.colon && this.unexpected(), 
    this.eat(types.colon)) prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, refDestructuringErrors), 
    prop.kind = "init"; else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) isPattern && this.unexpected(), 
    prop.kind = "init", prop.method = !0, prop.value = this.parseMethod(isGenerator, isAsync); else if (isPattern || containsEsc || !(this.options.ecmaVersion >= 5) || prop.computed || "Identifier" !== prop.key.type || "get" !== prop.key.name && "set" !== prop.key.name || this.type === types.comma || this.type === types.braceR) this.options.ecmaVersion >= 6 && !prop.computed && "Identifier" === prop.key.type ? ((isGenerator || isAsync) && this.unexpected(), 
    this.checkUnreserved(prop.key), "await" !== prop.key.name || this.awaitIdentPos || (this.awaitIdentPos = startPos), 
    prop.kind = "init", isPattern ? prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key) : this.type === types.eq && refDestructuringErrors ? (refDestructuringErrors.shorthandAssign < 0 && (refDestructuringErrors.shorthandAssign = this.start), 
    prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)) : prop.value = prop.key, 
    prop.shorthand = !0) : this.unexpected(); else {
      (isGenerator || isAsync) && this.unexpected(), prop.kind = prop.key.name, this.parsePropertyName(prop), 
      prop.value = this.parseMethod(!1);
      var paramCount = "get" === prop.kind ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        "get" === prop.kind ? this.raiseRecoverable(start, "getter should have no params") : this.raiseRecoverable(start, "setter should have exactly one param");
      } else "set" === prop.kind && "RestElement" === prop.value.params[0].type && this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }, pp$3.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types.bracketL)) return prop.computed = !0, prop.key = this.parseMaybeAssign(), 
      this.expect(types.bracketR), prop.key;
      prop.computed = !1;
    }
    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
  }, pp$3.initFunction = function(node) {
    node.id = null, this.options.ecmaVersion >= 6 && (node.generator = node.expression = !1), 
    this.options.ecmaVersion >= 8 && (node.async = !1);
  }, pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    return this.initFunction(node), this.options.ecmaVersion >= 6 && (node.generator = isGenerator), 
    this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, 
    this.awaitIdentPos = 0, this.enterScope(64 | functionFlags(isAsync, node.generator) | (allowDirectSuper ? 128 : 0)), 
    this.expect(types.parenL), node.params = this.parseBindingList(types.parenR, !1, this.options.ecmaVersion >= 8), 
    this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(node, !1, !0), this.yieldPos = oldYieldPos, 
    this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, this.finishNode(node, "FunctionExpression");
  }, pp$3.parseArrowExpression = function(node, params, isAsync) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    return this.enterScope(16 | functionFlags(isAsync, !1)), this.initFunction(node), 
    this.options.ecmaVersion >= 8 && (node.async = !!isAsync), this.yieldPos = 0, this.awaitPos = 0, 
    this.awaitIdentPos = 0, node.params = this.toAssignableList(params, !0), this.parseFunctionBody(node, !0, !1), 
    this.yieldPos = oldYieldPos, this.awaitPos = oldAwaitPos, this.awaitIdentPos = oldAwaitIdentPos, 
    this.finishNode(node, "ArrowFunctionExpression");
  }, pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
    var isExpression = isArrowFunction && this.type !== types.braceL, oldStrict = this.strict, useStrict = !1;
    if (isExpression) node.body = this.parseMaybeAssign(), node.expression = !0, this.checkParams(node, !1); else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      oldStrict && !nonSimple || (useStrict = this.strictDirective(this.end)) && nonSimple && this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      var oldLabels = this.labels;
      this.labels = [], useStrict && (this.strict = !0), this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params)), 
      node.body = this.parseBlock(!1), node.expression = !1, this.adaptDirectivePrologue(node.body.body), 
      this.labels = oldLabels;
    }
    this.exitScope(), this.strict && node.id && this.checkLVal(node.id, 5), this.strict = oldStrict;
  }, pp$3.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1) {
      if ("Identifier" !== list[i].type) return !1;
    }
    return !0;
  }, pp$3.checkParams = function(node, allowDuplicates) {
    for (var nameHash = {}, i = 0, list = node.params; i < list.length; i += 1) {
      var param = list[i];
      this.checkLVal(param, 1, allowDuplicates ? null : nameHash);
    }
  }, pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    for (var elts = [], first = !0; !this.eat(close); ) {
      if (first) first = !1; else if (this.expect(types.comma), allowTrailingComma && this.afterTrailingComma(close)) break;
      var elt = void 0;
      allowEmpty && this.type === types.comma ? elt = null : this.type === types.ellipsis ? (elt = this.parseSpread(refDestructuringErrors), 
      refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0 && (refDestructuringErrors.trailingComma = this.start)) : elt = this.parseMaybeAssign(!1, refDestructuringErrors), 
      elts.push(elt);
    }
    return elts;
  }, pp$3.checkUnreserved = function(ref) {
    var start = ref.start, end = ref.end, name = ref.name;
    (this.inGenerator && "yield" === name && this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"), 
    this.inAsync && "await" === name && this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"), 
    this.keywords.test(name) && this.raise(start, "Unexpected keyword '" + name + "'"), 
    this.options.ecmaVersion < 6 && -1 !== this.input.slice(start, end).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(name) && (this.inAsync || "await" !== name || this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"), 
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved"));
  }, pp$3.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    return this.type === types.name ? node.name = this.value : this.type.keyword ? (node.name = this.type.keyword, 
    "class" !== node.name && "function" !== node.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), 
    this.next(), this.finishNode(node, "Identifier"), liberal || (this.checkUnreserved(node), 
    "await" !== node.name || this.awaitIdentPos || (this.awaitIdentPos = node.start)), 
    node;
  }, pp$3.parseYield = function(noIn) {
    this.yieldPos || (this.yieldPos = this.start);
    var node = this.startNode();
    return this.next(), this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr ? (node.delegate = !1, 
    node.argument = null) : (node.delegate = this.eat(types.star), node.argument = this.parseMaybeAssign(noIn)), 
    this.finishNode(node, "YieldExpression");
  }, pp$3.parseAwait = function() {
    this.awaitPos || (this.awaitPos = this.start);
    var node = this.startNode();
    return this.next(), node.argument = this.parseMaybeUnary(null, !0), this.finishNode(node, "AwaitExpression");
  };
  var pp$4 = Parser.prototype;
  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    throw err.pos = pos, err.loc = loc, err.raisedAt = this.pos, err;
  }, pp$4.raiseRecoverable = pp$4.raise, pp$4.curPosition = function() {
    if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
  };
  var pp$5 = Parser.prototype, Scope = function(flags) {
    this.flags = flags, this.var = [], this.lexical = [], this.functions = [];
  };
  pp$5.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  }, pp$5.exitScope = function() {
    this.scopeStack.pop();
  }, pp$5.treatFunctionsAsVarInScope = function(scope) {
    return 2 & scope.flags || !this.inModule && 1 & scope.flags;
  }, pp$5.declareName = function(name, bindingType, pos) {
    var redeclared = !1;
    if (2 === bindingType) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1, 
      scope.lexical.push(name), this.inModule && 1 & scope.flags && delete this.undefinedExports[name];
    } else if (4 === bindingType) {
      this.currentScope().lexical.push(name);
    } else if (3 === bindingType) {
      var scope$2 = this.currentScope();
      redeclared = this.treatFunctionsAsVar ? scope$2.lexical.indexOf(name) > -1 : scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1, 
      scope$2.functions.push(name);
    } else for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(32 & scope$3.flags && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = !0;
        break;
      }
      if (scope$3.var.push(name), this.inModule && 1 & scope$3.flags && delete this.undefinedExports[name], 
      3 & scope$3.flags) break;
    }
    redeclared && this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }, pp$5.checkLocalExport = function(id) {
    -1 === this.scopeStack[0].lexical.indexOf(id.name) && -1 === this.scopeStack[0].var.indexOf(id.name) && (this.undefinedExports[id.name] = id);
  }, pp$5.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  }, pp$5.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1; ;i--) {
      var scope = this.scopeStack[i];
      if (3 & scope.flags) return scope;
    }
  }, pp$5.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1; ;i--) {
      var scope = this.scopeStack[i];
      if (3 & scope.flags && !(16 & scope.flags)) return scope;
    }
  };
  var Node = function(parser, pos, loc) {
    this.type = "", this.start = pos, this.end = 0, parser.options.locations && (this.loc = new SourceLocation(parser, loc)), 
    parser.options.directSourceFile && (this.sourceFile = parser.options.directSourceFile), 
    parser.options.ranges && (this.range = [ pos, 0 ]);
  }, pp$6 = Parser.prototype;
  function finishNodeAt(node, type, pos, loc) {
    return node.type = type, node.end = pos, this.options.locations && (node.loc.end = loc), 
    this.options.ranges && (node.range[1] = pos), node;
  }
  pp$6.startNode = function() {
    return new Node(this, this.start, this.startLoc);
  }, pp$6.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc);
  }, pp$6.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
  }, pp$6.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc);
  };
  var TokContext = function(token, isExpr, preserveSpace, override, generator) {
    this.token = token, this.isExpr = !!isExpr, this.preserveSpace = !!preserveSpace, 
    this.override = override, this.generator = !!generator;
  }, types$1 = {
    b_stat: new TokContext("{", !1),
    b_expr: new TokContext("{", !0),
    b_tmpl: new TokContext("${", !1),
    p_stat: new TokContext("(", !1),
    p_expr: new TokContext("(", !0),
    q_tmpl: new TokContext("`", !0, !0, (function(p) {
      return p.tryReadTemplateToken();
    })),
    f_stat: new TokContext("function", !1),
    f_expr: new TokContext("function", !0),
    f_expr_gen: new TokContext("function", !0, !1, null, !0),
    f_gen: new TokContext("function", !1, !1, null, !0)
  }, pp$7 = Parser.prototype;
  pp$7.initialContext = function() {
    return [ types$1.b_stat ];
  }, pp$7.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    return parent === types$1.f_expr || parent === types$1.f_stat || (prevType !== types.colon || parent !== types$1.b_stat && parent !== types$1.b_expr ? prevType === types._return || prevType === types.name && this.exprAllowed ? lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) : prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow || (prevType === types.braceL ? parent === types$1.b_stat : prevType !== types._var && prevType !== types._const && prevType !== types.name && !this.exprAllowed) : !parent.isExpr);
  }, pp$7.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if ("function" === context.token) return context.generator;
    }
    return !1;
  }, pp$7.updateContext = function(prevType) {
    var update, type = this.type;
    type.keyword && prevType === types.dot ? this.exprAllowed = !1 : (update = type.updateContext) ? update.call(this, prevType) : this.exprAllowed = type.beforeExpr;
  }, types.parenR.updateContext = types.braceR.updateContext = function() {
    if (1 !== this.context.length) {
      var out = this.context.pop();
      out === types$1.b_stat && "function" === this.curContext().token && (out = this.context.pop()), 
      this.exprAllowed = !out.isExpr;
    } else this.exprAllowed = !0;
  }, types.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr), 
    this.exprAllowed = !0;
  }, types.dollarBraceL.updateContext = function() {
    this.context.push(types$1.b_tmpl), this.exprAllowed = !0;
  }, types.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr), this.exprAllowed = !0;
  }, types.incDec.updateContext = function() {}, types._function.updateContext = types._class.updateContext = function(prevType) {
    !prevType.beforeExpr || prevType === types.semi || prevType === types._else || prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) || (prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat ? this.context.push(types$1.f_stat) : this.context.push(types$1.f_expr), 
    this.exprAllowed = !1;
  }, types.backQuote.updateContext = function() {
    this.curContext() === types$1.q_tmpl ? this.context.pop() : this.context.push(types$1.q_tmpl), 
    this.exprAllowed = !1;
  }, types.star.updateContext = function(prevType) {
    if (prevType === types._function) {
      var index = this.context.length - 1;
      this.context[index] === types$1.f_expr ? this.context[index] = types$1.f_expr_gen : this.context[index] = types$1.f_gen;
    }
    this.exprAllowed = !0;
  }, types.name.updateContext = function(prevType) {
    var allowed = !1;
    this.options.ecmaVersion >= 6 && prevType !== types.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (allowed = !0), 
    this.exprAllowed = allowed;
  };
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic", unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS Extended_Pictographic"
  }, unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho"
  }, data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script, d.nonBinary.gc = d.nonBinary.General_Category, 
    d.nonBinary.sc = d.nonBinary.Script, d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  buildUnicodeData(9), buildUnicodeData(10), buildUnicodeData(11);
  var pp$8 = Parser.prototype, RegExpValidationState = function(parser) {
    this.parser = parser, this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : ""), 
    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion], 
    this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, 
    this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, 
    this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
  };
  function codePointToString(ch) {
    return ch <= 65535 ? String.fromCharCode(ch) : (ch -= 65536, String.fromCharCode(55296 + (ch >> 10), 56320 + (1023 & ch)));
  }
  function isSyntaxCharacter(ch) {
    return 36 === ch || ch >= 40 && ch <= 43 || 46 === ch || 63 === ch || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
  }
  function isControlLetter(ch) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
  }
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || 95 === ch;
  }
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
  }
  function isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  function isHexDigit(ch) {
    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
  }
  function hexToInt(ch) {
    return ch >= 65 && ch <= 70 ? ch - 65 + 10 : ch >= 97 && ch <= 102 ? ch - 97 + 10 : ch - 48;
  }
  function isOctalDigit(ch) {
    return ch >= 48 && ch <= 55;
  }
  RegExpValidationState.prototype.reset = function(start, pattern, flags) {
    var unicode = -1 !== flags.indexOf("u");
    this.start = 0 | start, this.source = pattern + "", this.flags = flags, this.switchU = unicode && this.parser.options.ecmaVersion >= 6, 
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }, RegExpValidationState.prototype.raise = function(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
  }, RegExpValidationState.prototype.at = function(i) {
    var s = this.source, l = s.length;
    if (i >= l) return -1;
    var c = s.charCodeAt(i);
    if (!this.switchU || c <= 55295 || c >= 57344 || i + 1 >= l) return c;
    var next = s.charCodeAt(i + 1);
    return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
  }, RegExpValidationState.prototype.nextIndex = function(i) {
    var s = this.source, l = s.length;
    if (i >= l) return l;
    var next, c = s.charCodeAt(i);
    return !this.switchU || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343 ? i + 1 : i + 2;
  }, RegExpValidationState.prototype.current = function() {
    return this.at(this.pos);
  }, RegExpValidationState.prototype.lookahead = function() {
    return this.at(this.nextIndex(this.pos));
  }, RegExpValidationState.prototype.advance = function() {
    this.pos = this.nextIndex(this.pos);
  }, RegExpValidationState.prototype.eat = function(ch) {
    return this.current() === ch && (this.advance(), !0);
  }, pp$8.validateRegExpFlags = function(state) {
    for (var validFlags = state.validFlags, flags = state.flags, i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      -1 === validFlags.indexOf(flag) && this.raise(state.start, "Invalid regular expression flag"), 
      flags.indexOf(flag, i + 1) > -1 && this.raise(state.start, "Duplicate regular expression flag");
    }
  }, pp$8.validateRegExpPattern = function(state) {
    this.regexp_pattern(state), !state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0 && (state.switchN = !0, 
    this.regexp_pattern(state));
  }, pp$8.regexp_pattern = function(state) {
    state.pos = 0, state.lastIntValue = 0, state.lastStringValue = "", state.lastAssertionIsQuantifiable = !1, 
    state.numCapturingParens = 0, state.maxBackReference = 0, state.groupNames.length = 0, 
    state.backReferenceNames.length = 0, this.regexp_disjunction(state), state.pos !== state.source.length && (state.eat(41) && state.raise("Unmatched ')'"), 
    (state.eat(93) || state.eat(125)) && state.raise("Lone quantifier brackets")), state.maxBackReference > state.numCapturingParens && state.raise("Invalid escape");
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];
      -1 === state.groupNames.indexOf(name) && state.raise("Invalid named capture referenced");
    }
  }, pp$8.regexp_disjunction = function(state) {
    for (this.regexp_alternative(state); state.eat(124); ) this.regexp_alternative(state);
    this.regexp_eatQuantifier(state, !0) && state.raise("Nothing to repeat"), state.eat(123) && state.raise("Lone quantifier brackets");
  }, pp$8.regexp_alternative = function(state) {
    for (;state.pos < state.source.length && this.regexp_eatTerm(state); ) ;
  }, pp$8.regexp_eatTerm = function(state) {
    return this.regexp_eatAssertion(state) ? (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state) && state.switchU && state.raise("Invalid quantifier"), 
    !0) : !!(state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) && (this.regexp_eatQuantifier(state), 
    !0);
  }, pp$8.regexp_eatAssertion = function(state) {
    var start = state.pos;
    if (state.lastAssertionIsQuantifiable = !1, state.eat(94) || state.eat(36)) return !0;
    if (state.eat(92)) {
      if (state.eat(66) || state.eat(98)) return !0;
      state.pos = start;
    }
    if (state.eat(40) && state.eat(63)) {
      var lookbehind = !1;
      if (this.options.ecmaVersion >= 9 && (lookbehind = state.eat(60)), state.eat(61) || state.eat(33)) return this.regexp_disjunction(state), 
      state.eat(41) || state.raise("Unterminated group"), state.lastAssertionIsQuantifiable = !lookbehind, 
      !0;
    }
    return state.pos = start, !1;
  }, pp$8.regexp_eatQuantifier = function(state, noError) {
    return void 0 === noError && (noError = !1), !!this.regexp_eatQuantifierPrefix(state, noError) && (state.eat(63), 
    !0);
  }, pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
  }, pp$8.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(123)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state) && (min = state.lastIntValue, state.eat(44) && this.regexp_eatDecimalDigits(state) && (max = state.lastIntValue), 
      state.eat(125))) return -1 !== max && max < min && !noError && state.raise("numbers out of order in {} quantifier"), 
      !0;
      state.switchU && !noError && state.raise("Incomplete quantifier"), state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
  }, pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatAtomEscape(state)) return !0;
      state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(40)) {
      if (state.eat(63) && state.eat(58)) {
        if (this.regexp_disjunction(state), state.eat(41)) return !0;
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatCapturingGroup = function(state) {
    if (state.eat(40)) {
      if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(state) : 63 === state.current() && state.raise("Invalid group"), 
      this.regexp_disjunction(state), state.eat(41)) return state.numCapturingParens += 1, 
      !0;
      state.raise("Unterminated group");
    }
    return !1;
  }, pp$8.regexp_eatExtendedAtom = function(state) {
    return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
  }, pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
    return this.regexp_eatBracedQuantifier(state, !0) && state.raise("Nothing to repeat"), 
    !1;
  }, pp$8.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    return !!isSyntaxCharacter(ch) && (state.lastIntValue = ch, state.advance(), !0);
  }, pp$8.regexp_eatPatternCharacters = function(state) {
    for (var start = state.pos, ch = 0; -1 !== (ch = state.current()) && !isSyntaxCharacter(ch); ) state.advance();
    return state.pos !== start;
  }, pp$8.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    return !(-1 === ch || 36 === ch || ch >= 40 && ch <= 43 || 46 === ch || 63 === ch || 91 === ch || 94 === ch || 124 === ch) && (state.advance(), 
    !0);
  }, pp$8.regexp_groupSpecifier = function(state) {
    if (state.eat(63)) {
      if (this.regexp_eatGroupName(state)) return -1 !== state.groupNames.indexOf(state.lastStringValue) && state.raise("Duplicate capture group name"), 
      void state.groupNames.push(state.lastStringValue);
      state.raise("Invalid group");
    }
  }, pp$8.regexp_eatGroupName = function(state) {
    if (state.lastStringValue = "", state.eat(60)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return !0;
      state.raise("Invalid capture group name");
    }
    return !1;
  }, pp$8.regexp_eatRegExpIdentifierName = function(state) {
    if (state.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(state)) {
      for (state.lastStringValue += codePointToString(state.lastIntValue); this.regexp_eatRegExpIdentifierPart(state); ) state.lastStringValue += codePointToString(state.lastIntValue);
      return !0;
    }
    return !1;
  }, pp$8.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos, ch = state.current();
    return state.advance(), 92 === ch && this.regexp_eatRegExpUnicodeEscapeSequence(state) && (ch = state.lastIntValue), 
    function(ch) {
      return isIdentifierStart(ch, !0) || 36 === ch || 95 === ch;
    }(ch) ? (state.lastIntValue = ch, !0) : (state.pos = start, !1);
  }, pp$8.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos, ch = state.current();
    return state.advance(), 92 === ch && this.regexp_eatRegExpUnicodeEscapeSequence(state) && (ch = state.lastIntValue), 
    function(ch) {
      return isIdentifierChar(ch, !0) || 36 === ch || 95 === ch || 8204 === ch || 8205 === ch;
    }(ch) ? (state.lastIntValue = ch, !0) : (state.pos = start, !1);
  }, pp$8.regexp_eatAtomEscape = function(state) {
    return !!(this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) || (state.switchU && (99 === state.current() && state.raise("Invalid unicode escape"), 
    state.raise("Invalid escape")), !1);
  }, pp$8.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) return n > state.maxBackReference && (state.maxBackReference = n), 
      !0;
      if (n <= state.numCapturingParens) return !0;
      state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatKGroupName = function(state) {
    if (state.eat(107)) {
      if (this.regexp_eatGroupName(state)) return state.backReferenceNames.push(state.lastStringValue), 
      !0;
      state.raise("Invalid named reference");
    }
    return !1;
  }, pp$8.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
  }, pp$8.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(99)) {
      if (this.regexp_eatControlLetter(state)) return !0;
      state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatZero = function(state) {
    return 48 === state.current() && !isDecimalDigit(state.lookahead()) && (state.lastIntValue = 0, 
    state.advance(), !0);
  }, pp$8.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    return 116 === ch ? (state.lastIntValue = 9, state.advance(), !0) : 110 === ch ? (state.lastIntValue = 10, 
    state.advance(), !0) : 118 === ch ? (state.lastIntValue = 11, state.advance(), !0) : 102 === ch ? (state.lastIntValue = 12, 
    state.advance(), !0) : 114 === ch && (state.lastIntValue = 13, state.advance(), 
    !0);
  }, pp$8.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    return !!isControlLetter(ch) && (state.lastIntValue = ch % 32, state.advance(), 
    !0);
  }, pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
    var ch, start = state.pos;
    if (state.eat(117)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (state.switchU && lead >= 55296 && lead <= 56319) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 56320 && trail <= 57343) return state.lastIntValue = 1024 * (lead - 55296) + (trail - 56320) + 65536, 
            !0;
          }
          state.pos = leadSurrogateEnd, state.lastIntValue = lead;
        }
        return !0;
      }
      if (state.switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && ((ch = state.lastIntValue) >= 0 && ch <= 1114111)) return !0;
      state.switchU && state.raise("Invalid unicode escape"), state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) return !!this.regexp_eatSyntaxCharacter(state) || !!state.eat(47) && (state.lastIntValue = 47, 
    !0);
    var ch = state.current();
    return !(99 === ch || state.switchN && 107 === ch) && (state.lastIntValue = ch, 
    state.advance(), !0);
  }, pp$8.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 49 && ch <= 57) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48), state.advance();
      } while ((ch = state.current()) >= 48 && ch <= 57);
      return !0;
    }
    return !1;
  }, pp$8.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();
    if (function(ch) {
      return 100 === ch || 68 === ch || 115 === ch || 83 === ch || 119 === ch || 87 === ch;
    }(ch)) return state.lastIntValue = -1, state.advance(), !0;
    if (state.switchU && this.options.ecmaVersion >= 9 && (80 === ch || 112 === ch)) {
      if (state.lastIntValue = -1, state.advance(), state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) return !0;
      state.raise("Invalid property name");
    }
    return !1;
  }, pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        return this.regexp_validateUnicodePropertyNameAndValue(state, name, value), !0;
      }
    }
    if (state.pos = start, this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue), !0;
    }
    return !1;
  }, pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    has(state.unicodeProperties.nonBinary, name) || state.raise("Invalid property name"), 
    state.unicodeProperties.nonBinary[name].test(value) || state.raise("Invalid property value");
  }, pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    state.unicodeProperties.binary.test(nameOrValue) || state.raise("Invalid property name");
  }, pp$8.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    for (state.lastStringValue = ""; isUnicodePropertyNameCharacter(ch = state.current()); ) state.lastStringValue += codePointToString(ch), 
    state.advance();
    return "" !== state.lastStringValue;
  }, pp$8.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    for (state.lastStringValue = ""; isUnicodePropertyValueCharacter(ch = state.current()); ) state.lastStringValue += codePointToString(ch), 
    state.advance();
    return "" !== state.lastStringValue;
  }, pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
  }, pp$8.regexp_eatCharacterClass = function(state) {
    if (state.eat(91)) {
      if (state.eat(94), this.regexp_classRanges(state), state.eat(93)) return !0;
      state.raise("Unterminated character class");
    }
    return !1;
  }, pp$8.regexp_classRanges = function(state) {
    for (;this.regexp_eatClassAtom(state); ) {
      var left = state.lastIntValue;
      if (state.eat(45) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        !state.switchU || -1 !== left && -1 !== right || state.raise("Invalid character class"), 
        -1 !== left && -1 !== right && left > right && state.raise("Range out of order in character class");
      }
    }
  }, pp$8.regexp_eatClassAtom = function(state) {
    var start = state.pos;
    if (state.eat(92)) {
      if (this.regexp_eatClassEscape(state)) return !0;
      if (state.switchU) {
        var ch$1 = state.current();
        (99 === ch$1 || isOctalDigit(ch$1)) && state.raise("Invalid class escape"), state.raise("Invalid escape");
      }
      state.pos = start;
    }
    var ch = state.current();
    return 93 !== ch && (state.lastIntValue = ch, state.advance(), !0);
  }, pp$8.regexp_eatClassEscape = function(state) {
    var start = state.pos;
    if (state.eat(98)) return state.lastIntValue = 8, !0;
    if (state.switchU && state.eat(45)) return state.lastIntValue = 45, !0;
    if (!state.switchU && state.eat(99)) {
      if (this.regexp_eatClassControlLetter(state)) return !0;
      state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
  }, pp$8.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    return !(!isDecimalDigit(ch) && 95 !== ch) && (state.lastIntValue = ch % 32, state.advance(), 
    !0);
  }, pp$8.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(120)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) return !0;
      state.switchU && state.raise("Invalid escape"), state.pos = start;
    }
    return !1;
  }, pp$8.regexp_eatDecimalDigits = function(state) {
    var start = state.pos, ch = 0;
    for (state.lastIntValue = 0; isDecimalDigit(ch = state.current()); ) state.lastIntValue = 10 * state.lastIntValue + (ch - 48), 
    state.advance();
    return state.pos !== start;
  }, pp$8.regexp_eatHexDigits = function(state) {
    var start = state.pos, ch = 0;
    for (state.lastIntValue = 0; isHexDigit(ch = state.current()); ) state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch), 
    state.advance();
    return state.pos !== start;
  }, pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        n1 <= 3 && this.regexp_eatOctalDigit(state) ? state.lastIntValue = 64 * n1 + 8 * n2 + state.lastIntValue : state.lastIntValue = 8 * n1 + n2;
      } else state.lastIntValue = n1;
      return !0;
    }
    return !1;
  }, pp$8.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    return isOctalDigit(ch) ? (state.lastIntValue = ch - 48, state.advance(), !0) : (state.lastIntValue = 0, 
    !1);
  }, pp$8.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) return state.pos = start, !1;
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch), state.advance();
    }
    return !0;
  };
  var Token = function(p) {
    this.type = p.type, this.value = p.value, this.start = p.start, this.end = p.end, 
    p.options.locations && (this.loc = new SourceLocation(p, p.startLoc, p.endLoc)), 
    p.options.ranges && (this.range = [ p.start, p.end ]);
  }, pp$9 = Parser.prototype;
  function codePointToString$1(code) {
    return code <= 65535 ? String.fromCharCode(code) : (code -= 65536, String.fromCharCode(55296 + (code >> 10), 56320 + (1023 & code)));
  }
  pp$9.next = function() {
    this.options.onToken && this.options.onToken(new Token(this)), this.lastTokEnd = this.end, 
    this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, 
    this.nextToken();
  }, pp$9.getToken = function() {
    return this.next(), new Token(this);
  }, "undefined" != typeof Symbol && (pp$9[Symbol.iterator] = function() {
    var this$1 = this;
    return {
      next: function() {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        };
      }
    };
  }), pp$9.curContext = function() {
    return this.context[this.context.length - 1];
  }, pp$9.nextToken = function() {
    var curContext = this.curContext();
    return curContext && curContext.preserveSpace || this.skipSpace(), this.start = this.pos, 
    this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(types.eof) : curContext.override ? curContext.override(this) : void this.readToken(this.fullCharCodeAtPos());
  }, pp$9.readToken = function(code) {
    return isIdentifierStart(code, this.options.ecmaVersion >= 6) || 92 === code ? this.readWord() : this.getTokenFromCode(code);
  }, pp$9.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    return code <= 55295 || code >= 57344 ? code : (code << 10) + this.input.charCodeAt(this.pos + 1) - 56613888;
  }, pp$9.skipBlockComment = function() {
    var match, startLoc = this.options.onComment && this.curPosition(), start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (-1 === end && this.raise(this.pos - 2, "Unterminated comment"), this.pos = end + 2, 
    this.options.locations) for (lineBreakG.lastIndex = start; (match = lineBreakG.exec(this.input)) && match.index < this.pos; ) ++this.curLine, 
    this.lineStart = match.index + match[0].length;
    this.options.onComment && this.options.onComment(!0, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }, pp$9.skipLineComment = function(startSkip) {
    for (var start = this.pos, startLoc = this.options.onComment && this.curPosition(), ch = this.input.charCodeAt(this.pos += startSkip); this.pos < this.input.length && !isNewLine(ch); ) ch = this.input.charCodeAt(++this.pos);
    this.options.onComment && this.options.onComment(!1, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }, pp$9.skipSpace = function() {
    loop: for (;this.pos < this.input.length; ) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
       case 32:
       case 160:
        ++this.pos;
        break;

       case 13:
        10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;

       case 10:
       case 8232:
       case 8233:
        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
        break;

       case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
         case 42:
          this.skipBlockComment();
          break;

         case 47:
          this.skipLineComment(2);
          break;

         default:
          break loop;
        }
        break;

       default:
        if (!(ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))) break loop;
        ++this.pos;
      }
    }
  }, pp$9.finishToken = function(type, val) {
    this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
    var prevType = this.type;
    this.type = type, this.value = val, this.updateContext(prevType);
  }, pp$9.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) return this.readNumber(!0);
    var next2 = this.input.charCodeAt(this.pos + 2);
    return this.options.ecmaVersion >= 6 && 46 === next && 46 === next2 ? (this.pos += 3, 
    this.finishToken(types.ellipsis)) : (++this.pos, this.finishToken(types.dot));
  }, pp$9.readToken_slash = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === next ? this.finishOp(types.assign, 2) : this.finishOp(types.slash, 1);
  }, pp$9.readToken_mult_modulo_exp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1), size = 1, tokentype = 42 === code ? types.star : types.modulo;
    return this.options.ecmaVersion >= 7 && 42 === code && 42 === next && (++size, tokentype = types.starstar, 
    next = this.input.charCodeAt(this.pos + 2)), 61 === next ? this.finishOp(types.assign, size + 1) : this.finishOp(tokentype, size);
  }, pp$9.readToken_pipe_amp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    return next === code ? this.finishOp(124 === code ? types.logicalOR : types.logicalAND, 2) : 61 === next ? this.finishOp(types.assign, 2) : this.finishOp(124 === code ? types.bitwiseOR : types.bitwiseAND, 1);
  }, pp$9.readToken_caret = function() {
    return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(types.assign, 2) : this.finishOp(types.bitwiseXOR, 1);
  }, pp$9.readToken_plus_min = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    return next === code ? 45 !== next || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(types.incDec, 2) : (this.skipLineComment(3), 
    this.skipSpace(), this.nextToken()) : 61 === next ? this.finishOp(types.assign, 2) : this.finishOp(types.plusMin, 1);
  }, pp$9.readToken_lt_gt = function(code) {
    var next = this.input.charCodeAt(this.pos + 1), size = 1;
    return next === code ? (size = 62 === code && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 
    61 === this.input.charCodeAt(this.pos + size) ? this.finishOp(types.assign, size + 1) : this.finishOp(types.bitShift, size)) : 33 !== next || 60 !== code || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === next && (size = 2), 
    this.finishOp(types.relational, size)) : (this.skipLineComment(4), this.skipSpace(), 
    this.nextToken());
  }, pp$9.readToken_eq_excl = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    return 61 === next ? this.finishOp(types.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === code && 62 === next && this.options.ecmaVersion >= 6 ? (this.pos += 2, 
    this.finishToken(types.arrow)) : this.finishOp(61 === code ? types.eq : types.prefix, 1);
  }, pp$9.getTokenFromCode = function(code) {
    switch (code) {
     case 46:
      return this.readToken_dot();

     case 40:
      return ++this.pos, this.finishToken(types.parenL);

     case 41:
      return ++this.pos, this.finishToken(types.parenR);

     case 59:
      return ++this.pos, this.finishToken(types.semi);

     case 44:
      return ++this.pos, this.finishToken(types.comma);

     case 91:
      return ++this.pos, this.finishToken(types.bracketL);

     case 93:
      return ++this.pos, this.finishToken(types.bracketR);

     case 123:
      return ++this.pos, this.finishToken(types.braceL);

     case 125:
      return ++this.pos, this.finishToken(types.braceR);

     case 58:
      return ++this.pos, this.finishToken(types.colon);

     case 63:
      return ++this.pos, this.finishToken(types.question);

     case 96:
      if (this.options.ecmaVersion < 6) break;
      return ++this.pos, this.finishToken(types.backQuote);

     case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (120 === next || 88 === next) return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (111 === next || 79 === next) return this.readRadixNumber(8);
        if (98 === next || 66 === next) return this.readRadixNumber(2);
      }

     case 49:
     case 50:
     case 51:
     case 52:
     case 53:
     case 54:
     case 55:
     case 56:
     case 57:
      return this.readNumber(!1);

     case 34:
     case 39:
      return this.readString(code);

     case 47:
      return this.readToken_slash();

     case 37:
     case 42:
      return this.readToken_mult_modulo_exp(code);

     case 124:
     case 38:
      return this.readToken_pipe_amp(code);

     case 94:
      return this.readToken_caret();

     case 43:
     case 45:
      return this.readToken_plus_min(code);

     case 60:
     case 62:
      return this.readToken_lt_gt(code);

     case 61:
     case 33:
      return this.readToken_eq_excl(code);

     case 126:
      return this.finishOp(types.prefix, 1);
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
  }, pp$9.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    return this.pos += size, this.finishToken(type, str);
  }, pp$9.readRegexp = function() {
    for (var escaped, inClass, start = this.pos; ;) {
      this.pos >= this.input.length && this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch) && this.raise(start, "Unterminated regular expression"), 
      escaped) escaped = !1; else {
        if ("[" === ch) inClass = !0; else if ("]" === ch && inClass) inClass = !1; else if ("/" === ch && !inClass) break;
        escaped = "\\" === ch;
      }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos, flags = this.readWord1();
    this.containsEsc && this.unexpected(flagsStart);
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags), this.validateRegExpFlags(state), this.validateRegExpPattern(state);
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {}
    return this.finishToken(types.regexp, {
      pattern: pattern,
      flags: flags,
      value: value
    });
  }, pp$9.readInt = function(radix, len) {
    for (var start = this.pos, total = 0, i = 0, e = null == len ? 1 / 0 : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.pos), val = void 0;
      if ((val = code >= 97 ? code - 97 + 10 : code >= 65 ? code - 65 + 10 : code >= 48 && code <= 57 ? code - 48 : 1 / 0) >= radix) break;
      ++this.pos, total = total * radix + val;
    }
    return this.pos === start || null != len && this.pos - start !== len ? null : total;
  }, pp$9.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2;
    var val = this.readInt(radix);
    return null == val && this.raise(this.start + 2, "Expected number in radix " + radix), 
    this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (val = "undefined" != typeof BigInt ? BigInt(this.input.slice(start, this.pos)) : null, 
    ++this.pos) : isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), 
    this.finishToken(types.num, val);
  }, pp$9.readNumber = function(startsWithDot) {
    var start = this.pos;
    startsWithDot || null !== this.readInt(10) || this.raise(start, "Invalid number");
    var octal = this.pos - start >= 2 && 48 === this.input.charCodeAt(start);
    octal && this.strict && this.raise(start, "Invalid number"), octal && /[89]/.test(this.input.slice(start, this.pos)) && (octal = !1);
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && 110 === next) {
      var str$1 = this.input.slice(start, this.pos), val$1 = "undefined" != typeof BigInt ? BigInt(str$1) : null;
      return ++this.pos, isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), 
      this.finishToken(types.num, val$1);
    }
    46 !== next || octal || (++this.pos, this.readInt(10), next = this.input.charCodeAt(this.pos)), 
    69 !== next && 101 !== next || octal || (43 !== (next = this.input.charCodeAt(++this.pos)) && 45 !== next || ++this.pos, 
    null === this.readInt(10) && this.raise(start, "Invalid number")), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
    var str = this.input.slice(start, this.pos), val = octal ? parseInt(str, 8) : parseFloat(str);
    return this.finishToken(types.num, val);
  }, pp$9.readCodePoint = function() {
    var code;
    if (123 === this.input.charCodeAt(this.pos)) {
      this.options.ecmaVersion < 6 && this.unexpected();
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, 
      code > 1114111 && this.invalidStringToken(codePos, "Code point out of bounds");
    } else code = this.readHexChar(4);
    return code;
  }, pp$9.readString = function(quote) {
    for (var out = "", chunkStart = ++this.pos; ;) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) break;
      92 === ch ? (out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(!1), 
      chunkStart = this.pos) : (isNewLine(ch, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), 
      ++this.pos);
    }
    return out += this.input.slice(chunkStart, this.pos++), this.finishToken(types.string, out);
  };
  var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  pp$9.tryReadTemplateToken = function() {
    this.inTemplateElement = !0;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err !== INVALID_TEMPLATE_ESCAPE_ERROR) throw err;
      this.readInvalidTemplateToken();
    }
    this.inTemplateElement = !1;
  }, pp$9.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
    this.raise(position, message);
  }, pp$9.readTmplToken = function() {
    for (var out = "", chunkStart = this.pos; ;) {
      this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.pos);
      if (96 === ch || 36 === ch && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== types.template && this.type !== types.invalidTemplate ? (out += this.input.slice(chunkStart, this.pos), 
      this.finishToken(types.template, out)) : 36 === ch ? (this.pos += 2, this.finishToken(types.dollarBraceL)) : (++this.pos, 
      this.finishToken(types.backQuote));
      if (92 === ch) out += this.input.slice(chunkStart, this.pos), out += this.readEscapedChar(!0), 
      chunkStart = this.pos; else if (isNewLine(ch)) {
        switch (out += this.input.slice(chunkStart, this.pos), ++this.pos, ch) {
         case 13:
          10 === this.input.charCodeAt(this.pos) && ++this.pos;

         case 10:
          out += "\n";
          break;

         default:
          out += String.fromCharCode(ch);
        }
        this.options.locations && (++this.curLine, this.lineStart = this.pos), chunkStart = this.pos;
      } else ++this.pos;
    }
  }, pp$9.readInvalidTemplateToken = function() {
    for (;this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
     case "\\":
      ++this.pos;
      break;

     case "$":
      if ("{" !== this.input[this.pos + 1]) break;

     case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos));
    }
    this.raise(this.start, "Unterminated template");
  }, pp$9.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    switch (++this.pos, ch) {
     case 110:
      return "\n";

     case 114:
      return "\r";

     case 120:
      return String.fromCharCode(this.readHexChar(2));

     case 117:
      return codePointToString$1(this.readCodePoint());

     case 116:
      return "\t";

     case 98:
      return "\b";

     case 118:
      return "\v";

     case 102:
      return "\f";

     case 13:
      10 === this.input.charCodeAt(this.pos) && ++this.pos;

     case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";

     default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], octal = parseInt(octalStr, 8);
        return octal > 255 && (octalStr = octalStr.slice(0, -1), octal = parseInt(octalStr, 8)), 
        this.pos += octalStr.length - 1, ch = this.input.charCodeAt(this.pos), "0" === octalStr && 56 !== ch && 57 !== ch || !this.strict && !inTemplate || this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"), 
        String.fromCharCode(octal);
      }
      return isNewLine(ch) ? "" : String.fromCharCode(ch);
    }
  }, pp$9.readHexChar = function(len) {
    var codePos = this.pos, n = this.readInt(16, len);
    return null === n && this.invalidStringToken(codePos, "Bad character escape sequence"), 
    n;
  }, pp$9.readWord1 = function() {
    this.containsEsc = !1;
    for (var word = "", first = !0, chunkStart = this.pos, astral = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2; else {
        if (92 !== ch) break;
        this.containsEsc = !0, word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), 
        ++this.pos;
        var esc = this.readCodePoint();
        (first ? isIdentifierStart : isIdentifierChar)(esc, astral) || this.invalidStringToken(escStart, "Invalid Unicode escape"), 
        word += codePointToString$1(esc), chunkStart = this.pos;
      }
      first = !1;
    }
    return word + this.input.slice(chunkStart, this.pos);
  }, pp$9.readWord = function() {
    var word = this.readWord1(), type = types.name;
    return this.keywords.test(word) && (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + word), 
    type = keywords$1[word]), this.finishToken(type, word);
  };
  var version = "6.4.2";
  function parse(input, options) {
    return Parser.parse(input, options);
  }
  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options);
  }
  function tokenizer(input, options) {
    return Parser.tokenizer(input, options);
  }
  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types,
    keywordTypes: keywords$1,
    TokContext: TokContext,
    tokContexts: types$1,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {RawSource: RawSource, ReplaceSource: ReplaceSource} = __webpack_require__(0);
  module.exports = class {
    generate(module, dependencyTemplates, runtimeTemplate) {
      const originalSource = module.originalSource();
      if (!originalSource) return new RawSource("throw new Error('No source available');");
      const source = new ReplaceSource(originalSource);
      return this.sourceBlock(module, module, [], dependencyTemplates, source, runtimeTemplate), 
      source;
    }
    sourceBlock(module, block, availableVars, dependencyTemplates, source, runtimeTemplate) {
      for (const dependency of block.dependencies) this.sourceDependency(dependency, dependencyTemplates, source, runtimeTemplate);
      const vars = block.variables.reduce((result, value) => {
        const variable = this.sourceVariables(value, availableVars, dependencyTemplates, runtimeTemplate);
        return variable && result.push(variable), result;
      }, []);
      if (vars.length > 0) {
        const injectionVariableChunks = this.splitVariablesInUniqueNamedChunks(vars), functionWrapperStarts = injectionVariableChunks.map(variableChunk => this.variableInjectionFunctionWrapperStartCode(variableChunk.map(variable => variable.name))), functionWrapperEnds = injectionVariableChunks.map(variableChunk => this.variableInjectionFunctionWrapperEndCode(module, variableChunk.map(variable => variable.expression), block)), varStartCode = functionWrapperStarts.join(""), varEndCode = functionWrapperEnds.reverse().join("");
        if (varStartCode && varEndCode) {
          const start = block.range ? block.range[0] : -10, end = block.range ? block.range[1] : module.originalSource().size() + 1;
          source.insert(start + .5, varStartCode), source.insert(end + .5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
        }
      }
      for (const childBlock of block.blocks) this.sourceBlock(module, childBlock, availableVars.concat(vars), dependencyTemplates, source, runtimeTemplate);
    }
    sourceDependency(dependency, dependencyTemplates, source, runtimeTemplate) {
      const template = dependencyTemplates.get(dependency.constructor);
      if (!template) throw new Error("No template for dependency: " + dependency.constructor.name);
      template.apply(dependency, source, runtimeTemplate, dependencyTemplates);
    }
    sourceVariables(variable, availableVars, dependencyTemplates, runtimeTemplate) {
      const name = variable.name, expr = variable.expressionSource(dependencyTemplates, runtimeTemplate);
      if (!availableVars.some(v => v.name === name && v.expression.source() === expr.source())) return {
        name: name,
        expression: expr
      };
    }
    variableInjectionFunctionWrapperStartCode(varNames) {
      return `/* WEBPACK VAR INJECTION */(function(${varNames.join(", ")}) {`;
    }
    contextArgument(module, block) {
      return this === block ? module.exportsArgument : "this";
    }
    variableInjectionFunctionWrapperEndCode(module, varExpressions, block) {
      return `}.call(${this.contextArgument(module, block)}, ${varExpressions.map(e => e.source()).join(", ")}))`;
    }
    splitVariablesInUniqueNamedChunks(vars) {
      return vars.reduce((chunks, variable) => {
        const current = chunks[chunks.length - 1];
        return current.some(v => v.name === variable.name) ? chunks.push([ variable ]) : current.push(variable), 
        chunks;
      }, [ [] ]);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const JsonParser = __webpack_require__(274), JsonGenerator = __webpack_require__(276);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("JsonModulesPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        normalModuleFactory.hooks.createParser.for("json").tap("JsonModulesPlugin", () => new JsonParser), 
        normalModuleFactory.hooks.createGenerator.for("json").tap("JsonModulesPlugin", () => new JsonGenerator);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const parseJson = __webpack_require__(57), JsonExportsDependency = __webpack_require__(275);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    parse(source, state) {
      const data = parseJson("\ufeff" === source[0] ? source.slice(1) : source);
      return state.module.buildInfo.jsonData = data, state.module.buildMeta.exportsType = "named", 
      "object" == typeof data && data && state.module.addDependency(new JsonExportsDependency(Object.keys(data))), 
      state.module.addDependency(new JsonExportsDependency([ "default" ])), state;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NullDependency = __webpack_require__(7);
  module.exports = class extends NullDependency {
    constructor(exports) {
      super(), this.exports = exports;
    }
    get type() {
      return "json exports";
    }
    getExports() {
      return {
        exports: this.exports,
        dependencies: void 0
      };
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource, RawSource: RawSource} = __webpack_require__(0);
  module.exports = class {
    generate(module, dependencyTemplates, runtimeTemplate) {
      const source = new ConcatSource, data = module.buildInfo.jsonData;
      if (void 0 === data) return new RawSource(runtimeTemplate.missingModuleStatement({
        request: module.rawRequest
      }));
      let finalJson;
      if (Array.isArray(module.buildMeta.providedExports) && !module.isUsed("default")) {
        const reducedJson = {};
        for (const exportName of module.buildMeta.providedExports) {
          if ("default" === exportName) continue;
          const used = module.isUsed(exportName);
          used && (reducedJson[used] = data[exportName]);
        }
        finalJson = reducedJson;
      } else finalJson = data;
      const jsonExpr = `JSON.parse(${JSON.stringify((data => {
        const stringified = JSON.stringify(data);
        if (stringified) return stringified.replace(/\u2028|\u2029/g, str => "\u2029" === str ? "\\u2029" : "\\u2028");
      })(finalJson))})`;
      return source.add(`${module.moduleArgument}.exports = ${jsonExpr};`), source;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Generator = __webpack_require__(71), WebAssemblyExportImportedDependency = __webpack_require__(43), WebAssemblyImportDependency = __webpack_require__(44), WebAssemblyInInitialChunkError = __webpack_require__(278);
  let WebAssemblyGenerator, WebAssemblyJavascriptGenerator, WebAssemblyParser;
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("WebAssemblyModulesPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(WebAssemblyImportDependency, normalModuleFactory), 
        compilation.dependencyFactories.set(WebAssemblyExportImportedDependency, normalModuleFactory), 
        normalModuleFactory.hooks.createParser.for("webassembly/experimental").tap("WebAssemblyModulesPlugin", () => (void 0 === WebAssemblyParser && (WebAssemblyParser = __webpack_require__(279)), 
        new WebAssemblyParser)), normalModuleFactory.hooks.createGenerator.for("webassembly/experimental").tap("WebAssemblyModulesPlugin", () => (void 0 === WebAssemblyGenerator && (WebAssemblyGenerator = __webpack_require__(280)), 
        void 0 === WebAssemblyJavascriptGenerator && (WebAssemblyJavascriptGenerator = __webpack_require__(282)), 
        Generator.byType({
          javascript: new WebAssemblyJavascriptGenerator,
          webassembly: new WebAssemblyGenerator(this.options)
        }))), compilation.chunkTemplate.hooks.renderManifest.tap("WebAssemblyModulesPlugin", (result, options) => {
          const chunk = options.chunk, outputOptions = options.outputOptions, moduleTemplates = options.moduleTemplates, dependencyTemplates = options.dependencyTemplates;
          for (const module of chunk.modulesIterable) if (module.type && module.type.startsWith("webassembly")) {
            const filenameTemplate = outputOptions.webassemblyModuleFilename;
            result.push({
              render: () => this.renderWebAssembly(module, moduleTemplates.webassembly, dependencyTemplates),
              filenameTemplate: filenameTemplate,
              pathOptions: {
                module: module
              },
              identifier: "webassemblyModule" + module.id,
              hash: module.hash
            });
          }
          return result;
        }), compilation.hooks.afterChunks.tap("WebAssemblyModulesPlugin", () => {
          const initialWasmModules = new Set;
          for (const chunk of compilation.chunks) if (chunk.canBeInitial()) for (const module of chunk.modulesIterable) module.type.startsWith("webassembly") && initialWasmModules.add(module);
          for (const module of initialWasmModules) compilation.errors.push(new WebAssemblyInInitialChunkError(module, compilation.requestShortener));
        });
      });
    }
    renderWebAssembly(module, moduleTemplate, dependencyTemplates) {
      return moduleTemplate.render(module, dependencyTemplates, {});
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(module, requestShortener) {
      const moduleChains = ((module, requestShortener) => {
        const queue = [ {
          head: module,
          message: module.readableIdentifier(requestShortener)
        } ], results = new Set, incompleteResults = new Set, visitedModules = new Set;
        for (const chain of queue) {
          const {head: head, message: message} = chain;
          let final = !0;
          const alreadyReferencedModules = new Set;
          for (const reason of head.reasons) {
            const newHead = reason.module;
            if (newHead) {
              if (!newHead.getChunks().some(c => c.canBeInitial())) continue;
              if (final = !1, alreadyReferencedModules.has(newHead)) continue;
              alreadyReferencedModules.add(newHead);
              const newMessage = `${newHead.readableIdentifier(requestShortener)}${reason.explanation ? ` (${reason.explanation})` : ""} --\x3e ${message}`;
              if (visitedModules.has(newHead)) {
                incompleteResults.add("... --\x3e " + newMessage);
                continue;
              }
              visitedModules.add(newHead), queue.push({
                head: newHead,
                message: newMessage
              });
            } else {
              final = !1;
              const newMessage = reason.explanation ? `(${reason.explanation}) --\x3e ${message}` : message;
              results.add(newMessage);
            }
          }
          final && results.add(message);
        }
        for (const result of incompleteResults) results.add(result);
        return Array.from(results);
      })(module, requestShortener);
      super("WebAssembly module is included in initial chunk.\nThis is not allowed, because WebAssembly download and compilation must happen asynchronous.\nAdd an async splitpoint (i. e. import()) somewhere between your entrypoint and the WebAssembly module:\n" + moduleChains.map(s => "* " + s).join("\n")), 
      this.name = "WebAssemblyInInitialChunkError", this.hideStack = !0, this.module = module, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const t = __webpack_require__(35), {decode: decode} = __webpack_require__(118), {moduleContextFromModuleAST: moduleContextFromModuleAST} = __webpack_require__(119), {Tapable: Tapable} = __webpack_require__(6), WebAssemblyImportDependency = __webpack_require__(44), WebAssemblyExportImportedDependency = __webpack_require__(43), JS_COMPAT_TYPES = new Set([ "i32", "f32", "f64" ]), decoderOpts = {
    ignoreCodeSection: !0,
    ignoreDataSection: !0,
    ignoreCustomNameSection: !0
  };
  module.exports = class extends Tapable {
    constructor(options) {
      super(), this.hooks = {}, this.options = options;
    }
    parse(binary, state) {
      state.module.buildMeta.exportsType = "namespace";
      const module = decode(binary, decoderOpts).body[0], moduleContext = moduleContextFromModuleAST(module), exports = state.module.buildMeta.providedExports = [], jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = [], importedGlobals = [];
      return t.traverse(module, {
        ModuleExport({node: node}) {
          const descriptor = node.descr;
          if ("Func" === descriptor.exportType) {
            const funcidx = descriptor.id.value, incompatibleType = (signature => {
              for (const param of signature.args) if (!JS_COMPAT_TYPES.has(param)) return param + " as parameter";
              for (const type of signature.result) if (!JS_COMPAT_TYPES.has(type)) return type + " as result";
              return null;
            })(moduleContext.getFunction(funcidx));
            incompatibleType && (jsIncompatibleExports[node.name] = incompatibleType);
          }
          if (exports.push(node.name), node.descr && "Global" === node.descr.exportType) {
            const refNode = importedGlobals[node.descr.id.value];
            if (refNode) {
              const dep = new WebAssemblyExportImportedDependency(node.name, refNode.module, refNode.name, refNode.descr.valtype);
              state.module.addDependency(dep);
            }
          }
        },
        Global({node: node}) {
          const init = node.init[0];
          let importNode = null;
          if ("get_global" === init.id) {
            const globalIdx = init.args[0].value;
            globalIdx < importedGlobals.length && (importNode = importedGlobals[globalIdx]);
          }
          importedGlobals.push(importNode);
        },
        ModuleImport({node: node}) {
          let onlyDirectImport = !1;
          if (!0 === t.isMemory(node.descr)) onlyDirectImport = "Memory"; else if (!0 === t.isTable(node.descr)) onlyDirectImport = "Table"; else if (!0 === t.isFuncImportDescr(node.descr)) {
            const incompatibleType = (signature => {
              for (const param of signature.params) if (!JS_COMPAT_TYPES.has(param.valtype)) return param.valtype + " as parameter";
              for (const type of signature.results) if (!JS_COMPAT_TYPES.has(type)) return type + " as result";
              return null;
            })(node.descr.signature);
            incompatibleType && (onlyDirectImport = `Non-JS-compatible Func Sigurature (${incompatibleType})`);
          } else if (!0 === t.isGlobalType(node.descr)) {
            const type = node.descr.valtype;
            JS_COMPAT_TYPES.has(type) || (onlyDirectImport = `Non-JS-compatible Global Type (${type})`);
          }
          const dep = new WebAssemblyImportDependency(node.module, node.name, node.descr, onlyDirectImport);
          state.module.addDependency(dep), t.isGlobalType(node.descr) && importedGlobals.push(node);
        }
      }), state;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Generator = __webpack_require__(71), Template = __webpack_require__(2), WebAssemblyUtils = __webpack_require__(120), {RawSource: RawSource} = __webpack_require__(0), {editWithAST: editWithAST, addWithAST: addWithAST} = __webpack_require__(281), {decode: decode} = __webpack_require__(118), t = __webpack_require__(35), {moduleContextFromModuleAST: moduleContextFromModuleAST} = __webpack_require__(119), WebAssemblyExportImportedDependency = __webpack_require__(43), createDefaultInitForGlobal = globalType => {
    if ("i" === globalType.valtype[0]) return t.objectInstruction("const", globalType.valtype, [ t.numberLiteralFromRaw(66) ]);
    if ("f" === globalType.valtype[0]) return t.objectInstruction("const", globalType.valtype, [ t.floatLiteral(66, !1, !1, "66") ]);
    throw new Error("unknown type: " + globalType.valtype);
  };
  module.exports = class extends Generator {
    constructor(options) {
      super(), this.options = options;
    }
    generate(module, dependencyTemplates, runtimeTemplate, type) {
      let bin = module.originalSource().source();
      const initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : "__webpack_init__"), ast = decode(bin, {
        ignoreDataSection: !0,
        ignoreCodeSection: !0,
        ignoreCustomNameSection: !0
      }), moduleContext = moduleContextFromModuleAST(ast.body[0]), importedGlobals = (ast => {
        const importedGlobals = [];
        return t.traverse(ast, {
          ModuleImport({node: node}) {
            t.isGlobalType(node.descr) && importedGlobals.push(node);
          }
        }), importedGlobals;
      })(ast), countImportedFunc = (ast => {
        let count = 0;
        return t.traverse(ast, {
          ModuleImport({node: node}) {
            t.isFuncImportDescr(node.descr) && count++;
          }
        }), count;
      })(ast), startAtFuncOffset = moduleContext.getStart(), nextFuncIndex = ((ast, countImportedFunc) => {
        const funcSectionMetadata = t.getSectionMetadata(ast, "func");
        if (void 0 === funcSectionMetadata) return t.indexLiteral(0 + countImportedFunc);
        const vectorOfSize = funcSectionMetadata.vectorOfSize.value;
        return t.indexLiteral(vectorOfSize + countImportedFunc);
      })(ast, countImportedFunc), nextTypeIndex = (ast => {
        const typeSectionMetadata = t.getSectionMetadata(ast, "type");
        return void 0 === typeSectionMetadata ? t.indexLiteral(0) : t.indexLiteral(typeSectionMetadata.vectorOfSize.value);
      })(ast), usedDependencyMap = ((module, mangle) => {
        const map = new Map;
        for (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {
          const dep = usedDep.dependency, request = dep.request, exportName = dep.name;
          map.set(request + ":" + exportName, usedDep);
        }
        return map;
      })(module, this.options.mangleImports), externalExports = new Set(module.dependencies.filter(d => d instanceof WebAssemblyExportImportedDependency).map(d => d.exportName)), additionalInitCode = [];
      var state;
      const newBin = ((...fns) => fns.reduce((prevFn, nextFn) => value => nextFn(prevFn(value)), value => value))((({ast: ast, module: module, externalExports: externalExports}) => bin => editWithAST(ast, bin, {
        ModuleExport(path) {
          if (externalExports.has(path.node.name)) return void path.remove();
          const usedName = module.isUsed(path.node.name);
          usedName ? path.node.name = usedName : path.remove();
        }
      }))({
        ast: ast,
        module: module,
        externalExports: externalExports
      }), (state = {
        ast: ast
      }, bin => editWithAST(state.ast, bin, {
        Start(path) {
          path.remove();
        }
      })), (state => bin => {
        const additionalInitCode = state.additionalInitCode, newGlobals = [];
        return bin = editWithAST(state.ast, bin, {
          ModuleImport(path) {
            if (t.isGlobalType(path.node.descr)) {
              const globalType = path.node.descr;
              globalType.mutability = "var";
              const init = [ createDefaultInitForGlobal(globalType), t.instruction("end") ];
              newGlobals.push(t.global(globalType, init)), path.remove();
            }
          },
          Global(path) {
            const {node: node} = path, [init] = node.init;
            if ("get_global" === init.id) {
              node.globalType.mutability = "var";
              const initialGlobalidx = init.args[0];
              node.init = [ createDefaultInitForGlobal(node.globalType), t.instruction("end") ], 
              additionalInitCode.push(t.instruction("get_local", [ initialGlobalidx ]), t.instruction("set_global", [ t.indexLiteral(newGlobals.length) ]));
            }
            newGlobals.push(node), path.remove();
          }
        }), addWithAST(state.ast, bin, newGlobals);
      })({
        ast: ast,
        additionalInitCode: additionalInitCode
      }), (({ast: ast, usedDependencyMap: usedDependencyMap}) => bin => editWithAST(ast, bin, {
        ModuleImport(path) {
          const result = usedDependencyMap.get(path.node.module + ":" + path.node.name);
          void 0 !== result && (path.node.module = result.module, path.node.name = result.name);
        }
      }))({
        ast: ast,
        usedDependencyMap: usedDependencyMap
      }), (({ast: ast, initFuncId: initFuncId, startAtFuncOffset: startAtFuncOffset, importedGlobals: importedGlobals, additionalInitCode: additionalInitCode, nextFuncIndex: nextFuncIndex, nextTypeIndex: nextTypeIndex}) => bin => {
        const funcParams = importedGlobals.map(importedGlobal => {
          const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);
          return t.funcParam(importedGlobal.descr.valtype, id);
        }), funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {
          const args = [ t.indexLiteral(index) ];
          return [ ...acc, ...[ t.instruction("get_local", args), t.instruction("set_global", args) ] ];
        }, []);
        "number" == typeof startAtFuncOffset && funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));
        for (const instr of additionalInitCode) funcBody.push(instr);
        funcBody.push(t.instruction("end"));
        const funcSignature = t.signature(funcParams, []), func = t.func(initFuncId, funcSignature, funcBody), functype = t.typeInstruction(void 0, funcSignature), funcindex = t.indexInFuncSection(nextTypeIndex), moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr("Func", nextFuncIndex));
        return addWithAST(ast, bin, [ func, moduleExport, funcindex, functype ]);
      })({
        ast: ast,
        initFuncId: initFuncId,
        importedGlobals: importedGlobals,
        additionalInitCode: additionalInitCode,
        startAtFuncOffset: startAtFuncOffset,
        nextFuncIndex: nextFuncIndex,
        nextTypeIndex: nextTypeIndex
      }))(bin);
      return new RawSource(newBin);
    }
  };
}, function(module, exports) {
  module.exports = require("../vendor/wasm-edit");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Generator = __webpack_require__(71), Template = __webpack_require__(2), {RawSource: RawSource} = __webpack_require__(0), WebAssemblyImportDependency = __webpack_require__(44), WebAssemblyExportImportedDependency = __webpack_require__(43);
  module.exports = class extends Generator {
    generate(module, dependencyTemplates, runtimeTemplate, type) {
      const initIdentifer = Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : "__webpack_init__";
      let needExportsCopy = !1;
      const importedModules = new Map, initParams = [];
      let index = 0;
      for (const dep of module.dependencies) {
        const depAsAny = dep;
        if (dep.module) {
          let importData = importedModules.get(dep.module);
          if (void 0 === importData && (importedModules.set(dep.module, importData = {
            importVar: "m" + index,
            index: index,
            request: "userRequest" in depAsAny ? depAsAny.userRequest : void 0,
            names: new Set,
            reexports: []
          }), index++), dep instanceof WebAssemblyImportDependency && (importData.names.add(dep.name), 
          "GlobalType" === dep.description.type)) {
            const exportName = dep.name, usedName = dep.module && dep.module.isUsed(exportName);
            dep.module && usedName && initParams.push(runtimeTemplate.exportFromImport({
              module: dep.module,
              request: dep.request,
              importVar: importData.importVar,
              originModule: module,
              exportName: dep.name,
              asiSafe: !0,
              isCall: !1,
              callContext: null
            }));
          }
          if (dep instanceof WebAssemblyExportImportedDependency) {
            importData.names.add(dep.name);
            const usedName = module.isUsed(dep.exportName);
            if (usedName) {
              const exportProp = `${module.exportsArgument}[${JSON.stringify(usedName)}]`, defineStatement = Template.asString([ `${exportProp} = ${runtimeTemplate.exportFromImport({
                module: dep.module,
                request: dep.request,
                importVar: importData.importVar,
                originModule: module,
                exportName: dep.name,
                asiSafe: !0,
                isCall: !1,
                callContext: null
              })};`, `if(WebAssembly.Global) ${exportProp} = new WebAssembly.Global({ value: ${JSON.stringify(dep.valueType)} }, ${exportProp});` ]);
              importData.reexports.push(defineStatement), needExportsCopy = !0;
            }
          }
        }
      }
      const importsCode = Template.asString(Array.from(importedModules, ([module, {importVar: importVar, request: request, reexports: reexports}]) => runtimeTemplate.importStatement({
        module: module,
        request: request,
        importVar: importVar,
        originModule: module
      }) + reexports.join("\n")));
      return new RawSource([ '"use strict";', "// Instantiate WebAssembly module", "var wasmExports = __webpack_require__.w[module.i];", Array.isArray(module.usedExports) ? "" : `__webpack_require__.r(${module.exportsArgument});`, "// export exports from WebAssembly module", Array.isArray(module.usedExports) && !needExportsCopy ? module.moduleArgument + ".exports = wasmExports;" : `for(var name in wasmExports) if(name != ${JSON.stringify(initIdentifer)}) ` + module.exportsArgument + "[name] = wasmExports[name];", "// exec imports from WebAssembly module (for esm order)", importsCode, "", "// exec wasm module", `wasmExports[${JSON.stringify(initIdentifer)}](${initParams.join(", ")})` ].join("\n"));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const FunctionModuleTemplatePlugin = __webpack_require__(284);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("FunctionModulePlugin", compilation => {
        (new FunctionModuleTemplatePlugin).apply(compilation.moduleTemplates.javascript);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0), Template = __webpack_require__(2);
  module.exports = class {
    apply(moduleTemplate) {
      moduleTemplate.hooks.render.tap("FunctionModuleTemplatePlugin", (moduleSource, module) => {
        const source = new ConcatSource, args = [ module.moduleArgument ];
        return module.type && module.type.startsWith("javascript") ? (args.push(module.exportsArgument), 
        module.hasDependencies(d => !1 !== d.requireWebpackRequire) && args.push("__webpack_require__")) : module.type && module.type.startsWith("json") || args.push(module.exportsArgument, "__webpack_require__"), 
        source.add("/***/ (function(" + args.join(", ") + ") {\n\n"), module.buildInfo.strict && source.add('"use strict";\n'), 
        source.add(moduleSource), source.add("\n\n/***/ })"), source;
      }), moduleTemplate.hooks.package.tap("FunctionModuleTemplatePlugin", (moduleSource, module) => {
        if (moduleTemplate.runtimeTemplate.outputOptions.pathinfo) {
          const source = new ConcatSource, reqStr = module.readableIdentifier(moduleTemplate.runtimeTemplate.requestShortener).replace(/\*\//g, "*_/"), reqStrStar = "*".repeat(reqStr.length);
          if (source.add("/*!****" + reqStrStar + "****!*\\\n"), source.add("  !*** " + reqStr + " ***!\n"), 
          source.add("  \\****" + reqStrStar + "****/\n"), Array.isArray(module.buildMeta.providedExports) && 0 === module.buildMeta.providedExports.length ? source.add(Template.toComment("no exports provided") + "\n") : Array.isArray(module.buildMeta.providedExports) ? source.add(Template.toComment("exports provided: " + module.buildMeta.providedExports.join(", ")) + "\n") : module.buildMeta.providedExports && source.add(Template.toComment("no static exports found") + "\n"), 
          Array.isArray(module.usedExports) && 0 === module.usedExports.length ? source.add(Template.toComment("no exports used") + "\n") : Array.isArray(module.usedExports) ? source.add(Template.toComment("exports used: " + module.usedExports.join(", ")) + "\n") : module.usedExports && source.add(Template.toComment("all exports used") + "\n"), 
          module.optimizationBailout) for (const text of module.optimizationBailout) {
            let code;
            code = "function" == typeof text ? text(moduleTemplate.runtimeTemplate.requestShortener) : text, 
            source.add(Template.toComment("" + code) + "\n");
          }
          return source.add(moduleSource), source;
        }
        return moduleSource;
      }), moduleTemplate.hooks.hash.tap("FunctionModuleTemplatePlugin", hash => {
        hash.update("FunctionModuleTemplatePlugin"), hash.update("2");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {RawSource: RawSource} = __webpack_require__(0), ModuleFilenameHelpers = __webpack_require__(21), cache = new WeakMap;
  module.exports = class {
    constructor(options) {
      this.sourceUrlComment = options.sourceUrlComment || "\n//# sourceURL=[url]", this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resourcePath]?[loaders]", 
      this.namespace = options.namespace || "";
    }
    apply(moduleTemplate) {
      moduleTemplate.hooks.module.tap("EvalDevToolModuleTemplatePlugin", (source, module) => {
        const cacheEntry = cache.get(source);
        if (void 0 !== cacheEntry) return cacheEntry;
        const content = source.source(), str = ModuleFilenameHelpers.createFilename(module, {
          moduleFilenameTemplate: this.moduleFilenameTemplate,
          namespace: this.namespace
        }, moduleTemplate.runtimeTemplate.requestShortener), footer = "\n" + this.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, "")), result = new RawSource(`eval(${JSON.stringify(content + footer)});`);
        return cache.set(source, result), result;
      }), moduleTemplate.hooks.hash.tap("EvalDevToolModuleTemplatePlugin", hash => {
        hash.update("EvalDevToolModuleTemplatePlugin"), hash.update("2");
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"definitions":{"rule":{"oneOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"rules":{"oneOf":[{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/rule"}]}},{"$ref":"#/definitions/rule"}]}},"title":"SourceMapDevToolPluginOptions","type":"object","additionalProperties":false,"properties":{"append":{"description":"Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending","oneOf":[{"description":"Append no SourceMap comment to the bundle, but still generate SourceMaps","enum":[false,null]},{"type":"string","minLength":1}]},"columns":{"description":"Indicates whether column mappings should be used (defaults to true)","type":"boolean"},"exclude":{"description":"Exclude modules that match the given value from source map generation","anyOf":[{"$ref":"#/definitions/rules"}]},"fallbackModuleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the \'sources\' array in the SourceMap used only if \'moduleFilenameTemplate\' would result in a conflict","oneOf":[{"description":"Custom function generating the identifer","instanceof":"Function","tsType":"Function"},{"type":"string","minLength":1}]},"fileContext":{"description":"Path prefix to which the [file] placeholder is relative to","type":"string"},"filename":{"description":"Defines the output filename of the SourceMap (will be inlined if no value is provided)","oneOf":[{"description":"Disable separate SourceMap file and inline SourceMap as DataUrl","enum":[false,null]},{"type":"string","absolutePath":false,"minLength":1}]},"include":{"description":"Include source maps for module paths that match the given value","anyOf":[{"$ref":"#/definitions/rules"}]},"lineToLine":{"description":"(deprecated) try to map original files line to line to generated files","anyOf":[{"type":"boolean"},{"description":"Simplify and speed up source mapping by using line to line source mappings for matched modules","type":"object","additionalProperties":false,"properties":{"exclude":{"description":"Exclude modules that match the given value from source map generation","anyOf":[{"$ref":"#/definitions/rules"}]},"include":{"description":"Include source maps for module paths that match the given value","anyOf":[{"$ref":"#/definitions/rules"}]},"test":{"description":"Include source maps for modules based on their extension (defaults to .js and .css)","anyOf":[{"$ref":"#/definitions/rules"}]}}}]},"module":{"description":"Indicates whether SourceMaps from loaders should be used (defaults to true)","type":"boolean"},"moduleFilenameTemplate":{"description":"Generator string or function to create identifiers of modules for the \'sources\' array in the SourceMap","oneOf":[{"description":"Custom function generating the identifer","instanceof":"Function","tsType":"Function"},{"type":"string","minLength":1}]},"namespace":{"description":"Namespace prefix to allow multiple webpack roots in the devtools","type":"string"},"noSources":{"description":"Omit the \'sourceContents\' array from the SourceMap","type":"boolean"},"publicPath":{"description":"Provide a custom public path for the SourceMapping comment","type":"string"},"sourceRoot":{"description":"Provide a custom value for the \'sourceRoot\' property in the SourceMap","type":"string"},"test":{"description":"Include source maps for modules based on their extension (defaults to .js and .css)","anyOf":[{"$ref":"#/definitions/rules"}]}}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {RawSource: RawSource} = __webpack_require__(0), ModuleFilenameHelpers = __webpack_require__(21), {absolutify: absolutify} = __webpack_require__(14), cache = new WeakMap;
  module.exports = class {
    constructor(compilation, options) {
      this.compilation = compilation, this.sourceMapComment = options.append || "//# sourceURL=[module]\n//# sourceMappingURL=[url]", 
      this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack://[namespace]/[resource-path]?[hash]", 
      this.namespace = options.namespace || "", this.options = options;
    }
    apply(moduleTemplate) {
      const self = this, options = this.options, matchModule = ModuleFilenameHelpers.matchObject.bind(ModuleFilenameHelpers, options);
      moduleTemplate.hooks.module.tap("EvalSourceMapDevToolModuleTemplatePlugin", (source, module) => {
        const cachedSource = cache.get(source);
        if (void 0 !== cachedSource) return cachedSource;
        if (!matchModule(module.resource)) return source;
        let sourceMap, content;
        if (source.sourceAndMap) {
          const sourceAndMap = source.sourceAndMap(options);
          sourceMap = sourceAndMap.map, content = sourceAndMap.source;
        } else sourceMap = source.map(options), content = source.source();
        if (!sourceMap) return source;
        sourceMap = Object.keys(sourceMap).reduce((obj, key) => (obj[key] = sourceMap[key], 
        obj), {});
        const context = this.compilation.compiler.options.context;
        let moduleFilenames = sourceMap.sources.map(source => {
          source.startsWith("webpack://") && (source = absolutify(context, source.slice(10)));
          return self.compilation.findModule(source) || source;
        }).map(module => ModuleFilenameHelpers.createFilename(module, {
          moduleFilenameTemplate: self.moduleFilenameTemplate,
          namespace: self.namespace
        }, moduleTemplate.runtimeTemplate.requestShortener));
        moduleFilenames = ModuleFilenameHelpers.replaceDuplicates(moduleFilenames, (filename, i, n) => {
          for (let j = 0; j < n; j++) filename += "*";
          return filename;
        }), sourceMap.sources = moduleFilenames, sourceMap.sourceRoot = options.sourceRoot || "", 
        sourceMap.file = module.id + ".js";
        const footer = self.sourceMapComment.replace(/\[url\]/g, "data:application/json;charset=utf-8;base64," + Buffer.from(JSON.stringify(sourceMap), "utf8").toString("base64")) + `\n//# sourceURL=webpack-internal:///${module.id}\n`, evalSource = new RawSource(`eval(${JSON.stringify(content + footer)});`);
        return cache.set(source, evalSource), evalSource;
      }), moduleTemplate.hooks.hash.tap("EvalSourceMapDevToolModuleTemplatePlugin", hash => {
        hash.update("eval-source-map"), hash.update("2");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const SingleEntryPlugin = __webpack_require__(73), MultiEntryPlugin = __webpack_require__(125), DynamicEntryPlugin = __webpack_require__(290), itemToPlugin = (context, item, name) => Array.isArray(item) ? new MultiEntryPlugin(context, item, name) : new SingleEntryPlugin(context, item, name);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {
        if ("string" == typeof entry || Array.isArray(entry)) itemToPlugin(context, entry, "main").apply(compiler); else if ("object" == typeof entry) for (const name of Object.keys(entry)) itemToPlugin(context, entry[name], name).apply(compiler); else "function" == typeof entry && new DynamicEntryPlugin(context, entry).apply(compiler);
        return !0;
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Module = __webpack_require__(18), Template = __webpack_require__(2), {RawSource: RawSource} = __webpack_require__(0);
  module.exports = class extends Module {
    constructor(context, dependencies, name) {
      super("javascript/dynamic", context), this.dependencies = dependencies, this.name = name, 
      this._identifier = "multi " + this.dependencies.map(d => d.request).join(" ");
    }
    identifier() {
      return this._identifier;
    }
    readableIdentifier(requestShortener) {
      return "multi " + this.dependencies.map(d => requestShortener.shorten(d.request)).join(" ");
    }
    build(options, compilation, resolver, fs, callback) {
      return this.built = !0, this.buildMeta = {}, this.buildInfo = {}, callback();
    }
    needRebuild() {
      return !1;
    }
    size() {
      return 16 + 12 * this.dependencies.length;
    }
    updateHash(hash) {
      hash.update("multi module"), hash.update(this.name || ""), super.updateHash(hash);
    }
    source(dependencyTemplates, runtimeTemplate) {
      const str = [];
      let idx = 0;
      for (const dep of this.dependencies) {
        if (dep.module) idx === this.dependencies.length - 1 && str.push("module.exports = "), 
        str.push("__webpack_require__("), runtimeTemplate.outputOptions.pathinfo && str.push(Template.toComment(dep.request)), 
        str.push("" + JSON.stringify(dep.module.id)), str.push(")"); else {
          const content = __webpack_require__(45).module(dep.request);
          str.push(content);
        }
        str.push(";\n"), idx++;
      }
      return new RawSource(str.join(""));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const MultiEntryDependency = __webpack_require__(126), SingleEntryDependency = __webpack_require__(31), MultiModuleFactory = __webpack_require__(127), MultiEntryPlugin = __webpack_require__(125), SingleEntryPlugin = __webpack_require__(73);
  class DynamicEntryPlugin {
    constructor(context, entry) {
      this.context = context, this.entry = entry;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("DynamicEntryPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const multiModuleFactory = new MultiModuleFactory;
        compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory), compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
      }), compiler.hooks.make.tapAsync("DynamicEntryPlugin", (compilation, callback) => {
        const addEntry = (entry, name) => {
          const dep = DynamicEntryPlugin.createDependency(entry, name);
          return new Promise((resolve, reject) => {
            compilation.addEntry(this.context, dep, name, err => {
              if (err) return reject(err);
              resolve();
            });
          });
        };
        Promise.resolve(this.entry()).then(entry => {
          "string" == typeof entry || Array.isArray(entry) ? addEntry(entry, "main").then(() => callback(), callback) : "object" == typeof entry && Promise.all(Object.keys(entry).map(name => addEntry(entry[name], name))).then(() => callback(), callback);
        });
      });
    }
  }
  module.exports = DynamicEntryPlugin, DynamicEntryPlugin.createDependency = (entry, name) => Array.isArray(entry) ? MultiEntryPlugin.createDependency(entry, name) : SingleEntryPlugin.createDependency(entry, name);
}, function(module, exports, __webpack_require__) {
  "use strict";
  const identifierUtils = __webpack_require__(14);
  module.exports = class {
    constructor(options) {
      this.options = options || {};
    }
    apply(compiler) {
      const portableIds = this.options.portableIds;
      compiler.hooks.compilation.tap("RecordIdsPlugin", compilation => {
        compilation.hooks.recordModules.tap("RecordIdsPlugin", (modules, records) => {
          records.modules || (records.modules = {}), records.modules.byIdentifier || (records.modules.byIdentifier = {}), 
          records.modules.usedIds || (records.modules.usedIds = {});
          for (const module of modules) {
            if ("number" != typeof module.id) continue;
            const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();
            records.modules.byIdentifier[identifier] = module.id, records.modules.usedIds[module.id] = module.id;
          }
        }), compilation.hooks.reviveModules.tap("RecordIdsPlugin", (modules, records) => {
          if (records.modules) {
            if (records.modules.byIdentifier) {
              const usedIds = new Set;
              for (const module of modules) {
                if (null !== module.id) continue;
                const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier(), id = records.modules.byIdentifier[identifier];
                void 0 !== id && (usedIds.has(id) || (usedIds.add(id), module.id = id));
              }
            }
            Array.isArray(records.modules.usedIds) && (compilation.usedModuleIds = new Set(records.modules.usedIds));
          }
        });
        const getModuleIdentifier = module => portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier(), getChunkSources = chunk => {
          const sources = [];
          for (const chunkGroup of chunk.groupsIterable) {
            const index = chunkGroup.chunks.indexOf(chunk);
            if (chunkGroup.name) sources.push(`${index} ${chunkGroup.name}`); else for (const origin of chunkGroup.origins) origin.module && (origin.request ? sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.request}`) : "string" == typeof origin.loc ? sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`) : origin.loc && "object" == typeof origin.loc && origin.loc.start && sources.push(`${index} ${getModuleIdentifier(origin.module)} ${JSON.stringify(origin.loc.start)}`));
          }
          return sources;
        };
        compilation.hooks.recordChunks.tap("RecordIdsPlugin", (chunks, records) => {
          records.chunks || (records.chunks = {}), records.chunks.byName || (records.chunks.byName = {}), 
          records.chunks.bySource || (records.chunks.bySource = {});
          const usedIds = new Set;
          for (const chunk of chunks) {
            if ("number" != typeof chunk.id) continue;
            const name = chunk.name;
            name && (records.chunks.byName[name] = chunk.id);
            const sources = getChunkSources(chunk);
            for (const source of sources) records.chunks.bySource[source] = chunk.id;
            usedIds.add(chunk.id);
          }
          records.chunks.usedIds = Array.from(usedIds).sort();
        }), compilation.hooks.reviveChunks.tap("RecordIdsPlugin", (chunks, records) => {
          if (!records.chunks) return;
          const usedIds = new Set;
          if (records.chunks.byName) for (const chunk of chunks) {
            if (null !== chunk.id) continue;
            if (!chunk.name) continue;
            const id = records.chunks.byName[chunk.name];
            void 0 !== id && (usedIds.has(id) || (usedIds.add(id), chunk.id = id));
          }
          if (records.chunks.bySource) for (const chunk of chunks) {
            const sources = getChunkSources(chunk);
            for (const source of sources) {
              const id = records.chunks.bySource[source];
              if (void 0 !== id && !usedIds.has(id)) {
                usedIds.add(id), chunk.id = id;
                break;
              }
            }
          }
          Array.isArray(records.chunks.usedIds) && (compilation.usedChunkIds = new Set(records.chunks.usedIds));
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5), ParserHelpers = __webpack_require__(9), NullFactory = __webpack_require__(10), REPLACEMENTS = {
    __webpack_require__: "__webpack_require__",
    __webpack_public_path__: "__webpack_require__.p",
    __webpack_modules__: "__webpack_require__.m",
    __webpack_chunk_load__: "__webpack_require__.e",
    __non_webpack_require__: "require",
    __webpack_nonce__: "__webpack_require__.nc",
    "require.onError": "__webpack_require__.oe"
  }, NO_WEBPACK_REQUIRE = {
    __non_webpack_require__: !0
  }, REPLACEMENT_TYPES = {
    __webpack_public_path__: "string",
    __webpack_require__: "function",
    __webpack_modules__: "object",
    __webpack_chunk_load__: "function",
    __webpack_nonce__: "string"
  };
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("APIPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const handler = parser => {
          Object.keys(REPLACEMENTS).forEach(key => {
            parser.hooks.expression.for(key).tap("APIPlugin", NO_WEBPACK_REQUIRE[key] ? ParserHelpers.toConstantDependency(parser, REPLACEMENTS[key]) : ParserHelpers.toConstantDependencyWithWebpackRequire(parser, REPLACEMENTS[key]));
            const type = REPLACEMENT_TYPES[key];
            type && parser.hooks.evaluateTypeof.for(key).tap("APIPlugin", ParserHelpers.evaluateToString(type));
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("APIPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("APIPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("APIPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5), NullFactory = __webpack_require__(10), ParserHelpers = __webpack_require__(9), getQuery = request => {
    const i = request.indexOf("?");
    return -1 !== i ? request.substr(i) : "";
  }, collectDeclaration = (declarations, pattern) => {
    const stack = [ pattern ];
    for (;stack.length > 0; ) {
      const node = stack.pop();
      switch (node.type) {
       case "Identifier":
        declarations.add(node.name);
        break;

       case "ArrayPattern":
        for (const element of node.elements) element && stack.push(element);
        break;

       case "AssignmentPattern":
        stack.push(node.left);
        break;

       case "ObjectPattern":
        for (const property of node.properties) stack.push(property.value);
        break;

       case "RestElement":
        stack.push(node.argument);
      }
    }
  }, getHoistedDeclarations = (branch, includeFunctionDeclarations) => {
    const declarations = new Set, stack = [ branch ];
    for (;stack.length > 0; ) {
      const node = stack.pop();
      if (node) switch (node.type) {
       case "BlockStatement":
        for (const stmt of node.body) stack.push(stmt);
        break;

       case "IfStatement":
        stack.push(node.consequent), stack.push(node.alternate);
        break;

       case "ForStatement":
        stack.push(node.init), stack.push(node.body);
        break;

       case "ForInStatement":
       case "ForOfStatement":
        stack.push(node.left), stack.push(node.body);
        break;

       case "DoWhileStatement":
       case "WhileStatement":
       case "LabeledStatement":
        stack.push(node.body);
        break;

       case "SwitchStatement":
        for (const cs of node.cases) for (const consequent of cs.consequent) stack.push(consequent);
        break;

       case "TryStatement":
        stack.push(node.block), node.handler && stack.push(node.handler.body), stack.push(node.finalizer);
        break;

       case "FunctionDeclaration":
        includeFunctionDeclarations && collectDeclaration(declarations, node.id);
        break;

       case "VariableDeclaration":
        if ("var" === node.kind) for (const decl of node.declarations) collectDeclaration(declarations, decl.id);
      }
    }
    return Array.from(declarations);
  };
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("ConstPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const handler = parser => {
          parser.hooks.statementIf.tap("ConstPlugin", statement => {
            if (parser.scope.isAsmJs) return;
            const param = parser.evaluateExpression(statement.test), bool = param.asBool();
            if ("boolean" == typeof bool) {
              if ("Literal" !== statement.test.type) {
                const dep = new ConstDependency("" + bool, param.range);
                dep.loc = statement.loc, parser.state.current.addDependency(dep);
              }
              const branchToRemove = bool ? statement.alternate : statement.consequent;
              if (branchToRemove) {
                let declarations, replacement;
                declarations = parser.scope.isStrict ? getHoistedDeclarations(branchToRemove, !1) : getHoistedDeclarations(branchToRemove, !0), 
                replacement = declarations.length > 0 ? `{ var ${declarations.join(", ")}; }` : "{}";
                const dep = new ConstDependency(replacement, branchToRemove.range);
                dep.loc = branchToRemove.loc, parser.state.current.addDependency(dep);
              }
              return bool;
            }
          }), parser.hooks.expressionConditionalOperator.tap("ConstPlugin", expression => {
            if (parser.scope.isAsmJs) return;
            const param = parser.evaluateExpression(expression.test), bool = param.asBool();
            if ("boolean" == typeof bool) {
              if ("Literal" !== expression.test.type) {
                const dep = new ConstDependency(" " + bool, param.range);
                dep.loc = expression.loc, parser.state.current.addDependency(dep);
              }
              const branchToRemove = bool ? expression.alternate : expression.consequent, dep = new ConstDependency("undefined", branchToRemove.range);
              return dep.loc = branchToRemove.loc, parser.state.current.addDependency(dep), bool;
            }
          }), parser.hooks.expressionLogicalOperator.tap("ConstPlugin", expression => {
            if (!parser.scope.isAsmJs && ("&&" === expression.operator || "||" === expression.operator)) {
              const param = parser.evaluateExpression(expression.left), bool = param.asBool();
              if ("boolean" == typeof bool) {
                const keepRight = "&&" === expression.operator && bool || "||" === expression.operator && !bool;
                if (param.isBoolean() || keepRight) {
                  const dep = new ConstDependency(" " + bool, param.range);
                  dep.loc = expression.loc, parser.state.current.addDependency(dep);
                } else parser.walkExpression(expression.left);
                if (!keepRight) {
                  const dep = new ConstDependency("false", expression.right.range);
                  dep.loc = expression.loc, parser.state.current.addDependency(dep);
                }
                return keepRight;
              }
            }
          }), parser.hooks.evaluateIdentifier.for("__resourceQuery").tap("ConstPlugin", expr => {
            if (!parser.scope.isAsmJs && parser.state.module) return ParserHelpers.evaluateToString(getQuery(parser.state.module.resource))(expr);
          }), parser.hooks.expression.for("__resourceQuery").tap("ConstPlugin", () => {
            if (!parser.scope.isAsmJs && parser.state.module) return parser.state.current.addVariable("__resourceQuery", JSON.stringify(getQuery(parser.state.module.resource))), 
            !0;
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("ConstPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ConstPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("ConstPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("CommonJsStuffPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const handler = (parser, parserOptions) => {
          parser.hooks.expression.for("require.main.require").tap("CommonJsStuffPlugin", ParserHelpers.expressionIsUnsupported(parser, "require.main.require is not supported by webpack.")), 
          parser.hooks.expression.for("module.parent.require").tap("CommonJsStuffPlugin", ParserHelpers.expressionIsUnsupported(parser, "module.parent.require is not supported by webpack.")), 
          parser.hooks.expression.for("require.main").tap("CommonJsStuffPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, "__webpack_require__.c[__webpack_require__.s]")), 
          parser.hooks.expression.for("module.loaded").tap("CommonJsStuffPlugin", expr => (parser.state.module.buildMeta.moduleConcatenationBailout = "module.loaded", 
          ParserHelpers.toConstantDependency(parser, "module.l")(expr))), parser.hooks.expression.for("module.id").tap("CommonJsStuffPlugin", expr => (parser.state.module.buildMeta.moduleConcatenationBailout = "module.id", 
          ParserHelpers.toConstantDependency(parser, "module.i")(expr))), parser.hooks.expression.for("module.exports").tap("CommonJsStuffPlugin", () => {
            const module = parser.state.module;
            if (!(module.buildMeta && module.buildMeta.exportsType)) return !0;
          }), parser.hooks.evaluateIdentifier.for("module.hot").tap("CommonJsStuffPlugin", ParserHelpers.evaluateToIdentifier("module.hot", !1)), 
          parser.hooks.expression.for("module").tap("CommonJsStuffPlugin", () => {
            const module = parser.state.module, isHarmony = module.buildMeta && module.buildMeta.exportsType;
            let moduleJsPath = path.join(__dirname, "..", "buildin", isHarmony ? "harmony-module.js" : "module.js");
            return module.context && (moduleJsPath = path.relative(parser.state.module.context, moduleJsPath), 
            /^[A-Z]:/i.test(moduleJsPath) || (moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/"))), 
            ParserHelpers.addParsedVariableToModule(parser, "module", `require(${JSON.stringify(moduleJsPath)})(module)`);
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("CommonJsStuffPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("CommonJsStuffPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5), NullFactory = __webpack_require__(10);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("CompatibilityPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template), 
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("CompatibilityPlugin", (parser, parserOptions) => {
          (void 0 === parserOptions.browserify || parserOptions.browserify) && parser.hooks.call.for("require").tap("CompatibilityPlugin", expr => {
            if (2 !== expr.arguments.length) return;
            const second = parser.evaluateExpression(expr.arguments[1]);
            if (!second.isBoolean()) return;
            if (!0 !== second.asBool()) return;
            const dep = new ConstDependency("require", expr.callee.range);
            if (dep.loc = expr.loc, parser.state.current.dependencies.length > 1) {
              const last = parser.state.current.dependencies[parser.state.current.dependencies.length - 1];
              last.critical && last.options && "." === last.options.request && "." === last.userRequest && last.options.recursive && parser.state.current.dependencies.pop();
            }
            return parser.state.current.addDependency(dep), !0;
          });
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const REGEXP_HASH = /\[hash(?::(\d+))?\]/gi, REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/gi, REGEXP_MODULEHASH = /\[modulehash(?::(\d+))?\]/gi, REGEXP_CONTENTHASH = /\[contenthash(?::(\d+))?\]/gi, REGEXP_NAME = /\[name\]/gi, REGEXP_ID = /\[id\]/gi, REGEXP_MODULEID = /\[moduleid\]/gi, REGEXP_FILE = /\[file\]/gi, REGEXP_QUERY = /\[query\]/gi, REGEXP_FILEBASE = /\[filebase\]/gi, REGEXP_URL = /\[url\]/gi, REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, "i"), REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, "i"), REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, "i"), REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, "i"), withHashLength = (replacer, handlerFn, assetInfo) => (match, hashLength, ...args) => {
    assetInfo && (assetInfo.immutable = !0);
    const length = hashLength && parseInt(hashLength, 10);
    if (length && handlerFn) return handlerFn(length);
    const hash = replacer(match, hashLength, ...args);
    return length ? hash.slice(0, length) : hash;
  }, getReplacer = (value, allowEmpty) => (match, ...args) => {
    const input = args[args.length - 1];
    if (null == value) {
      if (!allowEmpty) throw new Error(`Path variable ${match} not implemented in this context: ${input}`);
      return "";
    }
    return "" + escapePathVariables(value);
  }, escapePathVariables = value => "string" == typeof value ? value.replace(/\[(\\*[\w:]+\\*)\]/gi, "[\\$1\\]") : value, replacePathVariables = (path, data, assetInfo) => {
    const chunk = data.chunk, chunkId = chunk && chunk.id, chunkName = chunk && (chunk.name || chunk.id), chunkHash = chunk && (chunk.renderedHash || chunk.hash), chunkHashWithLength = chunk && chunk.hashWithLength, contentHashType = data.contentHashType, contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash, contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength, module = data.module, moduleId = module && module.id, moduleHash = module && (module.renderedHash || module.hash), moduleHashWithLength = module && module.hashWithLength;
    if ("function" == typeof path && (path = path(data)), data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) throw new Error(`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`);
    return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)).replace(REGEXP_QUERY, getReplacer(data.query, !0)).replace(REGEXP_URL, getReplacer(data.url)).replace(/\[\\(\\*[\w:]+\\*)\\\]/gi, "[$1]");
  };
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("TemplatedPathPlugin", compilation => {
        const mainTemplate = compilation.mainTemplate;
        mainTemplate.hooks.assetPath.tap("TemplatedPathPlugin", replacePathVariables), mainTemplate.hooks.globalHash.tap("TemplatedPathPlugin", (chunk, paths) => {
          const outputOptions = mainTemplate.outputOptions, publicPath = outputOptions.publicPath || "", filename = outputOptions.filename || "", chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
          return !!(REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) || (!!REGEXP_HASH_FOR_TEST.test(filename) || (!!REGEXP_HASH_FOR_TEST.test(chunkFilename) || (!!REGEXP_HASH_FOR_TEST.test(paths.join("|")) || void 0)));
        }), mainTemplate.hooks.hashForChunk.tap("TemplatedPathPlugin", (hash, chunk) => {
          const outputOptions = mainTemplate.outputOptions, chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
          REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename) && hash.update(JSON.stringify(chunk.getChunkMaps(!0).hash)), 
          REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename) && hash.update(JSON.stringify(chunk.getChunkMaps(!0).contentHash.javascript || {})), 
          REGEXP_NAME_FOR_TEST.test(chunkFilename) && hash.update(JSON.stringify(chunk.getChunkMaps(!0).name));
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const CaseSensitiveModulesWarning = __webpack_require__(298);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("WarnCaseSensitiveModulesPlugin", compilation => {
        compilation.hooks.seal.tap("WarnCaseSensitiveModulesPlugin", () => {
          const moduleWithoutCase = new Map;
          for (const module of compilation.modules) {
            const identifier = module.identifier().toLowerCase(), array = moduleWithoutCase.get(identifier);
            array ? array.push(module) : moduleWithoutCase.set(identifier, [ module ]);
          }
          for (const pair of moduleWithoutCase) {
            const array = pair[1];
            array.length > 1 && compilation.warnings.push(new CaseSensitiveModulesWarning(array));
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(modules) {
      const sortedModules = (modules => modules.slice().sort((a, b) => {
        const aIdent = a.identifier(), bIdent = b.identifier();
        return aIdent < bIdent ? -1 : aIdent > bIdent ? 1 : 0;
      }))(modules);
      super("There are multiple modules with names that only differ in casing.\nThis can lead to unexpected behavior when compiling on a filesystem with other case-semantic.\nUse equal casing. Compare these module identifiers:\n" + (modules => modules.map(m => {
        let message = "* " + m.identifier();
        const validReasons = m.reasons.filter(reason => reason.module);
        return validReasons.length > 0 && (message += `\n    Used by ${validReasons.length} module(s), i. e.`, 
        message += "\n    " + validReasons[0].module.identifier()), message;
      }).join("\n"))(sortedModules)), this.name = "CaseSensitiveModulesWarning", this.origin = this.module = sortedModules[0], 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("UseStrictPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const handler = parser => {
          parser.hooks.program.tap("UseStrictPlugin", ast => {
            const firstNode = ast.body[0];
            if (firstNode && "ExpressionStatement" === firstNode.type && "Literal" === firstNode.expression.type && "use strict" === firstNode.expression.value) {
              const dep = new ConstDependency("", firstNode.range);
              dep.loc = firstNode.loc, parser.state.current.addDependency(dep), parser.state.module.buildInfo.strict = !0;
            }
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("UseStrictPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("UseStrictPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("UseStrictPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const LoaderDependency = __webpack_require__(301), NormalModule = __webpack_require__(60);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("LoaderPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);
      }), compiler.hooks.compilation.tap("LoaderPlugin", compilation => {
        compilation.hooks.normalModuleLoader.tap("LoaderPlugin", (loaderContext, module) => {
          loaderContext.loadModule = (request, callback) => {
            const dep = new LoaderDependency(request);
            dep.loc = {
              name: request
            };
            const factory = compilation.dependencyFactories.get(dep.constructor);
            if (void 0 === factory) return callback(new Error("No module factory available for dependency type: " + dep.constructor.name));
            compilation.semaphore.release(), compilation.addModuleDependencies(module, [ {
              factory: factory,
              dependencies: [ dep ]
            } ], !0, "lm", !0, err => {
              compilation.semaphore.acquire(() => {
                if (err) return callback(err);
                if (!dep.module) return callback(new Error("Cannot load the module"));
                if (dep.module instanceof NormalModule && dep.module.error) return callback(dep.module.error);
                if (!dep.module._source) throw new Error("The module created for a LoaderDependency must have a property _source");
                let source, map;
                const moduleSource = dep.module._source;
                if (moduleSource.sourceAndMap) {
                  const sourceAndMap = moduleSource.sourceAndMap();
                  map = sourceAndMap.map, source = sourceAndMap.source;
                } else map = moduleSource.map(), source = moduleSource.source();
                if (dep.module.buildInfo.fileDependencies) for (const d of dep.module.buildInfo.fileDependencies) loaderContext.addDependency(d);
                if (dep.module.buildInfo.contextDependencies) for (const d of dep.module.buildInfo.contextDependencies) loaderContext.addContextDependency(d);
                return callback(null, source, map, dep.module);
              });
            });
          };
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleDependency = __webpack_require__(4);
  module.exports = class extends ModuleDependency {
    constructor(request) {
      super(request);
    }
    get type() {
      return "loader";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5), CommonJsRequireDependency = __webpack_require__(128), CommonJsRequireContextDependency = __webpack_require__(129), RequireResolveDependency = __webpack_require__(130), RequireResolveContextDependency = __webpack_require__(131), RequireResolveHeaderDependency = __webpack_require__(132), RequireHeaderDependency = __webpack_require__(133), NullFactory = __webpack_require__(10), RequireResolveDependencyParserPlugin = __webpack_require__(305), CommonJsRequireDependencyParserPlugin = __webpack_require__(306), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("CommonJsPlugin", (compilation, {contextModuleFactory: contextModuleFactory, normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(CommonJsRequireDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(CommonJsRequireDependency, new CommonJsRequireDependency.Template), 
        compilation.dependencyFactories.set(CommonJsRequireContextDependency, contextModuleFactory), 
        compilation.dependencyTemplates.set(CommonJsRequireContextDependency, new CommonJsRequireContextDependency.Template), 
        compilation.dependencyFactories.set(RequireResolveDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(RequireResolveDependency, new RequireResolveDependency.Template), 
        compilation.dependencyFactories.set(RequireResolveContextDependency, contextModuleFactory), 
        compilation.dependencyTemplates.set(RequireResolveContextDependency, new RequireResolveContextDependency.Template), 
        compilation.dependencyFactories.set(RequireResolveHeaderDependency, new NullFactory), 
        compilation.dependencyTemplates.set(RequireResolveHeaderDependency, new RequireResolveHeaderDependency.Template), 
        compilation.dependencyFactories.set(RequireHeaderDependency, new NullFactory), compilation.dependencyTemplates.set(RequireHeaderDependency, new RequireHeaderDependency.Template);
        const handler = (parser, parserOptions) => {
          if (void 0 !== parserOptions.commonjs && !parserOptions.commonjs) return;
          const requireExpressions = [ "require", "require.resolve", "require.resolveWeak" ];
          for (let expression of requireExpressions) parser.hooks.typeof.for(expression).tap("CommonJsPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function"))), 
          parser.hooks.evaluateTypeof.for(expression).tap("CommonJsPlugin", ParserHelpers.evaluateToString("function")), 
          parser.hooks.evaluateIdentifier.for(expression).tap("CommonJsPlugin", ParserHelpers.evaluateToIdentifier(expression, !0));
          parser.hooks.evaluateTypeof.for("module").tap("CommonJsPlugin", ParserHelpers.evaluateToString("object")), 
          parser.hooks.assign.for("require").tap("CommonJsPlugin", expr => {
            const dep = new ConstDependency("var require;", 0);
            return dep.loc = expr.loc, parser.state.current.addDependency(dep), parser.scope.definitions.add("require"), 
            !0;
          }), parser.hooks.canRename.for("require").tap("CommonJsPlugin", () => !0), parser.hooks.rename.for("require").tap("CommonJsPlugin", expr => {
            const dep = new ConstDependency("var require;", 0);
            return dep.loc = expr.loc, parser.state.current.addDependency(dep), !1;
          }), parser.hooks.typeof.for("module").tap("CommonJsPlugin", () => !0), parser.hooks.evaluateTypeof.for("exports").tap("CommonJsPlugin", ParserHelpers.evaluateToString("object")), 
          new CommonJsRequireDependencyParserPlugin(options).apply(parser), new RequireResolveDependencyParserPlugin(options).apply(parser);
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("CommonJsPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("CommonJsPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(message) {
      super(), this.name = "CriticalDependencyWarning", this.message = "Critical dependency: " + message, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(dep, source, runtime) {
      const moduleExports = runtime.moduleExports({
        module: dep.module,
        request: dep.request
      });
      if (dep.module) if (dep.valueRange) {
        if (Array.isArray(dep.replaces)) for (let i = 0; i < dep.replaces.length; i++) {
          const rep = dep.replaces[i];
          source.replace(rep.range[0], rep.range[1] - 1, rep.value);
        }
        source.replace(dep.valueRange[1], dep.range[1] - 1, ")"), source.replace(dep.range[0], dep.valueRange[0] - 1, `${moduleExports}.resolve(${"string" == typeof dep.prepend ? JSON.stringify(dep.prepend) : ""}`);
      } else source.replace(dep.range[0], dep.range[1] - 1, moduleExports + ".resolve"); else source.replace(dep.range[0], dep.range[1] - 1, moduleExports);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireResolveDependency = __webpack_require__(130), RequireResolveContextDependency = __webpack_require__(131), RequireResolveHeaderDependency = __webpack_require__(132), ContextDependencyHelpers = __webpack_require__(33);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(parser) {
      const options = this.options, process = (expr, weak) => {
        if (1 !== expr.arguments.length) return;
        const param = parser.evaluateExpression(expr.arguments[0]);
        if (param.isConditional()) {
          for (const option of param.options) {
            void 0 === processItem(expr, option, weak) && processContext(expr, option, weak);
          }
          const dep = new RequireResolveHeaderDependency(expr.callee.range);
          return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
        }
        {
          void 0 === processItem(expr, param, weak) && processContext(expr, param, weak);
          const dep = new RequireResolveHeaderDependency(expr.callee.range);
          return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
        }
      }, processItem = (expr, param, weak) => {
        if (param.isString()) {
          const dep = new RequireResolveDependency(param.string, param.range);
          return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, dep.weak = weak, 
          parser.state.current.addDependency(dep), !0;
        }
      }, processContext = (expr, param, weak) => {
        const dep = ContextDependencyHelpers.create(RequireResolveContextDependency, param.range, param, expr, options, {
          mode: weak ? "weak" : "sync"
        }, parser);
        if (dep) return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
        !0;
      };
      parser.hooks.call.for("require.resolve").tap("RequireResolveDependencyParserPlugin", expr => process(expr, !1)), 
      parser.hooks.call.for("require.resolveWeak").tap("RequireResolveDependencyParserPlugin", expr => process(expr, !0));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const CommonJsRequireDependency = __webpack_require__(128), CommonJsRequireContextDependency = __webpack_require__(129), RequireHeaderDependency = __webpack_require__(133), LocalModuleDependency = __webpack_require__(47), ContextDependencyHelpers = __webpack_require__(33), LocalModulesHelpers = __webpack_require__(76), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(parser) {
      const options = this.options, processItem = (expr, param) => {
        if (param.isString()) {
          const dep = new CommonJsRequireDependency(param.string, param.range);
          return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
          !0;
        }
      };
      parser.hooks.expression.for("require.cache").tap("CommonJsRequireDependencyParserPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, "__webpack_require__.c")), 
      parser.hooks.expression.for("require").tap("CommonJsRequireDependencyParserPlugin", expr => {
        const dep = new CommonJsRequireContextDependency({
          request: options.unknownContextRequest,
          recursive: options.unknownContextRecursive,
          regExp: options.unknownContextRegExp,
          mode: "sync"
        }, expr.range);
        return dep.critical = options.unknownContextCritical && "require function is used in a way in which dependencies cannot be statically extracted", 
        dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
        !0;
      });
      const createHandler = callNew => expr => {
        if (1 !== expr.arguments.length) return;
        let localModule;
        const param = parser.evaluateExpression(expr.arguments[0]);
        if (param.isConditional()) {
          let isExpression = !1;
          const prevLength = parser.state.current.dependencies.length, dep = new RequireHeaderDependency(expr.callee.range);
          dep.loc = expr.loc, parser.state.current.addDependency(dep);
          for (const p of param.options) {
            void 0 === processItem(expr, p) && (isExpression = !0);
          }
          if (!isExpression) return !0;
          parser.state.current.dependencies.length = prevLength;
        }
        if (param.isString() && (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string))) {
          const dep = new LocalModuleDependency(localModule, expr.range, callNew);
          return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
        }
        if (void 0 === processItem(expr, param)) ((expr, param) => {
          const dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency, expr.range, param, expr, options, {}, parser);
          if (dep) dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep);
        })(expr, param); else {
          const dep = new RequireHeaderDependency(expr.callee.range);
          dep.loc = expr.loc, parser.state.current.addDependency(dep);
        }
        return !0;
      };
      parser.hooks.call.for("require").tap("CommonJsRequireDependencyParserPlugin", createHandler(!1)), 
      parser.hooks.new.for("require").tap("CommonJsRequireDependencyParserPlugin", createHandler(!0)), 
      parser.hooks.call.for("module.require").tap("CommonJsRequireDependencyParserPlugin", createHandler(!1)), 
      parser.hooks.new.for("module.require").tap("CommonJsRequireDependencyParserPlugin", createHandler(!0));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(module, name, idx) {
      this.module = module, this.name = name, this.idx = idx, this.used = !1;
    }
    flagUsed() {
      this.used = !0;
    }
    variableName() {
      return "__WEBPACK_LOCAL_MODULE_" + this.idx + "__";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const HarmonyCompatibilityDependency = __webpack_require__(48), HarmonyInitDependency = __webpack_require__(134), HarmonyImportSpecifierDependency = __webpack_require__(49), HarmonyImportSideEffectDependency = __webpack_require__(34), HarmonyExportHeaderDependency = __webpack_require__(136), HarmonyExportExpressionDependency = __webpack_require__(77), HarmonyExportSpecifierDependency = __webpack_require__(78), HarmonyExportImportedSpecifierDependency = __webpack_require__(50), HarmonyAcceptDependency = __webpack_require__(137), HarmonyAcceptImportDependency = __webpack_require__(138), NullFactory = __webpack_require__(10), HarmonyDetectionParserPlugin = __webpack_require__(309), HarmonyImportDependencyParserPlugin = __webpack_require__(310), HarmonyExportDependencyParserPlugin = __webpack_require__(311), HarmonyTopLevelThisParserPlugin = __webpack_require__(312);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("HarmonyModulesPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(HarmonyCompatibilityDependency, new NullFactory), 
        compilation.dependencyTemplates.set(HarmonyCompatibilityDependency, new HarmonyCompatibilityDependency.Template), 
        compilation.dependencyFactories.set(HarmonyInitDependency, new NullFactory), compilation.dependencyTemplates.set(HarmonyInitDependency, new HarmonyInitDependency.Template), 
        compilation.dependencyFactories.set(HarmonyImportSideEffectDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(HarmonyImportSideEffectDependency, new HarmonyImportSideEffectDependency.Template), 
        compilation.dependencyFactories.set(HarmonyImportSpecifierDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(HarmonyImportSpecifierDependency, new HarmonyImportSpecifierDependency.Template), 
        compilation.dependencyFactories.set(HarmonyExportHeaderDependency, new NullFactory), 
        compilation.dependencyTemplates.set(HarmonyExportHeaderDependency, new HarmonyExportHeaderDependency.Template), 
        compilation.dependencyFactories.set(HarmonyExportExpressionDependency, new NullFactory), 
        compilation.dependencyTemplates.set(HarmonyExportExpressionDependency, new HarmonyExportExpressionDependency.Template), 
        compilation.dependencyFactories.set(HarmonyExportSpecifierDependency, new NullFactory), 
        compilation.dependencyTemplates.set(HarmonyExportSpecifierDependency, new HarmonyExportSpecifierDependency.Template), 
        compilation.dependencyFactories.set(HarmonyExportImportedSpecifierDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(HarmonyExportImportedSpecifierDependency, new HarmonyExportImportedSpecifierDependency.Template), 
        compilation.dependencyFactories.set(HarmonyAcceptDependency, new NullFactory), compilation.dependencyTemplates.set(HarmonyAcceptDependency, new HarmonyAcceptDependency.Template), 
        compilation.dependencyFactories.set(HarmonyAcceptImportDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(HarmonyAcceptImportDependency, new HarmonyAcceptImportDependency.Template);
        const handler = (parser, parserOptions) => {
          (void 0 === parserOptions.harmony || parserOptions.harmony) && ((new HarmonyDetectionParserPlugin).apply(parser), 
          new HarmonyImportDependencyParserPlugin(this.options).apply(parser), new HarmonyExportDependencyParserPlugin(this.options).apply(parser), 
          (new HarmonyTopLevelThisParserPlugin).apply(parser));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("HarmonyModulesPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("HarmonyModulesPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const HarmonyCompatibilityDependency = __webpack_require__(48), HarmonyInitDependency = __webpack_require__(134);
  module.exports = class {
    apply(parser) {
      parser.hooks.program.tap("HarmonyDetectionParserPlugin", ast => {
        const isStrictHarmony = "javascript/esm" === parser.state.module.type;
        if (isStrictHarmony || ast.body.some(statement => "ImportDeclaration" === statement.type || "ExportDefaultDeclaration" === statement.type || "ExportNamedDeclaration" === statement.type || "ExportAllDeclaration" === statement.type)) {
          const module = parser.state.module, compatDep = new HarmonyCompatibilityDependency(module);
          compatDep.loc = {
            start: {
              line: -1,
              column: 0
            },
            end: {
              line: -1,
              column: 0
            },
            index: -3
          }, module.addDependency(compatDep);
          const initDep = new HarmonyInitDependency(module);
          initDep.loc = {
            start: {
              line: -1,
              column: 0
            },
            end: {
              line: -1,
              column: 0
            },
            index: -2
          }, module.addDependency(initDep), parser.state.harmonyParserScope = parser.state.harmonyParserScope || {}, 
          parser.scope.isStrict = !0, module.buildMeta.exportsType = "namespace", module.buildInfo.strict = !0, 
          module.buildInfo.exportsArgument = "__webpack_exports__", isStrictHarmony && (module.buildMeta.strictHarmonyModule = !0, 
          module.buildInfo.moduleArgument = "__webpack_module__");
        }
      });
      const skipInHarmony = () => {
        const module = parser.state.module;
        if (module && module.buildMeta && module.buildMeta.exportsType) return !0;
      }, nullInHarmony = () => {
        const module = parser.state.module;
        if (module && module.buildMeta && module.buildMeta.exportsType) return null;
      }, nonHarmonyIdentifiers = [ "define", "exports" ];
      for (const identifer of nonHarmonyIdentifiers) parser.hooks.evaluateTypeof.for(identifer).tap("HarmonyDetectionParserPlugin", nullInHarmony), 
      parser.hooks.typeof.for(identifer).tap("HarmonyDetectionParserPlugin", skipInHarmony), 
      parser.hooks.evaluate.for(identifer).tap("HarmonyDetectionParserPlugin", nullInHarmony), 
      parser.hooks.expression.for(identifer).tap("HarmonyDetectionParserPlugin", skipInHarmony), 
      parser.hooks.call.for(identifer).tap("HarmonyDetectionParserPlugin", skipInHarmony);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {SyncBailHook: SyncBailHook} = __webpack_require__(6), HarmonyImportSideEffectDependency = __webpack_require__(34), HarmonyImportSpecifierDependency = __webpack_require__(49), HarmonyAcceptImportDependency = __webpack_require__(138), HarmonyAcceptDependency = __webpack_require__(137), ConstDependency = __webpack_require__(5);
  module.exports = class {
    constructor(moduleOptions) {
      this.strictExportPresence = moduleOptions.strictExportPresence, this.strictThisContextOnImports = moduleOptions.strictThisContextOnImports;
    }
    apply(parser) {
      parser.hooks.import.tap("HarmonyImportDependencyParserPlugin", (statement, source) => {
        parser.state.lastHarmonyImportOrder = (parser.state.lastHarmonyImportOrder || 0) + 1;
        const clearDep = new ConstDependency("", statement.range);
        clearDep.loc = statement.loc, parser.state.module.addDependency(clearDep);
        const sideEffectDep = new HarmonyImportSideEffectDependency(source, parser.state.module, parser.state.lastHarmonyImportOrder, parser.state.harmonyParserScope);
        return sideEffectDep.loc = statement.loc, parser.state.module.addDependency(sideEffectDep), 
        !0;
      }), parser.hooks.importSpecifier.tap("HarmonyImportDependencyParserPlugin", (statement, source, id, name) => (parser.scope.definitions.delete(name), 
      parser.scope.renames.set(name, "imported var"), parser.state.harmonySpecifier || (parser.state.harmonySpecifier = new Map), 
      parser.state.harmonySpecifier.set(name, {
        source: source,
        id: id,
        sourceOrder: parser.state.lastHarmonyImportOrder
      }), !0)), parser.hooks.expression.for("imported var").tap("HarmonyImportDependencyParserPlugin", expr => {
        const name = expr.name, settings = parser.state.harmonySpecifier.get(name), dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, settings.id, name, expr.range, this.strictExportPresence);
        return dep.shorthand = parser.scope.inShorthand, dep.directImport = !0, dep.loc = expr.loc, 
        parser.state.module.addDependency(dep), !0;
      }), parser.hooks.expressionAnyMember.for("imported var").tap("HarmonyImportDependencyParserPlugin", expr => {
        const name = expr.object.name, settings = parser.state.harmonySpecifier.get(name);
        if (null !== settings.id) return !1;
        const dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, expr.property.name || expr.property.value, name, expr.range, this.strictExportPresence);
        return dep.shorthand = parser.scope.inShorthand, dep.directImport = !1, dep.loc = expr.loc, 
        parser.state.module.addDependency(dep), !0;
      }), this.strictThisContextOnImports && parser.hooks.callAnyMember.for("imported var").tap("HarmonyImportDependencyParserPlugin", expr => {
        if ("MemberExpression" !== expr.callee.type) return;
        if ("Identifier" !== expr.callee.object.type) return;
        const name = expr.callee.object.name, settings = parser.state.harmonySpecifier.get(name);
        if (null !== settings.id) return !1;
        const dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, expr.callee.property.name || expr.callee.property.value, name, expr.callee.range, this.strictExportPresence);
        return dep.shorthand = parser.scope.inShorthand, dep.directImport = !1, dep.namespaceObjectAsContext = !0, 
        dep.loc = expr.callee.loc, parser.state.module.addDependency(dep), expr.arguments && parser.walkExpressions(expr.arguments), 
        !0;
      }), parser.hooks.call.for("imported var").tap("HarmonyImportDependencyParserPlugin", expr => {
        const args = expr.arguments, fullExpr = expr;
        if ("Identifier" !== (expr = expr.callee).type) return;
        const name = expr.name, settings = parser.state.harmonySpecifier.get(name), dep = new HarmonyImportSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, settings.id, name, expr.range, this.strictExportPresence);
        return dep.directImport = !0, dep.callArgs = args, dep.call = fullExpr, dep.loc = expr.loc, 
        parser.state.module.addDependency(dep), args && parser.walkExpressions(args), !0;
      }), parser.hooks.hotAcceptCallback || (parser.hooks.hotAcceptCallback = new SyncBailHook([ "expression", "requests" ])), 
      parser.hooks.hotAcceptWithoutCallback || (parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([ "expression", "requests" ])), 
      parser.hooks.hotAcceptCallback.tap("HarmonyImportDependencyParserPlugin", (expr, requests) => {
        const harmonyParserScope = parser.state.harmonyParserScope;
        if (!harmonyParserScope) return;
        const dependencies = requests.map(request => {
          const dep = new HarmonyAcceptImportDependency(request, parser.state.module, harmonyParserScope);
          return dep.loc = expr.loc, parser.state.module.addDependency(dep), dep;
        });
        if (dependencies.length > 0) {
          const dep = new HarmonyAcceptDependency(expr.range, dependencies, !0);
          dep.loc = expr.loc, parser.state.module.addDependency(dep);
        }
      }), parser.hooks.hotAcceptWithoutCallback.tap("HarmonyImportDependencyParserPlugin", (expr, requests) => {
        const dependencies = requests.map(request => {
          const dep = new HarmonyAcceptImportDependency(request, parser.state.module, parser.state.harmonyParserScope);
          return dep.loc = expr.loc, parser.state.module.addDependency(dep), dep;
        });
        if (dependencies.length > 0) {
          const dep = new HarmonyAcceptDependency(expr.range, dependencies, !1);
          dep.loc = expr.loc, parser.state.module.addDependency(dep);
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const HarmonyExportExpressionDependency = __webpack_require__(77), HarmonyImportSideEffectDependency = __webpack_require__(34), HarmonyExportHeaderDependency = __webpack_require__(136), HarmonyExportSpecifierDependency = __webpack_require__(78), HarmonyExportImportedSpecifierDependency = __webpack_require__(50), ConstDependency = __webpack_require__(5);
  module.exports = class {
    constructor(moduleOptions) {
      this.strictExportPresence = moduleOptions.strictExportPresence;
    }
    apply(parser) {
      parser.hooks.export.tap("HarmonyExportDependencyParserPlugin", statement => {
        const dep = new HarmonyExportHeaderDependency(statement.declaration && statement.declaration.range, statement.range);
        return dep.loc = Object.create(statement.loc), dep.loc.index = -1, parser.state.current.addDependency(dep), 
        !0;
      }), parser.hooks.exportImport.tap("HarmonyExportDependencyParserPlugin", (statement, source) => {
        parser.state.lastHarmonyImportOrder = (parser.state.lastHarmonyImportOrder || 0) + 1;
        const clearDep = new ConstDependency("", statement.range);
        clearDep.loc = Object.create(statement.loc), clearDep.loc.index = -1, parser.state.current.addDependency(clearDep);
        const sideEffectDep = new HarmonyImportSideEffectDependency(source, parser.state.module, parser.state.lastHarmonyImportOrder, parser.state.harmonyParserScope);
        return sideEffectDep.loc = Object.create(statement.loc), sideEffectDep.loc.index = -1, 
        parser.state.current.addDependency(sideEffectDep), !0;
      }), parser.hooks.exportExpression.tap("HarmonyExportDependencyParserPlugin", (statement, expr) => {
        const comments = parser.getComments([ statement.range[0], expr.range[0] ]), dep = new HarmonyExportExpressionDependency(parser.state.module, expr.range, statement.range, comments.map(c => {
          switch (c.type) {
           case "Block":
            return `/*${c.value}*/`;

           case "Line":
            return `//${c.value}\n`;
          }
          return "";
        }).join(""));
        return dep.loc = Object.create(statement.loc), dep.loc.index = -1, parser.state.current.addDependency(dep), 
        !0;
      }), parser.hooks.exportDeclaration.tap("HarmonyExportDependencyParserPlugin", statement => {}), 
      parser.hooks.exportSpecifier.tap("HarmonyExportDependencyParserPlugin", (statement, id, name, idx) => {
        const rename = parser.scope.renames.get(id);
        let dep;
        const harmonyNamedExports = parser.state.harmonyNamedExports = parser.state.harmonyNamedExports || new Set;
        if (harmonyNamedExports.add(name), "imported var" === rename) {
          const settings = parser.state.harmonySpecifier.get(id);
          dep = new HarmonyExportImportedSpecifierDependency(settings.source, parser.state.module, settings.sourceOrder, parser.state.harmonyParserScope, settings.id, name, harmonyNamedExports, null, this.strictExportPresence);
        } else dep = new HarmonyExportSpecifierDependency(parser.state.module, id, name);
        return dep.loc = Object.create(statement.loc), dep.loc.index = idx, parser.state.current.addDependency(dep), 
        !0;
      }), parser.hooks.exportImportSpecifier.tap("HarmonyExportDependencyParserPlugin", (statement, source, id, name, idx) => {
        const harmonyNamedExports = parser.state.harmonyNamedExports = parser.state.harmonyNamedExports || new Set;
        let harmonyStarExports = null;
        name ? harmonyNamedExports.add(name) : harmonyStarExports = parser.state.harmonyStarExports = parser.state.harmonyStarExports || [];
        const dep = new HarmonyExportImportedSpecifierDependency(source, parser.state.module, parser.state.lastHarmonyImportOrder, parser.state.harmonyParserScope, id, name, harmonyNamedExports, harmonyStarExports && harmonyStarExports.slice(), this.strictExportPresence);
        return harmonyStarExports && harmonyStarExports.push(dep), dep.loc = Object.create(statement.loc), 
        dep.loc.index = idx, parser.state.current.addDependency(dep), !0;
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ConstDependency = __webpack_require__(5);
  module.exports = class {
    apply(parser) {
      parser.hooks.expression.for("this").tap("HarmonyTopLevelThisParserPlugin", node => {
        if (!parser.scope.topLevelScope) return;
        const module = parser.state.module;
        if (!(!module.buildMeta || !module.buildMeta.exportsType)) {
          const dep = new ConstDependency("undefined", node.range, !1);
          dep.loc = node.loc, parser.state.current.addDependency(dep);
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ParserHelpers = __webpack_require__(9), WebpackError = __webpack_require__(1);
  class SystemImportDeprecationWarning extends WebpackError {
    constructor(module, loc) {
      super("System.import() is deprecated and will be removed soon. Use import() instead.\nFor more info visit https://webpack.js.org/guides/code-splitting/"), 
      this.name = "SystemImportDeprecationWarning", this.module = module, this.loc = loc, 
      Error.captureStackTrace(this, this.constructor);
    }
  }
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("SystemPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const handler = (parser, parserOptions) => {
          if (void 0 !== parserOptions.system && !parserOptions.system) return;
          const shouldWarn = void 0 === parserOptions.system, setNotSupported = name => {
            parser.hooks.evaluateTypeof.for(name).tap("SystemPlugin", ParserHelpers.evaluateToString("undefined")), 
            parser.hooks.expression.for(name).tap("SystemPlugin", ParserHelpers.expressionIsUnsupported(parser, name + " is not supported by webpack."));
          };
          parser.hooks.typeof.for("System.import").tap("SystemPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function"))), 
          parser.hooks.evaluateTypeof.for("System.import").tap("SystemPlugin", ParserHelpers.evaluateToString("function")), 
          parser.hooks.typeof.for("System").tap("SystemPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("object"))), 
          parser.hooks.evaluateTypeof.for("System").tap("SystemPlugin", ParserHelpers.evaluateToString("object")), 
          setNotSupported("System.set"), setNotSupported("System.get"), setNotSupported("System.register"), 
          parser.hooks.expression.for("System").tap("SystemPlugin", () => {
            const systemPolyfillRequire = ParserHelpers.requireFileAsExpression(parser.state.module.context, __webpack_require__(3).resolve(__dirname, "../buildin/system"));
            return ParserHelpers.addParsedVariableToModule(parser, "System", systemPolyfillRequire);
          }), parser.hooks.call.for("System.import").tap("SystemPlugin", expr => (shouldWarn && parser.state.module.warnings.push(new SystemImportDeprecationWarning(parser.state.module, expr.loc)), 
          parser.hooks.importCall.call(expr)));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("SystemPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("SystemPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ImportDependency = __webpack_require__(139), ImportEagerDependency = __webpack_require__(140), ImportWeakDependency = __webpack_require__(141), ImportContextDependency = __webpack_require__(142), ImportParserPlugin = __webpack_require__(315);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("ImportPlugin", (compilation, {contextModuleFactory: contextModuleFactory, normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ImportDependency, normalModuleFactory), compilation.dependencyTemplates.set(ImportDependency, new ImportDependency.Template), 
        compilation.dependencyFactories.set(ImportEagerDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(ImportEagerDependency, new ImportEagerDependency.Template), 
        compilation.dependencyFactories.set(ImportWeakDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(ImportWeakDependency, new ImportWeakDependency.Template), 
        compilation.dependencyFactories.set(ImportContextDependency, contextModuleFactory), 
        compilation.dependencyTemplates.set(ImportContextDependency, new ImportContextDependency.Template);
        const handler = (parser, parserOptions) => {
          (void 0 === parserOptions.import || parserOptions.import) && new ImportParserPlugin(options).apply(parser);
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("ImportPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ImportPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("ImportPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ImportContextDependency = __webpack_require__(142), ImportWeakDependency = __webpack_require__(141), ImportDependenciesBlock = __webpack_require__(316), ImportEagerDependency = __webpack_require__(140), ContextDependencyHelpers = __webpack_require__(33), UnsupportedFeatureWarning = __webpack_require__(74), CommentCompilationWarning = __webpack_require__(317);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(parser) {
      parser.hooks.importCall.tap("ImportParserPlugin", expr => {
        if (1 !== expr.arguments.length) throw new Error("Incorrect number of arguments provided to 'import(module: string) -> Promise'.");
        const param = parser.evaluateExpression(expr.arguments[0]);
        let chunkName = null, mode = "lazy", include = null, exclude = null;
        const groupOptions = {}, {options: importOptions, errors: commentErrors} = parser.parseCommentOptions(expr.range);
        if (commentErrors) for (const e of commentErrors) {
          const {comment: comment} = e;
          parser.state.module.warnings.push(new CommentCompilationWarning(`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`, parser.state.module, comment.loc));
        }
        if (importOptions) {
          if (void 0 !== importOptions.webpackIgnore) if ("boolean" != typeof importOptions.webpackIgnore) parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackIgnore\` expected a boolean, but received: ${importOptions.webpackIgnore}.`, expr.loc)); else if (importOptions.webpackIgnore) return !1;
          void 0 !== importOptions.webpackChunkName && ("string" != typeof importOptions.webpackChunkName ? parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackChunkName\` expected a string, but received: ${importOptions.webpackChunkName}.`, expr.loc)) : chunkName = importOptions.webpackChunkName), 
          void 0 !== importOptions.webpackMode && ("string" != typeof importOptions.webpackMode ? parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackMode\` expected a string, but received: ${importOptions.webpackMode}.`, expr.loc)) : mode = importOptions.webpackMode), 
          void 0 !== importOptions.webpackPrefetch && (!0 === importOptions.webpackPrefetch ? groupOptions.prefetchOrder = 0 : "number" == typeof importOptions.webpackPrefetch ? groupOptions.prefetchOrder = importOptions.webpackPrefetch : parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackPrefetch\` expected true or a number, but received: ${importOptions.webpackPrefetch}.`, expr.loc))), 
          void 0 !== importOptions.webpackPreload && (!0 === importOptions.webpackPreload ? groupOptions.preloadOrder = 0 : "number" == typeof importOptions.webpackPreload ? groupOptions.preloadOrder = importOptions.webpackPreload : parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackPreload\` expected true or a number, but received: ${importOptions.webpackPreload}.`, expr.loc))), 
          void 0 !== importOptions.webpackInclude && (importOptions.webpackInclude && "RegExp" === importOptions.webpackInclude.constructor.name ? include = new RegExp(importOptions.webpackInclude) : parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackInclude\` expected a regular expression, but received: ${importOptions.webpackInclude}.`, expr.loc))), 
          void 0 !== importOptions.webpackExclude && (importOptions.webpackExclude && "RegExp" === importOptions.webpackExclude.constructor.name ? exclude = new RegExp(importOptions.webpackExclude) : parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackExclude\` expected a regular expression, but received: ${importOptions.webpackExclude}.`, expr.loc)));
        }
        if (param.isString()) {
          if ("lazy" !== mode && "eager" !== mode && "weak" !== mode && parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackMode\` expected 'lazy', 'eager' or 'weak', but received: ${mode}.`, expr.loc)), 
          "eager" === mode) {
            const dep = new ImportEagerDependency(param.string, parser.state.module, expr.range);
            parser.state.current.addDependency(dep);
          } else if ("weak" === mode) {
            const dep = new ImportWeakDependency(param.string, parser.state.module, expr.range);
            parser.state.current.addDependency(dep);
          } else {
            const depBlock = new ImportDependenciesBlock(param.string, expr.range, Object.assign(groupOptions, {
              name: chunkName
            }), parser.state.module, expr.loc, parser.state.module);
            parser.state.current.addBlock(depBlock);
          }
          return !0;
        }
        {
          "lazy" !== mode && "lazy-once" !== mode && "eager" !== mode && "weak" !== mode && (parser.state.module.warnings.push(new UnsupportedFeatureWarning(parser.state.module, `\`webpackMode\` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ${mode}.`, expr.loc)), 
          mode = "lazy"), "weak" === mode && (mode = "async-weak");
          const dep = ContextDependencyHelpers.create(ImportContextDependency, expr.range, param, expr, this.options, {
            chunkName: chunkName,
            groupOptions: groupOptions,
            include: include,
            exclude: exclude,
            mode: mode,
            namespaceObject: !parser.state.module.buildMeta.strictHarmonyModule || "strict"
          }, parser);
          if (!dep) return;
          return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
          !0;
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AsyncDependenciesBlock = __webpack_require__(41), ImportDependency = __webpack_require__(139);
  module.exports = class extends AsyncDependenciesBlock {
    constructor(request, range, groupOptions, module, loc, originModule) {
      super(groupOptions, module, loc, request), this.range = range;
      const dep = new ImportDependency(request, originModule, this);
      dep.loc = loc, this.addDependency(dep);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(message, module, loc) {
      super(message), this.name = "CommentCompilationWarning", this.module = module, this.loc = loc, 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireContextDependency = __webpack_require__(143), ContextElementDependency = __webpack_require__(62), RequireContextDependencyParserPlugin = __webpack_require__(319);
  module.exports = class {
    constructor(modulesDirectories, extensions, mainFiles) {
      if (!Array.isArray(modulesDirectories)) throw new Error("modulesDirectories must be an array");
      if (!Array.isArray(extensions)) throw new Error("extensions must be an array");
      this.modulesDirectories = modulesDirectories, this.extensions = extensions, this.mainFiles = mainFiles;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("RequireContextPlugin", (compilation, {contextModuleFactory: contextModuleFactory, normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(RequireContextDependency, contextModuleFactory), 
        compilation.dependencyTemplates.set(RequireContextDependency, new RequireContextDependency.Template), 
        compilation.dependencyFactories.set(ContextElementDependency, normalModuleFactory);
        const handler = (parser, parserOptions) => {
          (void 0 === parserOptions.requireContext || parserOptions.requireContext) && (new RequireContextDependencyParserPlugin).apply(parser);
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireContextPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireContextPlugin", handler), 
        contextModuleFactory.hooks.alternatives.tap("RequireContextPlugin", items => 0 === items.length ? items : items.map(obj => this.extensions.filter(ext => {
          const l = obj.request.length;
          return l > ext.length && obj.request.substr(l - ext.length, l) === ext;
        }).map(ext => {
          const l = obj.request.length;
          return {
            context: obj.context,
            request: obj.request.substr(0, l - ext.length)
          };
        }).concat(obj)).reduce((a, b) => a.concat(b), [])), contextModuleFactory.hooks.alternatives.tap("RequireContextPlugin", items => 0 === items.length ? items : items.map(obj => this.mainFiles.filter(mainFile => {
          const l = obj.request.length;
          return l > mainFile.length + 1 && obj.request.substr(l - mainFile.length - 1, l) === "/" + mainFile;
        }).map(mainFile => {
          const l = obj.request.length;
          return [ {
            context: obj.context,
            request: obj.request.substr(0, l - mainFile.length)
          }, {
            context: obj.context,
            request: obj.request.substr(0, l - mainFile.length - 1)
          } ];
        }).reduce((a, b) => a.concat(b), []).concat(obj)).reduce((a, b) => a.concat(b), [])), 
        contextModuleFactory.hooks.alternatives.tap("RequireContextPlugin", items => 0 === items.length ? items : items.map(obj => {
          for (let i = 0; i < this.modulesDirectories.length; i++) {
            const dir = this.modulesDirectories[i];
            if (0 === obj.request.indexOf("./" + dir + "/")) {
              obj.request = obj.request.slice(dir.length + 3);
              break;
            }
          }
          return obj;
        }));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireContextDependency = __webpack_require__(143);
  module.exports = class {
    apply(parser) {
      parser.hooks.call.for("require.context").tap("RequireContextDependencyParserPlugin", expr => {
        let regExp = /^\.\/.*$/, recursive = !0, mode = "sync";
        switch (expr.arguments.length) {
         case 4:
          {
            const modeExpr = parser.evaluateExpression(expr.arguments[3]);
            if (!modeExpr.isString()) return;
            mode = modeExpr.string;
          }

         case 3:
          {
            const regExpExpr = parser.evaluateExpression(expr.arguments[2]);
            if (!regExpExpr.isRegExp()) return;
            regExp = regExpExpr.regExp;
          }

         case 2:
          {
            const recursiveExpr = parser.evaluateExpression(expr.arguments[1]);
            if (!recursiveExpr.isBoolean()) return;
            recursive = recursiveExpr.bool;
          }

         case 1:
          {
            const requestExpr = parser.evaluateExpression(expr.arguments[0]);
            if (!requestExpr.isString()) return;
            const dep = new RequireContextDependency({
              request: requestExpr.string,
              recursive: recursive,
              regExp: regExp,
              mode: mode
            }, expr.range);
            return dep.loc = expr.loc, dep.optional = parser.scope.inTry, parser.state.current.addDependency(dep), 
            !0;
          }
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireEnsureItemDependency = __webpack_require__(145), RequireEnsureDependency = __webpack_require__(146), NullFactory = __webpack_require__(10), RequireEnsureDependenciesBlockParserPlugin = __webpack_require__(321), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("RequireEnsurePlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(RequireEnsureItemDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(RequireEnsureItemDependency, new RequireEnsureItemDependency.Template), 
        compilation.dependencyFactories.set(RequireEnsureDependency, new NullFactory), compilation.dependencyTemplates.set(RequireEnsureDependency, new RequireEnsureDependency.Template);
        const handler = (parser, parserOptions) => {
          (void 0 === parserOptions.requireEnsure || parserOptions.requireEnsure) && ((new RequireEnsureDependenciesBlockParserPlugin).apply(parser), 
          parser.hooks.evaluateTypeof.for("require.ensure").tap("RequireEnsurePlugin", ParserHelpers.evaluateToString("function")), 
          parser.hooks.typeof.for("require.ensure").tap("RequireEnsurePlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function"))));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireEnsurePlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireEnsurePlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireEnsureDependenciesBlock = __webpack_require__(322), RequireEnsureItemDependency = __webpack_require__(145), getFunctionExpression = __webpack_require__(147);
  module.exports = class {
    apply(parser) {
      parser.hooks.call.for("require.ensure").tap("RequireEnsureDependenciesBlockParserPlugin", expr => {
        let chunkName = null, chunkNameRange = null, errorExpressionArg = null, errorExpression = null;
        switch (expr.arguments.length) {
         case 4:
          {
            const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
            if (!chunkNameExpr.isString()) return;
            chunkNameRange = chunkNameExpr.range, chunkName = chunkNameExpr.string;
          }

         case 3:
          if (errorExpressionArg = expr.arguments[2], errorExpression = getFunctionExpression(errorExpressionArg), 
          !errorExpression && !chunkName) {
            const chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);
            if (!chunkNameExpr.isString()) return;
            chunkNameRange = chunkNameExpr.range, chunkName = chunkNameExpr.string;
          }

         case 2:
          {
            const dependenciesExpr = parser.evaluateExpression(expr.arguments[0]), dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [ dependenciesExpr ], successExpressionArg = expr.arguments[1], successExpression = getFunctionExpression(successExpressionArg);
            successExpression && parser.walkExpressions(successExpression.expressions), errorExpression && parser.walkExpressions(errorExpression.expressions);
            const dep = new RequireEnsureDependenciesBlock(expr, successExpression ? successExpression.fn : successExpressionArg, errorExpression ? errorExpression.fn : errorExpressionArg, chunkName, chunkNameRange, parser.state.module, expr.loc), old = parser.state.current;
            parser.state.current = dep;
            try {
              let failed = !1;
              if (parser.inScope([], () => {
                for (const ee of dependenciesItems) if (ee.isString()) {
                  const edep = new RequireEnsureItemDependency(ee.string);
                  edep.loc = dep.loc, dep.addDependency(edep);
                } else failed = !0;
              }), failed) return;
              successExpression && ("BlockStatement" === successExpression.fn.body.type ? parser.walkStatement(successExpression.fn.body) : parser.walkExpression(successExpression.fn.body)), 
              old.addBlock(dep);
            } finally {
              parser.state.current = old;
            }
            return successExpression || parser.walkExpression(successExpressionArg), errorExpression ? "BlockStatement" === errorExpression.fn.body.type ? parser.walkStatement(errorExpression.fn.body) : parser.walkExpression(errorExpression.fn.body) : errorExpressionArg && parser.walkExpression(errorExpressionArg), 
            !0;
          }
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AsyncDependenciesBlock = __webpack_require__(41), RequireEnsureDependency = __webpack_require__(146);
  module.exports = class extends AsyncDependenciesBlock {
    constructor(expr, successExpression, errorExpression, chunkName, chunkNameRange, module, loc) {
      super(chunkName, module, loc, null), this.expr = expr;
      const successBodyRange = successExpression && successExpression.body && successExpression.body.range;
      successBodyRange && (this.range = [ successBodyRange[0] + 1, successBodyRange[1] - 1 ]), 
      this.chunkNameRange = chunkNameRange;
      const dep = new RequireEnsureDependency(this);
      dep.loc = loc, this.addDependency(dep);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireIncludeDependency = __webpack_require__(148), RequireIncludeDependencyParserPlugin = __webpack_require__(324), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("RequireIncludePlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(RequireIncludeDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(RequireIncludeDependency, new RequireIncludeDependency.Template);
        const handler = (parser, parserOptions) => {
          (void 0 === parserOptions.requireInclude || parserOptions.requireInclude) && ((new RequireIncludeDependencyParserPlugin).apply(parser), 
          parser.hooks.evaluateTypeof.for("require.include").tap("RequireIncludePlugin", ParserHelpers.evaluateToString("function")), 
          parser.hooks.typeof.for("require.include").tap("RequireIncludePlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function"))));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireIncludePlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireIncludePlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const RequireIncludeDependency = __webpack_require__(148);
  module.exports = class {
    apply(parser) {
      parser.hooks.call.for("require.include").tap("RequireIncludeDependencyParserPlugin", expr => {
        if (1 !== expr.arguments.length) return;
        const param = parser.evaluateExpression(expr.arguments[0]);
        if (!param.isString()) return;
        const dep = new RequireIncludeDependency(param.string, expr.range);
        return dep.loc = expr.loc, parser.state.current.addDependency(dep), !0;
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {SyncWaterfallHook: SyncWaterfallHook} = __webpack_require__(6), Template = __webpack_require__(2);
  module.exports = class {
    apply(mainTemplate) {
      const needChunkOnDemandLoadingCode = chunk => {
        for (const chunkGroup of chunk.groupsIterable) if (chunkGroup.getNumberOfChildren() > 0) return !0;
        return !1;
      }, needChunkLoadingCode = chunk => {
        for (const chunkGroup of chunk.groupsIterable) {
          if (chunkGroup.chunks.length > 1) return !0;
          if (chunkGroup.getNumberOfChildren() > 0) return !0;
        }
        return !1;
      }, needEntryDeferringCode = chunk => {
        for (const chunkGroup of chunk.groupsIterable) if (chunkGroup.chunks.length > 1) return !0;
        return !1;
      }, needPrefetchingCode = chunk => {
        const allPrefetchChunks = chunk.getChildIdsByOrdersMap(!0).prefetch;
        return allPrefetchChunks && Object.keys(allPrefetchChunks).length;
      };
      [ "jsonpScript", "linkPreload", "linkPrefetch" ].forEach(hook => {
        mainTemplate.hooks[hook] || (mainTemplate.hooks[hook] = new SyncWaterfallHook([ "source", "chunk", "hash" ]));
      });
      const getScriptSrcPath = (hash, chunk, chunkIdExpression) => {
        const chunkFilename = mainTemplate.outputOptions.chunkFilename, chunkMaps = chunk.getChunkMaps();
        return mainTemplate.getAssetPath(JSON.stringify(chunkFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          chunk: {
            id: `" + ${chunkIdExpression} + "`,
            hash: `" + ${JSON.stringify(chunkMaps.hash)}[${chunkIdExpression}] + "`,
            hashWithLength(length) {
              const shortChunkHashMap = Object.create(null);
              for (const chunkId of Object.keys(chunkMaps.hash)) "string" == typeof chunkMaps.hash[chunkId] && (shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length));
              return `" + ${JSON.stringify(shortChunkHashMap)}[${chunkIdExpression}] + "`;
            },
            name: `" + (${JSON.stringify(chunkMaps.name)}[${chunkIdExpression}]||${chunkIdExpression}) + "`,
            contentHash: {
              javascript: `" + ${JSON.stringify(chunkMaps.contentHash.javascript)}[${chunkIdExpression}] + "`
            },
            contentHashWithLength: {
              javascript: length => {
                const shortContentHashMap = {}, contentHash = chunkMaps.contentHash.javascript;
                for (const chunkId of Object.keys(contentHash)) "string" == typeof contentHash[chunkId] && (shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length));
                return `" + ${JSON.stringify(shortContentHashMap)}[${chunkIdExpression}] + "`;
              }
            }
          },
          contentHashType: "javascript"
        });
      };
      mainTemplate.hooks.localVars.tap("JsonpMainTemplatePlugin", (source, chunk, hash) => {
        const extraCode = [];
        return needChunkLoadingCode(chunk) && extraCode.push("", "// object to store loaded and loading chunks", "// undefined = chunk not loaded, null = chunk preloaded/prefetched", "// Promise = chunk loading, 0 = chunk loaded", "var installedChunks = {", Template.indent(chunk.ids.map(id => JSON.stringify(id) + ": 0").join(",\n")), "};", "", needEntryDeferringCode(chunk) ? needPrefetchingCode(chunk) ? "var deferredModules = [], deferredPrefetch = [];" : "var deferredModules = [];" : ""), 
        needChunkOnDemandLoadingCode(chunk) && extraCode.push("", "// script path function", "function jsonpScriptSrc(chunkId) {", Template.indent([ `return ${mainTemplate.requireFn}.p + ${getScriptSrcPath(hash, chunk, "chunkId")}` ]), "}"), 
        0 === extraCode.length ? source : Template.asString([ source, ...extraCode ]);
      }), mainTemplate.hooks.jsonpScript.tap("JsonpMainTemplatePlugin", (_, chunk, hash) => {
        const crossOriginLoading = mainTemplate.outputOptions.crossOriginLoading, chunkLoadTimeout = mainTemplate.outputOptions.chunkLoadTimeout, jsonpScriptType = mainTemplate.outputOptions.jsonpScriptType;
        return Template.asString([ "var script = document.createElement('script');", "var onScriptComplete;", jsonpScriptType ? `script.type = ${JSON.stringify(jsonpScriptType)};` : "", "script.charset = 'utf-8';", `script.timeout = ${chunkLoadTimeout / 1e3};`, `if (${mainTemplate.requireFn}.nc) {`, Template.indent(`script.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`), "}", "script.src = jsonpScriptSrc(chunkId);", crossOriginLoading ? Template.asString([ "if (script.src.indexOf(window.location.origin + '/') !== 0) {", Template.indent(`script.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), "}" ]) : "", "// create error before stack unwound to get useful stacktrace later", "var error = new Error();", "onScriptComplete = function (event) {", Template.indent([ "// avoid mem leaks in IE.", "script.onerror = script.onload = null;", "clearTimeout(timeout);", "var chunk = installedChunks[chunkId];", "if(chunk !== 0) {", Template.indent([ "if(chunk) {", Template.indent([ "var errorType = event && (event.type === 'load' ? 'missing' : event.type);", "var realSrc = event && event.target && event.target.src;", "error.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';", "error.name = 'ChunkLoadError';", "error.type = errorType;", "error.request = realSrc;", "chunk[1](error);" ]), "}", "installedChunks[chunkId] = undefined;" ]), "}" ]), "};", "var timeout = setTimeout(function(){", Template.indent([ "onScriptComplete({ type: 'timeout', target: script });" ]), `}, ${chunkLoadTimeout});`, "script.onerror = script.onload = onScriptComplete;" ]);
      }), mainTemplate.hooks.linkPreload.tap("JsonpMainTemplatePlugin", (_, chunk, hash) => {
        const crossOriginLoading = mainTemplate.outputOptions.crossOriginLoading, jsonpScriptType = mainTemplate.outputOptions.jsonpScriptType;
        return Template.asString([ "var link = document.createElement('link');", jsonpScriptType ? `link.type = ${JSON.stringify(jsonpScriptType)};` : "", "link.charset = 'utf-8';", `if (${mainTemplate.requireFn}.nc) {`, Template.indent(`link.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`), "}", 'link.rel = "preload";', 'link.as = "script";', "link.href = jsonpScriptSrc(chunkId);", crossOriginLoading ? Template.asString([ "if (link.href.indexOf(window.location.origin + '/') !== 0) {", Template.indent(`link.crossOrigin = ${JSON.stringify(crossOriginLoading)};`), "}" ]) : "" ]);
      }), mainTemplate.hooks.linkPrefetch.tap("JsonpMainTemplatePlugin", (_, chunk, hash) => {
        const crossOriginLoading = mainTemplate.outputOptions.crossOriginLoading;
        return Template.asString([ "var link = document.createElement('link');", crossOriginLoading ? `link.crossOrigin = ${JSON.stringify(crossOriginLoading)};` : "", `if (${mainTemplate.requireFn}.nc) {`, Template.indent(`link.setAttribute("nonce", ${mainTemplate.requireFn}.nc);`), "}", 'link.rel = "prefetch";', 'link.as = "script";', "link.href = jsonpScriptSrc(chunkId);" ]);
      }), mainTemplate.hooks.requireEnsure.tap("JsonpMainTemplatePlugin load", (source, chunk, hash) => Template.asString([ source, "", "// JSONP chunk loading for javascript", "", "var installedChunkData = installedChunks[chunkId];", 'if(installedChunkData !== 0) { // 0 means "already installed".', Template.indent([ "", '// a Promise means "currently loading".', "if(installedChunkData) {", Template.indent([ "promises.push(installedChunkData[2]);" ]), "} else {", Template.indent([ "// setup Promise in chunk cache", "var promise = new Promise(function(resolve, reject) {", Template.indent([ "installedChunkData = installedChunks[chunkId] = [resolve, reject];" ]), "});", "promises.push(installedChunkData[2] = promise);", "", "// start chunk loading", mainTemplate.hooks.jsonpScript.call("", chunk, hash), "document.head.appendChild(script);" ]), "}" ]), "}" ])), 
      mainTemplate.hooks.requireEnsure.tap({
        name: "JsonpMainTemplatePlugin preload",
        stage: 10
      }, (source, chunk, hash) => {
        const chunkMap = chunk.getChildIdsByOrdersMap().preload;
        return chunkMap && 0 !== Object.keys(chunkMap).length ? Template.asString([ source, "", "// chunk preloadng for javascript", "", `var chunkPreloadMap = ${JSON.stringify(chunkMap, null, "\t")};`, "", "var chunkPreloadData = chunkPreloadMap[chunkId];", "if(chunkPreloadData) {", Template.indent([ "chunkPreloadData.forEach(function(chunkId) {", Template.indent([ "if(installedChunks[chunkId] === undefined) {", Template.indent([ "installedChunks[chunkId] = null;", mainTemplate.hooks.linkPreload.call("", chunk, hash), "document.head.appendChild(link);" ]), "}" ]), "});" ]), "}" ]) : source;
      }), mainTemplate.hooks.requireExtensions.tap("JsonpMainTemplatePlugin", (source, chunk) => needChunkOnDemandLoadingCode(chunk) ? Template.asString([ source, "", "// on error function for async loading", mainTemplate.requireFn + ".oe = function(err) { console.error(err); throw err; };" ]) : source), 
      mainTemplate.hooks.bootstrap.tap("JsonpMainTemplatePlugin", (source, chunk, hash) => {
        if (needChunkLoadingCode(chunk)) {
          const withDefer = needEntryDeferringCode(chunk), withPrefetch = needPrefetchingCode(chunk);
          return Template.asString([ source, "", "// install a JSONP callback for chunk loading", "function webpackJsonpCallback(data) {", Template.indent([ "var chunkIds = data[0];", "var moreModules = data[1];", withDefer ? "var executeModules = data[2];" : "", withPrefetch ? "var prefetchChunks = data[3] || [];" : "", '// add "moreModules" to the modules object,', '// then flag all "chunkIds" as loaded and fire callback', "var moduleId, chunkId, i = 0, resolves = [];", "for(;i < chunkIds.length; i++) {", Template.indent([ "chunkId = chunkIds[i];", "if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {", Template.indent("resolves.push(installedChunks[chunkId][0]);"), "}", "installedChunks[chunkId] = 0;" ]), "}", "for(moduleId in moreModules) {", Template.indent([ "if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {", Template.indent(mainTemplate.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")), "}" ]), "}", "if(parentJsonpFunction) parentJsonpFunction(data);", withPrefetch ? withDefer ? "deferredPrefetch.push.apply(deferredPrefetch, prefetchChunks);" : Template.asString([ "// chunk prefetching for javascript", "prefetchChunks.forEach(function(chunkId) {", Template.indent([ "if(installedChunks[chunkId] === undefined) {", Template.indent([ "installedChunks[chunkId] = null;", mainTemplate.hooks.linkPrefetch.call("", chunk, hash), "document.head.appendChild(link);" ]), "}" ]), "});" ]) : "", "while(resolves.length) {", Template.indent("resolves.shift()();"), "}", withDefer ? Template.asString([ "", "// add entry modules from loaded chunk to deferred list", "deferredModules.push.apply(deferredModules, executeModules || []);", "", "// run deferred modules when all chunks ready", "return checkDeferredModules();" ]) : "" ]), "};", withDefer ? Template.asString([ "function checkDeferredModules() {", Template.indent([ "var result;", "for(var i = 0; i < deferredModules.length; i++) {", Template.indent([ "var deferredModule = deferredModules[i];", "var fulfilled = true;", "for(var j = 1; j < deferredModule.length; j++) {", Template.indent([ "var depId = deferredModule[j];", "if(installedChunks[depId] !== 0) fulfilled = false;" ]), "}", "if(fulfilled) {", Template.indent([ "deferredModules.splice(i--, 1);", "result = " + mainTemplate.requireFn + "(" + mainTemplate.requireFn + ".s = deferredModule[0]);" ]), "}" ]), "}", withPrefetch ? Template.asString([ "if(deferredModules.length === 0) {", Template.indent([ "// chunk prefetching for javascript", "deferredPrefetch.forEach(function(chunkId) {", Template.indent([ "if(installedChunks[chunkId] === undefined) {", Template.indent([ "installedChunks[chunkId] = null;", mainTemplate.hooks.linkPrefetch.call("", chunk, hash), "document.head.appendChild(link);" ]), "}" ]), "});", "deferredPrefetch.length = 0;" ]), "}" ]) : "", "return result;" ]), "}" ]) : "" ]);
        }
        return source;
      }), mainTemplate.hooks.beforeStartup.tap("JsonpMainTemplatePlugin", (source, chunk, hash) => {
        if (needChunkLoadingCode(chunk)) {
          var jsonpFunction = mainTemplate.outputOptions.jsonpFunction, globalObject = mainTemplate.outputOptions.globalObject;
          return Template.asString([ `var jsonpArray = ${globalObject}[${JSON.stringify(jsonpFunction)}] = ${globalObject}[${JSON.stringify(jsonpFunction)}] || [];`, "var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);", "jsonpArray.push = webpackJsonpCallback;", "jsonpArray = jsonpArray.slice();", "for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);", "var parentJsonpFunction = oldJsonpFunction;", "", source ]);
        }
        return source;
      }), mainTemplate.hooks.afterStartup.tap("JsonpMainTemplatePlugin", (source, chunk, hash) => {
        const prefetchChunks = chunk.getChildIdsByOrders().prefetch;
        return needChunkLoadingCode(chunk) && prefetchChunks && prefetchChunks.length ? Template.asString([ source, `webpackJsonpCallback([[], {}, 0, ${JSON.stringify(prefetchChunks)}]);` ]) : source;
      }), mainTemplate.hooks.startup.tap("JsonpMainTemplatePlugin", (source, chunk, hash) => {
        if (needEntryDeferringCode(chunk)) {
          if (chunk.hasEntryModule()) {
            const entries = [ chunk.entryModule ].filter(Boolean).map(m => [ m.id ].concat(Array.from(chunk.groupsIterable)[0].chunks.filter(c => c !== chunk).map(c => c.id)));
            return Template.asString([ "// add entry module to deferred list", `deferredModules.push(${entries.map(e => JSON.stringify(e)).join(", ")});`, "// run deferred modules when ready", "return checkDeferredModules();" ]);
          }
          return Template.asString([ "// run deferred modules from other chunks", "checkDeferredModules();" ]);
        }
        return source;
      }), mainTemplate.hooks.hotBootstrap.tap("JsonpMainTemplatePlugin", (source, chunk, hash) => {
        const globalObject = mainTemplate.outputOptions.globalObject, hotUpdateChunkFilename = mainTemplate.outputOptions.hotUpdateChunkFilename, hotUpdateMainFilename = mainTemplate.outputOptions.hotUpdateMainFilename, crossOriginLoading = mainTemplate.outputOptions.crossOriginLoading, hotUpdateFunction = mainTemplate.outputOptions.hotUpdateFunction, currentHotUpdateChunkFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateChunkFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          chunk: {
            id: '" + chunkId + "'
          }
        }), currentHotUpdateMainFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateMainFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
        }), runtimeSource = Template.getFunctionContent(__webpack_require__(326)).replace(/\/\/\$semicolon/g, ";").replace(/\$require\$/g, mainTemplate.requireFn).replace(/\$crossOriginLoading\$/g, crossOriginLoading ? JSON.stringify(crossOriginLoading) : "null").replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename).replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename).replace(/\$hash\$/g, JSON.stringify(hash));
        return `${source}\nfunction hotDisposeChunk(chunkId) {\n\tdelete installedChunks[chunkId];\n}\nvar parentHotUpdateCallback = ${globalObject}[${JSON.stringify(hotUpdateFunction)}];\n${globalObject}[${JSON.stringify(hotUpdateFunction)}] = ${runtimeSource}`;
      }), mainTemplate.hooks.hash.tap("JsonpMainTemplatePlugin", hash => {
        hash.update("jsonp"), hash.update("6");
      });
    }
  };
}, function(module, exports) {
  module.exports = function() {};
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0), getEntryInfo = chunk => [ chunk.entryModule ].filter(Boolean).map(m => [ m.id ].concat(Array.from(chunk.groupsIterable)[0].chunks.filter(c => c !== chunk).map(c => c.id)));
  module.exports = class {
    apply(chunkTemplate) {
      chunkTemplate.hooks.render.tap("JsonpChunkTemplatePlugin", (modules, chunk) => {
        const jsonpFunction = chunkTemplate.outputOptions.jsonpFunction, globalObject = chunkTemplate.outputOptions.globalObject, source = new ConcatSource, prefetchChunks = chunk.getChildIdsByOrders().prefetch;
        source.add(`(${globalObject}[${JSON.stringify(jsonpFunction)}] = ${globalObject}[${JSON.stringify(jsonpFunction)}] || []).push([${JSON.stringify(chunk.ids)},`), 
        source.add(modules);
        const entries = getEntryInfo(chunk);
        return entries.length > 0 ? source.add("," + JSON.stringify(entries)) : prefetchChunks && prefetchChunks.length && source.add(",0"), 
        prefetchChunks && prefetchChunks.length && source.add("," + JSON.stringify(prefetchChunks)), 
        source.add("])"), source;
      }), chunkTemplate.hooks.hash.tap("JsonpChunkTemplatePlugin", hash => {
        hash.update("JsonpChunkTemplatePlugin"), hash.update("4"), hash.update("" + chunkTemplate.outputOptions.jsonpFunction), 
        hash.update("" + chunkTemplate.outputOptions.globalObject);
      }), chunkTemplate.hooks.hashForChunk.tap("JsonpChunkTemplatePlugin", (hash, chunk) => {
        hash.update(JSON.stringify(getEntryInfo(chunk))), hash.update(JSON.stringify(chunk.getChildIdsByOrders().prefetch) || "");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    apply(hotUpdateChunkTemplate) {
      hotUpdateChunkTemplate.hooks.render.tap("JsonpHotUpdateChunkTemplatePlugin", (modulesSource, modules, removedModules, hash, id) => {
        const source = new ConcatSource;
        return source.add(`${hotUpdateChunkTemplate.outputOptions.hotUpdateFunction}(${JSON.stringify(id)},`), 
        source.add(modulesSource), source.add(")"), source;
      }), hotUpdateChunkTemplate.hooks.hash.tap("JsonpHotUpdateChunkTemplatePlugin", hash => {
        hash.update("JsonpHotUpdateChunkTemplatePlugin"), hash.update("3"), hash.update("" + hotUpdateChunkTemplate.outputOptions.hotUpdateFunction), 
        hash.update("" + hotUpdateChunkTemplate.outputOptions.library);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  const path = __webpack_require__(3);
  exports.assert = path.resolve(__dirname, "../web_modules/assert"), exports.buffer = path.resolve(__dirname, "../web_modules/buffer"), 
  exports.child_process = null, exports.cluster = null, exports.console = path.resolve(__dirname, "../web_modules/console-browserify"), 
  exports.constants = path.resolve(__dirname, "../web_modules/constants-browserify"), 
  exports.crypto = path.resolve(__dirname, "../web_modules/crypto-browserify"), exports.dgram = null, 
  exports.dns = null, exports.domain = path.resolve(__dirname, "../web_modules/domain-browser"), 
  exports.events = path.resolve(__dirname, "../web_modules/events"), exports.fs = null, 
  exports.http = path.resolve(__dirname, "../web_modules/stream-http"), exports.https = path.resolve(__dirname, "../web_modules/https-browserify"), 
  exports.module = null, exports.net = null, exports.os = path.resolve(__dirname, "../web_modules/os-browserify/browser.js"), 
  exports.path = path.resolve(__dirname, "../web_modules/path-browserify"), exports.punycode = path.resolve(__dirname, "../web_modules/punycode"), 
  exports.process = path.resolve(__dirname, "../web_modules/process/browser.js"), 
  exports.querystring = path.resolve(__dirname, "../web_modules/querystring-es3"), 
  exports.readline = null, exports.repl = null, exports.stream = path.resolve(__dirname, "../web_modules/stream-browserify"), 
  exports._stream_duplex = path.resolve(__dirname, "../web_modules/readable-stream/duplex.js"), 
  exports._stream_passthrough = path.resolve(__dirname, "../web_modules/readable-stream/passthrough.js"), 
  exports._stream_readable = path.resolve(__dirname, "../web_modules/readable-stream/readable.js"), 
  exports._stream_transform = path.resolve(__dirname, "../web_modules/readable-stream/transform.js"), 
  exports._stream_writable = path.resolve(__dirname, "../web_modules/readable-stream/writable.js"), 
  exports.string_decoder = path.resolve(__dirname, "../web_modules/string_decoder"), 
  exports.sys = path.resolve(__dirname, "../web_modules/util/util.js"), exports.timers = path.resolve(__dirname, "../web_modules/timers-browserify"), 
  exports.tls = null, exports.tty = path.resolve(__dirname, "../web_modules/tty-browserify"), 
  exports.url = path.resolve(__dirname, "../web_modules/url"), exports.util = path.resolve(__dirname, "../web_modules/util/util.js"), 
  exports.vm = path.resolve(__dirname, "../web_modules/vm-browserify"), exports.zlib = path.resolve(__dirname, "../web_modules/browserify-zlib");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2);
  module.exports = class {
    apply(mainTemplate) {
      const needChunkOnDemandLoadingCode = chunk => {
        for (const chunkGroup of chunk.groupsIterable) if (chunkGroup.getNumberOfChildren() > 0) return !0;
        return !1;
      };
      mainTemplate.hooks.localVars.tap("WebWorkerMainTemplatePlugin", (source, chunk) => needChunkOnDemandLoadingCode(chunk) ? Template.asString([ source, "", "// object to store loaded chunks", '// "1" means "already loaded"', "var installedChunks = {", Template.indent(chunk.ids.map(id => JSON.stringify(id) + ": 1").join(",\n")), "};" ]) : source), 
      mainTemplate.hooks.requireEnsure.tap("WebWorkerMainTemplatePlugin", (_, chunk, hash) => {
        const chunkFilename = mainTemplate.outputOptions.chunkFilename, chunkMaps = chunk.getChunkMaps();
        return Template.asString([ "promises.push(Promise.resolve().then(function() {", Template.indent([ '// "1" is the signal for "already loaded"', "if(!installedChunks[chunkId]) {", Template.indent([ "importScripts(__webpack_require__.p + " + mainTemplate.getAssetPath(JSON.stringify(chunkFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          chunk: {
            id: '" + chunkId + "',
            hash: `" + ${JSON.stringify(chunkMaps.hash)}[chunkId] + "`,
            hashWithLength(length) {
              const shortChunkHashMap = Object.create(null);
              for (const chunkId of Object.keys(chunkMaps.hash)) "string" == typeof chunkMaps.hash[chunkId] && (shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length));
              return `" + ${JSON.stringify(shortChunkHashMap)}[chunkId] + "`;
            },
            contentHash: {
              javascript: `" + ${JSON.stringify(chunkMaps.contentHash.javascript)}[chunkId] + "`
            },
            contentHashWithLength: {
              javascript: length => {
                const shortContentHashMap = {}, contentHash = chunkMaps.contentHash.javascript;
                for (const chunkId of Object.keys(contentHash)) "string" == typeof contentHash[chunkId] && (shortContentHashMap[chunkId] = contentHash[chunkId].substr(0, length));
                return `" + ${JSON.stringify(shortContentHashMap)}[chunkId] + "`;
              }
            },
            name: `" + (${JSON.stringify(chunkMaps.name)}[chunkId]||chunkId) + "`
          },
          contentHashType: "javascript"
        }) + ");" ]), "}" ]), "}));" ]);
      }), mainTemplate.hooks.bootstrap.tap("WebWorkerMainTemplatePlugin", (source, chunk, hash) => {
        if (needChunkOnDemandLoadingCode(chunk)) {
          const chunkCallbackName = mainTemplate.outputOptions.chunkCallbackName, globalObject = mainTemplate.outputOptions.globalObject;
          return Template.asString([ source, `${globalObject}[${JSON.stringify(chunkCallbackName)}] = function webpackChunkCallback(chunkIds, moreModules) {`, Template.indent([ "for(var moduleId in moreModules) {", Template.indent(mainTemplate.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")), "}", "while(chunkIds.length)", Template.indent("installedChunks[chunkIds.pop()] = 1;") ]), "};" ]);
        }
        return source;
      }), mainTemplate.hooks.hotBootstrap.tap("WebWorkerMainTemplatePlugin", (source, chunk, hash) => {
        const hotUpdateChunkFilename = mainTemplate.outputOptions.hotUpdateChunkFilename, hotUpdateMainFilename = mainTemplate.outputOptions.hotUpdateMainFilename, hotUpdateFunction = mainTemplate.outputOptions.hotUpdateFunction, globalObject = mainTemplate.outputOptions.globalObject, currentHotUpdateChunkFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateChunkFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`,
          chunk: {
            id: '" + chunkId + "'
          }
        }), currentHotUpdateMainFilename = mainTemplate.getAssetPath(JSON.stringify(hotUpdateMainFilename), {
          hash: `" + ${mainTemplate.renderCurrentHashCode(hash)} + "`,
          hashWithLength: length => `" + ${mainTemplate.renderCurrentHashCode(hash, length)} + "`
        });
        return source + "\n" + `var parentHotUpdateCallback = ${globalObject}[${JSON.stringify(hotUpdateFunction)}];\n` + `${globalObject}[${JSON.stringify(hotUpdateFunction)}] = ` + Template.getFunctionContent(__webpack_require__(331)).replace(/\/\/\$semicolon/g, ";").replace(/\$require\$/g, mainTemplate.requireFn).replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename).replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename).replace(/\$hash\$/g, JSON.stringify(hash));
      }), mainTemplate.hooks.hash.tap("WebWorkerMainTemplatePlugin", hash => {
        hash.update("webworker"), hash.update("4");
      });
    }
  };
}, function(module, exports) {
  module.exports = function() {};
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    apply(chunkTemplate) {
      chunkTemplate.hooks.render.tap("WebWorkerChunkTemplatePlugin", (modules, chunk) => {
        const chunkCallbackName = chunkTemplate.outputOptions.chunkCallbackName, globalObject = chunkTemplate.outputOptions.globalObject, source = new ConcatSource;
        return source.add(`${globalObject}[${JSON.stringify(chunkCallbackName)}](${JSON.stringify(chunk.ids)},`), 
        source.add(modules), source.add(")"), source;
      }), chunkTemplate.hooks.hash.tap("WebWorkerChunkTemplatePlugin", hash => {
        hash.update("webworker"), hash.update("3"), hash.update("" + chunkTemplate.outputOptions.chunkCallbackName), 
        hash.update("" + chunkTemplate.outputOptions.globalObject);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    apply(hotUpdateChunkTemplate) {
      hotUpdateChunkTemplate.hooks.render.tap("WebWorkerHotUpdateChunkTemplatePlugin", (modulesSource, modules, removedModules, hash, id) => {
        const hotUpdateFunction = hotUpdateChunkTemplate.outputOptions.hotUpdateFunction, globalObject = hotUpdateChunkTemplate.outputOptions.globalObject, source = new ConcatSource;
        return source.add(`${globalObject}[${JSON.stringify(hotUpdateFunction)}](${JSON.stringify(id)},`), 
        source.add(modulesSource), source.add(")"), source;
      }), hotUpdateChunkTemplate.hooks.hash.tap("WebWorkerHotUpdateChunkTemplatePlugin", hash => {
        hash.update("WebWorkerHotUpdateChunkTemplatePlugin"), hash.update("3"), hash.update(hotUpdateChunkTemplate.outputOptions.hotUpdateFunction + ""), 
        hash.update(hotUpdateChunkTemplate.outputOptions.globalObject + "");
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {OriginalSource: OriginalSource, RawSource: RawSource} = __webpack_require__(0), Module = __webpack_require__(18), WebpackMissingModule = __webpack_require__(45), Template = __webpack_require__(2);
  module.exports = class extends Module {
    constructor(request, type, userRequest) {
      super("javascript/dynamic", null), this.request = request, this.externalType = type, 
      this.userRequest = userRequest, this.external = !0;
    }
    libIdent() {
      return this.userRequest;
    }
    chunkCondition(chunk) {
      return chunk.hasEntryModule();
    }
    identifier() {
      return "external " + JSON.stringify(this.request);
    }
    readableIdentifier() {
      return "external " + JSON.stringify(this.request);
    }
    needRebuild() {
      return !1;
    }
    build(options, compilation, resolver, fs, callback) {
      this.built = !0, this.buildMeta = {}, this.buildInfo = {}, callback();
    }
    getSourceForGlobalVariableExternal(variableName, type) {
      Array.isArray(variableName) || (variableName = [ variableName ]);
      return `(function() { module.exports = ${type}${variableName.map(r => `[${JSON.stringify(r)}]`).join("")}; }());`;
    }
    getSourceForCommonJsExternal(moduleAndSpecifiers) {
      if (!Array.isArray(moduleAndSpecifiers)) return `module.exports = require(${JSON.stringify(moduleAndSpecifiers)});`;
      const moduleName = moduleAndSpecifiers[0], objectLookup = moduleAndSpecifiers.slice(1).map(r => `[${JSON.stringify(r)}]`).join("");
      return `module.exports = require(${JSON.stringify(moduleName)})${objectLookup};`;
    }
    checkExternalVariable(variableToCheck, request) {
      return `if(typeof ${variableToCheck} === 'undefined') {${WebpackMissingModule.moduleCode(request)}}\n`;
    }
    getSourceForAmdOrUmdExternal(id, optional, request) {
      const externalVariable = `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier("" + id)}__`;
      return `${optional ? this.checkExternalVariable(externalVariable, request) : ""}module.exports = ${externalVariable};`;
    }
    getSourceForDefaultCase(optional, request) {
      Array.isArray(request) || (request = [ request ]);
      const variableName = request[0];
      return `${optional ? this.checkExternalVariable(variableName, request.join(".")) : ""}module.exports = ${variableName}${request.slice(1).map(r => `[${JSON.stringify(r)}]`).join("")};`;
    }
    getSourceString(runtime) {
      const request = "object" != typeof this.request || Array.isArray(this.request) ? this.request : this.request[this.externalType];
      switch (this.externalType) {
       case "this":
       case "window":
       case "self":
        return this.getSourceForGlobalVariableExternal(request, this.externalType);

       case "global":
        return this.getSourceForGlobalVariableExternal(request, runtime.outputOptions.globalObject);

       case "commonjs":
       case "commonjs2":
        return this.getSourceForCommonJsExternal(request);

       case "amd":
       case "amd-require":
       case "umd":
       case "umd2":
       case "system":
        return this.getSourceForAmdOrUmdExternal(this.id, this.optional, request);

       default:
        return this.getSourceForDefaultCase(this.optional, request);
      }
    }
    getSource(sourceString) {
      return this.useSourceMap ? new OriginalSource(sourceString, this.identifier()) : new RawSource(sourceString);
    }
    source(dependencyTemplates, runtime) {
      return this.getSource(this.getSourceString(runtime));
    }
    size() {
      return 42;
    }
    updateHash(hash) {
      hash.update(this.externalType), hash.update(JSON.stringify(this.request)), hash.update(JSON.stringify(Boolean(this.optional))), 
      super.updateHash(hash);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    constructor(property) {
      this.property = property;
    }
    apply(compilation) {
      const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate} = compilation, onRenderWithEntry = (source, chunk, hash) => {
        const postfix = "" + [].concat(this.property).map(a => `[${JSON.stringify(a)}]`).join("");
        return new ConcatSource(source, postfix);
      };
      for (const template of [ mainTemplate, chunkTemplate ]) template.hooks.renderWithEntry.tap("ExportPropertyMainTemplatePlugin", onRenderWithEntry);
      mainTemplate.hooks.hash.tap("ExportPropertyMainTemplatePlugin", hash => {
        hash.update("export property"), hash.update("" + this.property);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0), Template = __webpack_require__(2);
  module.exports = class {
    constructor(options) {
      options && "string" != typeof options ? (this.name = options.name, this.requireAsWrapper = options.requireAsWrapper) : (this.name = options, 
      this.requireAsWrapper = !1);
    }
    apply(compilation) {
      const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate} = compilation, onRenderWithEntry = (source, chunk, hash) => {
        const externals = chunk.getModules().filter(m => m.external), externalsDepsArray = JSON.stringify(externals.map(m => "object" == typeof m.request ? m.request.amd : m.request)), externalsArguments = externals.map(m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier("" + m.id)}__`).join(", ");
        if (this.requireAsWrapper) return new ConcatSource(`require(${externalsDepsArray}, function(${externalsArguments}) { return `, source, "});");
        if (this.name) {
          const name = mainTemplate.getAssetPath(this.name, {
            hash: hash,
            chunk: chunk
          });
          return new ConcatSource(`define(${JSON.stringify(name)}, ${externalsDepsArray}, function(${externalsArguments}) { return `, source, "});");
        }
        return new ConcatSource(externalsArguments ? `define(${externalsDepsArray}, function(${externalsArguments}) { return ` : "define(function() { return ", source, "});");
      };
      for (const template of [ mainTemplate, chunkTemplate ]) template.hooks.renderWithEntry.tap("AmdMainTemplatePlugin", onRenderWithEntry);
      mainTemplate.hooks.globalHashPaths.tap("AmdMainTemplatePlugin", paths => (this.name && paths.push(this.name), 
      paths)), mainTemplate.hooks.hash.tap("AmdMainTemplatePlugin", hash => {
        hash.update("exports amd"), this.name && hash.update(this.name);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0);
  module.exports = class {
    constructor(name) {
      this.name = name;
    }
    apply(compilation) {
      const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate} = compilation, onRenderWithEntry = (source, chunk, hash) => {
        const name = mainTemplate.getAssetPath(this.name || "", {
          hash: hash,
          chunk: chunk
        });
        return new ConcatSource(name + "(", source, ");");
      };
      for (const template of [ mainTemplate, chunkTemplate ]) template.hooks.renderWithEntry.tap("JsonpExportMainTemplatePlugin", onRenderWithEntry);
      mainTemplate.hooks.globalHashPaths.tap("JsonpExportMainTemplatePlugin", paths => (this.name && paths.push(this.name), 
      paths)), mainTemplate.hooks.hash.tap("JsonpExportMainTemplatePlugin", hash => {
        hash.update("jsonp export"), hash.update("" + this.name);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0), Template = __webpack_require__(2);
  module.exports = class {
    constructor(options) {
      this.name = options.name;
    }
    apply(compilation) {
      const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate} = compilation, onRenderWithEntry = (source, chunk, hash) => {
        const externals = chunk.getModules().filter(m => m.external), name = this.name ? JSON.stringify(mainTemplate.getAssetPath(this.name, {
          hash: hash,
          chunk: chunk
        })) + ", " : "", systemDependencies = JSON.stringify(externals.map(m => "object" == typeof m.request ? m.request.amd : m.request)), externalWebpackNames = externals.map(m => `__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier("" + m.id)}__`), externalVarDeclarations = externalWebpackNames.length > 0 ? `var ${externalWebpackNames.join(", ")};` : "", setters = 0 === externalWebpackNames.length ? "" : Template.asString([ "setters: [", Template.indent(externalWebpackNames.map(external => Template.asString([ "function(module) {", Template.indent(external + " = module;"), "}" ])).join(",\n")), "]," ]);
        return new ConcatSource(Template.asString([ `System.register(${name}${systemDependencies}, function(__WEBPACK_DYNAMIC_EXPORT__) {`, Template.indent([ externalVarDeclarations, "return {", Template.indent([ setters, "execute: function() {", Template.indent("__WEBPACK_DYNAMIC_EXPORT__(") ]) ]) ]) + "\n", source, "\n" + Template.asString([ Template.indent([ Template.indent([ Template.indent([ ");" ]), "}" ]), "};" ]), "})" ]));
      };
      for (const template of [ mainTemplate, chunkTemplate ]) template.hooks.renderWithEntry.tap("SystemMainTemplatePlugin", onRenderWithEntry);
      mainTemplate.hooks.globalHashPaths.tap("SystemMainTemplatePlugin", paths => (this.name && paths.push(this.name), 
      paths)), mainTemplate.hooks.hash.tap("SystemMainTemplatePlugin", hash => {
        hash.update("exports system"), this.name && hash.update(this.name);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), AMDRequireDependency = __webpack_require__(156), AMDRequireItemDependency = __webpack_require__(84), AMDRequireArrayDependency = __webpack_require__(85), AMDRequireContextDependency = __webpack_require__(86), AMDDefineDependency = __webpack_require__(157), UnsupportedDependency = __webpack_require__(158), LocalModuleDependency = __webpack_require__(47), NullFactory = __webpack_require__(10), AMDRequireDependenciesBlockParserPlugin = __webpack_require__(340), AMDDefineDependencyParserPlugin = __webpack_require__(342), AliasPlugin = __webpack_require__(64), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    constructor(options, amdOptions) {
      this.amdOptions = amdOptions, this.options = options;
    }
    apply(compiler) {
      const options = this.options, amdOptions = this.amdOptions;
      compiler.hooks.compilation.tap("AMDPlugin", (compilation, {contextModuleFactory: contextModuleFactory, normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(AMDRequireDependency, new NullFactory), compilation.dependencyTemplates.set(AMDRequireDependency, new AMDRequireDependency.Template), 
        compilation.dependencyFactories.set(AMDRequireItemDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(AMDRequireItemDependency, new AMDRequireItemDependency.Template), 
        compilation.dependencyFactories.set(AMDRequireArrayDependency, new NullFactory), 
        compilation.dependencyTemplates.set(AMDRequireArrayDependency, new AMDRequireArrayDependency.Template), 
        compilation.dependencyFactories.set(AMDRequireContextDependency, contextModuleFactory), 
        compilation.dependencyTemplates.set(AMDRequireContextDependency, new AMDRequireContextDependency.Template), 
        compilation.dependencyFactories.set(AMDDefineDependency, new NullFactory), compilation.dependencyTemplates.set(AMDDefineDependency, new AMDDefineDependency.Template), 
        compilation.dependencyFactories.set(UnsupportedDependency, new NullFactory), compilation.dependencyTemplates.set(UnsupportedDependency, new UnsupportedDependency.Template), 
        compilation.dependencyFactories.set(LocalModuleDependency, new NullFactory), compilation.dependencyTemplates.set(LocalModuleDependency, new LocalModuleDependency.Template);
        const handler = (parser, parserOptions) => {
          if (void 0 !== parserOptions.amd && !parserOptions.amd) return;
          const setExpressionToModule = (outerExpr, module) => {
            parser.hooks.expression.for(outerExpr).tap("AMDPlugin", expr => {
              const dep = new AMDRequireItemDependency(module, expr.range);
              return dep.userRequest = outerExpr, dep.loc = expr.loc, parser.state.current.addDependency(dep), 
              !0;
            });
          };
          new AMDRequireDependenciesBlockParserPlugin(options).apply(parser), new AMDDefineDependencyParserPlugin(options).apply(parser), 
          setExpressionToModule("require.amd", "!!webpack amd options"), setExpressionToModule("define.amd", "!!webpack amd options"), 
          setExpressionToModule("define", "!!webpack amd define"), parser.hooks.expression.for("__webpack_amd_options__").tap("AMDPlugin", () => parser.state.current.addVariable("__webpack_amd_options__", JSON.stringify(amdOptions))), 
          parser.hooks.evaluateTypeof.for("define.amd").tap("AMDPlugin", ParserHelpers.evaluateToString(typeof amdOptions)), 
          parser.hooks.evaluateTypeof.for("require.amd").tap("AMDPlugin", ParserHelpers.evaluateToString(typeof amdOptions)), 
          parser.hooks.evaluateIdentifier.for("define.amd").tap("AMDPlugin", ParserHelpers.evaluateToIdentifier("define.amd", !0)), 
          parser.hooks.evaluateIdentifier.for("require.amd").tap("AMDPlugin", ParserHelpers.evaluateToIdentifier("require.amd", !0)), 
          parser.hooks.typeof.for("define").tap("AMDPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function"))), 
          parser.hooks.evaluateTypeof.for("define").tap("AMDPlugin", ParserHelpers.evaluateToString("function")), 
          parser.hooks.canRename.for("define").tap("AMDPlugin", ParserHelpers.approve), parser.hooks.rename.for("define").tap("AMDPlugin", expr => {
            const dep = new AMDRequireItemDependency("!!webpack amd define", expr.range);
            return dep.userRequest = "define", dep.loc = expr.loc, parser.state.current.addDependency(dep), 
            !1;
          }), parser.hooks.typeof.for("require").tap("AMDPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("function"))), 
          parser.hooks.evaluateTypeof.for("require").tap("AMDPlugin", ParserHelpers.evaluateToString("function"));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("AMDPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("AMDPlugin", handler);
      }), compiler.hooks.afterResolvers.tap("AMDPlugin", () => {
        compiler.resolverFactory.hooks.resolver.for("normal").tap("AMDPlugin", resolver => {
          new AliasPlugin("described-resolve", {
            name: "amdefine",
            alias: path.join(__dirname, "..", "..", "buildin", "amd-define.js")
          }, "resolve").apply(resolver), new AliasPlugin("described-resolve", {
            name: "webpack amd options",
            alias: path.join(__dirname, "..", "..", "buildin", "amd-options.js")
          }, "resolve").apply(resolver), new AliasPlugin("described-resolve", {
            name: "webpack amd define",
            alias: path.join(__dirname, "..", "..", "buildin", "amd-define.js")
          }, "resolve").apply(resolver);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AMDRequireItemDependency = __webpack_require__(84), AMDRequireArrayDependency = __webpack_require__(85), AMDRequireContextDependency = __webpack_require__(86), AMDRequireDependenciesBlock = __webpack_require__(341), UnsupportedDependency = __webpack_require__(158), LocalModuleDependency = __webpack_require__(47), ContextDependencyHelpers = __webpack_require__(33), LocalModulesHelpers = __webpack_require__(76), ConstDependency = __webpack_require__(5), getFunctionExpression = __webpack_require__(147), UnsupportedFeatureWarning = __webpack_require__(74);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    processFunctionArgument(parser, expression) {
      let bindThis = !0;
      const fnData = getFunctionExpression(expression);
      return fnData ? (parser.inScope(fnData.fn.params.filter(i => ![ "require", "module", "exports" ].includes(i.name)), () => {
        "BlockStatement" === fnData.fn.body.type ? parser.walkStatement(fnData.fn.body) : parser.walkExpression(fnData.fn.body);
      }), parser.walkExpressions(fnData.expressions), !1 === fnData.needThis && (bindThis = !1)) : parser.walkExpression(expression), 
      bindThis;
    }
    apply(parser) {
      parser.hooks.call.for("require").tap("AMDRequireDependenciesBlockParserPlugin", this.processCallRequire.bind(this, parser));
    }
    processArray(parser, expr, param) {
      if (param.isArray()) {
        for (const p of param.items) {
          void 0 === this.processItem(parser, expr, p) && this.processContext(parser, expr, p);
        }
        return !0;
      }
      if (param.isConstArray()) {
        const deps = [];
        for (const request of param.array) {
          let dep, localModule;
          "require" === request ? dep = "__webpack_require__" : [ "exports", "module" ].includes(request) ? dep = request : (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) ? (dep = new LocalModuleDependency(localModule, void 0, !1), 
          dep.loc = expr.loc, parser.state.current.addDependency(dep)) : (dep = this.newRequireItemDependency(request), 
          dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep)), 
          deps.push(dep);
        }
        const dep = this.newRequireArrayDependency(deps, param.range);
        return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
        !0;
      }
    }
    processItem(parser, expr, param) {
      if (param.isConditional()) {
        for (const p of param.options) {
          void 0 === this.processItem(parser, expr, p) && this.processContext(parser, expr, p);
        }
        return !0;
      }
      if (param.isString()) {
        let dep, localModule;
        return dep = "require" === param.string ? new ConstDependency("__webpack_require__", param.string) : "module" === param.string ? new ConstDependency(parser.state.module.buildInfo.moduleArgument, param.range) : "exports" === param.string ? new ConstDependency(parser.state.module.buildInfo.exportsArgument, param.range) : (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string)) ? new LocalModuleDependency(localModule, param.range, !1) : this.newRequireItemDependency(param.string, param.range), 
        dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
        !0;
      }
    }
    processContext(parser, expr, param) {
      const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);
      if (dep) return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
      !0;
    }
    processArrayForRequestString(param) {
      if (param.isArray()) {
        const result = param.items.map(item => this.processItemForRequestString(item));
        if (result.every(Boolean)) return result.join(" ");
      } else if (param.isConstArray()) return param.array.join(" ");
    }
    processItemForRequestString(param) {
      if (param.isConditional()) {
        const result = param.options.map(item => this.processItemForRequestString(item));
        if (result.every(Boolean)) return result.join("|");
      } else if (param.isString()) return param.string;
    }
    processCallRequire(parser, expr) {
      let param, dep, result;
      const old = parser.state.current;
      if (expr.arguments.length >= 1 && (param = parser.evaluateExpression(expr.arguments[0]), 
      dep = this.newRequireDependenciesBlock(expr, param.range, expr.arguments.length > 1 ? expr.arguments[1].range : null, expr.arguments.length > 2 ? expr.arguments[2].range : null, parser.state.module, expr.loc, this.processArrayForRequestString(param)), 
      parser.state.current = dep), 1 === expr.arguments.length) {
        if (parser.inScope([], () => {
          result = this.processArray(parser, expr, param);
        }), parser.state.current = old, !result) return;
        return parser.state.current.addBlock(dep), !0;
      }
      if (2 === expr.arguments.length || 3 === expr.arguments.length) {
        try {
          if (parser.inScope([], () => {
            result = this.processArray(parser, expr, param);
          }), !result) return dep = new UnsupportedDependency("unsupported", expr.range), 
          old.addDependency(dep), parser.state.module && parser.state.module.errors.push(new UnsupportedFeatureWarning(parser.state.module, "Cannot statically analyse 'require(…, …)' in line " + expr.loc.start.line, expr.loc)), 
          dep = null, !0;
          dep.functionBindThis = this.processFunctionArgument(parser, expr.arguments[1]), 
          3 === expr.arguments.length && (dep.errorCallbackBindThis = this.processFunctionArgument(parser, expr.arguments[2]));
        } finally {
          parser.state.current = old, dep && parser.state.current.addBlock(dep);
        }
        return !0;
      }
    }
    newRequireDependenciesBlock(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request) {
      return new AMDRequireDependenciesBlock(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request);
    }
    newRequireItemDependency(request, range) {
      return new AMDRequireItemDependency(request, range);
    }
    newRequireArrayDependency(depsArray, range) {
      return new AMDRequireArrayDependency(depsArray, range);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AsyncDependenciesBlock = __webpack_require__(41), AMDRequireDependency = __webpack_require__(156);
  module.exports = class extends AsyncDependenciesBlock {
    constructor(expr, arrayRange, functionRange, errorCallbackRange, module, loc, request) {
      super(null, module, loc, request), this.expr = expr, this.outerRange = expr.range, 
      this.arrayRange = arrayRange, this.functionBindThis = !1, this.functionRange = functionRange, 
      this.errorCallbackBindThis = !1, this.errorCallbackRange = errorCallbackRange, this.bindThis = !0, 
      this.range = arrayRange && functionRange && errorCallbackRange ? [ arrayRange[0], errorCallbackRange[1] ] : arrayRange && functionRange ? [ arrayRange[0], functionRange[1] ] : arrayRange || (functionRange || expr.range);
      const dep = this.newRequireDependency();
      dep.loc = loc, this.addDependency(dep);
    }
    newRequireDependency() {
      return new AMDRequireDependency(this);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const AMDRequireItemDependency = __webpack_require__(84), AMDRequireContextDependency = __webpack_require__(86), ConstDependency = __webpack_require__(5), AMDDefineDependency = __webpack_require__(157), AMDRequireArrayDependency = __webpack_require__(85), LocalModuleDependency = __webpack_require__(47), ContextDependencyHelpers = __webpack_require__(33), LocalModulesHelpers = __webpack_require__(76), isBoundFunctionExpression = expr => "CallExpression" === expr.type && ("MemberExpression" === expr.callee.type && (!expr.callee.computed && ("FunctionExpression" === expr.callee.object.type && ("Identifier" === expr.callee.property.type && "bind" === expr.callee.property.name)))), isUnboundFunctionExpression = expr => "FunctionExpression" === expr.type || "ArrowFunctionExpression" === expr.type, isCallable = expr => !!isUnboundFunctionExpression(expr) || !!isBoundFunctionExpression(expr);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(parser) {
      parser.hooks.call.for("define").tap("AMDDefineDependencyParserPlugin", this.processCallDefine.bind(this, parser));
    }
    processArray(parser, expr, param, identifiers, namedModule) {
      if (param.isArray()) return param.items.forEach((param, idx) => {
        param.isString() && [ "require", "module", "exports" ].includes(param.string) && (identifiers[idx] = param.string);
        void 0 === this.processItem(parser, expr, param, namedModule) && this.processContext(parser, expr, param);
      }), !0;
      if (param.isConstArray()) {
        const deps = [];
        param.array.forEach((request, idx) => {
          let dep, localModule;
          "require" === request ? (identifiers[idx] = request, dep = "__webpack_require__") : [ "exports", "module" ].includes(request) ? (identifiers[idx] = request, 
          dep = request) : (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) ? (dep = new LocalModuleDependency(localModule, void 0, !1), 
          dep.loc = expr.loc, parser.state.current.addDependency(dep)) : (dep = this.newRequireItemDependency(request), 
          dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep)), 
          deps.push(dep);
        });
        const dep = this.newRequireArrayDependency(deps, param.range);
        return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
        !0;
      }
    }
    processItem(parser, expr, param, namedModule) {
      if (param.isConditional()) return param.options.forEach(param => {
        void 0 === this.processItem(parser, expr, param) && this.processContext(parser, expr, param);
      }), !0;
      if (param.isString()) {
        let dep, localModule;
        return dep = "require" === param.string ? new ConstDependency("__webpack_require__", param.range) : [ "require", "exports", "module" ].includes(param.string) ? new ConstDependency(param.string, param.range) : (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string, namedModule)) ? new LocalModuleDependency(localModule, param.range, !1) : this.newRequireItemDependency(param.string, param.range), 
        dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
        !0;
      }
    }
    processContext(parser, expr, param) {
      const dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);
      if (dep) return dep.loc = expr.loc, dep.optional = !!parser.scope.inTry, parser.state.current.addDependency(dep), 
      !0;
    }
    processCallDefine(parser, expr) {
      let array, fn, obj, namedModule;
      switch (expr.arguments.length) {
       case 1:
        isCallable(expr.arguments[0]) ? fn = expr.arguments[0] : obj = "ObjectExpression" === expr.arguments[0].type ? expr.arguments[0] : fn = expr.arguments[0];
        break;

       case 2:
        "Literal" === expr.arguments[0].type ? (namedModule = expr.arguments[0].value, isCallable(expr.arguments[1]) ? fn = expr.arguments[1] : obj = "ObjectExpression" === expr.arguments[1].type ? expr.arguments[1] : fn = expr.arguments[1]) : (array = expr.arguments[0], 
        isCallable(expr.arguments[1]) ? fn = expr.arguments[1] : obj = "ObjectExpression" === expr.arguments[1].type ? expr.arguments[1] : fn = expr.arguments[1]);
        break;

       case 3:
        namedModule = expr.arguments[0].value, array = expr.arguments[1], isCallable(expr.arguments[2]) ? fn = expr.arguments[2] : obj = "ObjectExpression" === expr.arguments[2].type ? expr.arguments[2] : fn = expr.arguments[2];
        break;

       default:
        return;
      }
      let fnParams = null, fnParamsOffset = 0;
      fn && (isUnboundFunctionExpression(fn) ? fnParams = fn.params : isBoundFunctionExpression(fn) && (fnParams = fn.callee.object.params, 
      fnParamsOffset = fn.arguments.length - 1, fnParamsOffset < 0 && (fnParamsOffset = 0)));
      let inTry, fnRenames = parser.scope.renames.createChild();
      if (array) {
        const identifiers = {}, param = parser.evaluateExpression(array);
        if (!this.processArray(parser, expr, param, identifiers, namedModule)) return;
        fnParams && (fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => !identifiers[idx] || (fnRenames.set(param.name, identifiers[idx]), 
        !1)));
      } else {
        const identifiers = [ "require", "exports", "module" ];
        fnParams && (fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => !identifiers[idx] || (fnRenames.set(param.name, identifiers[idx]), 
        !1)));
      }
      fn && isUnboundFunctionExpression(fn) ? (inTry = parser.scope.inTry, parser.inScope(fnParams, () => {
        parser.scope.renames = fnRenames, parser.scope.inTry = inTry, "BlockStatement" === fn.body.type ? parser.walkStatement(fn.body) : parser.walkExpression(fn.body);
      })) : fn && isBoundFunctionExpression(fn) ? (inTry = parser.scope.inTry, parser.inScope(fn.callee.object.params.filter(i => ![ "require", "module", "exports" ].includes(i.name)), () => {
        parser.scope.renames = fnRenames, parser.scope.inTry = inTry, "BlockStatement" === fn.callee.object.body.type ? parser.walkStatement(fn.callee.object.body) : parser.walkExpression(fn.callee.object.body);
      }), fn.arguments && parser.walkExpressions(fn.arguments)) : (fn || obj) && parser.walkExpression(fn || obj);
      const dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule || null);
      return dep.loc = expr.loc, namedModule && (dep.localModule = LocalModulesHelpers.addLocalModule(parser.state, namedModule)), 
      parser.state.current.addDependency(dep), !0;
    }
    newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {
      return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);
    }
    newRequireArrayDependency(depsArray, range) {
      return new AMDRequireArrayDependency(depsArray, range);
    }
    newRequireItemDependency(request, range) {
      return new AMDRequireItemDependency(request, range);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ParserHelpers = __webpack_require__(9), ConstDependency = __webpack_require__(5), NullFactory = __webpack_require__(10);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("RequireJsStuffPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const handler = (parser, parserOptions) => {
          (void 0 === parserOptions.requireJs || parserOptions.requireJs) && (parser.hooks.call.for("require.config").tap("RequireJsStuffPlugin", ParserHelpers.toConstantDependency(parser, "undefined")), 
          parser.hooks.call.for("requirejs.config").tap("RequireJsStuffPlugin", ParserHelpers.toConstantDependency(parser, "undefined")), 
          parser.hooks.expression.for("require.version").tap("RequireJsStuffPlugin", ParserHelpers.toConstantDependency(parser, JSON.stringify("0.0.0"))), 
          parser.hooks.expression.for("requirejs.onError").tap("RequireJsStuffPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, "__webpack_require__.oe")));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("RequireJsStuffPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("RequireJsStuffPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), ParserHelpers = __webpack_require__(9), ConstDependency = __webpack_require__(5), NullFactory = __webpack_require__(10);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("NodeStuffPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const handler = (parser, parserOptions) => {
          if (!1 === parserOptions.node) return;
          let localOptions = options;
          parserOptions.node && (localOptions = Object.assign({}, localOptions, parserOptions.node));
          const setConstant = (expressionName, value) => {
            parser.hooks.expression.for(expressionName).tap("NodeStuffPlugin", () => (parser.state.current.addVariable(expressionName, JSON.stringify(value)), 
            !0));
          }, setModuleConstant = (expressionName, fn) => {
            parser.hooks.expression.for(expressionName).tap("NodeStuffPlugin", () => (parser.state.current.addVariable(expressionName, JSON.stringify(fn(parser.state.module))), 
            !0));
          }, context = compiler.context;
          localOptions.__filename && ("mock" === localOptions.__filename ? setConstant("__filename", "/index.js") : setModuleConstant("__filename", module => path.relative(context, module.resource)), 
          parser.hooks.evaluateIdentifier.for("__filename").tap("NodeStuffPlugin", expr => {
            if (!parser.state.module) return;
            const resource = parser.state.module.resource, i = resource.indexOf("?");
            return ParserHelpers.evaluateToString(i < 0 ? resource : resource.substr(0, i))(expr);
          })), localOptions.__dirname && ("mock" === localOptions.__dirname ? setConstant("__dirname", "/") : setModuleConstant("__dirname", module => path.relative(context, module.context)), 
          parser.hooks.evaluateIdentifier.for("__dirname").tap("NodeStuffPlugin", expr => {
            if (parser.state.module) return ParserHelpers.evaluateToString(parser.state.module.context)(expr);
          })), parser.hooks.expression.for("require.extensions").tap("NodeStuffPlugin", ParserHelpers.expressionIsUnsupported(parser, "require.extensions is not supported by webpack. Use a loader instead."));
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("NodeStuffPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("NodeStuffPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const NoModeWarning = __webpack_require__(346);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("WarnNoModeSetPlugin", compilation => {
        compilation.warnings.push(new NoModeWarning);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(modules) {
      super(), this.name = "NoModeWarning", this.message = "configuration\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/", 
      Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const GraphHelpers = __webpack_require__(27);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("EnsureChunkConditionsPlugin", compilation => {
        const handler = chunks => {
          for (const module of compilation.modules) {
            if (!module.chunkCondition) continue;
            const sourceChunks = new Set, chunkGroups = new Set;
            for (const chunk of module.chunksIterable) if (!module.chunkCondition(chunk)) {
              sourceChunks.add(chunk);
              for (const group of chunk.groupsIterable) chunkGroups.add(group);
            }
            if (0 === sourceChunks.size) continue;
            const targetChunks = new Set;
            chunkGroupLoop: for (const chunkGroup of chunkGroups) {
              for (const chunk of chunkGroup.chunks) if (module.chunkCondition(chunk)) {
                targetChunks.add(chunk);
                continue chunkGroupLoop;
              }
              if (chunkGroup.isInitial()) throw new Error("Cannot fullfil chunk condition of " + module.identifier());
              for (const group of chunkGroup.parentsIterable) chunkGroups.add(group);
            }
            for (const sourceChunk of sourceChunks) GraphHelpers.disconnectChunkAndModule(sourceChunk, module);
            for (const targetChunk of targetChunks) GraphHelpers.connectChunkAndModule(targetChunk, module);
          }
        };
        compilation.hooks.optimizeChunksBasic.tap("EnsureChunkConditionsPlugin", handler), 
        compilation.hooks.optimizeExtractedChunksBasic.tap("EnsureChunkConditionsPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Queue = __webpack_require__(159), {intersect: intersect} = __webpack_require__(37), getParentChunksWithModule = (currentChunk, module) => {
    const chunks = [], stack = new Set(currentChunk.parentsIterable);
    for (const chunk of stack) if (chunk.containsModule(module)) chunks.push(chunk); else for (const parent of chunk.parentsIterable) stack.add(parent);
    return chunks;
  };
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("RemoveParentModulesPlugin", compilation => {
        const handler = (chunks, chunkGroups) => {
          const queue = new Queue, availableModulesMap = new WeakMap;
          for (const chunkGroup of compilation.entrypoints.values()) {
            availableModulesMap.set(chunkGroup, new Set);
            for (const child of chunkGroup.childrenIterable) queue.enqueue(child);
          }
          for (;queue.length > 0; ) {
            const chunkGroup = queue.dequeue();
            let availableModules = availableModulesMap.get(chunkGroup), changed = !1;
            for (const parent of chunkGroup.parentsIterable) {
              const availableModulesInParent = availableModulesMap.get(parent);
              if (void 0 !== availableModulesInParent) if (void 0 === availableModules) {
                availableModules = new Set(availableModulesInParent);
                for (const chunk of parent.chunks) for (const m of chunk.modulesIterable) availableModules.add(m);
                availableModulesMap.set(chunkGroup, availableModules), changed = !0;
              } else for (const m of availableModules) parent.containsModule(m) || availableModulesInParent.has(m) || (availableModules.delete(m), 
              changed = !0);
            }
            if (changed) for (const child of chunkGroup.childrenIterable) queue.enqueue(child);
          }
          for (const chunk of chunks) {
            const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));
            if (availableModulesSets.some(s => void 0 === s)) continue;
            const availableModules = 1 === availableModulesSets.length ? availableModulesSets[0] : intersect(availableModulesSets), numberOfModules = chunk.getNumberOfModules(), toRemove = new Set;
            if (numberOfModules < availableModules.size) for (const m of chunk.modulesIterable) availableModules.has(m) && toRemove.add(m); else for (const m of availableModules) chunk.containsModule(m) && toRemove.add(m);
            for (const module of toRemove) module.rewriteChunkInReasons(chunk, getParentChunksWithModule(chunk, module)), 
            chunk.removeModule(module);
          }
        };
        compilation.hooks.optimizeChunksBasic.tap("RemoveParentModulesPlugin", handler), 
        compilation.hooks.optimizeExtractedChunksBasic.tap("RemoveParentModulesPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("RemoveEmptyChunksPlugin", compilation => {
        const handler = chunks => {
          for (let i = chunks.length - 1; i >= 0; i--) {
            const chunk = chunks[i];
            !chunk.isEmpty() || chunk.hasRuntime() || chunk.hasEntryModule() || (chunk.remove("empty"), 
            chunks.splice(i, 1));
          }
        };
        compilation.hooks.optimizeChunksBasic.tap("RemoveEmptyChunksPlugin", handler), compilation.hooks.optimizeChunksAdvanced.tap("RemoveEmptyChunksPlugin", handler), 
        compilation.hooks.optimizeExtractedChunksBasic.tap("RemoveEmptyChunksPlugin", handler), 
        compilation.hooks.optimizeExtractedChunksAdvanced.tap("RemoveEmptyChunksPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("MergeDuplicateChunksPlugin", compilation => {
        compilation.hooks.optimizeChunksBasic.tap("MergeDuplicateChunksPlugin", chunks => {
          const notDuplicates = new Set;
          for (const chunk of chunks) {
            let possibleDuplicates;
            for (const module of chunk.modulesIterable) if (void 0 === possibleDuplicates) {
              for (const dup of module.chunksIterable) dup === chunk || chunk.getNumberOfModules() !== dup.getNumberOfModules() || notDuplicates.has(dup) || (void 0 === possibleDuplicates && (possibleDuplicates = new Set), 
              possibleDuplicates.add(dup));
              if (void 0 === possibleDuplicates) break;
            } else {
              for (const dup of possibleDuplicates) dup.containsModule(module) || possibleDuplicates.delete(dup);
              if (0 === possibleDuplicates.size) break;
            }
            if (void 0 !== possibleDuplicates && possibleDuplicates.size > 0) for (const otherChunk of possibleDuplicates) otherChunk.hasRuntime() === chunk.hasRuntime() && chunk.integrate(otherChunk, "duplicate") && chunks.splice(chunks.indexOf(otherChunk), 1);
            notDuplicates.add(chunk);
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("FlagIncludedChunksPlugin", compilation => {
        compilation.hooks.optimizeChunkIds.tap("FlagIncludedChunksPlugin", chunks => {
          const moduleBits = new WeakMap, modulesCount = compilation.modules.length, modulo = 1 / Math.pow(1 / modulesCount, 1 / 31), modulos = Array.from({
            length: 31
          }, (x, i) => 0 | Math.pow(modulo, i));
          let i = 0;
          for (const module of compilation.modules) {
            let bit = 30;
            for (;i % modulos[bit] != 0; ) bit--;
            moduleBits.set(module, 1 << bit), i++;
          }
          const chunkModulesHash = new WeakMap;
          for (const chunk of chunks) {
            let hash = 0;
            for (const module of chunk.modulesIterable) hash |= moduleBits.get(module);
            chunkModulesHash.set(chunk, hash);
          }
          for (const chunkA of chunks) {
            const chunkAHash = chunkModulesHash.get(chunkA), chunkAModulesCount = chunkA.getNumberOfModules();
            if (0 === chunkAModulesCount) continue;
            let bestModule = void 0;
            for (const module of chunkA.modulesIterable) (void 0 === bestModule || bestModule.getNumberOfChunks() > module.getNumberOfChunks()) && (bestModule = module);
            loopB: for (const chunkB of bestModule.chunksIterable) {
              if (chunkA === chunkB) continue;
              const chunkBModulesCount = chunkB.getNumberOfModules();
              if (0 === chunkBModulesCount) continue;
              if (chunkAModulesCount > chunkBModulesCount) continue;
              if ((chunkModulesHash.get(chunkB) & chunkAHash) === chunkAHash) {
                for (const m of chunkA.modulesIterable) if (!chunkB.containsModule(m)) continue loopB;
                chunkB.ids.push(chunkA.id);
              }
            }
          }
        });
      });
    }
  };
}, function(module, exports) {
  module.exports = require("../vendor/micromatch");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Queue = __webpack_require__(159);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("FlagDependencyExportsPlugin", compilation => {
        compilation.hooks.finishModules.tap("FlagDependencyExportsPlugin", modules => {
          const dependencies = new Map, queue = new Queue;
          let module, moduleWithExports, moduleProvidedExports, providedExportsAreTemporary;
          const processDependenciesBlock = depBlock => {
            for (const dep of depBlock.dependencies) if (processDependency(dep)) return !0;
            for (const variable of depBlock.variables) for (const dep of variable.dependencies) if (processDependency(dep)) return !0;
            for (const block of depBlock.blocks) if (processDependenciesBlock(block)) return !0;
            return !1;
          }, processDependency = dep => {
            const exportDesc = dep.getExports && dep.getExports();
            if (!exportDesc) return;
            moduleWithExports = !0;
            const exports = exportDesc.exports;
            if (!0 === module.buildMeta.providedExports) return !0;
            if (!0 === exports) return module.buildMeta.providedExports = !0, !0;
            Array.isArray(exports) && ((a, b) => {
              for (const item of b) a.add(item);
            })(moduleProvidedExports, exports);
            const exportDeps = exportDesc.dependencies;
            if (exportDeps) {
              providedExportsAreTemporary = !0;
              for (const exportDependency of exportDeps) {
                const set = dependencies.get(exportDependency);
                void 0 === set ? dependencies.set(exportDependency, new Set([ module ])) : set.add(module);
              }
            }
            return !1;
          }, notifyDependencies = () => {
            const deps = dependencies.get(module);
            if (void 0 !== deps) for (const dep of deps) queue.enqueue(dep);
          }, notifyDependenciesIfDifferent = (set, array) => {
            const deps = dependencies.get(module);
            if (void 0 !== deps) {
              if (set.size === array.length) {
                let i = 0, different = !1;
                for (const item of set) if (item !== array[i++]) {
                  different = !0;
                  break;
                }
                if (!different) return;
              }
              for (const dep of deps) queue.enqueue(dep);
            }
          };
          for (const module of modules) module.buildInfo.temporaryProvidedExports ? (module.buildMeta.providedExports = null, 
          queue.enqueue(module)) : module.buildMeta.providedExports || queue.enqueue(module);
          for (;queue.length > 0; ) module = queue.dequeue(), !0 !== module.buildMeta.providedExports && (moduleWithExports = module.buildMeta && module.buildMeta.exportsType, 
          moduleProvidedExports = new Set, providedExportsAreTemporary = !1, processDependenciesBlock(module), 
          module.buildInfo.temporaryProvidedExports = providedExportsAreTemporary, moduleWithExports ? !0 === module.buildMeta.providedExports ? notifyDependencies() : module.buildMeta.providedExports ? (notifyDependenciesIfDifferent(moduleProvidedExports, module.buildMeta.providedExports), 
          module.buildMeta.providedExports = Array.from(moduleProvidedExports)) : (notifyDependencies(), 
          module.buildMeta.providedExports = Array.from(moduleProvidedExports)) : (notifyDependencies(), 
          module.buildMeta.providedExports = !0));
        });
        const providedExportsCache = new WeakMap;
        compilation.hooks.rebuildModule.tap("FlagDependencyExportsPlugin", module => {
          providedExportsCache.set(module, module.buildMeta.providedExports);
        }), compilation.hooks.finishRebuildingModule.tap("FlagDependencyExportsPlugin", module => {
          module.buildMeta.providedExports = providedExportsCache.get(module);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("FlagDependencyUsagePlugin", compilation => {
        compilation.hooks.optimizeDependencies.tap("FlagDependencyUsagePlugin", modules => {
          const processModule = (module, usedExports) => {
            if (module.used = !0, !0 !== module.usedExports) {
              if (!0 === usedExports) module.usedExports = !0; else if (Array.isArray(usedExports)) {
                const old = module.usedExports ? module.usedExports.length : -1;
                if (module.usedExports = ((a, b) => {
                  for (const item of b) a.includes(item) || a.push(item);
                  return a;
                })(module.usedExports || [], usedExports), module.usedExports.length === old) return;
              } else {
                if (Array.isArray(module.usedExports)) return;
                module.usedExports = !1;
              }
              if (module.factoryMeta.sideEffectFree) {
                if (!1 === module.usedExports) return;
                if (Array.isArray(module.usedExports) && 0 === module.usedExports.length) return;
              }
              queue.push([ module, module, module.usedExports ]);
            }
          }, processDependenciesBlock = (module, depBlock, usedExports) => {
            for (const dep of depBlock.dependencies) processDependency(module, dep);
            for (const variable of depBlock.variables) for (const dep of variable.dependencies) processDependency(module, dep);
            for (const block of depBlock.blocks) queue.push([ module, block, usedExports ]);
          }, processDependency = (module, dep) => {
            const reference = compilation.getDependencyReference(module, dep);
            if (!reference) return;
            const referenceModule = reference.module, importedNames = reference.importedNames, oldUsed = referenceModule.used, oldUsedExports = referenceModule.usedExports;
            var biggerSet, subset;
            oldUsed && (!importedNames || oldUsedExports && (subset = importedNames, !0 === (biggerSet = oldUsedExports) || !0 !== subset && subset.every(item => biggerSet.indexOf(item) >= 0))) || processModule(referenceModule, importedNames);
          };
          for (const module of modules) module.used || (module.used = !1);
          const queue = [];
          for (const preparedEntrypoint of compilation._preparedEntrypoints) preparedEntrypoint.module && processModule(preparedEntrypoint.module, !0);
          for (;queue.length; ) {
            const queueItem = queue.pop();
            processDependenciesBlock(queueItem[0], queueItem[1], queueItem[2]);
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Module = __webpack_require__(18), Template = __webpack_require__(2), Parser = __webpack_require__(114), eslintScope = __webpack_require__(356), {ConcatSource: ConcatSource, ReplaceSource: ReplaceSource} = __webpack_require__(0), DependencyReference = __webpack_require__(15), HarmonyImportDependency = __webpack_require__(22), HarmonyImportSideEffectDependency = __webpack_require__(34), HarmonyImportSpecifierDependency = __webpack_require__(49), HarmonyExportSpecifierDependency = __webpack_require__(78), HarmonyExportExpressionDependency = __webpack_require__(77), HarmonyExportImportedSpecifierDependency = __webpack_require__(50), HarmonyCompatibilityDependency = __webpack_require__(48), createHash = __webpack_require__(17), getFinalName = (info, exportName, moduleToInfoMap, requestShortener, asCall, strictHarmonyModule, alreadyVisited = new Set) => {
    switch (info.type) {
     case "concatenated":
      {
        const directExport = info.exportMap.get(exportName);
        if (directExport) {
          if (!0 === exportName) ((info, moduleToInfoMap, requestShortener, strictHarmonyModule) => {
            if (!info.hasNamespaceObject) {
              info.hasNamespaceObject = !0;
              const name = info.exportMap.get(!0), nsObj = [ `var ${name} = {};`, `__webpack_require__.r(${name});` ];
              for (const exportName of info.module.buildMeta.providedExports) {
                const finalName = getFinalName(info, exportName, moduleToInfoMap, requestShortener, !1, strictHarmonyModule);
                nsObj.push(`__webpack_require__.d(${name}, ${JSON.stringify(exportName)}, function() { return ${finalName}; });`);
              }
              info.namespaceObjectSource = nsObj.join("\n") + "\n";
            }
          })(info, moduleToInfoMap, requestShortener, strictHarmonyModule); else if (!info.module.isUsed(exportName)) return "/* unused export */ undefined";
          if (info.globalExports.has(directExport)) return directExport;
          const name = info.internalNames.get(directExport);
          if (!name) throw new Error(`The export "${directExport}" in "${info.module.readableIdentifier(requestShortener)}" has no internal name`);
          return name;
        }
        const reexport = info.reexportMap.get(exportName);
        if (reexport) {
          if (alreadyVisited.has(reexport)) throw new Error(`Circular reexports ${Array.from(alreadyVisited, e => `"${e.module.readableIdentifier(requestShortener)}".${e.exportName}`).join(" --\x3e ")} -(circular)-> "${reexport.module.readableIdentifier(requestShortener)}".${reexport.exportName}`);
          alreadyVisited.add(reexport);
          const refInfo = moduleToInfoMap.get(reexport.module);
          if (refInfo) return getFinalName(refInfo, reexport.exportName, moduleToInfoMap, requestShortener, asCall, strictHarmonyModule, alreadyVisited);
        }
        const problem = `Cannot get final name for export "${exportName}" in "${info.module.readableIdentifier(requestShortener)}" (known exports: ${Array.from(info.exportMap.keys()).filter(name => !0 !== name).join(" ")}, known reexports: ${Array.from(info.reexportMap.keys()).join(" ")})`;
        return Template.toNormalComment(problem) + " undefined";
      }

     case "external":
      return ((importedModule, info, exportName, asCall, strictHarmonyModule) => {
        const used = importedModule.isUsed(exportName);
        if (!used) return "/* unused reexport */undefined";
        const comment = used !== exportName ? " " + Template.toNormalComment(exportName) : "";
        switch (importedModule.buildMeta.exportsType) {
         case "named":
          if ("default" === exportName) return info.name;
          if (!0 === exportName) return info.interopNamespaceObjectUsed = !0, info.interopNamespaceObjectName;
          break;

         case "namespace":
          if (!0 === exportName) return info.name;
          break;

         default:
          if (strictHarmonyModule) return "default" === exportName ? info.name : !0 === exportName ? (info.interopNamespaceObjectUsed = !0, 
          info.interopNamespaceObjectName) : "/* non-default import from non-esm module */undefined";
          if ("default" === exportName) return info.interopDefaultAccessUsed = !0, asCall ? info.interopDefaultAccessName + "()" : info.interopDefaultAccessName + ".a";
          if (!0 === exportName) return info.name;
        }
        const reference = `${info.name}[${JSON.stringify(used)}${comment}]`;
        return asCall ? `Object(${reference})` : reference;
      })(info.module, info, exportName, asCall, strictHarmonyModule);
    }
  }, addScopeSymbols1 = (s, nameSet, scopeSet) => {
    let scope = s;
    for (;scope && !scopeSet.has(scope); ) {
      scopeSet.add(scope);
      for (const variable of scope.variables) nameSet.add(variable.name);
      scope = scope.upper;
    }
  }, addScopeSymbols2 = (s, nameSet, scopeSet1, scopeSet2) => {
    let scope = s;
    for (;scope && !scopeSet1.has(scope) && !scopeSet2.has(scope); ) {
      scopeSet1.add(scope);
      for (const variable of scope.variables) nameSet.add(variable.name);
      scope = scope.upper;
    }
  }, getAllReferences = variable => {
    let set = variable.references;
    const identifiers = new Set(variable.identifiers);
    for (const scope of variable.scope.childScopes) for (const innerVar of scope.variables) if (innerVar.identifiers.some(id => identifiers.has(id))) {
      set = set.concat(innerVar.references);
      break;
    }
    return set;
  }, getPathInAst = (ast, node) => {
    if (ast === node) return [];
    const nr = node.range, enterNode = n => {
      if (!n) return;
      const r = n.range;
      if (r && r[0] <= nr[0] && r[1] >= nr[1]) {
        const path = getPathInAst(n, node);
        if (path) return path.push(n), path;
      }
    };
    var i;
    if (Array.isArray(ast)) for (i = 0; i < ast.length; i++) {
      const enterResult = enterNode(ast[i]);
      if (void 0 !== enterResult) return enterResult;
    } else if (ast && "object" == typeof ast) {
      const keys = Object.keys(ast);
      for (i = 0; i < keys.length; i++) {
        const value = ast[keys[i]];
        if (Array.isArray(value)) {
          const pathResult = getPathInAst(value, node);
          if (void 0 !== pathResult) return pathResult;
        } else if (value && "object" == typeof value) {
          const enterResult = enterNode(value);
          if (void 0 !== enterResult) return enterResult;
        }
      }
    }
  }, getHarmonyExportImportedSpecifierDependencyExports = dep => {
    const importModule = dep._module;
    return importModule ? dep._id ? [ {
      name: dep.name,
      id: dep._id,
      module: importModule
    } ] : dep.name ? [ {
      name: dep.name,
      id: !0,
      module: importModule
    } ] : importModule.buildMeta.providedExports.filter(exp => "default" !== exp && !dep.activeExports.has(exp)).map(exp => ({
      name: exp,
      id: exp,
      module: importModule
    })) : [];
  };
  class ConcatenatedModule extends Module {
    constructor(rootModule, modules, concatenationList) {
      super("javascript/esm", null), super.setChunks(rootModule._chunks), this.rootModule = rootModule, 
      this.factoryMeta = rootModule.factoryMeta, this.index = rootModule.index, this.index2 = rootModule.index2, 
      this.depth = rootModule.depth, this.used = rootModule.used, this.usedExports = rootModule.usedExports, 
      this.buildInfo = {
        strict: !0,
        cacheable: modules.every(m => m.buildInfo.cacheable),
        moduleArgument: rootModule.buildInfo.moduleArgument,
        exportsArgument: rootModule.buildInfo.exportsArgument,
        fileDependencies: new Set,
        contextDependencies: new Set,
        assets: void 0
      }, this.built = modules.some(m => m.built), this.buildMeta = rootModule.buildMeta, 
      this._numberOfConcatenatedModules = modules.length;
      const modulesSet = new Set(modules);
      this.reasons = rootModule.reasons.filter(reason => !(reason.dependency instanceof HarmonyImportDependency && modulesSet.has(reason.module))), 
      this.dependencies = [], this.blocks = [], this.warnings = [], this.errors = [], 
      this._orderedConcatenationList = concatenationList || ConcatenatedModule.createConcatenationList(rootModule, modulesSet, null);
      for (const info of this._orderedConcatenationList) if ("concatenated" === info.type) {
        const m = info.module;
        for (const d of m.dependencies.filter(dep => !(dep instanceof HarmonyImportDependency && modulesSet.has(dep._module)))) this.dependencies.push(d);
        for (const d of m.blocks) this.blocks.push(d);
        if (m.buildInfo.fileDependencies) for (const file of m.buildInfo.fileDependencies) this.buildInfo.fileDependencies.add(file);
        if (m.buildInfo.contextDependencies) for (const context of m.buildInfo.contextDependencies) this.buildInfo.contextDependencies.add(context);
        for (const warning of m.warnings) this.warnings.push(warning);
        for (const error of m.errors) this.errors.push(error);
        if (m.buildInfo.assets && (void 0 === this.buildInfo.assets && (this.buildInfo.assets = Object.create(null)), 
        Object.assign(this.buildInfo.assets, m.buildInfo.assets)), m.buildInfo.assetsInfo) {
          void 0 === this.buildInfo.assetsInfo && (this.buildInfo.assetsInfo = new Map);
          for (const [key, value] of m.buildInfo.assetsInfo) this.buildInfo.assetsInfo.set(key, value);
        }
      }
      this._identifier = this._createIdentifier();
    }
    get modules() {
      return this._orderedConcatenationList.filter(info => "concatenated" === info.type).map(info => info.module);
    }
    identifier() {
      return this._identifier;
    }
    readableIdentifier(requestShortener) {
      return this.rootModule.readableIdentifier(requestShortener) + ` + ${this._numberOfConcatenatedModules - 1} modules`;
    }
    libIdent(options) {
      return this.rootModule.libIdent(options);
    }
    nameForCondition() {
      return this.rootModule.nameForCondition();
    }
    build(options, compilation, resolver, fs, callback) {
      throw new Error("Cannot build this module. It should be already built.");
    }
    size() {
      return this._orderedConcatenationList.reduce((sum, info) => {
        switch (info.type) {
         case "concatenated":
          return sum + info.module.size();

         case "external":
          return sum + 5;
        }
        return sum;
      }, 0);
    }
    static createConcatenationList(rootModule, modulesSet, compilation) {
      const list = [], set = new Set, enterModule = getModule => {
        const module = getModule();
        if (module && !set.has(module)) if (set.add(module), modulesSet.has(module)) {
          (module => {
            const map = new WeakMap, references = module.dependencies.filter(dep => dep instanceof HarmonyImportDependency).map(dep => {
              const ref = compilation.getDependencyReference(module, dep);
              return ref && map.set(ref, dep), ref;
            }).filter(ref => ref);
            return DependencyReference.sort(references), references.map(ref => {
              const dep = map.get(ref);
              return () => compilation.getDependencyReference(module, dep).module;
            });
          })(module).forEach(enterModule), list.push({
            type: "concatenated",
            module: module
          });
        } else list.push({
          type: "external",
          get module() {
            return getModule();
          }
        });
      };
      return enterModule(() => rootModule), list;
    }
    _createIdentifier() {
      let orderedConcatenationListIdentifiers = "";
      for (let i = 0; i < this._orderedConcatenationList.length; i++) "concatenated" === this._orderedConcatenationList[i].type && (orderedConcatenationListIdentifiers += this._orderedConcatenationList[i].module.identifier(), 
      orderedConcatenationListIdentifiers += " ");
      const hash = createHash("md4");
      return hash.update(orderedConcatenationListIdentifiers), this.rootModule.identifier() + " " + hash.digest("hex");
    }
    source(dependencyTemplates, runtimeTemplate) {
      const requestShortener = runtimeTemplate.requestShortener, modulesWithInfo = this._orderedConcatenationList.map((info, idx) => {
        switch (info.type) {
         case "concatenated":
          {
            const exportMap = new Map, reexportMap = new Map;
            for (const dep of info.module.dependencies) if (dep instanceof HarmonyExportSpecifierDependency) exportMap.has(dep.name) || exportMap.set(dep.name, dep.id); else if (dep instanceof HarmonyExportExpressionDependency) exportMap.has("default") || exportMap.set("default", "__WEBPACK_MODULE_DEFAULT_EXPORT__"); else if (dep instanceof HarmonyExportImportedSpecifierDependency) {
              const exportName = dep.name, importName = dep._id, importedModule = dep._module;
              if (exportName && importName) reexportMap.has(exportName) || reexportMap.set(exportName, {
                module: importedModule,
                exportName: importName,
                dependency: dep
              }); else if (exportName) reexportMap.has(exportName) || reexportMap.set(exportName, {
                module: importedModule,
                exportName: !0,
                dependency: dep
              }); else if (importedModule) for (const name of importedModule.buildMeta.providedExports) dep.activeExports.has(name) || "default" === name || reexportMap.has(name) || reexportMap.set(name, {
                module: importedModule,
                exportName: name,
                dependency: dep
              });
            }
            return {
              type: "concatenated",
              module: info.module,
              index: idx,
              ast: void 0,
              internalSource: void 0,
              source: void 0,
              globalScope: void 0,
              moduleScope: void 0,
              internalNames: new Map,
              globalExports: new Set,
              exportMap: exportMap,
              reexportMap: reexportMap,
              hasNamespaceObject: !1,
              namespaceObjectSource: null
            };
          }

         case "external":
          return {
            type: "external",
            module: info.module,
            index: idx,
            name: void 0,
            interopNamespaceObjectUsed: !1,
            interopNamespaceObjectName: void 0,
            interopDefaultAccessUsed: !1,
            interopDefaultAccessName: void 0
          };

         default:
          throw new Error("Unsupported concatenation entry type " + info.type);
        }
      }), moduleToInfoMap = new Map;
      for (const m of modulesWithInfo) moduleToInfoMap.set(m.module, m);
      const innerDependencyTemplates = new Map(dependencyTemplates);
      innerDependencyTemplates.set(HarmonyImportSpecifierDependency, new HarmonyImportSpecifierDependencyConcatenatedTemplate(dependencyTemplates.get(HarmonyImportSpecifierDependency), moduleToInfoMap)), 
      innerDependencyTemplates.set(HarmonyImportSideEffectDependency, new HarmonyImportSideEffectDependencyConcatenatedTemplate(dependencyTemplates.get(HarmonyImportSideEffectDependency), moduleToInfoMap)), 
      innerDependencyTemplates.set(HarmonyExportSpecifierDependency, new NullTemplate), 
      innerDependencyTemplates.set(HarmonyExportExpressionDependency, new HarmonyExportExpressionDependencyConcatenatedTemplate(dependencyTemplates.get(HarmonyExportExpressionDependency), this.rootModule)), 
      innerDependencyTemplates.set(HarmonyExportImportedSpecifierDependency, new NullTemplate), 
      innerDependencyTemplates.set(HarmonyCompatibilityDependency, new NullTemplate), 
      innerDependencyTemplates.set("hash", innerDependencyTemplates.get("hash") + this.identifier());
      for (const info of modulesWithInfo) if ("concatenated" === info.type) {
        const source = info.module.source(innerDependencyTemplates, runtimeTemplate), code = source.source();
        let ast;
        try {
          ast = Parser.parse(code, {
            sourceType: "module"
          });
        } catch (err) {
          if (err.loc && "object" == typeof err.loc && "number" == typeof err.loc.line) {
            const lineNumber = err.loc.line, lines = code.split("\n");
            err.message += "\n| " + lines.slice(Math.max(0, lineNumber - 3), lineNumber + 2).join("\n| ");
          }
          throw err;
        }
        const globalScope = eslintScope.analyze(ast, {
          ecmaVersion: 6,
          sourceType: "module",
          optimistic: !0,
          ignoreEval: !0,
          impliedStrict: !0
        }).acquire(ast), moduleScope = globalScope.childScopes[0], resultSource = new ReplaceSource(source);
        info.ast = ast, info.internalSource = source, info.source = resultSource, info.globalScope = globalScope, 
        info.moduleScope = moduleScope;
      }
      const allUsedNames = new Set([ "__WEBPACK_MODULE_DEFAULT_EXPORT__", "abstract", "arguments", "async", "await", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "eval", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "let", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with", "yield", "module", "__dirname", "__filename", "exports", "Array", "Date", "eval", "function", "hasOwnProperty", "Infinity", "isFinite", "isNaN", "isPrototypeOf", "length", "Math", "NaN", "name", "Number", "Object", "prototype", "String", "toString", "undefined", "valueOf", "alert", "all", "anchor", "anchors", "area", "assign", "blur", "button", "checkbox", "clearInterval", "clearTimeout", "clientInformation", "close", "closed", "confirm", "constructor", "crypto", "decodeURI", "decodeURIComponent", "defaultStatus", "document", "element", "elements", "embed", "embeds", "encodeURI", "encodeURIComponent", "escape", "event", "fileUpload", "focus", "form", "forms", "frame", "innerHeight", "innerWidth", "layer", "layers", "link", "location", "mimeTypes", "navigate", "navigator", "frames", "frameRate", "hidden", "history", "image", "images", "offscreenBuffering", "open", "opener", "option", "outerHeight", "outerWidth", "packages", "pageXOffset", "pageYOffset", "parent", "parseFloat", "parseInt", "password", "pkcs11", "plugin", "prompt", "propertyIsEnum", "radio", "reset", "screenX", "screenY", "scroll", "secure", "select", "self", "setInterval", "setTimeout", "status", "submit", "taint", "text", "textarea", "top", "unescape", "untaint", "window", "onblur", "onclick", "onerror", "onfocus", "onkeydown", "onkeypress", "onkeyup", "onmouseover", "onload", "onmouseup", "onmousedown", "onsubmit" ]), alreadyCheckedScopes = new Set;
      for (const info of modulesWithInfo) {
        const superClassExpressions = [];
        if (info.moduleScope) {
          alreadyCheckedScopes.add(info.moduleScope);
          for (const childScope of info.moduleScope.childScopes) "class" === childScope.type && childScope.block.superClass && superClassExpressions.push({
            range: childScope.block.superClass.range,
            variables: childScope.variables
          });
        }
        if (info.globalScope) for (const reference of info.globalScope.through) {
          const name = reference.identifier.name;
          if (/^__WEBPACK_MODULE_REFERENCE__\d+_([\da-f]+|ns)(_call)?(_strict)?__$/.test(name)) {
            for (const expr of superClassExpressions) if (expr.range[0] <= reference.identifier.range[0] && expr.range[1] >= reference.identifier.range[1]) for (const variable of expr.variables) allUsedNames.add(variable.name);
            addScopeSymbols1(reference.from, allUsedNames, alreadyCheckedScopes);
          } else allUsedNames.add(name);
        }
        if ("concatenated" === info.type) {
          const variables = new Set;
          for (const variable of info.moduleScope.variables) variables.add(variable.name);
          for (const [, variable] of info.exportMap) variables.has(variable) || info.globalExports.add(variable);
        }
      }
      for (const info of modulesWithInfo) switch (info.type) {
       case "concatenated":
        {
          const namespaceObjectName = this.findNewName("namespaceObject", allUsedNames, null, info.module.readableIdentifier(requestShortener));
          allUsedNames.add(namespaceObjectName), info.internalNames.set(namespaceObjectName, namespaceObjectName), 
          info.exportMap.set(!0, namespaceObjectName);
          for (const variable of info.moduleScope.variables) {
            const name = variable.name;
            if (allUsedNames.has(name)) {
              const references = getAllReferences(variable), symbolsInReferences = new Set, alreadyCheckedInnerScopes = new Set;
              for (const ref of references) addScopeSymbols2(ref.from, symbolsInReferences, alreadyCheckedInnerScopes, alreadyCheckedScopes);
              const newName = this.findNewName(name, allUsedNames, symbolsInReferences, info.module.readableIdentifier(requestShortener));
              allUsedNames.add(newName), info.internalNames.set(name, newName);
              const source = info.source, allIdentifiers = new Set(references.map(r => r.identifier).concat(variable.identifiers));
              for (const identifier of allIdentifiers) {
                const r = identifier.range, path = getPathInAst(info.ast, identifier);
                path && path.length > 1 && "Property" === path[1].type && path[1].shorthand ? source.insert(r[1], ": " + newName) : source.replace(r[0], r[1] - 1, newName);
              }
            } else allUsedNames.add(name), info.internalNames.set(name, name);
          }
          break;
        }

       case "external":
        {
          const externalName = this.findNewName("", allUsedNames, null, info.module.readableIdentifier(requestShortener));
          if (allUsedNames.add(externalName), info.name = externalName, "named" === info.module.buildMeta.exportsType || !info.module.buildMeta.exportsType) {
            const externalNameInterop = this.findNewName("namespaceObject", allUsedNames, null, info.module.readableIdentifier(requestShortener));
            allUsedNames.add(externalNameInterop), info.interopNamespaceObjectName = externalNameInterop;
          }
          if (!info.module.buildMeta.exportsType) {
            const externalNameInterop = this.findNewName("default", allUsedNames, null, info.module.readableIdentifier(requestShortener));
            allUsedNames.add(externalNameInterop), info.interopDefaultAccessName = externalNameInterop;
          }
          break;
        }
      }
      for (const info of modulesWithInfo) if ("concatenated" === info.type) for (const reference of info.globalScope.through) {
        const name = reference.identifier.name, match = /^__WEBPACK_MODULE_REFERENCE__(\d+)_([\da-f]+|ns)(_call)?(_strict)?__$/.exec(name);
        if (match) {
          const referencedModule = modulesWithInfo[+match[1]];
          let exportName;
          if ("ns" === match[2]) exportName = !0; else {
            const exportData = match[2];
            exportName = Buffer.from(exportData, "hex").toString("utf-8");
          }
          const asCall = !!match[3], strictHarmonyModule = !!match[4], finalName = getFinalName(referencedModule, exportName, moduleToInfoMap, requestShortener, asCall, strictHarmonyModule), r = reference.identifier.range;
          info.source.replace(r[0], r[1] - 1, finalName);
        }
      }
      const exportsMap = new Map, unusedExports = new Set;
      for (const dep of this.rootModule.dependencies) if (dep instanceof HarmonyExportSpecifierDependency) {
        const used = this.rootModule.isUsed(dep.name);
        if (used) {
          const info = moduleToInfoMap.get(this.rootModule);
          exportsMap.has(used) || exportsMap.set(used, () => "/* binding */ " + info.internalNames.get(dep.id));
        } else unusedExports.add(dep.name || "namespace");
      } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {
        const exportDefs = getHarmonyExportImportedSpecifierDependencyExports(dep);
        for (const def of exportDefs) {
          const info = moduleToInfoMap.get(def.module), used = dep.originModule.isUsed(def.name);
          used ? exportsMap.has(used) || exportsMap.set(used, requestShortener => "/* reexport */ " + getFinalName(info, def.id, moduleToInfoMap, requestShortener, !1, this.rootModule.buildMeta.strictHarmonyModule)) : unusedExports.add(def.name);
        }
      }
      const result = new ConcatSource, usedExports = this.rootModule.usedExports;
      if (!0 !== usedExports && null !== usedExports || (result.add("// ESM COMPAT FLAG\n"), 
      result.add(runtimeTemplate.defineEsModuleFlagStatement({
        exportsArgument: this.exportsArgument
      }))), exportsMap.size > 0) {
        result.add("\n// EXPORTS\n");
        for (const [key, value] of exportsMap) result.add(`__webpack_require__.d(${this.exportsArgument}, ${JSON.stringify(key)}, function() { return ${value(requestShortener)}; });\n`);
      }
      unusedExports.size > 0 && result.add(`\n// UNUSED EXPORTS: ${(iterable => {
        let str = "", first = !0;
        for (const item of iterable) first ? first = !1 : str += ", ", str += item;
        return str;
      })(unusedExports)}\n`);
      for (const info of modulesWithInfo) info.namespaceObjectSource && (result.add(`\n// NAMESPACE OBJECT: ${info.module.readableIdentifier(requestShortener)}\n`), 
      result.add(info.namespaceObjectSource));
      for (const info of modulesWithInfo) switch (info.type) {
       case "concatenated":
        result.add(`\n// CONCATENATED MODULE: ${info.module.readableIdentifier(requestShortener)}\n`), 
        result.add(info.source);
        break;

       case "external":
        result.add(`\n// EXTERNAL MODULE: ${info.module.readableIdentifier(requestShortener)}\n`), 
        result.add(`var ${info.name} = __webpack_require__(${JSON.stringify(info.module.id)});\n`), 
        info.interopNamespaceObjectUsed && ("named" === info.module.buildMeta.exportsType ? result.add(`var ${info.interopNamespaceObjectName} = /*#__PURE__*/__webpack_require__.t(${info.name}, 2);\n`) : info.module.buildMeta.exportsType || result.add(`var ${info.interopNamespaceObjectName} = /*#__PURE__*/__webpack_require__.t(${info.name});\n`)), 
        info.interopDefaultAccessUsed && result.add(`var ${info.interopDefaultAccessName} = /*#__PURE__*/__webpack_require__.n(${info.name});\n`);
        break;

       default:
        throw new Error("Unsupported concatenation entry type " + info.type);
      }
      return result;
    }
    findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {
      let name = oldName;
      "__WEBPACK_MODULE_DEFAULT_EXPORT__" === name && (name = "");
      const splittedInfo = (extraInfo = extraInfo.replace(/\.+\/|(\/index)?\.([a-zA-Z0-9]{1,4})($|\s|\?)|\s*\+\s*\d+\s*modules/g, "")).split("/");
      for (;splittedInfo.length; ) {
        name = splittedInfo.pop() + (name ? "_" + name : "");
        const nameIdent = Template.toIdentifier(name);
        if (!(usedNamed1.has(nameIdent) || usedNamed2 && usedNamed2.has(nameIdent))) return nameIdent;
      }
      let i = 0, nameWithNumber = Template.toIdentifier(`${name}_${i}`);
      for (;usedNamed1.has(nameWithNumber) || usedNamed2 && usedNamed2.has(nameWithNumber); ) i++, 
      nameWithNumber = Template.toIdentifier(`${name}_${i}`);
      return nameWithNumber;
    }
    updateHash(hash) {
      for (const info of this._orderedConcatenationList) switch (info.type) {
       case "concatenated":
        info.module.updateHash(hash);
        break;

       case "external":
        hash.update("" + info.module.id);
      }
      super.updateHash(hash);
    }
  }
  class HarmonyImportSpecifierDependencyConcatenatedTemplate {
    constructor(originalTemplate, modulesMap) {
      this.originalTemplate = originalTemplate, this.modulesMap = modulesMap;
    }
    getHarmonyInitOrder(dep) {
      const module = dep._module;
      return this.modulesMap.get(module) ? NaN : this.originalTemplate.getHarmonyInitOrder(dep);
    }
    harmonyInit(dep, source, runtimeTemplate, dependencyTemplates) {
      const module = dep._module;
      this.modulesMap.get(module) || this.originalTemplate.harmonyInit(dep, source, runtimeTemplate, dependencyTemplates);
    }
    apply(dep, source, runtime, dependencyTemplates) {
      const module = dep._module, info = this.modulesMap.get(module);
      if (!info) return void this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
      let content;
      const callFlag = dep.call ? "_call" : "", strictFlag = dep.originModule.buildMeta.strictHarmonyModule ? "_strict" : "";
      if (null === dep._id) content = `__WEBPACK_MODULE_REFERENCE__${info.index}_ns${strictFlag}__`; else if (dep.namespaceObjectAsContext) content = `__WEBPACK_MODULE_REFERENCE__${info.index}_ns${strictFlag}__[${JSON.stringify(dep._id)}]`; else {
        const exportData = Buffer.from(dep._id, "utf-8").toString("hex");
        content = `__WEBPACK_MODULE_REFERENCE__${info.index}_${exportData}${callFlag}${strictFlag}__`;
      }
      dep.shorthand && (content = dep.name + ": " + content), source.replace(dep.range[0], dep.range[1] - 1, content);
    }
  }
  class HarmonyImportSideEffectDependencyConcatenatedTemplate {
    constructor(originalTemplate, modulesMap) {
      this.originalTemplate = originalTemplate, this.modulesMap = modulesMap;
    }
    getHarmonyInitOrder(dep) {
      const module = dep._module;
      return this.modulesMap.get(module) ? NaN : this.originalTemplate.getHarmonyInitOrder(dep);
    }
    harmonyInit(dep, source, runtime, dependencyTemplates) {
      const module = dep._module;
      this.modulesMap.get(module) || this.originalTemplate.harmonyInit(dep, source, runtime, dependencyTemplates);
    }
    apply(dep, source, runtime, dependencyTemplates) {
      const module = dep._module;
      this.modulesMap.get(module) || this.originalTemplate.apply(dep, source, runtime, dependencyTemplates);
    }
  }
  class HarmonyExportExpressionDependencyConcatenatedTemplate {
    constructor(originalTemplate, rootModule) {
      this.originalTemplate = originalTemplate, this.rootModule = rootModule;
    }
    apply(dep, source, runtime, dependencyTemplates) {
      let content = "/* harmony default export */ var __WEBPACK_MODULE_DEFAULT_EXPORT__ = ";
      if (dep.originModule === this.rootModule) {
        const used = dep.originModule.isUsed("default"), exportsName = dep.originModule.exportsArgument;
        used && (content += `${exportsName}[${JSON.stringify(used)}] = `);
      }
      if (dep.range) return source.replace(dep.rangeStatement[0], dep.range[0] - 1, content + "(" + dep.prefix), 
      void source.replace(dep.range[1], dep.rangeStatement[1] - 1, ");");
      source.replace(dep.rangeStatement[0], dep.rangeStatement[1] - 1, content + dep.prefix);
    }
  }
  class NullTemplate {
    apply() {}
  }
  module.exports = ConcatenatedModule;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const assert = __webpack_require__(30), ScopeManager = __webpack_require__(357), Referencer = __webpack_require__(359), Reference = __webpack_require__(87), Variable = __webpack_require__(56), Scope = __webpack_require__(164).Scope, version = __webpack_require__(362).version;
  module.exports = {
    version: version,
    Reference: Reference,
    Variable: Variable,
    Scope: Scope,
    ScopeManager: ScopeManager,
    analyze: function(tree, providedOptions) {
      const options = function updateDeeply(target, override) {
        function isHashObject(value) {
          return "object" == typeof value && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
        }
        for (const key in override) if (override.hasOwnProperty(key)) {
          const val = override[key];
          isHashObject(val) ? isHashObject(target[key]) ? updateDeeply(target[key], val) : target[key] = updateDeeply({}, val) : target[key] = val;
        }
        return target;
      }({
        optimistic: !1,
        directive: !1,
        nodejsScope: !1,
        impliedStrict: !1,
        sourceType: "script",
        ecmaVersion: 5,
        childVisitorKeys: null,
        fallback: "iteration"
      }, providedOptions), scopeManager = new ScopeManager(options);
      return new Referencer(options, scopeManager).visit(tree), assert(null === scopeManager.__currentScope, "currentScope should be null."), 
      scopeManager;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Scope = __webpack_require__(164), assert = __webpack_require__(30), GlobalScope = Scope.GlobalScope, CatchScope = Scope.CatchScope, WithScope = Scope.WithScope, ModuleScope = Scope.ModuleScope, ClassScope = Scope.ClassScope, SwitchScope = Scope.SwitchScope, FunctionScope = Scope.FunctionScope, ForScope = Scope.ForScope, FunctionExpressionNameScope = Scope.FunctionExpressionNameScope, BlockScope = Scope.BlockScope;
  module.exports = class {
    constructor(options) {
      this.scopes = [], this.globalScope = null, this.__nodeToScope = new WeakMap, this.__currentScope = null, 
      this.__options = options, this.__declaredVariables = new WeakMap;
    }
    __useDirective() {
      return this.__options.directive;
    }
    __isOptimistic() {
      return this.__options.optimistic;
    }
    __ignoreEval() {
      return this.__options.ignoreEval;
    }
    __isNodejsScope() {
      return this.__options.nodejsScope;
    }
    isModule() {
      return "module" === this.__options.sourceType;
    }
    isImpliedStrict() {
      return this.__options.impliedStrict;
    }
    isStrictModeSupported() {
      return this.__options.ecmaVersion >= 5;
    }
    __get(node) {
      return this.__nodeToScope.get(node);
    }
    getDeclaredVariables(node) {
      return this.__declaredVariables.get(node) || [];
    }
    acquire(node, inner) {
      function predicate(testScope) {
        return "function" !== testScope.type || !testScope.functionExpressionScope;
      }
      const scopes = this.__get(node);
      if (!scopes || 0 === scopes.length) return null;
      if (1 === scopes.length) return scopes[0];
      if (inner) for (let i = scopes.length - 1; i >= 0; --i) {
        const scope = scopes[i];
        if (predicate(scope)) return scope;
      } else for (let i = 0, iz = scopes.length; i < iz; ++i) {
        const scope = scopes[i];
        if (predicate(scope)) return scope;
      }
      return null;
    }
    acquireAll(node) {
      return this.__get(node);
    }
    release(node, inner) {
      const scopes = this.__get(node);
      if (scopes && scopes.length) {
        const scope = scopes[0].upper;
        return scope ? this.acquire(scope.block, inner) : null;
      }
      return null;
    }
    attach() {}
    detach() {}
    __nestScope(scope) {
      return scope instanceof GlobalScope && (assert(null === this.__currentScope), this.globalScope = scope), 
      this.__currentScope = scope, scope;
    }
    __nestGlobalScope(node) {
      return this.__nestScope(new GlobalScope(this, node));
    }
    __nestBlockScope(node) {
      return this.__nestScope(new BlockScope(this, this.__currentScope, node));
    }
    __nestFunctionScope(node, isMethodDefinition) {
      return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
    }
    __nestForScope(node) {
      return this.__nestScope(new ForScope(this, this.__currentScope, node));
    }
    __nestCatchScope(node) {
      return this.__nestScope(new CatchScope(this, this.__currentScope, node));
    }
    __nestWithScope(node) {
      return this.__nestScope(new WithScope(this, this.__currentScope, node));
    }
    __nestClassScope(node) {
      return this.__nestScope(new ClassScope(this, this.__currentScope, node));
    }
    __nestSwitchScope(node) {
      return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
    }
    __nestModuleScope(node) {
      return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
    }
    __nestFunctionExpressionNameScope(node) {
      return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
    }
    __isES6() {
      return this.__options.ecmaVersion >= 6;
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"name":"estraverse","version":"4.3.0"}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Syntax = __webpack_require__(55).Syntax, esrecurse = __webpack_require__(166), Reference = __webpack_require__(87), Variable = __webpack_require__(56), PatternVisitor = __webpack_require__(361), definition = __webpack_require__(165), assert = __webpack_require__(30), ParameterDefinition = definition.ParameterDefinition, Definition = definition.Definition;
  class Importer extends esrecurse.Visitor {
    constructor(declaration, referencer) {
      super(null, referencer.options), this.declaration = declaration, this.referencer = referencer;
    }
    visitImport(id, specifier) {
      this.referencer.visitPattern(id, pattern => {
        this.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, this.declaration, null, null));
      });
    }
    ImportNamespaceSpecifier(node) {
      const local = node.local || node.id;
      local && this.visitImport(local, node);
    }
    ImportDefaultSpecifier(node) {
      const local = node.local || node.id;
      this.visitImport(local, node);
    }
    ImportSpecifier(node) {
      const local = node.local || node.id;
      node.name ? this.visitImport(node.name, node) : this.visitImport(local, node);
    }
  }
  class Referencer extends esrecurse.Visitor {
    constructor(options, scopeManager) {
      super(null, options), this.options = options, this.scopeManager = scopeManager, 
      this.parent = null, this.isInnerMethodDefinition = !1;
    }
    currentScope() {
      return this.scopeManager.__currentScope;
    }
    close(node) {
      for (;this.currentScope() && node === this.currentScope().block; ) this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
    }
    pushInnerMethodDefinition(isInnerMethodDefinition) {
      const previous = this.isInnerMethodDefinition;
      return this.isInnerMethodDefinition = isInnerMethodDefinition, previous;
    }
    popInnerMethodDefinition(isInnerMethodDefinition) {
      this.isInnerMethodDefinition = isInnerMethodDefinition;
    }
    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
      const scope = this.currentScope();
      assignments.forEach(assignment => {
        scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
      });
    }
    visitPattern(node, options, callback) {
      "function" == typeof options && (callback = options, options = {
        processRightHandNodes: !1
      }), function(options, rootPattern, referencer, callback) {
        const visitor = new PatternVisitor(options, rootPattern, callback);
        visitor.visit(rootPattern), null != referencer && visitor.rightHandNodes.forEach(referencer.visit, referencer);
      }(this.options, node, options.processRightHandNodes ? this : null, callback);
    }
    visitFunction(node) {
      let i, iz;
      node.type === Syntax.FunctionDeclaration && this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null)), 
      node.type === Syntax.FunctionExpression && node.id && this.scopeManager.__nestFunctionExpressionNameScope(node), 
      this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
      const that = this;
      function visitPatternCallback(pattern, info) {
        that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest)), 
        that.referencingDefaultValue(pattern, info.assignments, null, !0);
      }
      for (i = 0, iz = node.params.length; i < iz; ++i) this.visitPattern(node.params[i], {
        processRightHandNodes: !0
      }, visitPatternCallback);
      node.rest && this.visitPattern({
        type: "RestElement",
        argument: node.rest
      }, pattern => {
        this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, !0));
      }), node.body && (node.body.type === Syntax.BlockStatement ? this.visitChildren(node.body) : this.visit(node.body)), 
      this.close(node);
    }
    visitClass(node) {
      node.type === Syntax.ClassDeclaration && this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null)), 
      this.visit(node.superClass), this.scopeManager.__nestClassScope(node), node.id && this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node)), 
      this.visit(node.body), this.close(node);
    }
    visitProperty(node) {
      let previous;
      node.computed && this.visit(node.key);
      const isMethodDefinition = node.type === Syntax.MethodDefinition;
      isMethodDefinition && (previous = this.pushInnerMethodDefinition(!0)), this.visit(node.value), 
      isMethodDefinition && this.popInnerMethodDefinition(previous);
    }
    visitForIn(node) {
      node.left.type === Syntax.VariableDeclaration && "var" !== node.left.kind && this.scopeManager.__nestForScope(node), 
      node.left.type === Syntax.VariableDeclaration ? (this.visit(node.left), this.visitPattern(node.left.declarations[0].id, pattern => {
        this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, !0, !0);
      })) : this.visitPattern(node.left, {
        processRightHandNodes: !0
      }, (pattern, info) => {
        let maybeImplicitGlobal = null;
        this.currentScope().isStrict || (maybeImplicitGlobal = {
          pattern: pattern,
          node: node
        }), this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, !1), 
        this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !0, !1);
      }), this.visit(node.right), this.visit(node.body), this.close(node);
    }
    visitVariableDeclaration(variableTargetScope, type, node, index) {
      const decl = node.declarations[index], init = decl.init;
      this.visitPattern(decl.id, {
        processRightHandNodes: !0
      }, (pattern, info) => {
        variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind)), 
        this.referencingDefaultValue(pattern, info.assignments, null, !0), init && this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, !0);
      });
    }
    AssignmentExpression(node) {
      PatternVisitor.isPattern(node.left) ? "=" === node.operator ? this.visitPattern(node.left, {
        processRightHandNodes: !0
      }, (pattern, info) => {
        let maybeImplicitGlobal = null;
        this.currentScope().isStrict || (maybeImplicitGlobal = {
          pattern: pattern,
          node: node
        }), this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, !1), 
        this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, !1);
      }) : this.currentScope().__referencing(node.left, Reference.RW, node.right) : this.visit(node.left), 
      this.visit(node.right);
    }
    CatchClause(node) {
      this.scopeManager.__nestCatchScope(node), this.visitPattern(node.param, {
        processRightHandNodes: !0
      }, (pattern, info) => {
        this.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null)), 
        this.referencingDefaultValue(pattern, info.assignments, null, !0);
      }), this.visit(node.body), this.close(node);
    }
    Program(node) {
      this.scopeManager.__nestGlobalScope(node), this.scopeManager.__isNodejsScope() && (this.currentScope().isStrict = !1, 
      this.scopeManager.__nestFunctionScope(node, !1)), this.scopeManager.__isES6() && this.scopeManager.isModule() && this.scopeManager.__nestModuleScope(node), 
      this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0), 
      this.visitChildren(node), this.close(node);
    }
    Identifier(node) {
      this.currentScope().__referencing(node);
    }
    UpdateExpression(node) {
      PatternVisitor.isPattern(node.argument) ? this.currentScope().__referencing(node.argument, Reference.RW, null) : this.visitChildren(node);
    }
    MemberExpression(node) {
      this.visit(node.object), node.computed && this.visit(node.property);
    }
    Property(node) {
      this.visitProperty(node);
    }
    MethodDefinition(node) {
      this.visitProperty(node);
    }
    BreakStatement() {}
    ContinueStatement() {}
    LabeledStatement(node) {
      this.visit(node.body);
    }
    ForStatement(node) {
      node.init && node.init.type === Syntax.VariableDeclaration && "var" !== node.init.kind && this.scopeManager.__nestForScope(node), 
      this.visitChildren(node), this.close(node);
    }
    ClassExpression(node) {
      this.visitClass(node);
    }
    ClassDeclaration(node) {
      this.visitClass(node);
    }
    CallExpression(node) {
      this.scopeManager.__ignoreEval() || node.callee.type !== Syntax.Identifier || "eval" !== node.callee.name || this.currentScope().variableScope.__detectEval(), 
      this.visitChildren(node);
    }
    BlockStatement(node) {
      this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(node), this.visitChildren(node), 
      this.close(node);
    }
    ThisExpression() {
      this.currentScope().variableScope.__detectThis();
    }
    WithStatement(node) {
      this.visit(node.object), this.scopeManager.__nestWithScope(node), this.visit(node.body), 
      this.close(node);
    }
    VariableDeclaration(node) {
      const variableTargetScope = "var" === node.kind ? this.currentScope().variableScope : this.currentScope();
      for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
        const decl = node.declarations[i];
        this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i), 
        decl.init && this.visit(decl.init);
      }
    }
    SwitchStatement(node) {
      this.visit(node.discriminant), this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(node);
      for (let i = 0, iz = node.cases.length; i < iz; ++i) this.visit(node.cases[i]);
      this.close(node);
    }
    FunctionDeclaration(node) {
      this.visitFunction(node);
    }
    FunctionExpression(node) {
      this.visitFunction(node);
    }
    ForOfStatement(node) {
      this.visitForIn(node);
    }
    ForInStatement(node) {
      this.visitForIn(node);
    }
    ArrowFunctionExpression(node) {
      this.visitFunction(node);
    }
    ImportDeclaration(node) {
      assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
      new Importer(node, this).visit(node);
    }
    visitExportDeclaration(node) {
      node.source || (node.declaration ? this.visit(node.declaration) : this.visitChildren(node));
    }
    ExportDeclaration(node) {
      this.visitExportDeclaration(node);
    }
    ExportNamedDeclaration(node) {
      this.visitExportDeclaration(node);
    }
    ExportSpecifier(node) {
      const local = node.id || node.local;
      this.visit(local);
    }
    MetaProperty() {}
  }
  module.exports = Referencer;
}, function(module) {
  module.exports = JSON.parse('{"name":"esrecurse","version":"4.2.1"}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Syntax = __webpack_require__(55).Syntax, esrecurse = __webpack_require__(166);
  class PatternVisitor extends esrecurse.Visitor {
    static isPattern(node) {
      const nodeType = node.type;
      return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
    }
    constructor(options, rootPattern, callback) {
      super(null, options), this.rootPattern = rootPattern, this.callback = callback, 
      this.assignments = [], this.rightHandNodes = [], this.restElements = [];
    }
    Identifier(pattern) {
      const lastRestElement = (xs = this.restElements)[xs.length - 1] || null;
      var xs;
      this.callback(pattern, {
        topLevel: pattern === this.rootPattern,
        rest: null != lastRestElement && lastRestElement.argument === pattern,
        assignments: this.assignments
      });
    }
    Property(property) {
      property.computed && this.rightHandNodes.push(property.key), this.visit(property.value);
    }
    ArrayPattern(pattern) {
      for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
        const element = pattern.elements[i];
        this.visit(element);
      }
    }
    AssignmentPattern(pattern) {
      this.assignments.push(pattern), this.visit(pattern.left), this.rightHandNodes.push(pattern.right), 
      this.assignments.pop();
    }
    RestElement(pattern) {
      this.restElements.push(pattern), this.visit(pattern.argument), this.restElements.pop();
    }
    MemberExpression(node) {
      node.computed && this.rightHandNodes.push(node.property), this.rightHandNodes.push(node.object);
    }
    SpreadElement(node) {
      this.visit(node.argument);
    }
    ArrayExpression(node) {
      node.elements.forEach(this.visit, this);
    }
    AssignmentExpression(node) {
      this.assignments.push(node), this.visit(node.left), this.rightHandNodes.push(node.right), 
      this.assignments.pop();
    }
    CallExpression(node) {
      node.arguments.forEach(a => {
        this.rightHandNodes.push(a);
      }), this.visit(node.callee);
    }
  }
  module.exports = PatternVisitor;
}, function(module) {
  module.exports = JSON.parse('{"name":"eslint-scope","version":"4.0.3"}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const similarity = (a, b) => {
    const l = Math.min(a.length, b.length);
    let dist = 0;
    for (let i = 0; i < l; i++) {
      const ca = a.charCodeAt(i), cb = b.charCodeAt(i);
      dist += Math.max(0, 10 - Math.abs(ca - cb));
    }
    return dist;
  }, getName = (a, b) => {
    const l = Math.min(a.length, b.length);
    let r = "";
    for (let i = 0; i < l; i++) {
      const ca = a.charAt(i);
      if (r += ca, ca !== b.charAt(i)) return r;
    }
    return a;
  };
  class Node {
    constructor(item, key, size) {
      this.item = item, this.key = key, this.size = size;
    }
  }
  class Group {
    constructor(nodes, similarities) {
      this.nodes = nodes, this.similarities = similarities, this.size = nodes.reduce((size, node) => size + node.size, 0), 
      this.key = void 0;
    }
  }
  module.exports = ({maxSize: maxSize, minSize: minSize, items: items, getSize: getSize, getKey: getKey}) => {
    const result = [], nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item))), initialNodes = [];
    nodes.sort((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0);
    for (const node of nodes) node.size >= maxSize ? result.push(new Group([ node ], [])) : initialNodes.push(node);
    if (initialNodes.length > 0) {
      const similarities = [];
      for (let i = 1; i < initialNodes.length; i++) {
        const a = initialNodes[i - 1], b = initialNodes[i];
        similarities.push(similarity(a.key, b.key));
      }
      const initialGroup = new Group(initialNodes, similarities);
      if (initialGroup.size < minSize) if (result.length > 0) {
        const smallestGroup = result.reduce((min, group) => min.size > group.size ? group : min);
        for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);
        smallestGroup.nodes.sort((a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0);
      } else result.push(initialGroup); else {
        const queue = [ initialGroup ];
        for (;queue.length; ) {
          const group = queue.pop();
          if (group.size < maxSize) {
            result.push(group);
            continue;
          }
          let left = 0, leftSize = 0;
          for (;leftSize <= minSize; ) leftSize += group.nodes[left].size, left++;
          let right = group.nodes.length - 1, rightSize = 0;
          for (;rightSize <= minSize; ) rightSize += group.nodes[right].size, right--;
          if (left - 1 > right) {
            result.push(group);
            continue;
          }
          if (left <= right) {
            let best = left - 1, bestSimilarity = group.similarities[best];
            for (let i = left; i <= right; i++) {
              const similarity = group.similarities[i];
              similarity < bestSimilarity && (best = i, bestSimilarity = similarity);
            }
            left = best + 1, right = best;
          }
          const rightNodes = [ group.nodes[right + 1] ], rightSimilaries = [];
          for (let i = right + 2; i < group.nodes.length; i++) rightSimilaries.push(group.similarities[i - 1]), 
          rightNodes.push(group.nodes[i]);
          queue.push(new Group(rightNodes, rightSimilaries));
          const leftNodes = [ group.nodes[0] ], leftSimilaries = [];
          for (let i = 1; i < left; i++) leftSimilaries.push(group.similarities[i - 1]), leftNodes.push(group.nodes[i]);
          queue.push(new Group(leftNodes, leftSimilaries));
        }
      }
    }
    result.sort((a, b) => a.nodes[0].key < b.nodes[0].key ? -1 : a.nodes[0].key > b.nodes[0].key ? 1 : 0);
    for (let i = 0; i < result.length; i++) {
      const group = result[i], first = group.nodes[0], last = group.nodes[group.nodes.length - 1];
      let name = getName(first.key, last.key);
      group.key = name;
    }
    return result.map(group => ({
      key: group.key,
      items: group.nodes.map(node => node.item),
      size: group.size
    }));
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), SizeFormatHelpers = __webpack_require__(38);
  module.exports = class extends WebpackError {
    constructor(keys, minSize, maxSize) {
      let keysMessage = "Fallback cache group";
      keys && (keysMessage = keys.length > 1 ? "Cache groups " + keys.sort().join(", ") : "Cache group " + keys[0]), 
      super("SplitChunksPlugin\n" + keysMessage + "\n" + `Configured minSize (${SizeFormatHelpers.formatSize(minSize)}) is ` + `bigger than maxSize (${SizeFormatHelpers.formatSize(maxSize)}).\nThis seem to be a invalid optimiziation.splitChunks configuration.`);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const UnsupportedWebAssemblyFeatureError = __webpack_require__(117);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("WasmFinalizeExportsPlugin", compilation => {
        compilation.hooks.finishModules.tap("WasmFinalizeExportsPlugin", modules => {
          for (const module of modules) if (!0 === module.type.startsWith("webassembly")) {
            const jsIncompatibleExports = module.buildMeta.jsIncompatibleExports;
            if (void 0 === jsIncompatibleExports) continue;
            for (const reason of module.reasons) if (!1 === reason.module.type.startsWith("webassembly")) {
              const ref = compilation.getDependencyReference(reason.module, reason.dependency);
              if (!ref) continue;
              const importedNames = ref.importedNames;
              Array.isArray(importedNames) && importedNames.forEach(name => {
                if (Object.prototype.hasOwnProperty.call(jsIncompatibleExports, name)) {
                  const error = new UnsupportedWebAssemblyFeatureError(`Export "${name}" with ${jsIncompatibleExports[name]} can only be used for direct wasm to wasm dependencies`);
                  error.module = module, error.origin = reason.module, error.originLoc = reason.dependency.loc, 
                  error.dependencies = [ reason.dependency ], compilation.errors.push(error);
                }
              });
            }
          }
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"HashedModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"The context directory for creating names.","type":"string","absolutePath":true},"hashDigest":{"description":"The encoding to use when generating the hash, defaults to \'base64\'. All encodings from Node.JS\' hash.digest are supported.","enum":["hex","latin1","base64"]},"hashDigestLength":{"description":"The prefix length of the hash digest to use, defaults to 4.","type":"number","minimum":1},"hashFunction":{"description":"The hashing algorithm to use, defaults to \'md5\'. All functions from Node.JS\' crypto.createHash are supported.","type":"string","minLength":1}}}');
}, function(module) {
  module.exports = JSON.parse('{"title":"OccurrenceOrderModuleIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size","type":"boolean"}}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("NaturalChunkOrderPlugin", compilation => {
        compilation.hooks.optimizeChunkOrder.tap("NaturalChunkOrderPlugin", chunks => {
          chunks.sort((chunkA, chunkB) => {
            const a = chunkA.modulesIterable[Symbol.iterator](), b = chunkB.modulesIterable[Symbol.iterator]();
            for (;;) {
              const aItem = a.next(), bItem = b.next();
              if (aItem.done && bItem.done) return 0;
              if (aItem.done) return -1;
              if (bItem.done) return 1;
              const aModuleId = aItem.value.id, bModuleId = bItem.value.id;
              if (aModuleId < bModuleId) return -1;
              if (aModuleId > bModuleId) return 1;
            }
          });
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"OccurrenceOrderChunkIdsPluginOptions","type":"object","additionalProperties":false,"properties":{"prioritiseInitial":{"description":"Prioritise initial size over total size","type":"boolean"}}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const EntrypointsOverSizeLimitWarning = __webpack_require__(371), AssetsOverSizeLimitWarning = __webpack_require__(372), NoAsyncChunksWarning = __webpack_require__(373);
  module.exports = class {
    constructor(options) {
      this.hints = options.hints, this.maxAssetSize = options.maxAssetSize, this.maxEntrypointSize = options.maxEntrypointSize, 
      this.assetFilter = options.assetFilter;
    }
    apply(compiler) {
      const entrypointSizeLimit = this.maxEntrypointSize, assetSizeLimit = this.maxAssetSize, hints = this.hints, assetFilter = this.assetFilter || ((name, source, info) => !info.development);
      compiler.hooks.afterEmit.tap("SizeLimitsPlugin", compilation => {
        const warnings = [], assetsOverSizeLimit = [];
        for (const {name: name, source: source, info: info} of compilation.getAssets()) {
          if (!assetFilter(name, source, info) || !source) continue;
          const size = info.size || source.size();
          size > assetSizeLimit && (assetsOverSizeLimit.push({
            name: name,
            size: size
          }), source.isOverSizeLimit = !0);
        }
        const fileFilter = name => {
          const asset = compilation.getAsset(name);
          return asset && assetFilter(asset.name, asset.source, asset.info);
        }, entrypointsOverLimit = [];
        for (const [name, entry] of compilation.entrypoints) {
          const size = entry.getFiles().reduce((currentSize, file) => {
            const asset = compilation.getAsset(file);
            return asset && assetFilter(asset.name, asset.source, asset.info) && asset.source ? currentSize + (asset.info.size || asset.source.size()) : currentSize;
          }, 0);
          size > entrypointSizeLimit && (entrypointsOverLimit.push({
            name: name,
            size: size,
            files: entry.getFiles().filter(fileFilter)
          }), entry.isOverSizeLimit = !0);
        }
        if (hints && (assetsOverSizeLimit.length > 0 && warnings.push(new AssetsOverSizeLimitWarning(assetsOverSizeLimit, assetSizeLimit)), 
        entrypointsOverLimit.length > 0 && warnings.push(new EntrypointsOverSizeLimitWarning(entrypointsOverLimit, entrypointSizeLimit)), 
        warnings.length > 0)) {
          compilation.chunks.filter(chunk => !chunk.canBeInitial()).length > 0 || warnings.push(new NoAsyncChunksWarning), 
          "error" === hints ? compilation.errors.push(...warnings) : compilation.warnings.push(...warnings);
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), SizeFormatHelpers = __webpack_require__(38);
  module.exports = class extends WebpackError {
    constructor(entrypoints, entrypointLimit) {
      const entrypointList = entrypoints.map(entrypoint => `\n  ${entrypoint.name} (${SizeFormatHelpers.formatSize(entrypoint.size)})\n${entrypoint.files.map(asset => "      " + asset).join("\n")}`).join("");
      super(`entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (${SizeFormatHelpers.formatSize(entrypointLimit)}). This can impact web performance.\nEntrypoints:${entrypointList}\n`), 
      this.name = "EntrypointsOverSizeLimitWarning", this.entrypoints = entrypoints, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), SizeFormatHelpers = __webpack_require__(38);
  module.exports = class extends WebpackError {
    constructor(assetsOverSizeLimit, assetLimit) {
      const assetLists = assetsOverSizeLimit.map(asset => `\n  ${asset.name} (${SizeFormatHelpers.formatSize(asset.size)})`).join("");
      super(`asset size limit: The following asset(s) exceed the recommended size limit (${SizeFormatHelpers.formatSize(assetLimit)}).\nThis can impact web performance.\nAssets: ${assetLists}`), 
      this.name = "AssetsOverSizeLimitWarning", this.assets = assetsOverSizeLimit, Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor() {
      super("webpack performance recommendations: \nYou can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/"), 
      this.name = "NoAsyncChunksWarning", Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), OptionsDefaulter = __webpack_require__(375), Template = __webpack_require__(2), isProductionLikeMode = options => "production" === options.mode || !options.mode, getDevtoolNamespace = library => Array.isArray(library) ? library.join(".") : "object" == typeof library ? getDevtoolNamespace(library.root) : library || "";
  module.exports = class extends OptionsDefaulter {
    constructor() {
      super(), this.set("entry", "./src"), this.set("devtool", "make", options => "development" === options.mode && "eval"), 
      this.set("cache", "make", options => "development" === options.mode), this.set("context", process.cwd()), 
      this.set("target", "web"), this.set("module", "call", value => Object.assign({}, value)), 
      this.set("module.unknownContextRequest", "."), this.set("module.unknownContextRegExp", !1), 
      this.set("module.unknownContextRecursive", !0), this.set("module.unknownContextCritical", !0), 
      this.set("module.exprContextRequest", "."), this.set("module.exprContextRegExp", !1), 
      this.set("module.exprContextRecursive", !0), this.set("module.exprContextCritical", !0), 
      this.set("module.wrappedContextRegExp", /.*/), this.set("module.wrappedContextRecursive", !0), 
      this.set("module.wrappedContextCritical", !1), this.set("module.strictExportPresence", !1), 
      this.set("module.strictThisContextOnImports", !1), this.set("module.unsafeCache", "make", options => !!options.cache), 
      this.set("module.rules", []), this.set("module.defaultRules", "make", options => [ {
        type: "javascript/auto",
        resolve: {}
      }, {
        test: /\.mjs$/i,
        type: "javascript/esm",
        resolve: {
          mainFields: "web" === options.target || "webworker" === options.target || "electron-renderer" === options.target ? [ "browser", "main" ] : [ "main" ]
        }
      }, {
        test: /\.json$/i,
        type: "json"
      }, {
        test: /\.wasm$/i,
        type: "webassembly/experimental"
      } ]), this.set("output", "call", (value, options) => "string" == typeof value ? {
        filename: value
      } : "object" != typeof value ? {} : Object.assign({}, value)), this.set("output.filename", "[name].js"), 
      this.set("output.chunkFilename", "make", options => {
        const filename = options.output.filename;
        if ("function" != typeof filename) {
          const hasName = filename.includes("[name]"), hasId = filename.includes("[id]");
          return filename.includes("[chunkhash]") || hasName || hasId ? filename : filename.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
        }
        return "[id].js";
      }), this.set("output.webassemblyModuleFilename", "[modulehash].module.wasm"), this.set("output.library", ""), 
      this.set("output.hotUpdateFunction", "make", options => Template.toIdentifier("webpackHotUpdate" + Template.toIdentifier(options.output.library))), 
      this.set("output.jsonpFunction", "make", options => Template.toIdentifier("webpackJsonp" + Template.toIdentifier(options.output.library))), 
      this.set("output.chunkCallbackName", "make", options => Template.toIdentifier("webpackChunk" + Template.toIdentifier(options.output.library))), 
      this.set("output.globalObject", "make", options => {
        switch (options.target) {
         case "web":
         case "electron-renderer":
         case "node-webkit":
          return "window";

         case "webworker":
          return "self";

         case "node":
         case "async-node":
         case "electron-main":
          return "global";

         default:
          return "self";
        }
      }), this.set("output.devtoolNamespace", "make", options => getDevtoolNamespace(options.output.library)), 
      this.set("output.libraryTarget", "var"), this.set("output.path", path.join(process.cwd(), "dist")), 
      this.set("output.pathinfo", "make", options => "development" === options.mode), 
      this.set("output.sourceMapFilename", "[file].map[query]"), this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js"), 
      this.set("output.hotUpdateMainFilename", "[hash].hot-update.json"), this.set("output.crossOriginLoading", !1), 
      this.set("output.jsonpScriptType", !1), this.set("output.chunkLoadTimeout", 12e4), 
      this.set("output.hashFunction", "md4"), this.set("output.hashDigest", "hex"), this.set("output.hashDigestLength", 20), 
      this.set("output.devtoolLineToLine", !1), this.set("output.strictModuleExceptionHandling", !1), 
      this.set("node", "call", value => "boolean" == typeof value ? value : Object.assign({}, value)), 
      this.set("node.console", !1), this.set("node.process", !0), this.set("node.global", !0), 
      this.set("node.Buffer", !0), this.set("node.setImmediate", !0), this.set("node.__filename", "mock"), 
      this.set("node.__dirname", "mock"), this.set("performance", "call", (value, options) => !1 !== value && (!!(void 0 !== value || isProductionLikeMode(options) && (options => "web" === options.target || "webworker" === options.target)(options)) && Object.assign({}, value))), 
      this.set("performance.maxAssetSize", 25e4), this.set("performance.maxEntrypointSize", 25e4), 
      this.set("performance.hints", "make", options => !!isProductionLikeMode(options) && "warning"), 
      this.set("optimization", "call", value => Object.assign({}, value)), this.set("optimization.removeAvailableModules", "make", options => "development" !== options.mode), 
      this.set("optimization.removeEmptyChunks", !0), this.set("optimization.mergeDuplicateChunks", !0), 
      this.set("optimization.flagIncludedChunks", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.occurrenceOrder", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.sideEffects", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.providedExports", !0), this.set("optimization.usedExports", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.concatenateModules", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.splitChunks", {}), this.set("optimization.splitChunks.hidePathInfo", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.splitChunks.chunks", "async"), this.set("optimization.splitChunks.minSize", "make", options => isProductionLikeMode(options) ? 3e4 : 1e4), 
      this.set("optimization.splitChunks.minChunks", 1), this.set("optimization.splitChunks.maxAsyncRequests", "make", options => isProductionLikeMode(options) ? 5 : 1 / 0), 
      this.set("optimization.splitChunks.automaticNameDelimiter", "~"), this.set("optimization.splitChunks.automaticNameMaxLength", 109), 
      this.set("optimization.splitChunks.maxInitialRequests", "make", options => isProductionLikeMode(options) ? 3 : 1 / 0), 
      this.set("optimization.splitChunks.name", !0), this.set("optimization.splitChunks.cacheGroups", {}), 
      this.set("optimization.splitChunks.cacheGroups.default", {
        automaticNamePrefix: "",
        reuseExistingChunk: !0,
        minChunks: 2,
        priority: -20
      }), this.set("optimization.splitChunks.cacheGroups.vendors", {
        automaticNamePrefix: "vendors",
        test: /[\\/]node_modules[\\/]/,
        priority: -10
      }), this.set("optimization.runtimeChunk", "call", value => "single" === value ? {
        name: "runtime"
      } : !0 === value || "multiple" === value ? {
        name: entrypoint => "runtime~" + entrypoint.name
      } : value), this.set("optimization.noEmitOnErrors", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.checkWasmTypes", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.mangleWasmImports", !1), this.set("optimization.namedModules", "make", options => "development" === options.mode), 
      this.set("optimization.hashedModuleIds", !1), this.set("optimization.namedChunks", "make", options => "development" === options.mode), 
      this.set("optimization.portableRecords", "make", options => !!(options.recordsInputPath || options.recordsOutputPath || options.recordsPath)), 
      this.set("optimization.minimize", "make", options => isProductionLikeMode(options)), 
      this.set("optimization.minimizer", "make", options => [ {
        apply: compiler => {
          const TerserPlugin = __webpack_require__(176), SourceMapDevToolPlugin = __webpack_require__(72);
          new TerserPlugin({
            cache: !0,
            parallel: !0,
            sourceMap: options.devtool && /source-?map/.test(options.devtool) || options.plugins && options.plugins.some(p => p instanceof SourceMapDevToolPlugin)
          }).apply(compiler);
        }
      } ]), this.set("optimization.nodeEnv", "make", options => options.mode || "production"), 
      this.set("resolve", "call", value => Object.assign({}, value)), this.set("resolve.unsafeCache", !0), 
      this.set("resolve.modules", [ "node_modules" ]), this.set("resolve.extensions", [ ".wasm", ".mjs", ".js", ".json" ]), 
      this.set("resolve.mainFiles", [ "index" ]), this.set("resolve.aliasFields", "make", options => "web" === options.target || "webworker" === options.target || "electron-renderer" === options.target ? [ "browser" ] : []), 
      this.set("resolve.mainFields", "make", options => "web" === options.target || "webworker" === options.target || "electron-renderer" === options.target ? [ "browser", "module", "main" ] : [ "module", "main" ]), 
      this.set("resolve.cacheWithContext", "make", options => Array.isArray(options.resolve.plugins) && options.resolve.plugins.length > 0), 
      this.set("resolve.preferAbsolute", "make", options => !options.resolve.roots || 0 === options.resolve.roots.length), 
      this.set("resolve.ignoreRootsErrors", "make", options => !options.resolve.roots || 0 === options.resolve.roots.length), 
      this.set("resolve.roots", "make", options => [ options.context ]), this.set("resolveLoader", "call", value => Object.assign({}, value)), 
      this.set("resolveLoader.unsafeCache", !0), this.set("resolveLoader.mainFields", [ "loader", "main" ]), 
      this.set("resolveLoader.extensions", [ ".js", ".json" ]), this.set("resolveLoader.mainFiles", [ "index" ]), 
      this.set("resolveLoader.cacheWithContext", "make", options => Array.isArray(options.resolveLoader.plugins) && options.resolveLoader.plugins.length > 0), 
      this.set("infrastructureLogging", "call", value => Object.assign({}, value)), this.set("infrastructureLogging.level", "info"), 
      this.set("infrastructureLogging.debug", !1);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const getProperty = (obj, path) => {
    let name = path.split(".");
    for (let i = 0; i < name.length - 1; i++) if ("object" != typeof (obj = obj[name[i]]) || !obj || Array.isArray(obj)) return;
    return obj[name.pop()];
  }, setProperty = (obj, path, value) => {
    let name = path.split(".");
    for (let i = 0; i < name.length - 1; i++) {
      if ("object" != typeof obj[name[i]] && void 0 !== obj[name[i]]) return;
      if (Array.isArray(obj[name[i]])) return;
      obj[name[i]] || (obj[name[i]] = {}), obj = obj[name[i]];
    }
    obj[name.pop()] = value;
  };
  module.exports = class {
    constructor() {
      this.defaults = {}, this.config = {};
    }
    process(options) {
      options = Object.assign({}, options);
      for (let name in this.defaults) switch (this.config[name]) {
       case void 0:
        void 0 === getProperty(options, name) && setProperty(options, name, this.defaults[name]);
        break;

       case "call":
        setProperty(options, name, this.defaults[name].call(this, getProperty(options, name), options));
        break;

       case "make":
        void 0 === getProperty(options, name) && setProperty(options, name, this.defaults[name].call(this, options));
        break;

       case "append":
        {
          let oldValue = getProperty(options, name);
          Array.isArray(oldValue) || (oldValue = []), oldValue.push(...this.defaults[name]), 
          setProperty(options, name, oldValue);
          break;
        }

       default:
        throw new Error("OptionsDefaulter cannot process " + this.config[name]);
      }
      return options;
    }
    set(name, config, def) {
      void 0 !== def ? (this.defaults[name] = def, this.config[name] = config) : (this.defaults[name] = config, 
      delete this.config[name]);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ajv = new (__webpack_require__(377))({
    errorDataPath: "configuration",
    allErrors: !0,
    verbose: !0
  });
  __webpack_require__(378)(ajv, [ "instanceof" ]), __webpack_require__(401)(ajv);
  const validateObject = (schema, options) => {
    const validate = ajv.compile(schema);
    return validate(options) ? [] : filterErrors(validate.errors);
  }, filterErrors = errors => {
    let newErrors = [];
    for (const err of errors) {
      const dataPath = err.dataPath;
      let children = [];
      newErrors = newErrors.filter(oldError => !oldError.dataPath.includes(dataPath) || (oldError.children && (children = children.concat(oldError.children.slice(0))), 
      oldError.children = void 0, children.push(oldError), !1)), children.length && (err.children = children), 
      newErrors.push(err);
    }
    return newErrors;
  };
  module.exports = (schema, options) => {
    if (Array.isArray(options)) {
      const errors = options.map(options => validateObject(schema, options));
      return errors.forEach((list, idx) => {
        const applyPrefix = err => {
          err.dataPath = `[${idx}]${err.dataPath}`, err.children && err.children.forEach(applyPrefix);
        };
        list.forEach(applyPrefix);
      }), errors.reduce((arr, items) => arr.concat(items), []);
    }
    return validateObject(schema, options);
  };
}, function(module, exports) {
  module.exports = require("../vendor/ajv");
}, function(module, exports, __webpack_require__) {
  "use strict";
  var KEYWORDS = __webpack_require__(379);
  function defineKeywords(ajv, keyword) {
    if (Array.isArray(keyword)) {
      for (var i = 0; i < keyword.length; i++) get(keyword[i])(ajv);
      return ajv;
    }
    if (keyword) return get(keyword)(ajv), ajv;
    for (keyword in KEYWORDS) get(keyword)(ajv);
    return ajv;
  }
  function get(keyword) {
    var defFunc = KEYWORDS[keyword];
    if (!defFunc) throw new Error("Unknown keyword " + keyword);
    return defFunc;
  }
  module.exports = defineKeywords, defineKeywords.get = get;
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = {
    instanceof: __webpack_require__(380),
    range: __webpack_require__(381),
    regexp: __webpack_require__(382),
    typeof: __webpack_require__(383),
    dynamicDefaults: __webpack_require__(384),
    allRequired: __webpack_require__(385),
    anyRequired: __webpack_require__(386),
    oneRequired: __webpack_require__(387),
    prohibited: __webpack_require__(388),
    uniqueItemProperties: __webpack_require__(389),
    deepProperties: __webpack_require__(390),
    deepRequired: __webpack_require__(391),
    formatMinimum: __webpack_require__(392),
    formatMaximum: __webpack_require__(394),
    patternRequired: __webpack_require__(395),
    switch: __webpack_require__(397),
    select: __webpack_require__(399),
    transform: __webpack_require__(400)
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var CONSTRUCTORS = {
    Object: Object,
    Array: Array,
    Function: Function,
    Number: Number,
    String: String,
    Date: Date,
    RegExp: RegExp
  };
  module.exports = function defFunc(ajv) {
    return "undefined" != typeof Buffer && (CONSTRUCTORS.Buffer = Buffer), "undefined" != typeof Promise && (CONSTRUCTORS.Promise = Promise), 
    defFunc.definition = {
      compile: function(schema) {
        if ("string" == typeof schema) {
          var Constructor = getConstructor(schema);
          return function(data) {
            return data instanceof Constructor;
          };
        }
        var constructors = schema.map(getConstructor);
        return function(data) {
          for (var i = 0; i < constructors.length; i++) if (data instanceof constructors[i]) return !0;
          return !1;
        };
      },
      CONSTRUCTORS: CONSTRUCTORS,
      metaSchema: {
        anyOf: [ {
          type: "string"
        }, {
          type: "array",
          items: {
            type: "string"
          }
        } ]
      }
    }, ajv.addKeyword("instanceof", defFunc.definition), ajv;
    function getConstructor(c) {
      var Constructor = CONSTRUCTORS[c];
      if (Constructor) return Constructor;
      throw new Error('invalid "instanceof" keyword value ' + c);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "number",
      macro: function(schema, parentSchema) {
        var min = schema[0], max = schema[1], exclusive = parentSchema.exclusiveRange;
        return function(min, max, exclusive) {
          if (void 0 !== exclusive && "boolean" != typeof exclusive) throw new Error("Invalid schema for exclusiveRange keyword, should be boolean");
          if (min > max || exclusive && min == max) throw new Error("There are no numbers in range");
        }(min, max, exclusive), !0 === exclusive ? {
          exclusiveMinimum: min,
          exclusiveMaximum: max
        } : {
          minimum: min,
          maximum: max
        };
      },
      metaSchema: {
        type: "array",
        minItems: 2,
        maxItems: 2,
        items: {
          type: "number"
        }
      }
    }, ajv.addKeyword("range", defFunc.definition), ajv.addKeyword("exclusiveRange"), 
    ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "string",
      inline: function(it, keyword, schema) {
        return function() {
          try {
            if ("object" == typeof schema) return new RegExp(schema.pattern, schema.flags);
            var rx = schema.match(/^\/(.*)\/([gimuy]*)$/);
            if (rx) return new RegExp(rx[1], rx[2]);
            throw new Error("cannot parse string into RegExp");
          } catch (e) {
            throw console.error("regular expression", schema, "is invalid"), e;
          }
        }() + ".test(data" + (it.dataLevel || "") + ")";
      },
      metaSchema: {
        type: [ "string", "object" ],
        properties: {
          pattern: {
            type: "string"
          },
          flags: {
            type: "string"
          }
        },
        required: [ "pattern" ],
        additionalProperties: !1
      }
    }, ajv.addKeyword("regexp", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var KNOWN_TYPES = [ "undefined", "string", "number", "object", "function", "boolean", "symbol" ];
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      inline: function(it, keyword, schema) {
        var data = "data" + (it.dataLevel || "");
        return "string" == typeof schema ? "typeof " + data + ' == "' + schema + '"' : (schema = "validate.schema" + it.schemaPath + "." + keyword) + ".indexOf(typeof " + data + ") >= 0";
      },
      metaSchema: {
        anyOf: [ {
          type: "string",
          enum: KNOWN_TYPES
        }, {
          type: "array",
          items: {
            type: "string",
            enum: KNOWN_TYPES
          }
        } ]
      }
    }, ajv.addKeyword("typeof", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var sequences = {}, DEFAULTS = {
    timestamp: function() {
      return Date.now();
    },
    datetime: function() {
      return (new Date).toISOString();
    },
    date: function() {
      return (new Date).toISOString().slice(0, 10);
    },
    time: function() {
      return (new Date).toISOString().slice(11);
    },
    random: function() {
      return Math.random();
    },
    randomint: function(args) {
      var limit = args && args.max || 2;
      return function() {
        return Math.floor(Math.random() * limit);
      };
    },
    seq: function(args) {
      var name = args && args.name || "";
      return sequences[name] = sequences[name] || 0, function() {
        return sequences[name]++;
      };
    }
  };
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      compile: function(schema, parentSchema, it) {
        var funcs = {};
        for (var key in schema) {
          var d = schema[key], func = getDefault("string" == typeof d ? d : d.func);
          funcs[key] = func.length ? func(d.args) : func;
        }
        return it.opts.useDefaults && !it.compositeRule ? function(data) {
          for (var prop in schema) void 0 !== data[prop] && ("empty" != it.opts.useDefaults || null !== data[prop] && "" !== data[prop]) || (data[prop] = funcs[prop]());
          return !0;
        } : function() {
          return !0;
        };
      },
      DEFAULTS: DEFAULTS,
      metaSchema: {
        type: "object",
        additionalProperties: {
          type: [ "string", "object" ],
          additionalProperties: !1,
          required: [ "func", "args" ],
          properties: {
            func: {
              type: "string"
            },
            args: {
              type: "object"
            }
          }
        }
      }
    }, ajv.addKeyword("dynamicDefaults", defFunc.definition), ajv;
    function getDefault(d) {
      var def = DEFAULTS[d];
      if (def) return def;
      throw new Error('invalid "dynamicDefaults" keyword property value: ' + d);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      macro: function(schema, parentSchema) {
        if (!schema) return !0;
        var properties = Object.keys(parentSchema.properties);
        return 0 == properties.length || {
          required: properties
        };
      },
      metaSchema: {
        type: "boolean"
      },
      dependencies: [ "properties" ]
    }, ajv.addKeyword("allRequired", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      macro: function(schema) {
        return 0 == schema.length || (1 == schema.length ? {
          required: schema
        } : {
          anyOf: schema.map((function(prop) {
            return {
              required: [ prop ]
            };
          }))
        });
      },
      metaSchema: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }, ajv.addKeyword("anyRequired", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      macro: function(schema) {
        return 0 == schema.length || (1 == schema.length ? {
          required: schema
        } : {
          oneOf: schema.map((function(prop) {
            return {
              required: [ prop ]
            };
          }))
        });
      },
      metaSchema: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }, ajv.addKeyword("oneRequired", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      macro: function(schema) {
        return 0 == schema.length || (1 == schema.length ? {
          not: {
            required: schema
          }
        } : {
          not: {
            anyOf: schema.map((function(prop) {
              return {
                required: [ prop ]
              };
            }))
          }
        });
      },
      metaSchema: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }, ajv.addKeyword("prohibited", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var SCALAR_TYPES = [ "number", "integer", "string", "boolean", "null" ];
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "array",
      compile: function(keys, parentSchema, it) {
        var equal = it.util.equal, scalar = function(keys, schema) {
          return keys.map((function(key) {
            var properties = schema.items && schema.items.properties, propType = properties && properties[key] && properties[key].type;
            return Array.isArray(propType) ? propType.indexOf("object") < 0 && propType.indexOf("array") < 0 : SCALAR_TYPES.indexOf(propType) >= 0;
          }));
        }(keys, parentSchema);
        return function(data) {
          if (data.length > 1) for (var k = 0; k < keys.length; k++) {
            var i, key = keys[k];
            if (scalar[k]) {
              var hash = {};
              for (i = data.length; i--; ) if (data[i] && "object" == typeof data[i]) {
                var prop = data[i][key];
                if (!prop || "object" != typeof prop) {
                  if ("string" == typeof prop && (prop = '"' + prop), hash[prop]) return !1;
                  hash[prop] = !0;
                }
              }
            } else for (i = data.length; i--; ) if (data[i] && "object" == typeof data[i]) for (var j = i; j--; ) if (data[j] && "object" == typeof data[j] && equal(data[i][key], data[j][key])) return !1;
          }
          return !0;
        };
      },
      metaSchema: {
        type: "array",
        items: {
          type: "string"
        }
      }
    }, ajv.addKeyword("uniqueItemProperties", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var util = __webpack_require__(89);
  function getSchema(jsonPointer, schema) {
    for (var segments = jsonPointer.split("/"), rootSchema = {}, pointerSchema = rootSchema, i = 1; i < segments.length; i++) {
      var segment = segments[i], isLast = i == segments.length - 1;
      segment = segment.replace(/~1/g, "/").replace(/~0/g, "~");
      var properties = pointerSchema.properties = {}, items = void 0;
      if (/[0-9]+/.test(segment)) {
        var count = +segment;
        for (items = pointerSchema.items = []; count--; ) items.push({});
      }
      pointerSchema = isLast ? schema : {}, properties[segment] = pointerSchema, items && items.push(pointerSchema);
    }
    return rootSchema;
  }
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      macro: function(schema) {
        var schemas = [];
        for (var pointer in schema) schemas.push(getSchema(pointer, schema[pointer]));
        return {
          allOf: schemas
        };
      },
      metaSchema: {
        type: "object",
        propertyNames: {
          type: "string",
          format: "json-pointer"
        },
        additionalProperties: util.metaSchemaRef(ajv)
      }
    }, ajv.addKeyword("deepProperties", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  function getData(jsonPointer, lvl) {
    var data = "data" + (lvl || "");
    if (!jsonPointer) return data;
    for (var key, expr = data, segments = jsonPointer.split("/"), i = 1; i < segments.length; i++) {
      var segment = segments[i];
      expr += " && " + (data += (key = segment.replace(/~1/g, "/").replace(/~0/g, "~"), 
      INTEGER.test(key) ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + key.replace(SINGLE_QUOTE, "\\$&") + "']"));
    }
    return expr;
  }
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      inline: function(it, keyword, schema) {
        for (var expr = "", i = 0; i < schema.length; i++) i && (expr += " && "), expr += "(" + getData(schema[i], it.dataLevel) + " !== undefined)";
        return expr;
      },
      metaSchema: {
        type: "array",
        items: {
          type: "string",
          format: "json-pointer"
        }
      }
    }, ajv.addKeyword("deepRequired", defFunc.definition), ajv;
  };
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i, INTEGER = /^[0-9]+$/, SINGLE_QUOTE = /'|\\/g;
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = __webpack_require__(177)("Minimum");
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(it, $keyword, $ruleType) {
    var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl;
    if (out += "var " + $valid + " = undefined;", !1 === it.opts.format) return out += " " + $valid + " = true; ";
    var $schemaFormat = it.schema.format, $isDataFormat = it.opts.$data && $schemaFormat.$data, $closingBraces = "";
    if ($isDataFormat) {
      out += " var " + ($format = "format" + $lvl) + " = formats[" + it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr) + "] , " + ($compare = "compare" + $lvl) + " = " + $format + " && " + $format + ".compare;";
    } else {
      var $format;
      if (!($format = it.formats[$schemaFormat]) || !$format.compare) return out += "  " + $valid + " = true; ";
      var $compare = "formats" + it.util.getProperty($schemaFormat) + ".compare";
    }
    var $schemaValue, $isMax = "formatMaximum" == $keyword, $exclusiveKeyword = "formatExclusive" + ($isMax ? "Maximum" : "Minimum"), $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $result = "result" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
    if ($isData ? (out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ", 
    $schemaValue = "schema" + $lvl) : $schemaValue = $schema, $isDataExcl) {
      var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $opStr = "' + " + ($opExpr = "op" + $lvl) + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ", out += " if (typeof " + ($schemaValueExcl = "schemaExcl" + $lvl) + " != 'boolean' && " + $schemaValueExcl + " !== undefined) { " + $valid + " = false; ";
      var $errorKeyword = $exclusiveKeyword;
      ($$outStack = $$outStack || []).push(out), out = "", !1 !== it.createErrors ? (out += " { keyword: '" + ($errorKeyword || "_formatExclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ", 
      !1 !== it.opts.messages && (out += " , message: '" + $exclusiveKeyword + " should be boolean' "), 
      it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), 
      out += " } ") : out += " {} ";
      var __err = out;
      out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", 
      out += " }  ", $breakOnError && ($closingBraces += "}", out += " else { "), $isData && (out += " if (" + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'string') " + $valid + " = false; else { ", 
      $closingBraces += "}"), $isDataFormat && (out += " if (!" + $compare + ") " + $valid + " = true; else { ", 
      $closingBraces += "}"), out += " var " + $result + " = " + $compare + "(" + $data + ",  ", 
      out += $isData ? "" + $schemaValue : "" + it.util.toQuotedString($schema), out += " ); if (" + $result + " === undefined) " + $valid + " = false; var " + $exclusive + " = " + $schemaValueExcl + " === true; if (" + $valid + " === undefined) { " + $valid + " = " + $exclusive + " ? " + $result + " " + $op + " 0 : " + $result + " " + $op + "= 0; } if (!" + $valid + ") var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "=';";
    } else {
      $opStr = $op;
      ($exclusive = !0 === $schemaExcl) || ($opStr += "=");
      var $opExpr = "'" + $opStr + "'";
      $isData && (out += " if (" + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'string') " + $valid + " = false; else { ", 
      $closingBraces += "}"), $isDataFormat && (out += " if (!" + $compare + ") " + $valid + " = true; else { ", 
      $closingBraces += "}"), out += " var " + $result + " = " + $compare + "(" + $data + ",  ", 
      out += $isData ? "" + $schemaValue : "" + it.util.toQuotedString($schema), out += " ); if (" + $result + " === undefined) " + $valid + " = false; if (" + $valid + " === undefined) " + $valid + " = " + $result + " " + $op, 
      $exclusive || (out += "="), out += " 0;";
    }
    out += $closingBraces + "if (!" + $valid + ") { ";
    var $$outStack;
    $errorKeyword = $keyword;
    ($$outStack = $$outStack || []).push(out), out = "", !1 !== it.createErrors ? (out += " { keyword: '" + ($errorKeyword || "_formatLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit:  ", 
    out += $isData ? "" + $schemaValue : "" + it.util.toQuotedString($schema), out += " , exclusive: " + $exclusive + " } ", 
    !1 !== it.opts.messages && (out += " , message: 'should be " + $opStr + ' "', out += $isData ? "' + " + $schemaValue + " + '" : "" + it.util.escapeQuotes($schema), 
    out += "\"' "), it.opts.verbose && (out += " , schema:  ", out += $isData ? "validate.schema" + $schemaPath : "" + it.util.toQuotedString($schema), 
    out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), 
    out += " } ") : out += " {} ";
    __err = out;
    return out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", 
    out += "}";
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = __webpack_require__(177)("Maximum");
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    return defFunc.definition = {
      type: "object",
      inline: __webpack_require__(396),
      statements: !0,
      errors: "full",
      metaSchema: {
        type: "array",
        items: {
          type: "string",
          format: "regex"
        },
        uniqueItems: !0
      }
    }, ajv.addKeyword("patternRequired", defFunc.definition), ajv;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(it, $keyword, $ruleType) {
    var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $key = "key" + $lvl, $idx = "idx" + $lvl, $matched = "patternMatched" + $lvl, $dataProperties = "dataProperties" + $lvl, $closingBraces = "", $ownProperties = it.opts.ownProperties;
    out += "var " + $valid + " = true;", $ownProperties && (out += " var " + $dataProperties + " = undefined;");
    var arr1 = $schema;
    if (arr1) for (var $pProperty, i1 = -1, l1 = arr1.length - 1; i1 < l1; ) {
      $pProperty = arr1[i1 += 1], out += " var " + $matched + " = false;  ", out += $ownProperties ? " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; " : " for (var " + $key + " in " + $data + ") { ", 
      out += " " + $matched + " = " + it.usePattern($pProperty) + ".test(" + $key + "); if (" + $matched + ") break; } ";
      var $missingPattern = it.util.escapeQuotes($pProperty);
      out += " if (!" + $matched + ") { " + $valid + " = false;  var err =   ", !1 !== it.createErrors ? (out += " { keyword: 'patternRequired' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingPattern: '" + $missingPattern + "' } ", 
      !1 !== it.opts.messages && (out += " , message: 'should have property matching pattern \\'" + $missingPattern + "\\'' "), 
      it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), 
      out += " } ") : out += " {} ", out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ", 
      $breakOnError && ($closingBraces += "}", out += " else { ");
    }
    return out += "" + $closingBraces;
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var util = __webpack_require__(89);
  module.exports = function defFunc(ajv) {
    if (!ajv.RULES.keywords.switch || !ajv.RULES.keywords.if) {
      var metaSchemaRef = util.metaSchemaRef(ajv);
      return defFunc.definition = {
        inline: __webpack_require__(398),
        statements: !0,
        errors: "full",
        metaSchema: {
          type: "array",
          items: {
            required: [ "then" ],
            properties: {
              if: metaSchemaRef,
              then: {
                anyOf: [ {
                  type: "boolean"
                }, metaSchemaRef ]
              },
              continue: {
                type: "boolean"
              }
            },
            additionalProperties: !1,
            dependencies: {
              continue: [ "if" ]
            }
          }
        }
      }, ajv.addKeyword("switch", defFunc.definition), ajv;
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function(it, $keyword, $ruleType) {
    var out = " ", $lvl = it.level, $dataLvl = it.dataLevel, $schema = it.schema[$keyword], $schemaPath = it.schemaPath + it.util.getProperty($keyword), $errSchemaPath = it.errSchemaPath + "/" + $keyword, $breakOnError = !it.opts.allErrors, $data = "data" + ($dataLvl || ""), $valid = "valid" + $lvl, $errs = "errs__" + $lvl, $it = it.util.copy(it), $closingBraces = "";
    $it.level++;
    var $shouldContinue, $nextValid = "valid" + $it.level, $ifPassed = "ifPassed" + it.level, $currentBaseId = $it.baseId;
    out += "var " + $ifPassed + ";";
    var arr1 = $schema;
    if (arr1) for (var $sch, $caseIndex = -1, l1 = arr1.length - 1; $caseIndex < l1; ) {
      if ($sch = arr1[$caseIndex += 1], $caseIndex && !$shouldContinue && (out += " if (!" + $ifPassed + ") { ", 
      $closingBraces += "}"), $sch.if && (it.opts.strictKeywords ? "object" == typeof $sch.if && Object.keys($sch.if).length > 0 : it.util.schemaHasRules($sch.if, it.RULES.all))) {
        out += " var " + $errs + " = errors;   ";
        var $wasComposite = it.compositeRule;
        if (it.compositeRule = $it.compositeRule = !0, $it.createErrors = !1, $it.schema = $sch.if, 
        $it.schemaPath = $schemaPath + "[" + $caseIndex + "].if", $it.errSchemaPath = $errSchemaPath + "/" + $caseIndex + "/if", 
        out += "  " + it.validate($it) + " ", $it.baseId = $currentBaseId, $it.createErrors = !0, 
        it.compositeRule = $it.compositeRule = $wasComposite, out += " " + $ifPassed + " = " + $nextValid + "; if (" + $ifPassed + ") {  ", 
        "boolean" == typeof $sch.then) {
          if (!1 === $sch.then) {
            ($$outStack = $$outStack || []).push(out), out = "", !1 !== it.createErrors ? (out += " { keyword: 'switch' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { caseIndex: " + $caseIndex + " } ", 
            !1 !== it.opts.messages && (out += " , message: 'should pass \"switch\" keyword validation' "), 
            it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), 
            out += " } ") : out += " {} ";
            var __err = out;
            out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " var " + $nextValid + " = " + $sch.then + "; ";
        } else $it.schema = $sch.then, $it.schemaPath = $schemaPath + "[" + $caseIndex + "].then", 
        $it.errSchemaPath = $errSchemaPath + "/" + $caseIndex + "/then", out += "  " + it.validate($it) + " ", 
        $it.baseId = $currentBaseId;
        out += "  } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } } ";
      } else if (out += " " + $ifPassed + " = true;  ", "boolean" == typeof $sch.then) {
        if (!1 === $sch.then) {
          var $$outStack;
          ($$outStack = $$outStack || []).push(out), out = "", !1 !== it.createErrors ? (out += " { keyword: 'switch' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { caseIndex: " + $caseIndex + " } ", 
          !1 !== it.opts.messages && (out += " , message: 'should pass \"switch\" keyword validation' "), 
          it.opts.verbose && (out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " "), 
          out += " } ") : out += " {} ";
          __err = out;
          out = $$outStack.pop(), !it.compositeRule && $breakOnError ? it.async ? out += " throw new ValidationError([" + __err + "]); " : out += " validate.errors = [" + __err + "]; return false; " : out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " var " + $nextValid + " = " + $sch.then + "; ";
      } else $it.schema = $sch.then, $it.schemaPath = $schemaPath + "[" + $caseIndex + "].then", 
      $it.errSchemaPath = $errSchemaPath + "/" + $caseIndex + "/then", out += "  " + it.validate($it) + " ", 
      $it.baseId = $currentBaseId;
      $shouldContinue = $sch.continue;
    }
    return out += $closingBraces + "var " + $valid + " = " + $nextValid + ";";
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  var util = __webpack_require__(89);
  module.exports = function defFunc(ajv) {
    if (!ajv._opts.$data) return console.warn("keyword select requires $data option"), 
    ajv;
    var metaSchemaRef = util.metaSchemaRef(ajv), compiledCaseSchemas = [];
    return defFunc.definition = {
      validate: function v(schema, data, parentSchema) {
        if (void 0 === parentSchema.selectCases) throw new Error('keyword "selectCases" is absent');
        var compiled = getCompiledSchemas(parentSchema, !1), validate = compiled.cases[schema];
        if (void 0 === validate && (validate = compiled.default), "boolean" == typeof validate) return validate;
        var valid = validate(data);
        return valid || (v.errors = validate.errors), valid;
      },
      $data: !0,
      metaSchema: {
        type: [ "string", "number", "boolean", "null" ]
      }
    }, ajv.addKeyword("select", defFunc.definition), ajv.addKeyword("selectCases", {
      compile: function(schemas, parentSchema) {
        var compiled = getCompiledSchemas(parentSchema);
        for (var value in schemas) compiled.cases[value] = compileOrBoolean(schemas[value]);
        return function() {
          return !0;
        };
      },
      valid: !0,
      metaSchema: {
        type: "object",
        additionalProperties: metaSchemaRef
      }
    }), ajv.addKeyword("selectDefault", {
      compile: function(schema, parentSchema) {
        return getCompiledSchemas(parentSchema).default = compileOrBoolean(schema), function() {
          return !0;
        };
      },
      valid: !0,
      metaSchema: metaSchemaRef
    }), ajv;
    function getCompiledSchemas(parentSchema, create) {
      var compiled;
      return compiledCaseSchemas.some((function(c) {
        if (c.parentSchema === parentSchema) return compiled = c, !0;
      })), compiled || !1 === create || (compiled = {
        parentSchema: parentSchema,
        cases: {},
        default: !0
      }, compiledCaseSchemas.push(compiled)), compiled;
    }
    function compileOrBoolean(schema) {
      return "boolean" == typeof schema ? schema : ajv.compile(schema);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = function defFunc(ajv) {
    var transform = {
      trimLeft: function(value) {
        return value.replace(/^[\s]+/, "");
      },
      trimRight: function(value) {
        return value.replace(/[\s]+$/, "");
      },
      trim: function(value) {
        return value.trim();
      },
      toLowerCase: function(value) {
        return value.toLowerCase();
      },
      toUpperCase: function(value) {
        return value.toUpperCase();
      },
      toEnumCase: function(value, cfg) {
        return cfg.hash[makeHashTableKey(value)] || value;
      }
    };
    return defFunc.definition = {
      type: "string",
      errors: !1,
      modifying: !0,
      valid: !0,
      compile: function(schema, parentSchema) {
        var cfg;
        if (-1 !== schema.indexOf("toEnumCase")) {
          if (cfg = {
            hash: {}
          }, !parentSchema.enum) throw new Error('Missing enum. To use `transform:["toEnumCase"]`, `enum:[...]` is required.');
          for (var i = parentSchema.enum.length; i--; i) {
            var v = parentSchema.enum[i];
            if ("string" == typeof v) {
              var k = makeHashTableKey(v);
              if (cfg.hash[k]) throw new Error('Invalid enum uniqueness. To use `transform:["toEnumCase"]`, all values must be unique when case insensitive.');
              cfg.hash[k] = v;
            }
          }
        }
        return function(data, dataPath, object, key) {
          if (object) {
            for (var j = 0, l = schema.length; j < l; j++) data = transform[schema[j]](data, cfg);
            object[key] = data;
          }
        };
      },
      metaSchema: {
        type: "array",
        items: {
          type: "string",
          enum: [ "trimLeft", "trimRight", "trim", "toLowerCase", "toUpperCase", "toEnumCase" ]
        }
      }
    }, ajv.addKeyword("transform", defFunc.definition), ajv;
    function makeHashTableKey(value) {
      return value.toLowerCase();
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const errorMessage = (schema, data, message) => ({
    keyword: "absolutePath",
    params: {
      absolutePath: data
    },
    message: message,
    parentSchema: schema
  }), getErrorFor = (shouldBeAbsolute, data, schema) => {
    const message = shouldBeAbsolute ? `The provided value ${JSON.stringify(data)} is not an absolute path!` : `A relative path is expected. However, the provided value ${JSON.stringify(data)} is an absolute path!`;
    return errorMessage(schema, data, message);
  };
  module.exports = ajv => ajv.addKeyword("absolutePath", {
    errors: !0,
    type: "string",
    compile(expected, schema) {
      function callback(data) {
        let passes = !0;
        data.includes("!") && (callback.errors = [ errorMessage(schema, data, `The provided value ${JSON.stringify(data)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`) ], 
        passes = !1);
        return expected === /^(?:[A-Za-z]:\\|\\\\|\/)/.test(data) || (callback.errors = [ getErrorFor(expected, data, schema) ], 
        passes = !1), passes;
      }
      return callback.errors = [], callback;
    }
  });
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), webpackOptionsSchema = __webpack_require__(178), getSchemaPart = (path, parents, additionalPath) => {
    parents = parents || 0, path = (path = path.split("/")).slice(0, path.length - parents), 
    additionalPath && (additionalPath = additionalPath.split("/"), path = path.concat(additionalPath));
    let schemaPart = webpackOptionsSchema;
    for (let i = 1; i < path.length; i++) {
      const inner = schemaPart[path[i]];
      inner && (schemaPart = inner);
    }
    return schemaPart;
  }, getSchemaPartText = (schemaPart, additionalPath) => {
    if (additionalPath) for (let i = 0; i < additionalPath.length; i++) {
      const inner = schemaPart[additionalPath[i]];
      inner && (schemaPart = inner);
    }
    for (;schemaPart.$ref; ) schemaPart = getSchemaPart(schemaPart.$ref);
    let schemaText = WebpackOptionsValidationError.formatSchema(schemaPart);
    return schemaPart.description && (schemaText += "\n-> " + schemaPart.description), 
    schemaText;
  }, getSchemaPartDescription = schemaPart => {
    for (;schemaPart.$ref; ) schemaPart = getSchemaPart(schemaPart.$ref);
    return schemaPart.description ? "\n-> " + schemaPart.description : "";
  }, SPECIFICITY = {
    type: 1,
    oneOf: 1,
    anyOf: 1,
    allOf: 1,
    additionalProperties: 2,
    enum: 1,
    instanceof: 1,
    required: 2,
    minimum: 2,
    uniqueItems: 2,
    minLength: 2,
    minItems: 2,
    minProperties: 2,
    absolutePath: 2
  }, filterMax = (array, fn) => {
    const max = array.reduce((max, item) => Math.max(max, fn(item)), 0);
    return array.filter(item => fn(item) === max);
  }, indent = (str, prefix, firstLine) => firstLine ? prefix + str.replace(/\n(?!$)/g, "\n" + prefix) : str.replace(/\n(?!$)/g, "\n" + prefix);
  class WebpackOptionsValidationError extends WebpackError {
    constructor(validationErrors) {
      super("Invalid configuration object. Webpack has been initialised using a configuration object that does not match the API schema.\n" + validationErrors.map(err => " - " + indent(WebpackOptionsValidationError.formatValidationError(err), "   ", !1)).join("\n")), 
      this.name = "WebpackOptionsValidationError", this.validationErrors = validationErrors, 
      Error.captureStackTrace(this, this.constructor);
    }
    static formatSchema(schema, prevSchemas) {
      prevSchemas = prevSchemas || [];
      const formatInnerSchema = (innerSchema, addSelf) => addSelf ? prevSchemas.includes(innerSchema) ? "(recursive)" : WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas.concat(schema)) : WebpackOptionsValidationError.formatSchema(innerSchema, prevSchemas);
      if ("string" === schema.type) return 1 === schema.minLength ? "non-empty string" : schema.minLength > 1 ? `string (min length ${schema.minLength})` : "string";
      if ("boolean" === schema.type) return "boolean";
      if ("number" === schema.type) return "number";
      if ("object" === schema.type) {
        if (schema.properties) {
          const required = schema.required || [];
          return `object { ${Object.keys(schema.properties).map(property => required.includes(property) ? property : property + "?").concat(schema.additionalProperties ? [ "…" ] : []).join(", ")} }`;
        }
        return schema.additionalProperties ? `object { <key>: ${formatInnerSchema(schema.additionalProperties)} }` : "object";
      }
      if ("array" === schema.type) return `[${formatInnerSchema(schema.items)}]`;
      switch (schema.instanceof) {
       case "Function":
        return "function";

       case "RegExp":
        return "RegExp";
      }
      return schema.enum ? schema.enum.map(item => JSON.stringify(item)).join(" | ") : schema.$ref ? formatInnerSchema(getSchemaPart(schema.$ref), !0) : schema.allOf ? schema.allOf.map(formatInnerSchema).join(" & ") : schema.oneOf ? schema.oneOf.map(formatInnerSchema).join(" | ") : schema.anyOf ? schema.anyOf.map(formatInnerSchema).join(" | ") : JSON.stringify(schema, null, 2);
    }
    static formatValidationError(err) {
      const dataPath = "configuration" + err.dataPath;
      if ("additionalProperties" === err.keyword) {
        const baseMessage = `${dataPath} has an unknown property '${err.params.additionalProperty}'. These properties are valid:\n${getSchemaPartText(err.parentSchema)}`;
        if (!err.dataPath) {
          switch (err.params.additionalProperty) {
           case "debug":
            return baseMessage + "\nThe 'debug' property was removed in webpack 2.0.0.\nLoaders should be updated to allow passing this option via loader options in module.rules.\nUntil loaders are updated one can use the LoaderOptionsPlugin to switch loaders into debug mode:\nplugins: [\n  new webpack.LoaderOptionsPlugin({\n    debug: true\n  })\n]";
          }
          return baseMessage + "\nFor typos: please correct them.\nFor loader options: webpack >= v2.0.0 no longer allows custom properties in configuration.\n  Loaders should be updated to allow passing options via loader options in module.rules.\n  Until loaders are updated one can use the LoaderOptionsPlugin to pass these options to the loader:\n  plugins: [\n    new webpack.LoaderOptionsPlugin({\n      // test: /\\.xxx$/, // may apply this only for some modules\n      options: {\n" + `        ${err.params.additionalProperty}: …\n      }\n    })\n  ]`;
        }
        return baseMessage;
      }
      if ("oneOf" === err.keyword || "anyOf" === err.keyword) {
        if (err.children && err.children.length > 0) {
          if (1 === err.schema.length) {
            const lastChild = err.children[err.children.length - 1], remainingChildren = err.children.slice(0, err.children.length - 1);
            return WebpackOptionsValidationError.formatValidationError(Object.assign({}, lastChild, {
              children: remainingChildren,
              parentSchema: Object.assign({}, err.parentSchema, lastChild.parentSchema)
            }));
          }
          const children = (children => (children = filterMax(children, err => err.dataPath ? err.dataPath.length : 0), 
          children = filterMax(children, err => SPECIFICITY[err.keyword] || 2)))(err.children);
          return 1 === children.length ? WebpackOptionsValidationError.formatValidationError(children[0]) : `${dataPath} should be one of these:\n${getSchemaPartText(err.parentSchema)}\nDetails:\n` + children.map(err => " * " + indent(WebpackOptionsValidationError.formatValidationError(err), "   ", !1)).join("\n");
        }
        return `${dataPath} should be one of these:\n${getSchemaPartText(err.parentSchema)}`;
      }
      if ("enum" === err.keyword) return err.parentSchema && err.parentSchema.enum && 1 === err.parentSchema.enum.length ? `${dataPath} should be ${getSchemaPartText(err.parentSchema)}` : `${dataPath} should be one of these:\n${getSchemaPartText(err.parentSchema)}`;
      if ("allOf" === err.keyword) return `${dataPath} should be:\n${getSchemaPartText(err.parentSchema)}`;
      if ("type" === err.keyword) {
        switch (err.params.type) {
         case "object":
          return `${dataPath} should be an object.${getSchemaPartDescription(err.parentSchema)}`;

         case "string":
          return `${dataPath} should be a string.${getSchemaPartDescription(err.parentSchema)}`;

         case "boolean":
          return `${dataPath} should be a boolean.${getSchemaPartDescription(err.parentSchema)}`;

         case "number":
          return `${dataPath} should be a number.${getSchemaPartDescription(err.parentSchema)}`;

         case "array":
          return `${dataPath} should be an array:\n${getSchemaPartText(err.parentSchema)}`;
        }
        return `${dataPath} should be ${err.params.type}:\n${getSchemaPartText(err.parentSchema)}`;
      }
      if ("instanceof" === err.keyword) return `${dataPath} should be an instance of ${getSchemaPartText(err.parentSchema)}`;
      if ("required" === err.keyword) {
        const missingProperty = err.params.missingProperty.replace(/^\./, "");
        return `${dataPath} misses the property '${missingProperty}'.\n${getSchemaPartText(err.parentSchema, [ "properties", missingProperty ])}`;
      }
      if ("minimum" === err.keyword) return `${dataPath} ${err.message}.${getSchemaPartDescription(err.parentSchema)}`;
      if ("uniqueItems" === err.keyword) return `${dataPath} should not contain the item '${err.data[err.params.i]}' twice.${getSchemaPartDescription(err.parentSchema)}`;
      if ("minLength" === err.keyword || "minItems" === err.keyword || "minProperties" === err.keyword) {
        if (1 === err.params.limit) {
          switch (err.keyword) {
           case "minLength":
            return `${dataPath} should be an non-empty string.${getSchemaPartDescription(err.parentSchema)}`;

           case "minItems":
            return `${dataPath} should be an non-empty array.${getSchemaPartDescription(err.parentSchema)}`;

           case "minProperties":
            return `${dataPath} should be an non-empty object.${getSchemaPartDescription(err.parentSchema)}`;
          }
          return `${dataPath} should be not empty.${getSchemaPartDescription(err.parentSchema)}`;
        }
        return `${dataPath} ${err.message}${getSchemaPartDescription(err.parentSchema)}`;
      }
      if ("not" === err.keyword) return `${dataPath} should not be ${getSchemaPartText(err.schema)}\n${getSchemaPartText(err.parentSchema)}`;
      if ("absolutePath" === err.keyword) {
        const baseMessage = `${dataPath}: ${err.message}${getSchemaPartDescription(err.parentSchema)}`;
        return "configuration.output.filename" === dataPath ? baseMessage + "\nPlease use output.path to specify absolute path and output.filename for the file name." : baseMessage;
      }
      return `${dataPath} ${err.message} (${JSON.stringify(err, null, 2)}).\n${getSchemaPartText(err.parentSchema)}`;
    }
  }
  module.exports = WebpackOptionsValidationError;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1);
  module.exports = class extends WebpackError {
    constructor(message) {
      super(message), Error.captureStackTrace(this, this.constructor);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const asyncLib = __webpack_require__(12), PrefetchDependency = __webpack_require__(179), NormalModule = __webpack_require__(60);
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("AutomaticPrefetchPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
      });
      let lastModules = null;
      compiler.hooks.afterCompile.tap("AutomaticPrefetchPlugin", compilation => {
        lastModules = compilation.modules.filter(m => m instanceof NormalModule).map(m => ({
          context: m.context,
          request: m.request
        }));
      }), compiler.hooks.make.tapAsync("AutomaticPrefetchPlugin", (compilation, callback) => {
        if (!lastModules) return callback();
        asyncLib.forEach(lastModules, (m, callback) => {
          compilation.prefetch(m.context || compiler.context, new PrefetchDependency(m.request), callback);
        }, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ConcatSource: ConcatSource} = __webpack_require__(0), ModuleFilenameHelpers = __webpack_require__(21), Template = __webpack_require__(2), validateOptions = __webpack_require__(8), schema = __webpack_require__(406), wrapComment = str => str.includes("\n") ? `/*!\n * ${str.replace(/\*\//g, "* /").split("\n").join("\n * ")}\n */` : Template.toComment(str);
  module.exports = class {
    constructor(options) {
      if (arguments.length > 1) throw new Error("BannerPlugin only takes one argument (pass an options object)");
      validateOptions(schema, options, "Banner Plugin"), "string" != typeof options && "function" != typeof options || (options = {
        banner: options
      }), this.options = options;
      const bannerOption = options.banner;
      if ("function" == typeof bannerOption) {
        const getBanner = bannerOption;
        this.banner = this.options.raw ? getBanner : data => wrapComment(getBanner(data));
      } else {
        const banner = this.options.raw ? bannerOption : wrapComment(bannerOption);
        this.banner = () => banner;
      }
    }
    apply(compiler) {
      const options = this.options, banner = this.banner, matchObject = ModuleFilenameHelpers.matchObject.bind(void 0, options);
      compiler.hooks.compilation.tap("BannerPlugin", compilation => {
        compilation.hooks.optimizeChunkAssets.tap("BannerPlugin", chunks => {
          for (const chunk of chunks) if (!options.entryOnly || chunk.canBeInitial()) for (const file of chunk.files) {
            if (!matchObject(file)) continue;
            let query = "", filename = file;
            const hash = compilation.hash, querySplit = filename.indexOf("?");
            querySplit >= 0 && (query = filename.substr(querySplit), filename = filename.substr(0, querySplit));
            const lastSlashIndex = filename.lastIndexOf("/"), basename = -1 === lastSlashIndex ? filename : filename.substr(lastSlashIndex + 1), data = {
              hash: hash,
              chunk: chunk,
              filename: filename,
              basename: basename,
              query: query
            }, comment = compilation.getPath(banner(data), data);
            compilation.updateAsset(file, old => new ConcatSource(comment, "\n", old));
          }
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"definitions":{"BannerFunction":{"description":"The banner as function, it will be wrapped in a comment","instanceof":"Function","tsType":"(data: { hash: string, chunk: import(\'../../lib/Chunk\'), filename: string, basename: string, query: string}) => string"},"Rule":{"oneOf":[{"instanceof":"RegExp","tsType":"RegExp"},{"type":"string","minLength":1}]},"Rules":{"oneOf":[{"type":"array","items":{"description":"A rule condition","anyOf":[{"$ref":"#/definitions/Rule"}]}},{"$ref":"#/definitions/Rule"}]}},"title":"BannerPluginArgument","oneOf":[{"title":"BannerPluginOptions","type":"object","additionalProperties":false,"properties":{"banner":{"description":"Specifies the banner","anyOf":[{"$ref":"#/definitions/BannerFunction"},{"type":"string"}]},"entryOnly":{"description":"If true, the banner will only be added to the entry chunks","type":"boolean"},"exclude":{"description":"Exclude all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/Rules"}]},"include":{"description":"Include all modules matching any of these conditions","anyOf":[{"$ref":"#/definitions/Rules"}]},"raw":{"description":"If true, banner will not be wrapped in a comment","type":"boolean"},"test":{"description":"Include all modules that pass test assertion","anyOf":[{"$ref":"#/definitions/Rules"}]}},"required":["banner"]},{"$ref":"#/definitions/BannerFunction"},{"description":"The banner as string, it will be wrapped in a comment","type":"string","minLength":1}]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(negativeMatcher) {
      this.negativeMatcher = negativeMatcher;
    }
    apply(compiler) {
      compiler.hooks.contextModuleFactory.tap("ContextExclusionPlugin", cmf => {
        cmf.hooks.contextModuleFiles.tap("ContextExclusionPlugin", files => files.filter(filePath => !this.negativeMatcher.test(filePath)));
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), ContextElementDependency = __webpack_require__(62);
  const createResolveDependenciesFromContextMap = createContextMap => (fs, options, callback) => {
    createContextMap(fs, (err, map) => {
      if (err) return callback(err);
      const dependencies = Object.keys(map).map(key => new ContextElementDependency(map[key] + options.resourceQuery, key));
      callback(null, dependencies);
    });
  };
  module.exports = class {
    constructor(resourceRegExp, newContentResource, newContentRecursive, newContentRegExp) {
      this.resourceRegExp = resourceRegExp, "function" == typeof newContentResource ? this.newContentCallback = newContentResource : "string" == typeof newContentResource && "object" == typeof newContentRecursive ? (this.newContentResource = newContentResource, 
      this.newContentCreateContextMap = (fs, callback) => {
        callback(null, newContentRecursive);
      }) : "string" == typeof newContentResource && "function" == typeof newContentRecursive ? (this.newContentResource = newContentResource, 
      this.newContentCreateContextMap = newContentRecursive) : ("string" != typeof newContentResource && (newContentRegExp = newContentRecursive, 
      newContentRecursive = newContentResource, newContentResource = void 0), "boolean" != typeof newContentRecursive && (newContentRegExp = newContentRecursive, 
      newContentRecursive = void 0), this.newContentResource = newContentResource, this.newContentRecursive = newContentRecursive, 
      this.newContentRegExp = newContentRegExp);
    }
    apply(compiler) {
      const resourceRegExp = this.resourceRegExp, newContentCallback = this.newContentCallback, newContentResource = this.newContentResource, newContentRecursive = this.newContentRecursive, newContentRegExp = this.newContentRegExp, newContentCreateContextMap = this.newContentCreateContextMap;
      compiler.hooks.contextModuleFactory.tap("ContextReplacementPlugin", cmf => {
        cmf.hooks.beforeResolve.tap("ContextReplacementPlugin", result => {
          if (result) {
            if (resourceRegExp.test(result.request)) if (void 0 !== newContentResource && (result.request = newContentResource), 
            void 0 !== newContentRecursive && (result.recursive = newContentRecursive), void 0 !== newContentRegExp && (result.regExp = newContentRegExp), 
            "function" == typeof newContentCallback) newContentCallback(result); else for (const d of result.dependencies) d.critical && (d.critical = !1);
            return result;
          }
        }), cmf.hooks.afterResolve.tap("ContextReplacementPlugin", result => {
          if (result) {
            if (resourceRegExp.test(result.resource)) if (void 0 !== newContentResource && (result.resource = path.resolve(result.resource, newContentResource)), 
            void 0 !== newContentRecursive && (result.recursive = newContentRecursive), void 0 !== newContentRegExp && (result.regExp = newContentRegExp), 
            "function" == typeof newContentCreateContextMap && (result.resolveDependencies = createResolveDependenciesFromContextMap(newContentCreateContextMap)), 
            "function" == typeof newContentCallback) {
              const origResource = result.resource;
              newContentCallback(result), result.resource !== origResource && (result.resource = path.resolve(origResource, result.resource));
            } else for (const d of result.dependencies) d.critical && (d.critical = !1);
            return result;
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DllEntryPlugin = __webpack_require__(410), FlagAllModulesAsUsedPlugin = __webpack_require__(414), LibManifestPlugin = __webpack_require__(415), validateOptions = __webpack_require__(8), schema = __webpack_require__(416);
  module.exports = class {
    constructor(options) {
      validateOptions(schema, options, "Dll Plugin"), this.options = options;
    }
    apply(compiler) {
      compiler.hooks.entryOption.tap("DllPlugin", (context, entry) => {
        const itemToPlugin = (item, name) => {
          if (Array.isArray(item)) return new DllEntryPlugin(context, item, name);
          throw new Error("DllPlugin: supply an Array as entry");
        };
        return "object" != typeof entry || Array.isArray(entry) ? itemToPlugin(entry, "main").apply(compiler) : Object.keys(entry).forEach(name => {
          itemToPlugin(entry[name], name).apply(compiler);
        }), !0;
      }), new LibManifestPlugin(this.options).apply(compiler), this.options.entryOnly || new FlagAllModulesAsUsedPlugin("DllPlugin").apply(compiler);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DllEntryDependency = __webpack_require__(411), SingleEntryDependency = __webpack_require__(31), DllModuleFactory = __webpack_require__(412);
  module.exports = class {
    constructor(context, entries, name) {
      this.context = context, this.entries = entries, this.name = name;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("DllEntryPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        const dllModuleFactory = new DllModuleFactory;
        compilation.dependencyFactories.set(DllEntryDependency, dllModuleFactory), compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
      }), compiler.hooks.make.tapAsync("DllEntryPlugin", (compilation, callback) => {
        compilation.addEntry(this.context, new DllEntryDependency(this.entries.map((e, idx) => {
          const dep = new SingleEntryDependency(e);
          return dep.loc = {
            name: this.name,
            index: idx
          }, dep;
        }), this.name), this.name, callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Dependency = __webpack_require__(19);
  module.exports = class extends Dependency {
    constructor(dependencies, name) {
      super(), this.dependencies = dependencies, this.name = name;
    }
    get type() {
      return "dll entry";
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {Tapable: Tapable} = __webpack_require__(6), DllModule = __webpack_require__(413);
  module.exports = class extends Tapable {
    constructor() {
      super(), this.hooks = {};
    }
    create(data, callback) {
      const dependency = data.dependencies[0];
      callback(null, new DllModule(data.context, dependency.dependencies, dependency.name, dependency.type));
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {RawSource: RawSource} = __webpack_require__(0), Module = __webpack_require__(18);
  module.exports = class extends Module {
    constructor(context, dependencies, name, type) {
      super("javascript/dynamic", context), this.dependencies = dependencies, this.name = name, 
      this.type = type;
    }
    identifier() {
      return "dll " + this.name;
    }
    readableIdentifier() {
      return "dll " + this.name;
    }
    build(options, compilation, resolver, fs, callback) {
      return this.built = !0, this.buildMeta = {}, this.buildInfo = {}, callback();
    }
    source() {
      return new RawSource("module.exports = __webpack_require__;");
    }
    needRebuild() {
      return !1;
    }
    size() {
      return 12;
    }
    updateHash(hash) {
      hash.update("dll module"), hash.update(this.name || ""), super.updateHash(hash);
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(explanation) {
      this.explanation = explanation;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("FlagAllModulesAsUsedPlugin", compilation => {
        compilation.hooks.optimizeDependencies.tap("FlagAllModulesAsUsedPlugin", modules => {
          for (const module of modules) module.used = !0, module.usedExports = !0, module.addReason(null, null, this.explanation);
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3), asyncLib = __webpack_require__(12), SingleEntryDependency = __webpack_require__(31);
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      compiler.hooks.emit.tapAsync("LibManifestPlugin", (compilation, callback) => {
        asyncLib.forEach(compilation.chunks, (chunk, callback) => {
          if (!chunk.isOnlyInitial()) return void callback();
          const targetPath = compilation.getPath(this.options.path, {
            hash: compilation.hash,
            chunk: chunk
          }), manifest = {
            name: this.options.name && compilation.getPath(this.options.name, {
              hash: compilation.hash,
              chunk: chunk
            }),
            type: this.options.type,
            content: Array.from(chunk.modulesIterable, module => {
              if ((!this.options.entryOnly || module.reasons.some(r => r.dependency instanceof SingleEntryDependency)) && module.libIdent) {
                const ident = module.libIdent({
                  context: this.options.context || compiler.options.context
                });
                if (ident) return {
                  ident: ident,
                  data: {
                    id: module.id,
                    buildMeta: module.buildMeta
                  }
                };
              }
            }).filter(Boolean).reduce((obj, item) => (obj[item.ident] = item.data, obj), Object.create(null))
          }, manifestContent = this.options.format ? JSON.stringify(manifest, null, 2) : JSON.stringify(manifest), content = Buffer.from(manifestContent, "utf8");
          compiler.outputFileSystem.mkdirp(path.dirname(targetPath), err => {
            if (err) return callback(err);
            compiler.outputFileSystem.writeFile(targetPath, content, callback);
          });
        }, callback);
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"DllPluginOptions","type":"object","additionalProperties":false,"properties":{"context":{"description":"Context of requests in the manifest file (defaults to the webpack context)","type":"string","minLength":1},"entryOnly":{"description":"If true, only entry points will be exposed","type":"boolean"},"format":{"description":"If true, manifest json file (output) will be formatted","type":"boolean"},"name":{"description":"Name of the exposed dll function (external name, use value of \'output.library\')","type":"string","minLength":1},"path":{"description":"Absolute path to the manifest json file (output)","type":"string","minLength":1},"type":{"description":"Type of the dll bundle (external type, use value of \'output.libraryTarget\')","type":"string","minLength":1}},"required":["path"]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const parseJson = __webpack_require__(57), DelegatedSourceDependency = __webpack_require__(180), DelegatedModuleFactoryPlugin = __webpack_require__(418), ExternalModuleFactoryPlugin = __webpack_require__(152), DelegatedExportsDependency = __webpack_require__(181), NullFactory = __webpack_require__(10), makePathsRelative = __webpack_require__(14).makePathsRelative, WebpackError = __webpack_require__(1), validateOptions = __webpack_require__(8), schema = __webpack_require__(420);
  class DllManifestError extends WebpackError {
    constructor(filename, message) {
      super(), this.name = "DllManifestError", this.message = `Dll manifest ${filename}\n${message}`, 
      Error.captureStackTrace(this, this.constructor);
    }
  }
  module.exports = class {
    constructor(options) {
      validateOptions(schema, options, "Dll Reference Plugin"), this.options = options;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("DllReferencePlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(DelegatedSourceDependency, normalModuleFactory), 
        compilation.dependencyFactories.set(DelegatedExportsDependency, new NullFactory);
      }), compiler.hooks.beforeCompile.tapAsync("DllReferencePlugin", (params, callback) => {
        if ("manifest" in this.options) {
          const manifest = this.options.manifest;
          if ("string" == typeof manifest) return params.compilationDependencies.add(manifest), 
          void compiler.inputFileSystem.readFile(manifest, (err, result) => {
            if (err) return callback(err);
            try {
              params["dll reference " + manifest] = parseJson(result.toString("utf-8"));
            } catch (e) {
              const manifestPath = makePathsRelative(compiler.options.context, manifest);
              params["dll reference parse error " + manifest] = new DllManifestError(manifestPath, e.message);
            }
            return callback();
          });
        }
        return callback();
      }), compiler.hooks.compile.tap("DllReferencePlugin", params => {
        let name = this.options.name, sourceType = this.options.sourceType, content = "content" in this.options ? this.options.content : void 0;
        if ("manifest" in this.options) {
          let manifest, manifestParameter = this.options.manifest;
          if ("string" == typeof manifestParameter) {
            if (params["dll reference parse error " + manifestParameter]) return;
            manifest = params["dll reference " + manifestParameter];
          } else manifest = manifestParameter;
          manifest && (name || (name = manifest.name), sourceType || (sourceType = manifest.type), 
          content || (content = manifest.content));
        }
        const externals = {}, source = "dll-reference " + name;
        externals[source] = name;
        const normalModuleFactory = params.normalModuleFactory;
        new ExternalModuleFactoryPlugin(sourceType || "var", externals).apply(normalModuleFactory), 
        new DelegatedModuleFactoryPlugin({
          source: source,
          type: this.options.type,
          scope: this.options.scope,
          context: this.options.context || compiler.options.context,
          content: content,
          extensions: this.options.extensions
        }).apply(normalModuleFactory);
      }), compiler.hooks.compilation.tap("DllReferencePlugin", (compilation, params) => {
        if ("manifest" in this.options) {
          let manifest = this.options.manifest;
          if ("string" == typeof manifest) {
            let e = params["dll reference parse error " + manifest];
            e && compilation.errors.push(e);
          }
        }
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const DelegatedModule = __webpack_require__(419);
  module.exports = class {
    constructor(options) {
      this.options = options, options.type = options.type || "require", options.extensions = options.extensions || [ "", ".wasm", ".mjs", ".js", ".json" ];
    }
    apply(normalModuleFactory) {
      const scope = this.options.scope;
      scope ? normalModuleFactory.hooks.factory.tap("DelegatedModuleFactoryPlugin", factory => (data, callback) => {
        const request = data.dependencies[0].request;
        if (request && 0 === request.indexOf(scope + "/")) {
          const innerRequest = "." + request.substr(scope.length);
          let resolved;
          if (innerRequest in this.options.content) return resolved = this.options.content[innerRequest], 
          callback(null, new DelegatedModule(this.options.source, resolved, this.options.type, innerRequest, request));
          for (let i = 0; i < this.options.extensions.length; i++) {
            const extension = this.options.extensions[i], requestPlusExt = innerRequest + extension;
            if (requestPlusExt in this.options.content) return resolved = this.options.content[requestPlusExt], 
            callback(null, new DelegatedModule(this.options.source, resolved, this.options.type, requestPlusExt, request + extension));
          }
        }
        return factory(data, callback);
      }) : normalModuleFactory.hooks.module.tap("DelegatedModuleFactoryPlugin", module => {
        if (module.libIdent) {
          const request = module.libIdent(this.options);
          if (request && request in this.options.content) {
            const resolved = this.options.content[request];
            return new DelegatedModule(this.options.source, resolved, this.options.type, request, module);
          }
        }
        return module;
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {OriginalSource: OriginalSource, RawSource: RawSource} = __webpack_require__(0), Module = __webpack_require__(18), WebpackMissingModule = __webpack_require__(45), DelegatedSourceDependency = __webpack_require__(180), DelegatedExportsDependency = __webpack_require__(181);
  module.exports = class extends Module {
    constructor(sourceRequest, data, type, userRequest, originalRequest) {
      super("javascript/dynamic", null), this.sourceRequest = sourceRequest, this.request = data.id, 
      this.type = type, this.userRequest = userRequest, this.originalRequest = originalRequest, 
      this.delegateData = data, this.delegatedSourceDependency = void 0;
    }
    libIdent(options) {
      return "string" == typeof this.originalRequest ? this.originalRequest : this.originalRequest.libIdent(options);
    }
    identifier() {
      return `delegated ${JSON.stringify(this.request)} from ${this.sourceRequest}`;
    }
    readableIdentifier() {
      return `delegated ${this.userRequest} from ${this.sourceRequest}`;
    }
    needRebuild() {
      return !1;
    }
    build(options, compilation, resolver, fs, callback) {
      this.built = !0, this.buildMeta = Object.assign({}, this.delegateData.buildMeta), 
      this.buildInfo = {}, this.delegatedSourceDependency = new DelegatedSourceDependency(this.sourceRequest), 
      this.addDependency(this.delegatedSourceDependency), this.addDependency(new DelegatedExportsDependency(this, this.delegateData.exports || !0)), 
      callback();
    }
    source(depTemplates, runtime) {
      const dep = this.dependencies[0], sourceModule = dep.module;
      let str;
      if (sourceModule) {
        switch (str = `module.exports = (${runtime.moduleExports({
          module: sourceModule,
          request: dep.request
        })})`, this.type) {
         case "require":
          str += `(${JSON.stringify(this.request)})`;
          break;

         case "object":
          str += `[${JSON.stringify(this.request)}]`;
        }
        str += ";";
      } else str = WebpackMissingModule.moduleCode(this.sourceRequest);
      return this.useSourceMap ? new OriginalSource(str, this.identifier()) : new RawSource(str);
    }
    size() {
      return 42;
    }
    updateHash(hash) {
      hash.update(this.type), hash.update(JSON.stringify(this.request)), super.updateHash(hash);
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"definitions":{"DllReferencePluginOptionsContent":{"description":"The mappings from request to module info","type":"object","additionalProperties":{"description":"Module info","type":"object","additionalProperties":false,"properties":{"buildMeta":{"description":"Meta information about the module","type":"object"},"exports":{"description":"Information about the provided exports of the module","anyOf":[{"description":"Exports unknown/dynamic","enum":[true]},{"description":"List of provided exports of the module","type":"array","items":{"description":"Name of the export","type":"string","minLength":1}}]},"id":{"description":"Module ID","anyOf":[{"type":"number"},{"type":"string","minLength":1}]}},"required":["id"]},"minProperties":1},"DllReferencePluginOptionsManifest":{"description":"An object containing content, name and type","type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"name":{"description":"The name where the dll is exposed (external name)","type":"string","minLength":1},"type":{"description":"The type how the dll is exposed (external type)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]}},"required":["content"]},"DllReferencePluginOptionsSourceType":{"description":"The type how the dll is exposed (external type)","enum":["var","assign","this","window","global","commonjs","commonjs2","commonjs-module","amd","amd-require","umd","umd2","jsonp"]}},"title":"DllReferencePluginOptions","anyOf":[{"type":"object","additionalProperties":false,"properties":{"context":{"description":"(absolute path) context of requests in the manifest (or content property)","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using \'scope\')","type":"array","items":{"description":"An extension","type":"string"}},"manifest":{"description":"An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation","oneOf":[{"$ref":"#/definitions/DllReferencePluginOptionsManifest"},{"type":"string","absolutePath":true}]},"name":{"description":"The name where the dll is exposed (external name, defaults to manifest.name)","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget, defaults to manifest.type)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used","enum":["require","object"]}},"required":["manifest"]},{"type":"object","additionalProperties":false,"properties":{"content":{"description":"The mappings from request to module info","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsContent"}]},"context":{"description":"(absolute path) context of requests in the manifest (or content property)","type":"string","absolutePath":true},"extensions":{"description":"Extensions used to resolve modules in the dll bundle (only used when using \'scope\')","type":"array","items":{"description":"An extension","type":"string"}},"name":{"description":"The name where the dll is exposed (external name)","type":"string","minLength":1},"scope":{"description":"Prefix which is used for accessing the content of the dll","type":"string","minLength":1},"sourceType":{"description":"How the dll is exposed (libraryTarget)","anyOf":[{"$ref":"#/definitions/DllReferencePluginOptionsSourceType"}]},"type":{"description":"The way how the export of the dll bundle is used","enum":["require","object"]}},"required":["content","name"]}]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const WebpackError = __webpack_require__(1), DefinePlugin = __webpack_require__(88), needsEnvVarFix = [ "8", "9" ].indexOf(process.versions.node.split(".")[0]) >= 0 && "win32" === process.platform;
  module.exports = class {
    constructor(...keys) {
      1 === keys.length && Array.isArray(keys[0]) ? (this.keys = keys[0], this.defaultValues = {}) : 1 === keys.length && keys[0] && "object" == typeof keys[0] ? (this.keys = Object.keys(keys[0]), 
      this.defaultValues = keys[0]) : (this.keys = keys, this.defaultValues = {});
    }
    apply(compiler) {
      const definitions = this.keys.reduce((defs, key) => {
        needsEnvVarFix && __webpack_require__(422).cpus();
        const value = void 0 !== process.env[key] ? process.env[key] : this.defaultValues[key];
        return void 0 === value && compiler.hooks.thisCompilation.tap("EnvironmentPlugin", compilation => {
          const error = new WebpackError(`EnvironmentPlugin - ${key} environment variable is undefined.\n\nYou can pass an object with default values to suppress this warning.\nSee https://webpack.js.org/plugins/environment-plugin for example.`);
          error.name = "EnvVariableNotDefinedError", compilation.warnings.push(error);
        }), defs["process.env." + key] = void 0 === value ? "undefined" : JSON.stringify(value), 
        defs;
      }, {});
      new DefinePlugin(definitions).apply(compiler);
    }
  };
}, function(module, exports) {
  module.exports = require("os");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const Template = __webpack_require__(2), ConstDependency = __webpack_require__(5), ParserHelpers = __webpack_require__(9), NullFactory = __webpack_require__(10), REPLACEMENTS = {
    __webpack_hash__: "__webpack_require__.h",
    __webpack_chunkname__: "__webpack_require__.cn"
  }, REPLACEMENT_TYPES = {
    __webpack_hash__: "string",
    __webpack_chunkname__: "string"
  };
  module.exports = class {
    apply(compiler) {
      compiler.hooks.compilation.tap("ExtendedAPIPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const mainTemplate = compilation.mainTemplate;
        mainTemplate.hooks.requireExtensions.tap("ExtendedAPIPlugin", (source, chunk, hash) => {
          const buf = [ source ];
          return buf.push(""), buf.push("// __webpack_hash__"), buf.push(`${mainTemplate.requireFn}.h = ${JSON.stringify(hash)};`), 
          buf.push(""), buf.push("// __webpack_chunkname__"), buf.push(`${mainTemplate.requireFn}.cn = ${JSON.stringify(chunk.name)};`), 
          Template.asString(buf);
        }), mainTemplate.hooks.globalHash.tap("ExtendedAPIPlugin", () => !0);
        const handler = (parser, parserOptions) => {
          Object.keys(REPLACEMENTS).forEach(key => {
            parser.hooks.expression.for(key).tap("ExtendedAPIPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, REPLACEMENTS[key])), 
            parser.hooks.evaluateTypeof.for(key).tap("ExtendedAPIPlugin", ParserHelpers.evaluateToString(REPLACEMENT_TYPES[key]));
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("ExtendedAPIPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ExtendedAPIPlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/esm").tap("ExtendedAPIPlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {SyncBailHook: SyncBailHook} = __webpack_require__(6), {RawSource: RawSource} = __webpack_require__(0), Template = __webpack_require__(2), ModuleHotAcceptDependency = __webpack_require__(162), ModuleHotDeclineDependency = __webpack_require__(163), ConstDependency = __webpack_require__(5), NullFactory = __webpack_require__(10), ParserHelpers = __webpack_require__(9);
  module.exports = class {
    constructor(options) {
      this.options = options || {}, this.multiStep = this.options.multiStep, this.fullBuildTimeout = this.options.fullBuildTimeout || 200, 
      this.requestTimeout = this.options.requestTimeout || 1e4;
    }
    apply(compiler) {
      const multiStep = this.multiStep, fullBuildTimeout = this.fullBuildTimeout, requestTimeout = this.requestTimeout, hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename, hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
      compiler.hooks.additionalPass.tapAsync("HotModuleReplacementPlugin", callback => multiStep ? setTimeout(callback, fullBuildTimeout) : callback());
      const addParserPlugins = (parser, parserOptions) => {
        parser.hooks.expression.for("__webpack_hash__").tap("HotModuleReplacementPlugin", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, "__webpack_require__.h()")), 
        parser.hooks.evaluateTypeof.for("__webpack_hash__").tap("HotModuleReplacementPlugin", ParserHelpers.evaluateToString("string")), 
        parser.hooks.evaluateIdentifier.for("module.hot").tap({
          name: "HotModuleReplacementPlugin",
          before: "NodeStuffPlugin"
        }, expr => ParserHelpers.evaluateToIdentifier("module.hot", !!parser.state.compilation.hotUpdateChunkTemplate)(expr)), 
        parser.hooks.hotAcceptCallback || (parser.hooks.hotAcceptCallback = new SyncBailHook([ "expression", "requests" ])), 
        parser.hooks.hotAcceptWithoutCallback || (parser.hooks.hotAcceptWithoutCallback = new SyncBailHook([ "expression", "requests" ])), 
        parser.hooks.call.for("module.hot.accept").tap("HotModuleReplacementPlugin", expr => {
          if (!parser.state.compilation.hotUpdateChunkTemplate) return !1;
          if (expr.arguments.length >= 1) {
            const arg = parser.evaluateExpression(expr.arguments[0]);
            let params = [], requests = [];
            if (arg.isString() ? params = [ arg ] : arg.isArray() && (params = arg.items.filter(param => param.isString())), 
            params.length > 0) return params.forEach((param, idx) => {
              const request = param.string, dep = new ModuleHotAcceptDependency(request, param.range);
              dep.optional = !0, dep.loc = Object.create(expr.loc), dep.loc.index = idx, parser.state.module.addDependency(dep), 
              requests.push(request);
            }), expr.arguments.length > 1 ? (parser.hooks.hotAcceptCallback.call(expr.arguments[1], requests), 
            parser.walkExpression(expr.arguments[1]), !0) : (parser.hooks.hotAcceptWithoutCallback.call(expr, requests), 
            !0);
          }
        }), parser.hooks.call.for("module.hot.decline").tap("HotModuleReplacementPlugin", expr => {
          if (!parser.state.compilation.hotUpdateChunkTemplate) return !1;
          if (1 === expr.arguments.length) {
            const arg = parser.evaluateExpression(expr.arguments[0]);
            let params = [];
            arg.isString() ? params = [ arg ] : arg.isArray() && (params = arg.items.filter(param => param.isString())), 
            params.forEach((param, idx) => {
              const dep = new ModuleHotDeclineDependency(param.string, param.range);
              dep.optional = !0, dep.loc = Object.create(expr.loc), dep.loc.index = idx, parser.state.module.addDependency(dep);
            });
          }
        }), parser.hooks.expression.for("module.hot").tap("HotModuleReplacementPlugin", ParserHelpers.skipTraversal);
      };
      compiler.hooks.compilation.tap("HotModuleReplacementPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        if (compilation.compiler !== compiler) return;
        const hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
        if (!hotUpdateChunkTemplate) return;
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template), 
        compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template), 
        compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory), 
        compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template), 
        compilation.hooks.record.tap("HotModuleReplacementPlugin", (compilation, records) => {
          if (records.hash !== compilation.hash) {
            records.hash = compilation.hash, records.moduleHashs = {};
            for (const module of compilation.modules) {
              const identifier = module.identifier();
              records.moduleHashs[identifier] = module.hash;
            }
            records.chunkHashs = {};
            for (const chunk of compilation.chunks) records.chunkHashs[chunk.id] = chunk.hash;
            records.chunkModuleIds = {};
            for (const chunk of compilation.chunks) records.chunkModuleIds[chunk.id] = Array.from(chunk.modulesIterable, m => m.id);
          }
        });
        let initialPass = !1, recompilation = !1;
        compilation.hooks.afterHash.tap("HotModuleReplacementPlugin", () => {
          let records = compilation.records;
          if (!records) return void (initialPass = !0);
          records.hash || (initialPass = !0);
          const preHash = records.preHash || "x", prepreHash = records.prepreHash || "x";
          if (preHash === compilation.hash) return recompilation = !0, void compilation.modifyHash(prepreHash);
          records.prepreHash = records.hash || "x", records.preHash = compilation.hash, compilation.modifyHash(records.prepreHash);
        }), compilation.hooks.shouldGenerateChunkAssets.tap("HotModuleReplacementPlugin", () => {
          if (multiStep && !recompilation && !initialPass) return !1;
        }), compilation.hooks.needAdditionalPass.tap("HotModuleReplacementPlugin", () => {
          if (multiStep && !recompilation && !initialPass) return !0;
        }), compilation.hooks.additionalChunkAssets.tap("HotModuleReplacementPlugin", () => {
          const records = compilation.records;
          if (records.hash === compilation.hash) return;
          if (!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;
          for (const module of compilation.modules) {
            const identifier = module.identifier();
            let hash = module.hash;
            module.hotUpdate = records.moduleHashs[identifier] !== hash;
          }
          const hotUpdateMainContent = {
            h: compilation.hash,
            c: {}
          };
          for (const key of Object.keys(records.chunkHashs)) {
            const chunkId = isNaN(+key) ? key : +key, currentChunk = compilation.chunks.find(chunk => "" + chunk.id === key);
            if (currentChunk) {
              const newModules = currentChunk.getModules().filter(module => module.hotUpdate), allModules = new Set;
              for (const module of currentChunk.modulesIterable) allModules.add(module.id);
              const removedModules = records.chunkModuleIds[chunkId].filter(id => !allModules.has(id));
              if (newModules.length > 0 || removedModules.length > 0) {
                const source = hotUpdateChunkTemplate.render(chunkId, newModules, removedModules, compilation.hash, compilation.moduleTemplates.javascript, compilation.dependencyTemplates), {path: filename, info: assetInfo} = compilation.getPathWithInfo(hotUpdateChunkFilename, {
                  hash: records.hash,
                  chunk: currentChunk
                });
                compilation.additionalChunkAssets.push(filename), compilation.emitAsset(filename, source, Object.assign({
                  hotModuleReplacement: !0
                }, assetInfo)), hotUpdateMainContent.c[chunkId] = !0, currentChunk.files.push(filename), 
                compilation.hooks.chunkAsset.call(currentChunk, filename);
              }
            } else hotUpdateMainContent.c[chunkId] = !1;
          }
          const source = new RawSource(JSON.stringify(hotUpdateMainContent)), {path: filename, info: assetInfo} = compilation.getPathWithInfo(hotUpdateMainFilename, {
            hash: records.hash
          });
          compilation.emitAsset(filename, source, Object.assign({
            hotModuleReplacement: !0
          }, assetInfo));
        });
        const mainTemplate = compilation.mainTemplate;
        mainTemplate.hooks.hash.tap("HotModuleReplacementPlugin", hash => {
          hash.update("HotMainTemplateDecorator");
        }), mainTemplate.hooks.moduleRequire.tap("HotModuleReplacementPlugin", (_, chunk, hash, varModuleId) => `hotCreateRequire(${varModuleId})`), 
        mainTemplate.hooks.requireExtensions.tap("HotModuleReplacementPlugin", source => {
          const buf = [ source ];
          return buf.push(""), buf.push("// __webpack_hash__"), buf.push(mainTemplate.requireFn + ".h = function() { return hotCurrentHash; };"), 
          Template.asString(buf);
        });
        const needChunkLoadingCode = chunk => {
          for (const chunkGroup of chunk.groupsIterable) {
            if (chunkGroup.chunks.length > 1) return !0;
            if (chunkGroup.getNumberOfChildren() > 0) return !0;
          }
          return !1;
        };
        mainTemplate.hooks.bootstrap.tap("HotModuleReplacementPlugin", (source, chunk, hash) => (source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash), 
        Template.asString([ source, "", hotInitCode.replace(/\$require\$/g, mainTemplate.requireFn).replace(/\$hash\$/g, JSON.stringify(hash)).replace(/\$requestTimeout\$/g, requestTimeout).replace(/\/\*foreachInstalledChunks\*\//g, needChunkLoadingCode(chunk) ? "for(var chunkId in installedChunks)" : `var chunkId = ${JSON.stringify(chunk.id)};`) ]))), 
        mainTemplate.hooks.globalHash.tap("HotModuleReplacementPlugin", () => !0), mainTemplate.hooks.currentHash.tap("HotModuleReplacementPlugin", (_, length) => isFinite(length) ? `hotCurrentHash.substr(0, ${length})` : "hotCurrentHash"), 
        mainTemplate.hooks.moduleObj.tap("HotModuleReplacementPlugin", (source, chunk, hash, varModuleId) => Template.asString([ source + ",", `hot: hotCreateModule(${varModuleId}),`, "parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),", "children: []" ])), 
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("HotModuleReplacementPlugin", addParserPlugins), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("HotModuleReplacementPlugin", addParserPlugins), 
        compilation.hooks.normalModuleLoader.tap("HotModuleReplacementPlugin", context => {
          context.hot = !0;
        });
      });
    }
  };
  const hotInitCode = Template.getFunctionContent(__webpack_require__(425));
}, function(module, exports) {
  module.exports = function() {};
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(427);
  module.exports = class {
    constructor(options) {
      (arguments.length > 1 || options instanceof RegExp) && (options = {
        resourceRegExp: arguments[0],
        contextRegExp: arguments[1]
      }), validateOptions(schema, options, "IgnorePlugin"), this.options = options, this.checkIgnore = this.checkIgnore.bind(this);
    }
    checkIgnore(result) {
      if (!result) return result;
      if ("checkResource" in this.options && this.options.checkResource && this.options.checkResource(result.request, result.context)) {
        if (!("checkContext" in this.options) || !this.options.checkContext) return null;
        if (this.options.checkContext(result.context)) return null;
      }
      if ("resourceRegExp" in this.options && this.options.resourceRegExp && this.options.resourceRegExp.test(result.request)) {
        if (!("contextRegExp" in this.options) || !this.options.contextRegExp) return null;
        if (this.options.contextRegExp.test(result.context)) return null;
      }
      return result;
    }
    apply(compiler) {
      compiler.hooks.normalModuleFactory.tap("IgnorePlugin", nmf => {
        nmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
      }), compiler.hooks.contextModuleFactory.tap("IgnorePlugin", cmf => {
        cmf.hooks.beforeResolve.tap("IgnorePlugin", this.checkIgnore);
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"IgnorePluginOptions","oneOf":[{"type":"object","additionalProperties":false,"properties":{"contextRegExp":{"description":"A RegExp to test the context (directory) against","instanceof":"RegExp","tsType":"RegExp"},"resourceRegExp":{"description":"A RegExp to test the request against","instanceof":"RegExp","tsType":"RegExp"}}},{"type":"object","additionalProperties":false,"properties":{"checkContext":{"description":"A filter function for context","instanceof":"Function","tsType":"((context: string) => boolean)"},"checkResource":{"description":"A filter function for resource and context","instanceof":"Function","tsType":"((resource: string, context: string) => boolean)"}}}]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ModuleFilenameHelpers = __webpack_require__(21), validateOptions = __webpack_require__(8), schema = __webpack_require__(429);
  module.exports = class {
    constructor(options) {
      validateOptions(schema, options || {}, "Loader Options Plugin"), "object" != typeof options && (options = {}), 
      options.test || (options.test = {
        test: () => !0
      }), this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("LoaderOptionsPlugin", compilation => {
        compilation.hooks.normalModuleLoader.tap("LoaderOptionsPlugin", (context, module) => {
          const resource = module.resource;
          if (!resource) return;
          const i = resource.indexOf("?");
          if (ModuleFilenameHelpers.matchObject(options, i < 0 ? resource : resource.substr(0, i))) for (const key of Object.keys(options)) "include" !== key && "exclude" !== key && "test" !== key && (context[key] = options[key]);
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"LoaderOptionsPluginOptions","type":"object","additionalProperties":true,"properties":{"debug":{"description":"Whether loaders should be in debug mode or not. debug will be removed as of webpack 3","type":"boolean"},"minimize":{"description":"Where loaders can be switched to minimize mode","type":"boolean"},"options":{"description":"A configuration object that can be used to configure older loaders","type":"object","additionalProperties":true,"properties":{"context":{"description":"The context that can be used to configure older loaders","type":"string","absolutePath":true}}}}}');
}, function(module, exports, __webpack_require__) {
  module.exports = __webpack_require__(431);
}, function(module, exports, __webpack_require__) {
  "use strict";
  const normalize = __webpack_require__(63), join = __webpack_require__(102), MemoryFileSystemError = __webpack_require__(432), errors = __webpack_require__(433), stream = __webpack_require__(436), ReadableStream = stream.Readable, WritableStream = stream.Writable;
  function isDir(item) {
    return "object" == typeof item && !0 === item[""];
  }
  function isFile(item) {
    return "object" == typeof item && !item[""];
  }
  function pathToArray(path) {
    path = normalize(path);
    if (/^\//.test(path)) path = (path = path.replace(/\/+/g, "/")).substr(1).split("/"); else {
      if (!/^[A-Za-z]:/.test(path)) throw new MemoryFileSystemError(errors.code.EINVAL, path);
      (path = (path = path.replace(/[\\\/]+/g, "\\")).split(/[\\\/]/))[0] = path[0].toUpperCase();
    }
    return path[path.length - 1] || path.pop(), path;
  }
  function trueFn() {
    return !0;
  }
  function falseFn() {
    return !1;
  }
  class MemoryFileSystem {
    constructor(data) {
      this.data = data || {}, this.join = join, this.pathToArray = pathToArray, this.normalize = normalize;
    }
    meta(_path) {
      const path = pathToArray(_path);
      let current = this.data, i = 0;
      for (;i < path.length - 1; i++) {
        if (!isDir(current[path[i]])) return;
        current = current[path[i]];
      }
      return current[path[i]];
    }
    existsSync(_path) {
      return !!this.meta(_path);
    }
    statSync(_path) {
      let current = this.meta(_path);
      if ("/" === _path || isDir(current)) return {
        isFile: falseFn,
        isDirectory: trueFn,
        isBlockDevice: falseFn,
        isCharacterDevice: falseFn,
        isSymbolicLink: falseFn,
        isFIFO: falseFn,
        isSocket: falseFn
      };
      if (isFile(current)) return {
        isFile: trueFn,
        isDirectory: falseFn,
        isBlockDevice: falseFn,
        isCharacterDevice: falseFn,
        isSymbolicLink: falseFn,
        isFIFO: falseFn,
        isSocket: falseFn
      };
      throw new MemoryFileSystemError(errors.code.ENOENT, _path, "stat");
    }
    readFileSync(_path, optionsOrEncoding) {
      const path = pathToArray(_path);
      let current = this.data, i = 0;
      for (;i < path.length - 1; i++) {
        if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path, "readFile");
        current = current[path[i]];
      }
      if (!isFile(current[path[i]])) throw isDir(current[path[i]]) ? new MemoryFileSystemError(errors.code.EISDIR, _path, "readFile") : new MemoryFileSystemError(errors.code.ENOENT, _path, "readFile");
      current = current[path[i]];
      const encoding = "object" == typeof optionsOrEncoding ? optionsOrEncoding.encoding : optionsOrEncoding;
      return encoding ? current.toString(encoding) : current;
    }
    readdirSync(_path) {
      if ("/" === _path) return Object.keys(this.data).filter(Boolean);
      const path = pathToArray(_path);
      let current = this.data, i = 0;
      for (;i < path.length - 1; i++) {
        if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path, "readdir");
        current = current[path[i]];
      }
      if (!isDir(current[path[i]])) throw isFile(current[path[i]]) ? new MemoryFileSystemError(errors.code.ENOTDIR, _path, "readdir") : new MemoryFileSystemError(errors.code.ENOENT, _path, "readdir");
      return Object.keys(current[path[i]]).filter(Boolean);
    }
    mkdirpSync(_path) {
      const path = pathToArray(_path);
      if (0 === path.length) return;
      let current = this.data;
      for (let i = 0; i < path.length; i++) {
        if (isFile(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOTDIR, _path, "mkdirp");
        isDir(current[path[i]]) || (current[path[i]] = {
          "": !0
        }), current = current[path[i]];
      }
    }
    mkdirSync(_path) {
      const path = pathToArray(_path);
      if (0 === path.length) return;
      let current = this.data, i = 0;
      for (;i < path.length - 1; i++) {
        if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path, "mkdir");
        current = current[path[i]];
      }
      if (isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.EEXIST, _path, "mkdir");
      if (isFile(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOTDIR, _path, "mkdir");
      current[path[i]] = {
        "": !0
      };
    }
    _remove(_path, name, testFn) {
      const path = pathToArray(_path), operation = "File" === name ? "unlink" : "rmdir";
      if (0 === path.length) throw new MemoryFileSystemError(errors.code.EPERM, _path, operation);
      let current = this.data, i = 0;
      for (;i < path.length - 1; i++) {
        if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path, operation);
        current = current[path[i]];
      }
      if (!testFn(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path, operation);
      delete current[path[i]];
    }
    rmdirSync(_path) {
      return this._remove(_path, "Directory", isDir);
    }
    unlinkSync(_path) {
      return this._remove(_path, "File", isFile);
    }
    readlinkSync(_path) {
      throw new MemoryFileSystemError(errors.code.ENOSYS, _path, "readlink");
    }
    writeFileSync(_path, content, optionsOrEncoding) {
      if (!content && !optionsOrEncoding) throw new Error("No content");
      const path = pathToArray(_path);
      if (0 === path.length) throw new MemoryFileSystemError(errors.code.EISDIR, _path, "writeFile");
      let current = this.data, i = 0;
      for (;i < path.length - 1; i++) {
        if (!isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.ENOENT, _path, "writeFile");
        current = current[path[i]];
      }
      if (isDir(current[path[i]])) throw new MemoryFileSystemError(errors.code.EISDIR, _path, "writeFile");
      const encoding = "object" == typeof optionsOrEncoding ? optionsOrEncoding.encoding : optionsOrEncoding;
      current[path[i]] = optionsOrEncoding || "string" == typeof content ? new Buffer(content, encoding) : content;
    }
    createReadStream(path, options) {
      let data, stream = new ReadableStream, done = !1;
      try {
        data = this.readFileSync(path);
      } catch (e) {
        return stream._read = function() {
          done || (done = !0, this.emit("error", e), this.push(null));
        }, stream;
      }
      return (options = options || {}).start = options.start || 0, options.end = options.end || data.length, 
      stream._read = function() {
        done || (done = !0, this.push(data.slice(options.start, options.end)), this.push(null));
      }, stream;
    }
    createWriteStream(path) {
      let stream = new WritableStream;
      try {
        this.writeFileSync(path, new Buffer(0));
      } catch (e) {
        return stream.once("prefinish", (function() {
          stream.emit("error", e);
        })), stream;
      }
      let bl = [], len = 0;
      return stream._write = (chunk, encoding, callback) => {
        bl.push(chunk), len += chunk.length, this.writeFile(path, Buffer.concat(bl, len), callback);
      }, stream;
    }
    exists(path, callback) {
      return callback(this.existsSync(path));
    }
    writeFile(path, content, encoding, callback) {
      callback || (callback = encoding, encoding = void 0);
      try {
        this.writeFileSync(path, content, encoding);
      } catch (e) {
        return callback(e);
      }
      return callback();
    }
  }
  [ "stat", "readdir", "mkdirp", "rmdir", "unlink", "readlink" ].forEach((function(fn) {
    MemoryFileSystem.prototype[fn] = function(path, callback) {
      let result;
      try {
        result = this[fn + "Sync"](path);
      } catch (e) {
        return void setImmediate((function() {
          callback(e);
        }));
      }
      setImmediate((function() {
        callback(null, result);
      }));
    };
  })), [ "mkdir", "readFile" ].forEach((function(fn) {
    MemoryFileSystem.prototype[fn] = function(path, optArg, callback) {
      let result;
      callback || (callback = optArg, optArg = void 0);
      try {
        result = this[fn + "Sync"](path, optArg);
      } catch (e) {
        return void setImmediate((function() {
          callback(e);
        }));
      }
      setImmediate((function() {
        callback(null, result);
      }));
    };
  })), module.exports = MemoryFileSystem;
}, function(module, exports, __webpack_require__) {
  "use strict";
  class MemoryFileSystemError extends Error {
    constructor(err, path, operation) {
      super(err, path), this.name = this.constructor.name;
      var message = [ err.code + ":", err.description + "," ];
      operation && message.push(operation), message.push(`'${path}'`), this.message = message.join(" "), 
      this.code = err.code, this.errno = err.errno, this.path = path, this.operation = operation, 
      Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
    }
  }
  module.exports = MemoryFileSystemError;
}, function(module, exports, __webpack_require__) {
  var all = module.exports.all = [ {
    errno: -2,
    code: "ENOENT",
    description: "no such file or directory"
  }, {
    errno: -1,
    code: "UNKNOWN",
    description: "unknown error"
  }, {
    errno: 0,
    code: "OK",
    description: "success"
  }, {
    errno: 1,
    code: "EOF",
    description: "end of file"
  }, {
    errno: 2,
    code: "EADDRINFO",
    description: "getaddrinfo error"
  }, {
    errno: 3,
    code: "EACCES",
    description: "permission denied"
  }, {
    errno: 4,
    code: "EAGAIN",
    description: "resource temporarily unavailable"
  }, {
    errno: 5,
    code: "EADDRINUSE",
    description: "address already in use"
  }, {
    errno: 6,
    code: "EADDRNOTAVAIL",
    description: "address not available"
  }, {
    errno: 7,
    code: "EAFNOSUPPORT",
    description: "address family not supported"
  }, {
    errno: 8,
    code: "EALREADY",
    description: "connection already in progress"
  }, {
    errno: 9,
    code: "EBADF",
    description: "bad file descriptor"
  }, {
    errno: 10,
    code: "EBUSY",
    description: "resource busy or locked"
  }, {
    errno: 11,
    code: "ECONNABORTED",
    description: "software caused connection abort"
  }, {
    errno: 12,
    code: "ECONNREFUSED",
    description: "connection refused"
  }, {
    errno: 13,
    code: "ECONNRESET",
    description: "connection reset by peer"
  }, {
    errno: 14,
    code: "EDESTADDRREQ",
    description: "destination address required"
  }, {
    errno: 15,
    code: "EFAULT",
    description: "bad address in system call argument"
  }, {
    errno: 16,
    code: "EHOSTUNREACH",
    description: "host is unreachable"
  }, {
    errno: 17,
    code: "EINTR",
    description: "interrupted system call"
  }, {
    errno: 18,
    code: "EINVAL",
    description: "invalid argument"
  }, {
    errno: 19,
    code: "EISCONN",
    description: "socket is already connected"
  }, {
    errno: 20,
    code: "EMFILE",
    description: "too many open files"
  }, {
    errno: 21,
    code: "EMSGSIZE",
    description: "message too long"
  }, {
    errno: 22,
    code: "ENETDOWN",
    description: "network is down"
  }, {
    errno: 23,
    code: "ENETUNREACH",
    description: "network is unreachable"
  }, {
    errno: 24,
    code: "ENFILE",
    description: "file table overflow"
  }, {
    errno: 25,
    code: "ENOBUFS",
    description: "no buffer space available"
  }, {
    errno: 26,
    code: "ENOMEM",
    description: "not enough memory"
  }, {
    errno: 27,
    code: "ENOTDIR",
    description: "not a directory"
  }, {
    errno: 28,
    code: "EISDIR",
    description: "illegal operation on a directory"
  }, {
    errno: 29,
    code: "ENONET",
    description: "machine is not on the network"
  }, {
    errno: 31,
    code: "ENOTCONN",
    description: "socket is not connected"
  }, {
    errno: 32,
    code: "ENOTSOCK",
    description: "socket operation on non-socket"
  }, {
    errno: 33,
    code: "ENOTSUP",
    description: "operation not supported on socket"
  }, {
    errno: 34,
    code: "ENOENT",
    description: "no such file or directory"
  }, {
    errno: 35,
    code: "ENOSYS",
    description: "function not implemented"
  }, {
    errno: 36,
    code: "EPIPE",
    description: "broken pipe"
  }, {
    errno: 37,
    code: "EPROTO",
    description: "protocol error"
  }, {
    errno: 38,
    code: "EPROTONOSUPPORT",
    description: "protocol not supported"
  }, {
    errno: 39,
    code: "EPROTOTYPE",
    description: "protocol wrong type for socket"
  }, {
    errno: 40,
    code: "ETIMEDOUT",
    description: "connection timed out"
  }, {
    errno: 41,
    code: "ECHARSET",
    description: "invalid Unicode character"
  }, {
    errno: 42,
    code: "EAIFAMNOSUPPORT",
    description: "address family for hostname not supported"
  }, {
    errno: 44,
    code: "EAISERVICE",
    description: "servname not supported for ai_socktype"
  }, {
    errno: 45,
    code: "EAISOCKTYPE",
    description: "ai_socktype not supported"
  }, {
    errno: 46,
    code: "ESHUTDOWN",
    description: "cannot send after transport endpoint shutdown"
  }, {
    errno: 47,
    code: "EEXIST",
    description: "file already exists"
  }, {
    errno: 48,
    code: "ESRCH",
    description: "no such process"
  }, {
    errno: 49,
    code: "ENAMETOOLONG",
    description: "name too long"
  }, {
    errno: 50,
    code: "EPERM",
    description: "operation not permitted"
  }, {
    errno: 51,
    code: "ELOOP",
    description: "too many symbolic links encountered"
  }, {
    errno: 52,
    code: "EXDEV",
    description: "cross-device link not permitted"
  }, {
    errno: 53,
    code: "ENOTEMPTY",
    description: "directory not empty"
  }, {
    errno: 54,
    code: "ENOSPC",
    description: "no space left on device"
  }, {
    errno: 55,
    code: "EIO",
    description: "i/o error"
  }, {
    errno: 56,
    code: "EROFS",
    description: "read-only file system"
  }, {
    errno: 57,
    code: "ENODEV",
    description: "no such device"
  }, {
    errno: 58,
    code: "ESPIPE",
    description: "invalid seek"
  }, {
    errno: 59,
    code: "ECANCELED",
    description: "operation canceled"
  } ];
  module.exports.errno = {}, module.exports.code = {}, all.forEach((function(error) {
    module.exports.errno[error.errno] = error, module.exports.code[error.code] = error;
  })), module.exports.custom = __webpack_require__(434)(module.exports), module.exports.create = module.exports.custom.createError;
}, function(module, exports, __webpack_require__) {
  var prr = __webpack_require__(435);
  function init(type, message, cause) {
    message && "string" != typeof message && (message = message.message || message.name), 
    prr(this, {
      type: type,
      name: type,
      cause: "string" != typeof message ? message : cause,
      message: message
    }, "ewr");
  }
  function CustomError(message, cause) {
    Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), 
    init.call(this, "CustomError", message, cause);
  }
  CustomError.prototype = new Error, module.exports = function(errno) {
    var ce = function(type, proto) {
      return function(errno, type, proto) {
        var err = function(message, cause) {
          init.call(this, type, message, cause), "FilesystemError" == type && (this.code = this.cause.code, 
          this.path = this.cause.path, this.errno = this.cause.errno, this.message = (errno.errno[this.cause.errno] ? errno.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "")), 
          Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, err);
        };
        return err.prototype = proto ? new proto : new CustomError, err;
      }(errno, type, proto);
    };
    return {
      CustomError: CustomError,
      FilesystemError: ce("FilesystemError"),
      createError: ce
    };
  };
}, function(module, exports, __webpack_require__) {
  var context, definition;
  context = this, definition = function() {
    var setProperty = "function" == typeof Object.defineProperty ? function(obj, key, options) {
      return Object.defineProperty(obj, key, options), obj;
    } : function(obj, key, options) {
      return obj[key] = options.value, obj;
    };
    return function(obj, key, value, options) {
      var k;
      if (options = function(value, options) {
        var oo = "object" == typeof options, os = !oo && "string" == typeof options, op = function(p) {
          return oo ? !!options[p] : !!os && options.indexOf(p[0]) > -1;
        };
        return {
          enumerable: op("enumerable"),
          configurable: op("configurable"),
          writable: op("writable"),
          value: value
        };
      }(value, options), "object" == typeof key) {
        for (k in key) Object.hasOwnProperty.call(key, k) && (options.value = key[k], setProperty(obj, k, options));
        return obj;
      }
      return setProperty(obj, key, options);
    };
  }, module.exports ? module.exports = definition() : context.prr = definition();
}, function(module, exports) {
  module.exports = require("../vendor/readable-stream");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const path = __webpack_require__(3);
  module.exports = class {
    constructor(resourceRegExp, newResource) {
      this.resourceRegExp = resourceRegExp, this.newResource = newResource;
    }
    apply(compiler) {
      const resourceRegExp = this.resourceRegExp, newResource = this.newResource;
      compiler.hooks.normalModuleFactory.tap("NormalModuleReplacementPlugin", nmf => {
        nmf.hooks.beforeResolve.tap("NormalModuleReplacementPlugin", result => {
          if (result) return resourceRegExp.test(result.request) && ("function" == typeof newResource ? newResource(result) : result.request = newResource), 
          result;
        }), nmf.hooks.afterResolve.tap("NormalModuleReplacementPlugin", result => {
          if (result) return resourceRegExp.test(result.resource) && ("function" == typeof newResource ? newResource(result) : result.resource = path.resolve(path.dirname(result.resource), newResource)), 
          result;
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const PrefetchDependency = __webpack_require__(179);
  module.exports = class {
    constructor(context, request) {
      request ? (this.context = context, this.request = request) : this.request = context;
    }
    apply(compiler) {
      compiler.hooks.compilation.tap("PrefetchPlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
      }), compiler.hooks.make.tapAsync("PrefetchPlugin", (compilation, callback) => {
        compilation.prefetch(this.context || compiler.context, new PrefetchDependency(this.request), callback);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(440);
  class ProgressPlugin {
    constructor(options) {
      "function" == typeof options && (options = {
        handler: options
      }), validateOptions(schema, options = options || {}, "Progress Plugin"), options = Object.assign({}, ProgressPlugin.defaultOptions, options), 
      this.profile = options.profile, this.handler = options.handler, this.modulesCount = options.modulesCount, 
      this.showEntries = options.entries, this.showModules = options.modules, this.showActiveModules = options.activeModules;
    }
    apply(compiler) {
      const {modulesCount: modulesCount} = this, handler = this.handler || ((profile, logger) => {
        let lastState, lastStateTime;
        return (percentage, msg, ...args) => {
          if (logger.status(Math.floor(100 * percentage) + "%", msg, ...args), profile) {
            let state = msg;
            if (state = state.replace(/^\d+\/\d+\s+/, ""), 0 === percentage) lastState = null, 
            lastStateTime = Date.now(); else if (state !== lastState || 1 === percentage) {
              const now = Date.now();
              if (lastState) {
                const diff = now - lastStateTime, stateMsg = `${diff}ms ${lastState}`;
                diff > 1e3 ? logger.warn(stateMsg) : diff > 10 ? logger.info(stateMsg) : diff > 0 ? logger.log(stateMsg) : logger.debug(stateMsg);
              }
              lastState = state, lastStateTime = now;
            }
          }
          1 === percentage && logger.status();
        };
      })(this.profile, compiler.getInfrastructureLogger("webpack.Progress")), showEntries = this.showEntries, showModules = this.showModules, showActiveModules = this.showActiveModules;
      if (compiler.compilers) {
        const states = new Array(compiler.compilers.length);
        compiler.compilers.forEach((compiler, idx) => {
          new ProgressPlugin((p, msg, ...args) => {
            states[idx] = [ p, msg, ...args ], handler(states.map(state => state && state[0] || 0).reduce((a, b) => a + b) / states.length, `[${idx}] ${msg}`, ...args);
          }).apply(compiler);
        });
      } else {
        let lastModulesCount = 0, lastEntriesCount = 0, moduleCount = modulesCount, entriesCount = 1, doneModules = 0, doneEntries = 0;
        const activeModules = new Set;
        let lastActiveModule = "";
        const update = () => {
          const percentByModules = doneModules / Math.max(lastModulesCount, moduleCount), percentByEntries = doneEntries / Math.max(lastEntriesCount, entriesCount), items = [ .1 + .6 * Math.max(percentByModules, percentByEntries), "building" ];
          showEntries && items.push(`${doneEntries}/${entriesCount} entries`), showModules && items.push(`${doneModules}/${moduleCount} modules`), 
          showActiveModules && (items.push(activeModules.size + " active"), items.push(lastActiveModule)), 
          handler(...items);
        }, moduleAdd = module => {
          if (moduleCount++, showActiveModules) {
            const ident = module.identifier();
            ident && (activeModules.add(ident), lastActiveModule = ident);
          }
          update();
        }, entryAdd = (entry, name) => {
          entriesCount++, update();
        }, moduleDone = module => {
          if (doneModules++, showActiveModules) {
            const ident = module.identifier();
            if (ident && (activeModules.delete(ident), lastActiveModule === ident)) {
              lastActiveModule = "";
              for (const m of activeModules) lastActiveModule = m;
            }
          }
          update();
        }, entryDone = (entry, name) => {
          doneEntries++, update();
        };
        compiler.hooks.compilation.tap("ProgressPlugin", compilation => {
          if (compilation.compiler.isChild()) return;
          lastModulesCount = moduleCount, lastEntriesCount = entriesCount, moduleCount = entriesCount = 0, 
          doneModules = doneEntries = 0, handler(0, "compiling"), compilation.hooks.buildModule.tap("ProgressPlugin", moduleAdd), 
          compilation.hooks.failedModule.tap("ProgressPlugin", moduleDone), compilation.hooks.succeedModule.tap("ProgressPlugin", moduleDone), 
          compilation.hooks.addEntry.tap("ProgressPlugin", entryAdd), compilation.hooks.failedEntry.tap("ProgressPlugin", entryDone), 
          compilation.hooks.succeedEntry.tap("ProgressPlugin", entryDone);
          const hooks = {
            finishModules: "finish module graph",
            seal: "sealing",
            beforeChunks: "chunk graph",
            afterChunks: "after chunk graph",
            optimizeDependenciesBasic: "basic dependencies optimization",
            optimizeDependencies: "dependencies optimization",
            optimizeDependenciesAdvanced: "advanced dependencies optimization",
            afterOptimizeDependencies: "after dependencies optimization",
            optimize: "optimizing",
            optimizeModulesBasic: "basic module optimization",
            optimizeModules: "module optimization",
            optimizeModulesAdvanced: "advanced module optimization",
            afterOptimizeModules: "after module optimization",
            optimizeChunksBasic: "basic chunk optimization",
            optimizeChunks: "chunk optimization",
            optimizeChunksAdvanced: "advanced chunk optimization",
            afterOptimizeChunks: "after chunk optimization",
            optimizeTree: "module and chunk tree optimization",
            afterOptimizeTree: "after module and chunk tree optimization",
            optimizeChunkModulesBasic: "basic chunk modules optimization",
            optimizeChunkModules: "chunk modules optimization",
            optimizeChunkModulesAdvanced: "advanced chunk modules optimization",
            afterOptimizeChunkModules: "after chunk modules optimization",
            reviveModules: "module reviving",
            optimizeModuleOrder: "module order optimization",
            advancedOptimizeModuleOrder: "advanced module order optimization",
            beforeModuleIds: "before module ids",
            moduleIds: "module ids",
            optimizeModuleIds: "module id optimization",
            afterOptimizeModuleIds: "module id optimization",
            reviveChunks: "chunk reviving",
            optimizeChunkOrder: "chunk order optimization",
            beforeChunkIds: "before chunk ids",
            optimizeChunkIds: "chunk id optimization",
            afterOptimizeChunkIds: "after chunk id optimization",
            recordModules: "record modules",
            recordChunks: "record chunks",
            beforeHash: "hashing",
            afterHash: "after hashing",
            recordHash: "record hash",
            beforeModuleAssets: "module assets processing",
            beforeChunkAssets: "chunk assets processing",
            additionalChunkAssets: "additional chunk assets processing",
            record: "recording",
            additionalAssets: "additional asset processing",
            optimizeChunkAssets: "chunk asset optimization",
            afterOptimizeChunkAssets: "after chunk asset optimization",
            optimizeAssets: "asset optimization",
            afterOptimizeAssets: "after asset optimization",
            afterSeal: "after seal"
          }, numberOfHooks = Object.keys(hooks).length;
          Object.keys(hooks).forEach((name, idx) => {
            const title = hooks[name], percentage = idx / numberOfHooks * .25 + .7;
            compilation.hooks[name].intercept({
              name: "ProgressPlugin",
              context: !0,
              call: () => {
                handler(percentage, title);
              },
              tap: (context, tap) => {
                context && (context.reportProgress = (p, ...args) => {
                  handler(percentage, title, tap.name, ...args);
                }), handler(percentage, title, tap.name);
              }
            });
          });
        }), compiler.hooks.emit.intercept({
          name: "ProgressPlugin",
          context: !0,
          call: () => {
            handler(.95, "emitting");
          },
          tap: (context, tap) => {
            context && (context.reportProgress = (p, ...args) => {
              handler(.95, "emitting", tap.name, ...args);
            }), handler(.95, "emitting", tap.name);
          }
        }), compiler.hooks.afterEmit.intercept({
          name: "ProgressPlugin",
          context: !0,
          call: () => {
            handler(.98, "after emitting");
          },
          tap: (context, tap) => {
            context && (context.reportProgress = (p, ...args) => {
              handler(.98, "after emitting", tap.name, ...args);
            }), handler(.98, "after emitting", tap.name);
          }
        }), compiler.hooks.done.tap("ProgressPlugin", () => {
          handler(1, "");
        });
      }
    }
  }
  ProgressPlugin.defaultOptions = {
    profile: !1,
    modulesCount: 500,
    modules: !0,
    activeModules: !0,
    entries: !1
  }, module.exports = ProgressPlugin;
}, function(module) {
  module.exports = JSON.parse('{"definitions":{"HandlerFunction":{"description":"Function that executes for every progress step","instanceof":"Function","tsType":"((percentage: number, msg: string, ...args: string[]) => void)"},"ProgressPluginOptions":{"type":"object","additionalProperties":false,"properties":{"activeModules":{"description":"Show active modules count and one active module in progress message","type":"boolean"},"entries":{"description":"Show entries count in progress message","type":"boolean"},"handler":{"description":"Function that executes for every progress step","anyOf":[{"$ref":"#/definitions/HandlerFunction"}]},"modules":{"description":"Show modules count in progress message","type":"boolean"},"modulesCount":{"description":"Minimum modules count to start with. Only for mode=modules. Default: 500","type":"number"},"profile":{"description":"Collect profile data for progress steps. Default: false","enum":[true,false,null]}}}},"title":"ProgressPluginArgument","oneOf":[{"$ref":"#/definitions/ProgressPluginOptions"},{"$ref":"#/definitions/HandlerFunction"}]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const ParserHelpers = __webpack_require__(9), ConstDependency = __webpack_require__(5), NullFactory = __webpack_require__(10);
  module.exports = class {
    constructor(definitions) {
      this.definitions = definitions;
    }
    apply(compiler) {
      const definitions = this.definitions;
      compiler.hooks.compilation.tap("ProvidePlugin", (compilation, {normalModuleFactory: normalModuleFactory}) => {
        compilation.dependencyFactories.set(ConstDependency, new NullFactory), compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template);
        const handler = (parser, parserOptions) => {
          Object.keys(definitions).forEach(name => {
            var request = [].concat(definitions[name]), splittedName = name.split(".");
            splittedName.length > 0 && splittedName.slice(1).forEach((_, i) => {
              const name = splittedName.slice(0, i + 1).join(".");
              parser.hooks.canRename.for(name).tap("ProvidePlugin", ParserHelpers.approve);
            }), parser.hooks.expression.for(name).tap("ProvidePlugin", expr => {
              let nameIdentifier = name;
              const scopedName = name.includes(".");
              let expression = `require(${JSON.stringify(request[0])})`;
              return scopedName && (nameIdentifier = "__webpack_provided_" + name.replace(/\./g, "_dot_")), 
              request.length > 1 && (expression += request.slice(1).map(r => `[${JSON.stringify(r)}]`).join("")), 
              !!ParserHelpers.addParsedVariableToModule(parser, nameIdentifier, expression) && (scopedName && ParserHelpers.toConstantDependency(parser, nameIdentifier)(expr), 
              !0);
            });
          });
        };
        normalModuleFactory.hooks.parser.for("javascript/auto").tap("ProvidePlugin", handler), 
        normalModuleFactory.hooks.parser.for("javascript/dynamic").tap("ProvidePlugin", handler);
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = __webpack_require__(443).default;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
      Constructor;
    };
  }(), _ConstDependency2 = _interopRequireDefault(__webpack_require__(5)), _NullFactory2 = _interopRequireDefault(__webpack_require__(10)), _MissingLocalizationError2 = _interopRequireDefault(__webpack_require__(444)), _MakeLocalizeFunction2 = _interopRequireDefault(__webpack_require__(445));
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var I18nPlugin = function() {
    function I18nPlugin(localization, options, failOnMissing) {
      !function(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }(this, I18nPlugin), "string" == typeof options && (options = {
        functionName: options
      }), void 0 !== failOnMissing && (options.failOnMissing = failOnMissing), this.options = options || {}, 
      this.localization = localization ? "function" == typeof localization ? localization : (0, 
      _MakeLocalizeFunction2.default)(localization, !!this.options.nested) : null, this.functionName = this.options.functionName || "__", 
      this.failOnMissing = !!this.options.failOnMissing, this.hideMessage = this.options.hideMessage || !1;
    }
    return _createClass(I18nPlugin, [ {
      key: "apply",
      value: function(compiler) {
        var localization = this.localization, failOnMissing = this.failOnMissing, hideMessage = this.hideMessage, name = this.functionName;
        compiler.plugin("compilation", (function(compilation, params) {
          compilation.dependencyFactories.set(_ConstDependency2.default, new _NullFactory2.default), 
          compilation.dependencyTemplates.set(_ConstDependency2.default, new _ConstDependency2.default.Template);
        })), compiler.plugin("compilation", (function(compilation, data) {
          data.normalModuleFactory.plugin("parser", (function(parser, options) {
            parser.plugin("call " + name, (function(expr) {
              var param = void 0, defaultValue = void 0;
              switch (expr.arguments.length) {
               case 2:
                if (!(param = this.evaluateExpression(expr.arguments[1])).isString()) return;
                if (param = param.string, !(defaultValue = this.evaluateExpression(expr.arguments[0])).isString()) return;
                defaultValue = defaultValue.string;
                break;

               case 1:
                if (!(param = this.evaluateExpression(expr.arguments[0])).isString()) return;
                defaultValue = param = param.string;
                break;

               default:
                return;
              }
              var result = localization ? localization(param) : defaultValue;
              if (void 0 === result) {
                var error = this.state.module[__dirname];
                error ? error.requests.includes(param) || error.add(param, defaultValue) : (error = new _MissingLocalizationError2.default(this.state.module, param, defaultValue), 
                this.state.module[__dirname] = error, failOnMissing ? this.state.module.errors.push(error) : hideMessage || this.state.module.warnings.push(error)), 
                result = defaultValue;
              }
              var dep = new _ConstDependency2.default(JSON.stringify(result), expr.range);
              return dep.loc = expr.loc, this.state.current.addDependency(dep), !0;
            }));
          }));
        }));
      }
    } ]), I18nPlugin;
  }();
  exports.default = I18nPlugin;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  });
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
      Constructor;
    };
  }();
  var MissingLocalizationError = function(_Error) {
    function MissingLocalizationError(module, name, value) {
      !function(instance, Constructor) {
        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
      }(this, MissingLocalizationError);
      var _this = function(self, call) {
        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !call || "object" != typeof call && "function" != typeof call ? self : call;
      }(this, (MissingLocalizationError.__proto__ || Object.getPrototypeOf(MissingLocalizationError)).call(this));
      return Error.captureStackTrace(_this, MissingLocalizationError), _this.name = "MissingLocalizationError", 
      _this.requests = [ {
        name: name,
        value: value
      } ], _this.module = module, Object.setPrototypeOf(_this, MissingLocalizationError.prototype), 
      _this._buildMessage(), _this;
    }
    return function(subClass, superClass) {
      if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }(MissingLocalizationError, Error), _createClass(MissingLocalizationError, [ {
      key: "_buildMessage",
      value: function() {
        this.message = this.requests.map((function(request) {
          return request.name === request.value ? "Missing localization: " + request.name : `Missing localization: (${request.name}) ${request.value}`;
        })).join("\n");
      }
    }, {
      key: "add",
      value: function(name, value) {
        for (var i = 0; i < this.requests.length; i++) if (this.requests[i].name === name) return;
        this.requests.push({
          name: name,
          value: value
        }), this._buildMessage();
      }
    } ]), MissingLocalizationError;
  }();
  exports.default = MissingLocalizationError;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.default = function(localization, nested) {
    return function(key) {
      return nested ? function(object, string) {
        for (var keysArray = string.replace(/^\./, "").split("."), i = 0, length = keysArray.length; i < length; ++i) {
          var key = keysArray[i];
          if (!(key in object)) return;
          object = object[key];
        }
        return object;
      }(localization, key) : localization[key];
    };
  };
}, function(module, exports) {
  module.exports = require("./copy-plugin");
}, function(module, exports, __webpack_require__) {
  "use strict";
  const {ReplaceSource: ReplaceSource} = __webpack_require__(0), validateOptions = __webpack_require__(8), schema = {
    type: "array",
    minItems: 1,
    items: {
      type: "object",
      additionalProperties: !1,
      properties: {
        search: {
          anyOf: [ {
            type: "string",
            minLength: 1
          }, {
            instanceof: "RegExp"
          } ]
        },
        replace: {
          type: "string"
        },
        test: {
          instanceof: "RegExp"
        }
      },
      required: [ "search", "replace" ]
    }
  }, searchReplacements = (str, patterns) => {
    const indices = [];
    return patterns.forEach(({search: search, replace: replace}) => {
      if ("string" == typeof search) {
        const i = str.indexOf(search);
        i >= 0 && indices.push({
          start: i,
          end: i + search.length - 1,
          replace: replace
        });
      } else {
        const re = new RegExp(search.source, search.flags);
        str.replace(search, (m, ...args) => {
          "object" == typeof args.pop() && args.pop();
          const k = args.pop();
          return indices.push({
            start: k,
            end: k + m.length - 1,
            replace: m.replace(re, replace)
          }), "";
        });
      }
    }), indices;
  };
  module.exports = class {
    constructor(options) {
      this.options = Array.isArray(options) ? options : [ options ], validateOptions(schema, this.options, "ReplaceCode Plugin");
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("ReplaceCodePlugin", compilation => {
        compilation.hooks.optimizeChunkAssets.tap("ReplaceCodePlugin", chunks => {
          for (const chunk of chunks) for (const file of chunk.files) {
            const filtered = options.filter(({test: test}) => !test || test.test(file));
            if (!filtered.length) continue;
            const patterns = filtered.map(({search: search, replace: replace}) => ({
              search: search,
              replace: replace
            }));
            compilation.updateAsset(file, old => {
              const indices = searchReplacements(old.source(), patterns), source = new ReplaceSource(old);
              return indices.forEach(({start: start, end: end, replace: replace}) => source.replace(start, end, replace)), 
              source;
            });
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(449);
  class IgnoringWatchFileSystem {
    constructor(wfs, paths) {
      this.wfs = wfs, this.paths = paths;
    }
    watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
      const ignored = path => this.paths.some(p => p instanceof RegExp ? p.test(path) : 0 === path.indexOf(p)), notIgnored = path => !ignored(path), ignoredFiles = files.filter(ignored), ignoredDirs = dirs.filter(ignored), watcher = this.wfs.watch(files.filter(notIgnored), dirs.filter(notIgnored), missing, startTime, options, (err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps, removedFiles) => {
        if (err) return callback(err);
        for (const path of ignoredFiles) fileTimestamps.set(path, 1);
        for (const path of ignoredDirs) dirTimestamps.set(path, 1);
        callback(err, filesModified, dirsModified, missingModified, fileTimestamps, dirTimestamps, removedFiles);
      }, callbackUndelayed);
      return {
        close: () => watcher.close(),
        pause: () => watcher.pause(),
        getContextTimestamps: () => {
          const dirTimestamps = watcher.getContextTimestamps();
          for (const path of ignoredDirs) dirTimestamps.set(path, 1);
          return dirTimestamps;
        },
        getFileTimestamps: () => {
          const fileTimestamps = watcher.getFileTimestamps();
          for (const path of ignoredFiles) fileTimestamps.set(path, 1);
          return fileTimestamps;
        }
      };
    }
  }
  module.exports = class {
    constructor(paths) {
      validateOptions(schema, paths, "Watch Ignore Plugin"), this.paths = paths;
    }
    apply(compiler) {
      compiler.hooks.afterEnvironment.tap("WatchIgnorePlugin", () => {
        compiler.watchFileSystem = new IgnoringWatchFileSystem(compiler.watchFileSystem, this.paths);
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"WatchIgnorePluginOptions","description":"A list of RegExps or absolute paths to directories or files that should be ignored","type":"array","items":{"description":"RegExp or absolute path to directories or files that should be ignored","oneOf":[{"type":"string"},{"instanceof":"RegExp","tsType":"RegExp"}]},"minItems":1}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(options) {
      if (void 0 !== options && "object" != typeof options || Array.isArray(options)) throw new Error("Argument should be an options object. To use defaults, pass in nothing.\nFor more info on options, see https://webpack.js.org/plugins/");
      this.options = options || {};
    }
    apply(compiler) {
      const minSizeReduce = this.options.minSizeReduce || 1.5;
      compiler.hooks.thisCompilation.tap("AggressiveMergingPlugin", compilation => {
        compilation.hooks.optimizeChunksAdvanced.tap("AggressiveMergingPlugin", chunks => {
          let combinations = [];
          chunks.forEach((a, idx) => {
            if (!a.canBeInitial()) for (let i = 0; i < idx; i++) {
              const b = chunks[i];
              b.canBeInitial() || combinations.push({
                a: a,
                b: b,
                improvement: void 0
              });
            }
          });
          for (const pair of combinations) {
            const a = pair.b.size({
              chunkOverhead: 0
            }), b = pair.a.size({
              chunkOverhead: 0
            }), ab = pair.b.integratedSize(pair.a, {
              chunkOverhead: 0
            });
            let newSize;
            if (!1 === ab) return void (pair.improvement = !1);
            newSize = ab, pair.improvement = (a + b) / newSize;
          }
          combinations = combinations.filter(pair => !1 !== pair.improvement), combinations.sort((a, b) => b.improvement - a.improvement);
          const pair = combinations[0];
          if (pair && !(pair.improvement < minSizeReduce)) return pair.b.integrate(pair.a, "aggressive-merge") ? (chunks.splice(chunks.indexOf(pair.a), 1), 
          !0) : void 0;
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const identifierUtils = __webpack_require__(14), {intersect: intersect} = __webpack_require__(37), validateOptions = __webpack_require__(8), schema = __webpack_require__(452), moveModuleBetween = (oldChunk, newChunk) => module => {
    oldChunk.moveModule(module, newChunk);
  }, isNotAEntryModule = entryModule => module => entryModule !== module;
  module.exports = class {
    constructor(options) {
      options || (options = {}), validateOptions(schema, options, "Aggressive Splitting Plugin"), 
      this.options = options, "number" != typeof this.options.minSize && (this.options.minSize = 30720), 
      "number" != typeof this.options.maxSize && (this.options.maxSize = 51200), "number" != typeof this.options.chunkOverhead && (this.options.chunkOverhead = 0), 
      "number" != typeof this.options.entryChunkMultiplicator && (this.options.entryChunkMultiplicator = 1);
    }
    apply(compiler) {
      compiler.hooks.thisCompilation.tap("AggressiveSplittingPlugin", compilation => {
        let newSplits, fromAggressiveSplittingSet, chunkSplitDataMap, needAdditionalSeal = !1;
        compilation.hooks.optimize.tap("AggressiveSplittingPlugin", () => {
          newSplits = [], fromAggressiveSplittingSet = new Set, chunkSplitDataMap = new Map;
        }), compilation.hooks.optimizeChunksAdvanced.tap("AggressiveSplittingPlugin", chunks => {
          const nameToModuleMap = new Map, moduleToNameMap = new Map;
          for (const m of compilation.modules) {
            const name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);
            nameToModuleMap.set(name, m), moduleToNameMap.set(m, name);
          }
          const usedIds = new Set;
          for (const chunk of chunks) usedIds.add(chunk.id);
          const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [], usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits, minSize = this.options.minSize, maxSize = this.options.maxSize, applySplit = splitData => {
            if (void 0 !== splitData.id && usedIds.has(splitData.id)) return !1;
            const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name));
            if (!selectedModules.every(Boolean)) return !1;
            if (selectedModules.reduce((sum, m) => sum + m.size(), 0) !== splitData.size) return !1;
            const selectedChunks = intersect(selectedModules.map(m => new Set(m.chunksIterable)));
            if (0 === selectedChunks.size) return !1;
            if (1 === selectedChunks.size && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {
              const chunk = Array.from(selectedChunks)[0];
              return !fromAggressiveSplittingSet.has(chunk) && (fromAggressiveSplittingSet.add(chunk), 
              chunkSplitDataMap.set(chunk, splitData), !0);
            }
            const newChunk = compilation.addChunk();
            newChunk.chunkReason = "aggressive splitted";
            for (const chunk of selectedChunks) selectedModules.forEach(moveModuleBetween(chunk, newChunk)), 
            chunk.split(newChunk), chunk.name = null;
            return fromAggressiveSplittingSet.add(newChunk), chunkSplitDataMap.set(newChunk, splitData), 
            null !== splitData.id && void 0 !== splitData.id && (newChunk.id = splitData.id), 
            !0;
          };
          let changed = !1;
          for (let j = 0; j < usedSplits.length; j++) {
            applySplit(usedSplits[j]) && (changed = !0);
          }
          const sortedChunks = chunks.slice().sort((a, b) => {
            const diff1 = b.modulesSize() - a.modulesSize();
            if (diff1) return diff1;
            const diff2 = a.getNumberOfModules() - b.getNumberOfModules();
            if (diff2) return diff2;
            const modulesA = Array.from(a.modulesIterable), modulesB = Array.from(b.modulesIterable);
            modulesA.sort(), modulesB.sort();
            const aI = modulesA[Symbol.iterator](), bI = modulesB[Symbol.iterator]();
            for (;;) {
              const aItem = aI.next(), bItem = bI.next();
              if (aItem.done) return 0;
              const aModuleIdentifier = aItem.value.identifier(), bModuleIdentifier = bItem.value.identifier();
              if (aModuleIdentifier > bModuleIdentifier) return -1;
              if (aModuleIdentifier < bModuleIdentifier) return 1;
            }
          });
          for (const chunk of sortedChunks) {
            if (fromAggressiveSplittingSet.has(chunk)) continue;
            if (chunk.modulesSize() > maxSize && chunk.getNumberOfModules() > 1) {
              const modules = chunk.getModules().filter(isNotAEntryModule(chunk.entryModule)).sort((a, b) => (a = a.identifier()) > (b = b.identifier()) ? 1 : a < b ? -1 : 0), selectedModules = [];
              let selectedModulesSize = 0;
              for (let k = 0; k < modules.length; k++) {
                const module = modules[k], newSize = selectedModulesSize + module.size();
                if (newSize > maxSize && selectedModulesSize >= minSize) break;
                selectedModulesSize = newSize, selectedModules.push(module);
              }
              if (0 === selectedModules.length) continue;
              const splitData = {
                modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),
                size: selectedModulesSize
              };
              applySplit(splitData) && (newSplits = (newSplits || []).concat(splitData), changed = !0);
            }
          }
          if (changed) return !0;
        }), compilation.hooks.recordHash.tap("AggressiveSplittingPlugin", records => {
          const allSplits = new Set, invalidSplits = new Set;
          for (const chunk of compilation.chunks) {
            const splitData = chunkSplitDataMap.get(chunk);
            void 0 !== splitData && splitData.hash && chunk.hash !== splitData.hash && invalidSplits.add(splitData);
          }
          if (invalidSplits.size > 0) records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData)), 
          needAdditionalSeal = !0; else {
            for (const chunk of compilation.chunks) {
              const splitData = chunkSplitDataMap.get(chunk);
              void 0 !== splitData && (splitData.hash = chunk.hash, splitData.id = chunk.id, allSplits.add(splitData), 
              chunk.recorded = !0);
            }
            const recordedSplits = compilation.records && compilation.records.aggressiveSplits;
            if (recordedSplits) for (const splitData of recordedSplits) invalidSplits.has(splitData) || allSplits.add(splitData);
            records.aggressiveSplits = Array.from(allSplits), needAdditionalSeal = !1;
          }
        }), compilation.hooks.needAdditionalSeal.tap("AggressiveSplittingPlugin", () => {
          if (needAdditionalSeal) return needAdditionalSeal = !1, !0;
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"AggressiveSplittingPluginOptions","type":"object","additionalProperties":false,"properties":{"chunkOverhead":{"description":"Default: 0","type":"number"},"entryChunkMultiplicator":{"description":"Default: 1","type":"number"},"maxSize":{"description":"Byte, maxsize of per file. Default: 51200","type":"number"},"minSize":{"description":"Byte, split point. Default: 30720","type":"number"}}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const sortByIndex = (a, b) => a.index - b.index, sortByIndex2 = (a, b) => a.index2 - b.index2;
  module.exports = class {
    constructor(options) {
      this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("ChunkModuleIdRangePlugin", compilation => {
        compilation.hooks.moduleIds.tap("ChunkModuleIdRangePlugin", modules => {
          const chunk = compilation.chunks.find(chunk => chunk.name === options.name);
          if (!chunk) throw new Error(`ChunkModuleIdRangePlugin: Chunk with name '${options.name}"' was not found`);
          let chunkModules;
          if (options.order) switch (chunkModules = Array.from(chunk.modulesIterable), options.order) {
           case "index":
            chunkModules.sort(sortByIndex);
            break;

           case "index2":
            chunkModules.sort(sortByIndex2);
            break;

           default:
            throw new Error("ChunkModuleIdRangePlugin: unexpected value of order");
          } else chunkModules = modules.filter(m => m.chunksIterable.has(chunk));
          let currentId = options.start || 0;
          for (let i = 0; i < chunkModules.length; i++) {
            const m = chunkModules[i];
            if (null === m.id && (m.id = currentId++), options.end && currentId > options.end) break;
          }
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(455), LazyBucketSortedSet = __webpack_require__(456), addToSetMap = (map, key, value) => {
    const set = map.get(key);
    void 0 === set ? map.set(key, new Set([ value ])) : set.add(value);
  };
  module.exports = class {
    constructor(options) {
      options || (options = {}), validateOptions(schema, options, "Limit Chunk Count Plugin"), 
      this.options = options;
    }
    apply(compiler) {
      const options = this.options;
      compiler.hooks.compilation.tap("LimitChunkCountPlugin", compilation => {
        compilation.hooks.optimizeChunksAdvanced.tap("LimitChunkCountPlugin", chunks => {
          const maxChunks = options.maxChunks;
          if (!maxChunks) return;
          if (maxChunks < 1) return;
          if (chunks.length <= maxChunks) return;
          let remainingChunksToMerge = chunks.length - maxChunks;
          const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b)), combinations = new LazyBucketSortedSet(c => c.sizeDiff, (a, b) => b - a, c => c.integratedSize, (a, b) => a - b, c => c.bIdx - c.aIdx, (a, b) => a - b, (a, b) => a.bIdx - b.bIdx), combinationsByChunk = new Map;
          orderedChunks.forEach((b, bIdx) => {
            for (let aIdx = 0; aIdx < bIdx; aIdx++) {
              const a = orderedChunks[aIdx], integratedSize = a.integratedSize(b, options);
              if (!1 === integratedSize) continue;
              const aSize = a.size(options), bSize = b.size(options), c = {
                deleted: !1,
                sizeDiff: aSize + bSize - integratedSize,
                integratedSize: integratedSize,
                a: a,
                b: b,
                aIdx: aIdx,
                bIdx: bIdx,
                aSize: aSize,
                bSize: bSize
              };
              combinations.add(c), addToSetMap(combinationsByChunk, a, c), addToSetMap(combinationsByChunk, b, c);
            }
            return combinations;
          });
          const modifiedChunks = new Set;
          let changed = !1;
          loop: for (;;) {
            const combination = combinations.popFirst();
            if (void 0 === combination) break;
            combination.deleted = !0;
            const {a: a, b: b, integratedSize: integratedSize} = combination;
            if (modifiedChunks.size > 0) {
              const queue = new Set(a.groupsIterable);
              for (const group of b.groupsIterable) queue.add(group);
              for (const group of queue) {
                for (const mChunk of modifiedChunks) if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {
                  if (remainingChunksToMerge--, remainingChunksToMerge <= 0) break loop;
                  modifiedChunks.add(a), modifiedChunks.add(b);
                  continue loop;
                }
                for (const parent of group.parentsIterable) queue.add(parent);
              }
            }
            if (a.integrate(b, "limit")) {
              if (chunks.splice(chunks.indexOf(b), 1), modifiedChunks.add(a), changed = !0, remainingChunksToMerge--, 
              remainingChunksToMerge <= 0) break;
              for (const combination of combinationsByChunk.get(b)) combination.deleted || (combination.deleted = !0, 
              combinations.delete(combination));
              for (const combination of combinationsByChunk.get(a)) if (!combination.deleted) if (combination.a === a) {
                const newIntegratedSize = a.integratedSize(combination.b, options);
                if (!1 === newIntegratedSize) {
                  combination.deleted = !0, combinations.delete(combination);
                  continue;
                }
                const finishUpdate = combinations.startUpdate(combination);
                combination.integratedSize = newIntegratedSize, combination.aSize = integratedSize, 
                combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize, finishUpdate();
              } else if (combination.b === a) {
                const newIntegratedSize = combination.a.integratedSize(a, options);
                if (!1 === newIntegratedSize) {
                  combination.deleted = !0, combinations.delete(combination);
                  continue;
                }
                const finishUpdate = combinations.startUpdate(combination);
                combination.integratedSize = newIntegratedSize, combination.bSize = integratedSize, 
                combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize, finishUpdate();
              }
            }
          }
          return !!changed || void 0;
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"LimitChunkCountPluginOptions","type":"object","additionalProperties":false,"properties":{"maxChunks":{"description":"Limit the maximum number of chunks using a value greater greater than or equal to 1","type":"number","minimum":1},"minChunkSize":{"description":"Set a minimum chunk size","type":"number"}}}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  const SortableSet = __webpack_require__(23);
  class LazyBucketSortedSet {
    constructor(getKey, comparator, ...args) {
      this._getKey = getKey, this._innerArgs = args, this._leaf = args.length <= 1, this._keys = new SortableSet(void 0, comparator), 
      this._map = new Map, this._unsortedItems = new Set, this.size = 0;
    }
    add(item) {
      this.size++, this._unsortedItems.add(item);
    }
    _addInternal(key, item) {
      let entry = this._map.get(key);
      void 0 === entry && (entry = this._leaf ? new SortableSet(void 0, this._innerArgs[0]) : new LazyBucketSortedSet(...this._innerArgs), 
      this._keys.add(key), this._map.set(key, entry)), entry.add(item);
    }
    delete(item) {
      if (this.size--, this._unsortedItems.has(item)) return void this._unsortedItems.delete(item);
      const key = this._getKey(item), entry = this._map.get(key);
      entry.delete(item), 0 === entry.size && this._deleteKey(key);
    }
    _deleteKey(key) {
      this._keys.delete(key), this._map.delete(key);
    }
    popFirst() {
      if (0 === this.size) return;
      if (this.size--, this._unsortedItems.size > 0) {
        for (const item of this._unsortedItems) {
          const key = this._getKey(item);
          this._addInternal(key, item);
        }
        this._unsortedItems.clear();
      }
      this._keys.sort();
      const key = this._keys.values().next().value, entry = this._map.get(key);
      if (this._leaf) {
        const leafEntry = entry;
        leafEntry.sort();
        const item = leafEntry.values().next().value;
        return leafEntry.delete(item), 0 === leafEntry.size && this._deleteKey(key), item;
      }
      {
        const nodeEntry = entry, item = nodeEntry.popFirst();
        return 0 === nodeEntry.size && this._deleteKey(key), item;
      }
    }
    startUpdate(item) {
      if (this._unsortedItems.has(item)) return remove => {
        if (remove) return this._unsortedItems.delete(item), void this.size--;
      };
      const key = this._getKey(item);
      if (this._leaf) {
        const oldEntry = this._map.get(key);
        return remove => {
          if (remove) return this.size--, oldEntry.delete(item), void (0 === oldEntry.size && this._deleteKey(key));
          const newKey = this._getKey(item);
          key === newKey ? oldEntry.add(item) : (oldEntry.delete(item), 0 === oldEntry.size && this._deleteKey(key), 
          this._addInternal(newKey, item));
        };
      }
      {
        const oldEntry = this._map.get(key), finishUpdate = oldEntry.startUpdate(item);
        return remove => {
          if (remove) return this.size--, finishUpdate(!0), void (0 === oldEntry.size && this._deleteKey(key));
          const newKey = this._getKey(item);
          key === newKey ? finishUpdate() : (finishUpdate(!0), 0 === oldEntry.size && this._deleteKey(key), 
          this._addInternal(newKey, item));
        };
      }
    }
    _appendIterators(iterators) {
      this._unsortedItems.size > 0 && iterators.push(this._unsortedItems[Symbol.iterator]());
      for (const key of this._keys) {
        const entry = this._map.get(key);
        if (this._leaf) {
          const iterator = entry[Symbol.iterator]();
          iterators.push(iterator);
        } else {
          entry._appendIterators(iterators);
        }
      }
    }
    [Symbol.iterator]() {
      const iterators = [];
      this._appendIterators(iterators), iterators.reverse();
      let currentIterator = iterators.pop();
      return {
        next: () => {
          const res = currentIterator.next();
          return res.done ? 0 === iterators.length ? res : (currentIterator = iterators.pop(), 
          currentIterator.next()) : res;
        }
      };
    }
  }
  module.exports = LazyBucketSortedSet;
}, function(module, exports, __webpack_require__) {
  "use strict";
  const validateOptions = __webpack_require__(8), schema = __webpack_require__(458);
  module.exports = class {
    constructor(options) {
      validateOptions(schema, options, "Min Chunk Size Plugin"), this.options = options;
    }
    apply(compiler) {
      const options = this.options, minChunkSize = options.minChunkSize;
      compiler.hooks.compilation.tap("MinChunkSizePlugin", compilation => {
        compilation.hooks.optimizeChunksAdvanced.tap("MinChunkSizePlugin", chunks => {
          const equalOptions = {
            chunkOverhead: 1,
            entryChunkMultiplicator: 1
          }, sortedSizeFilteredExtendedPairCombinations = chunks.reduce((combinations, a, idx) => {
            for (let i = 0; i < idx; i++) {
              const b = chunks[i];
              combinations.push([ b, a ]);
            }
            return combinations;
          }, []).filter(pair => {
            const p0SmallerThanMinChunkSize = pair[0].size(equalOptions) < minChunkSize, p1SmallerThanMinChunkSize = pair[1].size(equalOptions) < minChunkSize;
            return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;
          }).map(pair => {
            const a = pair[0].size(options), b = pair[1].size(options), ab = pair[0].integratedSize(pair[1], options);
            return [ a + b - ab, ab, pair[0], pair[1] ];
          }).filter(pair => !1 !== pair[1]).sort((a, b) => {
            const diff = b[0] - a[0];
            return 0 !== diff ? diff : a[1] - b[1];
          });
          if (0 === sortedSizeFilteredExtendedPairCombinations.length) return;
          const pair = sortedSizeFilteredExtendedPairCombinations[0];
          return pair[2].integrate(pair[3], "min-size"), chunks.splice(chunks.indexOf(pair[3]), 1), 
          !0;
        });
      });
    }
  };
}, function(module) {
  module.exports = JSON.parse('{"title":"MinChunkSizePluginOptions","type":"object","additionalProperties":false,"properties":{"minChunkSize":{"description":"Minimum number of characters","type":"number"}},"required":["minChunkSize"]}');
}, function(module, exports, __webpack_require__) {
  "use strict";
  module.exports = class {
    constructor(preferEntry) {
      if (void 0 !== preferEntry && "boolean" != typeof preferEntry) throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.js.org/plugins/");
      this.preferEntry = preferEntry;
    }
    apply(compiler) {
      const preferEntry = this.preferEntry;
      compiler.hooks.compilation.tap("OccurrenceOrderPlugin", compilation => {
        compilation.hooks.optimizeModuleOrder.tap("OccurrenceOrderPlugin", modules => {
          const occursInInitialChunksMap = new Map, occursInAllChunksMap = new Map, initialChunkChunkMap = new Map, entryCountMap = new Map;
          for (const m of modules) {
            let initial = 0, entry = 0;
            for (const c of m.chunksIterable) c.canBeInitial() && initial++, c.entryModule === m && entry++;
            initialChunkChunkMap.set(m, initial), entryCountMap.set(m, entry);
          }
          const countOccursInEntry = (sum, r) => r.module ? sum + initialChunkChunkMap.get(r.module) : sum, countOccurs = (sum, r) => {
            if (!r.module) return sum;
            let factor = 1;
            return "function" == typeof r.dependency.getNumberOfIdOccurrences && (factor = r.dependency.getNumberOfIdOccurrences()), 
            0 === factor ? sum : sum + factor * r.module.getNumberOfChunks();
          };
          if (preferEntry) for (const m of modules) {
            const result = m.reasons.reduce(countOccursInEntry, 0) + initialChunkChunkMap.get(m) + entryCountMap.get(m);
            occursInInitialChunksMap.set(m, result);
          }
          const originalOrder = new Map;
          let i = 0;
          for (const m of modules) {
            const result = m.reasons.reduce(countOccurs, 0) + m.getNumberOfChunks() + entryCountMap.get(m);
            occursInAllChunksMap.set(m, result), originalOrder.set(m, i++);
          }
          modules.sort((a, b) => {
            if (preferEntry) {
              const aEntryOccurs = occursInInitialChunksMap.get(a), bEntryOccurs = occursInInitialChunksMap.get(b);
              if (aEntryOccurs > bEntryOccurs) return -1;
              if (aEntryOccurs < bEntryOccurs) return 1;
            }
            const aOccurs = occursInAllChunksMap.get(a), bOccurs = occursInAllChunksMap.get(b);
            if (aOccurs > bOccurs) return -1;
            if (aOccurs < bOccurs) return 1;
            return originalOrder.get(a) - originalOrder.get(b);
          });
        }), compilation.hooks.optimizeChunkOrder.tap("OccurrenceOrderPlugin", chunks => {
          const occursInInitialChunksMap = new Map, originalOrder = new Map;
          let i = 0;
          for (const c of chunks) {
            let occurs = 0;
            for (const chunkGroup of c.groupsIterable) for (const parent of chunkGroup.parentsIterable) parent.isInitial() && occurs++;
            occursInInitialChunksMap.set(c, occurs), originalOrder.set(c, i++);
          }
          chunks.sort((a, b) => {
            const aEntryOccurs = occursInInitialChunksMap.get(a), bEntryOccurs = occursInInitialChunksMap.get(b);
            if (aEntryOccurs > bEntryOccurs) return -1;
            if (aEntryOccurs < bEntryOccurs) return 1;
            const aOccurs = a.getNumberOfGroups(), bOccurs = b.getNumberOfGroups();
            if (aOccurs > bOccurs) return -1;
            if (aOccurs < bOccurs) return 1;
            return originalOrder.get(a) - originalOrder.get(b);
          });
        });
      });
    }
  };
}, function(module, exports, __webpack_require__) {
  const fs = __webpack_require__(20), path = __webpack_require__(3), mkdirp = __webpack_require__(113), {Tracer: Tracer} = __webpack_require__(461), validateOptions = __webpack_require__(8), schema = __webpack_require__(462);
  let inspector = void 0;
  try {
    inspector = __webpack_require__(463);
  } catch (e) {
    console.log("Unable to CPU profile in < node 8.0");
  }
  class Profiler {
    constructor(inspector) {
      this.session = void 0, this.inspector = inspector;
    }
    hasSession() {
      return void 0 !== this.session;
    }
    startProfiling() {
      if (void 0 === this.inspector) return Promise.resolve();
      try {
        this.session = new inspector.Session, this.session.connect();
      } catch (_) {
        return this.session = void 0, Promise.resolve();
      }
      return Promise.all([ this.sendCommand("Profiler.setSamplingInterval", {
        interval: 100
      }), this.sendCommand("Profiler.enable"), this.sendCommand("Profiler.start") ]);
    }
    sendCommand(method, params) {
      return this.hasSession() ? new Promise((res, rej) => this.session.post(method, params, (err, params) => {
        null !== err ? rej(err) : res(params);
      })) : Promise.resolve();
    }
    destroy() {
      return this.hasSession() && this.session.disconnect(), Promise.resolve();
    }
    stopProfiling() {
      return this.sendCommand("Profiler.stop");
    }
  }
  const interceptTemplateInstancesFrom = (compilation, tracer) => {
    const {mainTemplate: mainTemplate, chunkTemplate: chunkTemplate, hotUpdateChunkTemplate: hotUpdateChunkTemplate, moduleTemplates: moduleTemplates} = compilation, {javascript: javascript, webassembly: webassembly} = moduleTemplates;
    [ {
      instance: mainTemplate,
      name: "MainTemplate"
    }, {
      instance: chunkTemplate,
      name: "ChunkTemplate"
    }, {
      instance: hotUpdateChunkTemplate,
      name: "HotUpdateChunkTemplate"
    }, {
      instance: javascript,
      name: "JavaScriptModuleTemplate"
    }, {
      instance: webassembly,
      name: "WebAssemblyModuleTemplate"
    } ].forEach(templateObject => {
      Object.keys(templateObject.instance.hooks).forEach(hookName => {
        templateObject.instance.hooks[hookName].intercept(makeInterceptorFor(templateObject.name, tracer)(hookName));
      });
    });
  }, interceptAllHooksFor = (instance, tracer, logLabel) => {
    Reflect.has(instance, "hooks") && Object.keys(instance.hooks).forEach(hookName => {
      instance.hooks[hookName].intercept(makeInterceptorFor(logLabel, tracer)(hookName));
    });
  }, interceptAllParserHooks = (moduleFactory, tracer) => {
    [ "javascript/auto", "javascript/dynamic", "javascript/esm", "json", "webassembly/experimental" ].forEach(moduleType => {
      moduleFactory.hooks.parser.for(moduleType).tap("ProfilingPlugin", (parser, parserOpts) => {
        interceptAllHooksFor(parser, tracer, "Parser");
      });
    });
  }, makeInterceptorFor = (instance, tracer) => hookName => ({
    register: ({name: name, type: type, context: context, fn: fn}) => ({
      name: name,
      type: type,
      context: context,
      fn: makeNewProfiledTapFn(hookName, tracer, {
        name: name,
        type: type,
        fn: fn
      })
    })
  }), makeNewProfiledTapFn = (hookName, tracer, {name: name, type: type, fn: fn}) => {
    const defaultCategory = [ "blink.user_timing" ];
    switch (type) {
     case "promise":
      return (...args) => {
        const id = ++tracer.counter;
        tracer.trace.begin({
          name: name,
          id: id,
          cat: defaultCategory
        });
        return fn(...args).then(r => (tracer.trace.end({
          name: name,
          id: id,
          cat: defaultCategory
        }), r));
      };

     case "async":
      return (...args) => {
        const id = ++tracer.counter;
        tracer.trace.begin({
          name: name,
          id: id,
          cat: defaultCategory
        });
        const callback = args.pop();
        fn(...args, (...r) => {
          tracer.trace.end({
            name: name,
            id: id,
            cat: defaultCategory
          }), callback(...r);
        });
      };

     case "sync":
      return (...args) => {
        const id = ++tracer.counter;
        if ("ProfilingPlugin" === name) return fn(...args);
        let r;
        tracer.trace.begin({
          name: name,
          id: id,
          cat: defaultCategory
        });
        try {
          r = fn(...args);
        } catch (error) {
          throw tracer.trace.end({
            name: name,
            id: id,
            cat: defaultCategory
          }), error;
        }
        return tracer.trace.end({
          name: name,
          id: id,
          cat: defaultCategory
        }), r;
      };
    }
  };
  module.exports = class {
    constructor(opts) {
      validateOptions(schema, opts || {}, "Profiling plugin"), opts = opts || {}, this.outputPath = opts.outputPath || "events.json";
    }
    apply(compiler) {
      const tracer = (outputPath => {
        const trace = new Tracer({
          noStream: !0
        }), profiler = new Profiler(inspector);
        if (/\/|\\/.test(outputPath)) {
          const dirPath = path.dirname(outputPath);
          mkdirp.sync(dirPath);
        }
        const fsStream = fs.createWriteStream(outputPath);
        let counter = 0;
        return trace.pipe(fsStream), trace.instantEvent({
          name: "TracingStartedInPage",
          id: ++counter,
          cat: [ "disabled-by-default-devtools.timeline" ],
          args: {
            data: {
              sessionId: "-1",
              page: "0xfff",
              frames: [ {
                frame: "0xfff",
                url: "webpack",
                name: ""
              } ]
            }
          }
        }), trace.instantEvent({
          name: "TracingStartedInBrowser",
          id: ++counter,
          cat: [ "disabled-by-default-devtools.timeline" ],
          args: {
            data: {
              sessionId: "-1"
            }
          }
        }), {
          trace: trace,
          counter: 2,
          profiler: profiler,
          end: callback => {
            fsStream.on("finish", () => {
              callback();
            }), trace.push(null);
          }
        };
      })(this.outputPath);
      tracer.profiler.startProfiling(), Object.keys(compiler.hooks).forEach(hookName => {
        compiler.hooks[hookName].intercept(makeInterceptorFor("Compiler", tracer)(hookName));
      }), Object.keys(compiler.resolverFactory.hooks).forEach(hookName => {
        compiler.resolverFactory.hooks[hookName].intercept(makeInterceptorFor("Resolver", tracer)(hookName));
      }), compiler.hooks.compilation.tap("ProfilingPlugin", (compilation, {normalModuleFactory: normalModuleFactory, contextModuleFactory: contextModuleFactory}) => {
        interceptAllHooksFor(compilation, tracer, "Compilation"), interceptAllHooksFor(normalModuleFactory, tracer, "Normal Module Factory"), 
        interceptAllHooksFor(contextModuleFactory, tracer, "Context Module Factory"), interceptAllParserHooks(normalModuleFactory, tracer), 
        interceptTemplateInstancesFrom(compilation, tracer);
      }), compiler.hooks.done.tapAsync({
        name: "ProfilingPlugin",
        stage: 1 / 0
      }, (stats, callback) => {
        tracer.profiler.stopProfiling().then(parsedResults => {
          if (void 0 === parsedResults) return tracer.profiler.destroy(), tracer.trace.flush(), 
          void tracer.end(callback);
          const cpuStartTime = parsedResults.profile.startTime, cpuEndTime = parsedResults.profile.endTime;
          tracer.trace.completeEvent({
            name: "TaskQueueManager::ProcessTaskFromWorkQueue",
            id: ++tracer.counter,
            cat: [ "toplevel" ],
            ts: cpuStartTime,
            args: {
              src_file: "../../ipc/ipc_moji_bootstrap.cc",
              src_func: "Accept"
            }
          }), tracer.trace.completeEvent({
            name: "EvaluateScript",
            id: ++tracer.counter,
            cat: [ "devtools.timeline" ],
            ts: cpuStartTime,
            dur: cpuEndTime - cpuStartTime,
            args: {
              data: {
                url: "webpack",
                lineNumber: 1,
                columnNumber: 1,
                frame: "0xFFF"
              }
            }
          }), tracer.trace.instantEvent({
            name: "CpuProfile",
            id: ++tracer.counter,
            cat: [ "disabled-by-default-devtools.timeline" ],
            ts: cpuEndTime,
            args: {
              data: {
                cpuProfile: parsedResults.profile
              }
            }
          }), tracer.profiler.destroy(), tracer.trace.flush(), tracer.end(callback);
        });
      });
    }
  }, module.exports.Profiler = Profiler;
}, function(module, exports, __webpack_require__) {
  "use strict";
  Object.defineProperty(exports, "__esModule", {
    value: !0
  }), exports.Tracer = void 0;
  const stream_1 = __webpack_require__(107);
  class Tracer extends stream_1.Readable {
    constructor(opts = {}) {
      if (super(), this.noStream = !1, this.events = [], "object" != typeof opts) throw new Error("Invalid options passed (must be an object)");
      if (null != opts.parent && "object" != typeof opts.parent) throw new Error("Invalid option (parent) passed (must be an object)");
      if (null != opts.fields && "object" != typeof opts.fields) throw new Error("Invalid option (fields) passed (must be an object)");
      if (null != opts.objectMode && !0 !== opts.objectMode && !1 !== opts.objectMode) throw new Error("Invalid option (objectsMode) passed (must be a boolean)");
      if (this.noStream = opts.noStream || !1, this.parent = opts.parent, this.parent ? this.fields = Object.assign({}, opts.parent && opts.parent.fields) : this.fields = {}, 
      opts.fields && Object.assign(this.fields, opts.fields), this.fields.cat ? Array.isArray(this.fields.cat) && (this.fields.cat = this.fields.cat.join(",")) : this.fields.cat = "default", 
      this.fields.args || (this.fields.args = {}), this.parent) this._push = this.parent._push.bind(this.parent); else {
        this._objectMode = Boolean(opts.objectMode);
        var streamOpts = {
          objectMode: this._objectMode
        };
        this._objectMode ? this._push = this.push : (this._push = this._pushString, streamOpts.encoding = "utf8"), 
        stream_1.Readable.call(this, streamOpts);
      }
    }
    flush() {
      if (!0 === this.noStream) {
        for (const evt of this.events) this._push(evt);
        this._flush();
      }
    }
    _read(_) {}
    _pushString(ev) {
      var separator = "";
      this.firstPush ? separator = ",\n" : (this.push("["), this.firstPush = !0), this.push(separator + JSON.stringify(ev), "utf8");
    }
    _flush() {
      this._objectMode || this.push("]");
    }
    child(fields) {
      return new Tracer({
        parent: this,
        fields: fields
      });
    }
    begin(fields) {
      return this.mkEventFunc("b")(fields);
    }
    end(fields) {
      return this.mkEventFunc("e")(fields);
    }
    completeEvent(fields) {
      return this.mkEventFunc("X")(fields);
    }
    instantEvent(fields) {
      return this.mkEventFunc("I")(fields);
    }
    mkEventFunc(ph) {
      return fields => {
        var hrtime, ev = {
          ts: 1e6 * (hrtime = process.hrtime())[0] + Math.round(hrtime[1] / 1e3),
          pid: process.pid,
          tid: process.pid
        };
        if (ev.ph = ph, fields) if ("string" == typeof fields) ev.name = fields; else for (const k of Object.keys(fields)) "cat" === k ? ev.cat = fields.cat.join(",") : ev[k] = fields[k];
        this.noStream ? this.events.push(ev) : this._push(ev);
      };
    }
  }
  exports.Tracer = Tracer;
}, function(module) {
  module.exports = JSON.parse('{"title":"ProfilingPluginOptions","type":"object","additionalProperties":false,"properties":{"outputPath":{"description":"Path to the output file e.g. `profiling/events.json`. Defaults to `events.json`.","type":"string","absolutePath":false,"minLength":4}}}');
}, function(module, exports) {
  module.exports = require("inspector");
} ]);